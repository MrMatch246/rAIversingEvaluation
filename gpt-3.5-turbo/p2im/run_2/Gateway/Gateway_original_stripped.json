{
    "functions": {
        "FUN_08007246": {
            "renaming": {
                "FUN_08007246": "incrementSystemTick_08007246"
            },
            "code": "void incrementSystemTick_08007246(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007246",
            "calling": [],
            "imported": false,
            "current_name": "incrementSystemTick_08007246"
        },
        "FUN_0800a042": {
            "renaming": {
                "FUN_0800a042": "write_data_to_file_0800a042",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "param_3": "buffer",
                "param_4": "size",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void write_data_to_file_0800a042(int file_descriptor,int buffer_address,void* buffer,size_t size)\n{\n  int offset = *(short *)(buffer_address + 0xe);\n  uint16_t* data = (uint16_t*)(buffer_address + 0xc);\n  if ((int)((uint)*data << 0x17) < 0) {\n    _lseek_r(file_descriptor,offset,0,SEEK_END);\n  }\n  *data &= 0xefff;\n  _write_r(file_descriptor,offset,buffer,size);\n  return;\n}",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a042",
            "calling": [],
            "imported": false,
            "current_name": "write_data_to_file_0800a042"
        },
        "FUN_08008e4e": {
            "renaming": {
                "__thiscall Print::FUN_08008e4e": "Print::printBuffer",
                "this": "printObj",
                "buffer": "buffer",
                "size": "size",
                "pPVar1": "pPrintObj",
                "sVar2": "bytesPrinted",
                "FUN_08008e4e": "printBuffer_08008e4e"
            },
            "code": "size_t Print::printBuffer_08008e4e(Print *printObj, uint8_t *buffer, size_t size){\n    Print *pPrintObj = printObj;\n    size_t bytesPrinted = 0;\n    \n    while(size > 0){\n        pPrintObj = (Print *)(**printObj->_vptr_Print)(pPrintObj, (uint)*buffer);\n        if(pPrintObj == (Print *)0x0){\n            break;\n        }\n        bytesPrinted++;\n        buffer++;\n        size--;\n    }\n    return bytesPrinted;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e4e",
            "calling": [],
            "imported": false,
            "current_name": "printBuffer_08008e4e"
        },
        "FUN_08008694": {
            "renaming": {
                "FUN_08008694": "initialize_serial_port_08008694",
                "obj": "serial_port",
                "callback": "transmit_callback",
                "bVar1": "port_index",
                "PTR_tx_callback_080086dc": "tx_callbacks",
                "PTR_tx_callback_obj_080086e0": "tx_callback_objs",
                "PTR_uart_handlers_080086e4": "uart_handlers",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "HAL_NVIC_EnableIRQ": "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT": "HAL_UART_Transmit_IT"
            },
            "code": "void initialize_serial_port_08008694(serial_t *serial_port, _func_int_serial_t_ptr *transmit_callback) {\n  if (serial_port != NULL) {\n    uint8_t port_index = serial_port->index;\n    _func_int_serial_t_ptr **tx_callback_ptr = &PTR_tx_callback_080086dc[port_index];\n    serial_t **tx_callback_obj_ptr = &PTR_tx_callback_obj_080086e0[port_index];\n    HAL_NVIC_SetPriority(serial_port->irq, 0, 2);\n    HAL_NVIC_EnableIRQ(serial_port->irq);\n    UART_HandleTypeDef **uart_handler_ptr = &PTR_uart_handlers_080086e4[port_index];\n    HAL_UART_Transmit_IT(*uart_handler_ptr, serial_port->tx_buff + serial_port->tx_tail, 1);\n    *tx_callback_ptr = transmit_callback;\n    *tx_callback_obj_ptr = serial_port;\n  }\n}",
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008694",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "initialize_serial_port_08008694"
        },
        "FUN_08002ce0": {
            "renaming": {
                "FUN_08002ce0::FUN_08002ce0": "firmata::initialize_parser::initialize_parser",
                "this": "firmata_instance",
                "this_00": "firmata_parser",
                "marshaller": "firmata_instance->marshaller",
                "parser": "firmata_instance->parser",
                "parserBuffer": "firmata_instance->parserBuffer",
                "firmwareVersionCount": "firmata_instance->firmwareVersionCount",
                "firmwareVersionVector": "firmata_instance->firmwareVersionVector",
                "blinkVersionDisabled": "firmata_instance->blinkVersionDisabled",
                "FUN_08002ce0": "initialize_parser_08002ce0"
            },
            "code": "initialize_parser_08002ce0 * __thiscall firmata::initialize_parser_08002ce0::initialize_parser_08002ce0(initialize_parser_08002ce0 *firmata_instance) {\\n  FirmataParser *firmata_parser;\\n  FirmataMarshaller::FirmataMarshaller(&firmata_instance->marshaller);\\n  firmata_parser = &firmata_instance->parser;\\n  FirmataParser::FirmataParser(firmata_parser,firmata_instance->parserBuffer,0x40);\\n  firmata_instance->firmwareVersionCount = \"\\0\";\\n  firmata_instance->firmwareVersionVector = (byte *)0x0;\\n  firmata_instance->blinkVersionDisabled = false;\\n  FirmataParser::attach(firmata_parser,0xe0,PTR_DAT_08002d90,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,0x90,PTR_DAT_08002d94,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,0xc0,PTR_DAT_08002d98,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,0xd0,PTR_DAT_08002d9c,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,0xf4,PTR_DAT_08002da0,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,0xf5,PTR_DAT_08002da4,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,\"q\",PTR_DAT_08002da8,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,0xf0,PTR_DAT_08002dac,(void *)0x0);\\n  FirmataParser::attach(firmata_parser,\"y\",PTR_DAT_08002db0,firmata_instance);\\n  FirmataParser::attach(firmata_parser,0xf9,PTR_DAT_08002db4,firmata_instance);\\n  FirmataParser::attach(firmata_parser,0xff,PTR_DAT_08002db8,(void *)0x0);\\n  return firmata_instance;\\n}",
            "called": [
                "attach",
                "attach",
                "FirmataMarshaller",
                "attach",
                "FirmataParser",
                "attach",
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ce0",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_parser_08002ce0"
        },
        "FUN_08005188": {
            "renaming": {
                "FUN_08005188": "i2c_handle_08005188",
                "hi2c": "handle",
                "pIVar1": "instance",
                "uVar2": "sr1",
                "uVar3": "cr2",
                "uVar4": "sr2"
            },
            "code": "void i2c_handle_08005188(I2C_HandleTypeDef_conflict *handle)\n{\n  I2C_TypeDef_conflict *instance = handle->Instance;\n  uint32_t sr2 = instance->SR2;\n  uint32_t sr1 = instance->SR1;\n  uint32_t cr2 = instance->CR2;\n  if ((handle->Mode == HAL_I2C_MODE_MASTER) || (handle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((sr1 & 0x10001) == 0) || ((cr2 & 0x200) == 0)) {\n      if (((0x08 & sr1) == 0) || ((cr2 & 0x200) == 0)) {\n        if (((0x02 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n          I2C_Master_ADDR(handle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(handle);\n      }\n    }\n    else {\n      I2C_Master_SB(handle);\n    }\n    if ((0x04 & sr2) == 0) {\n      if ((((0x40 & sr1) != 0) && ((cr2 & 0x400) != 0)) && ((0x20 & sr1) == 0)) {\n        I2C_MasterReceive_RXNE(handle);\n        return;\n      }\n      if (((0x20 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(handle);\n        return;\n      }\n    }\n    else {\n      if ((((0x01 & sr1) != 0) && ((cr2 & 0x400) != 0)) && ((0x20 & sr1) == 0)) {\n        I2C_MasterTransmit_TXE(handle);\n        return;\n      }\n      if (((0x20 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((0x02 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(handle);\n      return;\n    }\n    if (((0x10 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(handle);\n      return;\n    }\n    if ((0x04 & sr2) == 0) {\n      if ((((0x40 & sr1) != 0) && ((cr2 & 0x400) != 0)) && ((0x20 & sr1) == 0)) {\n        I2C_SlaveReceive_RXNE(handle);\n        return;\n      }\n      if (((0x20 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(handle);\n      }\n    }\n    else {\n      if ((((0x01 & sr1) != 0) && ((cr2 & 0x400) != 0)) && ((0x20 & sr1) == 0)) {\n        I2C_SlaveTransmit_TXE(handle);\n        return;\n      }\n      if (((0x20 & sr1) != 0) && ((cr2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_SlaveTransmit_BTF",
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_RXNE"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005188",
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_08005188"
        },
        "FUN_08007244": {
            "renaming": {
                "FUN_08007244": "do_nothing_08007244"
            },
            "code": "\nvoid do_nothing_08007244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007244",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08007244"
        },
        "FUN_08001bf8": {
            "renaming": {
                "FUN_08001bf8": "write_data_to_wire_08001bf8",
                "data": "data_to_write"
            },
            "code": "void write_data_to_wire_08001bf8(byte data)\n{\n  TwoWire::write((TwoWire *)PTR_Wire_08001c04,data);\n  return;\n}",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bf8",
            "calling": [
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "write_data_to_wire_08001bf8"
        },
        "FUN_080069ec": {
            "renaming": {
                "FUN_080069ec": "handle_uart_data_080069ec",
                "*huart": "huart",
                "HVar1": "status",
                "uVar2": "cr1",
                "pUVar3": "uart_instance",
                "uVar4": "cr3",
                "uVar5": "sr",
                "UART_Receive_IT": "receive_uart_data",
                "UART_Transmit_IT": "transmit_uart_data",
                "UART_EndTransmit_IT": "end_uart_transmission",
                "HAL_UART_ErrorCallback": "handle_uart_error",
                "huart->ErrorCode": "error_code",
                "UART_EndRxTransfer": "end_uart_receive",
                "huart->hdmarx": "dma_rx_handle",
                "DAT_08006b08": "handle_dma_transfer_abort",
                "HAL_DMA_Abort_IT": "abort_dma_transfer"
            },
            "code": "void handle_uart_data_080069ec(UART_HandleTypeDef *huart) {\n  HAL_StatusTypeDef_conflict status;\n  uint16_t sr;\n  uint16_t cr1;\n  uint16_t cr3;\n  uint8_t error_code = 0;\n  USART_TypeDef *uart_instance = huart->Instance;\n  sr = uart_instance->SR;\n  cr1 = uart_instance->CR1;\n  cr3 = uart_instance->CR3;\n  if ((sr & 0xf) == 0 && (sr & 0x20) && (cr1 & 0x20)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if ((sr & 0xf) == 0 || (cr3 & 1) == 0 && (cr1 & 0x120) == 0) {\n    if ((sr & 0x80) && (cr1 & 0x80)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if ((sr & 0x40) && (cr1 & 0x40)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if ((sr & 1) && (cr1 & 0x100)) {\n      error_code |= 1;\n    }\n    if ((sr & 4) && !(cr3 & 1)) {\n      error_code |= 2;\n    }\n    if ((sr & 2) && !(cr3 & 1)) {\n      error_code |= 4;\n    }\n    if ((sr & 8) && !(cr3 & 1)) {\n      error_code |= 8;\n    }\n    if (error_code) {\n      if ((sr & 0x20) && (cr1 & 0x20)) {\n        UART_Receive_IT(huart);\n      }\n      if (!(error_code & 8) && !(cr3 & 0x40)) {\n        HAL_UART_ErrorCallback(huart);\n        error_code = 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      if (!(cr3 & 0x40)) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      uart_instance->CR3 &= 0xffffffbf;\n      if (huart->hdmarx == NULL) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart->hdmarx->XferAbortCallback = DAT_08006b08;\n      status = HAL_DMA_Abort_IT(huart->hdmarx);\n      if (status != HAL_OK) {\n        (*huart->hdmarx->XferAbortCallback)(huart->hdmarx);\n        return;\n      }\n    }\n  }\n}\n",
            "called": [
                "UART_EndTransmit_IT",
                "HAL_DMA_Abort_IT",
                "UART_EndRxTransfer",
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069ec",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_uart_data_080069ec"
        },
        "FUN_0800a168": {
            "renaming": {
                "FUN_0800a168": "read_file_0800a168",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "error_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_file_0800a168(int *error_code, int file_descriptor, char *buffer, int buffer_size) {\n  undefined *error_ptr;\n  int read_result;\n  \n  error_ptr = PTR_errno_0800a188;\n  *(undefined4 *)PTR_errno_0800a188 = 0;\n  read_result = _read(file_descriptor, buffer, buffer_size);\n  if ((read_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a168",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_file_0800a168"
        },
        "FUN_080067ac": {
            "renaming": {
                "FUN_080067ac": "transmitData_080067ac",
                "*huart": "*uartHandle",
                "pData": "*data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTick",
                "huart->gState": "uartHandle->gState",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "(uint8_t *)0x0": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "huart->Lock": "uartHandle->Lock",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "huart->ErrorCode": "uartHandle->ErrorCode",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_GetTick()": "HAL_GetTick()",
                "huart->TxXferSize": "uartHandle->TxXferSize",
                "huart->TxXferCount": "uartHandle->TxXferCount",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9B",
                "UART_WaitOnFlagUntilTimeout": "UART_WaitOnFlagUntilTimeout",
                "UART_FLAG_TXE": "UART_FLAG_TXE",
                "RESET": "RESET",
                "HAL_OK": "HAL_OK",
                "uartHandle->Instance->DR": "uartHandle->Instance->DR",
                "*(ushort *)pData & 0x1ff": "*(uint16_t *)data & 0x1FF",
                "(uint8_t *)((int)pData + 2)": "data += 2",
                "(uint8_t *)((int)pData + 1)": "data++",
                "(uint32_t)*pData": "(uint32_t)*data",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "UART_FLAG_TC": "UART_FLAG_TC",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIMEOUT": "HAL_TIMEOUT"
            },
            "code": "HAL_StatusTypeDef_conflict transmitData_080067ac(UART_HandleTypeDef *uartHandle, uint8_t *data, uint16_t size, uint32_t timeout)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  \n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  \n  if (data == NULL || size == 0 || uartHandle->Lock == HAL_LOCKED) {\n    return HAL_ERROR;\n  }\n  \n  uartHandle->Lock = HAL_LOCKED;\n  uartHandle->ErrorCode = 0;\n  uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n  startTick = HAL_GetTick();\n  uartHandle->TxXferSize = size;\n  uartHandle->TxXferCount = size;\n  \n  while (uartHandle->TxXferCount != 0) {\n    uartHandle->TxXferCount--;\n    if (uartHandle->Init.WordLength == UART_WORDLENGTH_9B) {\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTick, timeout);\n      if (status != HAL_OK) {\n        return HAL_TIMEOUT;\n      }\n      uartHandle->Instance->DR = *(uint16_t *)data & 0x1FF;\n      if (uartHandle->Init.Parity == UART_PARITY_NONE) {\n        data += 2;\n      }\n      else {\n        data++;\n      }\n    }\n    else {\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTick, timeout);\n      if (status != HAL_OK) {\n        return HAL_TIMEOUT;\n      }\n      uartHandle->Instance->DR = (uint32_t)*data;\n      data++;\n    }\n  }\n  \n  status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TC, RESET, startTick, timeout);\n  if (status == HAL_OK) {\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->Lock = HAL_UNLOCKED;\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  \n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080067ac",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "transmitData_080067ac"
        },
        "FUN_0800735a": {
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "uint32_t find_pin_function_0800735a(PinName_conflict target_pin, PinMap_conflict *pin_map) {\n  while (true) {\n    if (pin_map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (pin_map->pin == target_pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return pin_map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800735a",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800735a"
        },
        "FUN_08008c20": {
            "renaming": {
                "FUN_08008c20": "initializeSerialBuffers_08008c20",
                "this": "serialObject",
                "ctx": "context",
                "_serial": "serialObject",
                "_rx_buffer": "rx_buffer",
                "_tx_buffer": "tx_buffer",
                "rx_buff": "rx_buffer",
                "rx_head": "rx_head",
                "rx_tail": "rx_tail",
                "tx_buff": "tx_buffer",
                "tx_head": "tx_head",
                "tx_tail": "tx_tail"
            },
            "code": "int __thiscall initializeSerialBuffers_08008c20(HardwareSerial *serialObject, EVP_PKEY_CTX *context)\n{\n  serialObject->rx_buffer = serialObject->_rx_buffer;\n  serialObject->rx_head = 0;\n  serialObject->rx_tail = 0;\n  serialObject->tx_buffer = serialObject->_tx_buffer;\n  serialObject->tx_head = 0;\n  serialObject->tx_tail = 0;\n  return (int)serialObject;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c20",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initializeSerialBuffers_08008c20"
        },
        "FUN_0800723c": {
            "renaming": {
                "FUN_0800723c": "get_current_tick_0800723c",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_0800723c(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800723c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_0800723c"
        },
        "FUN_080043a2": {
            "renaming": {
                "FUN_080043a2": "handle_i2c_events_080043a2",
                "hi2c": "i2c_handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_events_080043a2(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint32_t transfer_options = i2c_handle->XferOptions;\n  I2C_TypeDef_conflict *i2c_instance = i2c_handle->Instance;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  if ((i2c_handle->State == HAL_I2C_STATE_BUSY_RX) && ((i2c_handle->EventCount != 0 || (i2c_handle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2c_handle->EventCount == 0) && ((i2c_handle->Init).AddressingMode == 0xc000)) {\n      i2c_instance->CR1 = i2c_instance->CR1 | 0x100;\n      i2c_handle->EventCount = i2c_handle->EventCount + 1;\n    }\n    else {\n      if (i2c_handle->XferCount == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n      }\n      else if (i2c_handle->XferCount == 1) {\n        if (transfer_options == 0xffff0000) {\n          i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n          if ((i2c_instance->CR2 & 0x800) == 0) {\n            i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n          }\n          else {\n            i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((transfer_options == 4) || (transfer_options == 8)) || (i2c_handle->PreviousState == 0x12)) {\n          i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n          i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n        }\n        else if (transfer_options == 2) {\n          i2c_instance->CR1 = i2c_instance->CR1 | 0x400;\n        }\n        else {\n          i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2c_handle->XferCount == 2) {\n        if (transfer_options == 2) {\n          i2c_instance->CR1 = i2c_instance->CR1 | 0x400;\n        }\n        else {\n          i2c_instance->CR1 = i2c_instance->CR1 | 0x800;\n          i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n        }\n        if ((i2c_instance->CR2 & 0x800) != 0) {\n          i2c_instance->CR2 = i2c_instance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x400;\n        if ((i2c_instance->CR2 & 0x800) != 0) {\n          i2c_instance->CR2 = i2c_instance->CR2 | 0x1000;\n        }\n      }\n      i2c_handle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043a2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_events_080043a2"
        },
        "FUN_08006280": {
            "renaming": {
                "FUN_08006280": "configure_timer_channel_08006280",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_channel_08006280(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel) {\n  TIM_TypeDef_conflict *timer_instance = timer_handle->Instance;\n  switch(channel) {\n    case 0:\n      timer_instance->DIER |= 2;\n      break;\n    case 4:\n      timer_instance->DIER |= 4;\n      break;\n    case 8:\n      timer_instance->DIER |= 8;\n      break;\n    case 0xc:\n      timer_instance->DIER |= 0x10;\n  }\n  TIM_CCxChannelCmd(timer_instance, channel, 1);\n  if (timer_instance == PTR_080062f0) {\n    timer_instance->BDTR |= 0x8000;\n  }\n  timer_instance->CR1 |= 1;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006280",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_timer_channel_08006280"
        },
        "FUN_08007258": {
            "renaming": {
                "FUN_08007258": "configure_GPIO_pin_08007258",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "uVar1": "pin_index",
                "GPIOx": "GPIO_port",
                "tmpreg": "unused_tmpreg",
                "GPIO_InitStructure": "GPIO_InitStruct",
                "DAT_080072d0": "unused_DAT_080072d0",
                "DAT_080072d4": "unused_DAT_080072d4"
            },
            "code": "void configure_GPIO_pin_08007258(PinName_conflict pin, uint32_t mode, uint32_t pull)\n{\n  uint32_t pin_index = (uint32_t) pin;\n  GPIO_TypeDef *GPIO_port = set_GPIO_Port_Clock((pin_index << 0x18) >> 0x1c);\n  uint32_t pin_mask = 1 << (pin_index & 0xf) & 0xffff;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_InitStruct.Pin = pin_mask;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n  *(uint *)(DAT_080072d0 + 0x18) |= 1;\n  if ((pin_index - 0xd & 0xff) < 2) {\n    *(uint *)(DAT_080072d4 + 4) &= 0xf8ffffff;\n    *(uint *)(DAT_080072d4 + 4) |= 0x4000000;\n  }\n  if ((pin_index == 0xf) || (pin_index == 0x13) || (pin_index == 0x14)) {\n    *(uint *)(DAT_080072d4 + 4) &= 0xf8ffffff;\n    *(uint *)(DAT_080072d4 + 4) |= 0x2000000;\n  }\n  GPIO_InitStruct.Mode = mode;\n  GPIO_InitStruct.Pull = pull;\n  HAL_GPIO_Init(GPIO_port, &GPIO_InitStruct);\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007258",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "configure_GPIO_pin_08007258"
        },
        "FUN_08009f4c": {
            "renaming": {
                "FUN_08009f4c": "allocate_memory_08009f4c",
                "param_1": "size",
                "param_2": "ptr1",
                "param_3": "ptr2",
                "param_4": "size2",
                "pvVar1": "new_ptr",
                "pvVar2": "usable_size"
            },
            "code": "void * allocate_memory_08009f4c(size_t size, void *ptr1, void *ptr2, size_t size2) {\n  void *new_ptr;\n  void *usable_size;\n  \n  if (ptr1 != NULL) {\n    if (ptr2 == NULL) {\n      free(ptr1);\n      new_ptr = ptr2;\n    }\n    else {\n      usable_size = (void *)malloc_usable_size(ptr1);\n      new_ptr = ptr1;\n      if ((usable_size < ptr2) && (new_ptr = (void *)malloc(size2), new_ptr != NULL)) {\n        memcpy(new_ptr, ptr1, (size_t)ptr2);\n        free(ptr1);\n      }\n    }\n    return new_ptr;\n  }\n  new_ptr = (void *)malloc(size2);\n  return new_ptr;\n}",
            "called": [
                "_free_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4c",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009f4c"
        },
        "FUN_08009f4a": {
            "renaming": {
                "FUN_08009f4a": "do_nothing_08009f4a"
            },
            "code": "\nvoid do_nothing_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4a",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f4a"
        },
        "FUN_08006c7c": {
            "renaming": {
                "FUN_08006c7c": "get_pwm_value_from_pin_08006c7c",
                "pin": "pin_name",
                "uVar1": "pwm_function",
                "uVar2": "pwm_value"
            },
            "code": "uint32_t get_pwm_value_from_pin_08006c7c(PinName_conflict pin)\n{\n  uint32_t pwm_function = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08006ca4);\n  uint32_t pwm_value = (pwm_function << 12) >> 27;\n  if (pwm_value == 3) {\n    return 8;\n  }\n  if (pwm_value != 4) {\n    if (pwm_value != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 12;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c7c",
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "imported": false,
            "current_name": "get_pwm_value_from_pin_08006c7c"
        },
        "FUN_08006b5c": {
            "renaming": {
                "FUN_08006b5c": "clear_pin_bit_in_map_08006b5c",
                "pin": "PinName_conflict pin",
                "map": "uint32_t *pin_map",
                "uVar1": "uint32_t pin_index",
                "bit_index": "uint32_t bit_index",
                "bit_mask": "uint32_t bit_mask"
            },
            "code": "void clear_pin_bit_in_map_08006b5c(PinName_conflict pin, uint32_t *pin_map) {\n    uint32_t pin_index = (uint32_t)pin >> 4;\n    uint32_t bit_index = (uint32_t)pin & 0xF;\n    uint32_t bit_mask = ~(1 << bit_index);\n    pin_map[pin_index] &= bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b5c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "clear_pin_bit_in_map_08006b5c"
        },
        "FUN_08007376": {
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_index"
            },
            "code": "uint32_t find_pin_function_08007376(PinName_conflict pin, PinMap_conflict *pin_map) {\n  uint32_t function_index;\n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  function_index = pinmap_find_function(pin, pin_map);\n  return function_index;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007376",
            "calling": [
                "pwm_stop",
                "get_adc_channel",
                "get_pwm_channel",
                "HAL_TIM_PWM_MspInit",
                "pwm_start",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_pin_function_08007376"
        },
        "FUN_080033cc": {
            "renaming": {
                "FUN_080033cc": "parse_080033cc",
                "this": "parser",
                "uVar1": "first_byte",
                "sVar2": "data_size",
                "puVar3": "data_buffer",
                "currentStringCallback": "string_callback",
                "sysexBytesRead": "sysex_bytes_read",
                "decodeByteStream": "decode_byte_stream",
                "bufferDataAtPosition": "buffer_data_at_position",
                "currentStringCallbackContext": "string_callback_context",
                "currentReportFirmwareCallback": "report_firmware_callback",
                "currentReportFirmwareCallbackContext": "report_firmware_callback_context",
                "currentSysexCallback": "sysex_callback",
                "currentSysexCallbackContext": "sysex_callback_context"
            },
            "code": "void __thiscall firmata::FirmataParser::parse_080033cc(FirmataParser *parse_080033ccr)\n{\n  uint8_t first_byte;\n  size_t data_size;\n  uint8_t *data_buffer;\n  data_buffer = parse_080033ccr->dataBuffer;\n  first_byte = *data_buffer;\n  if (first_byte == 'q') {\n    if (parse_080033ccr->currentStringCallback != (stringCallbackFunction)0x0) {\n      data_size = decodeByteStream(parse_080033ccr, parse_080033ccr->sysexBytesRead - 1, data_buffer + 1);\n      bufferDataAtPosition(parse_080033ccr, '\\0', data_size + 1);\n      (*parse_080033ccr->currentStringCallback)(parse_080033ccr->currentStringCallbackContext, (char *)(parse_080033ccr->dataBuffer + 1));\n      return;\n    }\n  }\n  else if (first_byte == 'y') {\n    if (parse_080033ccr->currentReportFirmwareCallback != (versionCallbackFunction)0x0) {\n      if (parse_080033ccr->sysexBytesRead < 3) {\n        (*parse_080033ccr->currentReportFirmwareCallback)(parse_080033ccr->currentReportFirmwareCallbackContext, 0, 0, (char *)0x0);\n        return;\n      }\n      data_size = decodeByteStream(parse_080033ccr, parse_080033ccr->sysexBytesRead - 3, data_buffer + 3);\n      bufferDataAtPosition(parse_080033ccr, '\\0', data_size + 3);\n      (*parse_080033ccr->currentReportFirmwareCallback)(parse_080033ccr->currentReportFirmwareCallbackContext, (uint)data_buffer[1], (uint)data_buffer[2], (char *)(data_buffer + 3));\n      return;\n    }\n  }\n  else if (parse_080033ccr->currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*parse_080033ccr->currentSysexCallback)(parse_080033ccr->currentSysexCallbackContext, first_byte, parse_080033ccr->sysexBytesRead - 1, data_buffer + 1);\n  }\n  return;\n}",
            "called": [
                "bufferDataAtPosition",
                "decodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033cc",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "parse_080033cc"
        },
        "FUN_08003de4": {
            "renaming": {
                "FUN_08003de4": "stop_and_disable_conversion_08003de4",
                "*hadc": "*adc_handle",
                "HVar1": "status",
                "hadc->Lock": "adc_handle->Lock",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "ADC_ConversionStop_Disable": "ADC_ConversionStop_Disable",
                "adc_handle->State": "adc_handle->State",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef_conflict stop_and_disable_conversion_08003de4(ADC_HandleTypeDef *adc_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (adc_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc_handle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->State = adc_handle->State & 0xffffeefe | 1;\n  }\n  adc_handle->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003de4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_and_disable_conversion_08003de4"
        },
        "FUN_08000500": {
            "renaming": {
                "FUN_08000500": "attachServoToPin_08000500",
                "pin": "pin",
                "minPulse": "minPulse",
                "maxPulse": "maxPulse",
                "*PTR_servoCount_0800056c": "servoCountPtr",
                "firmata::FirmataClass::sendString": "firmata::FirmataClass::sendString",
                "PTR_Firmata_08000584": "firmataPtr",
                "PTR_s_Max_servos_attached_08000580": "maxServosAttachedMsg",
                "*PTR_detachedServoCount_08000570": "detachedServoCountPtr",
                "PTR_servoPinMap_08000578": "servoPinMap",
                "PTR_detachedServos_08000574": "detachedServos",
                "Servo::attach": "Servo::attach",
                "PTR_servos_0800057c": "servosPtr"
            },
            "code": "void attachServoToPin_08000500(byte pin, int minPulse, int maxPulse) {\n  byte servoCount = **PTR_servoCount_0800056c;\n  if (servoCount > 11) {\n    firmata::FirmataClass::sendString((FirmataClass*)PTR_Firmata_08000584, PTR_s_Max_servos_attached_08000580);\n    return;\n  }\n  byte detachedServoCount = **PTR_detachedServoCount_08000570;\n  if (detachedServoCount == 0) {\n    PTR_servoPinMap_08000578[pin] = servoCount;\n    **PTR_servoCount_0800056c = servoCount + 1;\n  }\n  else {\n    PTR_servoPinMap_08000578[pin] = PTR_detachedServos_08000574[detachedServoCount - 1];\n    **PTR_detachedServoCount_08000570 = detachedServoCount - 1;\n  }\n  if (minPulse > 0 && maxPulse > 0) {\n    Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[pin] * 3), pin, minPulse, maxPulse);\n    return;\n  }\n  Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[pin] * 3), pin);\n}",
            "called": [
                "attach",
                "attach",
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000500",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "attachServoToPin_08000500"
        },
        "FUN_08009d24": {
            "renaming": {
                "FUN_08009d24": "allocate_memory_08009d24",
                "param_1": "size_of_struct",
                "param_2": "num_of_structs",
                "puVar1": "allocated_memory",
                "iVar2": "total_size"
            },
            "code": "undefined4* allocate_memory_08009d24(int size_of_struct, int num_of_structs) {\n  undefined4 *allocated_memory;\n  int total_size = (num_of_structs - 1) * 0x68;\n  allocated_memory = (undefined4 *)_malloc_r(size_of_struct, total_size + 0x74);\n  if (allocated_memory != (undefined4 *)0x0) {\n    *allocated_memory = 0;\n    allocated_memory[1] = num_of_structs;\n    allocated_memory[2] = allocated_memory + 3;\n    memset(allocated_memory + 3, 0, total_size + 0x68);\n  }\n  return allocated_memory;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d24",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009d24"
        },
        "FUN_08008e72": {
            "renaming": {
                "__thiscall Print::FUN_08008e72": "print_character",
                "this": "print_instance",
                "c": "character",
                "sVar1": "character_size",
                "FUN_08008e72": "print_character_08008e72"
            },
            "code": "size_t __thiscall print_character_08008e72(Print *print_instance, char character) {\n  size_t character_size = (**print_instance->_vptr_Print)(print_instance, (int)character);\n  return character_size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e72",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_character_08008e72"
        },
        "FUN_080022f8": {
            "renaming": {
                "FUN_080022f8": "checkInputsAndProcessData_080022f8",
                "bVar1": "isDigitalInput",
                "PVar2": "pinName",
                "bVar3": "pinModeValue",
                "iVar4": "availableBytes",
                "uVar5": "currentTime",
                "uVar6": "pinIndex",
                "ulPin": "analogPinIndex"
            },
            "code": "void checkInputsAndProcessData_080022f8() \\\n{\\n  bool isDigitalInput;\\n  PinName_conflict pinName;\\n  byte pinModeValue;\\n  int availableBytes;\\n  uint32_t currentTime;\\n  uint pinIndex;\\n  uint analogPinIndex;\\n  uint analogPinMask;\\n  \\n  checkDigitalInputs();\\n  while (availableBytes = firmata::FirmataClass::available((FirmataClass *)PTR_Firmata_080023e0), availableBytes != 0)\\n  {\\n    firmata::FirmataClass::processInput((FirmataClass *)PTR_Firmata_080023e0);\\n  }\\n  currentTime = millis();\\n  *(uint32_t *)PTR_currentMillis_080023e4 = currentTime;\\n  if (*(uint *)PTR_samplingInterval_080023ec < currentTime - *(int *)PTR_previousMillis_080023e8) {\\n    *(uint *)PTR_previousMillis_080023e8 = *(int *)PTR_previousMillis_080023e8 + *(uint *)PTR_samplingInterval_080023ec;\\n    for (pinIndex = 0; pinIndex < 0x3c; pinIndex = pinIndex + 1 & 0xff) {\\n      analogPinIndex = pinIndex - 0x2e & 0xff;\\n      if (analogPinIndex < 0xe) {\\n        if (pinIndex < 0x3c) {\\n          pinName = PTR_digitalPin_080023f4[pinIndex];\\n        }\\n        else {\\n          pinName = NC;\\n        }\\n        analogPinMask = pinNametoDigitalPin(pinName);\\n        if (analogPinMask == 0) {\\n          isDigitalInput = false;\\n        }\\n        else {\\n          if (pinIndex < 0x3c) {\\n            pinName = PTR_digitalPin_080023f4[pinIndex];\\n          }\\n          else {\\n            pinName = NC;\\n          }\\n          analogPinMask = pinNametoDigitalPin(pinName);\\n          if (analogPinMask == 1) {\\n            isDigitalInput = false;\\n          }\\n          else {\\n            pinModeValue = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080023e0,(byte)pinIndex);\\n            isDigitalInput = (pinModeValue == \"\\x02\");\\n          }\\n        }\\n      }\\n      else {\\n        isDigitalInput = false;\\n      }\\n      if ((isDigitalInput) && ((*(int *)PTR_analogInputsToReport_080023f0 >> analogPinIndex & 1U) != 0)) {\\n        analogPinMask = analogRead(analogPinIndex);\\n        firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080023e0,(byte)analogPinIndex,analogPinMask);\\n      }\\n    }\\n    if (-1 < (char)*PTR_queryIndex_080023f8) {\\n      for (pinIndex = 0; (int)pinIndex < (char)*PTR_queryIndex_080023f8 + 1; pinIndex = pinIndex + 1 & 0xff) {\\n        availableBytes = pinIndex * 0xc;\\n        readAndReportData(PTR_query_080023fc[availableBytes],*(int *)(PTR_query_080023fc + availableBytes + 4),PTR_query_080023fc[availableBytes + 8],PTR_query_080023fc[availableBytes + 9]);\\n      }\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "processInput",
                "checkDigitalInputs",
                "millis",
                "pinNametoDigitalPin",
                "sendAnalog",
                "analogRead",
                "readAndReportData",
                "getPinMode",
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022f8",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkInputsAndProcessData_080022f8"
        },
        "FUN_08005084": {
            "renaming": {
                "FUN_08005084": "handle_I2C_state_08005084",
                "*hi2c": "*i2c_handle",
                "HVar1": "state",
                "*pIVar2": "*i2c_instance",
                "*puVar3": "*buffer_pointer",
                "tmpreg": "tmp_reg"
            },
            "code": "HAL_StatusTypeDef_conflict handle_I2C_state_08005084(I2C_HandleTypeDef_conflict *i2c_handle) {\n  HAL_I2C_StateTypeDef_conflict state = i2c_handle->State;\n  I2C_TypeDef_conflict *i2c_instance = i2c_handle->Instance;\n  uint8_t *buffer_pointer;\n  uint32_t tmp_reg;\n  i2c_instance->CR2 &= 0xfffff8ff;\n  i2c_instance->CR1 |= 1;\n  i2c_instance->CR1 &= 0xfffffbff;\n  if ((i2c_instance->CR2 & 0x800) != 0) {\n    if ((i2c_handle->State == HAL_I2C_STATE_BUSY_RX) || (i2c_handle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2c_handle->XferCount != 0) {\n    if ((i2c_instance->SR1 & 4) != 0) {\n      buffer_pointer = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_pointer + 1;\n      *buffer_pointer = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount--;\n    }\n    if ((i2c_instance->SR1 & 0x40) != 0) {\n      buffer_pointer = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_pointer + 1;\n      *buffer_pointer = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount--;\n    }\n    i2c_handle->ErrorCode |= 4;\n  }\n  if (i2c_handle->ErrorCode == 0) {\n    if (((state == HAL_I2C_STATE_LISTEN) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) || (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handle->XferOptions = DAT_08005184;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2c_handle);\n    }\n    else if ((i2c_handle->PreviousState == 0x22) || (state == HAL_I2C_STATE_BUSY_RX)) {\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  else {\n    I2C_ITError(i2c_handle);\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005084",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_state_08005084"
        },
        "FUN_08008b0e": {
            "renaming": {
                "FUN_08008b0e": "readNextByteFromSerialBuffer_08008b0e",
                "this": "serialObj",
                "_serial": "serialData",
                "rx_tail": "rxTail",
                "rx_head": "rxHead",
                "rx_buff": "rxBuffer"
            },
            "code": "int __thiscall readNextByteFromSerialBuffer_08008b0e(HardwareSerial *serialObj)\n{\n  uint rxTail = (uint)(serialObj->_serial).rx_tail;\n  if ((serialObj->_serial).rx_head != rxTail) {\n    return (uint)(serialObj->_serial).rx_buff[rxTail];\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b0e",
            "calling": [],
            "imported": false,
            "current_name": "readNextByteFromSerialBuffer_08008b0e"
        },
        "FUN_0800291c": {
            "renaming": {
                "FUN_0800291c::FUN_0800291c": "initialize_FUN_0800291c",
                "this": "object",
                "puVar1": "digital_pins",
                "PTR_PTR_write_1_08002940": "write_function_ptr",
                "PTR_digitalPin_08002944": "digitalPin_ptr",
                "FUN_0800291c": "initialize_0800291c_0800291c"
            },
            "code": "initialize_0800291c_0800291c * __thiscall initialize_0800291c_0800291c(initialize_0800291c_0800291c *object)\n{\n  undefined *digital_pins;\n  (object->super_Stream).super_Print.write_error = 0;\n  (object->super_Stream)._timeout = 1000;\n  (object->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_08002940;\n  digital_pins = PTR_digitalPin_08002944;\n  (object->_i2c).sda = digital_pins[0xe];\n  (object->_i2c).scl = digital_pins[0xf];\n  return object;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800291c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_0800291c_0800291c"
        },
        "FUN_08002ac0": {
            "renaming": {
                "FUN_08002ac0": "sendStart_08002ac0",
                "this": "wire",
                "uVar1": "status",
                "'\\x01'": "0x01"
            },
            "code": "uint8_t __thiscall TwoWire::sendStart_08002ac0(TwoWire *wire)\n{\n  uint8_t status;\n  status = sendStart_08002ac0(wire, 0x01);\n  return status;\n}",
            "called": [
                "endTransmission"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ac0",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "sendStart_08002ac0"
        },
        "FUN_080032bc": {
            "renaming": {
                "FUN_080032bc::FUN_080032bc": "firmata::initialize",
                "this": "self",
                "dataBuffer": "data_buffer",
                "dataBufferSize": "data_buffer_size",
                "executeMultiByteCommand": "execute_multi_byte_command",
                "multiByteChannel": "multi_byte_channel",
                "waitForData": "wait_for_data",
                "parsingSysex": "parsing_sysex",
                "sysexBytesRead": "sysex_bytes_read",
                "currentAnalogCallbackContext": "current_analog_callback_context",
                "currentDigitalCallbackContext": "current_digital_callback_context",
                "currentReportAnalogCallbackContext": "current_report_analog_callback_context",
                "currentReportDigitalCallbackContext": "current_report_digital_callback_context",
                "currentPinModeCallbackContext": "current_pin_mode_callback_context",
                "currentPinValueCallbackContext": "current_pin_value_callback_context",
                "currentReportFirmwareCallbackContext": "current_report_firmware_callback_context",
                "currentReportVersionCallbackContext": "current_report_version_callback_context",
                "currentDataBufferOverflowCallbackContext": "current_data_buffer_overflow_callback_context",
                "currentStringCallbackContext": "current_string_callback_context",
                "currentSysexCallbackContext": "current_sysex_callback_context",
                "currentSystemResetCallbackContext": "current_system_reset_callback_context",
                "currentAnalogCallback": "current_analog_callback",
                "currentDigitalCallback": "current_digital_callback",
                "currentReportAnalogCallback": "current_report_analog_callback",
                "currentReportDigitalCallback": "current_report_digital_callback",
                "currentPinModeCallback": "current_pin_mode_callback",
                "currentPinValueCallback": "current_pin_value_callback",
                "currentDataBufferOverflowCallback": "current_data_buffer_overflow_callback",
                "currentStringCallback": "current_string_callback",
                "currentSysexCallback": "current_sysex_callback",
                "currentReportFirmwareCallback": "current_report_firmware_callback",
                "currentReportVersionCallback": "current_report_version_callback",
                "currentSystemResetCallback": "current_system_reset_callback",
                "uVar1": "leading_zeroes_count",
                "FUN_080032bc": "initialize_080032bc"
            },
            "code": "initialize_080032bc * __thiscall firmata::initialize_080032bc(initialize_080032bc *self, uint8_t *data_buffer, size_t data_buffer_size) {\\n    self->data_buffer = data_buffer;\\n    self->data_buffer_size = data_buffer_size;\\n    self->execute_multi_byte_command = \"\\0\";\\n    self->multi_byte_channel = \"\\0\";\\n    self->wait_for_data = false;\\n    self->parsing_sysex = false;\\n    self->sysex_bytes_read = 0;\\n    self->current_analog_callback_context = nullptr;\\n    self->current_digital_callback_context = nullptr;\\n    self->current_report_analog_callback_context = nullptr;\\n    self->current_report_digital_callback_context = nullptr;\\n    self->current_pin_mode_callback_context = nullptr;\\n    self->current_pin_value_callback_context = nullptr;\\n    self->current_report_firmware_callback_context = nullptr;\\n    self->current_report_version_callback_context = nullptr;\\n    self->current_data_buffer_overflow_callback_context = nullptr;\\n    self->current_string_callback_context = nullptr;\\n    self->current_sysex_callback_context = nullptr;\\n    self->current_system_reset_callback_context = nullptr;\\n    self->current_analog_callback = nullptr;\\n    self->current_digital_callback = nullptr;\\n    self->current_report_analog_callback = nullptr;\\n    self->current_report_digital_callback = nullptr;\\n    self->current_pin_mode_callback = nullptr;\\n    self->current_pin_value_callback = nullptr;\\n    self->current_data_buffer_overflow_callback = nullptr;\\n    self->current_string_callback = nullptr;\\n    self->current_sysex_callback = nullptr;\\n    self->current_report_firmware_callback = nullptr;\\n    self->current_report_version_callback = nullptr;\\n    self->current_system_reset_callback = nullptr;\\n    uint leading_zeroes_count = count_leading_zeroes(data_buffer);\\n    self->allow_buffer_update = SUB41(leading_zeroes_count >> 5,0);\\n    return self;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032bc",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "initialize_080032bc"
        },
        "FUN_080077b0": {
            "renaming": {
                "FUN_080077b0": "FUNC_080077b0"
            },
            "code": "\nvoid FUNC_080077b0(i2c_t_conflict *obj,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                    uint32_t ownAddress,uint8_t master)\n\n{\n  undefined *puVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  void *a;\n  void *b;\n  I2C_TypeDef_conflict *pIVar3;\n  GPIO_TypeDef *pGVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (i2c_t_conflict *)0x0) {\n    hi2c = &obj->handle;\n    a = pinmap_peripheral(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n    b = pinmap_peripheral(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      pIVar3 = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      obj->i2c = pIVar3;\n      pIVar2 = DAT_08007a7c;\n      if (pIVar3 == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (pIVar3 == DAT_08007a7c) {\n          DAT_08007a7c[0xc56].CR2 = DAT_08007a7c[0xc56].CR2 | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR & 0xffdfffff;\n          obj->irq = I2C1_EV_IRQn;\n          obj->irqER = I2C1_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08007a90 = hi2c;\n        }\n        pIVar2 = DAT_08007a80;\n        if (obj->i2c == DAT_08007a80) {\n          DAT_08007a80[0xc39].SR2 = DAT_08007a80[0xc39].SR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 & 0xffbfffff;\n          obj->irq = I2C2_EV_IRQn;\n          obj->irqER = I2C2_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08007a90 + 4) = hi2c;\n        }\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->scl << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SCL_08007a78;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->scl & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n        uVar6 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->sda << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SDA_08007a74;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->sda & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n        uVar6 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        (obj->handle).Instance = obj->i2c;\n        (obj->handle).Init.ClockSpeed = timing;\n        (obj->handle).Init.DutyCycle = 0;\n        (obj->handle).Init.OwnAddress1 = ownAddress;\n        (obj->handle).Init.OwnAddress2 = 0xff;\n        (obj->handle).Init.AddressingMode = addressingMode;\n        (obj->handle).Init.DualAddressMode = 0;\n        (obj->handle).Init.GeneralCallMode = 0;\n        (obj->handle).Init.NoStretchMode = 0;\n        (obj->handle).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(obj->irq,0,1);\n        HAL_NVIC_EnableIRQ(obj->irq);\n        HAL_NVIC_SetPriority(obj->irqER,0,1);\n        HAL_NVIC_EnableIRQ(obj->irqER);\n        HAL_I2C_Init(hi2c);\n        obj->isMaster = master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_function",
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "set_GPIO_Port_Clock",
                "HAL_NVIC_SetPriority",
                "HAL_I2C_Init",
                "HAL_NVIC_EnableIRQ",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080077b0",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "FUNC_080077b0"
        },
        "FUN_08008c44": {
            "renaming": {
                "FUN_08008c44": "setSerialConfig_08008c44",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "configMask",
                "iVar2": "databitsCount",
                "_serial": "_serial",
                "PTR_s__home_bo__arduino15_packages_STM_08008cfc": "PTR_s__home_bo__arduino15_packages_STM_08008cfc",
                "PTR___PRETTY_FUNCTION___08008cf8": "PTR___PRETTY_FUNCTION___08008cf8",
                "PTR_s_databits__0_08008cf4": "PTR_s_databits__0_08008cf4"
            },
            "code": "void __thiscall setSerialConfig_08008c44(HardwareSerial *serial, ulong baudrate, byte config) {\n  byte parity = 0;\n  byte stopbits = 0;\n  byte databits = 0;\n  byte configMask = config & 7;\n  int databitsCount = 0;\n  if (configMask == 4) {\n    databitsCount = 7;\n  }\n  else if (configMask == 6) {\n    databitsCount = 8;\n  }\n  else if (configMask == 2) {\n    databitsCount = 6;\n  }\n  if ((config & 0x30) == 0x30) {\n    parity = 0x60;\n    databitsCount++;\n  }\n  else if ((config & 0x20) == 0) {\n    parity = 0;\n  }\n  else {\n    parity = 0x40;\n    databitsCount++;\n  }\n  if ((config & 8) != 0) {\n    stopbits = 0x20;\n  }\n  if (databitsCount == 8) {\n    databits = 0;\n  }\n  else if (databitsCount == 9) {\n    databits = 0x10;\n  }\n  else {\n    return;\n  }\n  (serial->_serial).baudrate = baudrate;\n  (serial->_serial).parity = parity;\n  (serial->_serial).stopbits = stopbits;\n  (serial->_serial).databits = databits;\n  uart_init((serial_t *)&serial->_serial);\n  uart_attach_rx_callback((serial_t *)&serial->_serial, DAT_08008cf0);\n}\n",
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c44",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setSerialConfig_08008c44"
        },
        "FUN_08006060": {
            "renaming": {
                "FUN_08006060": "configureTimer_08006060",
                "htim": "timer",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_OC_MspInit": "HAL_TIM_OC_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict configureTimer_08006060(TIM_HandleTypeDef_conflict *timer)\n{\n  if (timer != NULL)\n  {\n    if (timer->State == HAL_TIM_STATE_RESET)\n    {\n      timer->Lock = HAL_UNLOCKED;\n      HAL_TIM_OC_MspInit(timer);\n    }\n    timer->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->Instance, &(timer->Init));\n    timer->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_OC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006060",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configureTimer_08006060"
        },
        "FUN_08009698": {
            "renaming": {
                "FUN_08009698": "FUNC_08009698"
            },
            "code": "\nuint FUNC_08009698(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08009852;\n          if (bVar1 != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080096c8;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_080096e8;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_080096e8:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080097be;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08009728:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800974e:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_0800975c;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_0800975c:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800970e:\n            puVar6 = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800974e;\n          if (bVar1 == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08009728;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_0800983e;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_0800983e:\n    *puVar3 = uVar7;\n  }\nLAB_08009852:\n  param_2[4] = 0;\nLAB_080097be:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_080097d2:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_080097d2;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009698",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_08009698"
        },
        "FUN_08006186": {
            "renaming": {
                "FUN_08006186": "set_TIM_OC_Config_08006186",
                "htim": "tim_handle",
                "sConfig": "config",
                "Channel": "channel"
            },
            "code": "HAL_StatusTypeDef set_TIM_OC_Config_08006186(TIM_HandleTypeDef* htim, TIM_OC_InitTypeDef* config, uint32_t channel) {\n    if (htim->Lock == HAL_LOCKED) {\n        return HAL_BUSY;\n    }\n    htim->Lock = HAL_LOCKED;\n    htim->State = HAL_TIM_STATE_BUSY;\n    switch (channel) {\n        case 0:\n            TIM_OC1_SetConfig(htim->Instance, config);\n            htim->Instance->CCMR1 |= 0x8;\n            htim->Instance->CCMR1 &= 0xFFFFFFFBU;\n            htim->Instance->CCMR1 |= config->OCFastMode;\n            break;\n        case 4:\n            TIM_OC2_SetConfig(htim->Instance, config);\n            htim->Instance->CCMR1 |= 0x800;\n            htim->Instance->CCMR1 &= 0xFFFFFBFFU;\n            htim->Instance->CCMR1 |= config->OCFastMode << 8;\n            break;\n        case 8:\n            TIM_OC3_SetConfig(htim->Instance, config);\n            htim->Instance->CCMR2 |= 0x8;\n            htim->Instance->CCMR2 &= 0xFFFFFFFBU;\n            htim->Instance->CCMR2 |= config->OCFastMode;\n            break;\n        case 0xC:\n            TIM_OC4_SetConfig(htim->Instance, config);\n            htim->Instance->CCMR2 |= 0x800;\n            htim->Instance->CCMR2 &= 0xFFFFFBFFU;\n            htim->Instance->CCMR2 |= config->OCFastMode << 8;\n            break;\n        default:\n            htim->Lock = HAL_UNLOCKED;\n            return HAL_ERROR;\n    }\n    htim->State = HAL_TIM_STATE_READY;\n    htim->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n}\n",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006186",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "set_TIM_OC_Config_08006186"
        },
        "FUN_08006b7c": {
            "renaming": {
                "FUN_08006b7c": "get_gpio_type_08006b7c",
                "port_idx": "port_index",
                "DAT_08006ba4": "GPIO_PortA",
                "DAT_08006bb4": "GPIO_PortB",
                "DAT_08006ba8": "GPIO_PortC",
                "DAT_08006bac": "GPIO_PortD",
                "DAT_08006bb0": "GPIO_PortE"
            },
            "code": "GPIO_TypeDef* get_gpio_type_08006b7c(uint32_t port_idx) {\n    switch(port_idx) {\n        case 0:\n            return DAT_08006ba4;\n        case 1:\n            return DAT_08006bb4;\n        case 2:\n            return DAT_08006ba8;\n        case 3:\n            return DAT_08006bac;\n        case 4:\n            return DAT_08006bb0;\n        default:\n            return (GPIO_TypeDef*)0x0;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b7c",
            "calling": [
                "digitalRead",
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "get_gpio_type_08006b7c"
        },
        "FUN_08008e7c": {
            "renaming": {
                "__thiscall Print::FUN_08008e7c": "print_number",
                "this": "self",
                "n": "number",
                "base": "base",
                "cVar1": "digit",
                "sVar2": "length",
                "sVar3": "buffer_length",
                "uVar4": "remainder",
                "uVar5": "base_number",
                "uVar6": "quotient",
                "__s": "current",
                "buf": "buffer",
                "FUN_08008e7c": "print_number_08008e7c"
            },
            "code": "size_t __thiscall Print::print_number_08008e7c(Print *this, ulong number, uint8_t base)\n{\n    char digit;\n    size_t length = 0;\n    uint base_number = (uint)base;\n    char buffer[33];\n    buffer[32] = '\\0';\n    if (base_number < 2)\n    {\n        base_number = 10;\n    }\n    char *current = buffer + 0x20;\n    do\n    {\n        uint quotient = number / base_number;\n        uint remainder = (number & 0xff) - (quotient * base_number & 0xff) & 0xff;\n        current--;\n        if (remainder < 10)\n        {\n            digit = remainder + '0';\n        }\n        else\n        {\n            digit = remainder + '7';\n        }\n        *current = digit;\n        number = quotient;\n    } while (number != 0);\n    if (current == (char *)0x0)\n    {\n        length = 0;\n    }\n    else\n    {\n        size_t buffer_length = strlen(current);\n        length = (*this->_vptr_Print[1])(buffer_length, current, buffer_length);\n    }\n    return length;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e7c",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_08008e7c"
        },
        "FUN_0800a194": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a194": "set_flags_if_negative",
                "PTR_id_0800a228": "flag_ptr_1",
                "PTR_id_0800a22c": "flag_ptr_2",
                "PTR_id_0800a230": "flag_ptr_3",
                "PTR_id_0800a234": "flag_ptr_4",
                "PTR_id_0800a238": "flag_ptr_5",
                "PTR_id_0800a23c": "flag_ptr_6",
                "PTR_id_0800a240": "flag_ptr_7",
                "PTR_id_0800a244": "flag_ptr_8",
                "PTR_id_0800a248": "flag_ptr_9",
                "PTR_id_0800a24c": "flag_ptr_10",
                "PTR_id_0800a250": "flag_ptr_11",
                "PTR_id_0800a254": "flag_ptr_12",
                "FUN_0800a194": "set_flags_if_negative_0800a194"
            },
            "code": "void set_flags_if_negative_0800a194(int* flag_ptr) {\n  if (*flag_ptr < 0) {\n    *flag_ptr = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a194",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_if_negative_0800a194"
        },
        "FUN_08003aa0": {
            "renaming": {
                "FUN_08003aa0": "configureADC_08003aa0",
                "*hadc": "*adc",
                "HVar1": "status",
                "pAVar2": "instance"
            },
            "code": "HAL_StatusTypeDef_conflict configureADC_08003aa0(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *instance;\n  if (adc->Lock != HAL_LOCKED) {\n    adc->Lock = HAL_LOCKED;\n    status = ADC_Enable(adc);\n    if (status == HAL_OK) {\n      adc->State = (adc->State & 0xfffffcfe) | 0x100;\n      instance = adc->Instance;\n      if ((instance == PTR_08003b84) && ((PTR_08003b84[-0xd].JOFR1 & 0xf0000) != 0)) {\n        adc->State |= 0x100000;\n        if ((*(uint *)(PTR_08003b88 + 4) & 0x400) != 0) {\n          adc->State = (adc->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      else {\n        adc->State &= 0xffefffff;\n        if ((instance->CR1 & 0x400) != 0) {\n          adc->State = (adc->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      if ((adc->State & 0x1000) == 0) {\n        adc->ErrorCode = 0;\n      }\n      else {\n        adc->ErrorCode &= 0xfffffff9;\n      }\n      adc->Lock = HAL_UNLOCKED;\n      instance->SR = 0xfffffffd;\n      instance = adc->Instance;\n      if (((instance->CR2 & 0xe0000) == 0xe0000) && ((instance != PTR_08003b84) || ((PTR_08003b84[-0xd].JOFR1 & 0xf0000) == 0))) {\n        instance->CR2 |= 0x500000;\n      }\n      else {\n        instance->CR2 |= 0x100000;\n      }\n    }\n    else {\n      adc->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "ADC_Enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003aa0",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configureADC_08003aa0"
        },
        "FUN_08005fe8": {
            "renaming": {
                "FUN_08005fe8": "configure_timer_08005fe8",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "cr1_value",
                "DAT_0800605c": "timer1"
            },
            "code": "void configure_timer_08005fe8(TIM_TypeDef_conflict *timer, TIM_Base_InitTypeDef_conflict *config)\n{\n  uint32_t cr1_value = timer->CR1;\n  if (((timer == DAT_0800605c) || (timer == timer2)) ||\n      (timer == &DAT_0800605c[-0x387].DMAR) ||\n      (timer == &DAT_0800605c[-0x37A].SMCR)) {\n    cr1_value = (cr1_value & 0xffffff8f) | config->CounterMode;\n  }\n  if (((timer == DAT_0800605c) || (timer == timer2)) ||\n      ((timer == &DAT_0800605c[-0x387].DMAR) ||\n       (timer == &DAT_0800605c[-0x37A].SMCR)))) {\n    cr1_value = (cr1_value & 0xfffffcff) | config->ClockDivision;\n  }\n  timer->CR1 = (cr1_value & 0xffffff7f) | config->AutoReloadPreload;\n  timer->ARR = config->Period;\n  timer->PSC = config->Prescaler;\n  if (timer == DAT_0800605c) {\n    timer->RCR = config->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fe8",
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_08005fe8"
        },
        "FUN_08003ce8": {
            "renaming": {
                "FUN_08003ce8": "stop_ADC_conversion_08003ce8",
                "hadc": "ADC_handle",
                "HVar1": "status"
            },
            "code": "HAL_StatusTypeDef_conflict stop_ADC_conversion_08003ce8(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (hadc == NULL) {\n    status = HAL_ERROR;\n  }\n  else {\n    hadc->State |= 2;\n    status = ADC_ConversionStop_Disable(hadc);\n    if (status == HAL_OK) {\n      hadc->Instance->SR = 0xffffffe0;\n      hadc->Instance->CR1 = hadc->Instance->CR1 & DAT_08003ddc;\n      hadc->Instance->CR2 = hadc->Instance->CR2 & DAT_08003de0;\n      hadc->Instance->SMPR1 &= 0xff000000;\n      hadc->Instance->SMPR2 &= 0xc0000000;\n      hadc->Instance->JOFR1 &= 0xfffff000;\n      hadc->Instance->JOFR2 &= 0xfffff000;\n      hadc->Instance->JOFR3 &= 0xfffff000;\n      hadc->Instance->JOFR4 &= 0xfffff000;\n      hadc->Instance->HTR &= 0xfffff000;\n      hadc->Instance->LTR &= 0xfffff000;\n      hadc->Instance->SQR1 &= 0xff000000;\n      hadc->Instance->SQR2 &= 0xc0000000;\n      hadc->Instance->SQR3 &= 0xc0000000;\n      hadc->Instance->JSQR &= 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc->ErrorCode = 0;\n      hadc->State = 0;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ce8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_ADC_conversion_08003ce8"
        },
        "FUN_0800738a": {
            "renaming": {
                "FUN_0800738a": "is_pin_in_map_0800738a",
                "pin": "pin_name",
                "map": "pin_map",
                "NC": "not_connected"
            },
            "code": "\n\nbool is_pin_in_map_0800738a(PinName_conflict pin, PinMap_conflict *map)\n{\n    if (pin == NC)\n    {\n        return false;\n    }\n    while (true)\n    {\n        if (map->pin == NC)\n        {\n            return false;\n        }\n        if (pin == map->pin)\n        {\n            break;\n        }\n        map++;\n    }\n    return true;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738a",
            "calling": [
                "enableI2CPins",
                "analogWrite",
                "pinMode",
                "sysexCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "is_pin_in_map_0800738a"
        },
        "FUN_08002948": {
            "renaming": {
                "FUN_08002948": "initializeWireLibrary_08002948",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority"
            },
            "code": "void initializeWireLibrary_08002948(int shouldInitialize, int priority) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    TwoWire::TwoWire((TwoWire *)PTR_Wire_08002964);\n  }\n  return;\n}",
            "called": [
                "TwoWire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002948",
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "imported": false,
            "current_name": "initializeWireLibrary_08002948"
        },
        "FUN_08009e64": {
            "renaming": {
                "FUN_08009e64": "check_file_accessibility_08009e64",
                "param_1": "file_descriptor",
                "param_2": "file_info_address",
                "param_3": "access_status",
                "param_4": "file_type",
                "iVar1": "file_status",
                "uVar2": "type_flag",
                "auStack_4c": "file_status_buffer",
                "local_48": "file_mode"
            },
            "code": "int check_file_accessibility_08009e64(int file_descriptor, int file_info_address, int* access_status, uint* file_type) {\n  int file_status;\n  uint type_flag;\n  if (*(short *)(file_info_address + 0xe) < 0 || _fstat_r(file_descriptor, (int)*(short *)(file_info_address + 0xe), &file_status) < 0) {\n    *access_status = 0;\n    if ((int)((uint)*(ushort *)(file_info_address + 0xc) << 0x18) < 0) {\n      type_flag = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    type_flag = (uint)((file_status & 0xf000) == 0x2000);\n    *access_status = 1;\n  }\n  type_flag = 0x400;\n  LAB_08009ea4:\n  *file_type = type_flag;\n  return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e64",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_accessibility_08009e64"
        },
        "FUN_08002acc": {
            "renaming": {
                "TwoWire::FUN_08002acc": "resize_rx_buffer",
                "length": "new_length",
                "puVar1": "rx_buffer_ptr",
                "pvVar2": "new_buffer_ptr",
                "uVar3": "new_buffer_length",
                "FUN_08002acc": "resize_rx_buffer_08002acc"
            },
            "code": "void resize_rx_buffer_08002acc(size_t new_length) {\n  undefined *rx_buffer_ptr;\n  void *new_buffer_ptr;\n  undefined new_buffer_length;\n  rx_buffer_ptr = rx_buffer;\n  if ((byte)*rx_buffer_allocated < new_length) {\n    if (new_length < 0x20) {\n      new_length = 0x20;\n    }\n    new_buffer_ptr = realloc(*(void **)rx_buffer,new_length);\n    *(void **)rx_buffer_ptr = new_buffer_ptr;\n    if (new_buffer_ptr == (void *)0x0) {\n      new_buffer_length = 0;\n    }\n    else {\n      new_buffer_length = (undefined)new_length;\n    }\n    *rx_buffer_allocated = new_buffer_length;\n  }\n  return;\n}",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002acc",
            "calling": [
                "requestFrom",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "resize_rx_buffer_08002acc"
        },
        "FUN_0800932c": {
            "renaming": {
                "FUN_0800932c": "write_character_to_buffer_0800932c",
                "param_1": "buffer_index",
                "param_2": "character",
                "param_3": "buffer_pointer",
                "uVar1": "result",
                "pbVar2": "current_buffer_position"
            },
            "code": "uint write_character_to_buffer_0800932c(uint buffer_index, byte character, byte **buffer_pointer)\n{\n  uint result;\n  byte *current_buffer_position;\n  current_buffer_position = buffer_pointer[2] - 1;\n  buffer_pointer[2] = current_buffer_position;\n  if (((int)current_buffer_position < 0) && (((int)current_buffer_position < (int)buffer_pointer[6] || (character == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  current_buffer_position = *buffer_pointer;\n  *buffer_pointer = current_buffer_position + 1;\n  *current_buffer_position = character;\n  return (uint)character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800932c",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_character_to_buffer_0800932c"
        },
        "FUN_080099a4": {
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "string",
                "__needle": "substring",
                "pcVar1": "current_char",
                "pcVar2": "current_substring_char",
                "pcVar3": "starting_char"
            },
            "code": "char* find_substring_080099a4(char* string, char* substring) {\n\tchar* current_char;\n\tchar* current_substring_char;\n\tchar* starting_char = string;\n\n\tif (*string == '\\0') {\n\t\tif (*substring != '\\0') {\n\t\t\tstring = NULL;\n\t\t}\n\t\treturn string;\n\t}\n\n\twhile (*starting_char != '\\0') {\n\t\tcurrent_char = starting_char;\n\t\tcurrent_substring_char = substring;\n\n\t\twhile (*current_substring_char != '\\0' && *current_char == *current_substring_char) {\n\t\t\tcurrent_substring_char++;\n\t\t\tcurrent_char++;\n\t\t}\n\n\t\tif (*current_substring_char == '\\0') {\n\t\t\treturn starting_char;\n\t\t}\n\n\t\tstarting_char++;\n\t}\n\n\treturn NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099a4",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_substring_080099a4"
        },
        "FUN_08005a1c": {
            "renaming": {
                "FUN_08005a1c": "get_system_core_clock_08005a1c",
                "PTR_SystemCoreClock_08005a24": "system_core_clock_address"
            },
            "code": "uint32_t get_system_core_clock_08005a1c(void)\n{\n  return *(uint32_t *)PTR_SystemCoreClock_08005a24;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a1c",
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "imported": false,
            "current_name": "get_system_core_clock_08005a1c"
        },
        "FUN_08006b0c": {
            "renaming": {
                "FUN_08006b0c": "reset_uart_transfer_counts_08006b0c",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "receive_transfer_count",
                "TxXferCount": "transmit_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error"
            },
            "code": "void reset_uart_transfer_counts_08006b0c(DMA_HandleTypeDef_conflict *dma_handle)\n{\n  UART_HandleTypeDef *uart_handle;\n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b0c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_transfer_counts_08006b0c"
        },
        "FUN_08001cd0": {
            "renaming": {
                "FUN_08001cd0": "FUNC_08001cd0"
            },
            "code": "\nvoid FUNC_08001cd0(byte command,byte argc,byte *argv)\n\n{\n  byte bVar1;\n  uint8_t address;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte bVar5;\n  char cVar6;\n  undefined *puVar7;\n  undefined *this;\n  PinName_conflict PVar8;\n  _Bool _Var9;\n  byte bVar10;\n  uint32_t uVar11;\n  uint uVar12;\n  int iVar13;\n  int iVar14;\n  char cVar15;\n  uint uVar16;\n  int iVar17;\n  bool bVar18;\n  \n  this = PTR_Firmata_080022e8;\n  puVar7 = PTR_Firmata_08002044;\n  uVar16 = (uint)argc;\n  switch(command) {\n  case 'i':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)this,'j');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      uVar12 = uVar16 - 0x2e & 0xff;\n      bVar10 = (byte)uVar12;\n      if (uVar12 < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_080022e4[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar10 = '\\x7f';\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_080022e4[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar10 = '\\x7f';\n          }\n        }\n      }\n      else {\n        bVar10 = '\\x7f';\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,bVar10);\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    break;\n  case 'k':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)puVar7,'l');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_08002044;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,'\\0');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\v');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      if ((uVar16 - 0x2e & 0xff) < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_08002060[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar18 = false;\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_08002060[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar18 = false;\n          }\n          else {\n            bVar18 = true;\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x02');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\n');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x03');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\b');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x04');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x0e');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_080022f0);\n              if (!_Var9) {\n                _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x06');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x7f');\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    return;\n  case 'm':\n    if (uVar16 != 0) {\n      bVar1 = *argv;\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n      firmata::FirmataClass::write((FirmataClass *)this,'n');\n      firmata::FirmataClass::write((FirmataClass *)this,bVar1);\n      if (bVar1 < 0x3c) {\n        bVar10 = firmata::FirmataClass::getPinMode((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,bVar10);\n        iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,(byte)iVar13 & 0x7f);\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        if ((uVar16 & 0xff80) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)this,(byte)((uint)(iVar13 << 0x12) >> 0x19));\n        }\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n        puVar7 = PTR_Firmata_080022e8;\n        if ((uVar16 & 0xc000) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)puVar7,(byte)((uint)(iVar13 << 0xb) >> 0x19))\n          ;\n        }\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 'o':\n    if (1 < uVar16) {\n      uVar12 = (uint)argv[1];\n      if (2 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[2] << 7;\n      }\n      if (3 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[3] << 0xe;\n      }\n      analogWriteCallback(*argv,uVar12);\n      return;\n    }\n    break;\n  case 'p':\n    if (4 < uVar16) {\n      bVar1 = *argv;\n      uVar16 = (uint)bVar1;\n      bVar2 = argv[1];\n      bVar3 = argv[2];\n      bVar4 = argv[3];\n      bVar5 = argv[4];\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_08002060[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      if (bVar18) {\n        if ((byte)PTR_servoPinMap_08002064[uVar16] < 0xc) {\n          bVar18 = Servo::attached((Servo *)(PTR_servos_08002068 +\n                                            (uint)(byte)PTR_servoPinMap_08002064[uVar16] * 3));\n        }\n        else {\n          bVar18 = false;\n        }\n        if (bVar18 != false) {\n          detachServo(bVar1);\n        }\n        attachServo(bVar1,(uint)bVar2 + (uint)bVar3 * 0x80,(uint)bVar4 + (uint)bVar5 * 0x80);\n        setPinModeCallback(bVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    bVar1 = argv[1];\n    if ((bVar1 & 0x20) != 0) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08002044,PTR_s_10_bit_addressing_not_supported_08002040\n                );\n      return;\n    }\n    address = *argv;\n    bVar18 = (bVar1 & 0x40) == 0;\n    if ((bVar1 & 0x18) < 0x19) {\n      switch(bVar1 & 0x18) {\n      case 0:\n        TwoWire::beginTransmission((TwoWire *)PTR_Wire_08002048,address);\n        for (uVar12 = 2; uVar12 < uVar16; uVar12 = uVar12 + 2 & 0xff) {\n          wireWrite(argv[uVar12 + 1] * -0x80 + argv[uVar12]);\n        }\n        TwoWire::endTransmission((TwoWire *)PTR_Wire_08002048);\n        return;\n      case 8:\n        if (uVar16 == 6) {\n          iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n          bVar10 = argv[4] + argv[5] * -0x80;\n        }\n        else {\n          bVar10 = argv[2] + argv[3] * -0x80;\n          iVar13 = -1;\n        }\n        readAndReportData(address,iVar13,bVar10,bVar18);\n        return;\n      case 0x10:\n        if ((char)*PTR_queryIndex_0800204c + 1 < 8) {\n          if (uVar16 == 6) {\n            iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n            cVar15 = argv[4] + argv[5] * -0x80;\n          }\n          else {\n            cVar15 = argv[2] + argv[3] * -0x80;\n            iVar13 = -1;\n          }\n          cVar6 = *PTR_queryIndex_0800204c + '\\x01';\n          *PTR_queryIndex_0800204c = cVar6;\n          puVar7 = PTR_query_08002050;\n          iVar14 = cVar6 * 0xc;\n          PTR_query_08002050[iVar14] = address;\n          *(int *)(puVar7 + iVar14 + 4) = iVar13;\n          puVar7[iVar14 + 8] = cVar15;\n          puVar7[iVar14 + 9] = bVar18;\n          return;\n        }\n        firmata::FirmataClass::sendString\n                  ((FirmataClass *)PTR_Firmata_08002044,PTR_s_too_many_queries_08002054);\n        return;\n      case 0x18:\n        cVar15 = *PTR_queryIndex_0800204c;\n        if (cVar15 < 1) {\n          *PTR_queryIndex_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uVar16 = 0; iVar13 = cVar15 + 1, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (address == PTR_query_08002050[uVar16 * 0xc]) goto LAB_08001e66;\n      }\n      uVar16 = 0;\nLAB_08001e66:\n      for (; puVar7 = PTR_query_08002050, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (uVar16 < 8) {\n          iVar14 = (uVar16 + 1) * 0xc;\n          iVar17 = uVar16 * 0xc;\n          PTR_query_08002050[iVar17] = PTR_query_08002050[iVar14];\n          *(undefined4 *)(puVar7 + iVar17 + 4) = *(undefined4 *)(puVar7 + iVar14 + 4);\n          puVar7[iVar17 + 8] = puVar7[iVar14 + 8];\n          puVar7[iVar17 + 9] = puVar7[iVar14 + 9];\n        }\n      }\n      *PTR_queryIndex_0800204c = cVar15 + -1;\n      return;\n    }\n    break;\n  case 'x':\n    iVar13 = (uint)*argv + (uint)argv[1] * 0x80;\n    if ((1 < uVar16) && (iVar13 != 0)) {\n      *(int *)PTR_i2cReadDelayTime_08002058 = iVar13;\n    }\n    if (*PTR_isI2CEnabled_0800205c == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 'z':\n    if ((1 < uVar16) &&\n       (iVar13 = (uint)*argv + (uint)argv[1] * 0x80, *(int *)PTR_samplingInterval_0800206c = iVar13,\n       iVar13 == 0)) {\n      *(undefined4 *)PTR_samplingInterval_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "enableI2CPins",
                "attached",
                "pin_in_pinmap",
                "beginTransmission",
                "pinNametoDigitalPin",
                "wireWrite",
                "sendString",
                "write",
                "endTransmission",
                "attachServo",
                "getPinState",
                "detachServo",
                "getPinMode",
                "readAndReportData",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001cd0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08001cd0"
        },
        "FUN_08007320": {
            "renaming": {
                "FUN_08007320": "find_peripheral_from_pin_08007320",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "code": "void * find_peripheral_from_pin_08007320(PinName_conflict pin, PinMap_conflict *pin_map) {\n  void *peripheral;\n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral(pin, pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007320",
            "calling": [
                "pwm_stop",
                "uart_debug_init",
                "pwm_start",
                "uart_init",
                "adc_read_value",
                "i2c_custom_init",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "find_peripheral_from_pin_08007320"
        },
        "FUN_080002ec": {
            "renaming": {
                "FUN_080002ec": "setPortValue_080002ec",
                "port": "portNum",
                "value": "portValue",
                "bVar1": "isPinValid",
                "bVar2": "pinMode",
                "uVar3": "portIndex",
                "uVar4": "pinNum",
                "iVar5": "pinState",
                "pin": "pinIndex",
                "ulPin": "pinIndex",
                "ulPin_00": "portStartIndex",
                "uVar6": "bitMask",
                "uVar7": "portEndIndex",
                "uVar8": "validPinsMask",
                "PTR_digitalPin_08000480": "digitalPin",
                "PTR_Firmata_08000484": "firmata"
            },
            "code": "void setPortValue_080002ec(byte port, int value) {\n  bool isPinValid;\n  byte pinIndex;\n  uint32_t pinNum;\n  uint8_t pinMode;\n  uint8_t bitMask;\n  uint8_t validPinsCount;\n  uint8_t validPins[6];\n\n  if (port < 5) {\n    validPinsCount = 0;\n    for (pinIndex = port * 8; pinIndex < (port + 1) * 8; pinIndex++) {\n      if (pinIndex == 0x3c) break;\n      if (PTR_digitalPin_08000480[pinIndex] != NC) {\n        pinNum = pinNametoDigitalPin(PTR_digitalPin_08000480[pinIndex]);\n        if (pinNum > 1) {\n          validPins[validPinsCount++] = pinIndex;\n        }\n      }\n    }\n\n    bitMask = 1;\n    for (uint8_t i = 0; i < validPinsCount; i++) {\n      pinIndex = validPins[i];\n      pinMode(pinIndex, INPUT);\n      pinMode(pinIndex, OUTPUT);\n      pinMode(pinIndex, INPUT_PULLUP);\n      pinMode(pinIndex, OUTPUT);\n\n      isPinValid = (bitMask & value) != 0;\n      pinMode(pinIndex, OUTPUT);\n      digitalWrite(pinIndex, isPinValid);\n      bitMask <<= 1;\n    }\n  }\n}",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "pinMode",
                "getPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002ec",
            "calling": [],
            "imported": false,
            "current_name": "setPortValue_080002ec"
        },
        "FUN_08000be8": {
            "renaming": {
                "FUN_08000be8": "send_digital_port_if_changed_08000be8",
                "portNumber": "port_number",
                "portValue": "port_value",
                "forceSend": "force_send",
                "PTR_portConfigInputs_08000c0c": "port_config_inputs",
                "PTR_previousPINs_08000c10": "previous_pins",
                "PTR_Firmata_08000c14": "firmata"
            },
            "code": "void send_digital_port_if_changed_08000be8(byte port_number, byte port_value, byte force_send) {\n  byte port_config = PTR_portConfigInputs_08000c0c[port_number] & port_value;\n  if (force_send || port_config != PTR_previousPINs_08000c10[port_number]) {\n    PTR_Firmata_08000c14::FirmataClass::sendDigitalPort((FirmataClass *)PTR_Firmata_08000c14, port_number, port_config);\n    PTR_previousPINs_08000c10[port_number] = port_config;\n  }\n  return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000be8",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "send_digital_port_if_changed_08000be8"
        },
        "FUN_08003fd8": {
            "renaming": {
                "FUN_08003fd8": "calculate_ticks_08003fd8",
                "TicksNumb": "ticks_number",
                "puVar1": "ticks_data"
            },
            "code": "uint32_t calculate_ticks_08003fd8(uint32_t ticks_number)\n{\n  undefined4 *ticks_data = DAT_08003ffc;\n  if (ticks_number - 1 < 0x1000000) {\n    ticks_data[1] = ticks_number - 1;\n    *(undefined *)(DAT_08004000 + 0x23) = 0xf0;\n    ticks_data[2] = 0;\n    *ticks_data = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd8",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08003fd8"
        },
        "FUN_0800307a": {
            "renaming": {
                "FUN_0800307a": "marshallData_0800307a",
                "this": "marshaller",
                "bytec": "numBytes",
                "bytev": "byteData",
                "max_bytes": "maxBytes",
                "uVar1": "currentByte",
                "uVar2": "marshalledBytes",
                "uVar3": "byteIndex",
                "uVar4": "unused"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::marshallData_0800307a(FirmataMarshaller *marshaller, size_t numBytes, uint8_t *byteData, size_t maxBytes) {\n    uint8_t currentByte = (uint8_t)*byteData;\n    if (maxBytes == 0) {\n        maxBytes = 0xffffffff;\n    }\n    size_t byteIndex = 0;\n    size_t marshalledBytes = 0;\n    while ((byteIndex < numBytes) && (marshalledBytes < maxBytes)) {\n        (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, ((uint)byteData[byteIndex] << (marshalledBytes & 0xff) | currentByte) & 0x7f);\n        currentByte = (int)(uint)byteData[byteIndex] >> (7 - marshalledBytes & 0xff) & 0xff;\n        marshalledBytes++;\n        while ((marshalledBytes > 6) && (marshalledBytes < maxBytes)) {\n            (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, currentByte & 0x7f);\n            currentByte = currentByte >> 7;\n            marshalledBytes -= 7;\n        }\n        byteIndex++;\n    }\n    if ((marshalledBytes != 0) && (marshalledBytes < maxBytes)) {\n        (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, (1 << (marshalledBytes & 0xff)) - 1U & currentByte);\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800307a",
            "calling": [
                "sendExtendedAnalog",
                "sendSysex",
                "sendFirmwareVersion",
                "sendDigitalPort",
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "marshallData_0800307a"
        },
        "FUN_08004b80": {
            "renaming": {
                "FUN_08004b80": "do_nothing_08004b80"
            },
            "code": "\nvoid do_nothing_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b80",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004b80"
        },
        "FUN_08002ca4": {
            "renaming": {
                "FUN_08002ca4": "processStringCallback_08002ca4",
                "param_1": "callback",
                "c_str": "string",
                "PTR_currentStringCallback_08002cb4": "currentStringCallback"
            },
            "code": "void firmata::FirmataClass::processStringCallback_08002ca4(void *callback, char *string){\n  if (*(code **)PTR_currentStringCallback_08002cb4 != (code *)0x0) {\n    (**(code **)PTR_currentStringCallback_08002cb4)(string);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca4",
            "calling": [],
            "imported": false,
            "current_name": "processStringCallback_08002ca4"
        },
        "FUN_0800319e": {
            "renaming": {
                "FUN_0800319e": "sendPortData_0800319e",
                "this": "marshaller",
                "portNumber": "portNumber",
                "portData": "portData",
                "local_a": "encodedData",
                "FirmataStream": "FirmataStream"
            },
            "code": "void __thiscall FirmataMarshaller::sendPortData_0800319e(FirmataMarshaller *marshaller, uint8_t portNumber, uint16_t portData)\n{\n  uint16_t encodedData;\n  if (marshaller->FirmataStream != nullptr) {\n    encodedData = portData;\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller, portNumber & 0xf | 0x90);\n    encodeByteStream(marshaller, 2, (uint8_t *)&encodedData, 2);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800319e",
            "calling": [
                "sendDigitalPort"
            ],
            "imported": false,
            "current_name": "sendPortData_0800319e"
        },
        "FUN_08008d00": {
            "renaming": {
                "FUN_08008d00": "setReceivePin_08008d00",
                "_rx": "receivePin",
                "PVar1": "pin",
                "PTR_digitalPin_08008d14": "digitalPinToPinName",
                "NC": "NC"
            },
            "code": "void __thiscall HardwareSerial::setReceivePin_08008d00(HardwareSerial *this, uint32_t receivePin) {\n  PinName pin;\n  if (receivePin < 0x3c) {\n    pin = PTR_digitalPin_08008d14(receivePin);\n  }\n  else {\n    pin = NC;\n  }\n  (this->_serial).pin_rx = pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d00",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setReceivePin_08008d00"
        },
        "FUN_08004b82": {
            "renaming": {
                "FUN_08004b82": "i2c_handle_state_08004b82",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pbVar2": "buffer_ptr",
                "uVar3": "xfer_options"
            },
            "code": "HAL_StatusTypeDef i2c_handle_state_08004b82(I2C_HandleTypeDef *i2c_handle)\n{\n  HAL_I2C_StateTypeDef i2c_state = i2c_handle->State;\n  uint32_t xfer_options = i2c_handle->XferOptions;\n  if ((i2c_handle->XferSize == 0) && (i2c_state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((xfer_options == 4) || ((xfer_options == 8 || (xfer_options == 0xffff0000)))) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2c_handle);\n      }\n      else {\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2c_handle);\n      }\n    }\n    else {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n      i2c_handle->PreviousState = 0x11;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2c_handle);\n    }\n  }\n  else if ((i2c_state == HAL_I2C_STATE_BUSY_TX) || ((i2c_handle->Mode == HAL_I2C_MODE_MEM && (i2c_state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2c_handle->XferCount == 0) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n      if (i2c_handle->EventCount == 0) {\n        if (i2c_handle->MemaddSize == 1) {\n          i2c_handle->Instance->DR = i2c_handle->Memaddress & 0xff;\n          i2c_handle->EventCount = i2c_handle->EventCount + 2;\n        }\n        else {\n          i2c_handle->Instance->DR = (i2c_handle->Memaddress << 0x10) >> 0x18;\n          i2c_handle->EventCount = i2c_handle->EventCount + 1;\n        }\n      }\n      else if (i2c_handle->EventCount == 1) {\n        i2c_handle->Instance->DR = i2c_handle->Memaddress & 0xff;\n        i2c_handle->EventCount = i2c_handle->EventCount + 1;\n      }\n      else if (i2c_handle->EventCount == 2) {\n        if (i2c_state == HAL_I2C_STATE_BUSY_RX) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n        }\n        else if (i2c_state == HAL_I2C_STATE_BUSY_TX) {\n          uint8_t *buffer_ptr = i2c_handle->pBuffPtr;\n          i2c_handle->pBuffPtr = buffer_ptr + 1;\n          i2c_handle->Instance->DR = (uint)*buffer_ptr;\n          i2c_handle->XferCount = i2c_handle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      uint8_t *buffer_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buffer_ptr + 1;\n      i2c_handle->Instance->DR = (uint)*buffer_ptr;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b82",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_state_08004b82"
        },
        "FUN_0800997e": {
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_0800997e",
                "__s": "str",
                "__c": "c",
                "pcVar1": "occurrence",
                "pcVar2": "last_occurrence"
            },
            "code": "char * find_last_occurrence_0800997e(char *str, int c) {\n  char *last_occurrence = NULL;\n  if (c != 0) {\n    while (char *occurrence = strchr(str, c)) {\n      last_occurrence = occurrence;\n      str = occurrence + 1;\n    }\n    return last_occurrence;\n  }\n  return strchr(str, 0);\n}",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800997e",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_last_occurrence_0800997e"
        },
        "FUN_0800779c": {
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "PTR_timer_handles_080077ac": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_TIM_interrupt",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_0800779c(void)\n{\n  TIM_HandleTypeDef_conflict *timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080077ac_080077ac + 0xc);\n  if (timer_handle != NULL)\n  {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800779c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800779c"
        },
        "FUN_08002dbc": {
            "renaming": {
                "FUN_08002dbc": "initialize_firmata_08002dbc",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "PTR_Firmata_08002dd8": "firmata_instance"
            },
            "code": "void initialize_firmata_08002dbc(int should_initialize, int priority_level) {\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    firmata::FirmataClass::FirmataClass(&PTR_Firmata_08002dd8);\n  }\n  return;\n}",
            "called": [
                "FirmataClass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dbc",
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "imported": false,
            "current_name": "initialize_firmata_08002dbc"
        },
        "FUN_08007f78": {
            "renaming": {
                "FUN_08007f78": "get_i2c_t_conflict_from_hi2c_08007f78",
                "hi2c": "i2c_handler",
                "i2c_t_conflict": "i2c_conflict_type",
                "EventCount": "event_count"
            },
            "code": "i2c_t_conflict * get_i2c_t_conflict_from_hi2c_08007f78(I2C_HandleTypeDef_conflict *i2c_handler)\n{\n    return (i2c_t_conflict *)&i2c_handler[-1].EventCount;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f78",
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_t_conflict_from_hi2c_08007f78"
        },
        "FUN_08006b28": {
            "renaming": {
                "FUN_08006b28": "is_pin_high_08006b28",
                "pin": "pin",
                "map": "pin_map"
            },
            "code": "_Bool is_pin_high_08006b28(PinName_conflict pin, uint32_t *pin_map) {\n    uint32_t pin_index = (uint)((int)pin << 0x18) >> 0x1c;\n    uint32_t pin_bit = (int)pin & 0xfU;\n    uint32_t pin_value = pin_map[pin_index];\n    uint32_t masked_value = pin_value >> pin_bit;\n    return (_Bool)(masked_value & 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b28",
            "calling": [
                "digitalRead",
                "digitalWrite",
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "is_pin_high_08006b28"
        },
        "FUN_08006b1c": {
            "renaming": {
                "FUN_08006b1c": "get_uart_rx_and_general_state_08006b1c",
                "*huart": "*uart_handle",
                "huart": "uart_handle",
                "RxState": "rx_state",
                "gState": "general_state",
                "HAL_UART_StateTypeDef": "HAL_UART_StateTypeDef"
            },
            "code": "HAL_UART_StateTypeDef get_uart_rx_and_general_state_08006b1c(UART_HandleTypeDef *uart_handle)\n{\n    HAL_UART_StateTypeDef rx_state = uart_handle->RxState;\n    HAL_UART_StateTypeDef general_state = uart_handle->gState;\n    return rx_state | general_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b1c",
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "imported": false,
            "current_name": "get_uart_rx_and_general_state_08006b1c"
        },
        "FUN_0800a130": {
            "renaming": {
                "FUN_0800a130": "seek_file_0800a130",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "error_pointer",
                "iVar2": "seek_result"
            },
            "code": "void seek_file_0800a130(int *error_code, int file_descriptor, int offset, int whence) {\n  undefined *error_pointer;\n  int seek_result;\n  error_pointer = PTR_errno_0800a150;\n  *(undefined4 *)PTR_errno_0800a150 = 0;\n  seek_result = _lseek(file_descriptor, offset, whence);\n  if (seek_result == -1 && *(int *)error_pointer != 0) {\n    *error_code = *(int *)error_pointer;\n  }\n  return;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a130",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "seek_file_0800a130"
        },
        "FUN_08008f3c": {
            "renaming": {
                "FUN_08008f3c": "get_bit_position_08008f3c",
                "pin": "pin",
                "uVar1": "current_pin",
                "uVar2": "bit_position"
            },
            "code": "uint8_t get_bit_position_08008f3c(uint16_t pin)\n{\n  uint16_t current_pin = pin;\n  uint8_t bit_position = 0;\n  while (current_pin != 1) {\n    current_pin = current_pin >> 1;\n    bit_position++;\n  }\n  return bit_position;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f3c",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "get_bit_position_08008f3c"
        },
        "FUN_08002ef2": {
            "renaming": {
                "FUN_08002ef2": "sendDigitalOutputState_08002ef2",
                "pin": "pin",
                "value": "value",
                "&this->marshaller": "&marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendDigitalOutputState_08002ef2(FirmataClass* this, byte pin, int value) {\n FirmataMarshaller::sendDigitalOutputState_08002ef2(&this->marshaller, pin, (uint16_t)value);\n return;\n}",
            "called": [
                "sendAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef2",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "sendDigitalOutputState_08002ef2"
        },
        "FUN_08007332": {
            "renaming": {
                "FUN_08007332": "find_pin_name_08007332",
                "PinName_conflict": "PinName_conflict",
                "void *peripheral": "void *peripheral",
                "PinMap_conflict *map": "PinMap_conflict *map",
                "NC": "NC",
                "map->peripheral": "map->peripheral",
                "NULL": "NULL",
                "map->pin": "map->pin"
            },
            "code": "PinName_conflict find_pin_name_08007332(void *peripheral, PinMap_conflict *map) {\n  while (true) {\n    if (map->peripheral == NULL) {\n      return NC;\n    }\n    if (map->peripheral == peripheral) {\n      break;\n    }\n    map++;\n  }\n  return map->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007332",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_08007332"
        },
        "FUN_08006128": {
            "renaming": {
                "FUN_08006128": "configureTimer_08006128",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_OC_InitTypeDef": "TIM_OC_InitTypeDef",
                "htim": "timer_handle",
                "sConfig": "config",
                "Channel": "channel",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "TIM_OC1_SetConfig": "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig": "TIM_OC2_SetConfig",
                "TIM_OC3_SetConfig": "TIM_OC3_SetConfig",
                "TIM_OC4_SetConfig": "TIM_OC4_SetConfig",
                "Instance": "instance",
                "Lock": "lock",
                "State": "state",
                "HAL_OK": "HAL_OK",
                "HAL_BUSY": "HAL_BUSY"
            },
            "code": "HAL_StatusTypeDef configureTimer_08006128(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *config, uint32_t channel) {\n  if (timer_handle->lock != HAL_LOCKED) {\n    timer_handle->lock = HAL_LOCKED;\n    timer_handle->state = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n      case 0:\n        TIM_OC1_SetConfig(timer_handle->instance, config);\n        break;\n      case 4:\n        TIM_OC2_SetConfig(timer_handle->instance, config);\n        break;\n      case 8:\n        TIM_OC3_SetConfig(timer_handle->instance, config);\n        break;\n      case 0xc:\n        TIM_OC4_SetConfig(timer_handle->instance, config);\n        break;\n    }\n    timer_handle->state = HAL_TIM_STATE_READY;\n    timer_handle->lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006128",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configureTimer_08006128"
        },
        "FUN_0800a258": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a258": "set_flags",
                "PTR_id_0800a2ec": "id_0800a2ec",
                "PTR_id_0800a2f0": "id_0800a2f0",
                "PTR_id_0800a2f4": "id_0800a2f4",
                "PTR_id_0800a2f8": "id_0800a2f8",
                "PTR_id_0800a2fc": "id_0800a2fc",
                "PTR_id_0800a300": "id_0800a300",
                "PTR_id_0800a304": "id_0800a304",
                "PTR_id_0800a308": "id_0800a308",
                "PTR_id_0800a30c": "id_0800a30c",
                "PTR_id_0800a310": "id_0800a310",
                "PTR_id_0800a314": "id_0800a314",
                "PTR_id_0800a318": "id_0800a318",
                "FUN_0800a258": "set_flags_0800a258"
            },
            "code": "void set_flags_0800a258() {\n  if (PTR_id_0800a2ec < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a2ec = 1;\n  }\n  if (PTR_id_0800a2f0 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a2f0 = 1;\n  }\n  if (PTR_id_0800a2f4 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a2f4 = 1;\n  }\n  if (PTR_id_0800a2f8 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a2f8 = 1;\n  }\n  if (PTR_id_0800a2fc < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a2fc = 1;\n  }\n  if (PTR_id_0800a300 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a300 = 1;\n  }\n  if (PTR_id_0800a304 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a304 = 1;\n  }\n  if (PTR_id_0800a308 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a308 = 1;\n  }\n  if (PTR_id_0800a30c < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a30c = 1;\n  }\n  if (PTR_id_0800a310 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a310 = 1;\n  }\n  if (PTR_id_0800a314 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a314 = 1;\n  }\n  if (PTR_id_0800a318 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a318 = 1;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a258",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a258"
        },
        "FUN_08002cb8": {
            "renaming": {
                "FUN_08002cb8": "handleSysexMessage_08002cb8",
                "param_1": "callback",
                "command": "command",
                "argc": "argc",
                "argv": "argv",
                "PTR_currentSysexCallback_08002ccc": "callback",
                "code": "code"
            },
            "code": "void firmata::FirmataClass::handleSysexMessage_08002cb8(void *PTR_currentSysexCallback_08002ccc, uint8_t command, size_t argc, uint8_t *argv) {\n  if (*(code **)PTR_currentSysexCallback_08002ccc != (code *)0x0) {\n    (**(code **)PTR_currentSysexCallback_08002ccc)(command, argc & 0xff, argv, argv, argv);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb8",
            "calling": [],
            "imported": false,
            "current_name": "handleSysexMessage_08002cb8"
        },
        "FUN_08004a74": {
            "renaming": {
                "FUN_08004a74": "do_nothing_08004a74"
            },
            "code": "\nvoid do_nothing_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a74",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a74"
        },
        "FUN_08008f50": {
            "renaming": {
                "FUN_08008f50": "free_gpio_irq_configurations_08008f50",
                "param_1": "list_start",
                "puVar1": "current_node",
                "puVar2": "next_node"
            },
            "code": "void free_gpio_irq_configurations_08008f50(void *list_start){\n  undefined *current_node;\n  undefined *next_node;\n  \n  current_node = PTR___malloc_free_list_08008f70;\n  while (next_node = current_node, next_node != PTR_gpio_irq_conf_08008f74) {\n    current_node = next_node + -0x14;\n    if (*(code **)(next_node + -8) != (code *)0x0) {\n      (**(code **)(next_node + -8))(next_node + -0x10, next_node + -0x10, 3);\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f50",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configurations_08008f50"
        },
        "FUN_08004a76": {
            "renaming": {
                "FUN_08004a76": "transfer_data_08004a76",
                "hi2c": "i2c_handle",
                "HVar1": "current_state",
                "puVar2": "data_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict transfer_data_08004a76(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict current_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0) {\n    uint8_t *data_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount--;\n    if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->Instance->CR2 &= 0xfffffbff;\n      i2c_handle->PreviousState = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a76",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_data_08004a76"
        },
        "FUN_0800877c": {
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "uart_handler",
                "tmpval": "register_value"
            },
            "code": "void initialize_uart_0800877c(UART_HandleTypeDef *uart_handler)\n{\n  uint32_t register_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800877c",
            "calling": [
                "HAL_UART_IRQHandler",
                "UART_DMAAbortOnError"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800877c"
        },
        "FUN_080047f4": {
            "renaming": {
                "FUN_080047f4": "i2c_read_080047f4",
                "hi2c": "handle",
                "DevAddress": "dev_address",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "instance",
                "count": "count"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_read_080047f4(I2C_HandleTypeDef_conflict *handle, uint16_t dev_address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *instance;\n  uint32_t count;\n  \n  if (handle->State == HAL_I2C_STATE_READY) {\n    count = (uint32_t)(((uint64_t)DAT_080048c0 * (*(uint32_t *)PTR_SystemCoreClock_080048bc >> 3)) >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      instance = handle->Instance;\n      count--;\n    } while ((instance->SR2 & 2) != 0);\n    if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 |= 1;\n      }\n      handle->Instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_RX;\n      handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = DAT_080048c4;\n      handle->XferSize = handle->XferCount;\n      handle->Devaddress = (uint16_t)dev_address;\n      handle->Instance->CR1 |= 0x400;\n      handle->Instance->CR1 |= 0x100;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f4",
            "calling": [
                "i2c_master_read"
            ],
            "imported": false,
            "current_name": "i2c_read_080047f4"
        },
        "FUN_08005a48": {
            "renaming": {
                "FUN_08005a48": "get_HCLK_frequency_divided_by_APB_prescaler_08005a48",
                "PTR_APBPrescTable_08005a64": "APB_prescaler_table",
                "DAT_08005a60": "APB_prescaler_register_address"
            },
            "code": "uint32_t get_HCLK_frequency_divided_by_APB_prescaler_08005a48(void)\n{\n  uint32_t HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t APB_prescaler_index = (uint)(*(int *)(DAT_08005a60 + 4) << 0x12) >> 0x1d;\n  uint32_t APB_prescaler_value = PTR_APBPrescTable_08005a64[APB_prescaler_index];\n  return HCLK_frequency >> APB_prescaler_value;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a48",
            "calling": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "getTimerClkFreq",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divided_by_APB_prescaler_08005a48"
        },
        "FUN_080033a8": {
            "renaming": {
                "FUN_080033a8": "parseBytes_080033a8",
                "this": "parser",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "sVar2": "outIndex",
                "uVar3": "i",
                "bVar1": "firstByte"
            },
            "code": "size_t __thiscall firmata::FirmataParser::parseBytes_080033a8(FirmataParser *parser, size_t numBytes, uint8_t *byteArray)\n{\n  size_t outIndex = 0;\n  for (uint i = 0; i < numBytes; i += 2) {\n    uint8_t firstByte = byteArray[i];\n    uint8_t secondByte = byteArray[i + 1];\n    byteArray[outIndex] = firstByte;\n    byteArray[outIndex] = (secondByte << 7) | firstByte;\n    outIndex++;\n  }\n  return outIndex;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033a8",
            "calling": [
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "parseBytes_080033a8"
        },
        "FUN_08008d18": {
            "renaming": {
                "FUN_08008d18": "setSerialTxPin_08008d18",
                "this": "serial",
                "_tx": "txPinNumber",
                "PVar1": "txPin",
                "PTR_digitalPin_08008d2c": "digitalPin",
                "NC": "NC"
            },
            "code": "void __thiscall setSerialTxPin_08008d18(HardwareSerial *serial, uint32_t txPinNumber) {\n  PinName txPin;\n  if (txPinNumber < 0x3c) {\n    txPin = PTR_digitalPin_08008d2c[txPinNumber];\n  }\n  else {\n    txPin = NC;\n  }\n  (serial->_serial).pin_tx = txPin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d18",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setSerialTxPin_08008d18"
        },
        "FUN_0800a020": {
            "renaming": {
                "FUN_0800a020": "read_and_update_data_0800a020",
                "param_1": "buffer",
                "param_2": "buffer_offset",
                "iVar1": "bytes_read",
                "uVar2": "updated_value",
                "bVar3": "is_read_successful"
            },
            "code": "void read_and_update_data_0800a020(void* buffer, int buffer_offset) {\n  int bytes_read = _read_r(buffer, (int)*(short *)(buffer_offset + 0xe));\n  bool is_read_successful = bytes_read >= 0;\n  uint updated_value;\n  if (is_read_successful) {\n    updated_value = *(int *)(buffer_offset + 0x54) + bytes_read;\n  }\n  else {\n    updated_value = *(ushort *)(buffer_offset + 0xc) & 0xffffefff;\n  }\n  if (is_read_successful) {\n    *(uint *)(buffer_offset + 0x54) = updated_value;\n  }\n  if (!is_read_successful) {\n    *(short *)(buffer_offset + 0xc) = (short)updated_value;\n  }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a020",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_data_0800a020"
        },
        "FUN_08007f7c": {
            "renaming": {
                "FUN_08007f7c": "set_on_slave_receive_callback_08007f7c",
                "obj": "i2c_conflict_obj",
                "function": "on_slave_receive_callback",
                "i2c_onSlaveReceive": "on_slave_receive",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt"
            },
            "code": "void set_on_slave_receive_callback_08007f7c(i2c_t_conflict *i2c_conflict_obj, _func_void_uint8_t_ptr_int *on_slave_receive_callback) {\n    if (i2c_conflict_obj != NULL) {\n        if (on_slave_receive_callback != NULL) {\n            i2c_conflict_obj->i2c_onSlaveReceive = on_slave_receive_callback;\n            HAL_I2C_EnableListen_IT(&(i2c_conflict_obj->handle));\n        }\n    }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f7c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_on_slave_receive_callback_08007f7c"
        },
        "FUN_08006d80": {
            "renaming": {
                "FUN_08006d80": "read_pin_voltage_08006d80",
                "PinName_conflict": "pin",
                "HAL_StatusTypeDef_conflict": "hal_status",
                "uint32_t": "adc_value",
                "uint16_t": "voltage",
                "ADC_ChannelConfTypeDef": "adc_channel_conf",
                "ADC_HandleTypeDef": "adc_handle",
                "memset": "memset",
                "PTR_PinMap_ADC_08006e60": "PinMap_ADC",
                "ADC_TypeDef": "ADC",
                "ADC_DATAALIGN_RIGHT": "ADC_DATAALIGN_RIGHT",
                "DISABLE": "DISABLE",
                "ADC_SOFTWARE_START": "ADC_SOFTWARE_START",
                "g_current_pin_08006e64": "g_current_pin",
                "get_adc_channel": "get_adc_channel",
                "ADC_SAMPLETIME_2CYCLES_5": "ADC_SAMPLETIME_2CYCLES_5",
                "HAL_ADC_Init": "HAL_ADC_Init",
                "HAL_ADC_ConfigChannel": "HAL_ADC_ConfigChannel",
                "HAL_ADCEx_Calibration_Start": "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start": "HAL_ADC_Start",
                "HAL_ADC_PollForConversion": "HAL_ADC_PollForConversion",
                "HAL_ADC_GetState": "HAL_ADC_GetState",
                "HAL_ADC_STATE_REG_EOC": "HAL_ADC_STATE_REG_EOC",
                "HAL_ADC_GetValue": "HAL_ADC_GetValue",
                "HAL_ADC_Stop": "HAL_ADC_Stop",
                "HAL_ADC_DeInit": "HAL_ADC_DeInit"
            },
            "code": "uint16_t read_pin_voltage_08006d80(PinName_conflict pin)\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t adc_value;\n  uint16_t voltage;\n  ADC_ChannelConfTypeDef adc_channel_conf;\n  ADC_HandleTypeDef adc_handle;\n  memset(&adc_handle, 0, sizeof(ADC_HandleTypeDef));\n  adc_channel_conf.Channel = 0;\n  adc_channel_conf.Rank = 0;\n  adc_channel_conf.SamplingTime = 0;\n  voltage = 0;\n  adc_handle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PTR_PinMap_ADC_08006e60_08006e60);\n  if (adc_handle.Instance == (ADC_TypeDef *)0x0) {\n    voltage = 0;\n  }\n  else {\n    adc_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n    adc_handle.Init.ScanConvMode = DISABLE;\n    adc_handle.Init.ContinuousConvMode = DISABLE;\n    adc_handle.Init.DiscontinuousConvMode = DISABLE;\n    adc_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n    adc_handle.State = 0;\n    adc_handle.Init.NbrOfConversion = 1;\n    adc_handle.Init.NbrOfDiscConversion = 0;\n    *g_current_pin = pin;\n    hal_status = HAL_ADC_Init(&adc_handle);\n    if (hal_status == HAL_OK) {\n      adc_channel_conf.Channel = get_adc_channel(pin);\n      if (adc_channel_conf.Channel < 0x12) {\n        adc_channel_conf.Rank = 1;\n        adc_channel_conf.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;\n        hal_status = HAL_ADC_ConfigChannel(&adc_handle, &adc_channel_conf);\n        if (hal_status == HAL_OK) {\n          hal_status = HAL_ADCEx_Calibration_Start(&adc_handle);\n          if (hal_status == HAL_OK) {\n            hal_status = HAL_ADC_Start(&adc_handle);\n            if (hal_status == HAL_OK) {\n              hal_status = HAL_ADC_PollForConversion(&adc_handle, 10);\n              if (hal_status == HAL_OK) {\n                uint32_t adc_state = HAL_ADC_GetState(&adc_handle);\n                if ((adc_state & HAL_ADC_STATE_REG_EOC) != 0) {\n                  adc_value = HAL_ADC_GetValue(&adc_handle);\n                  voltage = (uint16_t)adc_value;\n                }\n                hal_status = HAL_ADC_Stop(&adc_handle);\n                if (hal_status != HAL_OK) {\n                  voltage = 0;\n                }\n              }\n              else {\n                voltage = 0;\n              }\n            }\n            else {\n              voltage = 0;\n            }\n          }\n          else {\n            voltage = 0;\n          }\n        }\n        else {\n          voltage = 0;\n        }\n      }\n      else {\n        voltage = 0;\n      }\n      hal_status = HAL_ADC_DeInit(&adc_handle);\n      if (hal_status != HAL_OK) {\n        voltage = 0;\n      }\n    }\n    else {\n      voltage = 0;\n    }\n  }\n  return voltage;\n}",
            "called": [
                "get_adc_channel",
                "memset",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_Stop",
                "HAL_ADC_GetState",
                "pinmap_peripheral",
                "HAL_ADC_DeInit",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "HAL_ADC_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d80",
            "calling": [
                "analogRead"
            ],
            "imported": false,
            "current_name": "read_pin_voltage_08006d80"
        },
        "FUN_08006c60": {
            "renaming": {
                "FUN_08006c60": "get_adc_channel_from_pin_08006c60",
                "pin": "pin",
                "uVar1": "function_index",
                "PTR_PinMap_ADC_08006c78": "PTR_PinMap_ADC_08006c78",
                "PinMap_conflict": "PinMap_conflict",
                "0xc": "shift_bits_left",
                "0x1b": "shift_bits_right",
                "0x10": "max_channel_index",
                "channel": "channel"
            },
            "code": "uint32_t get_adc_channel_from_pin_08006c60(PinName_conflict pin) {\n  uint32_t function_index = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_ADC_08006c78);\n  uint32_t channel = (function_index << 12) >> 27;\n  if (channel > 15) {\n    channel = 0;\n  }\n  return channel;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c60",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_channel_from_pin_08006c60"
        },
        "FUN_08008e40": {
            "renaming": {
                "FUN_08008e40": "initialize_static_data_08008e40"
            },
            "code": "void initialize_static_data_08008e40(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e40",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08008e40"
        },
        "FUN_080045c0": {
            "renaming": {
                "FUN_080045c0": "configureI2C_080045c0",
                "hi2c": "i2c_handle",
                "bVar1": "is_valid_clock_speed",
                "uVar2": "pclk1_freq",
                "uVar3": "clock_speed",
                "uVar4": "duty_cycle",
                "uVar5": "rise_time"
            },
            "code": "HAL_StatusTypeDef_conflict configureI2C_080045c0(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n    bool is_valid_clock_speed;\n    uint32_t pclk1_freq, prescaler_value, rise_time;\n    uint clock_speed, duty_cycle, ccr_value;\n\n    if (i2c_handle == (I2C_HandleTypeDef_conflict *)0x0) {\n        return HAL_ERROR;\n    }\n\n    if (i2c_handle->State == HAL_I2C_STATE_RESET) {\n        i2c_handle->Lock = HAL_UNLOCKED;\n        HAL_I2C_MspInit(i2c_handle);\n    }\n\n    i2c_handle->State = HAL_I2C_STATE_BUSY;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffffe;\n    pclk1_freq = HAL_RCC_GetPCLK1Freq();\n    clock_speed = (i2c_handle->Init).ClockSpeed;\n\n    if (clock_speed <= 100000) {\n        is_valid_clock_speed = pclk1_freq >= 4000000;\n    }\n    else {\n        is_valid_clock_speed = pclk1_freq >= 16000000;\n    }\n\n    if (!is_valid_clock_speed) {\n        return HAL_ERROR;\n    }\n\n    prescaler_value = (uint)((ulonglong)0x4B * (ulonglong)pclk1_freq / (uint)(clock_speed * 25));\n    i2c_handle->Instance->CR2 = (prescaler_value & 0x3FF);\n\n    if (clock_speed <= 100000) {\n        rise_time = (uint)((ulonglong)300 * prescaler_value / 1000) + 1;\n    }\n    else {\n        duty_cycle = (i2c_handle->Init).DutyCycle;\n        if (duty_cycle == 0) {\n            rise_time = (uint)((ulonglong)3 * prescaler_value / 1000) + 1;\n        }\n        else {\n            rise_time = (uint)((ulonglong)25 * prescaler_value / 1000) + 1;\n        }\n    }\n\n    i2c_handle->Instance->TRISE = (rise_time & 0x3F);\n    ccr_value = 0;\n\n    if (clock_speed <= 100000) {\n        ccr_value = (uint)(pclk1_freq / (clock_speed << 1));\n        if (ccr_value < 4) {\n            ccr_value = 4;\n        }\n    }\n    else {\n        if (duty_cycle == 0) {\n            ccr_value = (uint)((pclk1_freq * 2) / (clock_speed * 3));\n        }\n        else {\n            ccr_value = (uint)(pclk1_freq / (clock_speed * 2));\n        }\n\n        if (ccr_value < 0x1) {\n            ccr_value = 0x1;\n        }\n        else if (ccr_value > 0xFFF) {\n            ccr_value = 0xFFF;\n        }\n    }\n\n    i2c_handle->Instance->CCR = ccr_value;\n    i2c_handle->Instance->CR1 = (i2c_handle->Init).GeneralCallMode | (i2c_handle->Init).NoStretchMode;\n    i2c_handle->Instance->OAR1 = (i2c_handle->Init).AddressingMode | (i2c_handle->Init).OwnAddress1;\n    i2c_handle->Instance->OAR2 = (i2c_handle->Init).DualAddressMode | (i2c_handle->Init).OwnAddress2;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 1;\n    i2c_handle->ErrorCode = 0;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->PreviousState = 0;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c0",
            "calling": [
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configureI2C_080045c0"
        },
        "FUN_08007e74": {
            "renaming": {
                "FUN_08007e74": "transmit_i2c_data_08007e74",
                "*obj": "i2c_handle",
                "dev_address": "device_address",
                "*data": "data",
                "size": "size",
                "HVar1": "i2c_state",
                "HVar2": "i2c_status",
                "uVar3": "start_time",
                "uVar4": "i2c_error",
                "uVar5": "elapsed_time",
                "iVar6": "status",
                "hi2c": "i2c_handle"
            },
            "code": "i2c_status_e_conflict transmit_i2c_data_08007e74(I2C_HandleTypeDef_conflict *i2c_handle, uint8_t device_address, uint8_t *data, uint16_t size)\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  HAL_StatusTypeDef_conflict i2c_status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t elapsed_time = 0;\n  i2c_status_e_conflict status = I2C_ERROR;\n  do {\n    i2c_status = HAL_I2C_Master_Transmit_IT(i2c_handle, (uint16_t)device_address, data, size);\n    if (i2c_status == HAL_OK) {\n      status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(i2c_handle), i2c_state != HAL_I2C_STATE_READY && (status == I2C_OK))) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time < 0x65) {\n          uint32_t i2c_error = HAL_I2C_GetError(i2c_handle);\n          if (i2c_error != 0) {\n            status = I2C_ERROR;\n          }\n        }\n        else {\n          status = I2C_TIMEOUT;\n        }\n      }\n    }\n    uint32_t i2c_error = HAL_I2C_GetError(i2c_handle);\n  } while ((i2c_error == 4) && (elapsed_time < 100));\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e74",
            "calling": [
                "endTransmission"
            ],
            "imported": false,
            "current_name": "transmit_i2c_data_08007e74"
        },
        "FUN_08002efe": {
            "renaming": {
                "FUN_08002efe": "updatePortData_08002efe",
                "this": "firmataInstance",
                "portNumber": "portNumber",
                "portData": "portData",
                "FirmataMarshaller::FUN_08002efe": "FirmataMarshaller::updatePortData",
                "&this->marshaller": "&firmataInstance->marshaller",
                "uint16_t": "uint16_t"
            },
            "code": "void __thiscall firmata::FirmataClass::updatePortData_08002efe(FirmataClass *firmataInstance, byte portNumber, int portData) {\n    FirmataMarshaller::updatePortData_08002efe(&firmataInstance->marshaller, portNumber, (uint16_t)portData);\n    return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efe",
            "calling": [
                "outputPort"
            ],
            "imported": false,
            "current_name": "updatePortData_08002efe"
        },
        "FUN_08002ddc": {
            "renaming": {
                "FUN_08002ddc": "sendFirmwareVersion_08002ddc",
                "&this": "*firmataClass",
                "FirmataMarshaller::sendVersion": "sendVersion",
                "&this->marshaller": "*marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendFirmwareVersion_08002ddc(FirmataClass *this)\n{\n  FirmataMarshaller::sendVersion(&this->marshaller,'\\x02','\\x05');\n  return;\n}",
            "called": [
                "sendVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ddc",
            "calling": [
                "staticReportVersionCallback",
                "begin"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_08002ddc"
        },
        "FUN_08009f2c": {
            "renaming": {
                "FUN_08009f2c": "find_byte_08009f2c",
                "__s": "buffer",
                "__c": "byte_to_find",
                "__n": "buffer_size",
                "pbVar1": "current_byte",
                "pbVar2": "previous_byte"
            },
            "code": "void * find_byte_08009f2c(void *buffer, int byte_to_find, size_t buffer_size) {\n  unsigned char *current_byte = (unsigned char*)buffer;\n  while (current_byte < (unsigned char*)(buffer_size + (int)buffer)) {\n    if (*current_byte == (byte_to_find & 0xff)) {\n      return current_byte;\n    }\n    current_byte++;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f2c",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_08009f2c"
        },
        "FUN_0800a154": {
            "renaming": {
                "FUN_0800a154": "calculate_value_0800a154",
                "param_1": "base_value",
                "param_2": "offset",
                "iVar1": "new_offset"
            },
            "code": "int calculate_value_0800a154(int base_value, int offset)\n{\n  int new_offset = base_value - 4;\n  if (base_value < 0) {\n    new_offset += *(int *)(offset + new_offset);\n  }\n  return new_offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a154",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_0800a154"
        },
        "FUN_08007f8e": {
            "renaming": {
                "FUN_08007f8e": "set_i2c_slave_transmit_callback_08007f8e",
                "obj": "i2c_obj",
                "function": "callback_func",
                "i2c_onSlaveTransmit": "callback_func_ptr"
            },
            "code": "void set_i2c_slave_transmit_callback_08007f8e(i2c_t_conflict *i2c_obj, _func_void *callback_func) {\n    if (i2c_obj != NULL) {\n        if (callback_func != NULL) {\n            i2c_obj->i2c_onSlaveTransmit = callback_func;\n            HAL_I2C_EnableListen_IT(&(i2c_obj->handle));\n        }\n    }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f8e",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_transmit_callback_08007f8e"
        },
        "FUN_08006b3e": {
            "renaming": {
                "FUN_08006b3e": "set_pin_state_08006b3e",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_state_08006b3e(PinName_conflict pin, uint32_t *pin_map) {\n  uint32_t pin_index = (uint32_t)((int)pin << 24) >> 28;\n  pin_map[pin_index] |= 1 << ((int)pin & 0xF);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b3e",
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_state_08006b3e"
        },
        "FUN_08006262": {
            "renaming": {
                "FUN_08006262": "set_TIMx_Channel_State_08006262",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channel_state",
                "CCER": "channel_control_register"
            },
            "code": "void set_TIMx_Channel_State_08006262(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t channel_state) {\n  uint32_t channel_mask = 1 << (channel & 0xff);\n  timer->CCER &= ~channel_mask;\n  timer->CCER |= channel_state << (channel & 0xff);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006262",
            "calling": [
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "set_TIMx_Channel_State_08006262"
        },
        "FUN_08007110": {
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110",
                "*htim": "*timer_handle"
            },
            "code": "void disable_timer_clock_08007110(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007110",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007110"
        },
        "FUN_08007594": {
            "renaming": {
                "FUN_08007594": "determineTimerInstance_08007594",
                "tim": "timer",
                "DAT_080075d0": "timer1",
                "DAT_080075d4": "timer2",
                "PTR_s_TIM__Unknown_timer_instance_080075d8": "unknownTimerInstance"
            },
            "code": "uint8_t determineTimerInstance_08007594(TIM_TypeDef_conflict *timer) {\\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\\n    return \"\\0\";\\n  }\\n  if (timer == DAT_080075d0) {\\n    return \"\\x01\";\\n  }\\n  if (DAT_080075d0 < timer) {\\n    if (timer == DAT_080075d4) {\\n      return \"\\x01\";\\n    }\\n    if (timer == (TIM_TypeDef_conflict *)&DAT_080075d4[0x379].DMAR) {\\n      return \"\\x02\";\\n    }\\n  }\\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\\n    return \"\\x01\";\\n  }\\n  iprintf(PTR_s_TIM__Unknown_timer_instance_080075d8);\\n  return \"\\0\";\\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007594",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "determineTimerInstance_08007594"
        },
        "FUN_08002cd0": {
            "renaming": {
                "FUN_08002cd0": "system_reset_callback_08002cd0",
                "param_1": "reset_callback",
                "PTR_currentSystemResetCallback_08002cdc": "current_system_reset_callback",
                "**(code **)PTR_currentSystemResetCallback_08002cdc": "**(code **)current_system_reset_callback"
            },
            "code": "void firmata::FirmataClass::system_reset_callback_08002cd0(void *reset_callback) {\n  if (*(code **)PTR_currentSystemResetCallback_08002cdc != (code *)0x0) {\n    (**(code **)PTR_currentSystemResetCallback_08002cdc)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cd0",
            "calling": [],
            "imported": false,
            "current_name": "system_reset_callback_08002cd0"
        },
        "FUN_08002df6": {
            "renaming": {
                "FUN_08002df6": "sendFirmwareVersionIfAvailable_08002df6",
                "this": "firmataClassInstance",
                "puVar1": "firmwareVersionVector",
                "firmwareVersionCount": "firmwareVersionCount",
                "FirmataMarshaller::sendFirmwareVersion": "FirmataMarshaller::sendFirmwareVersion",
                "&this->marshaller": "&firmataClassInstance->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendFirmwareVersionIfAvailable_08002df6(FirmataClass *firmataClassInstance)\n{\n  uint8_t *firmwareVersionVector;\n  int firmwareVersionCount;\n  firmwareVersionCount = firmataClassInstance->firmwareVersionCount;\n  if (firmwareVersionCount == 0) {\n    return;\n  }\n  firmwareVersionVector = firmataClassInstance->firmwareVersionVector;\n  FirmataMarshaller::sendFirmwareVersion\n            (&firmataClassInstance->marshaller,*firmwareVersionVector,firmwareVersionVector[1],firmwareVersionCount - 2,firmwareVersionVector + 2);\n  return;\n}",
            "called": [
                "sendFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002df6",
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersionIfAvailable_08002df6"
        },
        "FUN_080045bc": {
            "renaming": {
                "FUN_080045bc": "do_nothing_080045bc"
            },
            "code": "\nvoid do_nothing_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045bc",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080045bc"
        },
        "FUN_08007118": {
            "renaming": {
                "FUN_08007118": "configure_pwm_pin_08007118",
                "pin": "pin_name",
                "clock_freq": "clock_frequency",
                "period": "period_value",
                "value": "duty_cycle",
                "do_init": "initialize_pwm",
                "HVar1": "status",
                "uVar2": "timer_clk_freq",
                "uVar3": "pwm_function",
                "timConfig": "pwm_config",
                "timHandle": "timer_handle",
                "Instance": "timer_instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "TIM_OC_InitTypeDef": "TIM_OC_InitTypeDef",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "memset": "memset",
                "PTR_PinMap_PWM_080071dc": "PinMap_PWM",
                "getTimerClkFreq": "get_timer_clk_freq",
                "get_pwm_channel": "get_pwm_channel",
                "HAL_TIM_PWM_Init": "HAL_TIM_PWM_Init",
                "HAL_TIM_PWM_ConfigChannel": "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start": "HAL_TIM_PWM_Start",
                "HAL_TIMEx_PWMN_Start": "HAL_TIMEx_PWMN_Start",
                "DAT_080071e0": "current_pin"
            },
            "code": "void configure_pwm_pin_08007118(PinName pin_name, uint32_t clock_freq, uint32_t period, uint32_t duty_cycle, uint8_t do_init)\n{\n  HAL_StatusTypeDef status;\n  uint32_t timer_clk_freq;\n  uint32_t pwm_channel;\n  TIM_OC_InitTypeDef pwm_config;\n  TIM_HandleTypeDef timer_handle;\n  memset(&timer_handle, 0, sizeof(timer_handle));\n  pwm_config.OCMode = TIM_OCMODE_PWM1;\n  pwm_config.Pulse = 0;\n  pwm_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  pwm_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  pwm_config.OCFastMode = TIM_OCFAST_DISABLE;\n  pwm_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  pwm_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_handle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin_name, (PinMap *)PTR_PinMap_PWM_080071dc);\n  if (timer_handle.Instance != (TIM_TypeDef *)0x0) {\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_freq - 1;\n    timer_handle.Init.Period = period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = TIM_COUNTERMODE_UP;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if (do_init == 1) {\n      DAT_080071e0 = pin_name;\n      status = HAL_TIM_PWM_Init(&timer_handle);\n      if (status != HAL_OK) {\n        return;\n      }\n    }\n    pwm_channel = get_pwm_channel(pin_name);\n    if (pwm_channel == TIM_CHANNEL_1 || pwm_channel == TIM_CHANNEL_2 || pwm_channel == TIM_CHANNEL_3 || pwm_channel == TIM_CHANNEL_4 || pwm_channel == TIM_CHANNEL_5 || pwm_channel == TIM_CHANNEL_6) {\n      pwm_config.OCMode = TIM_OCMODE_PWM1;\n      pwm_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n      pwm_config.OCFastMode = TIM_OCFAST_DISABLE;\n      pwm_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n      pwm_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n      pwm_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n      pwm_config.Pulse = duty_cycle;\n      status = HAL_TIM_PWM_ConfigChannel(&timer_handle, &pwm_config, pwm_channel);\n      if (status == HAL_OK) {\n        uint32_t pwm_function = pinmap_function(pin_name, (PinMap *)PTR_PinMap_PWM_080071dc);\n        if ((pwm_function & 0x100000) == 0) {\n          HAL_TIM_PWM_Start(&timer_handle, pwm_channel);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(&timer_handle, pwm_channel);\n        }\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "pinmap_function",
                "memset",
                "get_pwm_channel",
                "HAL_TIM_PWM_Init",
                "getTimerClkFreq",
                "HAL_TIMEx_PWMN_Start",
                "pinmap_peripheral",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007118",
            "calling": [
                "analogWrite"
            ],
            "imported": false,
            "current_name": "configure_pwm_pin_08007118"
        },
        "FUN_08001be8": {
            "renaming": {
                "FUN_08001be8": "initialize_static_data_and_destructors_08001be8"
            },
            "code": "void initialize_static_data_and_destructors_08001be8(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001be8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_and_destructors_08001be8"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "configure_RCC_clock_08005a68",
                "RCC_ClkInitStruct": "clk_init_struct",
                "pFLatency": "flash_latency",
                "iVar1": "data_loc",
                "DAT_08005a9c": "DATA_LOCATION",
                "RCC_ClkInitStruct->ClockType": "RCC_CLOCK_TYPE_ALL",
                "RCC_ClkInitStruct->SYSCLKSource": "RCC_SYSCLK_SOURCE_MASK",
                "RCC_ClkInitStruct->AHBCLKDivider": "RCC_AHBCLK_DIVIDER_MASK",
                "RCC_ClkInitStruct->APB1CLKDivider": "RCC_APB1CLK_DIVIDER_MASK",
                "RCC_ClkInitStruct->APB2CLKDivider": "RCC_APB2CLK_DIVIDER_MASK",
                "*pFLatency": "*FLASH_LATENCY_POINTER",
                "*DAT_08005aa0": "*FLASH_LATENCY_POINTER",
                "7": "FLASH_LATENCY_MASK"
            },
            "code": "void configure_RCC_clock_08005a68(RCC_ClkInitTypeDef_conflict *clk_init_struct, uint32_t *flash_latency){\n  int data_loc = DAT_08005a9c;\n  clk_init_struct->ClockType = RCC_CLOCK_TYPE_ALL;\n  clk_init_struct->SYSCLKSource = *(uint *)(data_loc + 4) & RCC_SYSCLK_SOURCE_MASK;\n  clk_init_struct->AHBCLKDivider = *(uint *)(data_loc + 4) & RCC_AHBCLK_DIVIDER_MASK;\n  clk_init_struct->APB1CLKDivider = *(uint *)(data_loc + 4) & RCC_APB1CLK_DIVIDER_MASK;\n  clk_init_struct->APB2CLKDivider = *(uint *)(data_loc + 4) >> 3 & RCC_APB2CLK_DIVIDER_MASK;\n  *flash_latency = *DAT_08005aa0 & FLASH_LATENCY_MASK;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "configure_RCC_clock_08005a68"
        },
        "FUN_08008f78": {
            "renaming": {
                "FUN_08008f78": "configure_gpio_irq_08008f78",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "puVar1": "gpio_irq_conf_ptr"
            },
            "code": "void configure_gpio_irq_08008f78(int should_initialize, int priority) {\n    undefined *gpio_irq_conf_ptr;\n    gpio_irq_conf_ptr = PTR_gpio_irq_conf_08009018;\n    if (should_initialize != 1) {\n        return;\n    }\n    if (priority == 0xffff) {\n        gpio_irq_conf_ptr[0] = 6;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xc) = 0;\n        gpio_irq_conf_ptr[0x14] = 7;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x20) = 0;\n        gpio_irq_conf_ptr[0x28] = 8;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x34) = 0;\n        gpio_irq_conf_ptr[0x3c] = 9;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x48) = 0;\n        gpio_irq_conf_ptr[0x50] = 10;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x5c) = 0;\n        gpio_irq_conf_ptr[100] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x70) = 0;\n        gpio_irq_conf_ptr[0x78] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x84) = 0;\n        gpio_irq_conf_ptr[0x8c] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x98) = 0;\n        gpio_irq_conf_ptr[0xa0] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xac) = 0;\n        gpio_irq_conf_ptr[0xb4] = 0x17;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xc0) = 0;\n        gpio_irq_conf_ptr[200] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xd4) = 0;\n        gpio_irq_conf_ptr[0xdc] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xe8) = 0;\n        gpio_irq_conf_ptr[0xf0] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0xfc) = 0;\n        gpio_irq_conf_ptr[0x104] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x110) = 0;\n        gpio_irq_conf_ptr[0x118] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x124) = 0;\n        gpio_irq_conf_ptr[300] = 0x28;\n        *(undefined4 *)(gpio_irq_conf_ptr + 0x138) = 0;\n        __aeabi_atexit(0, DAT_08009020, PTR___dso_handle_0800901c);\n    }\n    return;\n}",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f78",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "configure_gpio_irq_08008f78"
        },
        "FUN_08002dea": {
            "renaming": {
                "FUN_08002dea": "printFirmataVersion_08002dea",
                "context": "firmataContext"
            },
            "code": "void firmata::FirmataClass::printFirmataVersion_08002dea(void *firmataContext) {\n  if (firmataContext != nullptr) {\n    printVersion((FirmataClass *)firmataContext);\n    return;\n  }\n  return;\n}",
            "called": [
                "printVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dea",
            "calling": [],
            "imported": false,
            "current_name": "printFirmataVersion_08002dea"
        },
        "FUN_08008d30": {
            "renaming": {
                "FUN_08008d30::FUN_08008d30": "initializeSerial",
                "*this": "serial_obj",
                "peripheral": "peripheral",
                "PVar1": "rx_pin",
                "extraout_r1": "ctx2",
                "ctx": "ctx1",
                "extraout_r1_00": "ctx1",
                "(this->super_Stream).super_Print.write_error": "(serial_obj->super_Stream).super_Print.write_error",
                "(this->super_Stream)._timeout": "(serial_obj->super_Stream)._timeout",
                "(this->super_Stream).super_Print._vptr_Print": "(serial_obj->super_Stream).super_Print._vptr_Print",
                "(this == (FUN_08008d30 *)PTR_Serial2_08008d80)": "(serial_obj == (FUN_08008d30 *)Serial2_ptr)",
                "setRx(this,0)": "setRx(serial_obj,0)",
                "setTx(this,1)": "setTx(serial_obj,1)",
                "(this->_serial).pin_rx": "(serial_obj->_serial).pin_rx",
                "(this->_serial).pin_tx": "(serial_obj->_serial).pin_tx",
                "PTR_PinMap_UART_RX_08008d84": "UART_RX_PinMap_ptr",
                "PTR_PinMap_UART_TX_08008d88": "UART_TX_PinMap_ptr",
                "init(this,ctx)": "init(serial_obj,ctx1,ctx2)",
                "FUN_08008d30": "initializeSerial_08008d30"
            },
            "code": "initializeSerial_08008d30 * __thiscall initializeSerial_08008d30(initializeSerial_08008d30 *serial_obj,void *peripheral) \\n\\\n{\\n\\\n  PinName rx_pin;\\n\\\n  EVP_PKEY_CTX *ctx1;\\n\\\n  EVP_PKEY_CTX *ctx2;\\n\\\n  (serial_obj->super_Stream).super_Print.write_error = 0;\\n\\\n  (serial_obj->super_Stream)._timeout = 1000;\\n\\\n  (serial_obj->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)write_ptr_ptr;\\n\\\n  if (this == (initializeSerial_08008d30 *)PTR_Serial2_08008d80) {\\n\\\n    setRx(serial_obj,0);\\n\\\n    setTx(serial_obj,1);\\n\\\n    ctx1 = extraout_r1_ptr;\\n\\\n  }\\n\\\n  else {\\n\\\n    rx_pin = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_08008d84);\\n\\\n    (serial_obj->_serial).pin_rx = rx_pin;\\n\\\n    PinName tx_pin = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_TX_08008d88);\\n\\\n    (serial_obj->_serial).pin_tx = tx_pin;\\n\\\n    ctx2 = extraout_r1_ptr;\\n\\\n  }\\n\\\n  init(serial_obj,ctx1,ctx2);\\n\\\n  return serial_obj;\\n\\\n}",
            "called": [
                "init",
                "pinmap_pin",
                "setTx",
                "setRx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d30",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initializeSerial_08008d30"
        },
        "FUN_0800734a": {
            "renaming": {
                "FUN_0800734a": "find_pin_for_peripheral_0800734a",
                "map": "pin_map",
                "PVar1": "pin_name"
            },
            "code": "PinName_conflict find_pin_for_peripheral_0800734a(void *peripheral, PinMap_conflict *pin_map) {\n  PinName_conflict pin_name;\n  if (peripheral != NULL) {\n    pin_name = pinmap_find_pin(peripheral, pin_map);\n    return pin_name;\n  }\n  return NC;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800734a",
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_0800734a"
        },
        "FUN_08000aec": {
            "renaming": {
                "FUN_08000aec": "initializePins_08000aec",
                "PTR_isResetting_08000bc0": "isResettingPtr",
                "PTR_isI2CEnabled_08000bc4": "isI2CEnabledPtr",
                "disableI2CPins": "disableI2CPins",
                "PTR_reportPINs_08000bc8": "reportPINsPtr",
                "PTR_portConfigInputs_08000bcc": "portConfigInputsPtr",
                "PTR_previousPINs_08000bd0": "previousPINsPtr",
                "PinName_conflict": "PinName",
                "uint32_t": "uint32_t",
                "uint": "uint",
                "digitalPinPtr": "digitalPinPtr",
                "NC": "NC",
                "pinNametoDigitalPin": "pinNametoDigitalPin",
                "bool": "bool",
                "setPinModeCallback": "setPinModeCallback",
                "byte": "byte",
                "PTR_servoPinMap_08000bd8": "servoPinMapPtr",
                "undefined4": "undefined4",
                "PTR_analogInputsToReport_08000bdc": "analogInputsToReportPtr",
                "PTR_detachedServoCount_08000be0": "detachedServoCountPtr",
                "PTR_servoCount_08000be4": "servoCountPtr"
            },
            "code": "void initializePins_08000aec()\n{\n  bool isI2CEnabled = *PTR_isI2CEnabled_08000bc4;\n  *PTR_isResetting_08000bc0 = true;\n  if (isI2CEnabled) {\n    disableI2CPins();\n  }\n  for (int i = 0; i < 5; i++) {\n    PTR_reportPINs_08000bc8[i] = 0;\n    PTR_portConfigInputs_08000bcc[i] = 0;\n    PTR_previousPINs_08000bd0[i] = 0;\n  }\n  for (int i = 0; i < 60; i++) {\n    bool isPinServo = false;\n    if ((i >= 46) && (i < 60)) {\n      isPinServo = false;\n    }\n    else {\n      PinName_conflict pin = (i < 60) ? digitalPinPtr[i] : NC;\n      uint32_t digitalPin = pinNametoDigitalPin(pin);\n      if (digitalPin == 0) {\n        isPinServo = false;\n      }\n      else {\n        digitalPin = pinNametoDigitalPin(pin);\n        if (digitalPin == 1) {\n          isPinServo = false;\n        }\n        else {\n          isPinServo = true;\n        }\n      }\n    }\n    if (isPinServo) {\n      setPinModeCallback((byte)i, 2);\n    }\n    else {\n      if ((i < 60) && (digitalPinPtr[i] != NC)) {\n        uint32_t digitalPin = pinNametoDigitalPin(digitalPinPtr[i]);\n        if ((digitalPin != 0) && (digitalPin != 1)) {\n          isPinServo = true;\n        }\n      }\n      if (isPinServo) {\n        setPinModeCallback((byte)i, 1);\n      }\n    }\n    PTR_servoPinMap_08000bd8[i] = 0xff;\n  }\n  *PTR_analogInputsToReport_08000bdc = 0;\n  *PTR_detachedServoCount_08000be0 = 0;\n  *PTR_servoCount_08000be4 = 0;\n  *PTR_isResetting_08000bc0 = false;\n  return;\n}\n",
            "called": [
                "disableI2CPins",
                "pinNametoDigitalPin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aec",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initializePins_08000aec"
        },
        "FUN_080068d6": {
            "renaming": {
                "FUN_080068d6": "receiveUARTData_080068d6",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "pRxBuffPtr": "pRxBuffPtr",
                "RxXferSize": "RxXferSize",
                "RxXferCount": "RxXferCount",
                "ErrorCode": "ErrorCode",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "Instance",
                "CR1": "CR1",
                "CR3": "CR3",
                "USART_CR1_RXNEIE": "USART_CR1_RXNEIE",
                "USART_CR3_EIE": "USART_CR3_EIE",
                "USART_CR1_RE": "USART_CR1_RE"
            },
            "code": "HAL_StatusTypeDef receiveUARTData_080068d6(UART_HandleTypeDef *uartHandle, uint8_t *dataBuffer, uint16_t dataSize)\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == NULL) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = dataBuffer;\n    uartHandle->RxXferSize = dataSize;\n    uartHandle->RxXferCount = dataSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 |= USART_CR1_RXNEIE;\n    uartHandle->Instance->CR3 |= USART_CR3_EIE;\n    uartHandle->Instance->CR1 |= USART_CR1_RE;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068d6",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "receiveUARTData_080068d6"
        },
        "FUN_080032a2": {
            "renaming": {
                "FUN_080032a2": "sendSysexMessage_080032a2",
                "this": "marshaller",
                "string": "message",
                "bytec": "message_length"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendSysexMessage_080032a2(FirmataMarshaller *marshaller, char *message) {\n  size_t message_length;\n  message_length = strlen(message);\n  sendSysex(marshaller, 'q', message_length, (uint8_t *)message);\n  return;\n}",
            "called": [
                "sendSysex",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032a2",
            "calling": [
                "sendString"
            ],
            "imported": false,
            "current_name": "sendSysexMessage_080032a2"
        },
        "FUN_08009e28": {
            "renaming": {
                "FUN_08009e28": "process_data_08009e28",
                "param_1": "data_size",
                "param_2": "processor",
                "iVar2": "processed_data",
                "piVar3": "data_ptr",
                "iVar4": "data_offset",
                "iVar6": "data_count",
                "uVar1": "processed_data",
                "uVar5": "result"
            },
            "code": "uint process_data_08009e28(int data_size, code *processor, undefined4 param_3, undefined4 param_4) {\n  uint result = 0;\n  for (int *data_ptr = (int *)(data_size + 0x48); data_ptr != (int *)0x0; data_ptr = (int *)*data_ptr) {\n    int data_offset = data_ptr[2];\n    int data_count = data_ptr[1];\n    while (data_count > 0) {\n      if ((1 < *(ushort *)(data_offset + 0xc)) && (*(short *)(data_offset + 0xe) + 1 != 0)) {\n        uint processed_data = (*processor)(data_size, data_offset, param_3, *(short *)(data_offset + 0xe) + 1, param_4);\n        result = result | processed_data;\n      }\n      data_offset += 0x68;\n      data_count--;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e28",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "process_data_08009e28"
        },
        "FUN_0800a01c": {
            "renaming": {
                "FUN_0800a01c": "get_process_id_0800a01c"
            },
            "code": "__pid_t get_process_id_0800a01c(void)\n{\n  __pid_t process_id = 1;\n  return process_id;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a01c",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800a01c"
        },
        "FUN_08006390": {
            "renaming": {
                "FUN_08006390": "configureTimer_08006390",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "DAT_080063bc": "PTR_DAT_080063bc"
            },
            "code": "HAL_StatusTypeDef_conflict configureTimer_08006390(TIM_HandleTypeDef_conflict *timerHandle, uint32_t channel) {\n  TIM_TypeDef_conflict *timerInstance = timerHandle->Instance;\n  TIM_CCxChannelCmd(timerInstance, channel, ENABLE);\n  if (timerInstance == DAT_080063bc) {\n    timerInstance->BDTR |= TIM_BDTR_MOE;\n  }\n  timerInstance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006390",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_08006390"
        },
        "FUN_08009f48": {
            "renaming": {
                "FUN_08009f48": "do_nothing_08009f48"
            },
            "code": "\nvoid do_nothing_08009f48(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f48",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f48"
        },
        "FUN_08004d6a": {
            "renaming": {
                "FUN_08004d6a": "do_nothing_08004d6a"
            },
            "code": "\nvoid do_nothing_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6a",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004d6a"
        },
        "FUN_08008730": {
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "*huart": "*uart_handler",
                "bVar1": "uart_index_value",
                "iVar3": "callback_result",
                "iVar4": "callback_obj_address",
                "uVar2": "uart_index_value",
                "PTR_tx_callback_obj_08008770": "PTR_tx_callback_obj_address",
                "PTR_tx_callback_08008774": "PTR_tx_callback_address",
                "PTR_uart_handlers_08008778": "PTR_uart_handlers_address"
            },
            "code": "void transmit_data_08008730(UART_HandleTypeDef *uart_handler) {\n  uint8_t uart_index_value = uart_index(uart_handler);\n  uint32_t callback_obj_address = *(uint32_t *)(PTR_tx_callback_obj_08008770 + uart_index_value * 4);\n  if ((uart_index_value < 5) && (callback_obj_address = (**(code **)(PTR_tx_callback_08008774 + uart_index_value * 4))(callback_obj_address), callback_obj_address != -1)) {\n    uint8_t *uart_handler_address = *(uint8_t **)(PTR_uart_handlers_08008778 + (uint32_t)*(uint8_t *)(callback_obj_address + 0x44) * 4);\n    uint8_t *data_address = (uint8_t *)(*(uint32_t *)(callback_obj_address + 100) + (uint32_t)*(uint16_t *)(callback_obj_address + 0x6a));\n    HAL_UART_Transmit_IT(uart_handler_address, data_address, 1);\n  }\n  return;\n}",
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008730",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_data_08008730"
        },
        "FUN_08005460": {
            "renaming": {
                "FUN_08005460": "FUNC_08005460"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict FUNC_08005460(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  HAL_StatusTypeDef_conflict HVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08005720;\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar5 = RCC_OscInitStruct->HSEState;\n      if (uVar5 == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (uVar5 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar5 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005724 = 0;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005728 = 0;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar6 = (DAT_08005720[7] & 0x10000000) == 0;\n    if (bVar6) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08005838;\n    puVar1 = DAT_08005720;\n    uVar5 = RCC_OscInitStruct->LSEState;\n    if (uVar5 == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (uVar5 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar5 == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005838[8] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[8] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar6) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  uVar5 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar5 == 0) {\n    HVar3 = HAL_OK;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    HVar3 = HAL_ERROR;\n  }\n  else if (uVar5 == 2) {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if ((RCC_OscInitStruct->PLL).PLLSource == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        DAT_08005838[1] =\n             DAT_08005838[1] & 0xffc2ffff |\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLMUL;\n        *DAT_0800583c = 1;\n        uVar5 = HAL_GetTick();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar5 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  return HVar3;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005460",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_08005460"
        },
        "FUN_08008854": {
            "renaming": {
                "FUN_08008854": "return_zero_08008854",
                "file_UNUSED": "file_unused",
                "ptr_UNUSED": "ptr_unused",
                "dir_UNUSED": "dir_unused"
            },
            "code": "int return_zero_08008854(int file_unused, int ptr_unused, int dir_unused) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008854",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "return_zero_08008854"
        },
        "FUN_08004d6c": {
            "renaming": {
                "FUN_08004d6c": "read_i2c_data_08004d6c",
                "*hi2c": "*i2c_handle",
                "puVar1": "data_ptr"
            },
            "code": "HAL_StatusTypeDef read_i2c_data_08004d6c(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *data_ptr;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2c_handle->XferCount < 4) {\n      if (i2c_handle->XferCount - 2 < 2) {\n        if (i2c_handle->XferOptions == 2) {\n          i2c_handle->Instance->CR1 |= 0x400;\n        }\n        else {\n          i2c_handle->Instance->CR1 &= 0xfffffbff;\n          i2c_handle->Instance->CR1 |= 0x800;\n        }\n        i2c_handle->Instance->CR2 &= 0xfffffbff;\n      }\n      else {\n        if (i2c_handle->XferOptions == 2) {\n          i2c_handle->Instance->CR1 |= 0x400;\n        }\n        else {\n          i2c_handle->Instance->CR1 &= 0xfffffbff;\n        }\n        i2c_handle->Instance->CR2 &= 0xfffff8ff;\n        data_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = data_ptr + 1;\n        *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->PreviousState = 0;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2c_handle);\n        }\n      }\n    }\n    else {\n      data_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = data_ptr + 1;\n      *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n      i2c_handle->XferCount--;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "read_i2c_data_08004d6c"
        },
        "FUN_08007760": {
            "renaming": {
                "FUN_08007760": "handle_timer_interrupt_08007760",
                "PTR_timer_handles_08007770": "PTR_timer_handle",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict",
                "HAL_TIM_IRQHandler": "HandleTimerIRQ"
            },
            "code": "void handle_timer_interrupt_08007760(void)\n{\n  TIM_HandleTypeDef_conflict** timer_handle_ptr = *(TIM_HandleTypeDef_conflict**)PTR_timer_handles_08007770s_08007770;\n  if (timer_handle_ptr != NULL)\n  {\n    TIM_HandleTypeDef_conflict* timer_handle = *timer_handle_ptr;\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007760",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007760"
        },
        "FUN_08008850": {
            "renaming": {
                "FUN_08008850": "returnTrue_08008850",
                "file_UNUSED": "fileUnused"
            },
            "code": "int returnTrue_08008850(int fileUnused) {\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008850",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "returnTrue_08008850"
        },
        "FUN_08002fc2": {
            "renaming": {
                "FUN_08002fc2": "setPinState_08002fc2",
                "pin": "pinNumber",
                "state": "pinState",
                "this": "firmataInstance",
                "pinState": "pinStates"
            },
            "code": "void __thiscall firmata::FirmataClass::setPinState_08002fc2(FirmataClass *this, byte pin, int state)\n{\n  this->pinState[pin] = state;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fc2",
            "calling": [
                "digitalWriteCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinState_08002fc2"
        },
        "FUN_08008afa": {
            "renaming": {
                "FUN_08008afa": "calculateAvailableSpace_08008afa",
                "this": "serial",
                "(this->_serial).rx_head": "head",
                "(this->_serial).rx_tail": "tail",
                "return": "return",
                "&": "&",
                "0x40": "64",
                "0x3f": "63",
                "int": "int"
            },
            "code": "int __thiscall calculateAvailableSpace_08008afa(HardwareSerial *serial) {\n    int head = (serial->_serial).rx_head;\n    int tail = (serial->_serial).rx_tail;\n    int space = (head + 0x40) - tail & 0x3f;\n    return space;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008afa",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "calculateAvailableSpace_08008afa"
        },
        "FUN_08003048": {
            "renaming": {
                "FUN_08003048": "initializeSerialCommunication_08003048",
                "s": "serialPointer",
                "speed": "baudRate",
                "HardwareSerial::FUN_08003048": "HardwareSerial::begin",
                "this": "this",
                "blinkVersion": "blinkVersion",
                "Stream": "Stream",
                "PTR_Serial2_08003068": "PTR_Serial2_08003068",
                "'\\x06'": "SERIAL_8N1"
            },
            "code": "void __thiscall firmata::FirmataClass::initializeSerialCommunication_08003048(FirmataClass *this,long baudRate)\n{\n  undefined *serialPointer;\n  serialPointer = PTR_Serial2_08003068;\n  HardwareSerial::begin((HardwareSerial *)PTR_Serial2_08003068,baudRate, SERIAL_8N1);\n  blinkVersion(this);\n  begin(this,(Stream *)serialPointer);\n  return;\n}",
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003048",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initializeSerialCommunication_08003048"
        },
        "FUN_080038dc": {
            "renaming": {
                "FUN_080038dc": "get_ADC_value_080038dc",
                "hadc": "adc_handler",
                "->Instance": "->Instance",
                "->DR": "->DR"
            },
            "code": "uint32_t get_ADC_value_080038dc(ADC_HandleTypeDef *adc_handler)\n{\n  return adc_handler->Instance->DR;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038dc",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_ADC_value_080038dc"
        },
        "FUN_080025ac": {
            "renaming": {
                "FUN_080025ac": "attach_080025ac",
                "this": "servo",
                "pin": "pin",
                "min": "min_pulse_width",
                "max": "max_pulse_width",
                "obj": "timer_obj",
                "bVar1": "is_timer_active",
                "iVar2": "min_pulse_duration/max_pulse_duration",
                "timer": "timer",
                "PTR_servos_08002628": "PTR_servos",
                "PTR__timer_08002630": "PTR_timer"
            },
            "code": "uint8_t __thiscall Servo::attach_080025ac(Servo *servo,int pin,int min_pulse_width,int max_pulse_width)\n{\n  undefined *timer_obj;\n  boolean is_timer_active;\n  int min_pulse_duration = -min_pulse_width + 0x220;\n  if (min_pulse_duration < 0) {\n    min_pulse_duration = -min_pulse_width + 0x223;\n  }\n  int max_pulse_duration = -max_pulse_width + 0x960;\n  if (max_pulse_duration < 0) {\n    max_pulse_duration = -max_pulse_width + 0x963;\n  }\n  timer16_Sequence_t timer = (timer16_Sequence_t)(uint)((ulonglong)PTR__timer_08002630 * (ulonglong)servo->servoIndex >> 0x23);\n  is_timer_active = isTimerActive(timer);\n  timer_obj = PTR__timer_08002630;\n  if (!is_timer_active) {\n    PTR__timer_08002630[68] = timer;\n    initISR((stimer_t *)timer_obj);\n  }\n  if (servo->servoIndex < 0xc) {\n    pinMode(pin, OUTPUT);\n    PTR_servos_08002628_08002628[(uint)servo->servoIndex * 8] = PTR_servos_08002628_08002628[(uint)servo->servoIndex * 8] & 0xc0 | (byte)pin & 0x3f;\n    PTR_servos_08002628_08002628[(uint)servo->servoIndex * 8] = PTR_servos_08002628_08002628[(uint)servo->servoIndex * 8] | 0x40;\n  }\n  return servo->servoIndex;\n}",
            "called": [
                "initISR",
                "isTimerActive",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ac",
            "calling": [
                "attachServo",
                "attach"
            ],
            "imported": false,
            "current_name": "attach_080025ac"
        },
        "FUN_08007648": {
            "renaming": {
                "FUN_08007648": "configure_stimer_08007648",
                "obj": "timer_obj",
                "period": "period",
                "pulseWidth": "pulse_width",
                "irqHandle": "irq_handler",
                "HVar1": "hal_status",
                "uVar2": "timer_value",
                "htim": "timer_handle",
                "sConfig": "output_compare_config",
                "OCMode": "TIM_OCMODE_PWM1",
                "Pulse": "pulse_width",
                "OCPolarity": "TIM_OCPOLARITY_HIGH",
                "OCNPolarity": "TIM_OCNPOLARITY_HIGH",
                "OCFastMode": "TIM_OCFAST_DISABLE",
                "OCIdleState": "TIM_OCIDLESTATE_RESET",
                "OCNIdleState": "TIM_OCNIDLESTATE_RESET",
                "getTimerClkFreq": "get_timer_clk_freq",
                "Init": "init",
                "Prescaler": "prescaler",
                "ClockDivision": "TIM_CLOCKDIVISION_DIV1",
                "CounterMode": "TIM_COUNTERMODE_UP",
                "RepetitionCounter": "repetition_counter",
                "irqHandleOC": "irq_handler_oc",
                "getTimerIrq": "get_timer_irq",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "HAL_NVIC_EnableIRQ": "HAL_NVIC_EnableIRQ",
                "HAL_TIM_OC_Init": "HAL_TIM_OC_Init",
                "HAL_TIM_OC_ConfigChannel": "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Start_IT": "HAL_TIM_OC_Start_IT"
            },
            "code": "void configure_stimer_08007648(stimer_t_conflict *timer_obj, uint16_t period, uint16_t pulse_width, _func_void_stimer_t_ptr_uint32_t_conflict *irq_handler) {\n  TIM_HandleTypeDef_conflict *timer_handle = &timer_obj->handle;\n  TIM_OC_InitTypeDef output_compare_config;\n  output_compare_config.OCMode = TIM_OCMODE_PWM1;\n  output_compare_config.Pulse = pulse_width;\n  output_compare_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  output_compare_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  output_compare_config.OCFastMode = TIM_OCFAST_DISABLE;\n  output_compare_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  output_compare_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_obj->timer = (TIM_TypeDef_conflict *)0x40000000;\n  timer_handle->Instance = (TIM_TypeDef_conflict *)0x40000000;\n  timer_handle->Init.Period = period;\n  uint32_t timer_clk_freq = get_timer_clk_freq((TIM_TypeDef_conflict *)0x40000000);\n  timer_handle->Init.Prescaler = ((uint64_t)PTR_DAT_080076dc * (uint64_t)timer_clk_freq >> 0x32) - 1;\n  timer_handle->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  timer_handle->Init.CounterMode = TIM_COUNTERMODE_UP;\n  timer_handle->Init.RepetitionCounter = 0;\n  timer_obj->irqHandleOC = irq_handler;\n  uint32_t timer_irq = get_timer_irq(timer_obj->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timer_irq, 14, 0);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timer_irq);\n  if (HAL_TIM_OC_Init(timer_handle) == HAL_OK && HAL_TIM_OC_ConfigChannel(timer_handle, &output_compare_config, 0) == HAL_OK) {\n    HAL_TIM_OC_Start_IT(timer_handle, 0);\n  }\n}\n",
            "called": [
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "getTimerIrq",
                "HAL_NVIC_SetPriority",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Start_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007648",
            "calling": [
                "initISR"
            ],
            "imported": false,
            "current_name": "configure_stimer_08007648"
        },
        "FUN_08008858": {
            "renaming": {
                "FUN_08008858": "file_not_used_08008858",
                "file_UNUSED": "file_num",
                "ptr_UNUSED": "data_ptr",
                "len_UNUSED": "data_length"
            },
            "code": "int file_not_used_08008858(int file_num, char *data_ptr, int data_length)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008858",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "file_not_used_08008858"
        },
        "FUN_08004a20": {
            "renaming": {
                "FUN_08004a20": "do_nothing_08004a20"
            },
            "code": "\nvoid do_nothing_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a20",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a20"
        },
        "FUN_08004a24": {
            "renaming": {
                "FUN_08004a24": "send_byte_08004a24",
                "hi2c": "i2c_handle",
                "HVar1": "state",
                "pbVar2": "buffer"
            },
            "code": "HAL_StatusTypeDef_conflict send_byte_08004a24(I2C_HandleTypeDef_conflict *hi2c)\n{\n  HAL_I2C_StateTypeDef_conflict state = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    byte *buffer = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = buffer + 1;\n    hi2c->Instance->DR = (uint)*buffer;\n    hi2c->XferCount--;\n    if ((hi2c->XferCount == 0) && (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->Instance->CR2 &= 0xfffffbff;\n      hi2c->PreviousState = 0x21;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a24",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_byte_08004a24"
        },
        "FUN_08004a22": {
            "renaming": {
                "FUN_08004a22": "do_nothing_08004a22"
            },
            "code": "\nvoid do_nothing_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a22",
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a22"
        },
        "FUN_08002fba": {
            "renaming": {
                "FUN_08002fba": "getPinState_08002fba",
                "pin": "pin",
                "this": "this",
                "pinState": "pinState"
            },
            "code": "int __thiscall firmata::FirmataClass::getPinState_08002fba(FirmataClass *this, byte pin)\n{\n  return this->pinState[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fba",
            "calling": [
                "digitalWriteCallback",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "getPinState_08002fba"
        },
        "FUN_080090cc": {
            "renaming": {
                "FUN_080090cc": "print_assertion_failed_080090cc",
                "param_1": "stream",
                "param_2": "file",
                "param_3": "expression",
                "param_4": "value",
                "puVar1": "format_string",
                "puVar2": "function",
                "PTR_s__08009104": "NULL",
                "PTR_s___function__080090fc": "NULL",
                "PTR_s_assertion___s__failed__file___s__08009100": "Assertion '%s' failed."
            },
            "code": "void print_assertion_failed_080090cc(FILE *stream, const char *file, int line, const char *function, const char *expression, const char *value)\n{\n  const char *format_string = (value != PTR_s__08009104) ? \"%s:%d: %s: PTR_s_assertion___s__failed__file___s__08009100 Value was: %s\\n\" : \"%s:%d: %s: PTR_s_assertion___s__failed__file___s__08009100\\n\";\n  fprintf(stream, format_string, file, line, function, expression, value);\n  abort();\n}\n",
            "called": [
                "fiprintf",
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090cc",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_080090cc"
        },
        "FUN_080049e0": {
            "renaming": {
                "FUN_080049e0": "listen_for_i2c_080049e0",
                "hi2c": "handle",
                "State": "state",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "Instance": "i2c_instance",
                "CR1": "CR1",
                "CR2": "CR2",
                "0x400": "0x400",
                "0x300": "0x300",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef listen_for_i2c_080049e0(I2C_HandleTypeDef *handle)\n{\n  I2C_TypeDef *i2c_instance;\n  \n  if (handle->state != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  handle->state = HAL_I2C_STATE_LISTEN;\n  i2c_instance = handle->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 = i2c_instance->CR1 | 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049e0",
            "calling": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "listen_for_i2c_080049e0"
        },
        "FUN_08006d24": {
            "renaming": {
                "FUN_08006d24": "set_adc_interrupt_flags_08006d24",
                "*hadc": "*adc_handler",
                "iVar1": "adc_data",
                "DAT_08006d7c": "adc_data",
                "DAT_08006d74": "instance_a",
                "DAT_08006d78": "instance_b",
                "*(uint *)(DAT_08006d7c + 0xc)": "*adc_flags",
                "*(uint *)(iVar1 + 0xc)": "*adc_data_a",
                "*(uint *)(iVar1 + 0x18)": "*adc_data_b"
            },
            "code": "void set_adc_interrupt_flags_08006d24(ADC_HandleTypeDef *adc_handler)\n{\n  int DAT_08006d7c = DAT_08006d7c;\n  int DAT_08006d74 = DAT_08006d74;\n  int DAT_08006d78 = DAT_08006d78;\n  \n  if (adc_handler->Instance != DAT_08006d74) {\n    if (adc_handler->Instance == DAT_08006d78) {\n      uint* adc_flags = (uint*)(DAT_08006d7c + 0xc);\n      *(uint *)(DAT_08006d7c + 0xc) |= 0x400;\n      \n      uint* DAT_08006d7c_a = (uint*)(DAT_08006d7c + 0xc);\n      *DAT_08006d7c_a &= 0xfffffbff;\n      \n      uint* DAT_08006d7c_b = (uint*)(DAT_08006d7c + 0x18);\n      *DAT_08006d7c_b &= 0xfffffbff;\n      *DAT_08006d7c_b &= 0xfffffbff;\n    }\n    return;\n  }\n  uint* adc_flags = (uint*)(DAT_08006d7c + 0xc);\n  *(uint *)(DAT_08006d7c + 0xc) |= 0x200;\n  \n  uint* DAT_08006d7c_a = (uint*)(DAT_08006d7c + 0xc);\n  *DAT_08006d7c_a &= 0xfffffdff;\n  \n  uint* DAT_08006d7c_b = (uint*)(DAT_08006d7c + 0x18);\n  *DAT_08006d7c_b &= 0xfffffdff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d24",
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "imported": false,
            "current_name": "set_adc_interrupt_flags_08006d24"
        },
        "FUN_08008500": {
            "renaming": {
                "FUN_08008500": "transmitData_08008500",
                "data": "dataBuffer",
                "size": "dataSize",
                "pin": "pinName",
                "HVar1": "status",
                "uVar2": "startTime",
                "pvVar3": "peripheral",
                "uVar4": "currentTime",
                "uVar5": "index",
                "PTR_digitalPin_080085a8": "digitalPin",
                "PTR_PinMap_UART_TX_080085ac": "PinMap_UART_TX",
                "PTR_uart_handlers_080085b0": "uartHandlers",
                "PTR_serial_debug_080085b4": "serialDebug"
            },
            "code": "size_t transmitData_08008500(uint8_t *data, uint32_t size) {\nPinName pinName;\nHAL_StatusTypeDef status;\nuint32_t startTime;\nvoid *peripheral;\nuint32_t index;\nstartTime = HAL_GetTick();\npinName = PTR_digitalPin_080085a8[1];\nperipheral = pinmap_peripheral(pinName, (PinMap *)PTR_PinMap_UART_TX_080085ac);\nif (peripheral == NULL) {\nreturn 0;\n}\nindex = 0;\nwhile ((index < 5 && ((PTR_uart_handlers_080085b0[index] == 0 || (peripheral = pinmap_peripheral(pinName, (PinMap *)PTR_PinMap_UART_TX_080085ac), *(void **)PTR_uart_handlers_080085b0[index] != peripheral))))) {\nindex = (index + 1) & 0xff;\n}\nif (4 < index) {\nif ((4 < (byte)PTR_serial_debug_080085b4[0x44]) && (uartDebugInit(), 4 < (byte)PTR_serial_debug_080085b4[0x44])) {\nreturn 0;\n}\nindex = (uint)(byte)PTR_serial_debug_080085b4[0x44];\n}\ndo {\nstatus = HAL_UART_Transmit(*(UART_HandleTypeDef **)PTR_uart_handlers_080085b0[index], data, (uint16_t)size, 1000);\nif (status == HAL_OK) {\nreturn size;\n}\n} while (HAL_GetTick() - startTime < 1000);\nreturn 0;\n}",
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008500",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmitData_08008500"
        },
        "FUN_08007774": {
            "renaming": {
                "FUN_08007774": "handle_timer_interrupt_08007774",
                "PTR_timer_handles_08007784": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandleTypeDef",
                "timer_handle": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_08007774(void)\n{\n    TIM_HandleTypeDef_conflict *timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007784_08007784 + 4);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007774",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007774"
        },
        "FUN_08005e6c": {
            "renaming": {
                "FUN_08005e6c": "do_nothing_08005e6c"
            },
            "code": "\nvoid do_nothing_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6c"
        },
        "FUN_080001a8": {
            "renaming": {
                "FUN_080001a8": "check_and_set_pin_state_080001a8",
                "pin": "pin_number",
                "value": "pin_value",
                "bVar1": "is_valid_pin",
                "bVar2": "pin_mode",
                "ulPin": "ul_pin",
                "uVar3": "digital_pin"
            },
            "code": "void check_and_set_pin_state_080001a8(byte pin, int value) {\n  bool is_valid_pin;\n  byte pin_mode;\n  uint32_t digital_pin;\n  uint32_t ulPin = (uint)pin;\n  if (ulPin < 0x3c) {\n    if (PTR_digitalPin_0800020c[ulPin] == NC) {\n      is_valid_pin = false;\n    }\n    else {\n      digital_pin = pinNametoDigitalPin(PTR_digitalPin_0800020c[ulPin]);\n      if (digital_pin == 0 || digital_pin == 1) {\n        is_valid_pin = false;\n      }\n      else {\n        is_valid_pin = true;\n      }\n    }\n  }\n  else {\n    is_valid_pin = false;\n  }\n  if (is_valid_pin && (pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000210, pin), pin_mode == '\\x01')) {\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000210, pin, value);\n    digitalWrite(ulPin, value);\n  }\n  return;\n}",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001a8",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_pin_state_080001a8"
        },
        "FUN_080048c8": {
            "renaming": {
                "FUN_080048c8": "i2c_transfer_080048c8",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "xfer_options",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "tmp_reg",
                "State": "state",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "NULL": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "Instance": "instance",
                "CR1": "CR1",
                "1": "1",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_MODE_SLAVE": "HAL_I2C_MODE_SLAVE",
                "HAL_OK": "HAL_OK",
                "ErrorCode": "error_code",
                "pBuffPtr": "buff_ptr",
                "XferCount": "xfer_count",
                "XferSize": "xfer_size",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "CR2": "CR2"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_transfer_080048c8(I2C_HandleTypeDef_conflict *handle, uint8_t *data, uint16_t size, uint32_t options)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *instance;\n  uint32_t tmp_reg;\n  \n  if (handle->state == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || handle->lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    }\n    else {\n      handle->lock = HAL_LOCKED;\n      instance = handle->instance;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 |= 1;\n      }\n      handle->instance->CR1 &= 0xfffff7ff;\n      handle->state = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      handle->mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      handle->error_code = 0;\n      handle->buff_ptr = data;\n      handle->xfer_count = size;\n      handle->xfer_options = options;\n      handle->xfer_size = handle->xfer_count;\n      handle->lock = HAL_UNLOCKED;\n      handle->instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048c8",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_transfer_080048c8"
        },
        "FUN_08009954": {
            "renaming": {
                "FUN_08009954": "copy_string_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_chars",
                "cVar1": "current_char",
                "sVar2": "remaining_chars",
                "pcVar3": "dest_ptr",
                "pcVar4": "temp_dest_ptr"
            },
            "code": "char* copy_string_08009954(char* destination, const char* source, size_t num_chars)\n{\n  char current_char;\n  size_t remaining_chars;\n  char* dest_ptr = destination;\n  const char* src_ptr = source;\n\n  do {\n    remaining_chars = num_chars;\n    if (remaining_chars == 0) {\n      return destination;\n    }\n    current_char = *src_ptr;\n    dest_ptr++;\n    *dest_ptr = current_char;\n    src_ptr++;\n    num_chars = remaining_chars - 1;\n  } while (current_char != '\\0');\n  for (; dest_ptr != destination + remaining_chars; dest_ptr++) {\n    *dest_ptr = '\\0';\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009954",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "copy_string_08009954"
        },
        "FUN_08005e6e": {
            "renaming": {
                "FUN_08005e6e": "process_TIM_interrupts_08005e6e",
                "htim": "TIM_HandleTypeDef",
                "pTVar1": "timer_instance",
                "Instance": "Instance",
                "SR": "StatusRegister",
                "DIER": "DMAInterruptEnableRegister",
                "Channel": "ActiveChannel",
                "HAL_TIM_ACTIVE_CHANNEL_1": "1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "Cleared",
                "CCMR1": "CaptureCompareModeRegister1",
                "CCMR2": "CaptureCompareModeRegister2",
                "TIM_FLAG_CC1": "1 << 1",
                "TIM_FLAG_CC2": "1 << 2",
                "TIM_FLAG_CC3": "1 << 3",
                "TIM_FLAG_CC4": "1 << 4",
                "TIM_FLAG_UPDATE": "1 << 0",
                "TIM_FLAG_BREAK": "1 << 6",
                "TIM_FLAG_TRIGGER": "1 << 6",
                "TIM_FLAG_COM": "1 << 5",
                "TIM_IT_CC1": "1 << 1",
                "TIM_IT_CC2": "1 << 2",
                "TIM_IT_CC3": "1 << 3",
                "TIM_IT_CC4": "1 << 4",
                "TIM_IT_UPDATE": "1 << 0",
                "TIM_IT_BREAK": "1 << 6",
                "TIM_IT_TRIGGER": "1 << 6",
                "TIM_IT_COM": "1 << 5",
                "HAL_TIM_OC_DelayElapsedCallback": "OutputCompareDelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback": "PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback": "InputCaptureCallback",
                "HAL_TIM_PeriodElapsedCallback": "PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback": "BreakCallback",
                "HAL_TIM_TriggerCallback": "TriggerCallback",
                "HAL_TIMEx_CommutationCallback": "CommutationCallback"
            },
            "code": "void process_TIM_interrupts_08005e6e(TIM_HandleTypeDef_conflict *htim) {\n  TIM_TypeDef_conflict *timer_instance;\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_CC1) != 0) && ((timer_instance->DIER & TIM_IT_CC1) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_CC1;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_CC2) != 0) && ((timer_instance->DIER & TIM_IT_CC2) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_CC2;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_CC3) != 0) && ((timer_instance->DIER & TIM_IT_CC3) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_CC3;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_CC4) != 0) && ((timer_instance->DIER & TIM_IT_CC4) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_CC4;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_UPDATE) != 0) && ((timer_instance->DIER & TIM_IT_UPDATE) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_UPDATE;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_BREAK) != 0) && ((timer_instance->DIER & TIM_IT_BREAK) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_BREAK;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_TRIGGER) != 0) && ((timer_instance->DIER & TIM_IT_TRIGGER) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_TRIGGER;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  timer_instance = htim->Instance;\n  if (((timer_instance->SR & TIM_FLAG_COM) != 0) && ((timer_instance->DIER & TIM_IT_COM) != 0)) {\n    timer_instance->SR = ~TIM_FLAG_COM;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6e",
            "calling": [
                "TIM2_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_TIM_interrupts_08005e6e"
        },
        "FUN_08004024": {
            "renaming": {
                "FUN_08004024": "set_clock_source_08004024",
                "CLKSource": "clock_source",
                "DAT_08004040": "clock_control_register",
                "*DAT_08004040": "*clock_control_register",
                "0xfffffffb": "~EXTERNAL_CLOCK_BITMASK",
                "4": "EXTERNAL_CLOCK_BITMASK"
            },
            "code": "void set_clock_source_08004024(uint32_t CLKSource)\n{\n    if (CLKSource != EXTERNAL_CLOCK)\n    {\n        *DAT_08004040 &= ~EXTERNAL_CLOCK_BITMASK;\n        return;\n    }\n    *DAT_08004040 |= EXTERNAL_CLOCK_BITMASK;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004024",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_08004024"
        },
        "FUN_08005e6a": {
            "renaming": {
                "FUN_08005e6a": "do_nothing_08005e6a"
            },
            "code": "\nvoid do_nothing_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6a"
        },
        "FUN_08004a1e": {
            "renaming": {
                "FUN_08004a1e": "do_nothing_08004a1e"
            },
            "code": "\nvoid do_nothing_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a1e",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a1e"
        },
        "FUN_08008868": {
            "renaming": {
                "FUN_08008868": "wait_forever_08008868",
                "status_UNUSED": "status",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void wait_forever_08008868(int status_UNUSED)\n{\n    while(true)\n    {\n        // Do nothing\n    }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008868",
            "calling": [
                "abort",
                "_exit"
            ],
            "imported": false,
            "current_name": "wait_forever_08008868"
        },
        "FUN_080036ac": {
            "renaming": {
                "FUN_080036ac": "find_pin_index_080036ac",
                "p": "pin_name",
                "uVar1": "index",
                "PTR_digitalPin_080036d0": "digital_pin_names"
            },
            "code": "uint32_t find_pin_index_080036ac(PinName_conflict pin_name) {\n  uint32_t index = 0xffffffff;\n  if ((uint)((int)pin_name << 0x18) >> 0x1c < 5) {\n    for (index = 0; (index < 0x3c && ((int)pin_name != (int)(char)PTR_digitalPin_080036d0[index])); index++) {\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036ac",
            "calling": [
                "enableI2CPins",
                "checkDigitalInputs",
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "systemResetCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "find_pin_index_080036ac"
        },
        "FUN_0800885c": {
            "renaming": {
                "FUN_0800885c": "send_data_to_uart_0800885c",
                "file_UNUSED": "file_unused",
                "ptr": "data_ptr",
                "len": "data_len",
                "sVar1": "uart_send_len",
                "uart_debugFUN_0800885c": "uart_debug_send_data"
            },
            "code": "int send_data_to_uart_0800885c(int file_unused, char *data_ptr, int data_len)\n{\n  size_t uart_send_len;\n  uart_send_len = uart_debug_send_data((uint8_t *)data_ptr, data_len);\n  return uart_send_len;\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800885c",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_data_to_uart_0800885c"
        },
        "FUN_0800643c": {
            "renaming": {
                "FUN_0800643c": "configure_TIM_channel_0800643c",
                "htim": "tim_handle",
                "Channel": "channel",
                "Instance": "tim_instance",
                "BDTR": "tim_bdtr",
                "CR1": "tim_cr1",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef_conflict configure_TIM_channel_0800643c(TIM_HandleTypeDef_conflict *htim, uint32_t channel)\n{\n  TIM_CCxNChannelCmd(htim->Instance, channel, TIM_CCxN_ENABLE);\n  htim->Instance->BDTR |= TIM_BDTR_MOE;\n  htim->Instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800643c",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_TIM_channel_0800643c"
        },
        "FUN_08002fca": {
            "renaming": {
                "FUN_08002fca": "blinkPin_08002fca",
                "pin": "blinkPinNumber",
                "count": "blinkCount",
                "onInterval": "onTime",
                "offInterval": "offTime",
                "uVar1": "i"
            },
            "code": "void __thiscall firmata::FirmataClass::blinkPin_08002fca(FirmataClass *this, byte pin, int blinkCount, int onTime, int offTime) {\n  for (int i = 0; i < blinkCount; ++i) {\n    delay(offTime);\n    digitalWrite((uint)pin, HIGH);\n    delay(onTime);\n    digitalWrite((uint)pin, LOW);\n  }\n  return;\n}",
            "called": [
                "delay",
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fca",
            "calling": [
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "blinkPin_08002fca"
        },
        "FUN_0800a31c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a31c": "set_flags",
                "PTR_id_0800a380": "id_0800a380",
                "PTR_id_0800a384": "id_0800a384",
                "PTR_id_0800a388": "id_0800a388",
                "PTR_id_0800a38c": "id_0800a38c",
                "PTR_id_0800a390": "id_0800a390",
                "PTR_id_0800a394": "id_0800a394",
                "PTR_id_0800a398": "id_0800a398",
                "PTR_id_0800a39c": "id_0800a39c",
                "FUN_0800a31c": "set_flags_0800a31c"
            },
            "code": "void set_flags_0800a31c() {\n  if (PTR_id_0800a380 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a380 = 1;\n  }\n  if (PTR_id_0800a384 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a384 = 1;\n  }\n  if (PTR_id_0800a388 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a388 = 1;\n  }\n  if (PTR_id_0800a38c < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a38c = 1;\n  }\n  if (PTR_id_0800a390 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a390 = 1;\n  }\n  if (PTR_id_0800a394 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a394 = 1;\n  }\n  if (PTR_id_0800a398 < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a398 = 1;\n  }\n  if (PTR_id_0800a39c < 0) {\n    *(undefined4 *)PTR_PTR_id_0800a39c = 1;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a31c",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a31c"
        },
        "FUN_080026f8": {
            "renaming": {
                "FUN_080026f8": "calculateServoState_080026f8",
                "this": "servoInstance",
                "PTR_servos_08002708": "servoValues",
                "servoIndex": "servoIndex",
                "DAT_0800270c": "shiftAmount",
                "maskedValue": "servoValueMasked",
                "servoState": "isServoOn"
            },
            "code": "bool __thiscall Servo::calculateServoState_080026f8(Servo *servoInstance)\n{\n    uint8_t servoIndex = servoInstance->servoIndex;\n    uint32_t servoValue = (uint32_t)PTR_servos_08002708[(uint32_t)servoIndex * 8];\n    uint32_t shiftedValue = servoValue << 0x19;\n    uint32_t maskedValue = shiftedValue >> 0x1f;\n    bool servoState = (maskedValue == 1);\n    return servoState;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026f8",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "calculateServoState_080026f8"
        },
        "FUN_08007544": {
            "renaming": {
                "FUN_08007544": "get_timer_interrupt_number_08007544",
                "tim": "timer",
                "DAT_08007588": "unknown_timer",
                "DAT_0800758c": "timer_1",
                "PTR_s_TIM__Unknown_timer_IRQn_08007590": "unknown_timer_IRQn",
                "DMAR": "timer_2"
            },
            "code": "uint32_t get_timer_interrupt_number_08007544(TIM_TypeDef_conflict *timer) {\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (timer == DAT_08007588) {\n    return 0x1d;\n  }\n  if (DAT_08007588 < timer) {\n    if (timer == DAT_0800758c) {\n      return 0x1e;\n    }\n    if (timer == (TIM_TypeDef_conflict *)&timer_2.DMAR) {\n      return 0x19;\n    }\n  }\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n    return 0x1c;\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_IRQn_08007590);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007544",
            "calling": [
                "TimerPulseDeinit",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "get_timer_interrupt_number_08007544"
        },
        "FUN_08008990": {
            "renaming": {
                "FUN_08008990": "configure_pin_08008990",
                "ulPin": "pin_number",
                "ulMode": "pin_mode",
                "_Var1": "is_configured",
                "pin": "pin_name",
                "PTR_digitalPin_08008a14": "digitalPin",
                "NC": "NC",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_08008a18": "output_pin_configured",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_conflict": "PinMap_PWM",
                "PTR_PinMap_PWM_08008a1c": "PinMap_PWM",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "digital_io_init": "digital_io_init",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_digPinConfigured_08008a20": "dig_pin_configured"
            },
            "code": "void configure_pin_08008990(uint32_t pin_number, uint32_t pin_mode) {\n  PinName_conflict pin_name;\n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_08008a14[pin_number];\n  } else {\n    pin_name = NC;\n  }\n  if (pin_name != NC) {\n    bool is_configured = is_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    if (is_configured) {\n      bool is_pwm = pin_in_pinmap(pin_name, (PinMap_conflict *)PTR_PinMap_PWM_08008a1c);\n      if (is_pwm) {\n        pwm_stop(pin_name);\n      }\n      reset_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    }\n    switch(pin_mode) {\n      case 0:\n        digital_io_init(pin_name, 0, 0);\n        break;\n      case 1:\n        digital_io_init(pin_name, 1, 0);\n        break;\n      case 2:\n        digital_io_init(pin_name, 0, 1);\n        break;\n      case 3:\n        digital_io_init(pin_name, 0, 2);\n        break;\n    }\n    set_pin_configured(pin_name, (uint32_t *)PTR_g_digPinConfigured_08008a20);\n  }\n}",
            "called": [
                "pwm_stop",
                "pin_in_pinmap",
                "digital_io_init",
                "set_pin_configured",
                "reset_pin_configured",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008990",
            "calling": [
                "attach",
                "analogWrite",
                "digitalWriteCallback",
                "blinkVersion",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_pin_08008990"
        },
        "FUN_08004396": {
            "renaming": {
                "FUN_08004396": "set_i2c_device_address_08004396",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address"
            },
            "code": "HAL_StatusTypeDef set_i2c_device_address_08004396(I2C_HandleTypeDef *i2c_handle, uint8_t device_address)\n{\n  i2c_handle->Instance->DR = device_address & 0xff;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004396",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_i2c_device_address_08004396"
        },
        "FUN_08003fb0": {
            "renaming": {
                "FUN_08003fb0": "set_interrupt_enable_bit_08003fb0",
                "IRQn": "irq_num",
                "uVar1": "irq_num_u32",
                "DAT_08003fd4": "reg_base_addr"
            },
            "code": "void set_interrupt_enable_bit_08003fb0(IRQn_Type_conflict irq_num){\n  uint32_t irq_num_u32 = (uint32_t)irq_num;\n  if (irq_num_u32 >= 0) {\n    uint32_t bit_offset = irq_num_u32 & 0x1f;\n    uint32_t* reg_addr = (uint32_t*)(DAT_08003fd4 + ((irq_num_u32 >> 5) + 0x20) * 4);\n    *reg_addr = 1 << bit_offset;\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fb0",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_08003fb0"
        },
        "FUN_08007788": {
            "renaming": {
                "FUN_08007788": "handle_timer_interrupt_08007788",
                "PTR_timer_handles_08007798": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandle",
                "HAL_TIM_IRQHandler": "HandleTimerInterruptRequest"
            },
            "code": "void handle_timer_interrupt_08007788(void)\n{\n  TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007798_08007798 + 8);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007788",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007788"
        },
        "FUN_08008f0c": {
            "renaming": {
                "FUN_08008f0c": "do_nothing_08008f0c"
            },
            "code": "\nvoid do_nothing_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008f0c"
        },
        "FUN_08002ec4": {
            "renaming": {
                "FUN_08002ec4": "printFirmataStream_08002ec4",
                "iVar1": "printResult"
            },
            "code": "int __thiscall firmata::FirmataClass::printFirmataStream_08002ec4(FirmataClass *this)\n{\n  int printResult;\n  printResult = (*(this->FirmataStream->super_Print)._vptr_Print[2])();\n  return printResult;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "printFirmataStream_08002ec4"
        },
        "FUN_08007306": {
            "renaming": {
                "FUN_08007306": "find_peripheral_from_pin_08007306",
                "pin": "target_pin",
                "map": "pin_map",
                "NC": "NC",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void * find_peripheral_from_pin_08007306(PinName_conflict target_pin, PinMap_conflict *pin_map) {\n  while (true) {\n    if (pin_map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (pin_map->pin == target_pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return pin_map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007306",
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_from_pin_08007306"
        },
        "FUN_08008f0e": {
            "renaming": {
                "FUN_08008f0e": "initialize_EVP_PKEY_CTX_08008f0e",
                "ctx": "pkey_ctx",
                "PTR_0804b008": "EVP_PKEY_CTX",
                "HAL_NVIC_SetPriorityGrouping": "set_NVIC_priority_grouping",
                "init": "initialize"
            },
            "code": "void initialize_EVP_PKEY_CTX_08008f0e(void)\n{\n  PTR_0804b008 *pkey_ctx;\n  pkey_ctx = (PTR_0804b008 *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(pkey_ctx);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0e",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08008f0e"
        },
        "FUN_0800886c": {
            "renaming": {
                "FUN_0800886c": "set_error_code_0800886c",
                "pid_UNUSED": "pid_unused",
                "sig_UNUSED": "sig_unused",
                "PTR_errno_08008878": "PTR_errno_08008878"
            },
            "code": "int set_error_code_0800886c(int pid_unused, int sig_unused)\n{\n    int error_code = 0x16;\n    *(undefined4 *)PTR_errno_08008878 = error_code;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800886c",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_error_code_0800886c"
        },
        "FUN_080036d4": {
            "renaming": {
                "FUN_080036d4": "do_nothing_080036d4"
            },
            "code": "\nvoid do_nothing_080036d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d4",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080036d4"
        },
        "FUN_08006e68": {
            "renaming": {
                "FUN_08006e68": "FUNC_08006e68"
            },
            "code": "\nvoid FUNC_08006e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  undefined *puVar1;\n  uint32_t uVar2;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  puVar1 = PTR_g_current_pin_08007100;\n  uVar2 = pinmap_function(*PTR_g_current_pin_08007100,(PinMap_conflict *)PTR_PinMap_PWM_08007104);\n  timer_enable_clock(htim);\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*puVar1 << 0x18) >> 0x1c);\n  GPIO_InitStruct.Mode = 2;\n  GPIO_InitStruct.Pull = 0;\n  GPIO_InitStruct.Speed = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((uVar2 << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  GPIO_InitStruct.Pin = 1 << (*PTR_g_current_pin_08007100 & 0xf) & 0xffff;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "timer_enable_clock",
                "set_GPIO_Port_Clock"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08006e68",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08006e68"
        },
        "FUN_080036d8": {
            "renaming": {
                "FUN_080036d8": "configureSysTickTimer_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "configResult",
                "PTR_SystemCoreClock_0800371c": "sysClock",
                "PTR_uwTickFreq_08003718": "tickFreq",
                "SysTick_IRQn": "SysTick_IRQn",
                "PTR_uwTickPrio_08003720": "tickPriorityPtr",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef configureSysTickTimer_080036d8(uint32_t tickPriority)\n{\n  uint32_t PTR_SystemCoreClock_0800371c = *(uint *)PTR_SystemCoreClock_0800371c;\n  uint32_t PTR_uwTickFreq_08003718 = *(uint *)PTR_uwTickFreq_08003718;\n  uint32_t ticks = PTR_SystemCoreClock_0800371c / (1000 / PTR_uwTickFreq_08003718);\n  uint32_t configResult = HAL_SYSTICK_Config(ticks);\n  if (configResult != 0) {\n    return HAL_ERROR;\n  }\n  if (tickPriority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn, tickPriority, 0);\n  *(uint32_t *)PTR_uwTickPrio_08003720 = tickPriority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d8",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configureSysTickTimer_080036d8"
        },
        "FUN_0800a110": {
            "renaming": {
                "FUN_0800a110": "check_terminal_0800a110",
                "param_1": "error_code",
                "param_2": "terminal_fd",
                "puVar1": "errno_ptr",
                "iVar2": "is_terminal"
            },
            "code": "void check_terminal_0800a110(int *error_code, int terminal_fd) {\n  undefined *errno_ptr;\n  int is_terminal;\n  errno_ptr = PTR_errno_0800a12c;\n  *(undefined4 *)PTR_errno_0800a12c = 0;\n  is_terminal = _isatty(terminal_fd);\n  if ((is_terminal == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a110",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_terminal_0800a110"
        },
        "FUN_08003b8c": {
            "renaming": {
                "FUN_08003b8c": "check_adc_conversion_ready_08003b8c",
                "*hadc": "*adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "pAVar3": "adc_instance",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "HAL_StatusTypeDef check_adc_conversion_ready_08003b8c(ADC_HandleTypeDef *hadc)\n{\n  uint32_t current_time;\n  uint32_t start_time;\n  ADC_TypeDef *adc_instance;\n  adc_instance = hadc->Instance;\n  if ((adc_instance->CR2 & ADC_CR2_ADON) == 0) {\n    return HAL_OK;\n  }\n  adc_instance->CR2 = adc_instance->CR2 & ~(ADC_CR2_ADON);\n  start_time = HAL_GetTick();\n  do {\n    if ((hadc->Instance->CR2 & ADC_CR2_ADON) == 0) {\n      return HAL_OK;\n    }\n    current_time = HAL_GetTick();\n  } while (current_time - start_time < 3);\n  hadc->State |= ADC_STATE_ERROR_INTERNAL;\n  hadc->ErrorCode |= ADC_ERROR_INTERNAL;\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b8c",
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "imported": false,
            "current_name": "check_adc_conversion_ready_08003b8c"
        },
        "FUN_080035b8": {
            "renaming": {
                "FUN_080035b8": "configure_SystemClock_080035b8",
                "HVar1": "status",
                "uVar2": "hclk_freq",
                "PeriphClkInit": "periph_clk_init",
                "RCC_ClkInitStruct": "clk_init_struct",
                "RCC_OscInitStruct": "osc_init_struct",
                "RCC_OscInitStruct.OscillatorType": "osc_init_struct.OscillatorType",
                "RCC_OscInitStruct.HSIState": "osc_init_struct.HSIState",
                "RCC_OscInitStruct.HSICalibrationValue": "osc_init_struct.HSICalibrationValue",
                "RCC_OscInitStruct.PLL.PLLState": "osc_init_struct.PLL.PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "osc_init_struct.PLL.PLLSource",
                "RCC_OscInitStruct.PLL.PLLMUL": "osc_init_struct.PLL.PLLMUL",
                "RCC_ClkInitStruct.ClockType": "clk_init_struct.ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "clk_init_struct.SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "clk_init_struct.AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "clk_init_struct.APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "clk_init_struct.APB2CLKDivider",
                "PeriphClkInit.PeriphClockSelection": "periph_clk_init.PeriphClockSelection",
                "PeriphClkInit.AdcClockSelection": "periph_clk_init.AdcClockSelection",
                "HAL_RCC_OscConfig": "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig": "HAL_RCC_ClockConfig",
                "HAL_RCCEx_PeriphCLKConfig": "HAL_RCCEx_PeriphCLKConfig",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "HAL_SYSTICK_CLKSourceConfig": "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "SysTick_IRQn": "SysTick_IRQn",
                "_Error_Handler": "_Error_Handler"
            },
            "code": "void configure_SystemClock_080035b8(void)\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclk_freq;\n  RCC_PeriphCLKInitTypeDef periph_clk_init;\n  RCC_ClkInitTypeDef clk_init_struct;\n  RCC_OscInitTypeDef osc_init_struct;\n  \n  osc_init_struct.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  osc_init_struct.HSIState = RCC_HSI_ON;\n  osc_init_struct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;\n  osc_init_struct.PLL.PLLState = RCC_PLL_ON;\n  osc_init_struct.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  osc_init_struct.PLL.PLLMUL = RCC_PLL_MUL16;\n  status = HAL_RCC_OscConfig(&osc_init_struct);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x88);\n  }\n  \n  clk_init_struct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clk_init_struct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clk_init_struct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clk_init_struct.APB1CLKDivider = RCC_HCLK_DIV2;\n  clk_init_struct.APB2CLKDivider = RCC_HCLK_DIV1;\n  status = HAL_RCC_ClockConfig(&clk_init_struct, FLASH_LATENCY_2);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x95);\n  }\n  \n  periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  periph_clk_init.AdcClockSelection = RCC_ADCPCLK2_DIV6;\n  status = HAL_RCCEx_PeriphCLKConfig(&periph_clk_init);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x9c);\n  }\n  \n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint32_t)(SYSTICK_CLOCK_SOURCE / hclk_freq));\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n",
            "called": [
                "_Error_Handler",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035b8",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "configure_SystemClock_080035b8"
        },
        "FUN_08006460": {
            "renaming": {
                "FUN_08006460": "disable_channel_08006460",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance"
            },
            "code": "HAL_StatusTypeDef_conflict disable_channel_08006460(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel)\n{\n  TIM_TypeDef_conflict *timer_instance;\n  \n  TIM_CCxNChannelCmd(timer_handle->Instance, channel, 0);\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR = timer_instance->BDTR & 0xffff7fff;\n  }\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006460",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_channel_08006460"
        },
        "FUN_08004046": {
            "renaming": {
                "FUN_08004046": "handle_systick_interrupt_08004046"
            },
            "code": "void handle_systick_interrupt_08004046(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004046",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "handle_systick_interrupt_08004046"
        },
        "FUN_08008880": {
            "renaming": {
                "FUN_08008880": "read_analog_pin_08008880",
                "ulPin": "pin_number",
                "bVar1": "is_valid_pin",
                "pin": "pin_name",
                "uVar2": "adc_value",
                "uVar3": "adc_value_converted",
                "uVar4": "read_resolution"
            },
            "code": "uint32_t read_analog_pin_08008880(uint32_t pin_number) {\n    bool is_valid_pin = false;\n    PinName_conflict pin_name;\n    uint16_t adc_value;\n    uint read_resolution;\n\n    if (pin_number < 0xe) {\n        if (pin_number + 0x2e < 0x3c) {\n            is_valid_pin = true;\n        }\n    }\n    else {\n        is_valid_pin = pin_number < 0x3c;\n    }\n\n    if (is_valid_pin) {\n        if (pin_number < 0xe) {\n            pin_number = pin_number + 0x2e;\n        }\n        pin_name = PTR_digitalPin_080088d8[pin_number];\n    }\n    else {\n        pin_name = NC;\n    }\n\n    if (pin_name == NC) {\n        adc_value = 0;\n    }\n    else {\n        adc_value = adc_read_value(pin_name);\n        read_resolution = *(uint *)PTR__readResolution_080088dc;\n        if (read_resolution != 0xc) {\n            if (read_resolution < 0xc) {\n                return (uint)(adc_value >> (0xc - read_resolution & 0xff));\n            }\n            return adc_value << (read_resolution - 0xc & 0xff);\n        }\n    }\n    return adc_value;\n}",
            "called": [
                "adc_read_value"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008880",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "read_analog_pin_08008880"
        },
        "FUN_08004044": {
            "renaming": {
                "FUN_08004044": "do_nothing_08004044"
            },
            "code": "\nvoid do_nothing_08004044(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004044",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004044"
        },
        "FUN_08002ed2": {
            "renaming": {
                "FUN_08002ed2": "parse_input_08002ed2",
                "this": "firmata_instance",
                "iVar1": "incoming_byte",
                "FirmataStream": "firmata_stream",
                "super_Print": "super_print",
                "_vptr_Print": "virtual_function_table",
                "FirmataParser": "firmata_parser",
                "parser": "firmata_parser_instance"
            },
            "code": "void __thiscall firmata::FirmataClass::parse_input_08002ed2(FirmataClass *firmata_instance) {\n  int incoming_byte = (*(firmata_instance->FirmataStream->super_Print)._vptr_Print[3])();\n  if (incoming_byte != -1) {\n    FirmataParser::parse(&firmata_instance->parser, (uint8_t)incoming_byte);\n  }\n  return;\n}",
            "called": [
                "parse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed2",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "parse_input_08002ed2"
        },
        "FUN_08008f1c": {
            "renaming": {
                "FUN_08008f1c": "main_loop_08008f1c",
                "initVariant": "init_variant",
                "setup": "setup",
                "loop": "loop",
                "DAT_08008f38": "data",
                "serialEventRun": "serial_event_run"
            },
            "code": "int main_loop_08008f1c(void)\n{\n  init_variant();\n  setup();\n  do {\n    do {\n      loop();\n    } while (DAT_08008f38 == 0);\n    serial_event_run();\n  } while( true );\n}",
            "called": [
                "loop",
                "initVariant",
                "serialEventRun",
                "setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f1c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "main_loop_08008f1c"
        },
        "FUN_080058ac": {
            "renaming": {
                "FUN_080058ac": "configureClocks_080058ac",
                "RCC_ClkInitTypeDef_conflict": "RCC_ClkInitTypeDef",
                "RCC_ClkInitStruct": "clockInit",
                "FLatency": "flashLatency",
                "puVar1": "flashLatencyPtr",
                "uVar2": "tickStart",
                "uVar3": "tickNow",
                "uVar4": "sysClockSource"
            },
            "code": "HAL_StatusTypeDef configureClocks_080058ac(RCC_ClkInitTypeDef *clockInit, uint32_t flashLatency)\n{\n    uint32_t *flashLatencyPtr = DAT_08005a0c;\n    if (((*flashLatencyPtr & 7) < flashLatency) && (*flashLatencyPtr = *flashLatencyPtr & 0xfffffff8 | flashLatency, flashLatency != (*flashLatencyPtr & 7))) {\n        return HAL_ERROR;\n    }\n    if ((clockInit->ClockType & RCC_CLOCKTYPE_HCLK) != 0) {\n        DAT_08005a10[1] = DAT_08005a10[1] & 0xffffff0f | clockInit->AHBCLKDivider;\n    }\n    if ((clockInit->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\n        uint32_t sysClockSource = clockInit->SYSCLKSource;\n        if (sysClockSource == RCC_SYSCLKSOURCE_PLLCLK) {\n            if ((*DAT_08005a10 & RCC_CFGR_SWS_PLL) == 0) {\n                return HAL_ERROR;\n            }\n        }\n        else if ((sysClockSource != RCC_SYSCLKSOURCE_HSI) && ((*DAT_08005a10 & RCC_CFGR_SWS_HSI) == 0)) {\n            return HAL_ERROR;\n        }\n        DAT_08005a10[1] = sysClockSource | DAT_08005a10[1] & 0xfffffffc;\n        uint32_t tickStart = HAL_GetTick();\n        while ((DAT_08005a10[1] & RCC_CFGR_SWS) != (sysClockSource << 2)) {\n            uint32_t tickNow = HAL_GetTick();\n            if (tickNow - tickStart > 5000) {\n                return HAL_TIMEOUT;\n            }\n        }\n    }\n    flashLatencyPtr = DAT_08005a0c;\n    if ((flashLatency < (*DAT_08005a0c & 7)) && (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | flashLatency, flashLatency != (*flashLatencyPtr & 7))) {\n        return HAL_ERROR;\n    }\n    if ((clockInit->ClockType & RCC_CLOCKTYPE_PCLK1) != 0) {\n        DAT_08005a10[1] = DAT_08005a10[1] & 0xfffff8ff | clockInit->APB1CLKDivider;\n    }\n    if ((clockInit->ClockType & RCC_CLOCKTYPE_PCLK2) != 0) {\n        DAT_08005a10[1] = DAT_08005a10[1] & 0xffffc7ff | clockInit->APB2CLKDivider << 3;\n    }\n    uint32_t sysClockFreq = HAL_RCC_GetSysClockFreq();\n    uint32_t ahbPrescIndex = (DAT_08005a10[1] << 0x18) >> 0x1c;\n    *(uint *)PTR_SystemCoreClock_08005a18 = sysClockFreq >> PTR_AHBPrescTable_08005a14[ahbPrescIndex];\n    HAL_InitTick(0xf);\n    return HAL_OK;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058ac",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configureClocks_080058ac"
        },
        "FUN_08007438": {
            "renaming": {
                "FUN_08007438": "initialize_timer_08007438",
                "*htim": "*timer",
                "tmpreg": "interrupt_flag",
                "tmpreg_1": "capture_compare_mode",
                "tmpreg_2": "slave_mode_control",
                "DAT_080074d0": "timer_1",
                "PTR_timer_handles_080074dc": "timer_handles",
                "TIM_TypeDef_conflict": "timer_2",
                "_DAT_4002101c": "timer_2->DIER",
                "DAT_080074d4": "timer_3",
                "DAT_080074d8": "timer_4"
            },
            "code": "void initialize_timer_08007438(TIM_HandleTypeDef_conflict *timer)\n{\n  uint32_t interrupt_flag;\n  uint32_t capture_compare_mode;\n  uint32_t slave_mode_control;\n  \n  if (timer->Instance == DAT_080074d0)\n  {\n    interrupt_flag = DAT_080074d0->DIER | 0x800;\n    PTR_timer_handles_080074dc[0] = timer;\n  }\n  if (timer->Instance == timer_2)\n  {\n    interrupt_flag = _DAT_4002101c | 0x1;\n    PTR_timer_handles_080074dc[1] = timer;\n  }\n  if (timer->Instance == DAT_080074d4)\n  {\n    capture_compare_mode = DAT_080074d4->CCMR1 | 2;\n    PTR_timer_handles_080074dc[2] = timer;\n  }\n  if (timer->Instance == DAT_080074d8)\n  {\n    slave_mode_control = DAT_080074d8->SMCR | 4;\n    PTR_timer_handles_080074dc[3] = timer;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007438",
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007438"
        },
        "FUN_0800306c": {
            "renaming": {
                "FUN_0800306c": "initialize_static_data_0800306c"
            },
            "code": "void initialize_static_data_0800306c()\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800306c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_0800306c"
        },
        "FUN_0800887c": {
            "renaming": {
                "FUN_0800887c": "get_process_id_0800887c"
            },
            "code": "__pid_t get_process_id_0800887c(void)\n{\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800887c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800887c"
        },
        "FUN_0800863c": {
            "renaming": {
                "FUN_0800863c": "receive_data_0800863c",
                "obj": "serial_object",
                "callback": "callback_function",
                "uVar2": "rx_active",
                "bVar1": "index_value"
            },
            "code": "void receive_data_0800863c(serial_t *serial_object, _func_void_serial_t_ptr *callback_function) {\n  byte index_value;\n  uint8_t rx_active;\n  if (serial_object != NULL) {\n    rx_active = serial_rx_active(serial_object);\n    if (rx_active == 0) {\n      index_value = serial_object->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_08008688 + (uint)index_value * 4) = callback_function;\n      *(serial_t **)(PTR_rx_callback_obj_0800868c + (uint)index_value * 4) = serial_object;\n      HAL_NVIC_SetPriority(serial_object->irq, 0, 1);\n      HAL_NVIC_EnableIRQ(serial_object->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008690 + (uint)serial_object->index * 4), &serial_object->recv, 1);\n    }\n  }\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800863c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "receive_data_0800863c"
        },
        "FUN_08004050": {
            "renaming": {
                "FUN_08004050": "configure_DMA_channel_08004050",
                "hdma": "dma_handle",
                "uVar1": "dma_mode",
                "pDVar2": "dma_channel",
                "DAT_080040e0": "PTR_DAT_080040e0",
                "DAT_080040e4": "PTR_DAT_080040e4",
                "HAL_DMA_STATE_BUSY": "HAL_DMA_STATE_BUSY",
                "HAL_DMA_STATE_READY": "HAL_DMA_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "_func_void___DMA_HandleTypeDef_ptr_conflict": "_func_void___DMA_HandleTypeDef_ptr_conflict"
            },
            "code": "HAL_StatusTypeDef_conflict configure_DMA_channel_08004050(DMA_HandleTypeDef_conflict *dma_handle)\n{\n    undefined4 dma_mode;\n    DMA_Channel_TypeDef_conflict *dma_channel;\n    \n    if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n        dma_handle->ErrorCode = 4;\n        return HAL_ERROR;\n    }\n\n    // configure DMA channel\n    dma_channel = dma_handle->Instance;\n    dma_channel->CCR &= 0xfffffff1; // clear bit 1\n    dma_channel->CCR &= 0xfffffffe; // clear bit 0\n\n    // set DMA mode\n    if (dma_channel == DAT_080040e0) {\n        dma_mode = 1;\n    }\n    else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[1].CNDTR) {\n        dma_mode = 0x10;\n    }\n    else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[2].CPAR) {\n        dma_mode = 0x100;\n    }\n    else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[3].CMAR) {\n        dma_mode = 0x1000;\n    }\n    else if (dma_channel == DAT_080040e0 + 5) {\n        dma_mode = 0x10000;\n    }\n    else if (dma_channel == (DMA_Channel_TypeDef_conflict *)&DAT_080040e0[6].CNDTR) {\n        dma_mode = 0x100000;\n    }\n    else {\n        dma_mode = 0x1000000;\n    }\n    *(undefined4 *)(DAT_080040e4 + 4) = dma_mode;\n    \n    // reset DMA handle\n    dma_handle->State = HAL_DMA_STATE_READY;\n    dma_handle->Lock = HAL_UNLOCKED;\n    if (dma_handle->XferAbortCallback != (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0) {\n        (*dma_handle->XferAbortCallback)(dma_handle);\n        return HAL_OK;\n    }\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004050",
            "calling": [
                "HAL_UART_IRQHandler",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "configure_DMA_channel_08004050"
        },
        "FUN_08008e14": {
            "renaming": {
                "FUN_08008e14": "initializeIPAddress_08008e14",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority"
            },
            "code": "void initializeIPAddress_08008e14(int shouldInitialize, int priority) {\n  if (shouldInitialize && priority == 0xffff) {\n    IPAddress::IPAddress((IPAddress *)PTR_INADDR_NONE_08008e3c, '\\0', '\\0', '\\0', '\\0');\n    return;\n  }\n  return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e14",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initializeIPAddress_08008e14"
        },
        "FUN_08005a28": {
            "renaming": {
                "FUN_08005a28": "get_HCLK_frequency_divided_by_APB_prescaler_08005a28",
                "uVar1": "HCLK_frequency",
                "DAT_08005a40": "data_08005a40",
                "PTR_APBPrescTable_08005a44": "APB_prescaler_table",
                "APB_prescaler_index": "APB_prescaler_index",
                "APB_prescaler": "APB_prescaler"
            },
            "code": "uint32_t get_HCLK_frequency_divided_by_APB_prescaler_08005a28(void)\n{\n  uint32_t HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t APB_prescaler_index = (*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d;\n  uint32_t APB_prescaler = PTR_APBPrescTable_08005a44[APB_prescaler_index];\n  return HCLK_frequency >> APB_prescaler;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a28",
            "calling": [
                "getTimerClkFreq",
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divided_by_APB_prescaler_08005a28"
        },
        "FUN_08008ac6": {
            "renaming": {
                "FUN_08008ac6": "calculateNextTailIndex_08008ac6",
                "obj": "serialObj",
                "iVar3": "nextTailIndex",
                "uVar1": "tailIndex",
                "uVar2": "maskedTailIndex"
            },
            "code": "int calculateNextTailIndex_08008ac6(serial_t_conflict *serialObj)\n{\n    int nextTailIndex = serialObj->tx_tail + 1;\n    ushort tailIndex = (ushort)nextTailIndex;\n    uint16_t maskedTailIndex = tailIndex & 0x7f;\n    if (nextTailIndex == 0) {\n        maskedTailIndex = -(-tailIndex & 0x7f);\n    }\n    serialObj->tx_tail = maskedTailIndex;\n    if (serialObj->tx_head != serialObj->tx_tail) {\n        return 0;\n    }\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac6",
            "calling": [],
            "imported": false,
            "current_name": "calculateNextTailIndex_08008ac6"
        },
        "FUN_08003002": {
            "renaming": {
                "FUN_08003002": "initializeFirmata_08003002",
                "this": "firmataInstance",
                "FUN_08003002Disabled": "isDisabled",
                "pinMode": "setPinMode",
                "strobeBlinkPin": "blinkPin",
                "'\\r'": "command",
                "2": "blinkCount1",
                "0x28": "blinkDuration1",
                "0xd2": "pin1",
                "delay": "wait",
                "0xfa": "waitDuration1",
                "5": "blinkCount2",
                "0x7d": "waitDuration2"
            },
            "code": "void __thiscall firmata::FirmataClass::initializeFirmata_08003002(FirmataClass *firmataInstance)\n{\n  if (firmataInstance->isDisabled != false) {\n    return;\n  }\n  pinMode(LED_BUILTIN, OUTPUT);\n  strobeBlinkPin(firmataInstance, '\r', 2, 0x28, 0xd2);\n  delay(250);\n  strobeBlinkPin(firmataInstance, '\r', 5, 0x28, 0xd2);\n  delay(125);\n  return;\n}",
            "called": [
                "delay",
                "strobeBlinkPin",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003002",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08003002"
        },
        "FUN_08008ac4": {
            "renaming": {
                "FUN_08008ac4": "do_nothing_08008ac4"
            },
            "code": "\nvoid do_nothing_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac4",
            "calling": [
                "strobeBlinkPin",
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "do_nothing_08008ac4"
        },
        "FUN_08003366": {
            "renaming": {
                "FUN_08003366": "setStringCallback_08003366",
                "this": "parser",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx",
                "currentStringCallback": "currentCallback",
                "currentStringCallbackContext": "currentCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::setStringCallback_08003366(FirmataParser *this, uint8_t command, stringCallbackFunction newFunction, void *context)\n{\n  if (command == 'q') {\n    this->currentStringCallback = newFunction;\n    this->currentStringCallbackContext = context;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003366",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setStringCallback_08003366"
        },
        "FUN_080091b0": {
            "renaming": {
                "FUN_080091b0": "reverse_copy_080091b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "src_end",
                "puVar2": "dst_end"
            },
            "code": "void * reverse_copy_080091b0(void *destination, const void *source, size_t num_bytes) {\n  unsigned char *dst = (unsigned char *)destination + num_bytes - 1;\n  const unsigned char *src = (const unsigned char *)source;\n  for (size_t i = 0; i < num_bytes; ++i) {\n    *dst-- = *src++;\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091b0",
            "calling": [
                "write",
                "_realloc_r",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "reverse_copy_080091b0"
        },
        "FUN_08009908": {
            "renaming": {
                "FUN_08009908": "allocate_memory_08009908",
                "__ptr": "ptr",
                "__size": "size",
                "pvVar1": "new_ptr"
            },
            "code": "void * allocate_memory_08009908(void *ptr, size_t size)\n{\n  void *new_ptr;\n  new_ptr = (void *)_allocate_memory_08009908_r(*(undefined4 *)PTR__impure_ptr_08009914, ptr, size);\n  return new_ptr;\n}",
            "called": [
                "_realloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009908",
            "calling": [
                "write",
                "write",
                "allocateRxBuffer"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009908"
        },
        "FUN_08008abc": {
            "renaming": {
                "FUN_08008abc": "get_current_millisecond_08008abc",
                "uVar1": "current_millisecond"
            },
            "code": "uint32_t get_current_millisecond_08008abc(void)\n{\n  uint32_t current_millisecond = GetCurrentMilli();\n  return current_millisecond;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008abc",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "get_current_millisecond_08008abc"
        },
        "FUN_08002b68": {
            "renaming": {
                "__thiscall": "",
                "TwoWire": "wire",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "iaddress": "internalAddress",
                "isize": "internalAddressSize",
                "sendStop": "sendStop",
                "iVar1": "status",
                "uVar2": "dataSize",
                "PTR_rxBuffer_08002bf4": "rxBuffer",
                "PTR_rxBufferIndex_08002bf8": "rxBufferIndex",
                "PTR_rxBufferLength_08002bfc": "rxBufferLength",
                "false": "0",
                "uint8_t": "uint8_t",
                "i2c_status_e_conflict": "i2c_status_e_conflict",
                "uint": "uint",
                "beginTransmission": "beginTransmission",
                "endTransmission": "endTransmission",
                "i2c_master_read": "i2c_master_read",
                "I2C_OK": "I2C_OK",
                "write_error": "write_error",
                "true": "1",
                "ushort": "ushort",
                "uint8_t *": "uint8_t *",
                "FUN_08002b68": "readFromAddress_08002b68"
            },
            "code": "uint8_t readFromAddress_08002b68(TwoWire *wire, uint8_t address, uint8_t quantity, uint32_t internalAddress, uint8_t internalAddressSize, uint8_t sendStop)\n{\n  i2c_status_e_conflict status;\n  uint8_t dataSize = (uint8_t)internalAddressSize;\n  if (!(wire->master)) {\n    return 0;\n  }\n  allocateRxBuffer((uint)quantity);\n  if (*(int *)PTR_rxBuffer_08002bf4 != 0) {\n    if (dataSize != 0) {\n      beginTransmission(wire, address);\n      if (3 < dataSize) {\n        dataSize = 3;\n      }\n      while (dataSize > 0) {\n        uint8_t byteToSend = (internalAddress >> ((dataSize - 1 & 0x1f) << 3)) & 0xff;\n        (**(wire->super_Stream).super_Print._vptr_Print)(wire, byteToSend);\n        dataSize--;\n      }\n      endTransmission(wire, 0);\n    }\n    status = i2c_master_read((i2c_t_conflict *)&wire->_i2c, address << 1, *(uint8_t **)PTR_rxBuffer_08002bf4, (ushort)quantity);\n    if (status != I2C_OK) {\n      quantity = 0;\n    }\n    *PTR_PTR_rxBuffer_08002bf4Index_08002bf8 = 0;\n    *PTR_PTR_rxBuffer_08002bf4Length_08002bfc = quantity;\n    return quantity;\n  }\n  (wire->super_Stream).super_Print.write_error = 1;\n  return 0;\n}",
            "called": [
                "beginTransmission",
                "endTransmission",
                "i2c_master_read",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b68",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromAddress_08002b68"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "disableI2C_080005e0",
                "*PTR_isI2CEnabled_080005f0": "*is_I2C_Enabled",
                "*PTR_queryIndex_080005f4": "*query_Index"
            },
            "code": "void disableI2C_080005e0(void)\n{\n  *PTR_isI2CEnabled_080005f0 = 0;\n  *PTR_queryIndex_080005f4 = 0xff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "disableI2C_080005e0"
        },
        "FUN_0800674c": {
            "renaming": {
                "FUN_0800674c": "do_nothing_0800674c"
            },
            "code": "\nvoid do_nothing_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_0800674c"
        },
        "FUN_0800674e": {
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "huart": "uart",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_UART_MspInit": "initialize_uart_msp",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_UART_STATE_RESET": "HAL_UART_STATE_RESET",
                "HAL_UART_STATE_BUSY": "HAL_UART_STATE_BUSY",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "ErrorCode": "ErrorCode",
                "Instance": "Instance",
                "CR1": "CR1",
                "CR2": "CR2",
                "CR3": "CR3",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "HAL_StatusTypeDef initialize_uart_0800674e(UART_HandleTypeDef *uart)\n{\n  if (uart != NULL) {\n    if (uart->gState == HAL_UART_STATE_RESET) {\n      uart->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uart);\n    }\n    uart->gState = HAL_UART_STATE_BUSY;\n    uart->Instance->CR1 &= ~(1 << 13);\n    UART_SetConfig(uart);\n    uart->Instance->CR2 &= ~(1 << 11);\n    uart->Instance->CR3 &= ~(1 << 2);\n    uart->Instance->CR1 |= (1 << 13);\n    uart->ErrorCode = 0;\n    uart->gState = HAL_UART_STATE_READY;\n    uart->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674e",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800674e"
        },
        "FUN_0800771c": {
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandleOC": "irq_handler_oc"
            },
            "code": "void handle_timer_interrupt_0800771c(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  stimer_t_conflict *timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->irq_handler_oc != (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) && (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->irq_handler_oc)(timer_obj, 0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800771c"
        },
        "FUN_08003370": {
            "renaming": {
                "FUN_08003370": "setSysexCallback_08003370",
                "this": "parser",
                "command": "command",
                "newFunction": "callback",
                "context": "context"
            },
            "code": "void __thiscall firmata::FirmataParser::setSysexCallback_08003370(FirmataParser *parser, uint8_t command, sysexCallbackFunction callback, void *context)\\n\\\n{\\n\\\n  parser->currentSysexCallback = callback;\\n\\\n  parser->currentSysexCallbackContext = context;\\n\\\n  return;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003370",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08003370"
        },
        "FUN_08003376": {
            "renaming": {
                "__thiscall": "",
                "firmata::FirmataParser::FUN_08003376": "isBufferOverflow",
                "*this": "parser",
                "data": "data",
                "pos": "position",
                "bVar1": "isOverflowed",
                "this->dataBufferSize": "parser->bufferSize",
                "this->currentDataBufferOverflowCallback": "parser->currentOverflowCallback",
                "(dataBufferOverflowCallbackFunction)0x0": "(dataBufferOverflowCallbackFunction)0x0",
                "this->allowBufferUpdate": "parser->allowBufferUpdate",
                "(*this->currentDataBufferOverflowCallback)(this->currentDataBufferOverflowCallbackContext)": "(*parser->currentOverflowCallback)(parser->currentOverflowCallbackContext)",
                "this->dataBuffer[pos]": "parser->buffer[position]",
                "FUN_08003376": "isBufferOverflow_08003376"
            },
            "code": "bool isBufferOverflow_08003376(FirmataParser *parser, uint8_t data, size_t position) {\n  bool isOverflowed;\n  if (position >= parser->bufferSize) {\n    isOverflowed = true;\n    if (parser->currentOverflowCallback != (dataBufferOverflowCallbackFunction)0x0) {\n      parser->allowBufferUpdate = true;\n      (*parser->currentOverflowCallback)(parser->currentOverflowCallbackContext);\n      if (position >= parser->bufferSize) {\n        isOverflowed = true;\n      }\n      else {\n        isOverflowed = false;\n      }\n    }\n  }\n  else {\n    isOverflowed = false;\n    parser->buffer[position] = data;\n  }\n  return isOverflowed;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003376",
            "calling": [
                "parse",
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "isBufferOverflow_08003376"
        },
        "FUN_08008bf4": {
            "renaming": {
                "FUN_08008bf4": "checkSerialAvailability_08008bf4",
                "DAT_08008c18": "serialFlag",
                "PTR_Serial2_08008c1c": "serialPointer"
            },
            "code": "void checkSerialAvailability_08008bf4(void)\n{\n  if (DAT_08008c18 != 0) {\n    HardwareSerial::available((HardwareSerial *)PTR_Serial2_08008c1c);\n  }\n  return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkSerialAvailability_08008bf4"
        },
        "FUN_08002c7c": {
            "renaming": {
                "FUN_08002c7c": "reportAnalogData_08002c7c",
                "param_1": "callback",
                "command": "command",
                "value": "value",
                "PTR_currentReportAnalogCallback_08002c8c": "currentReportAnalogCallback"
            },
            "code": "void firmata::FirmataClass::reportAnalogData_08002c7c(void *callback, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentReportAnalogCallback_08002c8c != (code *)0x0) {\n    (**(code **)PTR_currentReportAnalogCallback_08002c8c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c7c",
            "calling": [],
            "imported": false,
            "current_name": "reportAnalogData_08002c7c"
        },
        "FUN_08005430": {
            "renaming": {
                "FUN_08005430": "get_i2c_error_code_08005430",
                "hi2c": "i2c_handler",
                "ErrorCode": "error_code"
            },
            "code": "uint32_t get_i2c_error_code_08005430(I2C_HandleTypeDef_conflict *i2c_handler)\n{\n  return i2c_handler->ErrorCode;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005430",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_error_code_08005430"
        },
        "FUN_08009918": {
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "allocation_status",
                "param_2": "size",
                "puVar1": "error_ptr",
                "pcVar2": "address_ptr",
                "PTR_errno_08009934": "errno_ptr"
            },
            "code": "void allocate_memory_08009918(int *allocation_status, int size) {\n    undefined *error_ptr;\n    caddr_t address_ptr;\n    error_ptr = PTR_errno_08009934;\n    *(undefined4 *)PTR_errno_08009934 = 0;\n    address_ptr = _sbrk(size);\n    if ((address_ptr == (caddr_t)0xffffffff) && (*(int *)error_ptr != 0)) {\n        *allocation_status = *(int *)error_ptr;\n    }\n    return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009918",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009918"
        },
        "FUN_08005434": {
            "renaming": {
                "FUN_08005434": "delay_08005434",
                "mdelay": "milliseconds",
                "Delay": "cycles",
                "DAT_0800545c": "SYS_CLOCK_FREQ",
                "PTR_SystemCoreClock_08005458": "SYS_CLOCK_FREQ_PTR",
                "bVar1": "delay_complete"
            },
            "code": "void delay_08005434(uint32_t milliseconds)\n{\n  uint32_t cycles = milliseconds * ((uint64_t)DAT_0800545c * (uint64_t)*PTR_SystemCoreClock_08005458 >> 41);\n  while(cycles--);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005434",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_08005434"
        },
        "FUN_08005e2e": {
            "renaming": {
                "FUN_08005e2e": "resetTimer_08005e2e",
                "htim": "timer",
                "pTVar1": "timerInstance",
                "HAL_TIM_STATE_BUSY": "TIMER_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "TIMER_STATE_RESET",
                "HAL_UNLOCKED": "TIMER_UNLOCKED",
                "HAL_TIM_PWM_MspDeInit": "deInitPWM"
            },
            "code": "HAL_StatusTypeDef_conflict resetTimer_08005e2e(TIM_HandleTypeDef_conflict *timer)\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 &= ~(1 << 0);\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e2e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "resetTimer_08005e2e"
        },
        "FUN_08007736": {
            "renaming": {
                "FUN_08007736": "handle_timer_interrupt_08007736",
                "htim": "timer_handle",
                "psVar1": "timer_object",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "interrupt_handler"
            },
            "code": "void handle_timer_interrupt_08007736(TIM_HandleTypeDef_conflict *timer_handle){\n  stimer_t_conflict *timer_object;\n  \n  timer_object = get_timer_object(timer_handle);\n  if (timer_object->interrupt_handler != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*timer_object->interrupt_handler)(timer_object);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007736",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007736"
        },
        "FUN_08002c90": {
            "renaming": {
                "FUN_08002c90": "report_digital_values_08002c90",
                "param_1": "callback",
                "command": "command",
                "value": "value",
                "PTR_currentReportDigitalCallback_08002ca0": "current_report_digital_callback"
            },
            "code": "void firmata::FirmataClass::report_digital_values_08002c90(void *callback, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentReportDigitalCallback_08002ca0 != (code *)0x0) {\n    (**(code **)PTR_currentReportDigitalCallback_08002ca0)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c90",
            "calling": [],
            "imported": false,
            "current_name": "report_digital_values_08002c90"
        },
        "FUN_0800542a": {
            "renaming": {
                "FUN_0800542a": "get_i2c_state_0800542a",
                "hi2c": "i2c_handle"
            },
            "code": "HAL_I2C_StateTypeDef get_i2c_state_0800542a(I2C_HandleTypeDef *i2c_handle){\n  return i2c_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800542a",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_state_0800542a"
        },
        "FUN_0800457c": {
            "renaming": {
                "FUN_0800457c": "send_byte_0800457c",
                "hi2c": "i2c_handle",
                "pbVar1": "buffer_pointer",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "XferCount": "transfer_count",
                "HAL_StatusTypeDef_conflict": "HAL_status"
            },
            "code": "HAL_StatusTypeDef_conflict send_byte_0800457c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint8_t *buffer_pointer;\n  \n  if (i2c_handle->XferCount != 0) {\n    buffer_pointer = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_pointer + 1;\n    i2c_handle->Instance->DR = (uint8_t)*buffer_pointer;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800457c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_byte_0800457c"
        },
        "FUN_080091c6": {
            "renaming": {
                "FUN_080091c6": "fill_with_character_080091c6",
                "__s": "buffer",
                "__c": "character",
                "__n": "size",
                "puVar1": "current_byte",
                "(undefined *)__s": "buffer",
                "(undefined *)(__n + (int)__s)": "end_byte",
                "*puVar1": "*current_byte",
                "(char)__c": "(unsigned char)character"
            },
            "code": "void * fill_with_character_080091c6(void *buffer, int character, size_t size) {\n  unsigned char *current_byte;\n  unsigned char *end_byte = buffer + size;\n  \n  for (current_byte = buffer; current_byte < end_byte; current_byte++) {\n    *current_byte = (unsigned char)character;\n  }\n  \n  return buffer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091c6",
            "calling": [
                "begin",
                "std.isra.0",
                "endTransmission",
                "pwm_start",
                "__sfp",
                "adc_read_value",
                "flush",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "fill_with_character_080091c6"
        },
        "FUN_08003a20": {
            "renaming": {
                "FUN_08003a20": "check_ADC_status_08003a20",
                "*hadc": "*ADC_handle",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "*pAVar4": "*ADC_instance",
                "wait_loop_index": "wait_time"
            },
            "code": "HAL_StatusTypeDef_conflict check_ADC_status_08003a20(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t wait_time;\n  uint32_t start_time;\n  ADC_TypeDef *ADC_instance;\n  \n  ADC_instance = hadc->Instance;\n  if ((ADC_instance->CR2 & 1) == 0) {\n    ADC_instance->CR2 |= 1;\n    wait_time = (uint32_t)((uint64_t)DAT_08003a9c * (uint64_t)*(uint *)PTR_SystemCoreClock_08003a98 >> 0x32);\n    while (wait_time != 0) {\n        wait_time--;\n    }\n    start_time = HAL_GetTick();\n    do {\n      if ((hadc->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      uVar3 = HAL_GetTick();\n    } while (uVar3 - start_time < 3);\n    hadc->State |= 0x10;\n    hadc->ErrorCode |= 1;\n    hadc->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a20",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "imported": false,
            "current_name": "check_ADC_status_08003a20"
        },
        "FUN_08009cdc": {
            "renaming": {
                "std_isra_0": "initialize_data_structure",
                "*param_1": "*data_structure",
                "param_2": "value1",
                "param_3": "value2",
                "FUN_08009cdc": "initialize_data_structure_08009cdc"
            },
            "code": "void initialize_data_structure_08009cdc(undefined4 *data_structure, undefined2 value1, undefined2 value2) {\n  *data_structure = 0;\n  data_structure[1] = 0;\n  data_structure[2] = 0;\n  *(undefined2 *)(data_structure + 3) = value1;\n  data_structure[25] = 0;\n  *(undefined2 *)((int)data_structure + 0xe) = value2;\n  data_structure[4] = 0;\n  data_structure[5] = 0;\n  data_structure[6] = 0;\n  memset(data_structure + 23,0,8);\n  data_structure[8] = data_structure;\n  data_structure[9] = PTR_DAT_08009d14;\n  data_structure[10] = PTR_DAT_08009d18;\n  data_structure[11] = PTR_DAT_08009d1c;\n  data_structure[12] = PTR_DAT_08009d20;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cdc",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_08009cdc"
        },
        "FUN_080026b0": {
            "renaming": {
                "FUN_080026b0": "mapValueToMicroseconds_080026b0",
                "this": "servo",
                "value": "inputValue",
                "min": "minPulseWidth",
                "max": "maxPulseWidth"
            },
            "code": "void __thiscall Servo::mapValueToMicroseconds_080026b0(Servo *servo, int value) {\n  int minPulse = (0x88 - servo->min) * 4;\n  int maxPulse = (600 - servo->max) * 4;\n  if (value < 0x220) {\n    if (value < 0) {\n      value = 0;\n    } else if (value > 0xb4) {\n      value = 0xb4;\n    }\n    value = map(value, 0, 0xb4, minPulse, maxPulse);\n  }\n  mapValueToMicroseconds_080026b0Microseconds(servo, value);\n  return;\n}",
            "called": [
                "map",
                "writeMicroseconds"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026b0",
            "calling": [
                "analogWriteCallback"
            ],
            "imported": false,
            "current_name": "mapValueToMicroseconds_080026b0"
        },
        "FUN_08002a58": {
            "renaming": {
                "__thiscall TwoWire::FUN_08002a58": "transmitData",
                "sendStop": "sendStop",
                "i2c_status_e_conflict": "i2c_status",
                "iVar1": "status",
                "uVar2": "result",
                "this": "this",
                "master": "master",
                "i2c_t_conflict": "i2c_t",
                "*PTR_txAddress_08002ab0": "txAddress",
                "**PTR_txBuffer_08002aac": "txBuffer",
                "(ushort)(byte)*PTR_txBufferLength_08002aa8": "txBufferLength",
                "I2C_OK": "I2C_SUCCESS",
                "I2C_TIMEOUT": "I2C_TIMEOUT_ERROR",
                "memset": "memset",
                "*PTR_txBufferAllocated_08002ab4": "txBufferAllocated",
                "*PTR_txBufferIndex_08002ab8": "txBufferIndex",
                "*PTR_transmitting_08002abc": "transmitting",
                "FUN_08002a58": "transmitData_08002a58"
            },
            "code": "uint8_t __thiscall TwoWire::transmitData_08002a58(TwoWire *this, uint8_t sendStop)\n{\n  i2c_status_e_conflict status;\n  uint8_t result;\n  \n  if (this->master == false) {\n    result = I2C_MASTER_NOT_AVAILABLE;\n  }\n  else {\n    status = i2c_master_write((i2c_t_conflict *)&this->_i2c, *PTR_txAddress_08002ab0, ***PTR_txBuffer_08002aac, (ushort)(byte)*(ushort)(byte)*PTR_**PTR_txBuffer_08002aacLength_08002aa8);\n    if (status == I2C_OK) {\n      result = I2C_SUCCESS;\n    }\n    else if (status == I2C_TIMEOUT) {\n      result = I2C_TIMEOUT_ERROR;\n    }\n    else {\n      result = I2C_ERROR;\n    }\n    if (***PTR_txBuffer_08002aac != (void *)0x0) {\n      memset(***PTR_txBuffer_08002aac, 0, (uint)(byte)**PTR_**PTR_txBuffer_08002aacAllocated_08002ab4);\n    }\n    **PTR_**PTR_txBuffer_08002aacIndex_08002ab8 = 0;\n    *(ushort)(byte)*PTR_**PTR_txBuffer_08002aacLength_08002aa8 = 0;\n    **PTR_transmitting_08002abc = 0;\n  }\n  return result;\n}",
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a58",
            "calling": [
                "requestFrom",
                "endTransmission",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "transmitData_08002a58"
        },
        "FUN_080004d4": {
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "this": "servo_ptr",
                "iVar1": "servo_index"
            },
            "code": "void initialize_servos_080004d4(int should_initialize, int priority_level) {\n\tint servo_index;\n\tServo *servo_ptr;\n\tif (should_initialize != 1) {\n\t\treturn;\n\t}\n\tif (priority_level == 0xffff) {\n\t\tservo_ptr = (Servo *)PTR_servos_080004fc;\n\t\tfor (servo_index = 0xb; servo_index >= 0; servo_index--) {\n\t\t\tServo::Servo(servo_ptr);\n\t\t\tservo_ptr++;\n\t\t}\n\t}\n\treturn;\n}",
            "called": [
                "Servo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004d4",
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "imported": false,
            "current_name": "initialize_servos_080004d4"
        },
        "FUN_080005f8": {
            "renaming": {
                "FUN_080005f8": "FUNC_080005f8"
            },
            "code": "\nvoid FUNC_080005f8(byte pin,int mode)\n\n{\n  undefined *this;\n  byte bVar1;\n  PinName_conflict PVar2;\n  bool bVar3;\n  bool bVar4;\n  _Bool _Var5;\n  uint ulPin;\n  uint32_t uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  ulPin = (uint)pin;\n  bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n  if (bVar1 != '\\x7f') {\n    bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n    if (bVar1 == '\\x06') {\n      cVar7 = *PTR_isI2CEnabled_0800087c;\n      if (cVar7 == '\\0') {\n        cVar7 = '\\0';\n      }\n      else if (mode == 6) {\n        cVar7 = '\\0';\n      }\n    }\n    else {\n      cVar7 = '\\0';\n    }\n    if (cVar7 != '\\0') {\n      disableI2CPins();\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else if (mode == 4) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((byte)PTR_servoPinMap_08000880[ulPin] < 0xc) {\n        bVar3 = Servo::attached((Servo *)(PTR_servos_08000884 +\n                                         (uint)(byte)PTR_servoPinMap_08000880[ulPin] * 3));\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3 != false) {\n        detachServo(pin);\n      }\n    }\n    uVar8 = ulPin - 0x2e & 0xff;\n    if (uVar8 < 0xe) {\n      if (ulPin < 0x3c) {\n        PVar2 = PTR_digitalPin_08000878[ulPin];\n      }\n      else {\n        PVar2 = NC;\n      }\n      uVar6 = pinNametoDigitalPin(PVar2);\n      if (uVar6 == 0) {\n        bVar3 = false;\n      }\n      else {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 1) {\n          bVar3 = false;\n        }\n        else {\n          bVar3 = true;\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      reportAnalogCallback((byte)uVar8,(uint)(mode == 2));\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((mode == 0) || (mode == 0xb)) {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] | (byte)(1 << (ulPin & 7));\n      }\n      else {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] & ~(byte)(1 << (ulPin & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000874,pin,0);\n    switch(mode) {\n    case 0:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000a44,pin);\n        if (bVar1 == '\\x03') {\n          digitalWrite(ulPin,0);\n        }\n        pinMode(ulPin,1);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 < 0xe) {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          if (ulPin < 0x3c) {\n            PVar2 = PTR_digitalPin_08000878[ulPin];\n          }\n          else {\n            PVar2 = NC;\n          }\n          uVar6 = pinNametoDigitalPin(PVar2);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        if (ulPin < 0x3c) {\n          if (PTR_digitalPin_08000878[ulPin] == NC) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 0) {\n              bVar3 = false;\n            }\n            else {\n              uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n              if (uVar6 == 1) {\n                bVar3 = false;\n              }\n            }\n          }\n        }\n        else {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          pinMode(ulPin,0);\n        }\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        pinMode(ulPin,1);\n        analogWrite(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x04');\n        if (((byte)PTR_servoPinMap_08000a50[ulPin] != 0xff) &&\n           (bVar4 = Servo::attached((Servo *)(PTR_servos_08000a54 +\n                                             (uint)(byte)PTR_servoPinMap_08000a50[ulPin] * 3)),\n           bVar4)) {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000a58);\n              if (!_Var5) {\n                _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,2);\n        this = PTR_Firmata_08000a44;\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\v');\n        firmata::FirmataClass::setPinState((FirmataClass *)this,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "attached",
                "pin_in_pinmap",
                "disableI2CPins",
                "digitalWrite",
                "pinNametoDigitalPin",
                "analogWrite",
                "pinMode",
                "sendString",
                "reportAnalogCallback",
                "setPinState",
                "attachServo",
                "detachServo",
                "getPinMode",
                "setPinMode"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080005f8",
            "calling": [
                "enableI2CPins",
                "sysexCallback",
                "systemResetCallback"
            ],
            "imported": false,
            "current_name": "FUNC_080005f8"
        },
        "FUN_08002fa0": {
            "renaming": {
                "__thiscall firmata::FirmataClass::FUN_08002fa0": "getPinConfig",
                "this": "firmata",
                "pin": "pin",
                "FUN_08002fa0": "getPinConfig_08002fa0"
            },
            "code": "byte getPinConfig_08002fa0(FirmataClass *firmata, byte pin) {\n  return firmata->pinConfig[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa0",
            "calling": [
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "getPinConfig_08002fa0"
        },
        "FUN_0800a424": {
            "renaming": {
                "FUN_0800a424": "do_nothing_0800a424"
            },
            "code": "\nvoid do_nothing_0800a424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a424",
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800a424"
        },
        "FUN_08003a1c": {
            "renaming": {
                "FUN_08003a1c": "get_adc_state_08003a1c",
                "*hadc": "adc_handle",
                "hadc": "adc_handle",
                "State": "adc_state"
            },
            "code": "uint32_t get_adc_state_08003a1c(ADC_HandleTypeDef *adc_handle)\n{\n  return adc_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a1c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_state_08003a1c"
        },
        "FUN_08007744": {
            "renaming": {
                "FUN_08007744": "get_timer_count_08007744",
                "obj": "timer_obj",
                "(obj->handle).Instance": "timer_instance",
                "((obj->handle).Instance)->CNT": "timer_count"
            },
            "code": "uint32_t get_timer_count_08007744(stimer_t_conflict *timer_obj)\n{\n  TIM_TypeDef *timer_instance = (timer_obj->handle).Instance;\n  uint32_t timer_count = timer_instance->CNT;\n  return timer_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007744",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "get_timer_count_08007744"
        },
        "FUN_08006538": {
            "renaming": {
                "FUN_08006538": "set_uart_config_08006538",
                "huart": "uart_handle",
                "uVar1": "baud_rate",
                "uVar2": "usart_div",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "uVar5": "pclk_freq",
                "uVar6": "pclk_freq",
                "uVar7": "pclk_freq",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "uVar10": "baud_rate",
                "uVar11": "baud_rate",
                "pUVar12": "uart_instance",
                "DAT_080066e0": "USART1",
                "DAT_080066e4": "0x19"
            },
            "code": "void set_uart_config_08006538(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t pclk_freq;\n  uint32_t baud_rate = (uart_handle->Init).BaudRate;\n  uint32_t stop_bits = (uart_handle->Init).StopBits;\n  uint32_t word_length = (uart_handle->Init).WordLength;\n  uint32_t parity = (uart_handle->Init).Parity;\n  uint32_t mode = (uart_handle->Init).Mode;\n  uint32_t hw_flow_ctl = (uart_handle->Init).HwFlowCtl;\n  USART_TypeDef *uart_instance = uart_handle->Instance;\n  \n  uart_instance->CR2 = uart_instance->CR2 & 0xffffcfff | stop_bits;\n  uart_instance->CR1 = word_length | parity | mode | uart_instance->CR1 & 0xffffe9f3;\n  uart_instance->CR3 = uart_instance->CR3 & 0xfffffcff | hw_flow_ctl;\n  \n  if (uart_instance != DAT_080066e0)\n  {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n  }\n  else\n  {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n  }\n  \n  uint32_t usart_div = (uint32_t)((pclk_freq * 2) / baud_rate);\n  uint32_t mantissa = usart_div / 0x10;\n  uint32_t fraction = usart_div % 0x10;\n  \n  if (mantissa < 0x400)\n  {\n    mantissa = mantissa << 4;\n    fraction = fraction << 4;\n  }\n  else\n  {\n    mantissa = (mantissa / 0x2) << 4;\n    fraction = ((mantissa % 0x10) + fraction) << 4;\n    mantissa = (mantissa / 0x10) << 4;\n  }\n  \n  uart_instance->BRR = mantissa | fraction;\n}\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006538",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "set_uart_config_08006538"
        },
        "FUN_08002fa8": {
            "renaming": {
                "FUN_08002fa8": "setPinConfig_08002fa8",
                "pin": "pinNumber",
                "config": "pinConfigValue",
                "this->pinConfig": "this->pinConfigArray"
            },
            "code": "void __thiscall firmata::FirmataClass::setPinConfig_08002fa8(FirmataClass *this, byte pin, byte config)\n{\n  if (this->pinConfig[pin] != '\\x7f') {\n    this->pinConfig[pin] = config;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa8",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinConfig_08002fa8"
        },
        "FUN_0800325a": {
            "renaming": {
                "FUN_0800325a": "sendCommand_0800325a",
                "this": "self",
                "command": "command",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "uVar1": "index"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendCommand_0800325a(FirmataMarshaller *self, uint8_t command, size_t numBytes, uint8_t *byteArray) {\n  uint index = 0;\n  if (self->FirmataStream != nullptr) {\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self,0xf0);\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self->FirmataStream,(uint)command);\n    for (index = 0; index < numBytes; index++) {\n      encodeByteStream(self, 1, byteArray + index, 0);\n    }\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self->FirmataStream,0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800325a",
            "calling": [
                "sendString",
                "sendSysex"
            ],
            "imported": false,
            "current_name": "sendCommand_0800325a"
        },
        "FUN_080091d8": {
            "renaming": {
                "FUN_080091d8": "allocate_memory_080091d8",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "unused_param1",
                "param_4": "unused_param2",
                "puVar1": "free_list",
                "extraout_r1": "extraout_r1",
                "ppiVar2": "new_ptr",
                "ppiVar3": "end_ptr",
                "piVar4": "block_ptr",
                "ppiVar5": "current_ptr",
                "ppiVar6": "next_ptr",
                "ppiVar7": "previous_ptr"
            },
            "code": "void allocate_memory_080091d8(int* error_code, int size, int unused_param1, int unused_param2)\n{\n    if (size == 0) {\n        return;\n    }\n    int** previous_ptr = (int**)(size - sizeof(int));\n    if (*previous_ptr < 0) {\n        previous_ptr = (int**)((int)previous_ptr + *previous_ptr);\n    }\n    __malloc_lock();\n    void* free_list = PTR___malloc_free_list_0800926c;\n    int** current_ptr = *(int***)(free_list);\n    if (current_ptr == NULL) {\n        previous_ptr[1] = NULL;\n        *(int***)(free_list) = previous_ptr;\n        int** extraout_r1 = NULL;\n        int** new_ptr = (int**)free_list;\n    }\n    else if (previous_ptr < current_ptr) {\n        int** next_ptr = (int**)current_ptr[0];\n        int** end_ptr = (int**)((int)current_ptr + (int)next_ptr);\n        if (current_ptr == end_ptr) {\n            int* block_ptr = current_ptr[0];\n            current_ptr = (int**)current_ptr[1];\n            end_ptr = (int**)((int)block_ptr + (int)next_ptr);\n            previous_ptr[0] = (int*)end_ptr;\n        }\n        previous_ptr[1] = (int*)current_ptr;\n        *(int***)(free_list) = previous_ptr;\n    }\n    else {\n        while (current_ptr[1] != NULL && current_ptr[1] <= previous_ptr) {\n            current_ptr = (int**)current_ptr[1];\n        }\n        int** next_ptr = (int**)current_ptr[1];\n        if ((int**)((int)current_ptr + (int)next_ptr) == previous_ptr) {\n            next_ptr = (int**)((int)next_ptr + (int)*previous_ptr);\n            current_ptr[0] = (int*)next_ptr;\n            if ((int**)((int)current_ptr + (int)next_ptr) == (int**)next_ptr[1]) {\n                int* block_ptr = next_ptr[0];\n                next_ptr = (int**)next_ptr[1];\n                next_ptr = (int**)((int)next_ptr + (int)block_ptr);\n                current_ptr[0] = (int*)next_ptr;\n                current_ptr[1] = (int*)next_ptr[1];\n            }\n        }\n        else if (previous_ptr < (int**)((int)current_ptr + (int)next_ptr)) {\n            *error_code = 0xc;\n        }\n        else {\n            next_ptr = (int**)((int)previous_ptr + (int)*previous_ptr);\n            if ((int**)((int)current_ptr + (int)next_ptr) == next_ptr[1]) {\n                int* block_ptr = next_ptr[0];\n                next_ptr = (int**)next_ptr[1];\n                next_ptr = (int**)((int)block_ptr + (int)next_ptr);\n                previous_ptr[0] = (int*)next_ptr;\n            }\n            previous_ptr[1] = (int*)next_ptr[1];\n            current_ptr[1] = (int*)previous_ptr;\n        }\n    }\n    __malloc_unlock(error_code, current_ptr, previous_ptr, unused_param2);\n    return;\n}",
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091d8",
            "calling": [
                "free",
                "__swsetup_r",
                "_realloc_r",
                "__sflush_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080091d8"
        },
        "FUN_0800688e": {
            "renaming": {
                "FUN_0800688e": "UART_transmit_0800688e",
                "*huart": "*huart",
                "*pData": "*data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "pData": "data",
                "HAL_BUSY": "HAL_BUSY",
                "(uint8_t *)0x0": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "huart->Lock": "huart->Lock",
                "huart->pTxBuffPtr": "huart->pTxBuffPtr",
                "huart->TxXferSize": "huart->TxXferSize",
                "huart->TxXferCount": "huart->TxXferCount",
                "huart->ErrorCode": "huart->ErrorCode",
                "huart->gState": "huart->gState",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "huart->Instance->CR1": "huart->Instance->CR1",
                "0x80": "USART_CR1_TXEIE",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef UART_transmit_0800688e(UART_HandleTypeDef *huart, uint8_t *data, uint16_t size)\n{\n    if (huart->gState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == NULL) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (huart->Lock != HAL_LOCKED) {\n        huart->pTxBuffPtr = data;\n        huart->TxXferSize = size;\n        huart->TxXferCount = size;\n        huart->ErrorCode = 0;\n        huart->gState = HAL_UART_STATE_BUSY_TX;\n        huart->Lock = HAL_UNLOCKED;\n        huart->Instance->CR1 |= USART_CR1_TXEIE;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800688e",
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "imported": false,
            "current_name": "UART_transmit_0800688e"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "initialize_static_variables_080090b4"
            },
            "code": "void initialize_static_variables_080090b4(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_080090b4"
        },
        "FUN_0800870c": {
            "renaming": {
                "FUN_0800870c": "handle_uart_data_0800870c",
                "*huart": "*uart_handle",
                "bVar1": "index",
                "uVar2": "index_uint",
                "PTR_rx_callback_08008728": "rx_callback_ptr",
                "PTR_rx_callback_obj_0800872c": "rx_callback_obj_ptr"
            },
            "code": "void handle_uart_data_0800870c(UART_HandleTypeDef *uart_handle) {\n  byte index = uart_index(uart_handle);\n  uint index_uint = (uint)index;\n  if (index_uint < 5) {\n    (**(code **)(PTR_rx_callback_08008728 + index_uint * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_0800872c + index_uint * 4));\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800870c",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "handle_uart_data_0800870c"
        },
        "FUN_08008840": {
            "renaming": {
                "FUN_08008840": "return_error_08008840",
                "file_UNUSED": "file"
            },
            "code": "int return_error_08008840(int file) {\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008840",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "return_error_08008840"
        },
        "FUN_08008600": {
            "renaming": {
                "FUN_08008600": "receive_serial_data_08008600",
                "obj": "serial_object",
                "c": "received_data",
                "uVar1": "rx_active_flag"
            },
            "code": "int receive_serial_data_08008600(serial_t *serial_object, uchar *received_data)\n{\n    uint8_t rx_active_flag;\n    \n    if (serial_object == NULL) {\n        return -1;\n    }\n    \n    rx_active_flag = serial_rx_active(serial_object);\n    \n    if (rx_active_flag == 0) {\n        *received_data = serial_object->recv;\n        HAL_UART_Receive_IT(*(UART_HandleTypeDef **) (PTR_uart_handlers_08008638 + (uint) serial_object->index * 4),\n                            &serial_object->recv, 1);\n        return 0;\n    }\n    \n    return -1;\n}",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008600",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_serial_data_08008600"
        },
        "FUN_08003154": {
            "renaming": {
                "FUN_08003154": "setFirmataStream_08003154",
                "s": "firmataStream"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::setFirmataStream_08003154(Stream *firmataStream)\n{\n  this->FirmataStream = firmataStream;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003154",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setFirmataStream_08003154"
        },
        "FUN_08006420": {
            "renaming": {
                "FUN_08006420": "setChannelState_08006420",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channelState",
                "CCER": "clearMask",
                "shiftAmount": "shiftAmount"
            },
            "code": "void setChannelState_08006420(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t channelState) {\n  uint32_t clearMask = ~(4 << (channel & 0xff));\n  timer->CCER &= clearMask;\n  uint32_t shiftAmount = (channel & 0xff);\n  timer->CCER |= (channelState << shiftAmount);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006420",
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "setChannelState_08006420"
        },
        "FUN_08007750": {
            "renaming": {
                "FUN_08007750": "set_timer_channel_08007750",
                "obj": "timer_obj",
                "channel": "channel_number",
                "value": "value_to_set"
            },
            "code": "void set_timer_channel_08007750(stimer_t_conflict *timer_obj, uint32_t channel_number, uint32_t value_to_set) {\n  uint32_t *channel_register = &((timer_obj->handle).Instance)->CCR1;\n  channel_register[channel_number] = value_to_set;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007750",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_channel_08007750"
        },
        "FUN_08009938": {
            "renaming": {
                "FUN_08009938": "find_char_in_string_08009938",
                "__s": "str",
                "__c": "c",
                "pbVar1": "current_char"
            },
            "code": "char* find_char_in_string_08009938(char* str, int c) {\n\tbyte* current_char;\n\t\n\twhile(*str != 0) {\n\t\tcurrent_char = (byte*)str;\n\t\tif(*current_char == (byte)c) {\n\t\t\treturn (char*)current_char;\n\t\t}\n\t\tstr = (char*)(current_char + 1);\n\t}\n\t\n\tif((c & 0xff) != 0) {\n\t\treturn NULL;\n\t}\n\t\n\treturn (char*)current_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009938",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "find_char_in_string_08009938"
        },
        "FUN_08007f0e": {
            "renaming": {
                "FUN_08007f0e": "check_i2c_communication_status_08007f0e",
                "obj": "i2c_object",
                "dev_address": "device_address",
                "data": "data_buffer",
                "size": "data_size",
                "HVar1": "i2c_state",
                "HVar2": "i2c_status",
                "uVar3": "start_time",
                "uVar4": "i2c_error",
                "uVar5": "elapsed_time",
                "iVar6": "status",
                "hi2c": "i2c_handle"
            },
            "code": "i2c_status_e check_i2c_communication_status_08007f0e(i2c_t *i2c_object, uint8_t device_address, uint8_t *data_buffer, uint16_t data_size)\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  HAL_StatusTypeDef i2c_status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t elapsed_time = 0;\n  i2c_status_e status = I2C_ERROR;\n  I2C_HandleTypeDef *i2c_handle;\n  do {\n    i2c_handle = &i2c_object->handle;\n    i2c_status = HAL_I2C_Master_Receive_IT(i2c_handle, (uint16_t)device_address, data_buffer, data_size);\n    if (i2c_status == HAL_OK) {\n      status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(i2c_handle), i2c_state != HAL_I2C_STATE_READY && (status == I2C_OK))) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time < 0x65) {\n          uint32_t i2c_error = HAL_I2C_GetError(i2c_handle);\n          if (i2c_error != 0) {\n            status = I2C_ERROR;\n          }\n        }\n        else {\n          status = I2C_TIMEOUT;\n        }\n      }\n    }\n    uint32_t i2c_error = HAL_I2C_GetError(i2c_handle);\n  } while ((i2c_error == 4) && (elapsed_time < 100));\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Receive_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f0e",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "check_i2c_communication_status_08007f0e"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "set_interrupt_handler_08004004",
                "IRQn": "irq",
                "uVar1": "irq_num",
                "DAT_08004020": "interrupt_enable_base"
            },
            "code": "void set_interrupt_handler_08004004(IRQn_Type_conflict irq) {\n  uint irq_num = (uint)irq;\n  if (irq_num >= 0) {\n    int* interrupt_enable_reg = (int*)(DAT_08004020 + ((irq_num >> 5) + 0x60) * 4);\n    *interrupt_enable_reg = 1 << (irq_num & 0x1f);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_interrupt_handler_08004004"
        },
        "FUN_08003158": {
            "renaming": {
                "FUN_08003158": "sendPinValue_08003158",
                "this": "marshaller",
                "pin": "pin",
                "value": "value",
                "local_a": "encoded_value",
                "FirmataStream": "FirmataStream",
                "Stream": "Stream",
                "super_Print": "super_Print",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream",
                "sendExtendedAnalog": "sendExtendedAnalog"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendPinValue_08003158(FirmataMarshaller *marshaller, uint8_t pin, uint16_t value) {\n    uint16_t encoded_value;\n    if (marshaller->FirmataStream != (Stream *)0x0) {\n        encoded_value = value;\n        if ((pin < 0x10) && (value < 0x4000)) {\n            (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller, pin | 0xe0);\n            encodeByteStream(marshaller, 2, (uint8_t *)&encoded_value, 2);\n        }\n        else {\n            sendExtendedAnalog(marshaller, pin, 2, (uint8_t *)&encoded_value);\n        }\n    }\n}",
            "called": [
                "encodeByteStream",
                "sendExtendedAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003158",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendPinValue_08003158"
        },
        "FUN_080090c2": {
            "renaming": {
                "FUN_080090c2": "register_atexit_handler_080090c2",
                "param_1": "handler_arg",
                "param_2": "arg",
                "__cxa_atexit": "register_exit_function"
            },
            "code": "void register_atexit_handler_080090c2(void (*handler)(void*), void* arg)\n{\n  __cxa_atexit(handler, arg);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c2",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_atexit_handler_080090c2"
        },
        "FUN_08000ef8": {
            "renaming": {
                "FUN_08000ef8": "FUNC_08000ef8"
            },
            "code": "\nvoid FUNC_08000ef8(void)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (*PTR_reportPINs_08001188 != '\\0') {\n    bVar1 = *PTR_portConfigInputs_0800118c;\n    if (*PTR_digitalPin_08001190 == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001190[1] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(1);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001190[2] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(2);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001190[3] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(3);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001190[4] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(4);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001190[5] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(5);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001190[6] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(6);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001190[7] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(7);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\0',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001188[1] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800118c[1];\n    if (PTR_digitalPin_08001190[8] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[8]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[8]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(8);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001424[9] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(9);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001424[10] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(10);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001424[0xb] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xb);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001424[0xc] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xc);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001424[0xd] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xd);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001424[0xe] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xe);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001424[0xf] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xf);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x01',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001428[2] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800142c[2];\n    if (PTR_digitalPin_08001424[0x10] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x10);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x11] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x11);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_080016c4[0x12] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x12);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_080016c4[0x13] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x13);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_080016c4[0x14] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x14);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_080016c4[0x15] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x15);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_080016c4[0x16] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x16);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_080016c4[0x17] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x17);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x02',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_080016c8[3] != '\\0') {\n    bVar1 = PTR_portConfigInputs_080016cc[3];\n    if (PTR_digitalPin_080016c4[0x18] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x18);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x19] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x19]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x19]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x19);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001960[0x1a] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1a);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001960[0x1b] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1b);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001960[0x1c] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1c);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001960[0x1d] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1d);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001960[0x1e] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1e);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001960[0x1f] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1f);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x03',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001964[4] != '\\0') {\n    bVar1 = PTR_portConfigInputs_08001968[4];\n    if (PTR_digitalPin_08001960[0x20] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x20);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001960[0x21] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x21);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001b44[0x22] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x22);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001b44[0x23] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x23);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001b44[0x24] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x24);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001b44[0x25] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x25);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001b44[0x26] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x26);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001b44[0x27] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x27);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x04',bVar5,'\\0');\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ef8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "FUNC_08000ef8"
        },
        "FUN_08008846": {
            "renaming": {
                "FUN_08008846": "set_file_mode_to_directory_08008846",
                "file_UNUSED": "unused_file",
                "st": "file_stats"
            },
            "code": "int set_file_mode_to_directory_08008846(stat *file_stats)\n{\n  file_stats->st_mode = 0x2000;\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008846",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_to_directory_08008846"
        },
        "FUN_0800a430": {
            "renaming": {
                "FUN_0800a430": "do_nothing_0800a430"
            },
            "code": "\nvoid do_nothing_0800a430(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a430",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800a430"
        },
        "FUN_0800459c": {
            "renaming": {
                "FUN_0800459c": "transfer_data_0800459c",
                "hi2c": "i2c_handle",
                "XferCount": "transfer_count",
                "pBuffPtr": "data_ptr",
                "puVar1": "data_byte"
            },
            "code": "HAL_StatusTypeDef_conflict transfer_data_0800459c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint8_t *data_ptr;\n  if (i2c_handle->transfer_count != 0) {\n    data_ptr = i2c_handle->data_ptr;\n    i2c_handle->data_ptr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->transfer_count--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_data_0800459c"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "set_timer_0800774a",
                "obj": "timer_object",
                "value": "count",
                "(obj->handle).Instance": "timer_handle",
                "(obj->handle).Instance->CNT": "timer_handle->Instance->CNT"
            },
            "code": "void set_timer_0800774a(stimer_t_conflict *timer_object, uint32_t count) {\n  TIM_HandleTypeDef *timer_handle = &(timer_object->handle);\n  timer_handle->Instance->CNT = count;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_0800774a"
        },
        "FUN_080027f0": {
            "renaming": {
                "__thiscall TwoWire::FUN_080027f0": "transmitData",
                "*data": "data",
                "quantity": "quantity",
                "cVar1": "bufferIndex",
                "puVar2": "txBuffer",
                "iVar3": "status",
                "pvVar4": "reallocResult",
                "uVar5": "bufferAllocated",
                "__size": "bufferSize",
                "*PTR_txBuffer_08002884": "txBuffer",
                "*PTR_transmitting_08002878": "isTransmitting",
                "i2c_slave_FUN_080027f0_IT": "i2c_slave_transmit",
                "I2C_OK": "I2C_SUCCESS",
                "*PTR_txBufferLength_0800287c": "txBufferLength",
                "*PTR_txBufferAllocated_08002880": "txBufferAllocated",
                "0x20": "MIN_BUFFER_SIZE",
                "*PTR_txBufferIndex_08002888": "txBufferIndex",
                "memcpy": "copyData",
                "FUN_080027f0": "transmitData_080027f0"
            },
            "code": "size_t __thiscall transmitData_080027f0(TwoWire *wire,uint8_t *data,size_t quantity)\n{\n  char bufferIndex;\n  undefined **PTR_txBuffer_08002884;\n  uint8_t *PTR_transmitting_08002878;\n  i2c_status_e_conflict status;\n  void *reallocResult;\n  undefined bufferAllocated;\n  size_t bufferSize;\n  \n  *PTR_txBuffer_08002884 = PTR_*PTR_txBuffer_08002884_08002884;\n  *PTR_transmitting_08002878 = *PTR_transmitting_08002878;\n  if (*PTR_transmitting_08002878 == 0) {\n    status = i2c_slave_transmit((i2c_t_conflict *)&wire->_i2c,data,(uint16_t)quantity);\n    if (status != I2C_OK) {\n      return 0;\n    }\n    return quantity;\n  }\n  bufferSize = (byte)*PTR_*PTR_*PTR_txBuffer_08002884Length_0800287c_0800287c + quantity;\n  bufferAllocated = (byte)*PTR_*PTR_*PTR_txBuffer_08002884Allocated_08002880_08002880;\n  if (bufferAllocated < bufferSize) {\n    if (bufferSize < 0x20) {\n      bufferSize = 0x20;\n    }\n    reallocResult = realloc(*(void **)*PTR_txBuffer_08002884,bufferSize);\n    *(void **)*PTR_txBuffer_08002884 = reallocResult;\n    if (reallocResult == (void *)0x0) {\n      bufferAllocated = 0;\n    }\n    else {\n      bufferAllocated = (undefined)bufferSize;\n    }\n    *PTR_*PTR_*PTR_txBuffer_08002884Allocated_08002880_08002880 = bufferAllocated;\n  }\n  bufferIndex = *PTR_*PTR_*PTR_txBuffer_08002884Index_08002888_08002888;\n  if (*(int *)*PTR_txBuffer_08002884 != 0) {\n    memcpy((void *)((uint)(byte)*PTR_*PTR_*PTR_txBuffer_08002884Index_08002888_08002888 + *(int *)*PTR_txBuffer_08002884),data,\n           quantity);\n    bufferIndex += (char)quantity;\n    *PTR_*PTR_*PTR_txBuffer_08002884Index_08002888_08002888 = bufferIndex;\n    *PTR_*PTR_*PTR_txBuffer_08002884Length_0800287c_0800287c = bufferIndex;\n    return quantity;\n  }\n  (wire->super_Stream).super_Print.transmitData_080027f0_error = 1;\n  return 0;\n}",
            "called": [
                "memcpy",
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f0",
            "calling": [],
            "imported": false,
            "current_name": "transmitData_080027f0"
        },
        "FUN_0800314e": {
            "renaming": {
                "FUN_0800314e::FUN_0800314e": "FirmataStreamInitializer::FirmataStreamInitializer",
                "this": "this_ptr",
                "FirmataStream": "nullptr",
                "FUN_0800314e": "FirmataStreamInitializer_0800314e"
            },
            "code": "FirmataStreamInitializer_0800314e* __thiscall firmata::FirmataStreamInitializer_0800314e::FirmataStreamInitializer_0800314e(FirmataStreamInitializer_0800314e* this_ptr)\n{\n    this_ptr->FirmataStream = nullptr;\n    return this_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "FirmataStreamInitializer_0800314e"
        },
        "FUN_080036a0": {
            "renaming": {
                "FUN_080036a0": "infinite_loop_080036a0"
            },
            "code": "void infinite_loop_080036a0() \n{ \n  while(true) \n  { \n    // Do nothing \n  } \n}",
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a0",
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_080036a0"
        },
        "FUN_080036a2": {
            "renaming": {
                "FUN_080036a2": "initialize_EVP_PKEY_CTX_080036a2",
                "ctx": "context",
                "hw_config_FUN_080036a2": "configure_hardware"
            },
            "code": "int initialize_EVP_PKEY_CTX_080036a2(EVP_PKEY_CTX *context)\n{\n  configure_hardware();\n  return (int)context;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a2",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_080036a2"
        },
        "FUN_080038e4": {
            "renaming": {
                "FUN_080038e4": "configureADC_080038e4",
                "*hadc": "*adc_handle",
                "*sConfig": "*channel_config",
                "HVar1": "status",
                "uVar2": "rank",
                "pAVar3": "adc_instance",
                "wait_loop_index": "i"
            },
            "code": "HAL_StatusTypeDef configureADC_080038e4(ADC_HandleTypeDef *adc_handle, ADC_ChannelConfTypeDef *channel_config) {\n    HAL_StatusTypeDef status;\n    uint32_t rank = channel_config->Rank;\n    uint32_t channel = channel_config->Channel;\n    uint32_t sampling_time = channel_config->SamplingTime;\n\n    if (adc_handle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n    }\n    else {\n        adc_handle->Lock = HAL_LOCKED;\n        if (rank < 7) {\n            uint32_t sqr3_shift = (rank * 5) - 5;\n            adc_handle->Instance->SQR3 = (channel << sqr3_shift) | (adc_handle->Instance->SQR3 & ~(0x1f << sqr3_shift));\n        }\n        else if (rank < 0xd) {\n            uint32_t sqr2_shift = (rank * 5) - 0x23;\n            adc_handle->Instance->SQR2 = (channel << sqr2_shift) | (adc_handle->Instance->SQR2 & ~(0x1f << sqr2_shift));\n        }\n        else {\n            uint32_t sqr1_shift = (rank * 5) - 0x41;\n            adc_handle->Instance->SQR1 = (channel << sqr1_shift) | (adc_handle->Instance->SQR1 & ~(0x1f << sqr1_shift));\n        }\n        if (channel < 10) {\n            adc_handle->Instance->SMPR2 = (sampling_time << (channel * 3)) | (adc_handle->Instance->SMPR2 & ~(7 << (channel * 3)));\n        }\n        else {\n            uint32_t smpr1_shift = (channel * 3) - 0x1e;\n            adc_handle->Instance->SMPR1 = (sampling_time << smpr1_shift) | (adc_handle->Instance->SMPR1 & ~(7 << smpr1_shift));\n        }\n        if (channel >= 0x10 && channel <= 0x12) {\n            ADC_TypeDef *adc_instance = adc_handle->Instance;\n            if (adc_instance == ADC1) {\n                if ((adc_instance->CR2 & 0x800000) == 0) {\n                    adc_instance->CR2 |= 0x800000;\n                    if (channel == 0x10) {\n                        for (uint32_t i = 0; i < (uint32_t)((uint64_t)ADC_CLOCKS_PER_DELAY * (uint64_t)*SYS_CLOCK_FREQ_PTR >> 0x32) * 10; i++);\n                        status = HAL_OK;\n                    }\n                    else {\n                        status = HAL_OK;\n                    }\n                }\n                else {\n                    status = HAL_OK;\n                }\n            }\n            else {\n                adc_handle->State |= 0x20;\n                status = HAL_ERROR;\n            }\n        }\n        else {\n            status = HAL_OK;\n        }\n        adc_handle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038e4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configureADC_080038e4"
        },
        "FUN_08005e68": {
            "renaming": {
                "FUN_08005e68": "do_nothing_08005e68"
            },
            "code": "\nvoid do_nothing_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e68",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e68"
        },
        "FUN_08005d48": {
            "renaming": {
                "FUN_08005d48": "configure_timer_08005d48",
                "TIMx": "timer",
                "OC_Config": "config",
                "uVar1": "ccer_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode",
                "DAT_08005da8": "PTR_08005da8"
            },
            "code": "void configure_timer_08005d48(TIM_TypeDef_conflict *timer,TIM_OC_InitTypeDef *config)\n{\n  uint32_t ccer_mask = 0xfffffeff;\n  uint32_t cr2_value = timer->CR2;\n  uint oc_mode = config->OCMode;\n  uint32_t ccer_value = (timer->CCER & 0xfffffdff) | (config->OCPolarity << 8);\n  if (timer == DAT_08005da8) {\n    ccer_value = (ccer_value & 0xfffff7ff) | (config->OCNPolarity << 8);\n    cr2_value = (cr2_value & 0xffffcfff) | (config->OCIdleState << 4) | (config->OCNIdleState << 4);\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR2 = (timer->CCMR2 & 0xffffff8c) | oc_mode;\n  timer->CCR3 = config->Pulse;\n  timer->CCER = ccer_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d48",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005d48"
        },
        "FUN_08008ba4": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08008ba4": "writeByte",
                "this": "serial",
                "c": "byteToSend",
                "_written": "isDataWritten",
                "_serial": "serial->_serial",
                "tx_head": "txHead",
                "tx_tail": "txTail",
                "tx_buff": "serial->_serial.tx_buff",
                "uVar2": "nextTxHead",
                "serial_tx_active": "isSerialTxActive",
                "uart_attach_tx_callback": "uartAttachTxCallback",
                "DAT_08008bf0": "txCallback",
                "FUN_08008ba4": "writeByte_08008ba4"
            },
            "code": "size_t __thiscall HardwareSerial::writeByte_08008ba4(HardwareSerial *serial,uint8_t byteToSend)\n{\n  bool isDataWritten;\n  uint txHead;\n  uint txTail;\n  uint txBuffSize;\n  uint nextTxHead;\n  uint txBuffIndex;\n  \n  isDataWritten = true;\n  txHead = serial->_serial.tx_head;\n  txBuffSize = sizeof(serial->_serial.tx_buff);\n  nextTxHead = (txHead + 1) % txBuffSize;\n  if (nextTxHead == serial->_serial.tx_tail) {\n    return 0;\n  }\n  serial->_serial.tx_buff[txHead] = byteToSend;\n  serial->_serial.tx_head = nextTxHead;\n  txTail = serial->_serial.tx_tail;\n  if (txHead == txTail) {\n    uart_attach_tx_callback((serial_t *)&serial->_serial, DAT_08008bf0);\n  }\n  return 1;\n}",
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba4",
            "calling": [],
            "imported": false,
            "current_name": "writeByte_08008ba4"
        },
        "FUN_08009ff8": {
            "renaming": {
                "FUN_08009ff8": "kill_process_if_exists_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "puVar1": "error_ptr",
                "iVar2": "kill_result"
            },
            "code": "void kill_process_if_exists_08009ff8(int *error_code, int process_id, int signal){\n    undefined *error_ptr;\n    int kill_result;\n\n    error_ptr = PTR_errno_0800a018;\n    *(undefined4 *)PTR_errno_0800a018 = 0;\n    kill_result = _kill(process_id, signal);\n    if ((kill_result == -1) && (*(int *)error_ptr != 0)) {\n        *error_code = *(int *)error_ptr;\n    }\n    return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009ff8",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_if_exists_08009ff8"
        },
        "FUN_08009db0": {
            "renaming": {
                "FUN_08009db0": "allocate_memory_block_08009db0",
                "param_1": "error_code",
                "piVar1": "block_size",
                "piVar2": "block_pointer",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "current_block_pointer"
            },
            "code": "int * allocate_memory_block_08009db0(undefined4 *error_code) {\n  int *block_pointer;\n  int *current_block_pointer;\n  int global_impure_ptr = *(int *)PTR__global_impure_ptr_08009e24;\n  if (*(int *)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  current_block_pointer = (int *)(global_impure_ptr + 0x48);\n  do {\n    block_pointer = current_block_pointer[2];\n    int block_size = current_block_pointer[1];\n    while (block_size = (int *)((int)block_size + -1), -1 < (int)block_size) {\n      if (*(short *)(block_pointer + 3) == 0) {\n        *(undefined2 *)((int)block_pointer + 0xe) = 0xffff;\n        block_pointer[0x19] = 0;\n        *(undefined2 *)(block_pointer + 3) = 1;\n        *block_pointer = 0;\n        block_pointer[2] = 0;\n        block_pointer[1] = 0;\n        block_pointer[4] = 0;\n        block_pointer[5] = 0;\n        block_pointer[6] = 0;\n        memset(block_pointer + 0x17,0,8);\n        block_pointer[0xd] = 0;\n        block_pointer[0xe] = 0;\n        block_pointer[0x12] = 0;\n        block_pointer[0x13] = 0;\n        return block_pointer;\n      }\n      block_pointer = block_pointer + 0x1a;\n    }\n    if (*current_block_pointer == (int *)0x0) {\n      block_size = (int *)__sfmoreglue(error_code,4);\n      *current_block_pointer = block_size;\n      if (block_size == (int *)0x0) {\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    current_block_pointer = (int **)*current_block_pointer;\n  } while( true );\n}",
            "called": [
                "memset",
                "__sinit",
                "__sfmoreglue"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009db0",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009db0"
        },
        "FUN_08002c2c": {
            "renaming": {
                "FUN_08002c2c": "analogCallbackHandler_08002c2c",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentAnalogCallback_08002c3c": "currentAnalogCallback"
            },
            "code": "void firmata::FirmataClass::analogCallbackHandler_08002c2c(void *callbackFunction, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentAnalogCallback_08002c3c != (code *)0x0) {\n    (**(code **)PTR_currentAnalogCallback_08002c3c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2c",
            "calling": [],
            "imported": false,
            "current_name": "analogCallbackHandler_08002c2c"
        },
        "FUN_080072f0": {
            "renaming": {
                "FUN_080072f0": "read_gpio_pin_state_080072f0",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "GVar1": "pin_state"
            },
            "code": "uint32_t read_gpio_pin_state_080072f0(GPIO_TypeDef *gpio_port, uint32_t gpio_pin) {\n  GPIO_PinState pin_state = HAL_GPIO_ReadPin(gpio_port, (uint16_t)gpio_pin);\n  return (uint32_t)pin_state;\n}",
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072f0",
            "calling": [
                "digitalRead"
            ],
            "imported": false,
            "current_name": "read_gpio_pin_state_080072f0"
        },
        "FUN_08000178": {
            "renaming": {
                "FUN_08000178": "count_characters_08000178",
                "__s": "string",
                "pcVar3": "string_start",
                "pcVar2": "current_position",
                "cVar1": "current_char"
            },
            "code": "size_t count_characters_08000178(char *string)\n{\n  char current_char;\n  char *current_position;\n  char *string_start;\n  string_start = string;\n  do {\n    current_position = string_start + 1;\n    current_char = *string_start;\n    string_start = current_position;\n  } while (current_char != '\\0');\n  return (size_t)(current_position + (-1 - (int)string));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000178",
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion",
                "printNumber"
            ],
            "imported": false,
            "current_name": "count_characters_08000178"
        },
        "FUN_08000a64": {
            "renaming": {
                "FUN_08000a64": "initializeI2CPins_08000a64",
                "_Var1": "isPinValid",
                "uVar2": "digitalPinNumber",
                "uVar3": "pinIndex"
            },
            "code": "void initializeI2CPins_08000a64() {\n  bool isPinValid;\n  uint32_t digitalPinNumber;\n  uint8_t pinIndex;\n  for (pinIndex = 0; pinIndex < 60; pinIndex++) {\n    if (PTR_digitalPin_08000ad8[pinIndex] == NC) {\n      isPinValid = false;\n    }\n    else {\n      digitalPinNumber = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pinIndex]);\n      if (digitalPinNumber == 0 || digitalPinNumber == 1) {\n        isPinValid = false;\n      }\n      else {\n        isPinValid = pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex], (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000adc) || pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex], (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000ae0);\n      }\n    }\n    if (isPinValid) {\n      setPinModeCallback((byte)pinIndex, 6);\n    }\n  }\n  *PTR_isI2CEnabled_08000ae4 = 1;\n  TwoWire::begin((TwoWire *)PTR_Wire_08000ae8);\n}",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "begin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a64",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "initializeI2CPins_08000a64"
        },
        "FUN_08002c40": {
            "renaming": {
                "FUN_08002c40": "digitalCallback_08002c40",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentDigitalCallback_08002c50": "PTR_currentDigitalCallback_08002c50",
                "code": "code",
                "**PTR_currentDigitalCallback_08002c50": "currentDigitalCallback",
                "(code *)0x0": "nullptr",
                "**(code **)PTR_currentDigitalCallback_08002c50": "*currentDigitalCallback"
            },
            "code": "void firmata::FirmataClass::digitalCallback_08002c40(void *callbackFunction, uint8_t command, uint16_t value) {\n  code* **PTR_currentDigitalCallback_08002c50 = *(code**)PTR_**PTR_currentDigitalCallback_08002c50_08002c50;\n  if (**PTR_currentDigitalCallback_08002c50 != nullptr) {\n    (**(code **)PTR_**PTR_currentDigitalCallback_08002c50_08002c50)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c40",
            "calling": [],
            "imported": false,
            "current_name": "digitalCallback_08002c40"
        },
        "FUN_0800694c": {
            "renaming": {
                "FUN_0800694c": "receive_uart_data_0800694c",
                "*huart": "*uart_handle",
                "pbVar1": "rx_buffer_ptr",
                "uVar2": "rx_transfer_count",
                "puVar3": "rx_buffer_ptr",
                "HAL_UART_STATE_BUSY_RX": "HAL_BUSY",
                "HAL_UART_STATE_READY": "HAL_OK",
                "HAL_UART_RxCpltCallback": "HAL_UART_RxCompleteCallback",
                "huart->RxState": "uart_handle->RxState",
                "huart->Init": "uart_handle->Init",
                "huart->pRxBuffPtr": "uart_handle->pRxBuffPtr",
                "huart->Instance->DR": "uart_handle->Instance->DR",
                "huart->RxXferCount": "uart_handle->RxXferCount",
                "USART_CR1_RXNEIE": "USART_CR1_RXNEIE",
                "USART_CR1_PEIE": "USART_CR1_PEIE",
                "USART_CR3_EIE": "USART_CR3_EIE",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9B"
            },
            "code": "HAL_StatusTypeDef receive_uart_data_0800694c(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t *rx_buffer_ptr;\n  uint16_t rx_transfer_count;\n  uint16_t data;\n  \n  if (uart_handle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uart_handle->Init).WordLength == UART_WORDLENGTH_9B) {\n    if ((uart_handle->Init).Parity == UART_PARITY_NONE) {\n      data = (uint16_t)((uart_handle->Instance->DR << 0x17) >> 0x17);\n      *(uint16_t *)uart_handle->pRxBuffPtr = data;\n      uart_handle->pRxBuffPtr += 2;\n    }\n    else {\n      data = (uint16_t)(uart_handle->Instance->DR & 0xff);\n      *(uint16_t *)uart_handle->pRxBuffPtr = data;\n      uart_handle->pRxBuffPtr += 1;\n    }\n  }\n  else if ((uart_handle->Init).Parity == UART_PARITY_NONE) {\n    rx_buffer_ptr = uart_handle->pRxBuffPtr;\n    uart_handle->pRxBuffPtr = rx_buffer_ptr + 1;\n    *rx_buffer_ptr = (uint8_t)uart_handle->Instance->DR;\n  }\n  else {\n    rx_buffer_ptr = uart_handle->pRxBuffPtr;\n    uart_handle->pRxBuffPtr = rx_buffer_ptr + 1;\n    *rx_buffer_ptr = (uint8_t)(uart_handle->Instance->DR & 0x7f);\n  }\n  rx_transfer_count = uart_handle->RxXferCount - 1;\n  uart_handle->RxXferCount = rx_transfer_count;\n  if (rx_transfer_count != 0) {\n    return HAL_OK;\n  }\n  uart_handle->Instance->CR1 &= ~(USART_CR1_RXNEIE | USART_CR1_PEIE);\n  uart_handle->Instance->CR3 &= ~USART_CR3_EIE;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart_handle);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800694c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_uart_data_0800694c"
        },
        "FUN_0800a0ec": {
            "renaming": {
                "FUN_0800a0ec": "get_file_status_0800a0ec",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "puVar1": "error_ptr",
                "iVar2": "status_code"
            },
            "code": "void get_file_status_0800a0ec(int *error_code, int file_descriptor, stat *file_status) {\n  undefined *error_ptr;\n  int status_code;\n  error_ptr = PTR_errno_0800a10c;\n  *(undefined4 *)PTR_errno_0800a10c = 0;\n  status_code = _fstat(file_descriptor, file_status);\n  if ((status_code == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0ec",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_0800a0ec"
        },
        "FUN_08008df8": {
            "renaming": {
                "FUN_08008df8::FUN_08008df8": "IPv4Address::IPv4Address",
                "this": "this",
                "first_octet": "first_octet",
                "second_octet": "second_octet",
                "third_octet": "third_octet",
                "fourth_octet": "fourth_octet",
                "super_Printable": "super_Printable",
                "_vptr_Printable": "_vptr_Printable",
                "PTR_DAT_08008e10": "PTR_DAT_08008e10",
                "_address": "_address",
                "bytes": "bytes",
                "FUN_08008df8": "IPv4Address_08008df8"
            },
            "code": "IPv4Address_08008df8* __thiscall IPv4Address_08008df8::IPv4Address_08008df8(IPv4Address_08008df8* this, uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)\n{\n    this->super_Printable->_vptr_Printable = (func_int_varargs**)PTR_DAT_08008e10;\n    this->_address.bytes[0] = first_octet;\n    this->_address.bytes[1] = second_octet;\n    this->_address.bytes[2] = third_octet;\n    this->_address.bytes[3] = fourth_octet;\n    return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008df8",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "IPv4Address_08008df8"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "read_and_return_08000188",
                "a0": "data",
                "a1": "address",
                "a2": "flag"
            },
            "code": "uint32_t read_and_return_08000188(uint32_t data, uint32_t address, int32_t flag) {\n  software_interrupt(0x3f);\n  return data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_and_return_08000188"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "i2c_handle_08004f3c",
                "hi2c": "handle",
                "HVar1": "status",
                "puVar2": "buffer_ptr",
                "pIVar3": "instance_ptr"
            },
            "code": "void i2c_handle_08004f3c(I2C_HandleTypeDef_conflict *handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *buffer_ptr;\n  I2C_TypeDef_conflict *instance_ptr;\n  \n  if ((byte)handle->State - 0x29 < 2) {\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((handle->State != HAL_I2C_STATE_ABORT) && ((handle->Instance->CR2 & 0x800) == 0)) {\n      handle->State = HAL_I2C_STATE_READY;\n    }\n    handle->PreviousState = 0;\n    handle->Mode = HAL_I2C_MODE_NONE;\n  }\n  handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n  instance_ptr = handle->Instance;\n  if ((instance_ptr->CR2 & 0x800) == 0) {\n    if (handle->State == HAL_I2C_STATE_ABORT) {\n      handle->State = HAL_I2C_STATE_READY;\n      handle->ErrorCode = 0;\n      if ((instance_ptr->SR1 & 0x40) != 0) {\n        buffer_ptr = handle->pBuffPtr;\n        handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)instance_ptr->DR;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(handle);\n    }\n    else {\n      if ((instance_ptr->SR1 & 0x40) != 0) {\n        buffer_ptr = handle->pBuffPtr;\n        handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)instance_ptr->DR;\n      }\n      HAL_I2C_ErrorCallback(handle);\n    }\n  }\n  else {\n    instance_ptr->CR2 = instance_ptr->CR2 & 0xfffff7ff;\n    if (handle->hdmatx->State == HAL_DMA_STATE_READY) {\n      handle->hdmarx->XferAbortCallback = i2c_data_transfer_abort_callback;\n      status = HAL_DMA_Abort_IT(handle->hdmarx);\n      if (status != HAL_OK) {\n        if ((handle->Instance->SR1 & 0x40) != 0) {\n          buffer_ptr = handle->pBuffPtr;\n          handle->pBuffPtr = buffer_ptr + 1;\n          *buffer_ptr = (uint8_t)handle->Instance->DR;\n        }\n        handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmarx->XferAbortCallback)(handle->hdmarx);\n      }\n    }\n    else {\n      handle->hdmatx->XferAbortCallback = i2c_data_transfer_abort_callback;\n      status = HAL_DMA_Abort_IT(handle->hdmatx);\n      if (status != HAL_OK) {\n        handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmatx->XferAbortCallback)(handle->hdmatx);\n      }\n    }\n  }\n  if ((handle->State == HAL_I2C_STATE_LISTEN) && ((handle->ErrorCode & 4) != 0)) {\n    handle->XferOptions = HAL_I2C_XFER_OPTIONS_DEFAULT;\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_READY;\n    handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(handle);\n  }\n  return;\n}",
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "i2c_handle_08004f3c"
        },
        "FUN_08004f3a": {
            "renaming": {
                "FUN_08004f3a": "do_nothing_08004f3a"
            },
            "code": "\nvoid do_nothing_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3a",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f3a"
        },
        "FUN_0800344a": {
            "renaming": {
                "FUN_0800344a": "resetParserState_0800344a",
                "this": "parser",
                "uVar1": "data_buffer_index"
            },
            "code": "void __thiscall firmata::FirmataParser::resetParserState_0800344a(FirmataParser *parser) {\n  uint data_buffer_index;\n  \n  parser->waitForData = 0;\n  parser->executeMultiByteCommand = \"\\0\";\n  parser->multiByteChannel = \"\\0\";\n  for (data_buffer_index = 0; data_buffer_index < parser->dataBufferSize; data_buffer_index++) {\n    parser->dataBuffer[data_buffer_index] = \"\\0\";\n  }\n  parser->parsingSysex = false;\n  parser->sysexBytesRead = 0;\n  if (parser->currentSystemResetCallback != (systemCallbackFunction)0x0) {\n    (*parser->currentSystemResetCallback)(parser->currentSystemResetCallbackContext);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800344a",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "resetParserState_0800344a"
        },
        "FUN_080071e4": {
            "renaming": {
                "FUN_080071e4": "stop_pwm_signal_080071e4",
                "pin": "pin_name",
                "Channel": "channel_number",
                "uVar1": "pwm_function",
                "timHandle": "tim_handle"
            },
            "code": "void stop_pwm_signal_080071e4(PinName_conflict pin)\n{\n  uint32_t channel_number;\n  uint32_t pwm_function;\n  TIM_HandleTypeDef_conflict tim_handle;\n  \n  tim_handle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_PWM_08007238);\n  if ((tim_handle.Instance != (TIM_TypeDef_conflict *)0x0) && (((channel_number = get_pwm_channel(pin), channel_number == 0 || (channel_number == 4)) || (channel_number == 8)) || ((channel_number == 0xc || (channel_number == 0x18)))))) {\n    pwm_function = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08007238);\n    if ((pwm_function & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&tim_handle, channel_number);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&tim_handle, channel_number);\n    }\n    HAL_TIM_PWM_DeInit(&tim_handle);\n  }\n  return;\n}",
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIM_PWM_DeInit",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071e4",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_080071e4"
        },
        "FUN_08002c54": {
            "renaming": {
                "FUN_08002c54": "handlePinModeCallback_08002c54",
                "param_1": "callbackPtr",
                "command": "command",
                "value": "value",
                "PTR_currentPinModeCallback_08002c64": "currentPinModeCallback"
            },
            "code": "void firmata::FirmataClass::handlePinModeCallback_08002c54(void *callbackPtr, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentPinModeCallback_08002c64 != (code *)0x0) {\n    (**(code **)PTR_currentPinModeCallback_08002c64)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c54",
            "calling": [],
            "imported": false,
            "current_name": "handlePinModeCallback_08002c54"
        },
        "FUN_080072fa": {
            "renaming": {
                "FUN_080072fa": "Initialize_HAL_and_SystemClock_080072fa"
            },
            "code": "void Initialize_HAL_and_SystemClock_080072fa(void)\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}",
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072fa",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "Initialize_HAL_and_SystemClock_080072fa"
        },
        "FUN_08003346": {
            "renaming": {
                "FUN_08003346": "reportFirmwareVersion_08003346",
                "command": "firmwareCommand",
                "newFunction": "versionCallback",
                "context": "callbackContext",
                "currentReportFirmwareCallback": "reportFirmwareCallback",
                "currentReportFirmwareCallbackContext": "reportFirmwareCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::reportFirmwareVersion_08003346(FirmataParser *this, uint8_t command, versionCallbackFunction newCallback, void *callbackContext)\n{\n    if (command == 'y') {\n        this->currentReportFirmwareCallback = newCallback;\n        this->currentReportFirmwareCallbackContext = callbackContext;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003346",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "reportFirmwareVersion_08003346"
        },
        "FUN_08003106": {
            "renaming": {
                "FUN_08003106": "sendData_08003106",
                "this": "marshaller",
                "pin": "pin",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FirmataStream": "firmataStream",
                "Stream": "Stream",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendData_08003106(FirmataMarshaller *marshaller, uint8_t pin, size_t byteCount, uint8_t *byteValues) {\n  if (marshaller->firmataStream != nullptr) {\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller, 0xf0);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, 0x6f);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, static_cast<uint>(pin));\n    encodeByteStream(marshaller, byteCount, byteValues, byteCount);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, 0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003106",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendData_08003106"
        },
        "FUN_08007708": {
            "renaming": {
                "FUN_08007708": "enable_timer_clock_08007708",
                "*htim": "*timer_handle"
            },
            "code": "void enable_timer_clock_08007708(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_enable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_enable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007708",
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "enable_timer_clock_08007708"
        },
        "FUN_0800018c": {
            "renaming": {
                "FUN_0800018c": "call_afl_if_hypercall_disabled_0800018c",
                "ticks": "num_ticks",
                "uVar1": "result",
                "PTR_noHyperCall_080001a4": "noHyperCall"
            },
            "code": "int call_afl_if_hypercall_disabled_0800018c(int ticks)\n{\n  uint32_t result;\n  if (*PTR_noHyperCall_080001a4 != 0) {\n    return 0;\n  }\n  result = aflCall(1, ticks, 0);\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800018c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "call_afl_if_hypercall_disabled_0800018c"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "set_interrupt_08003f94",
                "IRQn": "interrupt_type",
                "uVar1": "interrupt_number",
                "DAT_08003fac": "interrupt_register_base_address"
            },
            "code": "void set_interrupt_08003f94(IRQn_Type_conflict IRQn)\n{\n  uint32_t interrupt_number = (uint32_t)IRQn;\n  if (interrupt_number >= 0)\n  {\n    uint32_t word_offset = interrupt_number >> 5;\n    uint32_t bit_offset = interrupt_number & 0x1f;\n    uint32_t* interrupt_register = (uint32_t*)(DAT_08003fac + (word_offset * 4));\n    *interrupt_register = 1 << bit_offset;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "TimerPulseInit",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_08003f94"
        },
        "FUN_08002c68": {
            "renaming": {
                "FUN_08002c68": "pin_value_callback_08002c68",
                "param_1": "callback_function",
                "command": "command",
                "value": "value",
                "PTR_currentPinValueCallback_08002c78": "current_pin_value_callback"
            },
            "code": "void firmata::FirmataClass::pin_value_callback_08002c68(void *callback_function, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentPinValueCallback_08002c78 != (code *)0x0) {\n    (**(code **)PTR_currentPinValueCallback_08002c78)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c68",
            "calling": [],
            "imported": false,
            "current_name": "pin_value_callback_08002c68"
        },
        "FUN_08002a26": {
            "renaming": {
                "FUN_08002a26": "sendData_08002a26",
                "this": "wire"
            },
            "code": "void __thiscall TwoWire::sendData_08002a26(TwoWire *wire){\n  sendData_08002a26(wire, 0x33);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a26",
            "calling": [
                "enableI2CPins"
            ],
            "imported": false,
            "current_name": "sendData_08002a26"
        },
        "FUN_0800430c": {
            "renaming": {
                "FUN_0800430c": "configureI2C_0800430c",
                "*hi2c": "*i2cHandler",
                "hi2c->Mode": "mode",
                "hi2c->EventCount": "eventCount",
                "hi2c->Instance": "instance",
                "hi2c->Init": "init",
                "hi2c->Devaddress": "devAddress",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "init.AddressingMode": "init.AddressingMode",
                "status": "status"
            },
            "code": "HAL_StatusTypeDef_conflict configureI2C_0800430c(I2C_HandleTypeDef_conflict *i2cHandler) {\n    uint16_t devAddress = i2cHandler->Devaddress;\n    uint8_t mode = i2cHandler->Mode;\n    uint8_t eventCount = i2cHandler->EventCount;\n    I2C_TypeDef *instance = i2cHandler->Instance;\n    I2C_InitTypeDef init = i2cHandler->Init;\n    HAL_StatusTypeDef_conflict status = HAL_OK;\n    if (mode == HAL_I2C_MODE_MEM) {\n        if (eventCount == 0) {\n            instance->DR = devAddress & 0xfe;\n        }\n        else {\n            instance->DR = devAddress & 0xff | 1;\n        }\n    }\n    else if (init.AddressingMode == 0x4000) {\n        if (i2cHandler->State == HAL_I2C_STATE_BUSY_TX) {\n            instance->DR = devAddress & 0xfe;\n        }\n        else {\n            instance->DR = devAddress & 0xff | 1;\n        }\n    }\n    else if (eventCount == 0) {\n        instance->DR = (devAddress << 0x10) >> 0x17 & 6 | 0xf0;\n    }\n    else if (eventCount == 1) {\n        instance->DR = (devAddress << 0x10) >> 0x17 & 6 | 0xf1;\n    }\n    return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800430c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "configureI2C_0800430c"
        },
        "FUN_08003350": {
            "renaming": {
                "FUN_08003350": "parseCommand_08003350",
                "command": "commandByte",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "currentReportVersionCallback": "reportVersionCallback",
                "currentReportVersionCallbackContext": "reportVersionCallbackContext",
                "currentSystemResetCallback": "systemResetCallback",
                "currentSystemResetCallbackContext": "systemResetCallbackContext",
                "0xf9": "REPORT_VERSION_COMMAND",
                "0xff": "SYSTEM_RESET_COMMAND"
            },
            "code": "void __thiscall firmata::FirmataParser::parseCommand_08003350(FirmataParser *this, uint8_t command, systemCallbackFunction newFunction, void *context) {\n  if (command == REPORT_VERSION_COMMAND) {\n    this->reportVersionCallback = newFunction;\n    this->reportVersionCallbackContext = context;\n    return;\n  }\n  if (command != SYSTEM_RESET_COMMAND) {\n    return;\n  }\n  this->systemResetCallback = newFunction;\n  this->systemResetCallbackContext = context;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003350",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "parseCommand_08003350"
        },
        "FUN_08007710": {
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08007710(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007710",
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007710"
        },
        "FUN_08003474": {
            "renaming": {
                "FUN_08003474": "parseFirmataMessage_08003474",
                "this": "parser",
                "inputData": "inputData",
                "bVar1": "byteValue",
                "uVar2": "uintValue",
                "pos": "pos",
                "parsingSysex": "parsingSysex",
                "sysexBytesRead": "sysexBytesRead",
                "waitForData": "waitForData",
                "multiByteChannel": "channel",
                "executeMultiByteCommand": "executeMultiByteCommand",
                "currentReportVersionCallback": "currentReportVersionCallback",
                "currentReportVersionCallbackContext": "currentReportVersionCallbackContext",
                "currentReportDigitalCallback": "currentReportDigitalCallback",
                "currentReportDigitalCallbackContext": "currentReportDigitalCallbackContext",
                "currentDigitalCallback": "currentDigitalCallback",
                "currentDigitalCallbackContext": "currentDigitalCallbackContext",
                "currentReportAnalogCallback": "currentReportAnalogCallback",
                "currentReportAnalogCallbackContext": "currentReportAnalogCallbackContext",
                "currentPinModeCallback": "currentPinModeCallback",
                "currentPinModeCallbackContext": "currentPinModeCallbackContext",
                "currentPinValueCallback": "currentPinValueCallback",
                "currentPinValueCallbackContext": "currentPinValueCallbackContext",
                "currentAnalogCallback": "currentAnalogCallback",
                "currentAnalogCallbackContext": "currentAnalogCallbackContext",
                "bufferDataAtPosition": "bufferDataAtPosition",
                "processSysexMessage": "processSysexMessage",
                "systemReset": "systemReset",
                "SYSEX_END": "0xF7",
                "SYSTEM_RESET": "0xFF",
                "SYSEX_START": "0xF0",
                "REPORT_VERSION": "0xF9",
                "REPORT_ANALOG": "0xC0",
                "REPORT_DIGITAL": "0x90",
                "ANALOG_MESSAGE": "0xE0",
                "DIGITAL_MESSAGE": "0x90",
                "SET_PIN_MODE": "0xF4"
            },
            "code": "void __thiscall firmata::FirmataParser::parseFirmataMessage_08003474(FirmataParser *parser, uint8_t inputData)\n{\n  uint8_t commandByte = inputData & 0xF0;\n  uint8_t channel = inputData & 0x0F;\n  if (parser->parsingSysex)\n  {\n    if (inputData != SYSEX_END)\n    {\n      bufferDataAtPosition(parser, inputData, parser->sysexBytesRead);\n      parser->sysexBytesRead++;\n      return;\n    }\n    parser->parsingSysex = false;\n    processSysexMessage(parser);\n    return;\n  }\n  if (parser->waitForData > 0 && inputData <= 0x7F)\n  {\n    bufferDataAtPosition(parser, inputData, parser->waitForData - 1);\n    parser->waitForData--;\n    if (parser->waitForData == 0)\n    {\n      executeMultiByteCommand(parser);\n    }\n  }\n  else if (commandByte == SYSTEM_RESET)\n  {\n    systemReset(parser);\n  }\n  else if (commandByte == SYSEX_START)\n  {\n    parser->parsingSysex = true;\n    parser->sysexBytesRead = 0;\n  }\n  else if (commandByte == REPORT_VERSION)\n  {\n    if (parser->currentReportVersionCallback != NULL)\n    {\n      parser->currentReportVersionCallback(parser->currentReportVersionCallbackContext);\n    }\n  }\n  else if (commandByte == REPORT_ANALOG || commandByte == REPORT_DIGITAL)\n  {\n    parser->waitForData = 1;\n    parser->executeMultiByteCommand = inputData;\n  }\n  else if (commandByte == ANALOG_MESSAGE || commandByte == DIGITAL_MESSAGE || commandByte == REPORT_ANALOG || commandByte == REPORT_DIGITAL)\n  {\n    parser->waitForData = 2;\n    parser->executeMultiByteCommand = inputData;\n  }\n  else if (commandByte == SET_PIN_MODE)\n  {\n    parser->waitForData = 2;\n    parser->executeMultiByteCommand = inputData;\n  }\n}",
            "called": [
                "systemReset",
                "bufferDataAtPosition",
                "processSysexMessage"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "processInput"
            ],
            "imported": false,
            "current_name": "parseFirmataMessage_08003474"
        },
        "FUN_08008804": {
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "incr": "increment",
                "pcVar1": "current_address",
                "pcVar2": "new_address"
            },
            "code": "caddr_t allocate_memory_08008804(int increment) {\n  caddr_t current_address;\n  caddr_t new_address;\n  \n  if (*(int *)PTR_heap_end_08008834 == 0) {\n    *(undefined **)PTR_heap_end_08008834 = PTR__ebss_08008838;\n  }\n  current_address = *(caddr_t *)PTR_heap_end_08008834;\n  new_address = current_address + increment;\n  if (new_address <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08008834 = new_address;\n    return current_address;\n  }\n  *(undefined4 *)PTR_errno_0800883c = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008804",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008804"
        },
        "FUN_08004e3c": {
            "renaming": {
                "FUN_08004e3c": "i2c_transfer_08004e3c",
                "hi2c": "i2c_handle",
                "uVar1": "transfer_options",
                "puVar2": "buffer_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_transfer_08004e3c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n    uint32_t transfer_options = i2c_handle->XferOptions;\n    uint8_t *buffer_ptr;\n    \n    if (i2c_handle->XferCount == 3) {\n        if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n            i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n        }\n        buffer_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n    else if (i2c_handle->XferCount == 2) {\n        if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n            i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffcff;\n            i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        }\n        else {\n            if (transfer_options == 2) {\n                i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n            }\n            else {\n                i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n            }\n            i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffcff;\n        }\n        buffer_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount = i2c_handle->XferCount - 1;\n        buffer_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount = i2c_handle->XferCount - 1;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->PreviousState = 0;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n            i2c_handle->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MemRxCpltCallback(i2c_handle);\n        }\n        else {\n            i2c_handle->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MasterRxCpltCallback(i2c_handle);\n        }\n    }\n    else {\n        buffer_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e3c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004e3c"
        },
        "FUN_080091a0": {
            "renaming": {
                "FUN_080091a0": "processPointer_080091a0",
                "__ptr": "pointer",
                "PTR__impure_ptr_080091ac": "PTR__impure_ptr_080091ac",
                "_FUN_080091a0_r": "_processPointer_r"
            },
            "code": "void processPointer_080091a0(void *__ptr)\n{\n  int* impure_ptr = *(int *)PTR__impure_ptr_080091ac;\n  _processPointer_080091a0_r(impure_ptr, __ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a0",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "processPointer_080091a0"
        },
        "FUN_08002a1c": {
            "renaming": {
                "TwoWire::FUN_08002a1c": "setDeviceAddress",
                "this": "wire",
                "address": "device_address",
                "FUN_08002a1c": "setDeviceAddress_08002a1c"
            },
            "code": "void __thiscall setDeviceAddress_08002a1c(TwoWire *wire, int address) {\n  setDeviceAddress_08002a1c(wire, (uint8_t)address);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a1c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setDeviceAddress_08002a1c"
        },
        "FUN_08007718": {
            "renaming": {
                "FUN_08007718": "get_stimer_08007718",
                "htim": "timer_handle",
                "stimer_t_conflict": "stimer",
                "&htim[-1].Lock": "&timer_handle[-1].Lock"
            },
            "code": "stimer_t_conflict* get_stimer_08007718(TIM_HandleTypeDef_conflict* timer_handle) {\n    return (stimer_t_conflict*) &timer_handle[-1].Lock;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007718",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_08007718"
        },
        "FUN_08002a30": {
            "renaming": {
                "FUN_08002a30": "initializeTransmission_08002a30",
                "this": "wire",
                "address": "address",
                "PTR_transmitting_08002a48": "isTransmitting",
                "PTR_txAddress_08002a4c": "txAddress",
                "PTR_txBufferIndex_08002a50": "txBufferIndex",
                "PTR_txBufferLength_08002a54": "txBufferLength"
            },
            "code": "void __thiscall initializeTransmission_08002a30(TwoWire *wire, uint8_t address) {\n  bool PTR_transmitting_08002a48 = true;\n  uint8_t PTR_txAddress_08002a4c = address << 1;\n  uint8_t PTR_txBufferIndex_08002a50 = 0;\n  uint8_t PTR_txBufferLength_08002a54 = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a30",
            "calling": [
                "requestFrom",
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "initializeTransmission_08002a30"
        },
        "FUN_08009cd0": {
            "renaming": {
                "FUN_08009cd0": "walk_reent_pointers_and_call_function_08009cd0",
                "param_1": "reent_struct_pointer",
                "DAT_08009cd8": "function_pointer",
                "_fwalk_reent": "_fwalk_reent"
            },
            "code": "void walk_reent_pointers_and_call_function_08009cd0(void* reent_struct_pointer, void (*DAT_08009cd8)(void*))\n{\n    _fwalk_reent(reent_struct_pointer, DAT_08009cd8);\n    return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cd0",
            "calling": [],
            "imported": false,
            "current_name": "walk_reent_pointers_and_call_function_08009cd0"
        },
        "FUN_0800322c": {
            "renaming": {
                "FUN_0800322c": "sendVersion_0800322c",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "FirmataStream": "stream"
            },
            "code": "void __thiscall FirmataMarshaller::sendVersion_0800322c(FirmataMarshaller *marshaller,uint8_t major,uint8_t minor)\n{\n  if (marshaller->stream != nullptr) {\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller,0xf9);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)major);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)minor);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800322c",
            "calling": [
                "printVersion"
            ],
            "imported": false,
            "current_name": "sendVersion_0800322c"
        },
        "FUN_08003760": {
            "renaming": {
                "FUN_08003760": "get_uwTick_value_08003760",
                "PTR_uwTick_08003768": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_08003760(void)\n{\n  uint32_t* PTR_uwTick_08003768 = (uint32_t*)PTR_uwTick_08003768;\n  return *PTR_uwTick_08003768;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003760",
            "calling": [
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_ADC_PollForConversion",
                "i2c_master_write",
                "uart_debug_write",
                "HAL_RCC_ClockConfig",
                "GetCurrentMilli",
                "i2c_master_read",
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08003760"
        },
        "FUN_08000130": {
            "renaming": {
                "FUN_08000130": "execute_if_completed_08000130",
                "PTR_completed_8667_08000170": "completed_ptr",
                "DAT_08000174": "function_ptr",
                "DAT_08000164": "is_completed",
                "PTR_object_8672_0800016c": "object_ptr"
            },
            "code": "void execute_if_completed_08000130() {\n  int *PTR_completed_8667_08000170 = (int *)PTR_completed_8667_08000170;\n  code *DAT_08000174 = DAT_08000174;\n  if (DAT_08000164 == 0) {\n    if ((*PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n      (*DAT_08000174)();\n      return;\n    }\n    return;\n  }\n  if ((*PTR_completed_8667_08000170 != 0) && (DAT_08000174 != (code *)0x0)) {\n    (*DAT_08000174)(PTR_completed_8667_08000170,PTR_object_8672_0800016c);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000130",
            "calling": [],
            "imported": false,
            "current_name": "execute_if_completed_08000130"
        },
        "FUN_08002798": {
            "renaming": {
                "FUN_08002798": "initializeWire_08002798",
                "PTR_rxBufferIndex_080027d0": "wire->rxBufferIndex",
                "PTR_rxBufferLength_080027d4": "wire->rxBufferLength",
                "PTR_rxBuffer_080027d8": "wire->rxBuffer",
                "PTR_rxBufferAllocated_080027dc": "wire->rxBufferAllocated",
                "PTR_txBufferIndex_080027e0": "wire->txBufferIndex",
                "PTR_txBufferLength_080027e4": "wire->txBufferLength",
                "PTR_txBuffer_080027e8": "wire->txBuffer",
                "PTR_txBufferAllocated_080027ec": "wire->txBufferAllocated"
            },
            "code": "void __thiscall initializeWire_08002798(TwoWire *wire)\n{\n  PTR_rxBufferIndex_080027d0 = 0;\n  PTR_rxBufferLength_080027d4 = 0;\n  if (*(void **)PTR_rxBuffer_080027d8 != (void *)0x0) {\n    memset(*(void **)PTR_rxBuffer_080027d8, 0, (uint)(byte)*PTR_rxBufferAllocated_080027dc);\n  }\n  PTR_txBufferIndex_080027e0 = 0;\n  PTR_txBufferLength_080027e4 = 0;\n  if (*(void **)PTR_txBuffer_080027e8 != (void *)0x0) {\n    memset(*(void **)PTR_txBuffer_080027e8, 0, (uint)(byte)*PTR_txBufferAllocated_080027ec);\n  }\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002798",
            "calling": [],
            "imported": false,
            "current_name": "initializeWire_08002798"
        },
        "FUN_08009190": {
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "size",
                "pvVar1": "allocated_memory"
            },
            "code": "void* allocate_memory_08009190(size_t size)\n{\n  void* allocated_memory;\n  allocated_memory = (void *)_allocate_memory_08009190_r(*(undefined4 *)PTR__impure_ptr_0800919c, size);\n  return allocated_memory;\n}",
            "called": [
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009190",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009190"
        },
        "FUN_0800242c": {
            "renaming": {
                "FUN_0800242c": "initialize_timer_0800242c",
                "obj": "timer_object",
                "DAT_08002440": "timer_callback_function"
            },
            "code": "void initialize_timer_0800242c(stimer_t *timer_object)\n{\n  TimerPulseInit((stimer_t_conflict *)timer_object, 60000, 0x5dc, DAT_08002440);\n  return;\n}",
            "called": [
                "TimerPulseInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800242c",
            "calling": [
                "attach"
            ],
            "imported": false,
            "current_name": "initialize_timer_0800242c"
        },
        "FUN_08002e44": {
            "renaming": {
                "FUN_08002e44": "parseFirmwareVersion_08002e44",
                "this": "firmataObject",
                "name": "firmwareName",
                "major": "majorVersionNumber",
                "minor": "minorVersionNumber",
                "bVar1": "nameIndex",
                "pcVar2": "cppExtension",
                "pcVar3": "lastSlash",
                "pbVar4": "firmwareVersionVector",
                "sVar5": "firmwareNameLength"
            },
            "code": "void __thiscall firmata::FirmataClass::parseFirmwareVersion_08002e44(char *firmwareName, byte major, byte minor) {\n  byte nameIndex;\n  char *cppExtension;\n  char *lastSlash;\n  byte *firmwareVersionVector;\n  size_t firmwareNameLength;\n  \n  cppExtension = strstr(firmwareName, \".cpp\");\n  lastSlash = strrchr(firmwareName, '/');\n  if (lastSlash == NULL) {\n    lastSlash = strrchr(firmwareName, '\\');\n  }\n  if (lastSlash != NULL) {\n    firmwareName = lastSlash + 1;\n  }\n  if (cppExtension == NULL) {\n    firmwareNameLength = strlen(firmwareName);\n    nameIndex = (char)firmwareNameLength + 2;\n  }\n  else {\n    nameIndex = (char)cppExtension - (char)firmwareName + 2;\n  }\n  free(this->firmwareVersionVector);\n  firmwareVersionVector = (byte *)malloc(nameIndex + 1);\n  this->firmwareVersionVector = firmwareVersionVector;\n  firmwareVersionVector[nameIndex] = '\\0';\n  *firmwareVersionVector = major;\n  firmwareVersionVector[1] = minor;\n  strncpy((char *)(firmwareVersionVector + 2), firmwareName, nameIndex - 2);\n  return;\n}",
            "called": [
                "free",
                "strncpy",
                "strstr",
                "strrchr",
                "malloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e44",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "parseFirmwareVersion_08002e44"
        },
        "FUN_0800a0a8": {
            "renaming": {
                "FUN_0800a0a8": "write_to_file_0800a0a8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "data",
                "param_4": "data_size",
                "puVar1": "errno_ptr",
                "iVar2": "write_result"
            },
            "code": "void write_to_file_0800a0a8(int *error_code, int file_descriptor, char *data, int data_size) {\n  undefined *errno_ptr;\n  int write_result;\n  errno_ptr = PTR_errno_0800a0c8;\n  *(undefined4 *)PTR_errno_0800a0c8 = 0;\n  write_result = _write(file_descriptor, data, data_size);\n  if ((write_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0a8",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_0800a0a8"
        },
        "FUN_08002c00": {
            "renaming": {
                "FUN_08002c00": "readFromSlave_08002c00",
                "this": "wire",
                "address": "addr",
                "quantity": "numBytes",
                "sendStop": "sendStop",
                "uVar1": "bytesReceived"
            },
            "code": "uint8_t __thiscall readFromSlave_08002c00(TwoWire *wire, uint8_t addr, uint8_t numBytes, uint8_t sendStop)\\n{\\n  uint8_t bytesReceived;\\n  bytesReceived = readFromSlave_08002c00(wire, addr, numBytes, 0, \"\\0\", sendStop);\\n  return bytesReceived;\\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c00",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromSlave_08002c00"
        },
        "FUN_08003f30": {
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_num",
                "uVar2": "priority_group_bits",
                "uVar3": "priority_group_num",
                "DAT_08003f8c": "DAT_irq_priority_bits",
                "DAT_08003f90": "DAT_irq_priority_bits_2",
                "priority_group_bits": "priority_group_bits",
                "priority_group_num": "priority_group_num",
                "priority_group_shift": "priority_group_shift",
                "priority_bits": "priority_bits"
            },
            "code": "void set_interrupt_priority_08003f30(IRQn_Type_conflict irq, uint32_t preempt_priority, uint32_t sub_priority) {\n  uint32_t irq_num = (uint32_t)irq;\n  uint32_t priority_group_bits = (*(int *)(DAT_08003f8c + 0xc) << 0x15) >> 0x1d;\n  uint32_t priority_group_num = 7 - priority_group_bits;\n  if (priority_group_num > 3) {\n    priority_group_num = 4;\n  }\n  uint32_t priority_group_shift = priority_group_bits + 4 < 7 ? 0 : priority_group_bits - 3;\n  uint32_t priority_bits = (preempt_priority & ((1 << (priority_group_num & 0xff)) - 1U)) << (priority_group_shift & 0xff) | ((1 << (priority_group_shift & 0xff)) - 1U) & sub_priority;\n  if ((int)irq_num < 0) {\n    *(char *)(DAT_08003f90 + (irq_num & 0xf)) = (char)(priority_bits << 4);\n  }\n  else {\n    *(char *)(irq_num + 0xe000e400) = (char)(priority_bits << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f30",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "TimerPulseInit",
                "SystemClock_Config",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08003f30"
        },
        "FUN_080073d8": {
            "renaming": {
                "FUN_080073d8": "handle_alarm_interrupt_080073d8",
                "PTR_RtcHandle_080073e4": "rtc_handle"
            },
            "code": "void handle_alarm_interrupt_080073d8(void)\n{\n    RTC_HandleTypeDef *PTR_RtcHandle_080073e4 = (RTC_HandleTypeDef *)PTR_RtcHandle_080073e4;\n    HAL_RTC_AlarmIRQHandler(PTR_RtcHandle_080073e4);\n    return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d8",
            "calling": [],
            "imported": false,
            "current_name": "handle_alarm_interrupt_080073d8"
        },
        "FUN_080085dc": {
            "renaming": {
                "FUN_080085dc": "is_uart_transmit_complete_080085dc",
                "obj": "serial",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085fc": "uart_handlers",
                "DAT_0800b51c": "HAL_UART_STATE_BUSY_TX_RX",
                "HAL_UART_StateTypeDef": "HAL_UART_State",
                "UART_HandleTypeDef": "UART_Handle",
                "PTR_0800b51c": "HAL_UART_STATE_BUSY_TX_RX"
            },
            "code": "bool is_uart_transmit_complete_080085dc(serial_t *serial) {\n    UART_HandleTypeDef* uart = *(UART_HandleTypeDef**)(PTR_PTR_uart_handlers_080085fc_080085fc + (uint)serial->index * 4);\n    HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart);\n    bool is_complete = (uart_state & 0x21U) == 0x21;\n    return is_complete;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085dc",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085dc"
        },
        "FUN_08008ed6": {
            "renaming": {
                "FUN_08008ed6": "printNumber_08008ed6",
                "this": "printObj",
                "n": "num",
                "base": "base",
                "sVar1": "count",
                "FUN_08008ed6Number": "printNumber",
                "_vptr_Print": "_vptr_Print"
            },
            "code": "size_t __thiscall Print::printNumber_08008ed6(Print *printObj, unsigned long num, int base)\n{\n  size_t count;\n  if (base != 0) {\n    count = printObj->printNumber_08008ed6(num, (uint8_t)base);\n    return count;\n  }\n  count = (**printObj->_vptr_Print)(printObj, num & 0xff);\n  return count;\n}",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ed6",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "printNumber_08008ed6"
        },
        "FUN_08008db0": {
            "renaming": {
                "FUN_08008db0": "initialize_static_variables_08008db0"
            },
            "code": "void initialize_static_variables_08008db0(void)\n{\n  __static_initialization_and_destruction_0(1, 0xFFFF);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008db0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08008db0"
        },
        "FUN_08002444": {
            "renaming": {
                "FUN_08002444": "servo_controller_08002444",
                "obj": "timer",
                "channel": "channel",
                "bVar1": "servo_has_signal",
                "puVar2": "timer_channel_ptr",
                "uVar3": "ccr_value",
                "iVar4": "servo_idx",
                "uVar5": "timer_channel_idx"
            },
            "code": "void servo_controller_08002444(stimer_t *timer, uint32_t channel)\n{\n    bool servo_has_signal;\n    undefined *timer_channel_ptr;\n    uint8_t timer_channel_idx = (uint8_t)timer->idx;\n\n    if ((PTR_timerChannel_0800256c[timer_channel_idx] & 0x80) == 0)\n    {\n        int servo_idx = timer_channel_idx * 12;\n        int servo_channel_idx = (int)(char)PTR_timerChannel_0800256c[timer_channel_idx] + servo_idx;\n        uint8_t servo_count = (uint8_t)*PTR_ServoCount_08002570;\n\n        if (servo_channel_idx < (int)servo_count)\n        {\n            if ((PTR_servos_08002574[servo_channel_idx * 8] & 0x40) == 0)\n            {\n                servo_has_signal = false;\n            }\n            else\n            {\n                servo_has_signal = true;\n            }\n        }\n        else\n        {\n            servo_has_signal = false;\n        }\n\n        if (servo_has_signal)\n        {\n            uint8_t servo_pin = (byte)PTR_servos_08002574[servo_channel_idx * 8] & 0x3f;\n            digitalWrite(servo_pin, 0);\n        }\n    }\n    else\n    {\n        setTimerCounter((stimer_t_conflict *)timer, 0);\n    }\n\n    timer_channel_ptr = PTR_timerChannel_0800256c;\n    timer_channel_ptr[timer_channel_idx]++;\n\n    int servo_idx = timer_channel_idx * 12;\n    int servo_channel_idx = (int)(char)timer_channel_ptr[timer_channel_idx] + servo_idx;\n    uint8_t servo_count = (uint8_t)*PTR_ServoCount_08002570;\n\n    if (servo_channel_idx < (int)servo_count)\n    {\n        if ((char)timer_channel_ptr[timer_channel_idx] < '\\f')\n        {\n            servo_has_signal = true;\n        }\n        else\n        {\n            servo_has_signal = false;\n        }\n    }\n    else\n    {\n        servo_has_signal = false;\n    }\n\n    if (servo_has_signal)\n    {\n        if ((PTR_servos_08002574[servo_channel_idx * 8] & 0x40) != 0)\n        {\n            uint32_t timer_counter = getTimerCounter((stimer_t_conflict *)timer);\n            uint32_t ccr_value = *(int *)(PTR_servos_08002574 + servo_channel_idx * 8 + 4) + timer_counter;\n            setCCRRegister((stimer_t_conflict *)timer, channel, ccr_value);\n        }\n    }\n    else\n    {\n        uint32_t timer_counter = getTimerCounter((stimer_t_conflict *)timer);\n        if (timer_counter + 4 < 20000)\n        {\n            setCCRRegister((stimer_t_conflict *)timer, channel, 20000);\n        }\n        else\n        {\n            setCCRRegister((stimer_t_conflict *)timer, channel, timer_counter + 4);\n        }\n        PTR_timerChannel_0800256c[timer_channel_idx] = 0xff;\n    }\n}",
            "called": [
                "digitalWrite",
                "getTimerCounter",
                "setCCRRegister",
                "setTimerCounter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002444",
            "calling": [],
            "imported": false,
            "current_name": "servo_controller_08002444"
        },
        "FUN_0800906c": {
            "renaming": {
                "FUN_0800906c": "iterate_gpio_exti_handlers_0800906c",
                "uVar1": "gpio_pin_number"
            },
            "code": "void iterate_gpio_exti_handlers_0800906c(void)\n{\n  uint16_t gpio_pin_number;\n  for (gpio_pin_number = 0x400; gpio_pin_number < 0x8001; gpio_pin_number = gpio_pin_number << 1) {\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin_number);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800906c",
            "calling": [],
            "imported": false,
            "current_name": "iterate_gpio_exti_handlers_0800906c"
        },
        "FUN_08003658": {
            "renaming": {
                "FUN_08003658": "initialize_program_08003658",
                "iVar1": "index",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "UNRECOVERED_JUMPTABLE",
                "PTR_completed_8667_08003698": "PTR_completed_8667_08003698",
                "PTR___dso_handle_08003690": "PTR___dso_handle_08003690",
                "PTR__sidata_0800368c": "PTR__sidata_0800368c",
                "PTR__ebss_0800369c": "PTR__ebss_0800369c"
            },
            "code": "void initialize_program_08003658(void)\n{\n  int index;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8667_08003698;\n  undefined4 *dso_ptr = PTR___dso_handle_08003690;\n  code *UNRECOVERED_JUMPTABLE;\n  for (index = 0; dso_ptr + index < PTR_completed_8667_08003694; index += 4) {\n    *(undefined4 *)(dso_ptr + index) = *(undefined4 *)(PTR__sidata_0800368c + index);\n  }\n  for (; completed_ptr < PTR__ebss_0800369c; completed_ptr++) {\n    *completed_ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x800368a;\n  main();\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003658",
            "calling": [],
            "imported": false,
            "current_name": "initialize_program_08003658"
        },
        "FUN_08009a80": {
            "renaming": {
                "FUN_08009a80": "stream_status_08009a80",
                "param_1": "status",
                "param_2": "stream",
                "uVar1": "result",
                "uVar2": "flags",
                "iVar3": "impure_ptr"
            },
            "code": "uint stream_status_08009a80(uint *status, uint *stream) {\n  uint result;\n  ushort flags;\n  int impure_ptr = *(int *)PTR__impure_ptr_08009b4c;\n\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n\n  if (stream == (uint *)PTR___sf_fake_stdin_08009b50) {\n    stream = *(uint **)(impure_ptr + 4);\n  }\n  else if (stream == (uint *)PTR___sf_fake_stdout_08009b54) {\n    stream = *(uint **)(impure_ptr + 8);\n  }\n  else if (stream == (uint *)PTR___sf_fake_stderr_08009b58) {\n    stream = *(uint **)(impure_ptr + 0xc);\n  }\n\n  flags = *(ushort *)(stream + 3);\n  result = (uint)flags;\n\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *status = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((uint *)stream[0xd] != (uint *)0x0) {\n        if ((uint *)stream[0xd] != stream + 0x11) {\n          _free_r(status);\n        }\n        stream[0xd] = 0;\n      }\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n      stream[1] = 0;\n      *stream = stream[4];\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 8;\n  }\n\n  if ((stream[4] == 0) && ((*(ushort *)(stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(status, stream);\n  }\n\n  flags = *(ushort *)(stream + 3);\n  result = flags & 1;\n\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      result = stream[5];\n    }\n    stream[2] = result;\n  }\n  else {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n\n  if (stream[4] == 0) {\n    flags = *(ushort *)(stream + 3);\n    result = (int)(short)flags & 0x80;\n    if (result != 0) {\n      *(ushort *)(stream + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a80",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "stream_status_08009a80"
        },
        "FUN_080062f4": {
            "renaming": {
                "FUN_080062f4": "disable_timer_interrupt_080062f4",
                "htim": "timer_handle",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "pTVar1": "timer_instance",
                "PTR_TIM1": "TIM1"
            },
            "code": "HAL_StatusTypeDef_conflict disable_timer_interrupt_080062f4(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel) {\n  TIM_TypeDef_conflict *timer_instance = timer_handle->Instance;\n\n  switch(channel) {\n    case 0:\n      timer_instance->DIER &= 0xfffffffd;\n      break;\n    case 4:\n      timer_instance->DIER &= 0xfffffffb;\n      break;\n    case 8:\n      timer_instance->DIER &= 0xfffffff7;\n      break;\n    case 0xc:\n      timer_instance->DIER &= 0xffffffef;\n  }\n\n  TIM_CCxChannelCmd(timer_instance, channel, 0);\n\n  if (((timer_instance == PTR_PTR_TIM1) && ((timer_instance->CCER & 0x1111) == 0)) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080062f4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "disable_timer_interrupt_080062f4"
        },
        "FUN_080073e8": {
            "renaming": {
                "FUN_080073e8": "wait_forever_080073e8",
                "msg": "message",
                "val": "value"
            },
            "code": "void wait_forever_080073e8(char *message, int value) {\n    while(true) {\n        // Do nothing\n    }\n}",
            "called": [
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073e8",
            "calling": [
                "_Error_Handler",
                "SystemClock_Config",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "wait_forever_080073e8"
        },
        "FUN_0800267c": {
            "renaming": {
                "FUN_0800267c": "setServoValue_0800267c",
                "this": "servo",
                "value": "servoValue",
                "iVar1": "maxDifference",
                "iVar2": "servoValue"
            },
            "code": "void __thiscall Servo::setServoValue_0800267c(Servo *servo, int value) {\n  int servoValue;\n  int maxDifference;\n  \n  if (servo->servoIndex < 0xc) {\n    maxDifference = (0x88 - servo->min) * 4;\n    if ((maxDifference - value == 0 || maxDifference < value) &&\n       (servoValue = 600 - servo->max, maxDifference = servoValue * 4,\n       value == maxDifference || value + servoValue * -4 < 0 != SBORROW4(value,maxDifference))) {\n      servoValue = value;\n    }\n    *(int *)(PTR_servos_080026ac + (uint)servo->servoIndex * 8 + 4) = servoValue;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800267c",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "setServoValue_0800267c"
        },
        "FUN_0800376c": {
            "renaming": {
                "FUN_0800376c": "wait_for_conversion_0800376c",
                "hadc": "adc_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "pAVar5": "adc_instance",
                "Conversion_Timeout_CPU_cycles": "conversion_timeout_cpu_cycles",
                "ADC_CR2_ADON": "ADC_CR2_ADON",
                "ADC_CR1_SCAN": "ADC_CR1_SCAN",
                "ADC_SQR1_L": "ADC_SQR1_L",
                "ADC_SR_EOC": "ADC_SR_EOC",
                "ADC_STATE_TIMEOUT": "ADC_STATE_TIMEOUT",
                "ADC_STATE_ERROR_INTERNAL": "ADC_STATE_ERROR_INTERNAL",
                "ADC_CR2_CONT": "ADC_CR2_CONT",
                "ADC_STATE_READY": "ADC_STATE_READY",
                "ADC_STATE_INJECTED_BUSY": "ADC_STATE_INJECTED_BUSY",
                "ADC_STATE_REG_EOC": "ADC_STATE_REG_EOC",
                "ADC_STATE_EOC": "ADC_STATE_EOC",
                "ADC_STATE_INJECTED_EOC": "ADC_STATE_INJECTED_EOC",
                "uVar3": "time_elapsed",
                "uVar6": "system_core_clock",
                "adc_clock_freq": "adc_clock_freq",
                "sample_time": "sample_time",
                "total_conversion_time": "total_conversion_time",
                "max_conversion_time": "max_conversion_time",
                "DAT_080038cc": "DAT_080038cc",
                "DAT_080038d0": "DAT_080038d0",
                "DAT_080038d4": "DAT_080038d4",
                "DAT_080038d8": "DAT_080038d8"
            },
            "code": "HAL_StatusTypeDef_conflict wait_for_conversion_0800376c(ADC_HandleTypeDef *hadc, uint32_t timeout)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = hadc->Instance;\n  uint32_t conversion_timeout_cpu_cycles = 0;\n  \n  if ((adc_instance->CR2 & ADC_CR2_ADON) == 0)\n  {\n    if (((adc_instance->CR1 & ADC_CR1_SCAN) == 0) && ((adc_instance->SQR1 & ADC_SQR1_L) == 0))\n    {\n      do {\n        if ((hadc->Instance->SR & ADC_SR_EOC) != 0) goto end_conversion;\n      } while ((timeout == 0xffffffff) || ((timeout != 0 && (HAL_GetTick() - start_time <= timeout))));\n      hadc->State |= ADC_STATE_TIMEOUT;\n      hadc->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else\n    {\n      uint32_t system_core_clock = *(uint *)PTR_SystemCoreClock_080038c8;\n      uint32_t adc_clock_freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);\n      uint32_t sample_time = 0;\n      if (((adc_instance->SMPR2 & DAT_080038cc) == 0) && ((adc_instance->SMPR1 & (DAT_080038cc + 0xdc000000)) == 0))\n      {\n        if ((adc_instance->SMPR2 & DAT_080038d0) == 0)\n        {\n          if ((adc_instance->SMPR1 & DAT_080038d4) == 0) sample_time = 20;\n          else sample_time = 41;\n        }\n        else sample_time = 41;\n      }\n      else if (((adc_instance->SMPR2 & DAT_080038d0) == 0) && ((adc_instance->SMPR1 & (DAT_080038d0 + 0xee000000)) == 0))\n      {\n        sample_time = 84;\n      }\n      else if ((DAT_080038d8 & adc_instance->SMPR2) == 0)\n      {\n        if ((DAT_080038d8 & adc_instance->SMPR1) == 0) sample_time = 84;\n        else sample_time = 480;\n      }\n      else sample_time = 480;\n      uint32_t total_conversion_time = ((12 + sample_time) * (1 << ((adc_instance->SQR1 & ADC_SQR1_L) >> ADC_SQR1_L_Pos)));\n      uint32_t max_conversion_time = (system_core_clock / adc_clock_freq) * total_conversion_time;\n      for (; conversion_timeout_cpu_cycles <= max_conversion_time && max_conversion_time - conversion_timeout_cpu_cycles != 0; conversion_timeout_cpu_cycles++)\n      {\n        if ((timeout != 0xffffffff) && ((timeout == 0 || (HAL_GetTick() - start_time > timeout))))\n        {\n          hadc->State |= ADC_STATE_TIMEOUT;\n          hadc->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  else\n  {\n    hadc->State |= ADC_STATE_ERROR_INTERNAL;\n    hadc->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\nend_conversion:\n  adc_instance->SR = 0xffffffed;\n  hadc->State |= ADC_STATE_READY;\n  if ((adc_instance->CR2 & ADC_CR2_CONT) == ADC_CR2_CONT)\n  {\n    status = HAL_OK;\n  }\n  else if ((hadc->State & ADC_STATE_INJECTED_BUSY) != ADC_STATE_INJECTED_BUSY)\n  {\n    hadc->State &= ~ADC_STATE_REG_EOC;\n    hadc->State |= ADC_STATE_EOC;\n    status = HAL_OK;\n  }\n  else\n  {\n    hadc->State &= ~ADC_STATE_INJECTED_BUSY;\n    hadc->State |= ADC_STATE_INJECTED_EOC;\n    status = HAL_OK;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "wait_for_conversion_0800376c"
        },
        "FUN_08003e20": {
            "renaming": {
                "FUN_08003e20": "perform_ADC_conversion_08003e20",
                "hadc": "ADC_handle",
                "Lock": "ADC_lock",
                "HAL_LOCKED": "HAL_ADC_LOCKED",
                "HAL_BUSY": "HAL_ADC_BUSY",
                "HAL_UNLOCKED": "HAL_ADC_UNLOCKED",
                "HAL_OK": "HAL_ADC_OK",
                "ADC_ConversionStop_Disable": "ADC_stop_conversion_disable",
                "State": "ADC_state",
                "PTR_SystemCoreClock_08003f08": "PTR_SystemCoreClock",
                "uVar2": "clock_freq",
                "uVar3": "current_time",
                "pAVar4": "adc_instance",
                "uVar5": "hclk_freq",
                "wait_loop_index": "wait_loop_index",
                "start_time": "start_time",
                "HVar1": "status"
            },
            "code": "HAL_StatusTypeDef_conflict perform_ADC_conversion_08003e20(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clock_freq, wait_loop_index;\n  ADC_TypeDef *adc_instance;\n  uint32_t start_time, current_time;\n\n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(hadc);\n  if (status == HAL_OK) {\n    hadc->State = hadc->State & 0xffffeefd | 2;\n    clock_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    wait_loop_index = (uint32_t) (HAL_RCC_GetHCLKFreq() / clock_freq) << 1;\n    while (wait_loop_index--);\n    ADC_Enable(hadc);\n    hadc->Instance->CR2 |= 8;\n    start_time = HAL_GetTick();\n    while ((hadc->Instance->CR2 & 8) != 0) {\n      current_time = HAL_GetTick();\n      if (current_time - start_time > 10) {\n        hadc->State = hadc->State & 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_instance = hadc->Instance;\n    adc_instance->CR2 |= 4;\n    start_time = HAL_GetTick();\n    while ((adc_instance->CR2 & 4) != 0) {\n      current_time = HAL_GetTick();\n      if (current_time - start_time > 10) {\n        hadc->State = hadc->State & 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc->State = hadc->State & 0xfffffffc | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e20",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_ADC_conversion_08003e20"
        },
        "FUN_08002c14": {
            "renaming": {
                "FUN_08002c14": "readFromAddressWithQuantity_08002c14",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall TwoWire::readFromAddressWithQuantity_08002c14(TwoWire *wire,uint8_t address,uint8_t quantity)\n{\n  uint8_t result;\n  result = readFromAddressWithQuantity_08002c14(wire,address,quantity,'\\x01');\n  return result;\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c14",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readFromAddressWithQuantity_08002c14"
        },
        "FUN_08009084": {
            "renaming": {
                "__thiscall std::function<void()>::operator__": "execute_function",
                "this": "function",
                "function_void___": "function_data",
                "super__Function_base": "function_base",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "_Any_data": "any_data",
                "__throw_bad_function_call": "throw_bad_function_call",
                "FUN_08009084": "execute_function_08009084"
            },
            "code": "void __thiscall execute_function_08009084(std::function<void()>::function_void___ *function) {\n    if ((function->super__Function_base)._M_manager != (_Manager_type)0x0) {\n        (*function->_M_invoker)((_Any_data *)function);\n        return;\n    }\n    __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009084",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "execute_function_08009084"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "uVar1": "result",
                "uVar2": "flag",
                "local_1c": "local_value",
                "abStack_18": "stack_values",
                "uStack_14": "value_1",
                "uStack_10": "value_2",
                "uStack_c": "value_3",
                "DAT_080058a0": "data_1",
                "DAT_080058a4": "data_2",
                "DAT_080058a8": "data_3"
            },
            "code": "uint calculate_result_08005840(void)\n{\n  uint result = 0;\n  uint flag = *(uint *)(PTR__etext_0800589c + 4);\n  uint value = *(uint *)(DAT_080058a0 + 4);\n  byte stack_value = abStack_18[(value << 10) >> 0x1c];\n  if ((flag & 0xc) == 8) {\n    if ((flag & 0x10000) == 0) {\n      result = DAT_080058a4 * (uint)stack_value;\n    }\n    else {\n      uint temp = (uint)*(byte *)((int)&local_1c - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\n      result = (DAT_080058a8 * stack_value) / temp;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_result_08005840"
        },
        "FUN_08003306": {
            "renaming": {
                "FUN_08003306": "parseCommand_08003306",
                "command": "commandCode",
                "newFunction": "callback",
                "context": "callbackContext",
                "currentReportDigitalCallback": "digitalReportCallback",
                "currentReportDigitalCallbackContext": "digitalReportCallbackContext",
                "PIN_MODE_RESPONSE": "pinModeResponse",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "PIN_STATE_RESPONSE": "pinStateResponse",
                "currentPinValueCallback": "pinValueCallback",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "ANALOG_MESSAGE": "analogMessage",
                "currentAnalogCallback": "analogCallback",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "DIGITAL_MESSAGE": "digitalMessage",
                "currentDigitalCallback": "digitalCallback",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "ANALOG_REPORT": "analogReport",
                "currentReportAnalogCallback": "analogReportCallback",
                "currentReportAnalogCallbackContext": "analogReportCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::parseCommand_08003306(FirmataParser *this, uint8_t command, callbackFunction newFunction, void *context) {\n    if (command == DIGITAL_REPORT) {\n        this->currentReportDigitalCallback = newFunction;\n        this->currentReportDigitalCallbackContext = context;\n        return;\n    }\n    if (command > DIGITAL_REPORT) {\n        if (command == PIN_MODE_RESPONSE) {\n            this->currentPinModeCallback = newFunction;\n            this->currentPinModeCallbackContext = context;\n            return;\n        }\n        if (command == PIN_STATE_RESPONSE) {\n            this->currentPinValueCallback = newFunction;\n            this->currentPinValueCallbackContext = context;\n        }\n        else if (command == ANALOG_MESSAGE) {\n            this->currentAnalogCallback = newFunction;\n            this->currentAnalogCallbackContext = context;\n            return;\n        }\n        return;\n    }\n    if (command == DIGITAL_MESSAGE) {\n        this->currentDigitalCallback = newFunction;\n        this->currentDigitalCallbackContext = context;\n        return;\n    }\n    if (command == ANALOG_REPORT) {\n        this->currentReportAnalogCallback = newFunction;\n        this->currentReportAnalogCallbackContext = context;\n        return;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003306",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "parseCommand_08003306"
        },
        "FUN_08002578": {
            "renaming": {
                "FUN_08002578": "stopTimer_08002578",
                "obj": "timerObject"
            },
            "code": "void stopTimer_08002578(stimer_t *timerObject)\n{\n  TimerPulseDeinit((stimer_t_conflict *)timerObject);\n  return;\n}",
            "called": [
                "TimerPulseDeinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002578",
            "calling": [
                "detach"
            ],
            "imported": false,
            "current_name": "stopTimer_08002578"
        },
        "FUN_08006932": {
            "renaming": {
                "FUN_08006932": "configure_uart_08006932",
                "*huart": "*uart_handle",
                "Instance": "instance",
                "CR1": "control_register_1",
                "gState": "global_state",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_UART_TxCpltCallback": "UART_transmit_complete_callback",
                "HAL_OK": "HAL_Ok"
            },
            "code": "HAL_StatusTypeDef configure_uart_08006932(UART_HandleTypeDef *uart_handle)\n{\n    //Disable UART transmit\n    uart_handle->Instance->CR1 &= ~(1 << 6);\n    \n    //Set UART state to ready\n    uart_handle->gState = HAL_UART_STATE_READY;\n    \n    //Call UART transmit complete callback\n    HAL_UART_TxCpltCallback(uart_handle);\n    \n    return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006932",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "configure_uart_08006932"
        },
        "FUN_080060c4": {
            "renaming": {
                "FUN_080060c4": "initialize_timer_080060c4",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "cc_enable_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode",
                "CCER": "cc_enable_register",
                "CR2": "cr2_register",
                "OCMode": "oc_mode_value",
                "OCPolarity": "oc_polarity_value",
                "OCNPolarity": "ocn_polarity_value",
                "Pulse": "pulse_value",
                "DAT_08006124": "PTR_08006124",
                "CCMR1": "ccmr1_register",
                "PTR_08006124": "PTR_08006124",
                "OCIdleState": "oc_idle_state",
                "OCNIdleState": "ocn_idle_state"
            },
            "code": "void initialize_timer_080060c4(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_compare_config)\n{\n    uint32_t cc_enabled_mask = 0xffffffef;\n    uint32_t cr2_value = timer->CR2;\n    uint32_t oc_mode = output_compare_config->OCMode;\n    uint32_t cc_enable_value = (timer->CCER & 0xffffffdf) | (output_compare_config->OCPolarity << 4);\n    if (timer == DAT_08006124) {\n        cc_enable_value = (cc_enable_value & 0xffffff7f) | (output_compare_config->OCNPolarity << 4);\n        cr2_value = (cr2_value & 0xfffff3ff) | (output_compare_config->OCIdleState << 2) | (output_compare_config->OCNIdleState << 2);\n    }\n    timer->CR2 = cr2_value;\n    timer->CCMR1 = (timer->CCMR1 & 0xffff8cff) | (oc_mode << 8);\n    timer->CCR2 = output_compare_config->Pulse;\n    timer->CCER = cc_enable_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060c4",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "initialize_timer_080060c4"
        },
        "FUN_08009eac": {
            "renaming": {
                "FUN_08009eac": "parse_data_08009eac",
                "param_1": "file_descriptor",
                "param_2": "data_array",
                "uVar1": "flags",
                "iVar2": "size",
                "local_18": "local_file_descriptor",
                "local_14": "local_data_array"
            },
            "code": "void parse_data_08009eac(int file_descriptor, int *data_array) {\n\tushort flags;\n\tint size;\n\tint local_file_descriptor;\n\tint *local_data_array;\n\n\tif ((uint)*(ushort *)(data_array + 3) << 0x1e > -1) {\n\t\tlocal_file_descriptor = file_descriptor;\n\t\tlocal_data_array = data_array;\n\t\tflags = __swhatbuf_r(file_descriptor, data_array, &local_file_descriptor, &local_data_array);\n\t\tsize = _malloc_r(file_descriptor, local_file_descriptor);\n\t\tif (size != 0) {\n\t\t\t*(undefined4 *)(file_descriptor + 0x28) = DAT_08009f28;\n\t\t\t*data_array = size;\n\t\t\t*(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) | 0x80;\n\t\t\tdata_array[4] = size;\n\t\t\tdata_array[5] = local_file_descriptor;\n\t\t\tif ((local_data_array != (int *)0x0) && (_isatty_r(file_descriptor, (int)*(short *)((int)data_array + 0xe)) != 0)) {\n\t\t\t\t*(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 1;\n\t\t\t}\n\t\t\t*(ushort *)(data_array + 3) = flags | *(ushort *)(data_array + 3);\n\t\t\treturn;\n\t\t}\n\t\tif ((int)(short)*(ushort *)(data_array + 3) << 0x16 < 0) {\n\t\t\treturn;\n\t\t}\n\t\t*(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 2;\n\t}\n\t*data_array = (int)data_array + 0x47;\n\tdata_array[4] = (int)data_array + 0x47;\n\tdata_array[5] = 1;\n\treturn;\n}",
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009eac",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "parse_data_08009eac"
        },
        "FUN_08008dbe": {
            "renaming": {
                "__thiscall IPAddress::FUN_08008dbe": "printIPAddress",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "i",
                "iVar4": "totalBytesPrinted",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted",
                "FUN_08008dbe": "printIPAddress_08008dbe"
            },
            "code": "size_t __thiscall printIPAddress_08008dbe(IPAddress *ipAddress,Print *printer)\n{\n  size_t totalBytesPrinted = 0;\n  for (int i = 0; i < 3; i++) {\n    size_t bytesPrinted = Print::print(printer, (ipAddress->_address).bytes[i], 10);\n    size_t dotPrinted = Print::print(printer, '.');\n    totalBytesPrinted += bytesPrinted + dotPrinted;\n  }\n  size_t lastBytePrinted = Print::print(printer, (ipAddress->_address).bytes[3], 10);\n  return totalBytesPrinted + lastBytePrinted;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008dbe",
            "calling": [],
            "imported": false,
            "current_name": "printIPAddress_08008dbe"
        },
        "FUN_080072d8": {
            "renaming": {
                "FUN_080072d8": "set_GPIO_pin_state_080072d8",
                "port": "gpio_port",
                "pin": "pin_number",
                "val": "pin_state"
            },
            "code": "void set_GPIO_pin_state_080072d8(GPIO_TypeDef *gpio_port, uint32_t pin_number, uint32_t pin_state) {\n  if (pin_state == 0) {\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)pin_number, GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port, (uint16_t)pin_number, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d8",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_GPIO_pin_state_080072d8"
        },
        "FUN_08002b00": {
            "renaming": {
                "TwoWire::FUN_08002b00": "receiveData",
                "*inBytes": "inputBytes",
                "numBytes": "numberOfBytes",
                "PTR_user_onReceive_08002b54": "userOnReceive",
                "*PTR_rxBufferLength_08002b5c": "rxBufferLength",
                "*PTR_rxBufferIndex_08002b58": "rxBufferIndex",
                "allocateRxBuffer": "allocateRxBuffer",
                "*PTR_rxBuffer_08002b60": "rxBuffer",
                "_Error_Handler": "errorHandler",
                "FUN_08002b00": "receiveData_08002b00"
            },
            "code": "void receiveData_08002b00(uint8_t *inputBytes, int numberOfBytes) {\n\tif (*(int *)PTR_user_onReceive_08002b54 != 0 && *PTR_*PTR_rxBuffer_08002b60Length_08002b5c <= *PTR_*PTR_rxBuffer_08002b60Index_08002b58) {\n\t\tallocateRxBuffer(numberOfBytes);\n\t\tif (*(int *)*PTR_rxBuffer_08002b60 == 0) {\n\t\t\terrorHandler(s__home_bo__arduino15_packages_STM_08002b64, 0x183);\n\t\t}\n\t\tmemcpy(*(void **)*PTR_rxBuffer_08002b60,inputBytes,numberOfBytes);\n\t\t*PTR_*PTR_rxBuffer_08002b60Index_08002b58 = 0;\n\t\t*PTR_*PTR_rxBuffer_08002b60Length_08002b5c = (char)numberOfBytes;\n\t\t(*(code **)PTR_user_onReceive_08002b54)(numberOfBytes);\n\t}\n\treturn;\n}",
            "called": [
                "_Error_Handler",
                "memcpy",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b00",
            "calling": [],
            "imported": false,
            "current_name": "receiveData_08002b00"
        },
        "FUN_08002f84": {
            "renaming": {
                "FUN_08002f84": "setSystemResetCallback_08002f84",
                "command": "command",
                "newFunction": "newFunction",
                "PTR_currentSystemResetCallback_08002f90": "currentSystemResetCallback",
                "systemCallbackFunction": "systemCallbackFunction"
            },
            "code": "void __thiscall firmata::FirmataClass::setSystemResetCallback_08002f84(FirmataClass *this, uint8_t command, systemCallbackFunction newFunction)\n{\n  if (command == SYSTEM_RESET_COMMAND) {\n    *(systemCallbackFunction *)PTR_currentSystemResetCallback_08002f90 = newFunction;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f84",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSystemResetCallback_08002f84"
        },
        "FUN_08009094": {
            "renaming": {
                "FUN_08009094": "handle_gpio_irq_08009094",
                "GPIO_Pin": "pin",
                "bVar1": "pin_id",
                "PTR_gpio_irq_conf_080090b0": "irq_conf_ptr",
                "std::function<void()>::operator__": "operator()",
                "function_void___": "std::function<void()>*"
            },
            "code": "void handle_gpio_irq_08009094(uint16_t pin) {\n    byte pin_id = get_pin_id(pin);\n    int* PTR_gpio_irq_conf_080090b0 = (int*)(PTR_gpio_irq_conf_080090b0 + pin_id * 0x14 + 0xc);\n    if (*PTR_gpio_irq_conf_080090b0 != 0) {\n        std::function<void()>* irq_handler_ptr = (std::function<void()>*)(PTR_gpio_irq_conf_080090b0 + pin_id * 0x14 + 4);\n        irq_handler_ptr->operator()();\n    }\n    return;\n}",
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009094",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_irq_08009094"
        },
        "FUN_0800a0cc": {
            "renaming": {
                "FUN_0800a0cc": "close_file_and_set_error_if_failed_0800a0cc",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "error_ptr",
                "iVar2": "close_result"
            },
            "code": "void close_file_and_set_error_if_failed_0800a0cc(int *error_code, int file_descriptor) {\n  undefined *error_ptr = PTR_errno_0800a0e8;\n  *(undefined4 *)PTR_errno_0800a0e8 = 0;\n  int close_result = _close(file_descriptor);\n  if ((close_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0cc",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_and_set_error_if_failed_0800a0cc"
        },
        "FUN_08002580": {
            "renaming": {
                "FUN_08002580::FUN_08002580": "initialize_servo",
                "this": "servo",
                "bVar1": "servo_count",
                "MAX_SERVOS": "12",
                "FUN_08002580": "initialize_servo_08002580"
            },
            "code": "initialize_servo_08002580* initialize_servo_08002580(initialize_servo_08002580* servo){\n\tconst int MAX_SERVOS = 12;\n\tint servo_count = *PTR_initialize_servo_08002580Count_080025a4;\n\tif (servo_count > MAX_SERVOS){\n\t\tservo->servoIndex = 0xff;\n\t\treturn servo;\n\t}\n\t*PTR_initialize_servo_08002580Count_080025a4 = servo_count + 1;\n\tservo->servoIndex = servo_count;\n\t*(int*)(PTR_servos_080025a8 + (uint)servo_count * 8 + 4) = 1500;\n\treturn servo;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002580",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_servo_08002580"
        },
        "FUN_080073ec": {
            "renaming": {
                "FUN_080073ec": "set_bit_and_clear_flags_080073ec",
                "puVar1": "data_ptr"
            },
            "code": "void set_bit_and_clear_flags_080073ec(void)\n{\n  uint* data_ptr = DAT_0800742c;\n  *data_ptr |= 1;\n  data_ptr[1] &= DAT_08007430;\n  *data_ptr &= 0xfef6ffff;\n  *data_ptr &= 0xfffbffff;\n  data_ptr[1] &= 0xff80ffff;\n  data_ptr[2] = 0x9f0000;\n  *(undefined4 *)(DAT_08007434 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ec",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_flags_080073ec"
        },
        "FUN_08008ef4": {
            "renaming": {
                "FUN_08008ef4": "map_08008ef4",
                "x": "input_value",
                "in_min": "input_min",
                "in_max": "input_max",
                "out_min": "output_min",
                "out_max": "output_max",
                "(uint)": ""
            },
            "code": "long map_08008ef4(long input_value, long input_min, long input_max, long output_min, long output_max) {\n    long output_range = output_max - output_min;\n    long input_range = input_max - input_min;\n    long scaled_value = (input_value - input_min) * output_range;\n    long map_08008ef4ped_value = (scaled_value / input_range) + output_min;\n    return map_08008ef4ped_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ef4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "map_08008ef4"
        },
        "FUN_08009fe8": {
            "renaming": {
                "FUN_08009fe8": "calculate_signal_08009fe8",
                "__sig": "signal",
                "iVar1": "result",
                "_FUN_08009fe8_r": "_calculate_signal_r"
            },
            "code": "int calculate_signal_08009fe8(int signal) {\n  int result = _calculate_signal_08009fe8_r(*(undefined4 *)PTR__impure_ptr_08009ff4, signal);\n  return result;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009fe8",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "calculate_signal_08009fe8"
        },
        "FUN_08002c1e": {
            "renaming": {
                "FUN_08002c1e": "initialize_static_data_08002c1e"
            },
            "code": "void initialize_static_data_08002c1e()\n{\n  __static_initialization_and_destruction_0(1, 0xFFFF);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c1e",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08002c1e"
        },
        "FUN_08002f94": {
            "renaming": {
                "FUN_08002f94": "setSysexCallback_08002f94",
                "command": "sysexCommand",
                "newFunction": "callbackFunction",
                "PTR_currentSysexCallback_08002f9c": "currentSysexCallback"
            },
            "code": "void __thiscall firmata::FirmataClass::setSysexCallback_08002f94(FirmataClass *this,uint8_t command,sysexCallbackFunction newFunction)\n{\n  *(sysexCallbackFunction *)PTR_currentSysexCallback_08002f9c = newFunction;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f94",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08002f94"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "print_08008eec",
                "this": "print_object",
                "b": "character",
                "base": "base",
                "sVar1": "result"
            },
            "code": "size_t __thiscall Print::print_08008eec(Print *print_08008eec_object, uchar character, int base)\n{\n  size_t result;\n  result = print_08008eec(print_08008eec_object, (uint)character, base);\n  return result;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_08008eec"
        },
        "FUN_08001b48": {
            "renaming": {
                "FUN_08001b48": "initializeFirmata_08001b48",
                "this": "firmata"
            },
            "code": "void initializeFirmata_08001b48(void)\n{\n  FirmataClass* firmata = PTR_Firmata_08001bc0;\n  firmata->setFirmwareNameAndVersion(PTR_Firmata_08001bc0, PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4, 2, 5);\n  firmata->attach(firmata, 0xe0, DAT_08001bc8);\n  firmata->attach(firmata, 0x90, DAT_08001bcc);\n  firmata->attach(firmata, 0xc0, DAT_08001bd0);\n  firmata->attach(firmata, 0xd0, DAT_08001bd4);\n  firmata->attach(firmata, 0xf4, DAT_08001bd8);\n  firmata->attach(firmata, 0xf5, DAT_08001bdc);\n  firmata->attach(firmata, 0xf0, DAT_08001be0);\n  firmata->attach(firmata, 0xff, DAT_08001be4);\n  firmata->begin(0xe100);\n  systemResetCallback();\n  startForkserver(0);\n  return;\n}",
            "called": [
                "begin",
                "startForkserver",
                "attach",
                "attach",
                "setFirmwareNameAndVersion",
                "attach",
                "systemResetCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b48",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08001b48"
        },
        "FUN_08005df4": {
            "renaming": {
                "FUN_08005df4": "check_TIM_channel_conflict_08005df4",
                "htim": "timer_handle",
                "pTVar1": "timer_instance"
            },
            "code": "HAL_StatusTypeDef_conflict check_TIM_channel_conflict_08005df4(TIM_HandleTypeDef_conflict *htim)\n{\n  TIM_TypeDef_conflict *timer_instance;\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  timer_instance = htim->Instance;\n  \n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  \n  HAL_TIM_OC_MspDeInit(htim);\n  \n  htim->State = HAL_TIM_STATE_RESET;\n  htim->Lock = HAL_UNLOCKED;\n  \n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005df4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "check_TIM_channel_conflict_08005df4"
        },
        "FUN_08009148": {
            "renaming": {
                "FUN_08009148": "run_global_constructors_and_destructors_08009148",
                "puVar1": "constructor_array",
                "iVar2": "num_constructors",
                "iVar3": "i",
                "_init": "_init",
                "PTR___preinit_array_end_08009188": "destructor_array",
                "PTR___do_global_dtors_aux_fini_array_entry_0800918c": "PTR___do_global_dtors_aux_fini_array_entry_0800918c"
            },
            "code": "void run_global_constructors_and_destructors_08009148(void)\n{\n  void** constructor_array = PTR___preinit_array_end_08009180;\n  int num_constructors = (int)PTR___preinit_array_end_08009184 - (int)PTR___preinit_array_end_08009180;\n  for (int i = 0; i < num_constructors >> 2; i++) {\n    (**(void (**)(void))(constructor_array + i * 4))();\n  }\n  _init();\n  void** PTR___preinit_array_end_08009188 = PTR___preinit_array_end_08009188;\n  int num_destructors = (int)PTR___do_global_dtors_aux_fini_array_entry_0800918c - (int)PTR___preinit_array_end_08009188;\n  for (int i = 0; i < num_destructors >> 2; i++) {\n    (**(void (**)(void))(PTR___preinit_array_end_08009188 + i * 4))();\n  }\n  return;\n}",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009148",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "run_global_constructors_and_destructors_08009148"
        },
        "FUN_080099dc": {
            "renaming": {
                "FUN_080099dc": "write_to_stream_080099dc",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "flags",
                "iVar1": "size",
                "uVar2": "ushort_value",
                "puVar3": "byte_buffer"
            },
            "code": "uint write_to_stream_080099dc(int stream, uint character, int *buffer, undefined4 flags)\n{\n  int size;\n  uint ushort_value;\n  undefined *byte_buffer;\n  \n  if (stream != 0 && *(int *)(stream + 0x18) == 0) {\n    __sinit();\n  }\n  if (buffer == (int *)PTR___sf_fake_stdin_08009a74) {\n    buffer = *(int **)(stream + 4);\n  }\n  else if (buffer == (int *)PTR___sf_fake_stdout_08009a78) {\n    buffer = *(int **)(stream + 8);\n  }\n  else if (buffer == (int *)PTR___sf_fake_stderr_08009a7c) {\n    buffer = *(int **)(stream + 0xc);\n  }\n  buffer[2] = buffer[6];\n  ushort_value = (uint)*(ushort *)(buffer + 3);\n  size = ushort_value << 0x1c;\n  if (((size < 0) && (ushort_value = buffer[4], ushort_value != 0)) || (size = __swsetup_r(stream, buffer, size, ushort_value, flags), size == 0)) {\n    character = character & 0xff;\n    size = *buffer - buffer[4];\n    if ((size < buffer[5]) || (size = _fflush_r(stream, buffer), size == 0)) {\n      buffer[2] = buffer[2] + -1;\n      byte_buffer = (undefined *)*buffer;\n      *buffer = (int)(byte_buffer + 1);\n      *byte_buffer = (char)character;\n      if (size + 1 != buffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      size = _fflush_r(stream, buffer);\n      if (size == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099dc",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_080099dc"
        },
        "FUN_08000c18": {
            "renaming": {
                "FUN_08000c18": "FUNC_08000c18"
            },
            "code": "\nvoid FUNC_08000c18(byte port,int value)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte portValue;\n  \n  uVar6 = (uint)port;\n  if ((uVar6 < 5) && (PTR_reportPINs_08000ebc[uVar6] = (char)value, value != 0)) {\n    bVar1 = PTR_portConfigInputs_08000ec0[uVar6];\n    uVar6 = (uVar6 & 0x1f) * 8;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        portValue = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          portValue = 0;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            portValue = 0;\n          }\n          else if ((bVar1 & 1) == 0) {\n            portValue = 0;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              portValue = 0;\n            }\n            else {\n              portValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      portValue = 0;\n    }\n    uVar5 = uVar6 + 1;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 2) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 2;\n    }\n    uVar5 = uVar6 + 2;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 4) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 4;\n    }\n    uVar5 = uVar6 + 3;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 8) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 8;\n    }\n    uVar5 = uVar6 + 4;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x10) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x10;\n    }\n    uVar5 = uVar6 + 5;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x20) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x20;\n    }\n    uVar5 = uVar6 + 6;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x40) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x40;\n    }\n    uVar6 = uVar6 + 7;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x80) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(port,portValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000c18",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08000c18"
        },
        "FUN_08009024": {
            "renaming": {
                "FUN_08009024": "handle_external_interrupt_08009024"
            },
            "code": "void handle_external_interrupt_08009024(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009024",
            "calling": [],
            "imported": false,
            "current_name": "handle_external_interrupt_08009024"
        },
        "FUN_080064cc": {
            "renaming": {
                "FUN_080064cc": "send_data_080064cc",
                "*huart": "*uart",
                "uVar1": "tx_count",
                "pbVar2": "tx_buffer",
                "HAL_UART_STATE_BUSY_TX": "HAL_BUSY",
                "HAL_OK": "HAL_OK",
                "HAL_BUSY": "HAL_BUSY"
            },
            "code": "HAL_StatusTypeDef send_data_080064cc(UART_HandleTypeDef *uart)\n{\n  uint16_t tx_count;\n  byte *tx_buffer;\n\n  if (uart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n\n  if ((uart->Init).WordLength == 0x1000) {\n    tx_buffer = uart->pTxBuffPtr;\n    uart->Instance->DR = *(ushort *)tx_buffer & 0x1ff;\n    if ((uart->Init).Parity == 0) {\n      uart->pTxBuffPtr = tx_buffer + 2;\n    }\n    else {\n      uart->pTxBuffPtr = tx_buffer + 1;\n    }\n  }\n  else {\n    tx_buffer = uart->pTxBuffPtr;\n    uart->pTxBuffPtr = tx_buffer + 1;\n    uart->Instance->DR = (uint)*tx_buffer;\n  }\n\n  tx_count = uart->TxXferCount - 1;\n  uart->TxXferCount = tx_count;\n\n  if (tx_count == 0) {\n    uart->Instance->CR1 &= 0xffffff7f;\n    uart->Instance->CR1 |= 0x40;\n    return HAL_OK;\n  }\n\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064cc",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_data_080064cc"
        },
        "FUN_08008058": {
            "renaming": {
                "FUN_08008058": "handle_I2C_event_08008058",
                "PTR_i2c_handles_08008064": "i2c_handles",
                "*(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008064 + 4)": "current_i2c_handle",
                "HAL_I2C_EV_IRQHandler": "handle_I2C_event_interrupt"
            },
            "code": "void handle_I2C_event_08008058(void)\n{\n  I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008064 = PTR_PTR_i2c_handles_08008064_08008064;\n  I2C_HandleTypeDef_conflict **(I2C_HandleTypeDef_conflict **)(PTR_PTR_i2c_handles_08008064_08008064 + 4) = *(PTR_i2c_handles_08008064 + 4);\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef_conflict **)(PTR_PTR_i2c_handles_08008064_08008064 + 4));\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008058",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_08008058"
        },
        "FUN_08004ac2": {
            "renaming": {
                "FUN_08004ac2": "i2c_address_match_callback_08004ac2",
                "hi2c": "i2c_handle",
                "AddrMatchCode": "address_match_code",
                "OwnAddress1": "own_address_1",
                "OwnAddress2": "own_address_2",
                "HAL_I2C_AddrCallback": "HAL_I2C_AddressCallback",
                "SR2": "status_register_2"
            },
            "code": "HAL_StatusTypeDef i2c_address_match_callback_08004ac2(I2C_HandleTypeDef *i2c_handle)\n{\n  uint16_t address_match_code;\n  if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle,(i2c_handle->Instance->SR2 & 4) == 0,address_match_code);\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ac2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_address_match_callback_08004ac2"
        },
        "FUN_08006ca8": {
            "renaming": {
                "FUN_08006ca8": "configure_ADC_pin_08006ca8",
                "hadc": "adc_handle",
                "GPIOx": "gpio_port",
                "tmpreg": "pin_mask",
                "tmpreg_1": "unused",
                "GPIO_InitStruct": "gpio_config",
                "DAT_08006d14": "ADC1",
                "DAT_08006d18": "ADC2",
                "g_current_pin_08006d1c": "g_current_pin",
                "puVar1": "current_pin",
                "PTR_g_current_pin_08006d1c": "g_current_pin",
                "DAT_08006d20": "g_adc_pin_mask"
            },
            "code": "void configure_ADC_pin_08006ca8(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t pin_mask;\n  GPIO_TypeDef *gpio_port;\n  GPIO_InitTypeDef gpio_config;\n  \n  if (adc_handle->Instance == DAT_08006d14) {\n    *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | 0x200;\n  }\n  else if (adc_handle->Instance == DAT_08006d18) {\n    *(uint *)(DAT_08006d20 + 0x18) = *(uint *)(DAT_08006d20 + 0x18) | 0x400;\n  }\n  \n  uint8_t *current_pin = PTR_g_current_pin_08006d1c;\n  gpio_port = set_GPIO_Port_Clock((uint)((int)(char)*current_pin << 0x18) >> 0x1c);\n  pin_mask = 1 << (*current_pin & 0xf) & 0xffff;\n  gpio_config.Pin = pin_mask;\n  gpio_config.Mode = GPIO_MODE_ANALOG;\n  gpio_config.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(gpio_port, &gpio_config);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ca8",
            "calling": [
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "configure_ADC_pin_08006ca8"
        },
        "FUN_0800937c": {
            "renaming": {
                "FUN_0800937c": "FUNC_0800937c"
            },
            "code": "\nint FUNC_0800937c(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08009588) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08009590) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08009594) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_080093be:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08009568;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__0800958c,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08009598;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__0800958c & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08009498;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08009498:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar5 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar5;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar8 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08009598,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_0800959c,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_080095a4,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_080095a0 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_0800951a;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08009568;\nLAB_0800951a:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_080093be;\n}\n\n",
            "called": [
                "memchr",
                "__sfputs_r",
                "__swsetup_r",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800937c",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_0800937c"
        },
        "FUN_08000214": {
            "renaming": {
                "FUN_08000214": "analogWriteIfPossible_08000214",
                "pin": "pinNumber",
                "value": "value",
                "bVar1": "isServo",
                "bVar2": "pinMode",
                "_Var3": "isPWM",
                "ulPin": "pinNumber",
                "uVar4": "digitalPin",
                "PTR_Firmata_080002d8": "firmataInstance",
                "PTR_digitalPin_080002dc": "digitalPinArray",
                "NC": "NC",
                "pinNametoDigitalPin": "pinNametoDigitalPin",
                "pin_in_pinmap": "isPWM",
                "PTR_PinMap_PWM_080002e8": "pinMapPWM",
                "Servo::write": "servoWrite",
                "PTR_servos_080002e4": "servoArray",
                "PTR_servoPinMap_080002e0": "servoPinMap"
            },
            "code": "void analogWriteIfPossible_08000214(byte pin, int value) {\n  uint pinNumber = (uint)pin;\n  if (pinNumber > 59) {\n    return;\n  }\n  byte pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080002d8, pin);\n  if (pinMode == 3) {\n    bool isPWM = false;\n    if (pinNumber < 60) {\n      if (PTR_digitalPin_080002dc[pinNumber] != NC) {\n        uint digitalPin = pinNametoDigitalPin(PTR_digitalPin_080002dc[pinNumber]);\n        if (digitalPin > 1) {\n          isPWM = pin_in_pinmap(PTR_digitalPin_080002dc[pinNumber], (PinMap_conflict *)PTR_PinMap_PWM_080002e8);\n        }\n      }\n    }\n    if (isPWM) {\n      analogWrite(pinNumber, value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n  }\n  else if (pinMode == 4) {\n    bool isServo = false;\n    if (pinNumber < 60) {\n      if (PTR_digitalPin_080002dc[pinNumber] != NC) {\n        uint digitalPin = pinNametoDigitalPin(PTR_digitalPin_080002dc[pinNumber]);\n        if (digitalPin > 1) {\n          isServo = true;\n        }\n      }\n    }\n    if (isServo) {\n      Servo * servo = (Servo *)(PTR_servos_080002e4 + (uint)(byte)PTR_PTR_servoPinMap_080002e0_080002e0[pinNumber] * 3);\n      servo->write(value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n  }\n}\n",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "setPinState",
                "analogWrite",
                "getPinMode",
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000214",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "analogWriteIfPossible_08000214"
        },
        "FUN_08003724": {
            "renaming": {
                "FUN_08003724": "set_flag_and_init_08003724",
                "FUN_08003724Tick": "set_tick",
                "DAT_08003744": "flag_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict set_flag_and_init_08003724(void)\n{\n  *DAT_08003744 = *DAT_08003744 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  set_tick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_InitTick",
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003724",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "set_flag_and_init_08003724"
        },
        "FUN_08005bb8": {
            "renaming": {
                "FUN_08005bb8": "calculatePeripheralClock_08005bb8",
                "PeriphClk": "periphClock",
                "uVar1": "calculatedClock",
                "uVar2": "multiplier",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "code": "uint32_t calculatePeripheralClock_08005bb8(uint32_t periphClock)\n{\n  uint32_t calculatedClock = 0;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n\n  pllMulFactorTable[0] = *(undefined4 *)(PTR_DAT_08005ca0);\n  pllMulFactorTable[1] = *(undefined4 *)(PTR_DAT_08005ca0 + 4);\n  pllMulFactorTable[2] = *(undefined4 *)(PTR_DAT_08005ca0 + 8);\n  predivFactorTable = *(uint8_t (*) [2])(PTR_DAT_08005ca0 + 0x10);\n\n  if (periphClock == 2) {\n    calculatedClock = HAL_RCC_GetPCLK2Freq();\n    calculatedClock /= ((((DAT_08005ca4[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (periphClock == 0x10) {\n    if ((*DAT_08005ca4 & 0x1000000) == 0) {\n      calculatedClock = 0;\n    }\n    else {\n      uint multiplier = DAT_08005cb0;\n      if ((DAT_08005ca4[1] & 0x10000) != 0) {\n        multiplier = DAT_08005ca8 / predivFactorTable[-((int)(DAT_08005ca4[1] << 0xe) >> 0x1f)];\n      }\n      calculatedClock = multiplier * pllMulFactorTable[(DAT_08005ca4[1] << 10) >> 0x1c];\n      if ((DAT_08005ca4[1] & 0x400000) == 0) {\n        calculatedClock = (uint32_t)((ulonglong)DAT_08005cac * (ulonglong)(calculatedClock * 2) >> 0x21);\n      }\n    }\n  }\n  else if (periphClock == 1) {\n    if ((DAT_08005ca4[8] & 0x302) == 0x102) {\n      calculatedClock = 0x8000;\n    }\n    else {\n      uint8_t clockType = DAT_08005ca4[8] & 0x300;\n      if ((clockType == 0x200) && ((DAT_08005ca4[9] & 2) != 0)) {\n        calculatedClock = 32000;\n      }\n      else if (clockType == 0x300) {\n        if ((*DAT_08005ca4 & 0x20000) == 0) {\n          calculatedClock = 0;\n        }\n        else {\n          calculatedClock = 0xf424;\n        }\n      }\n      else {\n        calculatedClock = 0;\n      }\n    }\n  }\n  else {\n    calculatedClock = 0;\n  }\n  return calculatedClock;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bb8",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion"
            ],
            "imported": false,
            "current_name": "calculatePeripheralClock_08005bb8"
        },
        "FUN_08002f0a": {
            "renaming": {
                "FUN_08002f0a": "sendCommand_08002f0a",
                "bytec": "dataLength",
                "bytev": "dataBytes"
            },
            "code": "void __thiscall firmata::FirmataClass::sendCommand_08002f0a(byte command, byte dataLength, byte *dataBytes) {\n  FirmataMarshaller::sendCommand_08002f0a(&this->marshaller, command, (uint)dataLength, dataBytes);\n  return;\n}",
            "called": [
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f0a",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "sendCommand_08002f0a"
        },
        "FUN_08002634": {
            "renaming": {
                "FUN_08002634": "setPin_08002634",
                "this": "servo",
                "pin": "pinNumber",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall Servo::setPin_08002634(int pin)\n{\n  uint8_t result;\n  result = setPin_08002634(this, pin, 0x220, 0x960);\n  return result;\n}",
            "called": [
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002634",
            "calling": [
                "attachServo"
            ],
            "imported": false,
            "current_name": "setPin_08002634"
        },
        "FUN_080063c0": {
            "renaming": {
                "FUN_080063c0": "disableTimerChannel_080063c0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "DAT_0800641c": "PTR_DAT_0800641c"
            },
            "code": "HAL_StatusTypeDef_conflict disableTimerChannel_080063c0(TIM_HandleTypeDef_conflict *timerHandle, uint32_t channel)\n{\n    TIM_TypeDef_conflict *timerInstance = timerHandle->Instance;\n    TIM_CCxChannelCmd(timerInstance, channel, DISABLE);\n    if (((timerInstance == DAT_0800641c) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0))\n    {\n        timerInstance->BDTR &= ~(1 << 15);\n    }\n    if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0))\n    {\n        timerInstance->CR1 &= ~(1 << 0);\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080063c0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disableTimerChannel_080063c0"
        },
        "FUN_0800274c": {
            "renaming": {
                "FUN_0800274c": "getNextByteInRxBuffer_0800274c",
                "this": "wire",
                "PTR_rxBufferIndex_08002768": "wire->rxBufferIndex",
                "PTR_rxBufferLength_0800276c": "wire->rxBufferLength",
                "PTR_rxBuffer_08002770": "wire->rxBuffer"
            },
            "code": "int getNextByteInRxBuffer_0800274c(TwoWire *wire) {\n  int rxBufferIndex = *(PTR_rxBufferIndex_08002768);\n  int rxBufferLength = *(PTR_rxBufferLength_0800276c);\n  if (rxBufferIndex < rxBufferLength) {\n    int* rxBuffer = *(PTR_rxBuffer_08002770);\n    uint8_t nextByte = *(rxBuffer + rxBufferIndex);\n    *(PTR_rxBufferIndex_08002768) += 1;\n    return (int)nextByte;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800274c",
            "calling": [],
            "imported": false,
            "current_name": "getNextByteInRxBuffer_0800274c"
        },
        "FUN_080098d8": {
            "renaming": {
                "FUN_080098d8": "format_string_080098d8",
                "__format": "format",
                "iVar1": "impure_ptr",
                "pcVar2": "args",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int format_string_080098d8(char *format, ...)\n{\n  int impure_ptr = *(int *)PTR__impure_ptr_08009904;\n  char *args = format;\n  undefined4 arg1 = 0;\n  undefined4 arg2 = 0;\n  undefined4 arg3 = 0;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _vfformat_string_080098d8_r(impure_ptr, *(undefined4 *)(impure_ptr + 8), format, &arg1, args, &arg1);\n  return result;\n}",
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d8",
            "calling": [
                "getTimerClkFreq",
                "getTimerIrq",
                "getTimerClkSrc",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "format_string_080098d8"
        },
        "FUN_08009270": {
            "renaming": {
                "FUN_08009270": "allocate_memory_08009270",
                "param_1": "errorCode",
                "param_2": "requestedSize",
                "puVar1": "currentPointer",
                "uVar2": "allocatedSize",
                "puVar3": "previousPointer",
                "iVar4": "allocationResult",
                "puVar5": "currentPointer",
                "uVar6": "remainingSize",
                "puVar7": "previousPointer",
                "uVar8": "allocationSize"
            },
            "code": "uint allocate_memory_08009270(uint *errorCode, uint requestedSize)\n{\n  uint *currentPointer;\n  uint allocationSize;\n  uint *previousPointer;\n  uint remainingSize;\n  uint *newPointer;\n  uint allocatedSize;\n  \n  allocationSize = (requestedSize + 3 & 0xfffffffc) + 8;\n  if (allocationSize < 0xc) {\n    allocationSize = 0xc;\n  }\n  if (((int)allocationSize < 0) || (allocationSize < requestedSize)) {\n    *errorCode = 0xc;\n  }\n  else {\n    __malloc_lock();\n    currentPointer = *(uint **)PTR___malloc_free_list_08009324;\n    previousPointer = *(uint **)PTR___malloc_free_list_08009324;\n    while (currentPointer != (uint *)0x0) {\n      remainingSize = *currentPointer - allocationSize;\n      if (-1 < (int)remainingSize) {\n        if (remainingSize < 0xc) {\n          if (previousPointer == currentPointer) {\n            allocatedSize = previousPointer[1];\n            *(uint *)PTR___malloc_free_list_08009324 = allocatedSize;\n          }\n          else {\n            allocatedSize = currentPointer[1];\n          }\n          if (previousPointer != currentPointer) {\n            previousPointer[1] = allocatedSize;\n            previousPointer = currentPointer;\n          }\n        }\n        else {\n          *currentPointer = remainingSize;\n          *(uint *)((int)currentPointer + remainingSize) = allocationSize;\n          previousPointer = (uint *)((int)currentPointer + remainingSize);\n        }\n        goto LAB_080092d4;\n      }\n      previousPointer = currentPointer;\n      currentPointer = (uint *)currentPointer[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08009328 == 0) {\n      allocatedSize = _sbrk_r(errorCode);\n      *(uint *)PTR___malloc_sbrk_start_08009328 = allocatedSize;\n    }\n    newPointer = (uint *)_sbrk_r(errorCode,allocationSize);\n    if ((newPointer != (uint *)0xffffffff) &&\n       ((previousPointer = (uint *)((int)newPointer + 3U & 0xfffffffc), newPointer == previousPointer ||\n        (allocatedSize = _sbrk_r(errorCode,(int)previousPointer - (int)newPointer), allocatedSize != -1)))) {\n      *previousPointer = allocationSize;\nLAB_080092d4:\n      __malloc_unlock(errorCode);\n      allocatedSize = (int)previousPointer + 0xbU & 0xfffffff8;\n      remainingSize = allocatedSize - (int)(previousPointer + 1);\n      if (remainingSize != 0) {\n        *(int *)((int)previousPointer + remainingSize) = -remainingSize;\n        return allocatedSize;\n      }\n      return allocatedSize;\n    }\n    *errorCode = 0xc;\n    __malloc_unlock(errorCode);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009270",
            "calling": [
                "__smakebuf_r",
                "malloc",
                "_realloc_r",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009270"
        },
        "FUN_08009038": {
            "renaming": {
                "FUN_08009038": "handle_gpio_ext_interrupt_08009038"
            },
            "code": "void handle_gpio_ext_interrupt_08009038(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009038",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_ext_interrupt_08009038"
        },
        "FUN_08005aa4": {
            "renaming": {
                "FUN_08005aa4": "configurePeriphClock_08005aa4",
                "PeriphClkInitTypeDef_conflict": "RCC_PeriphCLKInitTypeDef",
                "PeriphClkInit": "PeriphClkInit",
                "iVar1": "index",
                "puVar2": "pointer",
                "uVar3": "value1",
                "uVar4": "value2",
                "uVar5": "value3",
                "bVar6": "isHSEReady",
                "tmpreg": "temporaryRegister"
            },
            "code": "HAL_StatusTypeDef configurePeriphClock_08005aa4(RCC_PeriphCLKInitTypeDef *PeriphClkInit) {\n    bool isHSEReady = (*(uint *)(DAT_08005bac + 0x1c) & 0x10000000) == 0;\n    if (PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) {\n        if (isHSEReady) {\n            *(uint *)(DAT_08005bac + 0x1c) |= 0x10000000;\n        }\n        if ((*DAT_08005bb0 & RCC_BDCR_RTCEN) == 0) {\n            *DAT_08005bb0 |= RCC_BDCR_RTCEN;\n            uint32_t startTick = HAL_GetTick();\n            while ((*DAT_08005bb0 & RCC_BDCR_RTCEN) == 0) {\n                uint32_t currentTick = HAL_GetTick();\n                if (100 < currentTick - startTick) {\n                    return HAL_TIMEOUT;\n                }\n            }\n        }\n        uint32_t currentClockSelection = *(uint *)(DAT_08005bac + 0x20) & RCC_PERIPHCLK_RTC;\n        uint32_t newClockSelection = PeriphClkInit->RTCClockSelection & RCC_PERIPHCLK_RTC;\n        if (currentClockSelection != 0 && currentClockSelection != newClockSelection) {\n            uint32_t currentBackupDomainControl = *(uint *)(DAT_08005bac + 0x20);\n            *DAT_08005bb4 = 1;\n            *DAT_08005bb4 = 0;\n            *(uint *)(DAT_08005bac + 0x20) = currentBackupDomainControl & 0xfffffcff;\n            if ((currentBackupDomainControl & RCC_BDCR_RTCSEL_LSE) != 0) {\n                uint32_t startTick = HAL_GetTick();\n                while ((*(uint *)(DAT_08005bac + 0x20) & RCC_BDCR_RTCSEL_LSI) == 0) {\n                    uint32_t currentTick = HAL_GetTick();\n                    if (5000 < currentTick - startTick) {\n                        return HAL_TIMEOUT;\n                    }\n                }\n            }\n        }\n        *(uint *)(DAT_08005bac + 0x20) = *(uint *)(DAT_08005bac + 0x20) & 0xfffffcff | newClockSelection;\n        if (isHSEReady) {\n            *(uint *)(DAT_08005bac + 0x1c) &= 0xefffffff;\n        }\n    }\n    if (PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) {\n        *(uint *)(DAT_08005bac + 4) &= 0xffff3fff | PeriphClkInit->AdcClockSelection;\n    }\n    if (PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USB) {\n        *(uint *)(DAT_08005bac + 4) &= 0xffbfffff | PeriphClkInit->UsbClockSelection;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aa4",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configurePeriphClock_08005aa4"
        },
        "FUN_08008068": {
            "renaming": {
                "FUN_08008068": "handle_I2C_error_interrupt_08008068",
                "PTR_i2c_handles_08008074": "i2c_handles_ptr",
                "i2c_handle": "i2c_handle_ptr"
            },
            "code": "void handle_I2C_error_interrupt_08008068(void)\n{\n    I2C_HandleTypeDef_conflict* i2c_handle = *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008074 + 4);\n    HAL_I2C_ER_IRQHandler(i2c_handle);\n    return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008068",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_error_interrupt_08008068"
        },
        "FUN_08002400": {
            "renaming": {
                "FUN_08002400": "servo_sequence_complete_08002400",
                "timer": "timer16_Sequence_t",
                "uVar1": "servo_index"
            },
            "code": "bool servo_sequence_complete_08002400(timer16_Sequence_t timer) {\n  uint8_t servo_index = 0;\n  while (true) {\n    if (servo_index > 0xb) {\n      return false;\n    }\n    if ((PTR_servos_08002428[((uint)timer * 0xc + servo_index) * 8] & 0x40) != 0) {\n      break;\n    }\n    servo_index = (servo_index + 1) % 0xff;\n  }\n  return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002400",
            "calling": [
                "attach",
                "detach"
            ],
            "imported": false,
            "current_name": "servo_sequence_complete_08002400"
        },
        "FUN_08000588": {
            "renaming": {
                "FUN_08000588": "detachServoFromPin_08000588",
                "pin": "servoPin",
                "cVar1": "currentServoCount",
                "cVar2": "currentPin",
                "puVar3": "servoPinMap",
                "PTR_servoPinMap_080005cc": "servoPinMap",
                "Servo::detach": "detachServo",
                "PTR_servos_080005d0": "servos",
                "PTR_servoCount_080005d4": "servoCount",
                "PTR_detachedServoCount_080005d8": "detachedServoCount",
                "PTR_detachedServos_080005dc": "detachedServos"
            },
            "code": "void detachServoFromPin_08000588(byte pin)\\n{\\n  char currentPin;\\n  char PTR_servoCount_080005d4;\\n  undefined *PTR_servoPinMap_080005cc;\\n  \\n  PTR_servoPinMap_080005cc = PTR_PTR_servoPinMap_080005cc_080005cc;\\n  Servo::detach((Servo *)(PTR_PTR_servos_080005d0_080005d0 + (uint)(byte)PTR_PTR_servoPinMap_080005cc_080005cc[pin] * 3));\\n  currentPin = PTR_servoPinMap_080005cc[pin];\\n  PTR_servoCount_080005d4 = *PTR_PTR_servoCount_080005d4_080005d4;\\n  if ((currentPin == PTR_servoCount_080005d4) && (PTR_servoCount_080005d4 != \"\\0\")) {\\n    *PTR_PTR_servoCount_080005d4_080005d4 = PTR_servoCount_080005d4 - 1;\\n  }\\n  else if (PTR_servoCount_080005d4 != \"\\0\") {\\n    char PTR_detachedServoCount_080005d8 = *PTR_PTR_detachedServoCount_080005d8_080005d8;\\n    *PTR_PTR_detachedServoCount_080005d8_080005d8 = PTR_detachedServoCount_080005d8 + 1U;\\n    PTR_PTR_detachedServos_080005dc_080005dc[(byte)(PTR_detachedServoCount_080005d8 + 1U) - 1] = currentPin;\\n  }\\n  PTR_servoPinMap_080005cc[pin] = 0xff;\\n  return;\\n}",
            "called": [
                "detach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000588",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "detachServoFromPin_08000588"
        },
        "FUN_08002644": {
            "renaming": {
                "FUN_08002644": "updateServo_08002644",
                "this": "servo",
                "bVar1": "timerActive",
                "uVar2": "servoIndex"
            },
            "code": "void __thiscall updateServo_08002644(Servo *servo) {\n  boolean timerActive;\n  uint servoIndex = (uint)servo->servoIndex;\n  PTR_servos_08002670[servoIndex * 8] = PTR_servos_08002670[servoIndex * 8] & 0xbf;\n  timerActive = isTimerActive((timer16_Sequence_t)((ulonglong)DAT_08002674 * (ulonglong)servoIndex >> 0x23));\n  if (!timerActive) {\n    finISR((stimer_t *)PTR__timer_08002678);\n  }\n  return;\n}",
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002644",
            "calling": [
                "detachServo"
            ],
            "imported": false,
            "current_name": "updateServo_08002644"
        },
        "FUN_08002f1e": {
            "renaming": {
                "FUN_08002f1e": "printByte_08002f1e",
                "this": "firmataInstance",
                "c": "byteToPrint",
                "FirmataStream": "firmataStream",
                "super_Print": "superPrint",
                "_vptr_Print": "virtualPointerPrint"
            },
            "code": "void __thiscall FirmataClass::printByte_08002f1e(FirmataClass *firmataInstance, byte byteToPrint) {\n    (**(firmataInstance->FirmataStream->super_Print)._vptr_Print)(firmataInstance->FirmataStream, (uint)byteToPrint);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f1e",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "printByte_08002f1e"
        },
        "FUN_0800902e": {
            "renaming": {
                "FUN_0800902e": "handle_GPIO_EXTI_0800902e"
            },
            "code": "void handle_GPIO_EXTI_0800902e(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800902e",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_0800902e"
        },
        "FUN_08009042": {
            "renaming": {
                "FUN_08009042": "handle_GPIO_EXTI_Interrupt_08009042",
                "PTR_": "",
                "DAT_": "",
                "GPIO_PIN": "GPIO_PIN_NUMBER"
            },
            "code": "void handle_GPIO_EXTI_Interrupt_08009042(void)\n{\n  const int GPIO_PIN_NUMBER = 8;\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_NUMBER);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009042",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_Interrupt_08009042"
        },
        "FUN_08009c7c": {
            "renaming": {
                "FUN_08009c7c": "flush_if_short_buf_08009c7c",
                "param_1": "stream",
                "param_2": "buf",
                "param_3": "mode",
                "param_4": "flags",
                "uVar1": "result"
            },
            "code": "int flush_if_short_buf_08009c7c(int stream, char *buf, int mode, int flags) {\n  int result = 0;\n  if (*(int *)(buf + 0x10) != 0) {\n    if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (buf == PTR___sf_fake_stdin_08009cc4) {\n      buf = *(char **)(stream + 4);\n    }\n    else if (buf == PTR___sf_fake_stdout_08009cc8) {\n      buf = *(char **)(stream + 8);\n    }\n    else if (buf == PTR___sf_fake_stderr_08009ccc) {\n      buf = *(char **)(stream + 0xc);\n    }\n    if (*(short *)(buf + 0xc) != 0) {\n      result = __sflush_r(stream, buf, mode, flags);\n    }\n  }\n  return result;\n}",
            "called": [
                "__sinit",
                "__sflush_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009c7c",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_short_buf_08009c7c"
        },
        "FUN_08009b5c": {
            "renaming": {
                "FUN_08009b5c": "handle_signal_08009b5c",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_signal_08009b5c(void)\n{\n    raise(SIGABRT);\n    _exit(EXIT_FAILURE);\n}\n",
            "called": [
                "_exit",
                "raise"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b5c",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "handle_signal_08009b5c"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_08008a6c",
                "ulPin": "pin_number",
                "_Var1": "is_pin_configured_flag",
                "port": "gpio_port",
                "uVar2": "digital_io_read_value",
                "uVar3": "digital_pin_index",
                "PTR_digitalPin_08008ab4": "digitalPin",
                "0x3c": "60",
                "0xffffffff": "4294967295",
                "is_pin_configured": "is_pin_configured",
                "PinName_conflict": "PinName_conflict",
                "PTR_g_digPinConfigured_08008ab8": "g_digital_pin_configured",
                "get_GPIO_Port": "get_GPIO_Port",
                "digital_io_read": "digital_io_read"
            },
            "code": "int read_digital_pin_08008a6c(uint32_t pin_number) {\n  _Bool is_pin_configured_flag;\n  GPIO_TypeDef *gpio_port;\n  uint32_t digital_io_read_value;\n  uint32_t digital_pin_index;\n  if (pin_number < 0x3c) {\n    digital_pin_index = (uint)(char)PTR_digitalPin_08008ab4[pin_number];\n  }\n  else {\n    digital_pin_index = 0xffffffff;\n  }\n  if (digital_pin_index == 0xffffffff) {\n    digital_pin_index = 0;\n  }\n  else {\n    is_pin_configured_flag = is_pin_configured((PinName_conflict)digital_pin_index, (uint32_t *)PTR_g_digPinConfigured_08008ab8);\n    if (is_pin_configured_flag) {\n      gpio_port = get_GPIO_Port((digital_pin_index << 0x18) >> 0x1c);\n      digital_io_read_value = digital_io_read(gpio_port, 1 << (digital_pin_index & 0xf) & 0xffff);\n      digital_pin_index = digital_io_read_value & 0xff;\n    }\n    else {\n      digital_pin_index = 0;\n    }\n  }\n  if (digital_pin_index != 0) {\n    digital_pin_index = 1;\n  }\n  return digital_pin_index;\n}",
            "called": [
                "digital_io_read",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "read_digital_pin_08008a6c"
        },
        "FUN_080085b8": {
            "renaming": {
                "FUN_080085b8": "is_uart_transmit_complete_080085b8",
                "obj": "serial",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085d8": "PTR_uart_handlers",
                "index": "serial_index"
            },
            "code": "bool is_uart_transmit_complete_080085b8(serial_t *serial) {\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(*(UART_HandleTypeDef **)(PTR_uart_handlers_080085d8_080085d8 + (uint)serial->index * 4));\n  return (uart_state & 0x22U) == 0x22;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085b8",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085b8"
        },
        "FUN_08001c08": {
            "renaming": {
                "FUN_08001c08": "readTwoWire_08001c08",
                "in_r1": "address",
                "in_r2": "buffer",
                "in_r3": "size",
                "sVar1": "readSize"
            },
            "code": "byte readTwoWire_08001c08(TwoWire* wire, int address, void* buffer, size_t size) {\n  ssize_t readSize = TwoWire::read(wire, address, buffer, size);\n  return (byte)readSize;\n}",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c08",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readTwoWire_08001c08"
        },
        "FUN_080075dc": {
            "renaming": {
                "FUN_080075dc": "getTimerClockFrequency_080075dc",
                "tim": "timer",
                "uVar1": "timerClockFrequency",
                "uVar2": "timerClockSource",
                "uVar3": "timerClockFrequency",
                "uVar4": "apb1ClockDivider",
                "pFLatency": "flashLatency",
                "clkconfig": "clockConfig"
            },
            "code": "uint32_t getTimerClockFrequency_080075dc(TIM_TypeDef_conflict *timer) {\n  uint32_t timerClockFrequency, apb1ClockDivider, apb2ClockDivider, flashLatency;\n  uint8_t timerClockSource;\n  RCC_ClkInitTypeDef_conflict clockConfig;\n  clockConfig.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n  HAL_RCC_GetClockConfig(&clockConfig, &flashLatency);\n  timerClockSource = getTimerClockSource(timer);\n  apb1ClockDivider = clockConfig.APB1CLKDivider;\n  apb2ClockDivider = clockConfig.APB2CLKDivider;\n  if (timerClockSource == TIMER_CLOCK_SOURCE_APB1) {\n    timerClockFrequency = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timerClockSource == TIMER_CLOCK_SOURCE_APB2) {\n    timerClockFrequency = HAL_RCC_GetPCLK2Freq();\n    apb1ClockDivider = apb2ClockDivider;\n  }\n  else {\n    iprintf(PTR_s_TIM__Unknown_clock_source_08007644);\n    timerClockFrequency = 0;\n    apb1ClockDivider = 0;\n  }\n  if (apb1ClockDivider != RCC_HCLK_DIV2) {\n    if (apb1ClockDivider < RCC_HCLK_DIV2) {\n      if (apb1ClockDivider != RCC_HCLK_DIV1) {\n        return timerClockFrequency;\n      }\n    }\n    else if ((apb1ClockDivider != RCC_HCLK_DIV4) && (apb1ClockDivider != RCC_HCLK_DIV8)) {\n      return timerClockFrequency;\n    }\n  }\n  return timerClockFrequency << 1;\n}",
            "called": [
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK1Freq",
                "getTimerClkSrc",
                "iprintf",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075dc",
            "calling": [
                "pwm_start",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "getTimerClockFrequency_080075dc"
        },
        "FUN_080087ec": {
            "renaming": {
                "FUN_080087ec": "handle_uart_interrupt_080087ec",
                "USART3_IRQn": "UART3_IRQn",
                "PTR_uart_handlers_08008800": "PTR_uart_handlers",
                "UART_HandleTypeDef": "UART_handler",
                "uart_handler_ptr": "current_UART_handler"
            },
            "code": "void handle_uart_interrupt_080087ec(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  UART_HandleTypeDef* uart_handler_ptr = *(UART_HandleTypeDef**)(PTR_uart_handlers_08008800_08008800 + 8);\n  if (uart_handler_ptr != NULL) {\n    HAL_UART_IRQHandler(uart_handler_ptr);\n  }\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087ec",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_080087ec"
        },
        "FUN_08007ff0": {
            "renaming": {
                "FUN_08007ff0": "enable_i2c_slave_mode_08007ff0",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "uVar2": "remaining_bytes",
                "get_i2c_obj": "get_i2c_object",
                "i2c_onSlaveReceive": "on_slave_receive",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "slaveMode": "slave_mode",
                "_func_void_uint8_t_ptr_int": "function_pointer",
                "handle": "i2c_handle_struct",
                "XferSize": "transfer_size"
            },
            "code": "void enable_i2c_slave_mode_08007ff0(I2C_HandleTypeDef_conflict *hi2c) {\n  i2c_t_conflict *i2c_obj;\n  uint32_t remaining_bytes;\n  i2c_obj = get_i2c_object(hi2c);\n  if (((i2c_obj->on_slave_receive != (_func_void_uint8_t_ptr_int *)0x0) && (i2c_obj->slave_mode == '\\x01')) && (remaining_bytes = 0x20 - *(uint8_t *)&(i2c_obj->handle).XferSize & 0xff, remaining_bytes != 0)) {\n    (*i2c_obj->on_slave_receive)(i2c_obj->tx_rx_buffer,remaining_bytes);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ff0",
            "calling": [
                "I2C_Slave_AF",
                "I2C_ITError",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "enable_i2c_slave_mode_08007ff0"
        },
        "FUN_08008078": {
            "renaming": {
                "FUN_08008078": "FUNC_08008078"
            },
            "code": "\nvoid FUNC_08008078(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar4;\n  GPIO_TypeDef *pGVar5;\n  uint32_t uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08008348);\n    }\n    else {\n      pUVar4 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar4;\n      pUVar3 = DAT_08008340;\n      pUVar2 = DAT_0800833c;\n      pUVar1 = DAT_08008338;\n      if (pUVar4 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (pUVar4 == DAT_08008338) {\n          DAT_08008338[0x7b7].BRR = DAT_08008338[0x7b7].BRR | 0x4000;\n          pUVar1[0x7b7].BRR = pUVar1[0x7b7].BRR & 0xffffbfff;\n          pUVar1[0x7b7].CR3 = pUVar1[0x7b7].CR3 | 0x4000;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar4 == DAT_0800833c) {\n          DAT_0800833c[0x106e].BRR = DAT_0800833c[0x106e].BRR | 0x20000;\n          pUVar2[0x106e].BRR = pUVar2[0x106e].BRR & 0xfffdffff;\n          pUVar2[0x106e].CR3 = pUVar2[0x106e].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar4 == DAT_08008340) {\n          DAT_08008340[0x1049].CR3 = DAT_08008340[0x1049].CR3 | 0x40000;\n          pUVar3[0x1049].CR3 = pUVar3[0x1049].CR3 & 0xfffbffff;\n          pUVar3[0x104a].DR = pUVar3[0x104a].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08008354 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008078",
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "FUNC_08008078"
        },
        "FUN_08002774": {
            "renaming": {
                "FUN_08002774": "onRequestHandler_08002774",
                "PTR_user_onRequest_0800278c": "user_onRequest",
                "PTR_txBufferIndex_08002790": "txBufferIndex",
                "PTR_txBufferLength_08002794": "txBufferLength",
                "pcVar1": "requestHandler"
            },
            "code": "void onRequestHandler_08002774(void)\n{\n  code *requestHandler = *(code **)PTR_user_onRequest_0800278c;\n  if (requestHandler != (code *)0x0) {\n    *PTR_txBufferIndex_08002790 = 0;\n    *PTR_txBufferLength_08002794 = 0;\n    (*requestHandler)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002774",
            "calling": [],
            "imported": false,
            "current_name": "onRequestHandler_08002774"
        },
        "FUN_080052f0": {
            "renaming": {
                "FUN_080052f0": "handle_I2C_errors_080052f0",
                "*hi2c": "*handle",
                "HVar1": "state",
                "pIVar2": "instance",
                "uVar3": "SR1",
                "uVar4": "CR2",
                "DAT_080053c8": "I2C_SR1_ARLO",
                "0x100": "I2C_CR2_AUTOEND",
                "1": "I2C_ERROR_ARLO",
                "0xfffffeff": "I2C_SR1_ARLO_RESET",
                "0x8000": "I2C_CR1_STOP",
                "0x10200": "I2C_SR1_AF",
                "2": "I2C_ERROR_AF",
                "0xfffffdff": "I2C_SR1_AF_RESET",
                "0x10400": "I2C_SR1_BERR",
                "4": "I2C_ERROR_BERR",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "0x21": "I2C_STATE_ADDR",
                "hi2c->Mode": "handle->Mode",
                "hi2c->XferCount": "handle->XferCount",
                "hi2c->PreviousState": "handle->PreviousState",
                "I2C_Slave_AF": "I2C_Slave_AF",
                "8": "I2C_ERROR_OVR",
                "0xfffff7ff": "I2C_SR1_OVR_RESET",
                "0x10800": "I2C_SR1_OVR",
                "hi2c->ErrorCode": "handle->ErrorCode",
                "I2C_ITError": "I2C_ITError"
            },
            "code": "void handle_I2C_errors_080052f0(I2C_HandleTypeDef_conflict *hi2c) {\n  HAL_I2C_StateTypeDef_conflict state;\n  I2C_TypeDef_conflict *instance;\n  uint SR1;\n  uint CR2;\n  instance = hi2c->Instance;\n  SR1 = instance->SR1;\n  CR2 = instance->CR2;\n  if (((SR1 & DAT_080053c8) != 0) && ((CR2 & I2C_CR2_AUTOEND) != 0)) {\n    hi2c->ErrorCode |= I2C_ERROR_ARLO;\n    instance->SR1 = DAT_080053c8_RESET;\n    instance->CR1 |= I2C_CR1_STOP;\n  }\n  if (((SR1 & I2C_SR1_AF) != 0) && ((CR2 & I2C_CR2_AUTOEND) != 0)) {\n    hi2c->ErrorCode |= I2C_ERROR_AF;\n    instance->SR1 = I2C_SR1_AF_RESET;\n  }\n  if (((SR1 & I2C_SR1_BERR) != 0) && ((CR2 & I2C_CR2_AUTOEND) != 0)) {\n    state = hi2c->State;\n    if (((hi2c->Mode == HAL_I2C_MODE_SLAVE) && (hi2c->XferCount == 0)) && (((state == HAL_I2C_STATE_BUSY_TX) || (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((state == HAL_I2C_STATE_LISTEN) && (hi2c->PreviousState == I2C_STATE_ADDR)))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c->ErrorCode |= I2C_ERROR_BERR;\n      if (hi2c->Mode == HAL_I2C_MODE_MASTER) {\n        instance->CR1 |= I2C_CR1_START;\n      }\n      instance->SR1 = I2C_SR1_BERR_RESET;\n    }\n  }\n  if (((SR1 & I2C_SR1_OVR) != 0) && ((CR2 & I2C_CR2_AUTOEND) != 0)) {\n    hi2c->ErrorCode |= I2C_ERROR_OVR;\n    instance->SR1 = I2C_SR1_OVR_RESET;\n  }\n  if (hi2c->ErrorCode != 0) {\n    I2C_ITError(hi2c);\n  }\n}\n",
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052f0",
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_errors_080052f0"
        },
        "FUN_08002f2c": {
            "renaming": {
                "FUN_08002f2c": "updateCallbackFunction_08002f2c",
                "this": "firmataObject",
                "command": "commandByte",
                "newFunction": "newCallbackFunction",
                "PTR_currentReportDigitalCallback_08002f78": "currentReportDigitalCallback",
                "PTR_currentPinModeCallback_08002f7c": "currentPinModeCallback",
                "PTR_currentPinValueCallback_08002f80": "currentPinValueCallback",
                "PTR_currentAnalogCallback_08002f6c": "currentAnalogCallback",
                "PTR_currentDigitalCallback_08002f74": "currentDigitalCallback",
                "PTR_currentReportAnalogCallback_08002f70": "currentReportAnalogCallback"
            },
            "code": "void __thiscall firmata::FirmataClass::updateCallbackFunction_08002f2c(FirmataClass *this, uint8_t command, callbackFunction newFunction) {\n  if (command == DIGITAL_MESSAGE) {\n    *(callbackFunction *)PTR_currentReportDigitalCallback_08002f78 = newFunction;\n    return;\n  }\n  if (command == REPORT_ANALOG) {\n    *(callbackFunction *)PTR_currentReportAnalogCallback_08002f70 = newFunction;\n    return;\n  }\n  if (command == ANALOG_MESSAGE) {\n    *(callbackFunction *)PTR_currentAnalogCallback_08002f6c = newFunction;\n    return;\n  }\n  if (command == REPORT_DIGITAL) {\n    *(callbackFunction *)PTR_currentDigitalCallback_08002f74 = newFunction;\n    return;\n  }\n  if (command == SET_PIN_MODE) {\n    *(callbackFunction *)PTR_currentPinModeCallback_08002f7c = newFunction;\n    return;\n  }\n  if (command == SET_DIGITAL_PIN_VALUE) {\n    *(callbackFunction *)PTR_currentPinValueCallback_08002f80 = newFunction;\n    return;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f2c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "updateCallbackFunction_08002f2c"
        },
        "FUN_08004954": {
            "renaming": {
                "FUN_08004954": "i2c_listen_08004954",
                "hi2c": "i2c_handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "xfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "tmp_reg"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_listen_08004954(I2C_HandleTypeDef_conflict *i2c_handle, uint8_t *data, uint16_t size, uint32_t xfer_options) {\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t tmp_reg;\n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    } else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 |= 1;\n      }\n      i2c_handle->Instance->CR1 &= 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = xfer_options;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 |= 0x700;\n    }\n  } else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004954",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_08004954"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configure_timer_08005cec",
                "TIMx": "timer",
                "OC_Config": "output_config",
                "uVar1": "cc_enabled_polarity",
                "uVar2": "cr2",
                "uVar3": "output_mode",
                "DAT_08005d44": "PTR_08005d44",
                "CCER": "cc_enabled",
                "OCMode": "output_mode",
                "OCPolarity": "output_polarity",
                "OCNPolarity": "output_n_polarity",
                "CR2": "cr2",
                "OCIdleState": "output_idle_state",
                "OCNIdleState": "output_n_idle_state",
                "CCMR1": "cc_mode_register",
                "CCR1": "cc_register"
            },
            "code": "void configure_timer_08005cec(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_config) {\\n\\\n    uint32_t cc_enabled = timer->CCER & 0xfffffffe;\\n\\\n    uint32_t cr2 = timer->CR2;\\n\\\n    uint output_mode = output_config->OCMode;\\n\\\n    uint32_t cc_enabled_polarity = (timer->CCER & 0xfffffffd) | output_config->OCPolarity;\\n\\\n    if (timer == DAT_08005d44) {\\n\\\n        cc_enabled_polarity = (cc_enabled_polarity & 0xfffffff7 | output_config->OCNPolarity) & 0xfffffffb;\\n\\\n        cr2 = (cr2 & 0xfffffcff) | output_config->OCIdleState | output_config->OCNIdleState;\\n\\\n    }\\n\\\n    timer->CR2 = cr2;\\n\\\n    timer->CCMR1 = (timer->CCMR1 & 0xffffff8c) | output_mode;\\n\\\n    timer->CCR1 = output_config->Pulse;\\n\\\n    timer->CCER = cc_enabled_polarity;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005cec"
        },
        "FUN_08003748": {
            "renaming": {
                "FUN_08003748": "update_tick_count_08003748",
                "PTR_uwTick_08003758": "tick_count_ptr",
                "PTR_uwTickFreq_0800375c": "tick_freq_ptr",
                "uint": "uint32_t",
                "byte": "uint8_t",
                "*(uint *)PTR_uwTick_08003758": "*tick_count_ptr",
                "*(int *)PTR_uwTick_08003758": "*(int *)tick_count_ptr"
            },
            "code": "void update_tick_count_08003748(void)\n{\n  uint8_t tick_freq = *PTR_uwTickFreq_0800375c;\n  uint32_t* PTR_uwTick_08003758 = (uint32_t*)PTR_uwTick_08003758;\n  *(uint *)PTR_uwTick_08003758 += tick_freq;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003748",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_tick_count_08003748"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "configure_GPIO_080040e8",
                "GPIOx": "GPIO",
                "GPIO_Init": "init",
                "pGVar1": "GPIO",
                "uVar2": "speed_value",
                "uVar3": "pin_mask",
                "uVar4": "pin_mask",
                "uVar5": "i",
                "uVar6": "mode_value",
                "uVar7": "pull_value",
                "iVar8": "pin_index",
                "iVar10": "port_index",
                "tmpreg": "tmp_reg",
                "DAT_080042bc": "EXTI",
                "DAT_080042c0": "SYSCFG",
                "DAT_080042c4": "EXTI",
                "DAT_080042c8": "GPIO_MODE_ANALOG",
                "DAT_080042cc": "GPIO_MODE_INPUT_ANALOG",
                "DAT_080042d0": "GPIOA",
                "BSRR": "bsrr_val",
                "BRR": "brr_val",
                "CRL": "crl_val",
                "CRH": "crh_val",
                "Pin": "init->Pin",
                "Mode": "init->Mode",
                "Speed": "init->Speed",
                "Pull": "init->Pull",
                "GPIO_SPEED_FREQ_HIGH": "GPIO_SPEED_FREQ_HIGH",
                "GPIO_SPEED_FREQ_LOW": "GPIO_SPEED_FREQ_LOW",
                "GPIO_NOPULL": "GPIO_NOPULL",
                "GPIO_PULLUP": "GPIO_PULLUP",
                "GPIO_PULLDOWN": "GPIO_PULLDOWN",
                "GPIO_MODE_OUTPUT_50_MHZ": "GPIO_MODE_OUTPUT_50_MHZ",
                "GPIO_MODE_OUTPUT_PP": "GPIO_MODE_OUTPUT_PP",
                "GPIO_MODE_INPUT_PULLUP": "GPIO_MODE_INPUT_PULLUP",
                "GPIO_MODE_INPUT_PULLDOWN": "GPIO_MODE_INPUT_PULLDOWN",
                "GPIO_MODE_ANALOG": "GPIO_MODE_ANALOG",
                "GPIO_MODE_IT": "GPIO_MODE_IT",
                "GPIO_MODE_EVT": "GPIO_MODE_EVT",
                "GPIO_MODE_IT_FALLING": "GPIO_MODE_IT_FALLING",
                "GPIO_MODE_IT_RISING": "GPIO_MODE_IT_RISING"
            },
            "code": "void configure_GPIO_080040e8(GPIO_TypeDef *GPIO, GPIO_InitTypeDef *init)\n{\n    uint32_t pin_mask;\n    uint32_t speed_value;\n    uint32_t mode_value;\n    uint32_t pull_value;\n    uint32_t crl_val;\n    uint32_t crh_val;\n    uint32_t bsrr_val;\n    uint32_t brr_val;\n\n    for (uint32_t i = 0; i <= 15; i++) {\n        pin_mask = (1 << i);\n        if (pin_mask & init->Pin) {\n            mode_value = init->Mode;\n            if (mode_value == GPIO_MODE_OUTPUT_50_MHZ) {\n                speed_value = GPIO_SPEED_FREQ_HIGH;\n            }\n            else if (mode_value < DAT_080042c8) {\n                if (mode_value == GPIO_MODE_OUTPUT_PP) {\n                    speed_value = GPIO_SPEED_FREQ_LOW;\n                }\n                else if (mode_value == GPIO_MODE_INPUT_PULLUP) {\n                    pull_value = GPIO_PULLUP;\n                    bsrr_val = pin_mask;\n                }\n                else if (mode_value == GPIO_MODE_INPUT_PULLDOWN) {\n                    pull_value = GPIO_PULLDOWN;\n                    brr_val = pin_mask;\n                }\n                else {\n                    pull_value = GPIO_NOPULL;\n                }\n                crl_val = GPIO->CRL;\n                crh_val = GPIO->CRH;\n                if (i < 8) {\n                    crl_val &= ~(0x0F << (i * 4));\n                    crl_val |= (speed_value << (i * 4));\n                    GPIO->CRL = crl_val;\n                }\n                else {\n                    crh_val &= ~(0x0F << ((i - 8) * 4));\n                    crh_val |= (speed_value << ((i - 8) * 4));\n                    GPIO->CRH = crh_val;\n                }\n                if (init->Mode & GPIO_MODE_IT) {\n                    DAT_080042bc->IMR |= pin_mask;\n                    uint32_t port_index = (uint32_t)(GPIO - DAT_080042d0) / sizeof(GPIO_TypeDef);\n                    uint32_t pin_index = i % 4;\n                    uint32_t shift = pin_index * 4;\n                    DAT_080042c0->DAT_080042bcCR[i / 4] &= ~(0x0F << shift);\n                    DAT_080042c0->DAT_080042bcCR[i / 4] |= (port_index << shift);\n                    if (init->Mode & GPIO_MODE_EVT) {\n                        DAT_080042bc->EMR |= pin_mask;\n                    }\n                    if (init->Mode & GPIO_MODE_IT_FALLING) {\n                        DAT_080042bc->FTSR |= pin_mask;\n                    }\n                    if (init->Mode & GPIO_MODE_IT_RISING) {\n                        DAT_080042bc->RTSR |= pin_mask;\n                    }\n                }\n            }\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configure_GPIO_080040e8"
        },
        "FUN_08009b6c": {
            "renaming": {
                "FUN_08009b6c": "process_data_08009b6c",
                "param_1": "data",
                "param_2": "info",
                "iVar1": "offset",
                "piVar2": "data_ptr",
                "uVar3": "data_val",
                "uVar4": "data_size",
                "iVar5": "block_size",
                "pcVar6": "func_ptr",
                "iVar7": "data_offset",
                "uVar8": "orig_data_val",
                "bVar9": "is_negative"
            },
            "code": "uint32_t process_data_08009b6c(uint32_t *data, int *info) {\n  int data_size = (int)(*(uint16_t *)(info + 3));\n  uint32_t data_val = (uint32_t)data_size;\n  bool is_negative = ((data_val << 0x1c) < 0);\n  \n  if (is_negative) {\n    int offset = info[4];\n    if (offset != 0) {\n      int block_size = data_val << 0x1e;\n      bool is_block_size_zero = (block_size == 0);\n      if (is_block_size_zero) {\n        block_size = 0;\n      }\n      int data_offset = *info;\n      if (!is_block_size_zero) {\n        data_offset = info[5];\n      }\n      *info = offset;\n      info[2] = data_offset;\n      for (data_offset = data_offset - offset; data_offset > 0; data_offset = data_offset - data_offset) {\n        data_offset = (*(code *)info[10])(data, info[8], offset, data_offset);\n        if (data_offset < 1) {\n          data_size = (int)(*(uint16_t *)(info + 3));\n          goto LAB_08009c62;\n        }\n        offset = offset + data_offset;\n      }\n    }\n  }\n  else {\n    bool has_data = ((info[1] > 0) || (info[0x10] > 0));\n    code *func_ptr = (code *)info[0xb];\n    if (has_data && (func_ptr != (code *)0x0)) {\n      uint32_t orig_data_val = *data;\n      *data = 0;\n      if ((data_val & 0x1000) == 0) {\n        int block_size = (*func_ptr)(data, info[8], data_val & 0x1000, 1);\n        if ((block_size == -1) && (*data != 0)) {\n          if ((*data != 0x1d) && (*data != 0x16)) {\n            *(uint16_t *)(info + 3) = *(uint16_t *)(info + 3) | 0x40;\n            return 0xffffffff;\n          }\n          *data = orig_data_val;\n          return 0;\n        }\n      }\n      else {\n        int block_size = info[0x15];\n      }\n      if (((int)((uint)*(uint16_t *)(info + 3) << 0x1d) < 0) && (info[0xd] != 0)) {\n        block_size = block_size - info[1];\n        if (info[0xd] != (int *)(info + 0x11)) {\n          _free_r(data);\n        }\n        info[0xd] = 0;\n        return 0;\n      }\n      block_size = (*(code *)info[0xb])(data, info[8], block_size, 0);\n      data_size = (int)(*(uint16_t *)(info + 3));\n      if ((block_size == -1) && ((0x1d < *data) || (-1 < (int)((DAT_08009c78 >> (*data & 0xff)) << 0x1f))))) {\n        *(uint16_t *)(info + 3) = *(uint16_t *)(info + 3) | 0x40;\n        return 0xffffffff;\n      }\n      info[1] = 0;\n      *info = info[4];\n      if (((int)((uint)data_size << 0x13) < 0) && ((block_size != -1) || (*data == 0))) {\n        info[0x15] = block_size;\n      }\n      int *data_ptr = (int *)info[0xd];\n      *data = orig_data_val;\n      if (data_ptr != 0x0) {\n        if (data_ptr != info + 0x11) {\n          _free_r(data);\n        }\n        info[0xd] = 0;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b6c",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_08009b6c"
        },
        "FUN_0800288c": {
            "renaming": {
                "FUN_0800288c": "transmitData_0800288c",
                "this": "wire",
                "data": "dataByte",
                "puVar1": "txBuffer",
                "iVar2": "status",
                "pvVar3": "newBuffer",
                "sVar4": "result",
                "cVar5": "newIndex",
                "uVar6": "newSize",
                "__size": "newLength",
                "local_11": "localData",
                "*PTR_transmitting_08002908": "transmitting",
                "*PTR_txBuffer_08002914": "txBuffer",
                "*PTR_txBufferLength_0800290c": "txBufferLength",
                "*PTR_txBufferAllocated_08002910": "txBufferAllocated",
                "*PTR_txBufferIndex_08002918": "txBufferIndex",
                "(this->super_Stream).super_Print.FUN_0800288c_error": "(this->super_Stream).super_Print.isError"
            },
            "code": "size_t __thiscall TwoWire::transmitData_0800288c(TwoWire *this, uint8_t data) {\\n\\\n    uint8_t localData = data;\\n\\\n    undefined **PTR_txBuffer_08002914 = PTR_*PTR_txBuffer_08002914_08002914;\\n\\\n    uint8_t **PTR_transmitting_08002908 = PTR_*PTR_transmitting_08002908_08002908;\\n\\\n    size_t result = 0;\\n\\\n    if (**PTR_transmitting_08002908 == \"\\0\") {\\n\\\n        i2c_status_e_conflict status = i2c_slave_transmitData_0800288c_IT((i2c_t_conflict *)&this->_i2c, &localData, 1);\\n\\\n        result = (status == I2C_OK) ? 1 : 0;\\n\\\n    }\\n\\\n    else {\\n\\\n        size_t newSize = (size_t)*PTR_*PTR_*PTR_txBuffer_08002914Length_0800290c_0800290c + 1;\\n\\\n        if ((size_t)*PTR_*PTR_*PTR_txBuffer_08002914Allocated_08002910_08002910 < newSize) {\\n\\\n            if (newSize < 0x20) {\\n\\\n                newSize = 0x20;\\n\\\n            }\\n\\\n            void *newBuffer = realloc(*(void **)*PTR_txBuffer_08002914, newSize);\\n\\\n            **PTR_txBuffer_08002914 = newBuffer;\\n\\\n            *PTR_*PTR_*PTR_txBuffer_08002914Allocated_08002910_08002910 = (undefined)newSize;\\n\\\n        }\\n\\\n        undefined **PTR_*PTR_txBuffer_08002914Index_08002918 = PTR_*PTR_*PTR_txBuffer_08002914Index_08002918_08002918;\\n\\\n        if (*(int *)*PTR_txBuffer_08002914 == 0) {\\n\\\n            (this->super_Stream).super_Print.isError = 1;\\n\\\n            result = 0;\\n\\\n        }\\n\\\n        else {\\n\\\n            *(uint8_t *)(*(int *)*PTR_txBuffer_08002914 + (uint)(size_t)**PTR_*PTR_txBuffer_08002914Index_08002918) = localData;\\n\\\n            char newIndex = **PTR_*PTR_txBuffer_08002914Index_08002918 + \"\\x01\";\\n\\\n            **PTR_*PTR_txBuffer_08002914Index_08002918 = newIndex;\\n\\\n            *PTR_*PTR_*PTR_txBuffer_08002914Length_0800290c_0800290c = newIndex;\\n\\\n            result = 1;\\n\\\n        }\\n\\\n    }\\n\\\n    return result;\\n\\\n    }",
            "called": [
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800288c",
            "calling": [
                "wireWrite"
            ],
            "imported": false,
            "current_name": "transmitData_0800288c"
        },
        "FUN_08002e26": {
            "renaming": {
                "FUN_08002e26": "initialize_08002e26",
                "s": "serial_stream",
                "this": "firmata_instance"
            },
            "code": "void __thiscall firmata::FirmataClass::initialize_08002e26(FirmataClass *firmata_instance,Stream *serial_stream)\n{\n  firmata_instance->FirmataStream = serial_stream;\n  FirmataMarshaller::initialize_08002e26(&firmata_instance->marshaller, serial_stream);\n  printVersion(firmata_instance);\n  printFirmwareVersion(firmata_instance);\n  return;\n}",
            "called": [
                "printVersion",
                "begin",
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e26",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_08002e26"
        },
        "FUN_0800010c": {
            "renaming": {
                "FUN_0800010c": "has_completed_init_0800010c",
                "param_1": "init_data",
                "PTR_completed_8667_08000124": "completed",
                "DAT_08000128": "init_ptr"
            },
            "code": "bool has_completed_init_0800010c(bool *PTR_completed_8667_08000124, int *DAT_08000128, void *init_data) {\n  if (*PTR_completed_8667_08000124 == false) {\n    if (*DAT_08000128 != 0) {\n      init_data = DAT_08000128;\n    }\n    *PTR_completed_8667_08000124 = true;\n  }\n  return init_data;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800010c",
            "calling": [],
            "imported": false,
            "current_name": "has_completed_init_0800010c"
        },
        "FUN_080086e8": {
            "renaming": {
                "FUN_080086e8": "get_uart_handler_index_080086e8",
                "huart": "uart_handler",
                "uVar1": "index",
                "PTR_uart_handlers_08008708": "PTR_uart_handlers_08008708",
                "uint8_t": "uint8_t",
                "NULL": "NULL",
                "while( true )": "while (true)",
                "return (uint8_t)uVar1;": "return index;",
                "if (huart == (UART_HandleTypeDef *)0x0)": "if (uart_handler == NULL)",
                "if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + uVar1 * 4))": "if (uart_handler == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + index * 4))",
                "uVar1 + 1 & 0xff": "index++"
            },
            "code": "uint8_t get_uart_handler_index_080086e8(UART_HandleTypeDef *huart)\n{\n  uint8_t index;\n  if (huart == NULL) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while (true) {\n      if (index > 4) {\n        return index;\n      }\n      if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + index * 4)) {\n        break;\n      }\n      index++;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080086e8",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "get_uart_handler_index_080086e8"
        },
        "FUN_08001c18": {
            "renaming": {
                "FUN_08001c18": "read_i2c_data_08001c18",
                "address": "device_address",
                "theRegister": "register_address",
                "numBytes": "num_bytes_to_read",
                "stopTX": "stop_tx",
                "bVar1": "data_available",
                "puVar2": "i2c_data_buffer",
                "bVar3": "read_byte",
                "iVar4": "available_bytes",
                "iVar5": "i",
                "uVar6": "num_bytes",
                "PTR_Wire_08001cbc": "wire",
                "PTR_Firmata_08001cc4": "firmata",
                "PTR_s_I2C__Too_many_bytes_received_08001cc0": "too_many_bytes_received",
                "PTR_s_I2C__Too_few_bytes_received_08001ccc": "too_few_bytes_received",
                "PTR_i2cRxData_08001cc8": "i2c_data_buffer"
            },
            "code": "void read_i2c_data_08001c18(byte device_address, int register_address, byte num_bytes_to_read, byte stop_tx) {\n  bool data_available;\n  byte PTR_i2cRxData_08001cc8[32];\n  int available_bytes;\n  FirmataClass *PTR_Firmata_08001cc4 = (FirmataClass *)PTR_Firmata_08001cc4;\n  TwoWire *PTR_Wire_08001cbc = (TwoWire *)PTR_Wire_08001cbc;\n\n  if (register_address != -1) {\n    PTR_Wire_08001cbc->beginTransmission(device_address);\n    PTR_Wire_08001cbc->write(register_address);\n    PTR_Wire_08001cbc->endTransmission(stop_tx);\n  }\n\n  PTR_Wire_08001cbc->requestFrom(device_address, num_bytes_to_read);\n  available_bytes = PTR_Wire_08001cbc->available();\n\n  if ((int)num_bytes_to_read < available_bytes) {\n    PTR_Firmata_08001cc4->sendString(PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else if (available_bytes < (int)num_bytes_to_read) {\n    PTR_Firmata_08001cc4->sendString(PTR_s_I2C__Too_few_bytes_received_08001ccc);\n  }\n  else {\n    PTR_i2cRxData_08001cc8[0] = device_address;\n    PTR_i2cRxData_08001cc8[1] = (byte)register_address;\n    for (int i = 0; i < num_bytes_to_read; i++) {\n      data_available = false;\n      while (!data_available) {\n        if (PTR_Wire_08001cbc->available() == 0) {\n          data_available = false;\n        }\n        else {\n          data_available = true;\n        }\n      }\n      PTR_i2cRxData_08001cc8[i + 2] = PTR_Wire_08001cbc->read();\n    }\n    PTR_Firmata_08001cc4->sendSysex('w', num_bytes_to_read + 2, PTR_i2cRxData_08001cc8);\n  }\n}",
            "called": [
                "beginTransmission",
                "endTransmission",
                "available",
                "wireWrite",
                "wireRead",
                "sendString",
                "sendSysex",
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c18",
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "read_i2c_data_08001c18"
        },
        "FUN_08009056": {
            "renaming": {
                "FUN_08009056": "handle_gpio_exti_irq_08009056",
                "uVar1": "gpio_pin"
            },
            "code": "void handle_gpio_exti_irq_08009056(void)\n{\n  uint16_t gpio_pin = 0x20;\n  while (gpio_pin < 0x201)\n  {\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n    gpio_pin <<= 1;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009056",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_08009056"
        },
        "FUN_08002e1a": {
            "renaming": {
                "FUN_08002e1a": "printFirmwareVersionIfContextNotNull_08002e1a",
                "param_2": "paramSize",
                "param_3": "dataSize",
                "param_4": "dataPtr",
                "context": "contextPtr",
                "(void *)0x0": "nullptr"
            },
            "code": "printFirmwareVersionIfContextNotNull_08002e1avprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1adprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1afprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1amprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1a:printFirmwareVersionIfContextNotNull_08002e1a:printFirmwareVersionIfContextNotNull_08002e1aFprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1amprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1aCprintFirmwareVersionIfContextNotNull_08002e1alprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1a:printFirmwareVersionIfContextNotNull_08002e1a:printFirmwareVersionIfContextNotNull_08002e1apprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aFprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1amprintFirmwareVersionIfContextNotNull_08002e1awprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1aVprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1aIprintFirmwareVersionIfContextNotNull_08002e1afprintFirmwareVersionIfContextNotNull_08002e1aCprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1axprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aNprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aNprintFirmwareVersionIfContextNotNull_08002e1auprintFirmwareVersionIfContextNotNull_08002e1alprintFirmwareVersionIfContextNotNull_08002e1alprintFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a(printFirmwareVersionIfContextNotNull_08002e1avprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1adprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a*printFirmwareVersionIfContextNotNull_08002e1acprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1axprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aPprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1a,printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1azprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1a_printFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1apprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1amprintFirmwareVersionIfContextNotNull_08002e1aSprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1azprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1a,printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1azprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1a_printFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1adprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1aSprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1azprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1a,printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1acprintFirmwareVersionIfContextNotNull_08002e1ahprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a*printFirmwareVersionIfContextNotNull_08002e1adprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1aPprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1a)printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a{printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1afprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a(printFirmwareVersionIfContextNotNull_08002e1acprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1axprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aPprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a!printFirmwareVersionIfContextNotNull_08002e1a=printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1auprintFirmwareVersionIfContextNotNull_08002e1alprintFirmwareVersionIfContextNotNull_08002e1alprintFirmwareVersionIfContextNotNull_08002e1apprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1a)printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a{printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1apprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aFprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1amprintFirmwareVersionIfContextNotNull_08002e1awprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1aVprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1a(printFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1acprintFirmwareVersionIfContextNotNull_08002e1a_printFirmwareVersionIfContextNotNull_08002e1acprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1a<printFirmwareVersionIfContextNotNull_08002e1aFprintFirmwareVersionIfContextNotNull_08002e1aiprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1amprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1aCprintFirmwareVersionIfContextNotNull_08002e1alprintFirmwareVersionIfContextNotNull_08002e1aaprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1asprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a*printFirmwareVersionIfContextNotNull_08002e1a>printFirmwareVersionIfContextNotNull_08002e1a(printFirmwareVersionIfContextNotNull_08002e1acprintFirmwareVersionIfContextNotNull_08002e1aoprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1axprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1aPprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1a)printFirmwareVersionIfContextNotNull_08002e1a)printFirmwareVersionIfContextNotNull_08002e1a;printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1auprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1a;printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a}printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1a printFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1aeprintFirmwareVersionIfContextNotNull_08002e1atprintFirmwareVersionIfContextNotNull_08002e1auprintFirmwareVersionIfContextNotNull_08002e1arprintFirmwareVersionIfContextNotNull_08002e1anprintFirmwareVersionIfContextNotNull_08002e1a;printFirmwareVersionIfContextNotNull_08002e1a\nprintFirmwareVersionIfContextNotNull_08002e1a}printFirmwareVersionIfContextNotNull_08002e1a",
            "called": [
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e1a",
            "calling": [],
            "imported": false,
            "current_name": "printFirmwareVersionIfContextNotNull_08002e1a"
        },
        "FUN_0800904c": {
            "renaming": {
                "FUN_0800904c": "handle_GPIO_EXTI_interrupt_0800904c",
                "DAT_08003000": "GPIO_PIN_4"
            },
            "code": "void handle_GPIO_EXTI_interrupt_0800904c(void)\n{\n  uint32_t pin = DAT_08003000;\n  HAL_GPIO_EXTI_IRQHandler(pin);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800904c",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_interrupt_0800904c"
        },
        "FUN_080073ae": {
            "renaming": {
                "FUN_080073ae": "find_first_non_null_pointer_080073ae",
                "a": "ptr1",
                "b": "ptr2"
            },
            "code": "void * find_first_non_null_pointer_080073ae(void *ptr1, void *ptr2)\n{\n  if (ptr1 != ptr2) {\n    if (ptr1 == NULL) {\n      return ptr2;\n    }\n    if (ptr2 == NULL) {\n      return ptr1;\n    }\n    ptr1 = NULL;\n  }\n  return ptr1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ae",
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_first_non_null_pointer_080073ae"
        },
        "FUN_08003f0c": {
            "renaming": {
                "FUN_08003f0c": "set_priority_group_08003f0c",
                "PriorityGroup": "priority_group",
                "DAT_08003f2c": "priority_reg",
                "*PTR_DAT_08003f2c": "current_value",
                "PTR_DAT_08003f2c": "new_value"
            },
            "code": "void set_priority_group_08003f0c(uint32_t priority_group) {\n    uint32_t* DAT_08003f2c = (uint32_t*)(DAT_08003f2c + 0xc);\n    uint32_t *PTR_DAT_08003f2c = *DAT_08003f2c;\n    uint32_t PTR_DAT_08003f2c = (priority_group & 7) << 8 | (*PTR_DAT_08003f2c & 0xf8ff) | 0x5fa0000;\n    *DAT_08003f2c = PTR_DAT_08003f2c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0c",
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "imported": false,
            "current_name": "set_priority_group_08003f0c"
        },
        "FUN_08000488": {
            "renaming": {
                "FUN_08000488": "reportAnalogInput_08000488",
                "analogPin": "analog_pin",
                "value": "value",
                "ulPin": "pin_number",
                "value_00": "analog_value",
                "PTR_analogInputsToReport_080004c8": "analog_inputs_to_report",
                "PTR_isResetting_080004cc": "is_resetting",
                "analogRead": "analogRead",
                "PTR_Firmata_080004d0": "firmata_instance",
                "FirmataClass": "firmata::FirmataClass"
            },
            "code": "void reportAnalogInput_08000488(byte analog_pin, int value) {\\n  uint pin_number;\\n  uint32_t analog_value;\\n  pin_number = (uint)analog_pin;\\n  if (pin_number < 0xe) {\\n    if (value == 0) {\\n      *(uint *)PTR_analogInputsToReport_080004c8 = *(uint *)PTR_analogInputsToReport_080004c8 & ~(1 << pin_number);\\n      return;\\n    }\\n    *(uint *)PTR_analogInputsToReport_080004c8 = 1 << pin_number | *(uint *)PTR_analogInputsToReport_080004c8;\\n    if (*PTR_isResetting_080004cc == \"\\0\") {\\n      analog_value = analogRead(pin_number);\\n      firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080004d0, analog_pin, analog_value);\\n      return;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "sendAnalog",
                "analogRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000488",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "reportAnalogInput_08000488"
        },
        "FUN_08006bb8": {
            "renaming": {
                "FUN_08006bb8": "get_GPIO_Port_08006bb8",
                "port_idx": "port_index",
                "pGVar1": "port",
                "tmpreg": "gpio_reg",
                "tmpreg_1": "gpio_reg_1",
                "tmpreg_2": "gpio_reg_2",
                "tmpreg_3": "gpio_reg_3",
                "tmpreg_4": "gpio_reg_4"
            },
            "code": "GPIO_TypeDef * get_GPIO_Port_08006bb8(uint32_t port_index)\n{\n  GPIO_TypeDef *port;\n  uint32_t gpio_reg;\n\n  switch(port_index) {\n    case 0:\n      gpio_reg = *(uint *)(DAT_08006c48 + 0x18);\n      gpio_reg |= 4;\n      *(uint *)(DAT_08006c48 + 0x18) = gpio_reg;\n      port = DAT_08006c4c;\n      break;\n    case 1:\n      gpio_reg = *(uint *)(DAT_08006c48 + 0x18);\n      gpio_reg |= 8;\n      *(uint *)(DAT_08006c48 + 0x18) = gpio_reg;\n      port = DAT_08006c50;\n      break;\n    case 2:\n      gpio_reg = *(uint *)(DAT_08006c48 + 0x18);\n      gpio_reg |= 0x10;\n      *(uint *)(DAT_08006c48 + 0x18) = gpio_reg;\n      port = DAT_08006c54;\n      break;\n    case 3:\n      gpio_reg = *(uint *)(DAT_08006c48 + 0x18);\n      gpio_reg |= 0x20;\n      *(uint *)(DAT_08006c48 + 0x18) = gpio_reg;\n      port = DAT_08006c58;\n      break;\n    case 4:\n      gpio_reg = *(uint *)(DAT_08006c48 + 0x18);\n      gpio_reg |= 0x40;\n      *(uint *)(DAT_08006c48 + 0x18) = gpio_reg;\n      port = DAT_08006c5c;\n      break;\n    default:\n      port = (GPIO_TypeDef *)0x0;\n  }\n  return port;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006bb8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_Port_08006bb8"
        },
        "FUN_08004aec": {
            "renaming": {
                "FUN_08004aec": "handle_i2c_events_08004aec",
                "*hi2c": "*i2c_handle",
                "XferOptions": "transfer_options",
                "State": "state",
                "Instance": "i2c_instance",
                "CR2": "i2c_cr2",
                "SR1": "i2c_sr1",
                "CR1": "i2c_cr1",
                "PreviousState": "previous_state",
                "Mode": "mode",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_ListenCpltCallback": "handle_i2c_listen_complete",
                "HAL_I2C_SlaveTxCpltCallback": "handle_i2c_slave_tx_complete"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_events_08004aec(I2C_HandleTypeDef_conflict *hi2c) {\n    if (((hi2c->transfer_options == 4) || (hi2c->transfer_options == 8)) && (hi2c->state == HAL_I2C_STATE_LISTEN)) {\n        hi2c->transfer_options = DAT_08004b7c;\n        hi2c->Instance->CR2 &= 0xfffff8ff;\n        hi2c->Instance->SR1 = 0xfffffbff;\n        hi2c->Instance->CR1 &= 0xfffffbff;\n        hi2c->previous_state = 0;\n        hi2c->state = HAL_I2C_STATE_READY;\n        hi2c->mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if (hi2c->state == HAL_I2C_STATE_BUSY_TX) {\n        hi2c->transfer_options = DAT_08004b7c;\n        hi2c->previous_state = 0x21;\n        hi2c->state = HAL_I2C_STATE_READY;\n        hi2c->mode = HAL_I2C_MODE_NONE;\n        hi2c->Instance->CR2 &= 0xfffff8ff;\n        hi2c->Instance->SR1 = 0xfffffbff;\n        hi2c->Instance->CR1 &= 0xfffffbff;\n        HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    else {\n        hi2c->Instance->SR1 = 0xfffffbff;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004aec",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_events_08004aec"
        },
        "FUN_08007ede": {
            "renaming": {
                "FUN_08007ede": "transferData_08007ede",
                "obj": "i2c_obj",
                "data": "data",
                "size": "size",
                "uVar1": "index",
                "i2cTxRxBuffer": "i2c_obj->i2cTxRxBuffer",
                "i2cTxRxBufferSize": "i2c_obj->i2cTxRxBufferSize",
                "I2C_ERROR": "I2C_ERROR",
                "I2C_OK": "I2C_OK"
            },
            "code": "i2c_status_e transferData_08007ede(i2c_t_conflict *i2c_obj, uint8_t *data, uint16_t size)\n{\n  uint16_t index;\n\n  if (size > 0x20) {\n    return I2C_ERROR;\n  }\n\n  for (index = 0; index < size; index++) {\n    i2c_obj->i2cTxRxBuffer[index] = data[index];\n    i2c_obj->i2cTxRxBufferSize++;\n  }\n\n  return I2C_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ede",
            "calling": [
                "write",
                "write"
            ],
            "imported": false,
            "current_name": "transferData_08007ede"
        },
        "FUN_08004728": {
            "renaming": {
                "FUN_08004728": "i2c_transfer_08004728",
                "hi2c": "handle",
                "DevAddress": "address",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "i2c",
                "count": "count",
                "PTR_SystemCoreClock_080047e8": "SYSCLK_FREQ",
                "DAT_080047ec": "transfer_timeout",
                "DAT_080047f0": "transfer_options"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_transfer_08004728(I2C_HandleTypeDef_conflict *handle, uint16_t address, uint8_t *data, uint16_t size) {\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c;\n  uint32_t count;\n  if (handle->State == HAL_I2C_STATE_READY) {\n    count = (uint)((ulonglong)DAT_080047ec * (ulonglong)(*(uint *)PTR_SystemCoreClock_080047e8 >> 3) >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2c = handle->Instance;\n      count--;\n    } while ((i2c->SR2 & 2) != 0);\n    if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      if ((i2c->CR1 & 1) == 0) {\n        i2c->CR1 |= 1;\n      }\n      handle->Instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_TX;\n      handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = DAT_080047f0;\n      handle->XferSize = handle->XferCount;\n      handle->Devaddress = (uint)address;\n      handle->Instance->CR1 |= 0x100;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004728",
            "calling": [
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004728"
        },
        "FUN_080074e0": {
            "renaming": {
                "FUN_080074e0": "set_timer_flags_080074e0",
                "htim": "timer",
                "Instance": "timer_instance",
                "DAT_08007534": "TIM2",
                "uint": "unsigned_int",
                "DAT_08007540": "timer_flags",
                "0x18": "TIMER_FLAG_1",
                "0x1c": "TIMER_FLAG_2",
                "TIM_TypeDef_conflict": "timer_type",
                "0x40000000": "TIMER_TYPE_2",
                "DAT_08007538": "TIM4",
                "DAT_0800753c": "TIM5"
            },
            "code": "void set_timer_flags_080074e0(TIM_HandleTypeDef_conflict *timer) {\n  if (timer->Instance == DAT_08007534) {\n    *(uint *)(DAT_08007540 + 0x18) = *(uint *)(DAT_08007540 + 0x18) & 0xfffff7ff;\n  }\n  if (timer->Instance == TIM3) {\n    *(uint *)(DAT_08007540 + 0x1c) = *(uint *)(DAT_08007540 + 0x1c) & 0xfffffffe;\n  }\n  if (timer->Instance == DAT_08007538) {\n    *(uint *)(DAT_08007540 + 0x1c) = *(uint *)(DAT_08007540 + 0x1c) & 0xfffffffd;\n  }\n  if (timer->Instance == DAT_0800753c) {\n    *(uint *)(DAT_08007540 + 0x1c) = *(uint *)(DAT_08007540 + 0x1c) & 0xfffffffb;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074e0",
            "calling": [
                "HAL_TIM_PWM_MspDeInit",
                "HAL_TIM_OC_MspDeInit"
            ],
            "imported": false,
            "current_name": "set_timer_flags_080074e0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "execute_RTC_user_callback_080073c0",
                "hrtc": "rtc_handle",
                "PTR_RTCUserCallback_080073d0": "RTC_USER_CALLBACK_PTR",
                "PTR_callbackUserData_080073d4": "RTC_CALLBACK_USER_DATA_PTR"
            },
            "code": "void execute_RTC_user_callback_080073c0(RTC_HandleTypeDef *rtc_handle) {\n  code* user_callback = *(code**)PTR_RTCUserCallback_080073d0;\n  if (user_callback != NULL) {\n    user_callback(*(uint32_t*)PTR_callbackUserData_080073d4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "execute_RTC_user_callback_080073c0"
        },
        "FUN_080084b0": {
            "renaming": {
                "FUN_080084b0": "configure_UART_debug_080084b0",
                "pin": "pin_name",
                "obj": "debug_obj",
                "PVar1": "tx_pin_name",
                "pvVar2": "peripheral",
                "PTR_digitalPin_080084f0": "digitalPin_1",
                "PTR_PinMap_UART_TX_080084f4": "PinMap_UART_TX",
                "PTR_PinMap_UART_RX_080084f8": "PinMap_UART_RX",
                "PTR_serial_debug_080084fc": "serial_debug"
            },
            "code": "void configure_UART_debug_080084b0(void)\n{\n  PinName_conflict pin_name;\n  undefined *debug_obj;\n  PinName_conflict tx_pin_name;\n  void *peripheral;\n  \n  pin_name = PTR_digitalPin_080084f0;\n  peripheral = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n  if (peripheral != (void *)0x0) {\n    tx_pin_name = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_RX_080084f8);\n    debug_obj = PTR_serial_debug_080084fc;\n    PTR_serial_debug_080084fc[0x59] = tx_pin_name;\n    debug_obj[0x58] = pin_name;\n    *(undefined4 *)(debug_obj + 0x48) = 0x2580;\n    *(undefined4 *)(debug_obj + 0x54) = 0;\n    *(undefined4 *)(debug_obj + 0x4c) = 0;\n    *(undefined4 *)(debug_obj + 0x50) = 0;\n    uart_init((serial_t *)debug_obj);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080084b0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "configure_UART_debug_080084b0"
        },
        "FUN_080095a8": {
            "renaming": {
                "FUN_080095a8": "calculate_checksum_080095a8",
                "param_1": "starting_value",
                "param_2": "data",
                "param_3": "data_length",
                "param_4": "constant",
                "param_5": "algorithm",
                "uVar2": "i",
                "uVar3": "additional_length",
                "bVar4": "is_four",
                "iVar1": "status"
            },
            "code": "int calculate_checksum_080095a8(uint32_t starting_value, uint32_t *data, uint32_t *data_length, uint32_t constant, checksum_algorithm *algorithm) {\\n  int result = 0;\\n  uint32_t max_length = data[4];\\n  if (max_length < data[2]) {\\n    max_length = data[2];\\n  }\\n  *data_length = max_length;\\n  if (*(char *)((int)data + 0x43) != \"\\0\") {\\n    *data_length = max_length + 1;\\n  }\\n  if ((int)(*data << 0x1a) < 0) {\\n    *data_length = *data_length + 2;\\n  }\\n  uint32_t i = *data & 6;\\n  if (i == 0) {\\n    for (; (int)i < (int)(data[3] - *data_length); i = i + 1) {\\n      int status = (*algorithm)(starting_value, constant, (int)data + 0x19, 1);\\n      if (status == -1) {\\n        return -1;\\n      }\\n    }\\n  }\\n  uint32_t additional_length = (*(byte *)((int)data + 0x43) != 0) ? 1 : 0;\\n  uint32_t offset = additional_length;\\n  if ((int)(*data << 0x1a) < 0) {\\n    *(undefined *)((int)data + additional_length + 0x43) = 0x30;\\n    offset = additional_length + 2;\\n    *(undefined *)((int)data + additional_length + 0x44) = *(undefined *)((int)data + 0x45);\\n  }\\n  int status = (*algorithm)(starting_value, constant, (int)data + 0x43, offset);\\n  if (status != -1) {\\n    uint32_t length = data[3];\\n    bool is_four = ((*data & 6) != 4);\\n    if (is_four) {\\n      length = 0;\\n    }\\n    uint32_t difference = 0;\\n    if (!is_four) {\\n      length = length - *data_length;\\n    }\\n    if (!is_four) {\\n      length = length & ~((int)length >> 0x1f);\\n    }\\n    if (max_length < data[2]) {\\n      difference = length + (data[2] - data[4]);\\n    } else {\\n      difference = length;\\n    }\\n    while (difference > 0) {\\n      status = (*algorithm)(starting_value, constant, (int)data + 0x1a, 1);\\n      if (status == -1) {\\n        return -1;\\n      }\\n      difference--;\\n    }\\n    result = 0;\\n  } else {\\n    result = -1;\\n  }\\n  return result;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095a8",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "calculate_checksum_080095a8"
        },
        "FUN_08008b2a": {
            "renaming": {
                "FUN_08008b2a": "readByte_08008b2a",
                "__thiscall HardwareSerial *this": "HardwareSerial *serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "byte bVar1": "byte byteRead",
                "ushort uVar2": "ushort rxTail"
            },
            "code": "ssize_t __thiscall HardwareSerial::readByte_08008b2a(HardwareSerial *serial, int fileDescriptor, void *buffer, size_t numBytes) {\n  byte byteRead;\n  ushort rxTail = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)rxTail) {\n    byteRead = (serial->_serial).rx_buff[rxTail];\n    (serial->_serial).rx_tail = (rxTail + 1) & 0x3f;\n    return (uint)byteRead;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b2a",
            "calling": [],
            "imported": false,
            "current_name": "readByte_08008b2a"
        },
        "FUN_08003bd8": {
            "renaming": {
                "FUN_08003bd8": "configureADC_08003bd8",
                "*hadc": "*adc",
                "HVar1": "status",
                "uVar2": "config2",
                "uVar3": "config1",
                "uVar4": "stateFlag",
                "uVar5": "continuousConvMode",
                "DAT_08003ce0": "0xffc0ffff",
                "DAT_08003ce4": "0xffc01fff"
            },
            "code": "HAL_StatusTypeDef_conflict configureADC_08003bd8(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t stateFlag;\n  uint32_t config1 = 0;\n  uint32_t config2 = 0;\n  uint32_t sqr1 = 0;\n  uint32_t continuousConvMode;\n  uint32_t nbrOfDiscConversion;\n\n  if (adc == NULL) {\n    return HAL_ERROR;\n  }\n\n  if (adc->State == 0) {\n    adc->ErrorCode = 0;\n    adc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc);\n  }\n\n  status = ADC_ConversionStop_Disable(adc);\n  stateFlag = adc->State & 0x10;\n\n  if ((stateFlag == 0) && (status == HAL_OK)) {\n    adc->State = adc->State & 0xffffeefd | 2;\n    continuousConvMode = (adc->Init).ContinuousConvMode;\n    config1 |= (adc->Init).DataAlign | (adc->Init).ExternalTrigConv | continuousConvMode << 1;\n\n    if ((adc->Init).ScanConvMode == 0x100 || (adc->Init).ScanConvMode == 1) {\n      config1 |= 0x100;\n    }\n\n    if ((adc->Init).DiscontinuousConvMode == 1) {\n      nbrOfDiscConversion = (adc->Init).NbrOfDiscConversion;\n\n      if (continuousConvMode == 0) {\n        config1 |= (nbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adc->State |= 0x20;\n        adc->ErrorCode |= 1;\n      }\n    }\n\n    adc->Instance->CR1 = config1 | adc->Instance->CR1 & 0xffff16ff;\n    config2 = (adc->Init).ExternalTrigConvEdge;\n    config2 <<= 14;\n    config2 |= (adc->Init).ExternalTrigConv;\n\n    if ((adc->Init).DMAContinuousRequests == ENABLE) {\n      config2 |= 0x200000;\n    }\n\n    adc->Instance->CR2 = config2 | adc->Instance->CR2 & DAT_08003ce0;\n\n    if (config1 != (adc->Instance->CR1 & DAT_08003ce4)) {\n      adc->State = adc->State & 0xffffffed | 0x10;\n      adc->ErrorCode |= 1;\n      return HAL_ERROR;\n    }\n\n    adc->ErrorCode = 0;\n    adc->State = adc->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n\n  adc->State |= 0x10;\n  return HAL_ERROR;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003bd8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configureADC_08003bd8"
        },
        "FUN_08009d50": {
            "renaming": {
                "FUN_08009d50": "initialize_data_08009d50",
                "param_1": "data_ptr",
                "uVar1": "float_val",
                "iVar2": "global_ptr",
                "bVar3": "is_global_ptr"
            },
            "code": "void initialize_data_08009d50(int data_ptr)\n{\n    // Check if data has already been initialized\n    if (*(int *)(data_ptr + 0x18) != 0) {\n        return;\n    }\n\n    // Initialize data\n    *(int *)(data_ptr + 0x48) = 0;\n    *(int *)(data_ptr + 0x4c) = 0;\n    *(int *)(data_ptr + 0x50) = 0;\n    int global_ptr = *(int *)PTR__global_impure_ptr_08009da8;\n    *(int *)(data_ptr + 0x28) = DAT_08009dac;\n    bool is_global_ptr = (data_ptr == global_ptr);\n    if (is_global_ptr) {\n        global_ptr = 1;\n    }\n    if (is_global_ptr) {\n        *(int *)(data_ptr + 0x18) = global_ptr;\n    }\n    // Call functions to set data\n    float f1 = __sfp();\n    *(float *)(data_ptr + 4) = f1;\n    float f2 = __sfp(data_ptr);\n    *(float *)(data_ptr + 8) = f2;\n    float f3 = __sfp(data_ptr);\n    *(float *)(data_ptr + 0xc) = f3;\n    std_isra_0(*(float *)(data_ptr + 4), 4, 0);\n    std_isra_0(*(float *)(data_ptr + 8), 9, 1);\n    std_isra_0(*(float *)(data_ptr + 0xc), 0x12, 2);\n    *(int *)(data_ptr + 0x18) = 1;\n}",
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d50",
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "_vfiprintf_r",
                "__swsetup_r",
                "__sfp",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_data_08009d50"
        },
        "FUN_08009108": {
            "renaming": {
                "FUN_08009108": "get_result_08009108",
                "param_1": "param1",
                "param_2": "param2",
                "DAT_08009120": "global_variable"
            },
            "code": "unsigned long long get_result_08009108(uint32_t param1, uint32_t param2)\n{\n  if (DAT_08009120 != 0) {\n    return ((unsigned long long)param1 << 32) | 2;\n  }\n  return (unsigned long long)param2 << 32;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009108",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "get_result_08009108"
        },
        "FUN_08009f98": {
            "renaming": {
                "FUN_08009f98": "execute_function_08009f98",
                "param_1": "output",
                "param_2": "input_index",
                "param_3": "error_code",
                "param_4": "signal",
                "_Var1": "pid",
                "uVar2": "result",
                "iVar3": "function_ptr",
                "pcVar4": "function"
            },
            "code": "int execute_function_08009f98(int* output, uint input_index, int error_code, int signal) {\n  pid_t pid;\n  int result;\n  int function_ptr;\n  \n  if (input_index > 31) {\n    *output = 22;\n    return -1;\n  }\n  \n  function_ptr = output[17];\n  \n  if (function_ptr && function_ptr + input_index*4) {\n    code* function = *(code**)(function_ptr + input_index*4);\n    \n    if (function != (code*)1) {\n      if (function == (code*)-1) {\n        *output = 22;\n        return 1;\n      }\n      *(int*)(function_ptr + input_index*4) = 0;\n      (*function)(input_index);\n    }\n    return 0;\n  }\n  \n  pid = getpid();\n  result = kill(output, pid, input_index, signal);\n  return result;\n}",
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f98",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "execute_function_08009f98"
        },
        "FUN_0800a18c": {
            "renaming": {
                "std::FUN_0800a18c": "abort_program",
                "FUN_0800a18c": "abort_program_0800a18c"
            },
            "code": "void abort_program_0800a18c(void)\n{\n    abort();\n}",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a18c",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_program_0800a18c"
        },
        "FUN_08008a24": {
            "renaming": {
                "FUN_08008a24": "write_digital_pin_08008a24",
                "ulPin": "pin",
                "ulVal": "value",
                "PTR_digitalPin_08008a64": "digitalPinArray",
                "uVar2": "digital_pin_index",
                "PTR_g_digPinConfigured_08008a68": "digitalPinConfigured",
                "_Var1": "is_configured"
            },
            "code": "void write_digital_pin_08008a24(uint32_t pin, uint32_t value); \n\nvoid write_digital_pin_08008a24(uint32_t pin, uint32_t value) {\n  uint32_t digital_pin_index;\n  GPIO_TypeDef *port;\n  digital_pin_index = (uint32_t)(char)PTR_digitalPin_08008a64[pin];\n  if (digital_pin_index != 0xffffffff) {\n    if (is_pin_configured((PinName_conflict)digital_pin_index, &PTR_g_digPinConfigured_08008a68)) {\n      port = get_GPIO_Port((digital_pin_index << 0x18) >> 0x1c);\n      write_digital_pin_08008a24(1 << (digital_pin_index & 0xf) & 0xffff, value);\n    }\n  }\n}\n",
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a24",
            "calling": [
                "strobeBlinkPin",
                "analogWrite",
                "digitalWriteCallback",
                "ServoIrqHandle",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "write_digital_pin_08008a24"
        },
        "FUN_08008020": {
            "renaming": {
                "FUN_08008020": "enable_i2c_listen_mode_08008020",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "isMaster": "is_master"
            },
            "code": "void enable_i2c_listen_mode_08008020(I2C_HandleTypeDef_conflict *i2c_handle) {\\n  i2c_t_conflict *i2c_object;\\n  i2c_object = get_i2c_obj(i2c_handle);\\n  if (i2c_object->isMaster == \"\\0\") {\\n    HAL_I2C_EnableListen_IT(i2c_handle);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008020",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_mode_08008020"
        },
        "FUN_08005dac": {
            "renaming": {
                "FUN_08005dac": "configure_timer_08005dac",
                "TIMx": "timer",
                "OC_Config": "oc_config",
                "uVar1": "cr2",
                "uVar2": "oc_mode",
                "uVar3": "oc_polarity"
            },
            "code": "void configure_timer_08005dac(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *oc_config) {\n  uint32_t cr2 = timer->CR2;\n  uint32_t oc_mode = oc_config->OCMode;\n  uint32_t oc_polarity = oc_config->OCPolarity;\n  timer->CCER &= 0xffffefff;\n  if (timer == PTR_08005df0) {\n    cr2 &= 0xffffbfff;\n    cr2 |= oc_config->OCIdleState << 6;\n  }\n  timer->CR2 = cr2;\n  timer->CCMR2 &= 0xffff8cff;\n  timer->CCMR2 |= oc_mode << 8;\n  timer->CCR4 = oc_config->Pulse;\n  timer->CCER &= 0xffffdfff;\n  timer->CCER |= oc_polarity << 0xc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dac",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005dac"
        },
        "FUN_080066e8": {
            "renaming": {
                "FUN_080066e8": "check_flag_status_080066e8",
                "*huart": "*uart",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "tickstart",
                "Timeout": "timeout",
                "uVar1": "current_tick"
            },
            "code": "HAL_StatusTypeDef check_flag_status_080066e8(UART_HandleTypeDef *uart, uint32_t flag, FlagStatus status, uint32_t tickstart, uint32_t timeout) {\n  uint32_t current_tick;\n  do {\n    bool flag_status = ((flag & ~uart->Instance->SR) == 0);\n    if (flag_status != (bool)status) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) || ((timeout != 0) && ((current_tick = HAL_GetTick()), (current_tick - tickstart <= timeout))));\n  uart->Instance->CR1 &= 0xfffffe5f;\n  uart->Instance->CR3 &= 0xfffffffe;\n  uart->gState = HAL_UART_STATE_READY;\n  uart->RxState = HAL_UART_STATE_READY;\n  uart->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066e8",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_flag_status_080066e8"
        },
        "FUN_08009358": {
            "renaming": {
                "FUN_08009358": "write_to_stream_08009358",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar2": "end_of_buffer",
                "iVar3": "write_count",
                "iVar1": "result"
            },
            "code": "int write_to_stream_08009358(int stream, int character, void *buffer, int buffer_size)\n{\n  int write_count = 0;\n  void *end_of_buffer = buffer + buffer_size;\n  while (buffer != end_of_buffer) {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    int result = __sfputc_r(stream, *buffer, character, buffer_size, write_count);\n    buffer++;\n    write_count = result + 1;\n  }\n  return write_count;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009358",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_08009358"
        },
        "FUN_0800270c": {
            "renaming": {
                "FUN_0800270c": "calculateBufferDifference_0800270c",
                "*PTR_rxBufferLength_08002718": "wire->rxBufferLength",
                "*PTR_rxBufferIndex_0800271c": "wire->rxBufferIndex"
            },
            "code": "int calculateBufferDifference_0800270c(TwoWire* wire) {\n  int bufferLength = (int)*(*PTR_rxBufferLength_08002718);\n  int bufferIndex = (int)*(*PTR_rxBufferIndex_0800271c);\n  int difference = bufferLength - bufferIndex;\n  return difference;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800270c",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "calculateBufferDifference_0800270c"
        },
        "FUN_08007fa0": {
            "renaming": {
                "FUN_08007fa0": "handle_i2c_transfer_08007fa0",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "tx_rx_buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "HAL_I2C_Slave_Sequential_Transmit_IT",
                "ushort": "unsigned_short"
            },
            "code": "void handle_i2c_transfer_08007fa0(I2C_HandleTypeDef_conflict *i2c_handle, uint8_t transfer_direction, uint16_t address_match_code) {\n  i2c_t_conflict *i2c_object = get_i2c_object(i2c_handle);\n  if ((uint)address_match_code == (i2c_handle->Init).OwnAddress1) {\n    if (transfer_direction == 0) {\n      i2c_object->tx_rx_buffer_size = 0;\n      i2c_object->slave_mode = 0;\n      if (i2c_object->on_slave_transmit != (_func_void *)0x0) {\n        (*i2c_object->on_slave_transmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT(i2c_handle, i2c_object->tx_rx_buffer, (ushort)i2c_object->tx_rx_buffer_size, 8);\n      return;\n    }\n    i2c_object->slave_mode = 1;\n    HAL_I2C_Slave_Sequential_Receive_IT(i2c_handle, i2c_object->tx_rx_buffer, 0x20, 8);\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007fa0",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "handle_i2c_transfer_08007fa0"
        },
        "FUN_08002720": {
            "renaming": {
                "FUN_08002720": "read_byte_from_rxBuffer_08002720",
                "__fd": "fd",
                "__buf": "buf",
                "__nbytes": "nbytes",
                "bVar1": "buffer_index",
                "bVar2": "byte_to_read",
                "*PTR_rxBufferIndex_08002740": "*rxBufferIndex",
                "*PTR_rxBufferLength_08002744": "*rxBufferLength",
                "*(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)bVar1)": "*(byte *)(*(int *)rxBuffer + (uint)buffer_index)"
            },
            "code": "ssize_t __thiscall read_byte_from_rxBuffer_08002720(TwoWire *wire, int fd, void *buf, size_t nbytes)\n{\n  byte buffer_index = *PTR_rxBufferIndex_08002740;\n  if ((uint)buffer_index < (uint)(byte)*PTR_rxBufferLength_08002744) {\n    byte byte_to_read = *(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)bVar1);\n    *PTR_rxBufferIndex_08002740 = buffer_index + 1;\n    return (uint)byte_to_read;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002720",
            "calling": [
                "wireRead"
            ],
            "imported": false,
            "current_name": "read_byte_from_rxBuffer_08002720"
        },
        "FUN_080031ce": {
            "renaming": {
                "FUN_080031ce": "sendFirmwareVersion_080031ce",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "byteCount",
                "bytev": "byteArray",
                "p_Var1": "printFunc",
                "uVar2": "index"
            },
            "code": "void __thiscall FirmataMarshaller::sendFirmwareVersion_080031ce(FirmataMarshaller *this, uint8_t major, uint8_t minor, size_t byteCount, uint8_t *byteArray) {\n    _func_int_varargs *printFunc;\n    uint index;\n\n    if (this->FirmataStream != (Stream *)0x0) {\n        printFunc = *(this->FirmataStream->super_Print)._vptr_Print;\n        (*printFunc)(this, 0xf0, (uint)minor, printFunc, byteCount);\n        (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream, 0x79);\n        (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream, (uint)major);\n        (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream, (uint)minor);\n        for (index = 0; index < byteCount; index = index + 1) {\n            encodeByteStream(this, 1, byteArray + index, 0);\n        }\n        (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream, 0xf7);\n    }\n    return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031ce",
            "calling": [
                "printFirmwareVersion"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_080031ce"
        },
        "FUN_08008b52": {
            "renaming": {
                "FUN_08008b52": "wait_for_tx_complete_08008b52",
                "this": "serial",
                "_written": "has_data_to_write",
                "_serial": "serial_data",
                "tx_head": "transmit_head",
                "tx_tail": "transmit_tail"
            },
            "code": "void __thiscall HardwareSerial::wait_for_tx_complete_08008b52(HardwareSerial *serial)\n{\n  if (serial->has_data_to_write) {\n    do {\n    } while ((serial->tx_head) != (serial->tx_tail));\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b52",
            "calling": [],
            "imported": false,
            "current_name": "wait_for_tx_complete_08008b52"
        },
        "FUN_08002968": {
            "renaming": {
                "FUN_08002968": "initializeWire_08002968",
                "this": "wire",
                "address": "address",
                "ownAddress": "own_address",
                "obj": "i2c_object",
                "PTR_rxBufferIndex_080029ec": "wire->rx_buffer_index",
                "PTR_rxBufferLength_080029f0": "wire->rx_buffer_length",
                "PTR_rxBuffer_080029f4": "wire->rx_buffer",
                "PTR_rxBufferAllocated_080029f8": "wire->rx_buffer_allocated",
                "PTR_txBufferIndex_080029fc": "wire->tx_buffer_index",
                "PTR_txBufferLength_08002a00": "wire->tx_buffer_length",
                "PTR_txBuffer_08002a04": "wire->tx_buffer",
                "PTR_txBufferAllocated_08002a08": "wire->tx_buffer_allocated",
                "PTR_transmitting_08002a0c": "wire->transmitting",
                "DAT_08002a10": "wire->rx_buffer",
                "DAT_08002a14": "wire->tx_slave_handler",
                "DAT_08002a18": "wire->rx_slave_handler"
            },
            "code": "void __thiscall initializeWire_08002968(TwoWire *wire, uint8_t address)\n{\n  uint32_t own_address;\n  i2c_t *i2c_object;\n  \n  PTR_rxBufferIndex_080029ec = 0;\n  PTR_rxBufferLength_080029f0 = 0;\n  if (*(void **)PTR_rxBuffer_080029f4 != (void *)0x0) {\n    memset(*(void **)PTR_rxBuffer_080029f4, 0, (uint)(byte)*PTR_rxBufferAllocated_080029f8);\n  }\n  PTR_txBufferIndex_080029fc = 0;\n  PTR_txBufferLength_08002a00 = 0;\n  if (*(void **)PTR_txBuffer_08002a04 != (void *)0x0) {\n    memset(*(void **)PTR_txBuffer_08002a04, 0, (uint)(byte)*PTR_txBufferAllocated_08002a08);\n  }\n  PTR_transmitting_08002a0c = 0;\n  own_address = (address & 0x7f) << 1;\n  wire->own_address = (uint8_t)own_address;\n  if (address == 0x33) {\n    wire->master = true;\n  }\n  else {\n    wire->master = false;\n  }\n  i2c_object = &wire->_i2c;\n  i2c_custom_init((i2c_t_conflict *)i2c_object, PTR_rxBuffer_080029f4, PTR_txBufferAllocated_08002a08, own_address, wire->master);\n  if (wire->master == false) {\n    i2c_attachSlaveTxEvent((i2c_t_conflict *)i2c_object, DAT_08002a14);\n    i2c_attachSlaveRxEvent((i2c_t_conflict *)i2c_object, DAT_08002a18);\n  }\n  return;\n}",
            "called": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "memset",
                "i2c_custom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002968",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeWire_08002968"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "i2c_transfer_08004ccc",
                "hi2c": "handle",
                "uVar1": "transfer_options",
                "pbVar2": "data_ptr"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08004ccc(I2C_HandleTypeDef *handle)\n{\n  uint32_t transfer_options = handle->XferOptions;\n  if (handle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (handle->XferCount == 0) {\n      if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n        handle->Instance->CR2 &= 0xfffff8ff;\n        handle->Instance->CR1 |= 0x200;\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        if (handle->Mode == HAL_I2C_MODE_MEM) {\n          handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(handle);\n        }\n        else {\n          handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(handle);\n        }\n      }\n      else {\n        handle->Instance->CR2 &= 0xfffff8ff;\n        handle->PreviousState = 0x11;\n        handle->Mode = HAL_I2C_MODE_NONE;\n        handle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(handle);\n      }\n    }\n    else {\n      uint8_t *data_ptr = handle->pBuffPtr;\n      handle->pBuffPtr = data_ptr + 1;\n      handle->Instance->DR = (uint32_t)*data_ptr;\n      handle->XferCount--;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004ccc"
        },
        "FUN_080042d4": {
            "renaming": {
                "FUN_080042d4": "get_GPIO_PinState_080042d4",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin",
                "GPIO_PIN_RESET": "LOW",
                "GPIO_PIN_SET": "HIGH"
            },
            "code": "GPIO_PinState get_GPIO_PinState_080042d4(GPIO_TypeDef *GPIOx, uint16_t pin)\n{\n    if ((pin & GPIOx->IDR) == 0)\n    {\n        return GPIO_PIN_RESET;\n    }\n    return GPIO_PIN_SET;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042d4",
            "calling": [
                "digital_io_read"
            ],
            "imported": false,
            "current_name": "get_GPIO_PinState_080042d4"
        },
        "FUN_0800a07a": {
            "renaming": {
                "FUN_0800a07a": "seek_to_position_0800a07a",
                "param_1": "file_descriptor",
                "param_2": "position_data",
                "iVar1": "seek_result",
                "uVar2": "bit_mask",
                "bVar3": "seek_failed"
            },
            "code": "void seek_to_position_0800a07a(int file_descriptor, int position_data)\n{\n  int seek_result;\n  ushort bit_mask;\n  bool seek_failed;\n  \n  seek_result = _lseek_r(file_descriptor, (int)*(short *)(position_data + 0xe));\n  seek_failed = seek_result == -1;\n  if (seek_failed) {\n    bit_mask = *(ushort *)(position_data + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(position_data + 0x54) = seek_result;\n    bit_mask = *(ushort *)(position_data + 0xc) | 0x1000;\n  }\n  if (seek_failed) {\n    *(ushort *)(position_data + 0xc) = bit_mask;\n  }\n  if (!seek_failed) {\n    *(ushort *)(position_data + 0xc) = bit_mask;\n  }\n  return;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a07a",
            "calling": [],
            "imported": false,
            "current_name": "seek_to_position_0800a07a"
        },
        "FUN_080064b0": {
            "renaming": {
                "FUN_080064b0": "reset_uart_080064b0",
                "huart": "uart",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state",
                "HAL_UART_STATE_READY": "ready_state"
            },
            "code": "void reset_uart_080064b0(UART_HandleTypeDef *uart)\n{\n  uart->Instance->CR1 &= ~(1 << 13);\n  uart->Instance->CR3 &= ~(1 << 0);\n  uart->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064b0",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_080064b0"
        },
        "FUN_08006092": {
            "renaming": {
                "FUN_08006092": "configure_timer_08006092",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspInit": "HAL_TIM_PWM_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_08006092(TIM_HandleTypeDef_conflict *timer)\n{\n  if (timer != NULL) {\n    if (timer->State == HAL_TIM_STATE_RESET) {\n      timer->Lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(timer);\n    }\n    timer->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->Instance,&timer->Init);\n    timer->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006092",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_timer_08006092"
        },
        "FUN_08008d8c": {
            "renaming": {
                "FUN_08008d8c": "initializePriority_08008d8c",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel",
                "PTR_Serial2_08008dac": "serial2Ptr",
                "DAT_08008da8": "baudRate"
            },
            "code": "void initializePriority_08008d8c(int shouldInitialize, int priorityLevel) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    HardwareSerial::HardwareSerial(&PTR_Serial2_08008dac, DAT_08008da8);\n  }\n  return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d8c",
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "imported": false,
            "current_name": "initializePriority_08008d8c"
        },
        "FUN_08008038": {
            "renaming": {
                "FUN_08008038": "handle_I2C_events_08008038",
                "PTR_i2c_handles_08008044": "i2c_handles",
                "**PTR_i2c_handles_08008044": "*i2c_handles",
                "HAL_I2C_EV_IRQHandler": "handle_I2C_events_with_IRQ"
            },
            "code": "void handle_I2C_events_08008038(I2C_HandleTypeDef_conflict ***PTR_PTR_i2c_handles_08008044_08008044){\n  HAL_I2C_EV_IRQHandler(**PTR_PTR_i2c_handles_08008044_08008044);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008038",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_events_08008038"
        },
        "FUN_08009124": {
            "renaming": {
                "FUN_08009124": "printToFile_08009124",
                "__stream": "filePointer",
                "__format": "formatString",
                "iVar1": "result",
                "in_r2": "",
                "in_r3": "",
                "uStack_8": "",
                "uStack_4": "",
                "PTR__impure_ptr_08009144": ""
            },
            "code": "int printToFile_08009124(FILE *filePointer, char *formatString, ...) {\n    int result;\n    va_list arguments;\n    va_start(arguments, formatString);\n    result = vfprintf(filePointer, formatString, arguments);\n    va_end(arguments);\n    return result;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009124",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "printToFile_08009124"
        },
        "FUN_080064ae": {
            "renaming": {
                "FUN_080064ae": "do_nothing_080064ae"
            },
            "code": "\nvoid do_nothing_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ae",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ae"
        },
        "FUN_080064ac": {
            "renaming": {
                "FUN_080064ac": "do_nothing_080064ac"
            },
            "code": "\nvoid do_nothing_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ac",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ac"
        },
        "FUN_08005cb4": {
            "renaming": {
                "FUN_08005cb4": "handle_rtc_alarm_08005cb4",
                "hrtc": "rtc_handle",
                "PTR_DAT_08005ce8": "DAT_08005ce8"
            },
            "code": "void handle_rtc_alarm_08005cb4(RTC_HandleTypeDef *rtc_handle) {\n    bool is_alarm_a_enabled = (rtc_handle->Instance->CRH & 2) != 0;\n    bool is_alarm_a_pending = (rtc_handle->Instance->CRL & 2) != 0;\n    if (is_alarm_a_enabled && is_alarm_a_pending) {\n        HAL_RTC_AlarmAEventCallback(rtc_handle);\n        rtc_handle->Instance->CRL = 0xfffffffd;\n    }\n    *(uint32_t *)(PTR_DAT_08005ce8 + 0x14) = 0x20000;\n    rtc_handle->State = HAL_RTC_STATE_READY;\n}",
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cb4",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_rtc_alarm_08005cb4"
        },
        "FUN_080042e2": {
            "renaming": {
                "FUN_080042e2": "set_gpio_pin_state_080042e2",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "uint": "unsigned int"
            },
            "code": "void set_gpio_pin_state_080042e2(GPIO_TypeDef *gpio, uint16_t pin, GPIO_PinState state) {\n  if (state == GPIO_PIN_RESET) {\n    gpio->BSRR = (uint)pin << 0x10;\n  } else {\n    gpio->BSRR = (uint)pin;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e2",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080042e2"
        },
        "FUN_080088e0": {
            "renaming": {
                "FUN_080088e0": "set_pin_pwm_080088e0",
                "ulPin": "pin_number",
                "ulValue": "value",
                "_Var1": "is_pin_pwm",
                "uVar2": "write_resolution",
                "pin": "pin_name"
            },
            "code": "void set_pin_pwm_080088e0(uint32_t pin_number, uint32_t value) {\n  bool is_pin_pwm = false;\n  uint8_t write_resolution = *(uint8_t *)PTR__writeResolution_08008988;\n  PinName_conflict pin_name;\n\n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_0800897c[pin_number];\n  }\n  else {\n    pin_name = NC;\n  }\n\n  if (pin_name != NC) {\n    is_pin_pwm = pin_in_pinmap(pin_name, (PinMap_conflict *)PTR_PinMap_PWM_08008980);\n    if (is_pin_pwm) {\n      bool is_pin_configured = is_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008984);\n      if (!is_pin_configured) {\n        set_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008984);\n      }\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          value = value << (8 - write_resolution & 0xff);\n        }\n        else {\n          value = value >> (write_resolution - 8 & 0xff);\n        }\n      }\n      pwm_start(pin_name, DAT_0800898c, 0xff, value, !is_pin_configured);\n    }\n    else {\n      pinMode(pin_number, OUTPUT);\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          value = value << (8 - write_resolution & 0xff);\n        }\n        else {\n          value = value >> (write_resolution - 8 & 0xff);\n        }\n      }\n      digitalWrite(pin_number, value >= 0x80);\n    }\n  }\n}",
            "called": [
                "pin_in_pinmap",
                "set_pin_configured",
                "digitalWrite",
                "pinMode",
                "pwm_start",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088e0",
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "set_pin_pwm_080088e0"
        },
        "FUN_08008b66": {
            "renaming": {
                "FUN_08008b66": "receiveData_08008b66",
                "obj": "serial_object",
                "iVar1": "receive_status",
                "uVar2": "next_rx_head",
                "c": "received_byte"
            },
            "code": "void receiveData_08008b66(serial_t_conflict *serial_object)\n{\n    int receive_status;\n    ushort next_rx_head;\n    uchar received_byte;\n\n    receive_status = uart_getc((serial_t *)serial_object, &received_byte);\n    if ((receive_status == 0) && (next_rx_head = serial_object->rx_head + 1 & 0x3f, next_rx_head != serial_object->rx_tail)) {\n        serial_object->rx_buff[serial_object->rx_head] = received_byte;\n        serial_object->rx_head = next_rx_head;\n    }\n    return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b66",
            "calling": [],
            "imported": false,
            "current_name": "receiveData_08008b66"
        },
        "FUN_0800a3a0": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a3a0": "set_flags_if_negative",
                "PTR_id_0800a404": "ptr_1",
                "PTR_id_0800a408": "ptr_2",
                "PTR_id_0800a40c": "ptr_3",
                "PTR_id_0800a410": "ptr_4",
                "PTR_id_0800a414": "ptr_5",
                "PTR_id_0800a418": "ptr_6",
                "PTR_id_0800a41c": "ptr_7",
                "PTR_id_0800a420": "ptr_8",
                "FUN_0800a3a0": "set_flags_if_negative_0800a3a0"
            },
            "code": "void set_flags_if_negative_0800a3a0(int* ptr) {\n  if (*ptr < 0) {\n    *ptr = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a3a0",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_if_negative_0800a3a0"
        },
        "FUN_08008048": {
            "renaming": {
                "FUN_08008048": "handle_I2C_errors_08008048",
                "PTR_i2c_handles_08008054": "i2c_handles"
            },
            "code": "void handle_I2C_errors_08008048(void)\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008054);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008048",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_errors_08008048"
        },
        "FUN_080053cc": {
            "renaming": {
                "FUN_080053cc": "reset_I2C_DMA_080053cc",
                "hdma": "dma_config",
                "hi2c": "i2c_config",
                "HAL_I2C_STATE_ABORT": "I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_ErrorCallback": "I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback": "I2C_AbortCpltCallback",
                "Instance": "Instance",
                "CR1": "CR1",
                "XferCount": "XferCount",
                "hdmatx": "hdmatx",
                "hdmarx": "hdmarx",
                "ErrorCode": "ErrorCode"
            },
            "code": "void reset_I2C_DMA_080053cc(I2C_DMA_Config *dma_config) {\n  I2C_Config *i2c_config;\n  i2c_config = (I2C_Config *)dma_config->parent;\n  i2c_config->Instance->CR1 &= 0xfffffbff;\n  i2c_config->XferCount = 0;\n  i2c_config->hdmatx->XferAbortCallback = (void (*)(DMA_HandleTypeDef *))0x0;\n  i2c_config->hdmarx->XferAbortCallback = (void (*)(DMA_HandleTypeDef *))0x0;\n  if (i2c_config->State != I2C_STATE_ABORT) {\n    i2c_config->State = I2C_STATE_READY;\n    i2c_config->Mode = I2C_MODE_NONE;\n    i2c_config->Instance->CR1 &= 0xfffffffe;\n    I2C_ErrorCallback(i2c_config);\n    return;\n  }\n  i2c_config->State = I2C_STATE_READY;\n  i2c_config->Mode = I2C_MODE_NONE;\n  i2c_config->ErrorCode = 0;\n  i2c_config->Instance->CR1 &= 0xfffffffe;\n  I2C_AbortCpltCallback(i2c_config);\n  return;\n}",
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053cc",
            "calling": [],
            "imported": false,
            "current_name": "reset_I2C_DMA_080053cc"
        },
        "FUN_080087bc": {
            "renaming": {
                "FUN_080087bc": "handle_UART_interrupt_080087bc",
                "PTR_uart_handlers_080087d0": "uart_handler_ptr",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "USART1_IRQn": "USART1_IRQ"
            },
            "code": "void handle_UART_interrupt_080087bc(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef **)PTR_uart_handlers_080087d0;\n  HAL_UART_IRQHandler(uart_handler);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087bc",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART_interrupt_080087bc"
        },
        "FUN_080042f0": {
            "renaming": {
                "FUN_080042f0": "handle_gpio_interrupt_080042f0",
                "GPIO_Pin": "pin",
                "DAT_08004308": "gpio_data"
            },
            "code": "void handle_gpio_interrupt_080042f0(uint16_t pin) {\n    uint32_t *DAT_08004308 = (uint32_t *)(DAT_08004308 + 0x14);\n\n    if ((*DAT_08004308 & (uint32_t)pin) != 0) {\n        *DAT_08004308 = (uint32_t)pin;\n        HAL_GPIO_EXTI_Callback(pin);\n    }\n    return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042f0",
            "calling": [
                "EXTI2_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_interrupt_080042f0"
        },
        "FUN_080087d4": {
            "renaming": {
                "FUN_080087d4": "handle_UART_interrupt_080087d4",
                "USART2_IRQn": "UART_interrupt",
                "PTR_uart_handlers_080087e8": "ptr_uart_handlers"
            },
            "code": "void handle_UART_interrupt_080087d4(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_080087e8 + 4);\n  HAL_UART_IRQHandler(uart_handler);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART_interrupt_080087d4"
        },
        "FUN_0800a09e": {
            "renaming": {
                "FUN_0800a09e": "close_file_descriptor_0800a09e",
                "param_1": "file_descriptor",
                "param_2": "file_descriptor_offset"
            },
            "code": "void close_file_descriptor_0800a09e(void* file_descriptor, int file_descriptor_offset) {\n    _close_r(file_descriptor, (int)*(short *)(file_descriptor_offset + 0xe));\n    return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a09e",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_0800a09e"
        },
        "FUN_080076e0": {
            "renaming": {
                "FUN_080076e0": "disableTimerInterrupt_080076e0",
                "obj": "timerObj",
                "HVar1": "status",
                "uVar2": "timerIrq"
            },
            "code": "void disableTimerInterrupt_080076e0(stimer_t_conflict *timerObj)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timerIrq;\n  timerObj->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  timerIrq = getTimerIrq(timerObj->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)timerIrq);\n  status = HAL_TIM_OC_DeInit(&timerObj->handle);\n  if (status == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&timerObj->handle,0);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_OC_DeInit",
                "getTimerIrq",
                "HAL_TIM_OC_Stop_IT",
                "HAL_NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076e0",
            "calling": [
                "finISR"
            ],
            "imported": false,
            "current_name": "disableTimerInterrupt_080076e0"
        },
        "FUN_08002f14": {
            "renaming": {
                "FUN_08002f14": "sendStringToMarshaller_08002f14",
                "this": "firmataInstance",
                "string": "stringToSend",
                "&this->marshaller": "&firmataInstance->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendStringToMarshaller_08002f14(FirmataClass *firmataInstance,char *stringToSend)\n{\n  FirmataMarshaller::sendStringToMarshaller_08002f14(&firmataInstance->marshaller,stringToSend);\n  return;\n}",
            "called": [
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f14",
            "calling": [
                "attachServo",
                "sysexCallback",
                "readAndReportData",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "sendStringToMarshaller_08002f14"
        }
    },
    "used_tokens": 323303,
    "layers": [
        [
            "FUN_08007246",
            "FUN_0800a042",
            "FUN_08008e4e",
            "FUN_08008694",
            "FUN_08005188",
            "FUN_08001bf8",
            "FUN_080069ec",
            "FUN_0800a168",
            "FUN_080067ac",
            "FUN_0800735a",
            "FUN_08008c20",
            "FUN_0800723c",
            "FUN_080043a2",
            "FUN_08006280",
            "FUN_08007258",
            "FUN_08009f4c",
            "FUN_08006c7c",
            "FUN_08006b5c",
            "FUN_08007376",
            "FUN_080033cc",
            "FUN_08003de4",
            "FUN_08000500",
            "FUN_08009d24",
            "FUN_08008e72",
            "FUN_080022f8",
            "FUN_08005084",
            "FUN_08008b0e",
            "FUN_0800291c",
            "FUN_080032bc",
            "FUN_08008c44",
            "FUN_08006060",
            "FUN_08006186",
            "FUN_08006b7c",
            "FUN_08008e7c",
            "FUN_0800a194",
            "FUN_08003aa0",
            "FUN_08005fe8",
            "FUN_08003ce8",
            "FUN_0800738a",
            "FUN_08002948",
            "FUN_08009e64",
            "FUN_08002acc",
            "FUN_0800932c",
            "FUN_080099a4",
            "FUN_08005a1c",
            "FUN_08006b0c",
            "FUN_08007320",
            "FUN_080002ec",
            "FUN_08000be8",
            "FUN_08003fd8",
            "FUN_0800307a",
            "FUN_08002ca4",
            "FUN_0800319e",
            "FUN_08008d00",
            "FUN_08004b82",
            "FUN_0800997e",
            "FUN_0800779c",
            "FUN_08002dbc",
            "FUN_08007f78",
            "FUN_08006b28",
            "FUN_08006b1c",
            "FUN_0800a130",
            "FUN_08008f3c",
            "FUN_08007332",
            "FUN_08006128",
            "FUN_0800a258",
            "FUN_08002cb8",
            "FUN_08008f50",
            "FUN_08004a76",
            "FUN_0800877c",
            "FUN_080047f4",
            "FUN_08005a48",
            "FUN_080033a8",
            "FUN_08008d18",
            "FUN_0800a020",
            "FUN_08007f7c",
            "FUN_08006d80",
            "FUN_08006c60",
            "FUN_08008e40",
            "FUN_080045c0",
            "FUN_08007e74",
            "FUN_08002ddc",
            "FUN_08009f2c",
            "FUN_0800a154",
            "FUN_08007f8e",
            "FUN_08006b3e",
            "FUN_08006262",
            "FUN_08007110",
            "FUN_08007594",
            "FUN_08002cd0",
            "FUN_08002df6",
            "FUN_08007118",
            "FUN_08001be8",
            "FUN_08005a68",
            "FUN_08008f78",
            "FUN_08002dea",
            "FUN_0800734a",
            "FUN_08000aec",
            "FUN_080068d6",
            "FUN_080032a2",
            "FUN_08009e28",
            "FUN_0800a01c",
            "FUN_08006390",
            "FUN_08008730",
            "FUN_08008854",
            "FUN_08004d6c",
            "FUN_08007760",
            "FUN_08008850",
            "FUN_08002fc2",
            "FUN_08008afa",
            "FUN_080038dc",
            "FUN_080025ac",
            "FUN_08007648",
            "FUN_08008858",
            "FUN_08004a24",
            "FUN_08002fba",
            "FUN_080090cc",
            "FUN_080049e0",
            "FUN_08006d24",
            "FUN_08008500",
            "FUN_08007774",
            "FUN_080001a8",
            "FUN_080048c8",
            "FUN_08009954",
            "FUN_08005e6e",
            "FUN_08004024",
            "FUN_08008868",
            "FUN_080036ac",
            "FUN_0800643c",
            "FUN_08002fca",
            "FUN_0800a31c",
            "FUN_080026f8",
            "FUN_08007544",
            "FUN_08008990",
            "FUN_08004396",
            "FUN_08003fb0",
            "FUN_08007788",
            "FUN_08002ec4",
            "FUN_08007306",
            "FUN_08008f0e",
            "FUN_0800886c",
            "FUN_080036d8",
            "FUN_0800a110",
            "FUN_08003b8c",
            "FUN_080035b8",
            "FUN_08006460",
            "FUN_08004046",
            "FUN_08008880",
            "FUN_08002ed2",
            "FUN_08008f1c",
            "FUN_080058ac",
            "FUN_08007438",
            "FUN_0800306c",
            "FUN_0800887c",
            "FUN_0800863c",
            "FUN_08004050",
            "FUN_08008e14",
            "FUN_08005a28",
            "FUN_08008ac6",
            "FUN_08003366",
            "FUN_080091b0",
            "FUN_08008abc",
            "FUN_08002b68",
            "FUN_080005e0",
            "FUN_0800674e",
            "FUN_0800771c",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_08008bf4",
            "FUN_08002c7c",
            "FUN_08005430",
            "FUN_08009918",
            "FUN_08005434",
            "FUN_08005e2e",
            "FUN_08007736",
            "FUN_08002c90",
            "FUN_0800542a",
            "FUN_0800457c",
            "FUN_080091c6",
            "FUN_08003a20",
            "FUN_08002a58",
            "FUN_080004d4",
            "FUN_08002fa0",
            "FUN_08003a1c",
            "FUN_08007744",
            "FUN_08006538",
            "FUN_08002fa8",
            "FUN_0800325a",
            "FUN_080091d8",
            "FUN_0800688e",
            "FUN_080090b4",
            "FUN_0800870c",
            "FUN_08008840",
            "FUN_08008600",
            "FUN_08003154",
            "FUN_08006420",
            "FUN_08007750",
            "FUN_08009938",
            "FUN_08007f0e",
            "FUN_08004004",
            "FUN_08003158",
            "FUN_080090c2",
            "FUN_08008846",
            "FUN_0800459c",
            "FUN_0800774a",
            "FUN_0800314e",
            "FUN_080036a0",
            "FUN_080038e4",
            "FUN_08005d48",
            "FUN_08008ba4",
            "FUN_08009ff8",
            "FUN_08009db0",
            "FUN_08002c2c",
            "FUN_080072f0",
            "FUN_08000178",
            "FUN_08000a64",
            "FUN_08002c40",
            "FUN_0800694c",
            "FUN_0800a0ec",
            "FUN_08008df8",
            "FUN_08000188",
            "FUN_08004f3c",
            "FUN_0800344a",
            "FUN_080071e4",
            "FUN_08002c54",
            "FUN_080072fa",
            "FUN_08003346",
            "FUN_08003106",
            "FUN_08007708",
            "FUN_0800018c",
            "FUN_08003f94",
            "FUN_08002c68",
            "FUN_0800430c",
            "FUN_08003350",
            "FUN_08007710",
            "FUN_08003474",
            "FUN_08008804",
            "FUN_08004e3c",
            "FUN_08007718",
            "FUN_08002a30",
            "FUN_08009cd0",
            "FUN_0800322c",
            "FUN_08003760",
            "FUN_08000130",
            "FUN_08002798",
            "FUN_0800242c",
            "FUN_08002e44",
            "FUN_0800a0a8",
            "FUN_08003f30",
            "FUN_080073d8",
            "FUN_080085dc",
            "FUN_08008db0",
            "FUN_08002444",
            "FUN_0800906c",
            "FUN_08003658",
            "FUN_08009a80",
            "FUN_080062f4",
            "FUN_080073e8",
            "FUN_0800267c",
            "FUN_0800376c",
            "FUN_08003e20",
            "FUN_08005840",
            "FUN_08003306",
            "FUN_08002578",
            "FUN_08006932",
            "FUN_080060c4",
            "FUN_08009eac",
            "FUN_08008dbe",
            "FUN_080072d8",
            "FUN_08002b00",
            "FUN_08002f84",
            "FUN_08009094",
            "FUN_0800a0cc",
            "FUN_08002580",
            "FUN_080073ec",
            "FUN_08008ef4",
            "FUN_08002c1e",
            "FUN_08002f94",
            "FUN_08001b48",
            "FUN_08005df4",
            "FUN_08009148",
            "FUN_080099dc",
            "FUN_08009024",
            "FUN_080064cc",
            "FUN_08008058",
            "FUN_08004ac2",
            "FUN_08006ca8",
            "FUN_08000214",
            "FUN_08005bb8",
            "FUN_080063c0",
            "FUN_0800274c",
            "FUN_08009270",
            "FUN_08009038",
            "FUN_08005aa4",
            "FUN_08008068",
            "FUN_08002400",
            "FUN_08000588",
            "FUN_08002644",
            "FUN_08002f1e",
            "FUN_0800902e",
            "FUN_08009042",
            "FUN_08009c7c",
            "FUN_08009b5c",
            "FUN_08008a6c",
            "FUN_080085b8",
            "FUN_08001c08",
            "FUN_080075dc",
            "FUN_080087ec",
            "FUN_08007ff0",
            "FUN_08002774",
            "FUN_080052f0",
            "FUN_08002f2c",
            "FUN_08004954",
            "FUN_08005cec",
            "FUN_08003748",
            "FUN_080040e8",
            "FUN_08009b6c",
            "FUN_0800010c",
            "FUN_080086e8",
            "FUN_08001c18",
            "FUN_08009056",
            "FUN_08002e1a",
            "FUN_0800904c",
            "FUN_080073ae",
            "FUN_08003f0c",
            "FUN_08000488",
            "FUN_08006bb8",
            "FUN_08004aec",
            "FUN_08007ede",
            "FUN_08004728",
            "FUN_080074e0",
            "FUN_080073c0",
            "FUN_080084b0",
            "FUN_080095a8",
            "FUN_08008b2a",
            "FUN_08003bd8",
            "FUN_08009d50",
            "FUN_08009108",
            "FUN_08009f98",
            "FUN_08008a24",
            "FUN_08008020",
            "FUN_08005dac",
            "FUN_080066e8",
            "FUN_08009358",
            "FUN_0800270c",
            "FUN_08007fa0",
            "FUN_08002720",
            "FUN_080031ce",
            "FUN_08008b52",
            "FUN_08002968",
            "FUN_08004ccc",
            "FUN_080042d4",
            "FUN_0800a07a",
            "FUN_080064b0",
            "FUN_08006092",
            "FUN_08008d8c",
            "FUN_08008038",
            "FUN_08005cb4",
            "FUN_080042e2",
            "FUN_080088e0",
            "FUN_08008b66",
            "FUN_0800a3a0",
            "FUN_08008048",
            "FUN_080053cc",
            "FUN_080087bc",
            "FUN_080042f0",
            "FUN_080087d4",
            "FUN_0800a09e",
            "FUN_080076e0"
        ],
        [
            "FUN_08002ce0",
            "FUN_08002ac0",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08008d30",
            "FUN_08003048",
            "FUN_0800885c",
            "FUN_08003002",
            "FUN_08009908",
            "FUN_08009cdc",
            "FUN_080026b0",
            "FUN_080027f0",
            "FUN_080036a2",
            "FUN_08002a26",
            "FUN_080091a0",
            "FUN_08002a1c",
            "FUN_08009190",
            "FUN_08002c00",
            "FUN_08008ed6",
            "FUN_08002c14",
            "FUN_08009084",
            "FUN_08009fe8",
            "FUN_08008eec",
            "FUN_08003724",
            "FUN_08002f0a",
            "FUN_08002634",
            "FUN_080098d8",
            "FUN_0800288c",
            "FUN_08002e26",
            "FUN_0800a18c",
            "FUN_08009124",
            "FUN_08002f14"
        ]
    ],
    "locked_functions": []
}