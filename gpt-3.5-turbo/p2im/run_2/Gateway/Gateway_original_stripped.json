{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "initialize_completed_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 initializeCompletedFlag_0800010c(undefined4 inputParameter)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputParameter;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "initialize_completed_flag_0800010c",
                "param_1": "inputParameter",
                "completed_8667": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculateStringLength_08000178(char *string)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = string;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "string",
                "pcVar3": "currentCharPointer",
                "pcVar2": "nextCharPointer",
                "cVar1": "currentChar"
            },
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "execute_software_interrupt_08000188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_08000188(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000188": "execute_software_interrupt_08000188"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800018c": {
            "entrypoint": "0x0800018c",
            "current_name": "afl_call_with_hypercall_check_0800018c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint aflCallWithHypercallCheck_0800018c(int numTicks)\n\n{\n  uint32_t result;\n  \n  if (noHyperCall != 0) {\n    return 0;\n  }\n  result = aflCall(1,numTicks,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800018c": "afl_call_with_hypercall_check_0800018c",
                "ticks": "numTicks",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001a8": {
            "entrypoint": "0x080001a8",
            "current_name": "set_pin_state_and_write_digital_pin_080001a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinStateAndWriteDigitalPin_080001a8(byte pinNumber,int pinState)\n\n{\n  bool isValidPin;\n  byte pinMode;\n  uint unsignedPin;\n  uint32_t digitalPinValue;\n  \n  unsignedPin = (uint)pinNumber;\n  if (unsignedPin < 0x3c) {\n    if (unsignedPin < 0x3c) {\n      if ((&digitalPin)[unsignedPin] == NC) {\n        isValidPin = false;\n      }\n      else {\n        digitalPinValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n        if (digitalPinValue == 0) {\n          isValidPin = false;\n        }\n        else {\n          digitalPinValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPin]);\n          if (digitalPinValue == 1) {\n            isValidPin = false;\n          }\n          else {\n            isValidPin = true;\n          }\n        }\n      }\n    }\n    else {\n      isValidPin = false;\n    }\n  }\n  else {\n    isValidPin = false;\n  }\n  if ((isValidPin) && (pinMode = firmata::FirmataClass::getPinMode(&Firmata,pinNumber), pinMode == '\\x01')) {\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,pinState);\n    digitalWrite(unsignedPin,pinState);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001a8": "set_pin_state_and_write_digital_pin_080001a8",
                "pin": "pinNumber",
                "value": "pinState",
                "bVar1": "isValidPin",
                "bVar2": "pinMode",
                "ulPin": "unsignedPin",
                "uVar3": "digitalPinValue"
            },
            "calling": [],
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "getPinMode",
                "setPinState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000214": {
            "entrypoint": "0x08000214",
            "current_name": "handle_pin_value_08000214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handlePinValue_08000214(byte pinNumber,int pinValue)\n\n{\n  bool isServo;\n  byte pinMode;\n  _Bool isValidPin;\n  uint pinNumber;\n  uint32_t digitalPin;\n  void *servoConfiguration;\n  \n  pinNumber = (uint)pinNumber;\n  if (0x3b < pinNumber) {\n    return;\n  }\n  pinMode = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n  if (pinMode == '\\x03') {\n    if (pinNumber < 0x3c) {\n      if ((&digitalPin)[pinNumber] == NC) {\n        isValidPin = false;\n      }\n      else {\n        digitalPin = pinNumberNametoDigitalPin((&digitalPin)[pinNumber]);\n        if (digitalPin == 0) {\n          isValidPin = false;\n        }\n        else {\n          digitalPin = pinNumberNametoDigitalPin((&digitalPin)[pinNumber]);\n          if (digitalPin == 1) {\n            isValidPin = false;\n          }\n          else {\n            isValidPin = pinNumber_in_pinNumbermap((&digitalPin)[pinNumber],(PinMap_conflict *)&PinMap_PWM);\n          }\n        }\n      }\n    }\n    else {\n      isValidPin = false;\n    }\n    if (isValidPin != false) {\n      analogWrite(pinNumber,pinValue);\n    }\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,pinValue);\n  }\n  else if (pinMode == '\\x04') {\n    if (pinNumber < 0x3c) {\n      if ((&digitalPin)[pinNumber] == NC) {\n        isServo = false;\n      }\n      else {\n        digitalPin = pinNumberNametoDigitalPin((&digitalPin)[pinNumber]);\n        if (digitalPin == 0) {\n          isServo = false;\n        }\n        else {\n          digitalPin = pinNumberNametoDigitalPin((&digitalPin)[pinNumber]);\n          if (digitalPin == 1) {\n            isServo = false;\n          }\n          else {\n            isServo = true;\n          }\n        }\n      }\n    }\n    else {\n      isServo = false;\n    }\n    if (isServo) {\n      Servo::write(servos + servoPinMap[pinNumber],pinValue,servoConfiguration,(size_t)servos);\n    }\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,pinValue);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000214": "handle_pin_value_08000214",
                "pin": "pinNumber",
                "value": "pinValue",
                "bVar1": "isServo",
                "bVar2": "pinMode",
                "_Var3": "isValidPin",
                "ulPin": "pinNumber",
                "uVar4": "digitalPin",
                "in_r2": "servoConfiguration"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "getPinMode",
                "write",
                "setPinState",
                "analogWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002ec": {
            "entrypoint": "0x080002ec",
            "current_name": "update_digital_pins_080002ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDigitalPins_080002ec(byte pinGroup,int pinValues)\n\n{\n  bool isPinEnabled;\n  byte pinModeVal;\n  uint pinGroupNum;\n  uint32_t digitalPinNum;\n  int pinState;\n  byte pinNum;\n  uint32_t currentPin;\n  uint bitMask;\n  byte lastPin;\n  uint bitPosition;\n  byte pin;\n  byte pin_1;\n  uint32_t currentPin_00;\n  uint uVar8;\n  byte pinValue;\n  \n  pinGroupNum = (uint)pinGroup;\n  if (pinGroupNum < 5) {\n    bitPosition = (pinGroupNum + 1 & 0x1f) * 8;\n    if (0x3c < bitPosition) {\n      bitPosition = 0x3c;\n    }\n    uVar8 = 0;\n    bitMask = 1;\n    currentPin_00 = (pinGroupNum & 0x1f) * 8;\n    for (currentPin = currentPin_00; currentPin < bitPosition; currentPin = currentPin + 1 & 0xff) {\n      if (currentPin < 0x3c) {\n        if ((&digitalPin)[currentPin] == NC) {\n          isPinEnabled = false;\n        }\n        else {\n          digitalPinNum = pinNametoDigitalPin((&digitalPin)[currentPin]);\n          if (digitalPinNum == 0) {\n            isPinEnabled = false;\n          }\n          else {\n            digitalPinNum = pinNametoDigitalPin((&digitalPin)[currentPin]);\n            if (digitalPinNum == 1) {\n              isPinEnabled = false;\n            }\n            else {\n              isPinEnabled = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinEnabled = false;\n      }\n      if (isPinEnabled) {\n        pinNum = (byte)currentPin;\n        pinModeVal = firmata::FirmataClass::getPinMode(&Firmata,pinNum);\n        if ((pinModeVal != '\\x01') &&\n           (pinModeVal = firmata::FirmataClass::getPinMode(&Firmata,pinNum), pinModeVal != '\\0')) {\n          isPinEnabled = false;\n        }\n        if (isPinEnabled) {\n          pinGroupNum = (uint)((bitMask & pinValues) != 0);\n          pinModeVal = firmata::FirmataClass::getPinMode(&Firmata,pinNum);\n          if (pinModeVal == '\\x01') {\n            uVar8 = bitMask | uVar8;\n          }\n          else {\n            pinModeVal = firmata::FirmataClass::getPinMode(&Firmata,pinNum);\n            if (pinModeVal == '\\0') {\n              if (pinGroupNum == 0) {\n                isPinEnabled = false;\n              }\n              else {\n                pinState = firmata::FirmataClass::getPinState(&Firmata,pinNum);\n                if (pinState == 1) {\n                  isPinEnabled = false;\n                }\n              }\n            }\n            else {\n              isPinEnabled = false;\n            }\n            if (isPinEnabled) {\n              pinMode(currentPin,2);\n            }\n          }\n          firmata::FirmataClass::setPinState(&Firmata,pinNum,pinGroupNum);\n        }\n      }\n      bitMask = (bitMask & 0x7f) << 1;\n    }\n    if ((uVar8 & 1) != 0) {\n      digitalWrite(currentPin_00,pinValues & 1);\n    }\n    if ((uVar8 & 2) != 0) {\n      digitalWrite(currentPin_00 + 1,pinValues & 2);\n    }\n    if ((uVar8 & 4) != 0) {\n      digitalWrite(currentPin_00 + 2,pinValues & 4);\n    }\n    if ((uVar8 & 8) != 0) {\n      digitalWrite(currentPin_00 + 3,pinValues & 8);\n    }\n    if ((uVar8 & 0x10) != 0) {\n      digitalWrite(currentPin_00 + 4,pinValues & 0x10);\n    }\n    if ((uVar8 & 0x20) != 0) {\n      digitalWrite(currentPin_00 + 5,pinValues & 0x20);\n    }\n    if ((uVar8 & 0x40) != 0) {\n      digitalWrite(currentPin_00 + 6,pinValues & 0x40);\n    }\n    if ((uVar8 & 0x80) != 0) {\n      digitalWrite(currentPin_00 + 7,pinValues & 0x80);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002ec": "update_digital_pins_080002ec",
                "port": "pinGroup",
                "value": "pinValues",
                "bVar1": "isPinEnabled",
                "bVar2": "pinModeVal",
                "uVar3": "pinGroupNum",
                "uVar4": "digitalPinNum",
                "iVar5": "pinState",
                "pin_00": "pinNum",
                "ulPin": "currentPin",
                "uVar6": "bitMask",
                "uVar7": "bitPosition"
            },
            "calling": [],
            "called": [
                "digitalWrite",
                "getPinState",
                "pinNametoDigitalPin",
                "getPinMode",
                "setPinState",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000488": {
            "entrypoint": "0x08000488",
            "current_name": "update_analog_pin_08000488",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAnalogPin_08000488(byte pin,int pinValue)\n\n{\n  uint convertedPin;\n  uint32_t convertedValue;\n  \n  convertedPin = (uint)pin;\n  if (convertedPin < 0xe) {\n    if (pinValue == 0) {\n      analogInputsToReport = analogInputsToReport & ~(1 << convertedPin);\n      return;\n    }\n    analogInputsToReport = 1 << convertedPin | analogInputsToReport;\n    if (!isResetting) {\n      convertedValue = analogRead(convertedPin);\n      firmata::FirmataClass::sendAnalog(&Firmata,pin,convertedValue);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000488": "update_analog_pin_08000488",
                "analogPin": "pin",
                "value": "pinValue",
                "ulPin": "convertedPin",
                "value_00": "convertedValue"
            },
            "calling": [
                "setPinModeCallback"
            ],
            "called": [
                "analogRead",
                "sendAnalog"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d4": {
            "entrypoint": "0x080004d4",
            "current_name": "initialize_servos_080004d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServos_080004d4(int initialize_flag,int priority_level)\n\n{\n  int loop_counter;\n  Servo *current_servo;\n  \n  if (initialize_flag != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    current_servo = servo_array;\n    for (loop_counter = 0xb; -1 < loop_counter; loop_counter = loop_counter + -1) {\n      Servo::Servo(current_servo);\n      current_servo = current_servo + 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "initialize_flag",
                "__priority": "priority_level",
                "iVar1": "loop_counter",
                "this": "current_servo",
                "servos": "servo_array"
            },
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "called": [
                "Servo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000500": {
            "entrypoint": "0x08000500",
            "current_name": "attach_servo_08000500",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid attachServo_08000500(byte servoPin,int minPulseDuration,int maxPulseDuration)\n\n{\n  uint convertedPin;\n  \n  convertedPin = (uint)servoPin;\n  if (0xb < attachedServoCount) {\n    firmata::firmataObjectClass::sendString(&firmataObject,\"Max servosArray attached\");\n    return;\n  }\n  if (detachedServoCounter == 0) {\n    pinServoMapping[convertedPin] = attachedServoCount;\n    attachedServoCount = attachedServoCount + '\\x01';\n  }\n  else {\n    pinServoMapping[convertedPin] = (&DAT_2000011f)[detachedServoCounter];\n    detachedServoCounter = detachedServoCounter + 0xff;\n  }\n  if ((0 < minPulseDuration) && (0 < maxPulseDuration)) {\n    Servo::attach(servosArray + pinServoMapping[convertedPin],convertedPin,minPulseDuration,maxPulseDuration);\n    return;\n  }\n  Servo::attach(servosArray + pinServoMapping[convertedPin],convertedPin);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000500": "attach_servo_08000500",
                "pin": "servoPin",
                "minPulse": "minPulseDuration",
                "maxPulse": "maxPulseDuration",
                "pin_00": "convertedPin",
                "servoCount": "attachedServoCount",
                "Firmata": "firmataObject",
                "servoPinMap": "pinServoMapping",
                "detachedServoCount": "detachedServoCounter",
                "servos": "servosArray"
            },
            "calling": [
                "setPinModeCallback",
                "sysexCallback"
            ],
            "called": [
                "attach",
                "attach",
                "sendString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000588": {
            "entrypoint": "0x08000588",
            "current_name": "detach_servo_08000588",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid detachServo_08000588(byte pin)\n\n{\n  Servo::detach(servoArray + pinMapping[pin]);\n  if ((pinMapping[pin] == activeServoCount) && (activeServoCount != '\\0')) {\n    activeServoCount = activeServoCount + 0xff;\n  }\n  else if (activeServoCount != '\\0') {\n    inactiveServoCount = inactiveServoCount + 1;\n    (&DAT_2000011f)[inactiveServoCount] = pinMapping[pin];\n  }\n  pinMapping[pin] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000588": "detach_servo_08000588",
                "servos": "servoArray",
                "servoPinMap": "pinMapping",
                "servoCount": "activeServoCount",
                "detachedServoCount": "inactiveServoCount"
            },
            "calling": [
                "setPinModeCallback",
                "sysexCallback"
            ],
            "called": [
                "detach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "disable_i2_c_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableI2C_080005e0(void)\n\n{\n  isEnabled = false;\n  currentIndex = -1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "disable_i2_c_080005e0",
                "isI2CEnabled": "isEnabled",
                "queryIndex": "currentIndex"
            },
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005f8": {
            "entrypoint": "0x080005f8",
            "current_name": "configure_pin_080005f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_080005f8(byte pinNumber,int pinMode)\n\n{\n  byte pinModeReturnValue;\n  PinName_conflict pinNameConflict;\n  bool isDigitalPin;\n  bool isServoAttached;\n  _Bool isPinInPinmap;\n  uint unsignedPinNumber;\n  uint32_t pinToDigitalPinReturnValue;\n  char isI2CEnabled;\n  uint analogPinNumber;\n  \n  unsignedPinNumber = (uint)pinNumber;\n  pinModeReturnValue = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n  if (pinModeReturnValue != '\\x7f') {\n    pinModeReturnValue = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n    if (pinModeReturnValue == '\\x06') {\n      if (isI2CEnabled == false) {\n        isI2CEnabled = '\\0';\n      }\n      else {\n        isI2CEnabled = isI2CEnabled;\n        if (pinMode == 6) {\n          isI2CEnabled = '\\0';\n        }\n      }\n    }\n    else {\n      isI2CEnabled = '\\0';\n    }\n    if (isI2CEnabled != '\\0') {\n      disableI2CPins();\n    }\n    if (unsignedPinNumber < 0x3c) {\n      if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n        isDigitalPin = false;\n      }\n      else {\n        pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n        if (pinToDigitalPinReturnValue == 0) {\n          isDigitalPin = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 1) {\n            isDigitalPin = false;\n          }\n          else if (pinMode == 4) {\n            isDigitalPin = false;\n          }\n          else {\n            isDigitalPin = true;\n          }\n        }\n      }\n    }\n    else {\n      isDigitalPin = false;\n    }\n    if (isDigitalPin) {\n      if (servoPinMap[unsignedPinNumber] < 0xc) {\n        isDigitalPin = Servo::attached(servos + servoPinMap[unsignedPinNumber]);\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin != false) {\n        detachServo(pinNumber);\n      }\n    }\n    analogPinNumber = unsignedPinNumber - 0x2e & 0xff;\n    if (analogPinNumber < 0xe) {\n      if (unsignedPinNumber < 0x3c) {\n        pinNameConflict = (&digitalPin)[unsignedPinNumber];\n      }\n      else {\n        pinNameConflict = NotConnectedPin;\n      }\n      pinToDigitalPinReturnValue = pinNumberNametoDigitalPin(pinNameConflict);\n      if (pinToDigitalPinReturnValue == 0) {\n        isDigitalPin = false;\n      }\n      else {\n        if (unsignedPinNumber < 0x3c) {\n          pinNameConflict = (&digitalPin)[unsignedPinNumber];\n        }\n        else {\n          pinNameConflict = NotConnectedPin;\n        }\n        pinToDigitalPinReturnValue = pinNumberNametoDigitalPin(pinNameConflict);\n        if (pinToDigitalPinReturnValue == 1) {\n          isDigitalPin = false;\n        }\n        else {\n          isDigitalPin = true;\n        }\n      }\n    }\n    else {\n      isDigitalPin = false;\n    }\n    if (isDigitalPin) {\n      reportAnalogCallback((byte)analogPinNumber,(uint)(pinMode == 2));\n    }\n    if (unsignedPinNumber < 0x3c) {\n      if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n        isDigitalPin = false;\n      }\n      else {\n        pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n        if (pinToDigitalPinReturnValue == 0) {\n          isDigitalPin = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 1) {\n            isDigitalPin = false;\n          }\n          else {\n            isDigitalPin = true;\n          }\n        }\n      }\n    }\n    else {\n      isDigitalPin = false;\n    }\n    if (isDigitalPin) {\n      if ((pinMode == 0) || (pinMode == 0xb)) {\n        portConfigInputs[pinNumber >> 3] = portConfigInputs[pinNumber >> 3] | (byte)(1 << (unsignedPinNumber & 7));\n      }\n      else {\n        portConfigInputs[pinNumber >> 3] = portConfigInputs[pinNumber >> 3] & ~(byte)(1 << (unsignedPinNumber & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState(&Firmata,pinNumber,0);\n    switch(pinMode) {\n    case 0:\n      if (unsignedPinNumber < 0x3c) {\n        if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n          isDigitalPin = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 0) {\n            isDigitalPin = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 1) {\n              isDigitalPin = false;\n            }\n            else {\n              isDigitalPin = true;\n            }\n          }\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin) {\n        pinNumberMode(unsignedPinNumber,0);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (unsignedPinNumber < 0x3c) {\n        if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n          isDigitalPin = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 0) {\n            isDigitalPin = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 1) {\n              isDigitalPin = false;\n            }\n            else {\n              isDigitalPin = true;\n            }\n          }\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin) {\n        pinModeReturnValue = firmata::FirmataClass::getPinMode(&Firmata,pinNumber);\n        if (pinModeReturnValue == '\\x03') {\n          digitalWrite(unsignedPinNumber,0);\n        }\n        pinNumberMode(unsignedPinNumber,1);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (analogPinNumber < 0xe) {\n        if (unsignedPinNumber < 0x3c) {\n          pinNameConflict = (&digitalPin)[unsignedPinNumber];\n        }\n        else {\n          pinNameConflict = NotConnectedPin;\n        }\n        pinToDigitalPinReturnValue = pinNumberNametoDigitalPin(pinNameConflict);\n        if (pinToDigitalPinReturnValue == 0) {\n          isDigitalPin = false;\n        }\n        else {\n          if (unsignedPinNumber < 0x3c) {\n            pinNameConflict = (&digitalPin)[unsignedPinNumber];\n          }\n          else {\n            pinNameConflict = NotConnectedPin;\n          }\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin(pinNameConflict);\n          if (pinToDigitalPinReturnValue == 1) {\n            isDigitalPin = false;\n          }\n          else {\n            isDigitalPin = true;\n          }\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin) {\n        if (unsignedPinNumber < 0x3c) {\n          if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n            isDigitalPin = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 0) {\n              isDigitalPin = false;\n            }\n            else {\n              pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n              if (pinToDigitalPinReturnValue == 1) {\n                isDigitalPin = false;\n              }\n            }\n          }\n        }\n        else {\n          isDigitalPin = false;\n        }\n        if (isDigitalPin) {\n          pinNumberMode(unsignedPinNumber,0);\n        }\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (unsignedPinNumber < 0x3c) {\n        if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n          isPinInPinmap = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 0) {\n            isPinInPinmap = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 1) {\n              isPinInPinmap = false;\n            }\n            else {\n              isPinInPinmap = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPinNumber],(PinMap_conflict *)&PinMap_PWM);\n            }\n          }\n        }\n      }\n      else {\n        isPinInPinmap = false;\n      }\n      if (isPinInPinmap != false) {\n        pinNumberMode(unsignedPinNumber,1);\n        analogWrite(unsignedPinNumber,0);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (unsignedPinNumber < 0x3c) {\n        if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n          isDigitalPin = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 0) {\n            isDigitalPin = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 1) {\n              isDigitalPin = false;\n            }\n            else {\n              isDigitalPin = true;\n            }\n          }\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin) {\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x04');\n        if ((servoPinMap[unsignedPinNumber] != 0xff) &&\n           (isServoAttached = Servo::attached(servos + servoPinMap[unsignedPinNumber]), isServoAttached)) {\n          isDigitalPin = false;\n        }\n        if (isDigitalPin) {\n          attachServo(pinNumber,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString(&Firmata,\"Unknown pinNumber pinMode\");\n      break;\n    case 6:\n      if (unsignedPinNumber < 0x3c) {\n        if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n          isPinInPinmap = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 0) {\n            isPinInPinmap = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 1) {\n              isPinInPinmap = false;\n            }\n            else {\n              isPinInPinmap = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPinNumber],(PinMap_conflict *)&PinMap_I2C_SDA);\n              if (!isPinInPinmap) {\n                isPinInPinmap = pinNumber_in_pinNumbermap((&digitalPin)[unsignedPinNumber],(PinMap_conflict *)&PinMap_I2C_SCL);\n              }\n            }\n          }\n        }\n      }\n      else {\n        isPinInPinmap = false;\n      }\n      if (isPinInPinmap != false) {\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (unsignedPinNumber < 0x3c) {\n        if ((&digitalPin)[unsignedPinNumber] == NotConnectedPin) {\n          isDigitalPin = false;\n        }\n        else {\n          pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n          if (pinToDigitalPinReturnValue == 0) {\n            isDigitalPin = false;\n          }\n          else {\n            pinToDigitalPinReturnValue = pinNumberNametoDigitalPin((&digitalPin)[unsignedPinNumber]);\n            if (pinToDigitalPinReturnValue == 1) {\n              isDigitalPin = false;\n            }\n            else {\n              isDigitalPin = true;\n            }\n          }\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      if (isDigitalPin) {\n        pinNumberMode(unsignedPinNumber,2);\n        firmata::FirmataClass::setPinMode(&Firmata,pinNumber,'\\v');\n        firmata::FirmataClass::setPinState(&Firmata,pinNumber,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005f8": "configure_pin_080005f8",
                "pin": "pinNumber",
                "mode": "pinMode",
                "bVar1": "pinModeReturnValue",
                "bVar3": "isDigitalPin",
                "bVar4": "isServoAttached",
                "_Var5": "isPinInPinmap",
                "ulPin": "unsignedPinNumber",
                "uVar6": "pinToDigitalPinReturnValue",
                "cVar7": "isI2CEnabled",
                "uVar8": "analogPinNumber",
                "PVar2": "pinNameConflict",
                "NC": "NotConnectedPin"
            },
            "calling": [
                "systemResetCallback",
                "enableI2CPins",
                "sysexCallback"
            ],
            "called": [
                "attached",
                "disableI2CPins",
                "setPinMode",
                "setPinState",
                "analogWrite",
                "reportAnalogCallback",
                "digitalWrite",
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "detachServo",
                "getPinMode",
                "sendString",
                "pinMode",
                "attachServo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a64": {
            "entrypoint": "0x08000a64",
            "current_name": "initialize_i2_c_interface_08000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2CInterface_08000a64(void)\n\n{\n  _Bool isPinValid;\n  uint32_t pinToValidate;\n  uint counter;\n  \n  for (counter = 0; counter < 0x3c; counter = counter + 1 & 0xff) {\n    if (counter < 0x3c) {\n      if ((&pinMapping)[counter] == NotConnected) {\n        isPinValid = false;\n      }\n      else {\n        pinToValidate = getDigitalPin((&pinMapping)[counter]);\n        if (pinToValidate == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinToValidate = getDigitalPin((&pinMapping)[counter]);\n          if (pinToValidate == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = isPinInPinMap((&pinMapping)[counter],(ConflictPinMap *)&I2C_SDA_PinMap);\n            if (!isPinValid) {\n              isPinValid = isPinInPinMap((&pinMapping)[counter],(ConflictPinMap *)&I2C_SCL_PinMap);\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid != false) {\n      setPinMode((byte)counter,6);\n    }\n  }\n  I2CEnabled = true;\n  TwoI2CInterface::begin(&I2CInterface);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a64": "initialize_i2_c_interface_08000a64",
                "uVar3": "counter",
                "_Var1": "isPinValid",
                "uVar2": "pinToValidate",
                "NC": "NotConnected",
                "digitalPin": "pinMapping",
                "pinNametoDigitalPin": "getDigitalPin",
                "pin_in_pinmap": "isPinInPinMap",
                "PinMap_conflict": "ConflictPinMap",
                "PinMap_I2C_SDA": "I2C_SDA_PinMap",
                "PinMap_I2C_SCL": "I2C_SCL_PinMap",
                "setPinModeCallback": "setPinMode",
                "isI2CEnabled": "I2CEnabled",
                "Wire": "I2CInterface"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "begin",
                "setPinModeCallback",
                "pinNametoDigitalPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "initialize_device_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDevice_08000aec(void)\n\n{\n  bool bVar1;\n  PinName_conflict PVar2;\n  uint32_t uVar3;\n  byte i;\n  uint uVar4;\n  byte i_1;\n  \n  isDeviceResetting = true;\n  if (isI2CEnabled) {\n    disableI2C();\n  }\n  for (uVar4 = 0; uVar4 < 5; uVar4 = uVar4 + 1 & 0xff) {\n    reportedPins[uVar4] = '\\0';\n    inputConfigurations[uVar4] = '\\0';\n    previousPins[uVar4] = '\\0';\n  }\n  for (uVar4 = 0; uVar4 < 0x3c; uVar4 = uVar4 + 1 & 0xff) {\n    if ((uVar4 - 0x2e & 0xff) < 0xe) {\n      if (uVar4 < 0x3c) {\n        PVar2 = (&pinMapping)[uVar4];\n      }\n      else {\n        PVar2 = NotConnected;\n      }\n      uVar3 = mapDigitalPin(PVar2);\n      if (uVar3 == 0) {\n        bVar1 = false;\n      }\n      else {\n        if (uVar4 < 0x3c) {\n          PVar2 = (&pinMapping)[uVar4];\n        }\n        else {\n          PVar2 = NotConnected;\n        }\n        uVar3 = mapDigitalPin(PVar2);\n        if (uVar3 == 1) {\n          bVar1 = false;\n        }\n        else {\n          bVar1 = true;\n        }\n      }\n    }\n    else {\n      bVar1 = false;\n    }\n    if (bVar1) {\n      setPinMode((byte)uVar4,2);\n    }\n    else {\n      if ((((uVar4 < 0x3c) && ((&pinMapping)[uVar4] != NotConnected)) &&\n          (uVar3 = mapDigitalPin((&pinMapping)[uVar4]), uVar3 != 0)) &&\n         (uVar3 = mapDigitalPin((&pinMapping)[uVar4]), uVar3 != 1)) {\n        bVar1 = true;\n      }\n      if (bVar1) {\n        setPinMode((byte)uVar4,1);\n      }\n    }\n    servoPinMapping[uVar4] = 0xff;\n  }\n  analogInputsReported = 0;\n  detachedServoCount = '\\0';\n  servoCount = '\\0';\n  isDeviceResetting = false;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "initialize_device_08000aec",
                "isResetting": "isDeviceResetting",
                "disableI2CPins": "disableI2C",
                "reportPINs": "reportedPins",
                "portConfigInputs": "inputConfigurations",
                "previousPINs": "previousPins",
                "digitalPin": "pinMapping",
                "NC": "NotConnected",
                "pinNametoDigitalPin": "mapDigitalPin",
                "setPinModeCallback": "setPinMode",
                "servoPinMap": "servoPinMapping",
                "analogInputsToReport": "analogInputsReported"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "pinNametoDigitalPin",
                "setPinModeCallback",
                "disableI2CPins"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000be8": {
            "entrypoint": "0x08000be8",
            "current_name": "send_digital_port_if_needed_08000be8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendDigitalPortIfNeeded_08000be8(byte portNum,byte portVal,byte force)\n\n{\n  byte input;\n  \n  input = portConfigInputs[portNum] & portVal;\n  if ((force != '\\0') || ((uint)input != (uint)previousPINs[portNum])) {\n    firmata::FirmataClass::sendDigitalPort(&firmataInstance,portNum,(uint)input);\n    previousPINs[portNum] = input;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000be8": "send_digital_port_if_needed_08000be8",
                "portNumber": "portNum",
                "portValue": "portVal",
                "forceSend": "force",
                "bVar1": "input",
                "&Firmata": "&firmataInstance"
            },
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "called": [
                "sendDigitalPort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c18": {
            "entrypoint": "0x08000c18",
            "current_name": "read_port_values_08000c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readPortValues_08000c18(byte portNumber,int portValue)\n\n{\n  byte inputConfig;\n  bool isPinHigh;\n  uint32_t digitalPinValue;\n  int readResult;\n  uchar pin;\n  uint portIndex;\n  byte outputValue;\n  \n  portIndex = (uint)portNumber;\n  if ((portIndex < 5) && (reportNumberPINs[portIndex] = (byte)portValue, portValue != 0)) {\n    inputConfig = portNumberConfigInputs[portIndex];\n    portIndex = (portIndex & 0x1f) * 8;\n    if (portIndex < 0x3c) {\n      if ((&digitalPin)[portIndex] == NC) {\n        outputValue = 0;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&digitalPin)[portIndex]);\n        if (digitalPinValue == 0) {\n          outputValue = 0;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&digitalPin)[portIndex]);\n          if (digitalPinValue == 1) {\n            outputValue = 0;\n          }\n          else if ((inputConfig & 1) == 0) {\n            outputValue = 0;\n          }\n          else {\n            readResult = digitalRead(portIndex);\n            if (readResult == 0) {\n              outputValue = 0;\n            }\n            else {\n              outputValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      outputValue = 0;\n    }\n    if (portIndex + 1 < 0x3c) {\n      if ((&DAT_0800a909)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a909)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a909)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 2) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 1);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 2;\n    }\n    if (portIndex + 2 < 0x3c) {\n      if ((&DAT_0800a90a)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a90a)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a90a)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 4) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 2);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 4;\n    }\n    if (portIndex + 3 < 0x3c) {\n      if ((&DAT_0800a90b)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a90b)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a90b)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 8) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 3);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 8;\n    }\n    if (portIndex + 4 < 0x3c) {\n      if ((&DAT_0800a90c)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a90c)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a90c)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 0x10) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 4);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 0x10;\n    }\n    if (portIndex + 5 < 0x3c) {\n      if ((&DAT_0800a90d)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a90d)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a90d)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 0x20) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 5);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 0x20;\n    }\n    if (portIndex + 6 < 0x3c) {\n      if ((&DAT_0800a90e)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a90e)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a90e)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 0x40) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 6);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 0x40;\n    }\n    if (portIndex + 7 < 0x3c) {\n      if ((&DAT_0800a90f)[portIndex] == NC) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinValue = pinNametoDigitalPin((&DAT_0800a90f)[portIndex]);\n        if (digitalPinValue == 0) {\n          isPinHigh = false;\n        }\n        else {\n          digitalPinValue = pinNametoDigitalPin((&DAT_0800a90f)[portIndex]);\n          if (digitalPinValue == 1) {\n            isPinHigh = false;\n          }\n          else if ((inputConfig & 0x80) == 0) {\n            isPinHigh = false;\n          }\n          else {\n            readResult = digitalRead(portIndex + 7);\n            if (readResult == 0) {\n              isPinHigh = false;\n            }\n            else {\n              isPinHigh = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinHigh = false;\n    }\n    if (isPinHigh) {\n      outputValue = outputValue | 0x80;\n    }\n    outputPort(portNumber,outputValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c18": "read_port_values_08000c18",
                "port": "portNumber",
                "value": "portValue",
                "bVar1": "inputConfig",
                "bVar2": "isPinHigh",
                "uVar3": "digitalPinValue",
                "uVar5": "portIndex",
                "iVar4": "readResult",
                "portValue": "outputValue"
            },
            "calling": [],
            "called": [
                "outputPort",
                "pinNametoDigitalPin",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ef8": {
            "entrypoint": "0x08000ef8",
            "current_name": "read_inputs_and_output_08000ef8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001ade) */\n/* WARNING: Removing unreachable block (ram,0x08001a4a) */\n/* WARNING: Removing unreachable block (ram,0x080019b6) */\n/* WARNING: Removing unreachable block (ram,0x08001912) */\n/* WARNING: Removing unreachable block (ram,0x08001866) */\n/* WARNING: Removing unreachable block (ram,0x080017d2) */\n/* WARNING: Removing unreachable block (ram,0x0800173e) */\n/* WARNING: Removing unreachable block (ram,0x0800169a) */\n/* WARNING: Removing unreachable block (ram,0x080015ee) */\n/* WARNING: Removing unreachable block (ram,0x0800155a) */\n/* WARNING: Removing unreachable block (ram,0x08001490) */\n/* WARNING: Removing unreachable block (ram,0x080014a2) */\n/* WARNING: Removing unreachable block (ram,0x080014e4) */\n/* WARNING: Removing unreachable block (ram,0x080014b0) */\n/* WARNING: Removing unreachable block (ram,0x080014ba) */\n/* WARNING: Removing unreachable block (ram,0x080014e8) */\n/* WARNING: Removing unreachable block (ram,0x080014c2) */\n/* WARNING: Removing unreachable block (ram,0x080014b6) */\n/* WARNING: Removing unreachable block (ram,0x08001496) */\n/* WARNING: Removing unreachable block (ram,0x08001430) */\n/* WARNING: Removing unreachable block (ram,0x08001376) */\n/* WARNING: Removing unreachable block (ram,0x080012e2) */\n/* WARNING: Removing unreachable block (ram,0x0800124e) */\n/* WARNING: Removing unreachable block (ram,0x080011b8) */\n/* WARNING: Removing unreachable block (ram,0x08001100) */\n/* WARNING: Removing unreachable block (ram,0x0800106c) */\n/* WARNING: Removing unreachable block (ram,0x08000fd8) */\n/* WARNING: Removing unreachable block (ram,0x08000f42) */\n/* WARNING: Removing unreachable block (ram,0x08000f8e) */\n/* WARNING: Removing unreachable block (ram,0x08001022) */\n/* WARNING: Removing unreachable block (ram,0x080010b6) */\n/* WARNING: Removing unreachable block (ram,0x0800114a) */\n/* WARNING: Removing unreachable block (ram,0x08001204) */\n/* WARNING: Removing unreachable block (ram,0x08001298) */\n/* WARNING: Removing unreachable block (ram,0x0800132c) */\n/* WARNING: Removing unreachable block (ram,0x080013c0) */\n/* WARNING: Removing unreachable block (ram,0x0800147c) */\n/* WARNING: Removing unreachable block (ram,0x08001510) */\n/* WARNING: Removing unreachable block (ram,0x080015a4) */\n/* WARNING: Removing unreachable block (ram,0x08001638) */\n/* WARNING: Removing unreachable block (ram,0x080016f4) */\n/* WARNING: Removing unreachable block (ram,0x08001788) */\n/* WARNING: Removing unreachable block (ram,0x0800181c) */\n/* WARNING: Removing unreachable block (ram,0x080018b0) */\n/* WARNING: Removing unreachable block (ram,0x0800196c) */\n/* WARNING: Removing unreachable block (ram,0x08001a00) */\n/* WARNING: Removing unreachable block (ram,0x08001a94) */\n/* WARNING: Removing unreachable block (ram,0x08001b28) */\n/* WARNING: Removing unreachable block (ram,0x080014ca) */\n/* WARNING: Unknown calling convention */\n\nvoid readInputsAndOutput_08000ef8(void)\n\n{\n  bool isDigitalHigh;\n  byte portConfig;\n  uint32_t pinValue;\n  int digitalValue;\n  byte outputValue;\n  \n  portConfig = inputConfig[0];\n  if (reportPins[0] != '\\0') {\n    pinValue = pinNametoDigitalPin(PA_3);\n    if (pinValue == 0) {\n      outputValue = 0;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_3);\n      if (pinValue == 1) {\n        outputValue = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        outputValue = 0;\n      }\n      else {\n        digitalValue = digitalRead(0);\n        if (digitalValue == 0) {\n          outputValue = 0;\n        }\n        else {\n          outputValue = 1;\n        }\n      }\n    }\n    pinValue = pinNametoDigitalPin(PA_2);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_2);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(1);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 2;\n    }\n    pinValue = pinNametoDigitalPin(PA_10);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_10);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(2);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 4;\n    }\n    pinValue = pinNametoDigitalPin(PB_3);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_3);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(3);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 8;\n    }\n    pinValue = pinNametoDigitalPin(PB_5);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_5);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(4);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x10;\n    }\n    pinValue = pinNametoDigitalPin(PB_4);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_4);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(5);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x20;\n    }\n    pinValue = pinNametoDigitalPin(PB_10);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_10);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(6);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x40;\n    }\n    pinValue = pinNametoDigitalPin(PA_8);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_8);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(7);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x80;\n    }\n    outputPort('\\0',outputValue,'\\0');\n  }\n  portConfig = inputConfig[1];\n  if (reportPins[1] != '\\0') {\n    pinValue = pinNametoDigitalPin(PA_9);\n    if (pinValue == 0) {\n      outputValue = 0;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_9);\n      if (pinValue == 1) {\n        outputValue = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        outputValue = 0;\n      }\n      else {\n        digitalValue = digitalRead(8);\n        if (digitalValue == 0) {\n          outputValue = 0;\n        }\n        else {\n          outputValue = 1;\n        }\n      }\n    }\n    pinValue = pinNametoDigitalPin(PC_7);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_7);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(9);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 2;\n    }\n    pinValue = pinNametoDigitalPin(PB_6);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_6);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(10);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 4;\n    }\n    pinValue = pinNametoDigitalPin(PA_7);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_7);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0xb);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 8;\n    }\n    pinValue = pinNametoDigitalPin(PA_6);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_6);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0xc);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x10;\n    }\n    pinValue = pinNametoDigitalPin(PA_5);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_5);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0xd);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x20;\n    }\n    pinValue = pinNametoDigitalPin(PB_9);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_9);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0xe);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x40;\n    }\n    pinValue = pinNametoDigitalPin(PB_8);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_8);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0xf);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x80;\n    }\n    outputPort('\\x01',outputValue,'\\0');\n  }\n  portConfig = inputConfig[2];\n  if (reportPins[2] != '\\0') {\n    pinValue = pinNametoDigitalPin(PC_10);\n    if (pinValue == 0) {\n      outputValue = 0;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_10);\n      if (pinValue == 1) {\n        outputValue = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        outputValue = 0;\n      }\n      else {\n        digitalValue = digitalRead(0x10);\n        if (digitalValue == 0) {\n          outputValue = 0;\n        }\n        else {\n          outputValue = 1;\n        }\n      }\n    }\n    pinValue = pinNametoDigitalPin(PC_12);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_12);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x11);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 2;\n    }\n    pinValue = pinNametoDigitalPin(PA_13);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_13);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x13);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 8;\n    }\n    pinValue = pinNametoDigitalPin(PA_14);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_14);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x14);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x10;\n    }\n    pinValue = pinNametoDigitalPin(PA_15);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_15);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x15);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x20;\n    }\n    pinValue = pinNametoDigitalPin(PB_7);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_7);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x16);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x40;\n    }\n    pinValue = pinNametoDigitalPin(PC_13);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_13);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x17);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x80;\n    }\n    outputPort('\\x02',outputValue,'\\0');\n  }\n  portConfig = inputConfig[3];\n  if (reportPins[3] != '\\0') {\n    pinValue = pinNametoDigitalPin(PC_14);\n    if (pinValue == 0) {\n      outputValue = 0;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_14);\n      if (pinValue == 1) {\n        outputValue = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        outputValue = 0;\n      }\n      else {\n        digitalValue = digitalRead(0x18);\n        if (digitalValue == 0) {\n          outputValue = 0;\n        }\n        else {\n          outputValue = 1;\n        }\n      }\n    }\n    pinValue = pinNametoDigitalPin(PC_15);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_15);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x19);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 2;\n    }\n    pinValue = pinNametoDigitalPin(PD_0);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PD_0);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x1a);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 4;\n    }\n    pinValue = pinNametoDigitalPin(PD_1);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PD_1);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x1b);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 8;\n    }\n    pinValue = pinNametoDigitalPin(PC_2);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_2);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x1c);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x10;\n    }\n    pinValue = pinNametoDigitalPin(PC_3);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_3);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x1d);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x20;\n    }\n    pinValue = pinNametoDigitalPin(PC_11);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_11);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x1e);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x40;\n    }\n    pinValue = pinNametoDigitalPin(PD_2);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PD_2);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x1f);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x80;\n    }\n    outputPort('\\x03',outputValue,'\\0');\n  }\n  portConfig = inputConfig[4];\n  if (reportPins[4] != '\\0') {\n    pinValue = pinNametoDigitalPin(PC_9);\n    if (pinValue == 0) {\n      outputValue = 0;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_9);\n      if (pinValue == 1) {\n        outputValue = 0;\n      }\n      else if ((portConfig & 1) == 0) {\n        outputValue = 0;\n      }\n      else {\n        digitalValue = digitalRead(0x20);\n        if (digitalValue == 0) {\n          outputValue = 0;\n        }\n        else {\n          outputValue = 1;\n        }\n      }\n    }\n    pinValue = pinNametoDigitalPin(PC_8);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_8);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 2) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x21);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 2;\n    }\n    pinValue = pinNametoDigitalPin(PC_6);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_6);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 4) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x22);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 4;\n    }\n    pinValue = pinNametoDigitalPin(PC_5);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PC_5);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 8) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x23);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 8;\n    }\n    pinValue = pinNametoDigitalPin(PA_12);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_12);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x10) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x24);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x10;\n    }\n    pinValue = pinNametoDigitalPin(PA_11);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PA_11);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x20) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x25);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x20;\n    }\n    pinValue = pinNametoDigitalPin(PB_12);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_12);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x40) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x26);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x40;\n    }\n    pinValue = pinNametoDigitalPin(PB_11);\n    if (pinValue == 0) {\n      isDigitalHigh = false;\n    }\n    else {\n      pinValue = pinNametoDigitalPin(PB_11);\n      if (pinValue == 1) {\n        isDigitalHigh = false;\n      }\n      else if ((portConfig & 0x80) == 0) {\n        isDigitalHigh = false;\n      }\n      else {\n        digitalValue = digitalRead(0x27);\n        if (digitalValue == 0) {\n          isDigitalHigh = false;\n        }\n        else {\n          isDigitalHigh = true;\n        }\n      }\n    }\n    if (isDigitalHigh) {\n      outputValue = outputValue | 0x80;\n    }\n    outputPort('\\x04',outputValue,'\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ef8": "read_inputs_and_output_08000ef8",
                "portConfigInputs": "inputConfig",
                "reportPINs": "reportPins",
                "uVar3": "pinValue",
                "iVar4": "digitalValue",
                "bVar1": "isDigitalHigh",
                "bVar2": "portConfig",
                "bVar5": "outputValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "outputPort",
                "pinNametoDigitalPin",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_firmata_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFirmata_08001b48(void)\n\n{\n  firmata::FirmataClass::setFirmwareNameAndVersion\n            (firmataInstance,\"/home/bo/p2im/p2im-real_firmware_scratch/Gateway/StandardFirmata.ino\",'\\x02',\n             '\\x05');\n  firmata::FirmataClass::attach(firmataInstance,0xe0,analogWriteHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0x90,digitalWriteHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xc0,reportAnalogHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xd0,reportDigitalHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xf4,setPinModeHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xf5,setPinValueHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xf0,sysexHandler + 1);\n  firmata::FirmataClass::attach(firmataInstance,0xff,systemResetHandler);\n  firmata::FirmataClass::begin(firmataInstance,0xe100);\n  systemResetHandler();\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_firmata_08001b48",
                "&Firmata": "firmataInstance",
                "analogWriteCallback": "analogWriteHandler",
                "digitalWriteCallback": "digitalWriteHandler",
                "reportAnalogCallback": "reportAnalogHandler",
                "reportDigitalCallback": "reportDigitalHandler",
                "setPinModeCallback": "setPinModeHandler",
                "setPinValueCallback": "setPinValueHandler",
                "sysexCallback": "sysexHandler",
                "systemResetCallback": "systemResetHandler",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "systemResetCallback",
                "begin",
                "attach",
                "attach",
                "setFirmwareNameAndVersion",
                "startForkserver",
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_static_resources_08001be8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_resources_08001be8(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_static_resources_08001be8"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bf8": {
            "entrypoint": "0x08001bf8",
            "current_name": "send_data_over_i2_c_08001bf8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendDataOverI2C_08001bf8(byte byteToSend)\n\n{\n  void *pointerToBuffer;\n  size_t bufferSize;\n  \n  TwoWire::write(&Wire,(uint)byteToSend,pointerToBuffer,bufferSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001bf8": "send_data_over_i2_c_08001bf8",
                "data": "byteToSend",
                "in_r2": "pointerToBuffer",
                "in_r3": "bufferSize"
            },
            "calling": [
                "readAndReportData",
                "sysexCallback"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c08": {
            "entrypoint": "0x08001c08",
            "current_name": "read_from_wire_08001c08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbyte read_from_wire_08001c08(void)\n\n{\n  ssize_t read_result;\n  int input_1;\n  void *input_2;\n  size_t input_3;\n  \n  read_result = TwoWire::read(&Wire,input_1,input_2,input_3);\n  return (byte)read_result;\n}\n\n",
            "renaming": {
                "FUN_08001c08": "read_from_wire_08001c08",
                "in_r1": "input_1",
                "in_r2": "input_2",
                "in_r3": "input_3",
                "sVar1": "read_result"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c18": {
            "entrypoint": "0x08001c18",
            "current_name": "read_i2_c_data_08001c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readI2CData_08001c18(byte targetAddress,int registerValue,byte numberOfBytes,byte stopTransmission)\n\n{\n  bool isDataAvailable;\n  byte receivedByte;\n  int availableBytes;\n  int receivedBytes;\n  uint unsignedBytes;\n  \n  unsignedBytes = (uint)numberOfBytes;\n  if (registerValue == -1) {\n    registerValue = 0;\n  }\n  else {\n    TwoI2CWire::beginTransmission(&I2CWire,targetAddress);\n    wireWrite((byte)registerValue);\n    TwoI2CWire::endTransmission(&I2CWire,stopTransmission);\n  }\n  TwoI2CWire::requestFrom(&I2CWire,targetAddress,numberOfBytes);\n  availableBytes = TwoI2CWire::available(&I2CWire);\n  if ((int)unsignedBytes < availableBytes) {\n    firmata::firmataInstanceClass::sendString(&firmataInstance,\"I2C: Too many bytes received\");\n  }\n  else {\n    availableBytes = TwoI2CWire::available(&I2CWire);\n    if (availableBytes < (int)unsignedBytes) {\n      firmata::firmataInstanceClass::sendString(&firmataInstance,\"I2C: Too few bytes received\");\n    }\n  }\n  receivedData[1] = (byte)registerValue;\n  availableBytes = 0;\n  receivedData[0] = targetAddress;\n  while( true ) {\n    if (availableBytes < (int)unsignedBytes) {\n      receivedBytes = TwoI2CWire::available(&I2CWire);\n      if (receivedBytes == 0) {\n        isDataAvailable = false;\n      }\n      else {\n        isDataAvailable = true;\n      }\n    }\n    else {\n      isDataAvailable = false;\n    }\n    if (!isDataAvailable) break;\n    receivedByte = wireRead();\n    receivedData[availableBytes + 2] = receivedByte;\n    availableBytes = availableBytes + 1;\n  }\n  firmata::firmataInstanceClass::sendSysex(&firmataInstance,'w',numberOfBytes + '\\x02',receivedData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c18": "read_i2_c_data_08001c18",
                "address": "targetAddress",
                "theRegister": "registerValue",
                "numBytes": "numberOfBytes",
                "stopTX": "stopTransmission",
                "bVar1": "isDataAvailable",
                "bVar2": "receivedByte",
                "iVar3": "availableBytes",
                "iVar4": "receivedBytes",
                "uVar5": "unsignedBytes",
                "Wire": "I2CWire",
                "Firmata": "firmataInstance",
                "i2cRxData": "receivedData"
            },
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "called": [
                "wireRead",
                "sendSysex",
                "beginTransmission",
                "available",
                "requestFrom",
                "sendString",
                "endTransmission",
                "wireWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "improve_firmata_command_08001cd0",
            "code": "\n/* WARNING: Unknown callloopIndex1ng conventloopIndex1on */\n\nvoloopIndex1d improveFirmataCommand_08001cd0(byte cmd,byte argCount,byte *argValues)\n\n{\n  byte byteVar1;\n  uloopIndex1nt8_t deviceAddress;\n  byte byteVar2;\n  byte byteVar3;\n  byte byteVar4;\n  byte slaveAddress;\n  byte pinData;\n  PloopIndex1nName_conflloopIndex1ct pinName;\n  _Bool isPinValid;\n  byte byteVar7;\n  uloopIndex1nt32_t pinValue;\n  loopIndex1nt intVar1;\n  loopIndex1nt pinValue;\n  byte pinMode;\n  byte byteVar10;\n  byte stopTransmission;\n  byte loopIndex1;\n  byte loopIndex2;\n  undefloopIndex1ned1 *pinVariable1;\n  uloopIndex1nt tempValue;\n  uloopIndex1nt delayTloopIndex1me;\n  byte pinValue1;\n  undefloopIndex1ned1 *pinVariable2;\n  sloopIndex1ze_t sizeValue;\n  loopIndex1nt maxPulse;\n  byte pinValue;\n  uloopIndex1nt tempValue2;\n  loopIndex1nt mloopIndex1nPulse;\n  loopIndex1nt intVar2;\n  bool isServoAttached;\n  \n  tempValue2 = (uloopIndex1nt)argCount;\n  swloopIndex1tch(cmd) {\n  case 'loopIndex1':\n    floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xf0,argValues,(sloopIndex1ze_t)pinVariable1);\n    floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0x6a,argValues,(sloopIndex1ze_t)pinVariable1);\n    for (tempValue2 = 0; tempValue2 < 0x3c; tempValue2 = tempValue2 + 1 & 0xff) {\n      tempValue = tempValue2 - 0x2e & 0xff;\n      loopIndex1f (tempValue < 0xe) {\n        loopIndex1f (tempValue2 < 0x3c) {\n          pinVariable1 = &dloopIndex1gloopIndex1talPloopIndex1n;\n          pinName = (&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2];\n        }\n        else {\n          pinName = NC;\n        }\n        pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n(pinName);\n        loopIndex1f (pinValue == 0) {\n          tempValue = 0x7f;\n        }\n        else {\n          loopIndex1f (tempValue2 < 0x3c) {\n            pinVariable1 = &dloopIndex1gloopIndex1talPloopIndex1n;\n            pinName = (&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2];\n          }\n          else {\n            pinName = NC;\n          }\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n(pinName);\n          loopIndex1f (pinValue == 1) {\n            tempValue = 0x7f;\n          }\n        }\n      }\n      else {\n        tempValue = 0x7f;\n      }\n      floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,tempValue,argValues,(sloopIndex1ze_t)pinVariable1);\n    }\n    floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xf7,argValues,(sloopIndex1ze_t)pinVariable1);\n    break;\n  case 'k':\n    floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xf0,argValues,(sloopIndex1ze_t)pinVariable1);\n    floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0x6c,argValues,(sloopIndex1ze_t)pinVariable1);\n    for (tempValue2 = 0; tempValue2 < 0x3c; tempValue2 = tempValue2 + 1 & 0xff) {\n      loopIndex1f (tempValue2 < 0x3c) {\n        loopIndex1f ((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2] == NC) {\n          sizeValue = 0;\n        }\n        else {\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n          loopIndex1f (pinValue == 0) {\n            sizeValue = 0;\n          }\n          else {\n            pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n            loopIndex1f (pinValue == 1) {\n              sizeValue = 0;\n            }\n            else {\n              sizeValue = 1;\n            }\n          }\n        }\n      }\n      else {\n        sizeValue = 0;\n      }\n      loopIndex1f (sizeValue != 0) {\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0,argValues,sizeValue);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,1,argValues,sizeValue);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xb,argValues,sizeValue);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,1,argValues,sizeValue);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,1,argValues,sizeValue);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,1,argValues,sizeValue);\n      }\n      loopIndex1f ((tempValue2 - 0x2e & 0xff) < 0xe) {\n        loopIndex1f (tempValue2 < 0x3c) {\n          pinName = (&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2];\n        }\n        else {\n          pinName = NC;\n        }\n        pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n(pinName);\n        loopIndex1f (pinValue == 0) {\n          pinVariable2 = (undefloopIndex1ned1 *)0x0;\n        }\n        else {\n          loopIndex1f (tempValue2 < 0x3c) {\n            pinName = (&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2];\n          }\n          else {\n            pinName = NC;\n          }\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n(pinName);\n          loopIndex1f (pinValue == 1) {\n            pinVariable2 = (undefloopIndex1ned1 *)0x0;\n          }\n          else {\n            pinVariable2 = (undefloopIndex1ned1 *)0x1;\n          }\n        }\n      }\n      else {\n        pinVariable2 = (undefloopIndex1ned1 *)0x0;\n      }\n      loopIndex1f (pinVariable2 != (undefloopIndex1ned1 *)0x0) {\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,2,argValues,(sloopIndex1ze_t)pinVariable2);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,10,argValues,(sloopIndex1ze_t)pinVariable2);\n      }\n      loopIndex1f (tempValue2 < 0x3c) {\n        pinVariable2 = &dloopIndex1gloopIndex1talPloopIndex1n;\n        loopIndex1f ((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2] == NC) {\n          isPinValid = false;\n        }\n        else {\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n          loopIndex1f (pinValue == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinVariable2 = &dloopIndex1gloopIndex1talPloopIndex1n;\n            pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n            loopIndex1f (pinValue == 1) {\n              isPinValid = false;\n            }\n            else {\n              pinVariable2 = &dloopIndex1gloopIndex1talPloopIndex1n;\n              isPinValid = pinValue_loopIndex1n_pinValuemap((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2],(PloopIndex1nMap_conflloopIndex1ct *)&PloopIndex1nMap_PWM);\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      loopIndex1f (isPinValid != false) {\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,3,argValues,(sloopIndex1ze_t)pinVariable2);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,8,argValues,(sloopIndex1ze_t)pinVariable2);\n      }\n      loopIndex1f (tempValue2 < 0x3c) {\n        loopIndex1f ((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2] == NC) {\n          sizeValue = 0;\n        }\n        else {\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n          loopIndex1f (pinValue == 0) {\n            sizeValue = 0;\n          }\n          else {\n            pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n            loopIndex1f (pinValue == 1) {\n              sizeValue = 0;\n            }\n            else {\n              sizeValue = 1;\n            }\n          }\n        }\n      }\n      else {\n        sizeValue = 0;\n      }\n      loopIndex1f (sizeValue != 0) {\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,4,argValues,sizeValue);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xe,argValues,sizeValue);\n      }\n      loopIndex1f (tempValue2 < 0x3c) {\n        loopIndex1f ((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2] == NC) {\n          pinVariable1 = (undefloopIndex1ned1 *)0x0;\n        }\n        else {\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n          loopIndex1f (pinValue == 0) {\n            pinVariable1 = (undefloopIndex1ned1 *)0x0;\n          }\n          else {\n            pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n            loopIndex1f (pinValue == 1) {\n              pinVariable1 = (undefloopIndex1ned1 *)0x0;\n            }\n            else {\n              isPinValid = pinValue_loopIndex1n_pinValuemap((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2],(PloopIndex1nMap_conflloopIndex1ct *)&PloopIndex1nMap_I2C_SDA);\n              pinVariable1 = (undefloopIndex1ned1 *)(uloopIndex1nt)isPinValid;\n              loopIndex1f (pinVariable1 == (undefloopIndex1ned1 *)0x0) {\n                isPinValid = pinValue_loopIndex1n_pinValuemap((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2],(PloopIndex1nMap_conflloopIndex1ct *)&PloopIndex1nMap_I2C_SCL);\n                pinVariable1 = (undefloopIndex1ned1 *)(uloopIndex1nt)isPinValid;\n              }\n            }\n          }\n        }\n      }\n      else {\n        pinVariable1 = (undefloopIndex1ned1 *)0x0;\n      }\n      loopIndex1f (pinVariable1 != (undefloopIndex1ned1 *)0x0) {\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,6,argValues,(sloopIndex1ze_t)pinVariable1);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,1,argValues,(sloopIndex1ze_t)pinVariable1);\n      }\n      floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0x7f,argValues,(sloopIndex1ze_t)pinVariable1);\n    }\n    floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xf7,argValues,(sloopIndex1ze_t)pinVariable1);\n    return;\n  case 'm':\n    loopIndex1f (tempValue2 != 0) {\n      byteVar1 = *argValues;\n      floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xf0,argValues,(sloopIndex1ze_t)pinVariable1);\n      floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0x6e,argValues,(sloopIndex1ze_t)pinVariable1);\n      floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,(uloopIndex1nt)byteVar1,argValues,(sloopIndex1ze_t)pinVariable1);\n      loopIndex1f (byteVar1 < 0x3c) {\n        byteVar7 = floopIndex1rmata::FloopIndex1rmataClass::getPloopIndex1nMode(&FloopIndex1rmata,byteVar1);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,(uloopIndex1nt)byteVar7,argValues,(sloopIndex1ze_t)pinVariable1);\n        tempValue2 = floopIndex1rmata::FloopIndex1rmataClass::getPloopIndex1nState(&FloopIndex1rmata,byteVar1);\n        floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,tempValue2 & 0x7f,argValues,(sloopIndex1ze_t)pinVariable1);\n        tempValue2 = floopIndex1rmata::FloopIndex1rmataClass::getPloopIndex1nState(&FloopIndex1rmata,byteVar1);\n        pinVariable1 = (undefloopIndex1ned1 *)0xff80;\n        loopIndex1f ((tempValue2 & 0xff80) != 0) {\n          intVar1 = floopIndex1rmata::FloopIndex1rmataClass::getPloopIndex1nState(&FloopIndex1rmata,byteVar1);\n          floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,(uloopIndex1nt)(intVar1 << 0x12) >> 0x19,argValues,(sloopIndex1ze_t)pinVariable1);\n        }\n        tempValue2 = floopIndex1rmata::FloopIndex1rmataClass::getPloopIndex1nState(&FloopIndex1rmata,byteVar1);\n        loopIndex1f ((tempValue2 & 0xc000) != 0) {\n          intVar1 = floopIndex1rmata::FloopIndex1rmataClass::getPloopIndex1nState(&FloopIndex1rmata,byteVar1);\n          floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,(uloopIndex1nt)(intVar1 << 0xb) >> 0x19,argValues,(sloopIndex1ze_t)pinVariable1);\n        }\n      }\n      floopIndex1rmata::FloopIndex1rmataClass::wrloopIndex1te(&FloopIndex1rmata,0xf7,argValues,(sloopIndex1ze_t)pinVariable1);\n      return;\n    }\n    break;\n  case 'o':\n    loopIndex1f (1 < tempValue2) {\n      tempValue = (uloopIndex1nt)argValues[1];\n      loopIndex1f (2 < tempValue2) {\n        tempValue = tempValue | (uloopIndex1nt)argValues[2] << 7;\n      }\n      loopIndex1f (3 < tempValue2) {\n        tempValue = tempValue | (uloopIndex1nt)argValues[3] << 0xe;\n      }\n      analogWrloopIndex1teCallback(*argValues,tempValue);\n      return;\n    }\n    break;\n  case 'p':\n    loopIndex1f (4 < tempValue2) {\n      byteVar1 = *argValues;\n      tempValue2 = (uloopIndex1nt)byteVar1;\n      byteVar7 = argValues[1];\n      byteVar2 = argValues[2];\n      byteVar3 = argValues[3];\n      byteVar4 = argValues[4];\n      loopIndex1f (tempValue2 < 0x3c) {\n        loopIndex1f ((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2] == NC) {\n          isServoAttached = false;\n        }\n        else {\n          pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n          loopIndex1f (pinValue == 0) {\n            isServoAttached = false;\n          }\n          else {\n            pinValue = pinValueNametoDloopIndex1gloopIndex1talPloopIndex1n((&dloopIndex1gloopIndex1talPloopIndex1n)[tempValue2]);\n            loopIndex1f (pinValue == 1) {\n              isServoAttached = false;\n            }\n            else {\n              isServoAttached = true;\n            }\n          }\n        }\n      }\n      else {\n        isServoAttached = false;\n      }\n      loopIndex1f (isServoAttached) {\n        loopIndex1f (servoPloopIndex1nMap[tempValue2] < 0xc) {\n          isServoAttached = Servo::attached(servos + servoPloopIndex1nMap[tempValue2]);\n        }\n        else {\n          isServoAttached = false;\n        }\n        loopIndex1f (isServoAttached != false) {\n          detachServo(byteVar1);\n        }\n        attachServo(byteVar1,(uloopIndex1nt)byteVar7 + (uloopIndex1nt)byteVar2 * 0x80,(uloopIndex1nt)byteVar3 + (uloopIndex1nt)byteVar4 * 0x80);\n        setPloopIndex1nModeCallback(byteVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    byteVar1 = argValues[1];\n    loopIndex1f ((byteVar1 & 0x20) != 0) {\n      floopIndex1rmata::FloopIndex1rmataClass::sendStrloopIndex1ng(&FloopIndex1rmata,\"10-bloopIndex1t deviceAddressloopIndex1ng not supported\");\n      return;\n    }\n    deviceAddress = *argValues;\n    isServoAttached = (byteVar1 & 0x40) == 0;\n    loopIndex1f ((byteVar1 & 0x18) < 0x19) {\n      swloopIndex1tch(byteVar1 & 0x18) {\n      case 0:\n        TwoWloopIndex1re::begloopIndex1nTransmloopIndex1ssloopIndex1on(&WloopIndex1re,deviceAddress);\n        for (tempValue = 2; tempValue < tempValue2; tempValue = tempValue + 2 & 0xff) {\n          wloopIndex1reWrloopIndex1te(argValues[tempValue + 1] * -0x80 + argValues[tempValue]);\n        }\n        TwoWloopIndex1re::endTransmloopIndex1ssloopIndex1on(&WloopIndex1re);\n        return;\n      case 8:\n        loopIndex1f (tempValue2 == 6) {\n          intVar1 = (uloopIndex1nt)argValues[2] + (uloopIndex1nt)argValues[3] * 0x80;\n          byteVar10 = argValues[4] + argValues[5] * -0x80;\n        }\n        else {\n          byteVar10 = argValues[2] + argValues[3] * -0x80;\n          intVar1 = -1;\n        }\n        readAndReportData(deviceAddress,intVar1,byteVar10,isServoAttached);\n        return;\n      case 0x10:\n        loopIndex1f (queryIndex + 1 < 8) {\n          loopIndex1f (tempValue2 == 6) {\n            intVar1 = (uloopIndex1nt)argValues[2] + (uloopIndex1nt)argValues[3] * 0x80;\n            byteVar10 = argValues[4] + argValues[5] * -0x80;\n          }\n          else {\n            byteVar10 = argValues[2] + argValues[3] * -0x80;\n            intVar1 = -1;\n          }\n          queryIndex = queryIndex + '\\x01';\n          intVar2 = (loopIndex1nt)queryIndex;\n          query[intVar2].addr = deviceAddress;\n          query[intVar2].reg = intVar1;\n          query[intVar2].bytes = byteVar10;\n          *(bool *)(intVar2 * 0xc + 0x20000191) = isServoAttached;\n          return;\n        }\n        floopIndex1rmata::FloopIndex1rmataClass::sendStrloopIndex1ng(&FloopIndex1rmata,\"too many querloopIndex1es\");\n        return;\n      case 0x18:\n        loopIndex1f (queryIndex < 1) {\n          queryIndex = -1;\n          return;\n        }\n      }\n      for (tempValue2 = 0; intVar1 = queryIndex + 1, (loopIndex1nt)tempValue2 < intVar1; tempValue2 = tempValue2 + 1 & 0xff) {\n        loopIndex1f (deviceAddress == query[tempValue2].addr) goto LAB_08001e66;\n      }\n      tempValue2 = 0;\nLAB_08001e66:\n      for (; (loopIndex1nt)tempValue2 < intVar1; tempValue2 = tempValue2 + 1 & 0xff) {\n        loopIndex1f (tempValue2 < 8) {\n          intVar2 = tempValue2 + 1;\n          query[tempValue2].addr = query[intVar2].addr;\n          query[tempValue2].reg = query[intVar2].reg;\n          query[tempValue2].bytes = query[intVar2].bytes;\n          query[tempValue2].stopTransmission = query[intVar2].stopTransmission;\n        }\n      }\n      queryIndex = queryIndex + -1;\n      return;\n    }\n    break;\n  case 'x':\n    tempValue = (uloopIndex1nt)*argValues + (uloopIndex1nt)argValues[1] * 0x80;\n    loopIndex1f ((1 < tempValue2) && (tempValue != 0)) {\n      loopIndex12cReadDelayTloopIndex1me = tempValue;\n    }\n    loopIndex1f (!loopIndex1sI2CEnabled) {\n      enableI2CPloopIndex1ns();\n      return;\n    }\n    break;\n  case 'z':\n    loopIndex1f ((1 < tempValue2) &&\n       (samplloopIndex1ngInterpinValue = (uloopIndex1nt)*argValues + (uloopIndex1nt)argValues[1] * 0x80, samplloopIndex1ngInterpinValue == 0)) {\n      samplloopIndex1ngInterpinValue = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "improve_firmata_command_08001cd0",
                "command": "cmd",
                "argc": "argCount",
                "argv": "argValues",
                "bVar1": "byteVar1",
                "address": "deviceAddress",
                "bVar2": "byteVar2",
                "bVar3": "byteVar3",
                "bVar4": "byteVar4",
                "data": "pinData",
                "PVar5": "pinName",
                "_Var6": "isPinValid",
                "bVar7": "byteVar7",
                "uVar8": "pinValue",
                "iVar9": "intVar1",
                "val": "pinValue",
                "mode": "pinMode",
                "bVar10": "byteVar10",
                "stopTX": "stopTransmission",
                "i": "loopIndex1",
                "i_1": "loopIndex2",
                "in_r3": "pinVariable1",
                "uVar11": "tempValue",
                "pin_1": "pinValue1",
                "__n": "pinVariable2",
                "sVar12": "sizeValue",
                "pin": "pinValue",
                "uVar13": "tempValue2",
                "iVar14": "intVar2",
                "bVar15": "isServoAttached"
            },
            "calling": [],
            "called": [
                "attached",
                "analogWriteCallback",
                "beginTransmission",
                "readAndReportData",
                "write",
                "getPinState",
                "endTransmission",
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "setPinModeCallback",
                "detachServo",
                "getPinMode",
                "sendString",
                "attachServo",
                "wireWrite",
                "enableI2CPins"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022f8": {
            "entrypoint": "0x080022f8",
            "current_name": "process_firmata_inputs_080022f8",
            "code": "\n/* WARNING: Unknown callcounterng conventcounteron */\n\nvocounterd processFirmataInputs_080022f8(vocounterd)\n\n{\n  bool isDigitalPin;\n  PcounternName_conflcounterct pinName;\n  byte pinMode;\n  counternt firmataAvailable;\n  ucounternt32_t digitalPin;\n  byte counter;\n  ucounternt analogPinIndex;\n  byte analogPcountern;\n  ucounternt digitalPinIndex;\n  \n  checkDcountergcountertalInputs();\n  whcounterle (firmataAvailable = fcounterrmata::FcounterrmataClass::avacounterlable(&Fcounterrmata), firmataAvailable != 0) {\n    fcounterrmata::FcounterrmataClass::processInput(&Fcounterrmata);\n  }\n  currentMcounterllcounters = mcounterllcounters();\n  counterf (samplcounterngInterval < currentMcounterllcounters - prevcounterousMcounterllcounters) {\n    prevcounterousMcounterllcounters = prevcounterousMcounterllcounters + samplcounterngInterval;\n    for (analogPinIndex = 0; analogPinIndex < 0x3c; analogPinIndex = analogPinIndex + 1 & 0xff) {\n      digitalPinIndex = analogPinIndex - 0x2e & 0xff;\n      counterf (digitalPinIndex < 0xe) {\n        counterf (analogPinIndex < 0x3c) {\n          pinName = (&dcountergcountertalPcountern)[analogPinIndex];\n        }\n        else {\n          pinName = NC;\n        }\n        digitalPin = pcounternNametoDcountergcountertalPcountern(pinName);\n        counterf (digitalPin == 0) {\n          isDigitalPin = false;\n        }\n        else {\n          counterf (analogPinIndex < 0x3c) {\n            pinName = (&dcountergcountertalPcountern)[analogPinIndex];\n          }\n          else {\n            pinName = NC;\n          }\n          digitalPin = pcounternNametoDcountergcountertalPcountern(pinName);\n          counterf (digitalPin == 1) {\n            isDigitalPin = false;\n          }\n          else {\n            pinMode = fcounterrmata::FcounterrmataClass::getPcounternMode(&Fcounterrmata,(byte)analogPinIndex);\n            counterf (pinMode == '\\x02') {\n              isDigitalPin = true;\n            }\n            else {\n              isDigitalPin = false;\n            }\n          }\n        }\n      }\n      else {\n        isDigitalPin = false;\n      }\n      counterf ((isDigitalPin) && ((analogInputsToReport >> digitalPinIndex & 1U) != 0)) {\n        digitalPin = analogRead(digitalPinIndex);\n        fcounterrmata::FcounterrmataClass::sendAnalog(&Fcounterrmata,(byte)digitalPinIndex,digitalPin);\n      }\n    }\n    counterf (-1 < queryIndex) {\n      for (analogPinIndex = 0; (counternt)analogPinIndex < queryIndex + 1; analogPinIndex = analogPinIndex + 1 & 0xff) {\n        readAndReportData(query[analogPinIndex].addr,query[analogPinIndex].reg,query[analogPinIndex].bytes,query[analogPinIndex].stopTX)\n        ;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022f8": "process_firmata_inputs_080022f8",
                "bVar1": "isDigitalPin",
                "PVar2": "pinName",
                "bVar3": "pinMode",
                "iVar4": "firmataAvailable",
                "uVar5": "digitalPin",
                "i": "counter",
                "uVar6": "analogPinIndex",
                "ulPin": "digitalPinIndex"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available",
                "analogRead",
                "millis",
                "pinNametoDigitalPin",
                "sendAnalog",
                "checkDigitalInputs",
                "getPinMode",
                "readAndReportData",
                "processInput"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002400": {
            "entrypoint": "0x08002400",
            "current_name": "check_servo_pin_08002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nboolean check_servo_pin_08002400(timer16_Sequence_t timer)\n\n{\n  uint counter;\n  \n  counter = 0;\n  while( true ) {\n    if (0xb < counter) {\n      return false;\n    }\n    if (((byte)servo_array[(uint)timer * 0xc + counter].Pin & 0x40) != 0) break;\n    counter = counter + 1 & 0xff;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08002400": "check_servo_pin_08002400",
                "uVar1": "counter",
                "servos": "servo_array"
            },
            "calling": [
                "attach",
                "detach"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800242c": {
            "entrypoint": "0x0800242c",
            "current_name": "initialize_timer_pulse_0800242c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimerPulse_0800242c(stimer_t *timerObject)\n\n{\n  TimerPulseInit((stimer_t_conflict *)timerObject,60000,0x5dc,ServoIrqHandle + 1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800242c": "initialize_timer_pulse_0800242c",
                "obj": "timerObject"
            },
            "calling": [
                "attach"
            ],
            "called": [
                "TimerPulseInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002444": {
            "entrypoint": "0x08002444",
            "current_name": "update_servo_position_08002444",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateServoPosition_08002444(stimer_t *servoObject,uint32_t servoChannel)\n\n{\n  bool isServoPwmPin;\n  uint32_t counterValue;\n  int index;\n  uint objIndex;\n  \n  objIndex = (uint)servoObject->idx;\n  if ((timerChannel[objIndex] & 0x80U) == 0) {\n    index = objIndex * 0xc;\n    if (timerChannel[objIndex] + index < (int)(uint)ServoCount) {\n      if (((byte)servos[timerChannel[objIndex] + index].Pin & 0x40) == 0) {\n        isServoPwmPin = false;\n      }\n      else {\n        isServoPwmPin = true;\n      }\n    }\n    else {\n      isServoPwmPin = false;\n    }\n    if (isServoPwmPin) {\n      digitalWrite((byte)servos[index + timerChannel[objIndex]].Pin & 0x3f,0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)servoObject,0);\n  }\n  timerChannel[objIndex] = timerChannel[objIndex] + '\\x01';\n  index = objIndex * 0xc;\n  if (timerChannel[objIndex] + index < (int)(uint)ServoCount) {\n    if (timerChannel[objIndex] < '\\f') {\n      isServoPwmPin = true;\n    }\n    else {\n      isServoPwmPin = false;\n    }\n  }\n  else {\n    isServoPwmPin = false;\n  }\n  if (isServoPwmPin) {\n    if (((byte)servos[timerChannel[objIndex] + index].Pin & 0x40) != 0) {\n      digitalWrite((byte)servos[timerChannel[objIndex] + index].Pin & 0x3f,1);\n    }\n    counterValue = getTimerCounter((stimer_t_conflict *)servoObject);\n    setCCRRegister((stimer_t_conflict *)servoObject,servoChannel,\n                   servos[index + timerChannel[objIndex]].ticks + counterValue);\n    return;\n  }\n  counterValue = getTimerCounter((stimer_t_conflict *)servoObject);\n  if (counterValue + 4 < 20000) {\n    setCCRRegister((stimer_t_conflict *)servoObject,servoChannel,20000);\n  }\n  else {\n    counterValue = getTimerCounter((stimer_t_conflict *)servoObject);\n    setCCRRegister((stimer_t_conflict *)servoObject,servoChannel,counterValue + 4);\n  }\n  timerChannel[objIndex] = -1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002444": "update_servo_position_08002444",
                "obj": "servoObject",
                "channel": "servoChannel",
                "bVar1": "isServoPwmPin",
                "uVar2": "counterValue",
                "iVar3": "index",
                "uVar4": "objIndex"
            },
            "calling": [],
            "called": [
                "digitalWrite",
                "setCCRRegister",
                "setTimerCounter",
                "getTimerCounter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002578": {
            "entrypoint": "0x08002578",
            "current_name": "deinit_timer_pulse_08002578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deinitTimerPulse_08002578(stimer_t *timerObject)\n\n{\n  TimerPulseDeinit((stimer_t_conflict *)timerObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002578": "deinit_timer_pulse_08002578",
                "obj": "timerObject"
            },
            "calling": [
                "detach"
            ],
            "called": [
                "TimerPulseDeinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "initialize_servo_08002580",
            "code": "\n/* DWARF original prototype: Servo *  Servo(Servo * servo) */\n\nServo * __servocall Servo::initializeServo_08002580(Servo *servo)\n\n{\n  uint8_t updatedServoCount;\n  uint currentServoCount;\n  \n  currentServoCount = (uint)ServoCount;\n  if (0xb < currentServoCount) {\n    servo->servoIndex = 0xff;\n    return servo;\n  }\n  updatedServoCount = ServoCount + '\\x01';\n  servo->servoIndex = ServoCount;\n  ServoCount = updatedServoCount;\n  servos[currentServoCount].ticks = 0x5dc;\n  return servo;\n}\n\n",
            "renaming": {
                "FUN_08002580": "initialize_servo_08002580",
                "this": "servo",
                "uVar1": "updatedServoCount",
                "uVar2": "currentServoCount"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ac": {
            "entrypoint": "0x080025ac",
            "current_name": "attach_080025ac",
            "code": "\n/* DWARF original prototype: uint8_t  attach_080025ac(Servo * servo, int servoPin, int minimumPulse, int maximumPulse) */\n\nuint8_t __servocall Servo::attach_080025ac(Servo *servo,int servoPin,int minimumPulse,int maximumPulse)\n\n{\n  currentTimer16_Sequence_t timerIndex;\n  boolean isTimerActive;\n  currentTimer16_Sequence_t currentTimer;\n  int calculatedValue;\n  \n  if (servo->servoIndex < 0xc) {\n    servoPinMode(servoPin,1);\n    servos[servo->servoIndex].Pin =\n         (ServoPin_t)((byte)servos[servo->servoIndex].Pin & 0xc0 | (byte)servoPin & 0x3f);\n    calculatedValue = -minimumPulse + 0x220;\n    if (calculatedValue < 0) {\n      calculatedValue = -minimumPulse + 0x223;\n    }\n    servo->minimumPulse = (int8_t)((uint)(calculatedValue << 0x16) >> 0x18);\n    calculatedValue = -maximumPulse + 0x960;\n    if (calculatedValue < 0) {\n      calculatedValue = -maximumPulse + 0x963;\n    }\n    servo->maximumPulse = (int8_t)((uint)(calculatedValue << 0x16) >> 0x18);\n    timerIndex = servo->servoIndex / 0xc;\n    isTimerActive = isTimerActive(timerIndex);\n    if (!isTimerActive) {\n      _currentTimer.idx = timerIndex;\n      initISR(&_currentTimer);\n    }\n    servos[servo->servoIndex].Pin = (ServoPin_t)((byte)servos[servo->servoIndex].Pin | 0x40);\n  }\n  return servo->servoIndex;\n}\n\n",
            "renaming": {
                "FUN_080025ac": "attach_080025ac",
                "this": "servo",
                "pin": "servoPin",
                "min": "minimumPulse",
                "max": "maximumPulse",
                "timer_00": "timerIndex",
                "bVar1": "isTimerActive",
                "timer": "currentTimer",
                "iVar2": "calculatedValue"
            },
            "calling": [
                "attach",
                "attachServo"
            ],
            "called": [
                "isTimerActive",
                "initISR",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002634": {
            "entrypoint": "0x08002634",
            "current_name": "attach_servo_08002634",
            "code": "\n/* DWARF original prototype: uint8_t  attach(Servo * servo, int pin) */\n\nuint8_t __servocall Servo::attachServo_08002634(Servo *servo,int pin)\n\n{\n  uint8_t result;\n  \n  result = attach(servo,pin,0x220,0x960);\n  return result;\n}\n\n",
            "renaming": {
                "this": "servo",
                "uVar1": "result",
                "FUN_08002634": "attach_servo_08002634"
            },
            "calling": [
                "attachServo"
            ],
            "called": [
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002644": {
            "entrypoint": "0x08002644",
            "current_name": "detach_08002644",
            "code": "\n/* DWARF original prototype: void  detach_08002644(Servo * servo) */\n\nvoid __servocall Servo::detach_08002644(Servo *servo)\n\n{\n  byte index;\n  boolean isActive;\n  \n  index = servo->servoIndex;\n  allServos[index].Pin = (PinType)((byte)allServos[index].Pin & 0xbf);\n  isActive = checkTimerActive(index / 0xc);\n  if (!isActive) {\n    finISR(&timer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "servo",
                "bVar1": "index",
                "bVar2": "isActive",
                "servos": "allServos",
                "ServoPin_t": "PinType",
                "isTimerActive": "checkTimerActive",
                "_timer": "timer",
                "FUN_08002644": "detach_08002644"
            },
            "calling": [
                "detachServo"
            ],
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800267c": {
            "entrypoint": "0x0800267c",
            "current_name": "set_servo_microseconds_0800267c",
            "code": "\n/* DWARF original prototype: void  writeMicroseconds(Servo * servo, int microseconds) */\n\nvoid __servocall Servo::setServoMicroseconds_0800267c(Servo *servo,int microseconds)\n\n{\n  uint computedTicks;\n  int maxDiffTicks;\n  \n  if (servo->servoIndex < 0xc) {\n    computedTicks = (0x88 - servo->min) * 4;\n    if ((computedTicks - microseconds == 0 || (int)computedTicks < microseconds) &&\n       (maxDiffTicks = 600 - servo->max, computedTicks = maxDiffTicks * 4,\n       microseconds == computedTicks || microseconds + maxDiffTicks * -4 < 0 != SBORROW4(microseconds,computedTicks))) {\n      computedTicks = microseconds;\n    }\n    servos[servo->servoIndex].ticks = computedTicks;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800267c": "set_servo_microseconds_0800267c",
                "this": "servo",
                "value": "microseconds",
                "uVar1": "computedTicks",
                "iVar2": "maxDiffTicks"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026b0": {
            "entrypoint": "0x080026b0",
            "current_name": "set_servo_position_080026b0",
            "code": "\n/* DWARF original prototype: void  write(Servo * servo, int value) */\n\nssize_t Servo Servo::setServoPosition_080026b0(Servo *servo,int fileDescriptor,void *buffer,size_t bufferSize)\n\n{\n  if (fileDescriptor < 0x220) {\n    if (fileDescriptor < 0) {\n      fileDescriptor = 0;\n    }\n    else if (0xb4 < fileDescriptor) {\n      fileDescriptor = 0xb4;\n    }\n    fileDescriptor = map(fileDescriptor,0,0xb4,(0x88 - servo->minimumValue) * 4,(600 - servo->maximumValue) * 4);\n  }\n  writeMicroseconds(servo,fileDescriptor);\n  return (ssize_t)servo;\n}\n\n",
            "renaming": {
                "FUN_080026b0": "set_servo_position_080026b0",
                "__thiscall": "Servo",
                "this": "servo",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "bufferSize",
                "min": "minimumValue",
                "max": "maximumValue"
            },
            "calling": [
                "analogWriteCallback"
            ],
            "called": [
                "writeMicroseconds",
                "map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026f8": {
            "entrypoint": "0x080026f8",
            "current_name": "is_servo_attached_080026f8",
            "code": "\n/* DWARF original prototype: bool  attached(Servo * servo) */\n\nbool __servocall Servo::isServoAttached_080026f8(Servo *servo)\n\n{\n  return SUB41(((uint)(byte)allServos[servo->index].servoPin << 0x19) >> 0x1f,0);\n}\n\n",
            "renaming": {
                "this": "servo",
                "servos": "allServos",
                "servoIndex": "index",
                "Pin": "servoPin",
                "FUN_080026f8": "is_servo_attached_080026f8"
            },
            "calling": [
                "setPinModeCallback",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800270c": {
            "entrypoint": "0x0800270c",
            "current_name": "calculate_available_0800270c",
            "code": "\n/* DWARF original prototype: int  available(TwoWire * wireInstance) */\n\nint __wireInstancecall TwoWire::calculateAvailable_0800270c(TwoWire *wireInstance)\n\n{\n  return (uint)receiveBufferLength - (uint)receiveBufferIndex;\n}\n\n",
            "renaming": {
                "FUN_0800270c": "calculate_available_0800270c",
                "this": "wireInstance",
                "rxBufferLength": "receiveBufferLength",
                "rxBufferIndex": "receiveBufferIndex"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002720": {
            "entrypoint": "0x08002720",
            "current_name": "read_data_from_buffer_08002720",
            "code": "\n/* DWARF original prototype: int  read(TwoWire * wire) */\n\nssize_t __wirecall TwoWire::readDataFromBuffer_08002720(TwoWire *wire,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  uint currentIndex;\n  \n  currentIndex = (uint)bufferIndex;\n  if (currentIndex < bufferLength) {\n    bufferIndex = bufferIndex + '\\x01';\n    return (uint)receiveBuffer[currentIndex];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08002720": "read_data_from_buffer_08002720",
                "this": "wire",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "uVar1": "currentIndex",
                "rxBufferIndex": "bufferIndex",
                "rxBufferLength": "bufferLength",
                "rxBuffer": "receiveBuffer"
            },
            "calling": [
                "wireRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800274c": {
            "entrypoint": "0x0800274c",
            "current_name": "peek_0800274c",
            "code": "\n/* DWARF original prototype: int  peek_0800274c(TwoWire * wire) */\n\nint __wirecall TwoWire::peek_0800274c(TwoWire *wire)\n\n{\n  if ((uint)bufferIndex < (uint)bufferLength) {\n    return (uint)buffer[bufferIndex];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "wire",
                "rxBufferIndex": "bufferIndex",
                "rxBufferLength": "bufferLength",
                "rxBuffer": "buffer",
                "FUN_0800274c": "peek_0800274c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002774": {
            "entrypoint": "0x08002774",
            "current_name": "handle_on_request_08002774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::handleOnRequest_08002774(void)\n\n{\n  if (onRequestCallback != (_func_void *)0x0) {\n    transmitBufferIndex = '\\0';\n    transmitBufferLength = '\\0';\n    (*onRequestCallback)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002774": "handle_on_request_08002774",
                "user_onRequest": "onRequestCallback",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002798": {
            "entrypoint": "0x08002798",
            "current_name": "initialize_wire_08002798",
            "code": "\n/* DWARF original prototype: void  flush(TwoWire * wire) */\n\nvoid __wirecall TwoWire::initializeWire_08002798(TwoWire *wire)\n\n{\n  receiveBufferIndex = '\\0';\n  receiveBufferLength = '\\0';\n  if (receiveBuffer != (uint8_t *)0x0) {\n    memset(receiveBuffer,0,(uint)receiveBufferAllocated);\n  }\n  transmitBufferIndex = '\\0';\n  transmitBufferLength = '\\0';\n  if (transmitBuffer != (uint8_t *)0x0) {\n    memset(transmitBuffer,0,(uint)transmitBufferAllocated);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002798": "initialize_wire_08002798",
                "this": "wire",
                "rxBufferIndex": "receiveBufferIndex",
                "rxBufferLength": "receiveBufferLength",
                "rxBuffer": "receiveBuffer",
                "rxBufferAllocated": "receiveBufferAllocated",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength",
                "txBuffer": "transmitBuffer"
            },
            "calling": [],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f0": {
            "entrypoint": "0x080027f0",
            "current_name": "transmit_data_080027f0",
            "code": "\n/* DWARF original prototype: size_t  write(TwoWire * wire, uint8_t * data, size_t quantity) */\n\nssize_t __wirecall TwoWire::transmitData_080027f0(TwoWire *wire,int fileDescriptor,void *buffer,size_t size)\n\n{\n  I2CStatus status;\n  size_t totalSize;\n  \n  if (transmitting == '\\0') {\n    status = i2c_slave_write_IT((I2CT *)&wire->_i2c,(uint8_t *)fileDescriptor,(uint16_t)buffer);\n    if (status == I2C_OK) {\n      return (ssize_t)buffer;\n    }\n    return 0;\n  }\n  totalSize = (uint)transmitBufferLength + (int)buffer;\n  if (transmitBufferAllocated < totalSize) {\n    if (totalSize < 0x20) {\n      totalSize = 0x20;\n    }\n    transmitBuffer = (uint8_t *)realloc(transmitBuffer,totalSize);\n    if (transmitBuffer == (uint8_t *)0x0) {\n      transmitBufferAllocated = '\\0';\n    }\n    else {\n      transmitBufferAllocated = (uint8_t)totalSize;\n    }\n  }\n  if (transmitBuffer == (uint8_t *)0x0) {\n    (wire->superStream).super_Print.write_error = 1;\n    return 0;\n  }\n  memcpy(transmitBuffer + transmitBufferIndex,(void *)fileDescriptor,(size_t)buffer);\n  transmitBufferIndex = transmitBufferIndex + (char)buffer;\n  transmitBufferLength = transmitBufferIndex;\n  return (ssize_t)buffer;\n}\n\n",
            "renaming": {
                "FUN_080027f0": "transmit_data_080027f0",
                "this": "wire",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "i2c_status_e_conflict": "I2CStatus",
                "__size": "totalSize",
                "iVar1": "status",
                "i2c_t_conflict": "I2CT",
                "txBufferLength": "transmitBufferLength",
                "txBufferAllocated": "transmitBufferAllocated",
                "txBuffer": "transmitBuffer",
                "txBufferIndex": "transmitBufferIndex",
                "super_Stream": "superStream"
            },
            "calling": [],
            "called": [
                "i2c_slave_write_IT",
                "realloc",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800288c": {
            "entrypoint": "0x0800288c",
            "current_name": "write_data_to_wire_0800288c",
            "code": "\n/* DWARF original prototype: sizeType  write(TwoWire * this, uint8_t data) */\n\nsignedSize methodCall TwoWire::writeDataToWire_0800288c(TwoWire *this,int fileDescriptor,void *buffer,sizeType size)\n\n{\n  i2cStatusConflict iVar1;\n  signedSize sVar2;\n  sizeType __size;\n  uint8_t data;\n  \n  data = (uint8_t)fileDescriptor;\n  if (isTransmitting == '\\0') {\n    iVar1 = i2cSlaveWriteIT((i2cConflict *)&this->_i2c,&data,1);\n    if (iVar1 == I2CStatusOK) {\n      sVar2 = 1;\n    }\n    else {\n      sVar2 = 0;\n    }\n  }\n  else {\n    __size = transmitBufferLength + 1;\n    if (transmitBufferAllocated < __size) {\n      if (__size < 0x20) {\n        __size = 0x20;\n      }\n      transmitBuffer = (uint8_t *)realloc(transmitBuffer,__size);\n      if (transmitBuffer == (uint8_t *)0x0) {\n        transmitBufferAllocated = '\\0';\n      }\n      else {\n        transmitBufferAllocated = (uint8_t)__size;\n      }\n    }\n    if (transmitBuffer == (uint8_t *)0x0) {\n      (this->super_Stream).super_Print.write_error = 1;\n      sVar2 = 0;\n    }\n    else {\n      transmitBuffer[transmitBufferIndex] = data;\n      transmitBufferIndex = transmitBufferIndex + '\\x01';\n      sVar2 = 1;\n      transmitBufferLength = transmitBufferIndex;\n    }\n  }\n  return sVar2;\n}\n\n",
            "renaming": {
                "FUN_0800288c": "write_data_to_wire_0800288c",
                "__thiscall": "methodCall",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "i2c_status_e_conflict": "i2cStatusConflict",
                "ssize_t": "signedSize",
                "size_t": "sizeType",
                "local_11": "data",
                "transmitting": "isTransmitting",
                "i2c_slave_write_IT": "i2cSlaveWriteIT",
                "i2c_t_conflict": "i2cConflict",
                "I2C_OK": "I2CStatusOK",
                "txBufferLength": "transmitBufferLength",
                "txBufferAllocated": "transmitBufferAllocated",
                "txBuffer": "transmitBuffer",
                "txBufferIndex": "transmitBufferIndex"
            },
            "calling": [
                "wireWrite"
            ],
            "called": [
                "i2c_slave_write_IT",
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800291c": {
            "entrypoint": "0x0800291c",
            "current_name": "initialize_wire_0800291c",
            "code": "\n/* DWARF original prototype: TwoWire *  TwoWire(TwoWire * wireInstance) */\n\nTwoWire * __wireInstancecall TwoWire::initializeWire_0800291c(TwoWire *wireInstance)\n\n{\n  (wireInstance->super_Stream).super_Print.write_error = 0;\n  (wireInstance->super_Stream)._timeout = 1000;\n  (wireInstance->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_0800a5a0;\n  (wireInstance->_i2c).sda = PB_9;\n  (wireInstance->_i2c).scl = PB_8;\n  return wireInstance;\n}\n\n",
            "renaming": {
                "this": "wireInstance",
                "FUN_0800291c": "initialize_wire_0800291c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002948": {
            "entrypoint": "0x08002948",
            "current_name": "initialize_wire_08002948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeWire_08002948(int shouldInitialize,int priority)\n\n{\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    initializeTwoWire;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002948": "initialize_wire_08002948",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority",
                "TwoWire::TwoWire(&Wire)": "initializeTwoWire"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "called": [
                "TwoWire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002968": {
            "entrypoint": "0x08002968",
            "current_name": "initialize_wire_08002968",
            "code": "\n/* DWARF original prototype: void  begin(TwoWire * wire, uint8_t deviceAddress) */\n\nvoid __wirecall TwoWire::initializeWire_08002968(TwoWire *wire,uint8_t deviceAddress)\n\n{\n  uint32_t deviceOwnAddress;\n  i2cConfig *obj;\n  \n  receiveBufferIndex = '\\0';\n  receiveBufferLength = '\\0';\n  if (receiveBuffer != (uint8_t *)0x0) {\n    memset(receiveBuffer,0,(uint)receiveBufferAllocated);\n  }\n  transmitBufferIndex = '\\0';\n  transmitBufferLength = '\\0';\n  if (transmitBuffer != (uint8_t *)0x0) {\n    memset(transmitBuffer,0,(uint)transmitBufferAllocated);\n  }\n  isTransmitting = '\\0';\n  deviceOwnAddress = (deviceAddress & 0x7f) << 1;\n  wire->deviceOwnAddress = (uint8_t)deviceOwnAddress;\n  if (deviceAddress == 0x33) {\n    wire->isMaster = true;\n  }\n  else {\n    wire->isMaster = false;\n  }\n  obj = &wire->i2cObject;\n  initializeI2C((i2cConfigConflict *)obj,I2C_100KHz,0x4000,deviceOwnAddress,wire->isMaster);\n  if (wire->isMaster == false) {\n    attachSlaveTransmitEvent((i2cConfigConflict *)obj,slaveRequestService + 1);\n    attachSlaveReceiveEvent((i2cConfigConflict *)obj,slaveReceiveService + 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "wire",
                "address": "deviceAddress",
                "ownAddress": "deviceOwnAddress",
                "i2c_t": "i2cConfig",
                "rxBufferIndex": "receiveBufferIndex",
                "rxBufferLength": "receiveBufferLength",
                "rxBuffer": "receiveBuffer",
                "rxBufferAllocated": "receiveBufferAllocated",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength",
                "txBuffer": "transmitBuffer",
                "txBufferAllocated": "transmitBufferAllocated",
                "transmitting": "isTransmitting",
                "master": "isMaster",
                "_i2c": "i2cObject",
                "i2c_custom_init": "initializeI2C",
                "i2c_t_conflict": "i2cConfigConflict",
                "i2c_attachSlaveTxEvent": "attachSlaveTransmitEvent",
                "i2c_attachSlaveRxEvent": "attachSlaveReceiveEvent",
                "onRequestService": "slaveRequestService",
                "onReceiveService": "slaveReceiveService",
                "FUN_08002968": "initialize_wire_08002968"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "memset",
                "i2c_attachSlaveTxEvent",
                "i2c_attachSlaveRxEvent",
                "i2c_custom_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a1c": {
            "entrypoint": "0x08002a1c",
            "current_name": "initialize_wire_08002a1c",
            "code": "\n/* DWARF original prototype: void  begin(TwoWire * wireInstance, int deviceAddress) */\n\nvoid __wireInstancecall TwoWire::initializeWire_08002a1c(TwoWire *wireInstance,int deviceAddress)\n\n{\n  begin(wireInstance,(uint8_t)deviceAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a1c": "initialize_wire_08002a1c",
                "this": "wireInstance",
                "address": "deviceAddress"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a26": {
            "entrypoint": "0x08002a26",
            "current_name": "initialize_communication_08002a26",
            "code": "\n/* DWARF original prototype: void  startCommunication(TwoWire * wire) */\n\nvoid __wirecall TwoWire::initializeCommunication_08002a26(TwoWire *wire)\n\n{\n  startCommunication(wire,0x33);\n  return;\n}\n\n",
            "renaming": {
                "this": "wire",
                "begin": "startCommunication",
                "FUN_08002a26": "initialize_communication_08002a26"
            },
            "calling": [
                "enableI2CPins"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a30": {
            "entrypoint": "0x08002a30",
            "current_name": "initialize_transmission_08002a30",
            "code": "\n/* DWARF original prototype: void  beginTransmission(TwoWire * wire, uint8_t deviceAddress) */\n\nvoid __wirecall TwoWire::initializeTransmission_08002a30(TwoWire *wire,uint8_t deviceAddress)\n\n{\n  isTransmitting = '\\x01';\n  transmitAddress = deviceAddress << 1;\n  transmitBufferIndex = '\\0';\n  transmitBufferLength = '\\0';\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a30": "initialize_transmission_08002a30",
                "this": "wire",
                "address": "deviceAddress",
                "transmitting": "isTransmitting",
                "txAddress": "transmitAddress",
                "txBufferIndex": "transmitBufferIndex",
                "txBufferLength": "transmitBufferLength"
            },
            "calling": [
                "readAndReportData",
                "requestFrom",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a58": {
            "entrypoint": "0x08002a58",
            "current_name": "end_i2_c_transmission_08002a58",
            "code": "\n/* DWARF original prototype: uint8_t  endTransmission(TwoWire * wireObject, uint8_t stopTransmission) */\n\nuint8_t __wireObjectcall TwoWire::endI2CTransmission_08002a58(TwoWire *wireObject,uint8_t stopTransmission)\n\n{\n  I2CStatus i2cResult;\n  uint8_t returnStatus;\n  \n  if (wireObject->isMaster == false) {\n    returnStatus = '\\x04';\n  }\n  else {\n    i2cResult = writeToI2C((I2CType *)&wireObject->i2c,transmitAddress,transmitBuffer,(ushort)transmitBufferLength\n                            );\n    if (i2cResult == I2CSuccess) {\n      returnStatus = '\\0';\n    }\n    else if (i2cResult == I2CTimeout) {\n      returnStatus = '\\x01';\n    }\n    else {\n      returnStatus = '\\x04';\n    }\n    if (transmitBuffer != (uint8_t *)0x0) {\n      memset(transmitBuffer,0,(uint)transmitBufferAllocated);\n    }\n    transmitBufferIndex = '\\0';\n    transmitBufferLength = '\\0';\n    isTransmitting = '\\0';\n  }\n  return returnStatus;\n}\n\n",
            "renaming": {
                "this": "wireObject",
                "sendStop": "stopTransmission",
                "i2c_status_e_conflict": "I2CStatus",
                "uVar2": "returnStatus",
                "master": "isMaster",
                "iVar1": "i2cResult",
                "i2c_master_write": "writeToI2C",
                "i2c_t_conflict": "I2CType",
                "_i2c": "i2c",
                "txAddress": "transmitAddress",
                "txBuffer": "transmitBuffer",
                "txBufferLength": "transmitBufferLength",
                "I2C_OK": "I2CSuccess",
                "I2C_TIMEOUT": "I2CTimeout",
                "txBufferAllocated": "transmitBufferAllocated",
                "txBufferIndex": "transmitBufferIndex",
                "transmitting": "isTransmitting",
                "FUN_08002a58": "end_i2_c_transmission_08002a58"
            },
            "calling": [
                "endTransmission",
                "readAndReportData",
                "requestFrom"
            ],
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ac0": {
            "entrypoint": "0x08002ac0",
            "current_name": "send_single_byte_08002ac0",
            "code": "\n/* DWARF original prototype: uint8_t  endTransmission(TwoWire * wireObject) */\n\nuint8_t __wireObjectcall TwoWire::sendSingleByte_08002ac0(TwoWire *wireObject)\n\n{\n  uint8_t transmissionResult;\n  \n  transmissionResult = endTransmission(wireObject,'\\x01');\n  return transmissionResult;\n}\n\n",
            "renaming": {
                "FUN_08002ac0": "send_single_byte_08002ac0",
                "this": "wireObject",
                "uVar1": "transmissionResult"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "endTransmission"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002acc": {
            "entrypoint": "0x08002acc",
            "current_name": "resize_rx_buffer_08002acc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::resizeRxBuffer_08002acc(size_t newSize)\n\n{\n  if (currentSize < newSize) {\n    if (newSize < 0x20) {\n      newSize = 0x20;\n    }\n    buffer = (uint8_t *)realloc(buffer,newSize);\n    if (buffer == (uint8_t *)0x0) {\n      currentSize = '\\0';\n    }\n    else {\n      currentSize = (uint8_t)newSize;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002acc": "resize_rx_buffer_08002acc",
                "length": "newSize",
                "rxBufferAllocated": "currentSize",
                "rxBuffer": "buffer"
            },
            "calling": [
                "onReceiveService",
                "requestFrom"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b00": {
            "entrypoint": "0x08002b00",
            "current_name": "handle_received_data_08002b00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::handleReceivedData_08002b00(uint8_t *receivedBytes,int numberOfBytes)\n\n{\n  if ((onReceiveCallback != (_func_void_int *)0x0) && (receiveBufferLength <= receiveBufferIndex)) {\n    allocateReceiveBuffer(numberOfBytes);\n    if (receiveBuffer == (uint8_t *)0x0) {\n      _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/libraries/Wire/src/Wire.cpp\"\n                     ,0x183);\n    }\n    copyMemory(receiveBuffer,receivedBytes,numberOfBytes);\n    receiveBufferIndex = '\\0';\n    receiveBufferLength = (uint8_t)numberOfBytes;\n    (*onReceiveCallback)(numberOfBytes);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b00": "handle_received_data_08002b00",
                "inBytes": "receivedBytes",
                "numBytes": "numberOfBytes",
                "user_onReceive": "onReceiveCallback",
                "rxBufferLength": "receiveBufferLength",
                "rxBufferIndex": "receiveBufferIndex",
                "allocateRxBuffer": "allocateReceiveBuffer",
                "rxBuffer": "receiveBuffer",
                "memcpy": "copyMemory"
            },
            "calling": [],
            "called": [
                "_Error_Handler",
                "allocateRxBuffer",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b68": {
            "entrypoint": "0x08002b68",
            "current_name": "request_from_08002b68",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08002bb2 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: uint8_t  requestFrom_08002b68(TwoWire * wireObject, uint8_t deviceAddress, uint8_t dataLength,\n   uint32_t internalAddress, uint8_t internalSize, uint8_t stopSignal) */\n\nuint8_t __wireObjectcall\nTwoWire::requestFrom_08002b68(TwoWire *wireObject,uint8_t deviceAddress,uint8_t dataLength,uint32_t internalAddress,uint8_t internalSize,\n          uint8_t stopSignal)\n\n{\n  i2cStatusConflict status;\n  uint size;\n  \n  size = (uint)internalSize;\n  if (wireObject->master == false) {\n    return '\\0';\n  }\n  allocateReceiveBuffer((uint)dataLength);\n  if (receiveBuffer != (uint8_t *)0x0) {\n    if (size != 0) {\n      startTransmission(wireObject,deviceAddress);\n      if (3 < size) {\n        size = 3;\n      }\n      while( true ) {\n        if (size == 0) break;\n        (**(wireObject->super_Stream).super_Print._vptr_Print)\n                  (wireObject,internalAddress >> ((size - 1 & 0x1f) << 3) & 0xff);\n        size = size - 1 & 0xff;\n      }\n      finishTransmission(wireObject,'\\0');\n    }\n    status = i2c_master_read((i2cConflict *)&wireObject->_i2c,deviceAddress << 1,receiveBuffer,(ushort)dataLength);\n    if (status != i2cOK) {\n      dataLength = '\\0';\n    }\n    receiveBufferIndex = '\\0';\n    receiveBufferLength = dataLength;\n    return dataLength;\n  }\n  (wireObject->super_Stream).super_Print.write_error = 1;\n  return '\\0';\n}\n\n",
            "renaming": {
                "this": "wireObject",
                "address": "deviceAddress",
                "quantity": "dataLength",
                "iaddress": "internalAddress",
                "isize": "internalSize",
                "sendStop": "stopSignal",
                "iVar1": "status",
                "uVar2": "size",
                "allocateRxBuffer": "allocateReceiveBuffer",
                "rxBuffer": "receiveBuffer",
                "beginTransmission": "startTransmission",
                "endTransmission": "finishTransmission",
                "i2c_status_e_conflict": "i2cStatusConflict",
                "i2c_t_conflict": "i2cConflict",
                "I2C_OK": "i2cOK",
                "rxBufferIndex": "receiveBufferIndex",
                "rxBufferLength": "receiveBufferLength",
                "FUN_08002b68": "request_from_08002b68"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "beginTransmission",
                "i2c_master_read",
                "allocateRxBuffer",
                "endTransmission"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c00": {
            "entrypoint": "0x08002c00",
            "current_name": "read_data_from_i2_c_08002c00",
            "code": "\n/* DWARF original prototype: uint8_t  requestFrom(TwoWire * pointerToWireObject, uint8_t deviceAddress, uint8_t dataQuantity,\n   uint8_t stopSignal) */\n\nuint8_t __pointerToWireObjectcall\nTwoWire::readDataFromI2C_08002c00(TwoWire *pointerToWireObject,uint8_t deviceAddress,uint8_t dataQuantity,uint8_t stopSignal)\n\n{\n  uint8_t dataReceived;\n  \n  dataReceived = requestFrom(pointerToWireObject,deviceAddress,dataQuantity,0,'\\0',stopSignal);\n  return dataReceived;\n}\n\n",
            "renaming": {
                "this": "pointerToWireObject",
                "address": "deviceAddress",
                "quantity": "dataQuantity",
                "sendStop": "stopSignal",
                "uVar1": "dataReceived",
                "FUN_08002c00": "read_data_from_i2_c_08002c00"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "requestFrom"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c14": {
            "entrypoint": "0x08002c14",
            "current_name": "request_from_with_quantity_08002c14",
            "code": "\n/* DWARF original prototype: uint8_t  requestFrom(TwoWire * wireObject, uint8_t deviceAddress, uint8_t dataQuantity)\n    */\n\nuint8_t __wireObjectcall TwoWire::requestFromWithQuantity_08002c14(TwoWire *wireObject,uint8_t deviceAddress,uint8_t dataQuantity)\n\n{\n  uint8_t result;\n  \n  result = requestFrom(wireObject,deviceAddress,dataQuantity,'\\x01');\n  return result;\n}\n\n",
            "renaming": {
                "this": "wireObject",
                "address": "deviceAddress",
                "quantity": "dataQuantity",
                "uVar1": "result",
                "FUN_08002c14": "request_from_with_quantity_08002c14"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "requestFrom"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c1e": {
            "entrypoint": "0x08002c1e",
            "current_name": "initialize_static_variables_08002c1e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_08002c1e(void)\n\n{\n  initialize_and_destruct_static_vars(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c1e": "initialize_static_variables_08002c1e",
                "__static_initialization_and_destruction_0": "initialize_and_destruct_static_vars"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2c": {
            "entrypoint": "0x08002c2c",
            "current_name": "handle_analog_command_08002c2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleAnalogCommand_08002c2c(void *data,uint8_t commandCode,uint16_t commandValue)\n\n{\n  if (callbackFunctionPointer != (callbackFunction)0x0) {\n    (*callbackFunctionPointer)(commandCode,(int)commandValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c2c": "handle_analog_command_08002c2c",
                "param_1": "data",
                "command": "commandCode",
                "value": "commandValue",
                "currentAnalogCallback": "callbackFunctionPointer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c40": {
            "entrypoint": "0x08002c40",
            "current_name": "handle_digital_command_08002c40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleDigitalCommand_08002c40(void *data,uint8_t command,uint16_t value)\n\n{\n  if (digitalCallback != (callbackFunction)0x0) {\n    (*digitalCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c40": "handle_digital_command_08002c40",
                "param_1": "data",
                "currentDigitalCallback": "digitalCallback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "process_firmata_command_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::processFirmataCommand_08002c54(void *data,uint8_t pinCommand,uint16_t pinValue)\n\n{\n  if (callback != (callbackFunction)0x0) {\n    (*callback)(pinCommand,(int)pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "process_firmata_command_08002c54",
                "param_1": "data",
                "command": "pinCommand",
                "value": "pinValue",
                "currentPinModeCallback": "callback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c68": {
            "entrypoint": "0x08002c68",
            "current_name": "process_pin_value_08002c68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::processPinValue_08002c68(void *data,uint8_t pinCommand,uint16_t pinValue)\n\n{\n  if (pinValueCallback != (callbackFunction)0x0) {\n    (*pinValueCallback)(pinCommand,(int)pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data",
                "command": "pinCommand",
                "value": "pinValue",
                "currentPinValueCallback": "pinValueCallback",
                "FUN_08002c68": "process_pin_value_08002c68"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c7c": {
            "entrypoint": "0x08002c7c",
            "current_name": "report_analog_callback_08002c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::reportAnalogCallback_08002c7c(void *data,uint8_t command,uint16_t value)\n\n{\n  if (currentReportAnalogCallback != (callbackFunction)0x0) {\n    (*currentReportAnalogCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "data",
                "FUN_08002c7c": "report_analog_callback_08002c7c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c90": {
            "entrypoint": "0x08002c90",
            "current_name": "report_digital_command_08002c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::reportDigitalCommand_08002c90(void *data,uint8_t digitalCommand,uint16_t digitalValue)\n\n{\n  if (callback != (callbackFunction)0x0) {\n    (*callback)(digitalCommand,(int)digitalValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c90": "report_digital_command_08002c90",
                "param_1": "data",
                "command": "digitalCommand",
                "value": "digitalValue",
                "currentReportDigitalCallback": "callback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "call_string_callback_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::callStringCallback_08002ca4(void *param,char *string)\n\n{\n  if (currentStringCallback != (stringCallbackFunction)0x0) {\n    (*currentStringCallback)(string);\n  }\n  return;\n}\n\n",
            "renaming": {
                "param_1": "param",
                "c_str": "string",
                "FUN_08002ca4": "call_string_callback_08002ca4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb8": {
            "entrypoint": "0x08002cb8",
            "current_name": "handle_sysex_command_08002cb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleSysexCommand_08002cb8(void *data,uint8_t opcode,size_t argumentCount,uint8_t *arguments)\n\n{\n  if (currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*currentSysexCallback)(opcode,(uint8_t)argumentCount,arguments);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cb8": "handle_sysex_command_08002cb8",
                "param_1": "data",
                "command": "opcode",
                "argc": "argumentCount",
                "argv": "arguments"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cd0": {
            "entrypoint": "0x08002cd0",
            "current_name": "handle_system_reset_08002cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::handleSystemReset_08002cd0(void *data)\n\n{\n  if (resetCallback != (callbackFunction)0x0) {\n    (*resetCallback)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cd0": "handle_system_reset_08002cd0",
                "param_1": "data",
                "currentSystemResetCallback": "resetCallback",
                "systemCallbackFunction": "callbackFunction"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ce0": {
            "entrypoint": "0x08002ce0",
            "current_name": "initialize_firmata_08002ce0",
            "code": "\n/* DWARF original prototype: Firmata *  Firmata(Firmata * firmata) */\n\nFirmata * __firmatacall firmata::Firmata::initializeFirmata_08002ce0(Firmata *firmata)\n\n{\n  FirmataParser *parser;\n  \n  FirmataMarshaller::FirmataMarshaller(&firmata->firmataMarshaller);\n  parser = &firmata->parser;\n  FirmataParser::FirmataParser(parser,firmata->buffer,0x40);\n  firmata->versionCount = '\\0';\n  firmata->versionVector = (byte *)0x0;\n  firmata->isBlinkVersionDisabled = false;\n  FirmataParser::attach(parser,0xe0,analogCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,0x90,digitalCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,0xc0,reportAnalogCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,0xd0,reportDigitalCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,0xf4,pinModeCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,0xf5,pinValueCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,'q',stringCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,0xf0,sysexCallback + 1,(void *)0x0);\n  FirmataParser::attach(parser,'y',reportFirmwareCallback + 1,firmata);\n  FirmataParser::attach(parser,0xf9,reportVersionCallback + 1,firmata);\n  FirmataParser::attach(parser,0xff,systemResetCallback + 1,(void *)0x0);\n  return firmata;\n}\n\n",
            "renaming": {
                "FirmataClass": "Firmata",
                "this": "firmata",
                "this_00": "parser",
                "marshaller": "firmataMarshaller",
                "parserBuffer": "buffer",
                "firmwareVersionCount": "versionCount",
                "firmwareVersionVector": "versionVector",
                "blinkVersionDisabled": "isBlinkVersionDisabled",
                "staticAnalogCallback": "analogCallback",
                "staticDigitalCallback": "digitalCallback",
                "staticReportAnalogCallback": "reportAnalogCallback",
                "staticReportDigitalCallback": "reportDigitalCallback",
                "staticPinModeCallback": "pinModeCallback",
                "staticPinValueCallback": "pinValueCallback",
                "staticStringCallback": "stringCallback",
                "staticSysexCallback": "sysexCallback",
                "staticReportFirmwareCallback": "reportFirmwareCallback",
                "staticReportVersionCallback": "reportVersionCallback",
                "staticSystemResetCallback": "systemResetCallback",
                "FUN_08002ce0": "initialize_firmata_08002ce0"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "attach",
                "attach",
                "attach",
                "FirmataParser",
                "FirmataMarshaller",
                "attach",
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dbc": {
            "entrypoint": "0x08002dbc",
            "current_name": "initialize_firmata_08002dbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFirmata_08002dbc(int initializeFlag,int priorityLevel)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    FirmataConstructor(&Firmata);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002dbc": "initialize_firmata_08002dbc",
                "__initialize_p": "initializeFlag",
                "__priority": "priorityLevel",
                "firmata::FirmataClass::FirmataClass": "FirmataConstructor"
            },
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "called": [
                "FirmataClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ddc": {
            "entrypoint": "0x08002ddc",
            "current_name": "send_firmata_version_08002ddc",
            "code": "\n/* DWARF original prototype: void  printVersion(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::sendFirmataVersion_08002ddc(FirmataClass *firmataInstance)\n\n{\n  FirmataMarshaller::sendVersion(&firmataInstance->marshaller,'\\x02','\\x05');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ddc": "send_firmata_version_08002ddc",
                "this": "firmataInstance"
            },
            "calling": [
                "begin",
                "staticReportVersionCallback"
            ],
            "called": [
                "sendVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dea": {
            "entrypoint": "0x08002dea",
            "current_name": "print_firmata_version_08002dea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::printFirmataVersion_08002dea(void *ctx)\n\n{\n  if (ctx != (void *)0x0) {\n    printVersion((FirmataClass *)ctx);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "context": "ctx",
                "FUN_08002dea": "print_firmata_version_08002dea"
            },
            "calling": [],
            "called": [
                "printVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002df6": {
            "entrypoint": "0x08002df6",
            "current_name": "print_firmware_version_08002df6",
            "code": "\n/* DWARF original prototype: void  printFirmwareVersion_08002df6(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::printFirmwareVersion_08002df6(FirmataClass *firmataInstance)\n\n{\n  uint8_t *versionVector;\n  \n  if (firmataInstance->firmwareVersionCount == 0) {\n    return;\n  }\n  versionVector = firmataInstance->firmwareVersionVector;\n  sendFirmwareVersion\n            (&firmataInstance->marshaller,*versionVector,versionVector[1],firmataInstance->firmwareVersionCount - 2,versionVector + 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002df6": "print_firmware_version_08002df6",
                "this": "firmataInstance",
                "puVar1": "versionVector",
                "FirmataMarshaller::sendFirmwareVersion": "sendFirmwareVersion"
            },
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "called": [
                "sendFirmwareVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e1a": {
            "entrypoint": "0x08002e1a",
            "current_name": "print_firmware_version_if_needed_08002e1a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::printFirmwareVersionIfNeeded_08002e1a(void *firmataInstance,size_t size,size_t otherSize,char *message)\n\n{\n  if (firmataInstance != (void *)0x0) {\n    printFirmwareVersion((FirmataClass *)firmataInstance);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e1a": "print_firmware_version_if_needed_08002e1a",
                "context": "firmataInstance",
                "param_2": "size",
                "param_3": "otherSize",
                "param_4": "message"
            },
            "calling": [],
            "called": [
                "printFirmwareVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e26": {
            "entrypoint": "0x08002e26",
            "current_name": "initialize_firmata_08002e26",
            "code": "\n/* DWARF original prototype: void  begin(FirmataClastreamstream * firmataInstance, Stream * stream) */\n\nvoid __firmataInstancecall firmata::FirmataClastreamstream::initializeFirmata_08002e26(FirmataClastreamstream *firmataInstance,Stream *stream)\n\n{\n  firmataInstance->stream = stream;\n  marshallerBegin(&firmataInstance->marstreamhaller,stream);\n  printLibraryVersion(firmataInstance);\n  printFirmwareInformation(firmataInstance);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e26": "initialize_firmata_08002e26",
                "this": "firmataInstance",
                "s": "stream",
                "FirmataStream": "stream",
                "FirmataMarshaller::begin": "marshallerBegin",
                "printVersion": "printLibraryVersion",
                "printFirmwareVersion": "printFirmwareInformation"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "printFirmwareVersion",
                "printVersion",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e44": {
            "entrypoint": "0x08002e44",
            "current_name": "set_firmware_name_and_version_08002e44",
            "code": "\n/* DWARF original prototype: void  setFirmwareNameAndVersion_08002e44(FirmataClass * firmata, char * filePath, byte\n   majorVersion, byte minorVersion) */\n\nvoid __firmatacall\nfirmata::FirmataClass::setFirmwareNameAndVersion_08002e44(FirmataClass *firmata,char *filePath,byte majorVersion,byte minorVersion)\n\n{\n  byte count;\n  char *cppExtension;\n  char *slashBackward;\n  char *lastSlashOrBackward;\n  char *fileName;\n  byte *versionVector;\n  size_t fileNameLength;\n  \n  cppExtension = strstr(filePath,\".cpp\");\n  lastSlashOrBackward = strrchr(filePath,0x2f);\n  if (lastSlashOrBackward == (char *)0x0) {\n    lastSlashOrBackward = strrchr(filePath,0x5c);\n  }\n  if (lastSlashOrBackward != (char *)0x0) {\n    filePath = lastSlashOrBackward + 1;\n  }\n  if (cppExtension == (char *)0x0) {\n    fileNameLength = strlen(filePath);\n    firmata->firmwareVersionCount = (char)fileNameLength + '\\x02';\n  }\n  else {\n    firmata->firmwareVersionCount = ((char)cppExtension - (char)filePath) + '\\x02';\n  }\n  free(firmata->firmwareVersionVector);\n  count = firmata->firmwareVersionCount;\n  versionVector = (byte *)malloc(count + 1);\n  firmata->firmwareVersionVector = versionVector;\n  versionVector[count] = '\\0';\n  *versionVector = majorVersion;\n  versionVector[1] = minorVersion;\n  strncpy((char *)(versionVector + 2),filePath,firmata->firmwareVersionCount - 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e44": "set_firmware_name_and_version_08002e44",
                "this": "firmata",
                "name": "filePath",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bVar1": "count",
                "pcVar2": "cppExtension",
                "extension": "slashBackward",
                "pcVar3": "lastSlashOrBackward",
                "firmwareName": "fileName",
                "pbVar4": "versionVector",
                "sVar5": "fileNameLength"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "free",
                "strrchr",
                "strncpy",
                "strstr",
                "strlen",
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec4": {
            "entrypoint": "0x08002ec4",
            "current_name": "get_available_08002ec4",
            "code": "\n/* DWARF original prototype: int  available(FirmataClass * firmataInstance) */\n\nint __firmataInstancecall firmata::FirmataClass::getAvailable_08002ec4(FirmataClass *firmataInstance)\n\n{\n  int result;\n  \n  result = (*(firmataInstance->FirmataStream->super_Print)._vptr_Print[2])();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002ec4": "get_available_08002ec4",
                "this": "firmataInstance",
                "iVar1": "result"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed2": {
            "entrypoint": "0x08002ed2",
            "current_name": "process_input_08002ed2",
            "code": "\n/* DWARF original prototype: void  processInput_08002ed2(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::processInput_08002ed2(FirmataClass *firmataInstance)\n\n{\n  int returnValue;\n  int inputData;\n  \n  returnValue = (*(firmataInstance->FirmataStream->super_Print)._vptr_Print[3])();\n  if (returnValue != -1) {\n    FirmataParser::parse(&firmataInstance->parser,(uint8_t)returnValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "firmataInstance",
                "iVar1": "returnValue",
                "FUN_08002ed2": "process_input_08002ed2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "parse"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ef2": {
            "entrypoint": "0x08002ef2",
            "current_name": "send_analog_value_08002ef2",
            "code": "\n/* DWARF original prototype: void  sendAnalog(FirmataClass * firmataInstance, byte analogPin, int analogValue) */\n\nvoid __firmataInstancecall firmata::FirmataClass::sendAnalogValue_08002ef2(FirmataClass *firmataInstance,byte analogPin,int analogValue)\n\n{\n  sendAnalogData(&firmataInstance->marshaller,analogPin,(uint16_t)analogValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ef2": "send_analog_value_08002ef2",
                "this": "firmataInstance",
                "pin": "analogPin",
                "value": "analogValue",
                "FirmataMarshaller::sendAnalog": "sendAnalogData"
            },
            "calling": [
                "loop",
                "reportAnalogCallback"
            ],
            "called": [
                "sendAnalog"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efe": {
            "entrypoint": "0x08002efe",
            "current_name": "send_digital_port_08002efe",
            "code": "\n/* DWARF original prototype: void  sendDigitalPort_08002efe(FirmataClass * instance, byte portNumber, int\n   portData) */\n\nvoid __instancecall firmata::FirmataClass::sendDigitalPort_08002efe(FirmataClass *instance,byte portNumber,int portData)\n\n{\n  FirmataMarshaller::sendDigitalPort_08002efe(&instance->marshaller,portNumber,(uint16_t)portData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002efe": "send_digital_port_08002efe",
                "this": "instance"
            },
            "calling": [
                "outputPort"
            ],
            "called": [
                "sendDigitalPort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f0a": {
            "entrypoint": "0x08002f0a",
            "current_name": "send_sysex_data_08002f0a",
            "code": "\n/* DWARF original prototype: void  sendSysex(Firmata * firmataInstance, byte sysexCommand, byte numBytes, byte *\n   byteArray) */\n\nvoid __firmataInstancecall\nfirmata::Firmata::sendSysexData_08002f0a(Firmata *firmataInstance,byte sysexCommand,byte numBytes,byte *byteArray)\n\n{\n  FirmataMarshaller::sendSysex(&firmataInstance->marshaller,sysexCommand,(uint)numBytes,byteArray);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f0a": "send_sysex_data_08002f0a",
                "FirmataClass": "Firmata",
                "this": "firmataInstance",
                "command": "sysexCommand",
                "bytec": "numBytes",
                "bytev": "byteArray"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "sendSysex"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f14": {
            "entrypoint": "0x08002f14",
            "current_name": "send_string_08002f14",
            "code": "\n/* DWARF original prototype: void  sendString_08002f14(FirmataClass * firmata, char * inputString) */\n\nvoid __firmatacall firmata::FirmataClass::sendString_08002f14(FirmataClass *firmata,char *inputString)\n\n{\n  FirmataMarshaller::sendString_08002f14(&firmata->marshaller,inputString);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f14": "send_string_08002f14",
                "this": "firmata",
                "string": "inputString"
            },
            "calling": [
                "setPinModeCallback",
                "readAndReportData",
                "attachServo",
                "sysexCallback"
            ],
            "called": [
                "sendString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f1e": {
            "entrypoint": "0x08002f1e",
            "current_name": "write_data_to_stream_08002f1e",
            "code": "\n/* DWARF original prototype: void  write(FirmataClass * firmataInstance, byte c) */\n\nssize_t __firmataInstancecall\nfirmata::FirmataClass::writeDataToStream_08002f1e(FirmataClass *firmataInstance,int fileDescriptor,void *buffer,size_t length)\n\n{\n  int returnValue;\n  \n  returnValue = (**(firmataInstance->FirmataStream->super_Print)._vptr_Print)();\n  return returnValue;\n}\n\n",
            "renaming": {
                "this": "firmataInstance",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "length",
                "iVar1": "returnValue",
                "FUN_08002f1e": "write_data_to_stream_08002f1e"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f2c": {
            "entrypoint": "0x08002f2c",
            "current_name": "update_callback_function_08002f2c",
            "code": "\n/* DWARF original prototype: void  attach(FirmataClass * firmataClassInstance, uint8_t opcode, callbackFunction\n   callback) */\n\nvoid __firmataClassInstancecall\nfirmata::FirmataClass::updateCallbackFunction_08002f2c(FirmataClass *firmataClassInstance,uint8_t opcode,callbackFunction callback)\n\n{\n  callbackFunction currentCallback;\n  \n  if (opcode == 0xd0) {\n    currentReportDigitalCallback = callback;\n    return;\n  }\n  if (0xd0 < opcode) {\n    if (opcode == 0xf4) {\n      currentPinModeCallback = callback;\n      return;\n    }\n    currentCallback = callback;\n    if ((opcode != 0xf5) && (currentCallback = currentPinValueCallback, opcode == 0xe0)) {\n      currentAnalogCallback = callback;\n      return;\n    }\n    currentPinValueCallback = currentCallback;\n    return;\n  }\n  if (opcode == 0x90) {\n    currentDigitalCallback = callback;\n    return;\n  }\n  if (opcode != 0xc0) {\n    return;\n  }\n  currentReportAnalogCallback = callback;\n  return;\n}\n\n",
            "renaming": {
                "this": "firmataClassInstance",
                "command": "opcode",
                "newFunction": "callback",
                "p_Var1": "currentCallback",
                "FUN_08002f2c": "update_callback_function_08002f2c"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f84": {
            "entrypoint": "0x08002f84",
            "current_name": "handle_system_callback_08002f84",
            "code": "\n/* DWARF original prototype: void  attach(FirmataClass * firmataInstance, uint8_t receivedCommand,\n   systemCallbackFunction callbackFunction) */\n\nvoid __firmataInstancecall\nfirmata::FirmataClass::handleSystemCallback_08002f84(FirmataClass *firmataInstance,uint8_t receivedCommand,systemCallbackFunction callbackFunction)\n\n{\n  if (receivedCommand == 0xff) {\n    currentSystemResetCallback = callbackFunction;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f84": "handle_system_callback_08002f84",
                "this": "firmataInstance",
                "command": "receivedCommand",
                "newFunction": "callbackFunction"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f94": {
            "entrypoint": "0x08002f94",
            "current_name": "set_sysex_callback_08002f94",
            "code": "\n/* DWARF original prototype: void  attach(FirmataClass * self, uint8_t sysexCommand,\n   sysexCallbackFunction callback) */\n\nvoid __selfcall\nfirmata::FirmataClass::setSysexCallback_08002f94(FirmataClass *self,uint8_t sysexCommand,sysexCallbackFunction callback)\n\n{\n  currentSysexCallback = callback;\n  return;\n}\n\n",
            "renaming": {
                "this": "self",
                "command": "sysexCommand",
                "newFunction": "callback",
                "FUN_08002f94": "set_sysex_callback_08002f94"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fa0": {
            "entrypoint": "0x08002fa0",
            "current_name": "get_pin_mode_08002fa0",
            "code": "\n/* DWARF original prototype: byte  getPinMode_08002fa0(FirmataClass * firmataObject, byte pinNumber) */\n\nbyte __firmataObjectcall firmata::FirmataClass::getPinMode_08002fa0(FirmataClass *firmataObject,byte pinNumber)\n\n{\n  return firmataObject->pinConfiguration[pinNumber];\n}\n\n",
            "renaming": {
                "FUN_08002fa0": "get_pin_mode_08002fa0",
                "this": "firmataObject",
                "pin": "pinNumber",
                "pinConfig": "pinConfiguration"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "analogWriteCallback",
                "setPinModeCallback",
                "loop",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fa8": {
            "entrypoint": "0x08002fa8",
            "current_name": "update_pin_config_08002fa8",
            "code": "\n/* DWARF original prototype: void  setPinMode(FirmataClass * fClass, byte pinNumber, byte newConfig) */\n\nvoid __fClasscall firmata::FirmataClass::updatePinConfig_08002fa8(FirmataClass *fClass,byte pinNumber,byte newConfig)\n\n{\n  if (fClass->pinNumberConfig[pinNumber] != '\\x7f') {\n    fClass->pinNumberConfig[pinNumber] = newConfig;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fa8": "update_pin_config_08002fa8",
                "this": "fClass",
                "pin": "pinNumber",
                "config": "newConfig"
            },
            "calling": [
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fba": {
            "entrypoint": "0x08002fba",
            "current_name": "get_pin_state_08002fba",
            "code": "\n/* DWARF original prototype: int  getPinState_08002fba(FirmataClass * instance, byte pinNumber) */\n\nint __instancecall firmata::FirmataClass::getPinState_08002fba(FirmataClass *instance,byte pinNumber)\n\n{\n  return instance->pinNumberState[pinNumber];\n}\n\n",
            "renaming": {
                "FUN_08002fba": "get_pin_state_08002fba",
                "this": "instance",
                "pin": "pinNumber"
            },
            "calling": [
                "digitalWriteCallback",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fc2": {
            "entrypoint": "0x08002fc2",
            "current_name": "set_pin_state_08002fc2",
            "code": "\n/* DWARF original prototype: void  setPinState_08002fc2(FirmataClass * instance, byte pinNumber, int newState) */\n\nvoid __instancecall firmata::FirmataClass::setPinState_08002fc2(FirmataClass *instance,byte pinNumber,int newState)\n\n{\n  instance->pinNumberState[pinNumber] = newState;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fc2": "set_pin_state_08002fc2",
                "this": "instance",
                "pin": "pinNumber",
                "state": "newState"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fca": {
            "entrypoint": "0x08002fca",
            "current_name": "strobe_blink_pin_08002fca",
            "code": "\n/* DWARF original prototype: void  strobeBlinkPin_08002fca(FirmataClass * thisPointer, byte pinNumber, int blinkCount, int\n   onDuration, int offDuration) */\n\nvoid __thisPointercall\nfirmata::FirmataClass::strobeBlinkPin_08002fca(FirmataClass *thisPointer,byte pinNumber,int blinkCount,int onDuration,int offDuration)\n\n{\n  uint iteration;\n  \n  for (iteration = 0; (int)iteration < blinkCount; iteration = iteration + 1 & 0xff) {\n    delay(offDuration);\n    digitalWrite((uint)pinNumber,1);\n    delay(onDuration);\n    digitalWrite((uint)pinNumber,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fca": "strobe_blink_pin_08002fca",
                "this": "thisPointer",
                "pin": "pinNumber",
                "count": "blinkCount",
                "onInterval": "onDuration",
                "offInterval": "offDuration",
                "uVar1": "iteration"
            },
            "calling": [
                "blinkVersion"
            ],
            "called": [
                "digitalWrite",
                "delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003002": {
            "entrypoint": "0x08003002",
            "current_name": "blink_version_08003002",
            "code": "\n/* DWARF original prototype: void  blinkVersion_08003002(FirmataClass * firmataInstance) */\n\nvoid __firmataInstancecall firmata::FirmataClass::blinkVersion_08003002(FirmataClass *firmataInstance)\n\n{\n  if (firmataInstance->isBlinkVersionDisabled != false) {\n    return;\n  }\n  pinMode(0xd,1);\n  strobeBlinkPin(firmataInstance,'\\r',2,0x28,0xd2);\n  delay(0xfa);\n  strobeBlinkPin(firmataInstance,'\\r',5,0x28,0xd2);\n  delay(0x7d);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003002": "blink_version_08003002",
                "this": "firmataInstance",
                "blinkVersionDisabled": "isBlinkVersionDisabled"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "strobeBlinkPin",
                "delay",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003048": {
            "entrypoint": "0x08003048",
            "current_name": "initialize_firmata_08003048",
            "code": "\n/* DWARF original prototype: void  beginTransmission(FirmataClass * firmataObject, long baudRate) */\n\nvoid __firmataObjectcall firmata::FirmataClass::initializeFirmata_08003048(FirmataClass *firmataObject,long baudRate)\n\n{\n  initializeSerial(serialPort,baudRate,'\\x06');\n  blinkFirmwareVersion(firmataObject);\n  beginTransmission(firmataObject,transmissionStream);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003048": "initialize_firmata_08003048",
                "this": "firmataObject",
                "speed": "baudRate",
                "HardwareSerial::begin": "initializeSerial",
                "&Serial2": "serialPort",
                "blinkVersion": "blinkFirmwareVersion",
                "begin": "beginTransmission",
                "&Serial2.super_Stream": "transmissionStream"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "initialize_static_data_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_0800306c(void)\n\n{\n  initialize_and_destroy(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "initialize_static_data_0800306c",
                "__static_initialization_and_destruction_0": "initialize_and_destroy"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800307a": {
            "entrypoint": "0x0800307a",
            "current_name": "encode_byte_stream_0800307a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003102 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  encodeByteStream_0800307a(FirmataMarshaller * marshaller, size_t numBytes, uint8_t\n   * byteArray, size_t maxBytes) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::encodeByteStream_0800307a(FirmataMarshaller *marshaller,size_t numBytes,uint8_t *byteArray,size_t maxBytes)\n\n{\n  uint8_t transmitByte;\n  uint8_t bitCache;\n  uint currentByte;\n  uint bitPosition;\n  uint numEncodedBytes;\n  uint byteIndex;\n  \n  currentByte = (uint)*byteArray;\n  if (maxBytes == 0) {\n    maxBytes = 0xffffffff;\n  }\n  byteIndex = 0;\n  bitPosition = 0;\n  numEncodedBytes = 0;\n  while ((byteIndex < numBytes && (numEncodedBytes < maxBytes))) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)\n              (marshaller->FirmataStream,((uint)byteArray[byteIndex] << (bitPosition & 0xff) | currentByte) & 0x7f);\n    currentByte = (int)(uint)byteArray[byteIndex] >> (7 - bitPosition & 0xff) & 0xff;\n    bitPosition = bitPosition + 1;\n    while ((numEncodedBytes = numEncodedBytes + 1, 6 < bitPosition && (numEncodedBytes < maxBytes))) {\n      (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,currentByte & 0x7f);\n      currentByte = currentByte >> 7;\n      bitPosition = bitPosition - 7;\n    }\n    byteIndex = byteIndex + 1;\n  }\n  if ((bitPosition != 0) && (numEncodedBytes < maxBytes)) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)\n              (marshaller->FirmataStream,(1 << (bitPosition & 0xff)) - 1U & currentByte);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800307a": "encode_byte_stream_0800307a",
                "this": "marshaller",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "max_bytes": "maxBytes",
                "transmit_byte": "transmitByte",
                "outstanding_bit_cache": "bitCache",
                "uVar1": "currentByte",
                "uVar2": "bitPosition",
                "uVar3": "numEncodedBytes",
                "uVar4": "byteIndex"
            },
            "calling": [
                "sendFirmwareVersion",
                "sendSysex",
                "sendAnalog",
                "sendExtendedAnalog",
                "sendDigitalPort"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003106": {
            "entrypoint": "0x08003106",
            "current_name": "send_extended_analog_08003106",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800311e */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendExtendedAnalog_08003106(FirmataMarshaller * marshaller, uint8_t pinNumber, size_t\n   byteCount, uint8_t * byteValues) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendExtendedAnalog_08003106(FirmataMarshaller *marshaller,uint8_t pinNumber,size_t byteCount,uint8_t *byteValues)\n\n{\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0x6f);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)pinNumber);\n    encodeByteStream(marshaller,byteCount,byteValues,byteCount);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "marshaller",
                "pin": "pinNumber",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FUN_08003106": "send_extended_analog_08003106"
            },
            "calling": [
                "sendAnalog"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "initialize_firmata_marshaller_0800314e",
            "code": "\n/* DWARF original prototype: FirmataMarshaller *  FirmataMarshaller(FirmataMarshaller * marshallerInstance) */\n\nFirmataMarshaller * __marshallerInstancecall firmata::FirmataMarshaller::initializeFirmataMarshaller_0800314e(FirmataMarshaller *marshallerInstance)\n\n{\n  marshallerInstance->stream = (Stream *)0x0;\n  return marshallerInstance;\n}\n\n",
            "renaming": {
                "this": "marshallerInstance",
                "FirmataStream": "stream",
                "FUN_0800314e": "initialize_firmata_marshaller_0800314e"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003154": {
            "entrypoint": "0x08003154",
            "current_name": "initialize_firmata_marshaller_08003154",
            "code": "\n/* DWARF original prototype: void  begin(FirmataMarshaller * marshaller, Stream * s) */\n\nvoid __marshallercall firmata::FirmataMarshaller::initializeFirmataMarshaller_08003154(FirmataMarshaller *marshaller,Stream *s)\n\n{\n  marshaller->stream = s;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003154": "initialize_firmata_marshaller_08003154",
                "this": "marshaller",
                "FirmataStream": "stream"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003158": {
            "entrypoint": "0x08003158",
            "current_name": "send_analog_value_08003158",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800318c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendAnalog(FirmataMarshaller * marshaller, uint8_t analogPin, uint16_t analogValue)\n    */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendAnalogValue_08003158(FirmataMarshaller *marshaller,uint8_t analogPin,uint16_t analogValue)\n\n{\n  uint16_t encodedValue;\n  \n  if (marshaller->stream != (Stream *)0x0) {\n    encodedValue = analogValue;\n    if ((analogPin < 0x10) && (analogValue < 0x4000)) {\n      (**(marshaller->stream->super_Print)._vptr_Print)(marshaller,analogPin | 0xe0);\n      encodeByteStream(marshaller,2,(uint8_t *)&encodedValue,2);\n    }\n    else {\n      sendExtendedAnalog(marshaller,analogPin,2,(uint8_t *)&encodedValue);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003158": "send_analog_value_08003158",
                "this": "marshaller",
                "pin": "analogPin",
                "value": "analogValue",
                "local_a": "encodedValue",
                "FirmataStream": "stream"
            },
            "calling": [
                "sendAnalog"
            ],
            "called": [
                "sendExtendedAnalog",
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800319e": {
            "entrypoint": "0x0800319e",
            "current_name": "send_digital_port_0800319e",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031ba */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendDigitalPort_0800319e(FirmataMarshaller * marshaller, uint8_t number,\n   uint16_t data) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendDigitalPort_0800319e(FirmataMarshaller *marshaller,uint8_t number,uint16_t data)\n\n{\n  uint16_t encodedData;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    encodedData = data;\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,number & 0xf | 0x90);\n    encodeByteStream(marshaller,2,(uint8_t *)&encodedData,2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "marshaller",
                "portNumber": "number",
                "portData": "data",
                "local_a": "encodedData",
                "FUN_0800319e": "send_digital_port_0800319e"
            },
            "calling": [
                "sendDigitalPort"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031ce": {
            "entrypoint": "0x080031ce",
            "current_name": "send_firmware_version_080031ce",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031e8 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendFirmwareVersion_080031ce(FirmataMarshaller * marshaller, uint8_t majorVersion,\n   uint8_t minorVersion, size_t byteCount, uint8_t * byteVector) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendFirmwareVersion_080031ce(FirmataMarshaller *marshaller,uint8_t majorVersion,uint8_t minorVersion,size_t byteCount,uint8_t *byteVector)\n\n{\n  _func_int_varargs *printFuncPtr;\n  uint index;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    printFuncPtr = *(marshaller->FirmataStream->super_Print)._vptr_Print;\n    (*printFuncPtr)(marshaller,0xf0,(uint)minorVersion,printFuncPtr,byteCount);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0x79);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)majorVersion);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)minorVersion);\n    for (index = 0; index < byteCount; index = index + 1) {\n      encodeByteStream(marshaller,1,byteVector + index,0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080031ce": "send_firmware_version_080031ce",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "byteCount",
                "bytev": "byteVector",
                "p_Var1": "printFuncPtr",
                "uVar2": "index"
            },
            "calling": [
                "printFirmwareVersion"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800322c": {
            "entrypoint": "0x0800322c",
            "current_name": "send_version_0800322c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003240 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendVersion_0800322c(FirmataMarshaller * marshaller, uint8_t majorVersion, uint8_t\n   minorVersion) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendVersion_0800322c(FirmataMarshaller *marshaller,uint8_t majorVersion,uint8_t minorVersion)\n\n{\n  if (marshaller->stream != (Stream *)0x0) {\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller,0xf9);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)majorVersion);\n    (**(marshaller->stream->super_Print)._vptr_Print)(marshaller->stream,(uint)minorVersion);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800322c": "send_version_0800322c",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "FirmataStream": "stream"
            },
            "calling": [
                "printVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800325a": {
            "entrypoint": "0x0800325a",
            "current_name": "send_sysex_0800325a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003272 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendSysex_0800325a(FirmataMarshaller * marshaller, uint8_t commandCode, size_t\n   byteCount, uint8_t * byteValues) */\n\nvoid __marshallercall\nfirmata::FirmataMarshaller::sendSysex_0800325a(FirmataMarshaller *marshaller,uint8_t commandCode,size_t byteCount,uint8_t *byteValues)\n\n{\n  uint index;\n  \n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)commandCode);\n    for (index = 0; index < byteCount; index = index + 1) {\n      encodeByteStream(marshaller,1,byteValues + index,0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800325a": "send_sysex_0800325a",
                "this": "marshaller",
                "command": "commandCode",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "uVar1": "index"
            },
            "calling": [
                "sendSysex",
                "sendString"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032a2": {
            "entrypoint": "0x080032a2",
            "current_name": "send_string_080032a2",
            "code": "\n/* DWARF original prototype: void  sendString_080032a2(FirmataMarshaller * marshaller, char * inputString) */\n\nvoid __marshallercall firmata::FirmataMarshaller::sendString_080032a2(FirmataMarshaller *marshaller,char *inputString)\n\n{\n  size_t stringLength;\n  \n  stringLength = strlen(inputString);\n  sendSysex(marshaller,'q',stringLength,(uint8_t *)inputString);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080032a2": "send_string_080032a2",
                "this": "marshaller",
                "string": "inputString",
                "bytec": "stringLength"
            },
            "calling": [
                "sendString"
            ],
            "called": [
                "sendSysex",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032bc": {
            "entrypoint": "0x080032bc",
            "current_name": "init_parser_080032bc",
            "code": "\n/* DWARF original prototype: Parser *  Parser(Parser * parser, uint8_t *\n   buffer, size_t bufferSize) */\n\nParser * __parsercall\nfirmata::Parser::initParser_080032bc(Parser *parser,uint8_t *buffer,size_t bufferSize)\n\n{\n  parser->buffer = buffer;\n  parser->bufferSize = bufferSize;\n  parser->multiByteCommand = '\\0';\n  parser->channel = '\\0';\n  parser->isWaitingForData = 0;\n  parser->isParsingSysex = false;\n  parser->sysexBytesRead = 0;\n  parser->analogCallbackContext = (void *)0x0;\n  parser->digitalCallbackContext = (void *)0x0;\n  parser->reportAnalogCallbackContext = (void *)0x0;\n  parser->reportDigitalCallbackContext = (void *)0x0;\n  parser->pinModeCallbackContext = (void *)0x0;\n  parser->pinValueCallbackContext = (void *)0x0;\n  parser->reportFirmwareCallbackContext = (void *)0x0;\n  parser->reportVersionCallbackContext = (void *)0x0;\n  parser->dataBufferOverflowCallbackContext = (void *)0x0;\n  parser->stringCallbackContext = (void *)0x0;\n  parser->sysexCallbackContext = (void *)0x0;\n  parser->systemResetCallbackContext = (void *)0x0;\n  parser->analogCallback = (callbackFunction)0x0;\n  parser->digitalCallback = (callbackFunction)0x0;\n  parser->reportAnalogCallback = (callbackFunction)0x0;\n  parser->reportDigitalCallback = (callbackFunction)0x0;\n  parser->pinModeCallback = (callbackFunction)0x0;\n  parser->pinValueCallback = (callbackFunction)0x0;\n  parser->dataBufferOverflowCallback = (bufferOverflowCallbackFunction)0x0;\n  parser->stringCallback = (stringCallbackFunction)0x0;\n  parser->sysexCallback = (sysexCallbackFunction)0x0;\n  parser->reportFirmwareCallback = (versionCallbackFunction)0x0;\n  parser->reportVersionCallback = (systemCallbackFunction)0x0;\n  parser->systemResetCallback = (systemCallbackFunction)0x0;\n  parser->updateBufferFlag = buffer == (uint8_t *)0x0;\n  return parser;\n}\n\n",
            "renaming": {
                "FirmataParser": "Parser",
                "FUN_080032bc": "init_parser_080032bc",
                "this": "parser",
                "dataBuffer": "buffer",
                "dataBufferSize": "bufferSize",
                "executeMultiByteCommand": "multiByteCommand",
                "multiByteChannel": "channel",
                "waitForData": "isWaitingForData",
                "parsingSysex": "isParsingSysex",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "currentReportAnalogCallbackContext": "reportAnalogCallbackContext",
                "currentReportDigitalCallbackContext": "reportDigitalCallbackContext",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "currentReportFirmwareCallbackContext": "reportFirmwareCallbackContext",
                "currentReportVersionCallbackContext": "reportVersionCallbackContext",
                "currentDataBufferOverflowCallbackContext": "dataBufferOverflowCallbackContext",
                "currentStringCallbackContext": "stringCallbackContext",
                "currentSysexCallbackContext": "sysexCallbackContext",
                "currentSystemResetCallbackContext": "systemResetCallbackContext",
                "currentAnalogCallback": "analogCallback",
                "currentDigitalCallback": "digitalCallback",
                "currentReportAnalogCallback": "reportAnalogCallback",
                "currentReportDigitalCallback": "reportDigitalCallback",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinValueCallback": "pinValueCallback",
                "currentDataBufferOverflowCallback": "dataBufferOverflowCallback",
                "currentStringCallback": "stringCallback",
                "currentSysexCallback": "sysexCallback",
                "currentReportFirmwareCallback": "reportFirmwareCallback",
                "currentReportVersionCallback": "reportVersionCallback",
                "currentSystemResetCallback": "systemResetCallback",
                "allowBufferUpdate": "updateBufferFlag"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003306": {
            "entrypoint": "0x08003306",
            "current_name": "update_callback_08003306",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t cmd, callbackFunc\n   newCallbackFunc, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::updateCallback_08003306(FirmataParser *parser,uint8_t cmd,callbackFunc newCallbackFunc,void *callbackContext)\n\n{\n  if (cmd == 0xd0) {\n    parser->reportDigitalCallback = newCallbackFunc;\n    parser->rdCallbackContext = callbackContext;\n    return;\n  }\n  if (0xd0 < cmd) {\n    if (cmd == 0xf4) {\n      parser->pinModeCallback = newCallbackFunc;\n      parser->pmCallbackContext = callbackContext;\n      return;\n    }\n    if (cmd == 0xf5) {\n      parser->pinValueCallback = newCallbackFunc;\n      parser->pvCallbackContext = callbackContext;\n    }\n    else if (cmd == 0xe0) {\n      parser->analogCallback = newCallbackFunc;\n      parser->acCallbackContext = callbackContext;\n      return;\n    }\n    return;\n  }\n  if (cmd == 0x90) {\n    parser->digitalCallback = newCallbackFunc;\n    parser->dcCallbackContext = callbackContext;\n    return;\n  }\n  if (cmd == 0xc0) {\n    parser->reportAnalogCallback = newCallbackFunc;\n    parser->raCallbackContext = callbackContext;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "parser",
                "command": "cmd",
                "callbackFunction": "callbackFunc",
                "newFunction": "newCallbackFunc",
                "context": "callbackContext",
                "currentReportDigitalCallback": "reportDigitalCallback",
                "currentReportDigitalCallbackContext": "rdCallbackContext",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinModeCallbackContext": "pmCallbackContext",
                "currentPinValueCallback": "pinValueCallback",
                "currentPinValueCallbackContext": "pvCallbackContext",
                "currentAnalogCallback": "analogCallback",
                "currentAnalogCallbackContext": "acCallbackContext",
                "currentDigitalCallback": "digitalCallback",
                "currentDigitalCallbackContext": "dcCallbackContext",
                "currentReportAnalogCallback": "reportAnalogCallback",
                "currentReportAnalogCallbackContext": "raCallbackContext",
                "FUN_08003306": "update_callback_08003306"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003346": {
            "entrypoint": "0x08003346",
            "current_name": "attach_firmware_report_callback_08003346",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t firmwareCommand,\n   versionCallbackFunction callbackFunction, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::attachFirmwareReportCallback_08003346(FirmataParser *parser,uint8_t firmwareCommand,versionCallbackFunction callbackFunction,void *callbackContext)\n\n{\n  if (firmwareCommand == 'y') {\n    parser->currentReportFirmwareCallback = callbackFunction;\n    parser->currentReportFirmwareCallbackContext = callbackContext;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003346": "attach_firmware_report_callback_08003346",
                "this": "parser",
                "command": "firmwareCommand",
                "newFunction": "callbackFunction",
                "context": "callbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003350": {
            "entrypoint": "0x08003350",
            "current_name": "update_callback_08003350",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t opcode,\n   systemCallbackFunction callback, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::updateCallback_08003350(FirmataParser *parser,uint8_t opcode,systemCallbackFunction callback,void *callbackContext)\n\n{\n  if (opcode == 0xf9) {\n    parser->currentReportVersionCallback = callback;\n    parser->currentReportVersionCallbackContext = callbackContext;\n    return;\n  }\n  if (opcode != 0xff) {\n    return;\n  }\n  parser->currentSystemResetCallback = callback;\n  parser->currentSystemResetCallbackContext = callbackContext;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003350": "update_callback_08003350",
                "this": "parser",
                "command": "opcode",
                "newFunction": "callback",
                "context": "callbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003366": {
            "entrypoint": "0x08003366",
            "current_name": "set_string_callback_08003366",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * this, uint8_t command,\n   stringCallbackFunction callbackFunction, void * callbackContext) */\n\nvoid __thiscall\nfirmata::FirmataParser::setStringCallback_08003366(FirmataParser *this,uint8_t command,stringCallbackFunction callbackFunction,void *callbackContext)\n\n{\n  if (command == 'q') {\n    this->currentStringCallback = callbackFunction;\n    this->currentStringCallbackContext = callbackContext;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003366": "set_string_callback_08003366",
                "newFunction": "callbackFunction",
                "context": "callbackContext"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003370": {
            "entrypoint": "0x08003370",
            "current_name": "set_sysex_callback_08003370",
            "code": "\n/* DWARF original prototype: void  attach(FirmataParser * parser, uint8_t sysexCommand,\n   sysexCallbackFunction callbackFunction, void * callbackContext) */\n\nvoid __parsercall\nfirmata::FirmataParser::setSysexCallback_08003370(FirmataParser *parser,uint8_t sysexCommand,sysexCallbackFunction callbackFunction,void *callbackContext)\n\n{\n  parser->currentSysexCallback = callbackFunction;\n  parser->currentSysexCallbackContext = callbackContext;\n  return;\n}\n\n",
            "renaming": {
                "this": "parser",
                "command": "sysexCommand",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "FUN_08003370": "set_sysex_callback_08003370"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003376": {
            "entrypoint": "0x08003376",
            "current_name": "buffer_data_at_position_08003376",
            "code": "\n/* DWARF original prototype: bool  bufferDataAtPosition_08003376(FirmataParser * parser, uint8_t dataByte, size_t\n   position) */\n\nbool __parsercall firmata::FirmataParser::bufferDataAtPosition_08003376(FirmataParser *parser,uint8_t dataByte,size_t position)\n\n{\n  bool bufferOverflow;\n  bool isOverflow;\n  \n  if (position < parser->bufferSize) {\n    bufferOverflow = false;\n  }\n  else {\n    bufferOverflow = true;\n    if (parser->dataBufferOverflowCallback != (bufferOverflowCallbackFunction)0x0) {\n      parser->updateBufferAllowed = true;\n      (*parser->dataBufferOverflowCallback)(parser->dataBufferOverflowCallbackContext);\n      if (position < parser->bufferSize) {\n        bufferOverflow = false;\n      }\n      else {\n        bufferOverflow = true;\n      }\n    }\n  }\n  if (!bufferOverflow) {\n    parser->buffer[position] = dataByte;\n  }\n  return bufferOverflow;\n}\n\n",
            "renaming": {
                "this": "parser",
                "data": "dataByte",
                "pos": "position",
                "bVar1": "bufferOverflow",
                "bufferOverflow": "isOverflow",
                "currentDataBufferOverflowCallback": "dataBufferOverflowCallback",
                "allowBufferUpdate": "updateBufferAllowed",
                "currentDataBufferOverflowCallbackContext": "dataBufferOverflowCallbackContext",
                "dataBuffer": "buffer",
                "dataBufferSize": "bufferSize",
                "FUN_08003376": "buffer_data_at_position_08003376"
            },
            "calling": [
                "processSysexMessage",
                "parse"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033a8": {
            "entrypoint": "0x080033a8",
            "current_name": "decode_byte_stream_080033a8",
            "code": "\n/* DWARF original prototype: size_t  decodeByteStream_080033a8(FirmataParser * parser, size_t byteCount, uint8_t *\n   byteVector) */\n\nsize_t __parsercall\nfirmata::FirmataParser::decodeByteStream_080033a8(FirmataParser *parser,size_t byteCount,uint8_t *byteVector)\n\n{\n  byte currentByte;\n  size_t outputIndex;\n  uint inputIndex;\n  \n  outputIndex = 0;\n  for (inputIndex = 0; inputIndex < byteCount; inputIndex = inputIndex + 2) {\n    currentByte = byteVector[inputIndex];\n    byteVector[outputIndex] = currentByte;\n    byteVector[outputIndex] = byteVector[inputIndex + 1] << 7 | currentByte;\n    outputIndex = outputIndex + 1;\n  }\n  return outputIndex;\n}\n\n",
            "renaming": {
                "FUN_080033a8": "decode_byte_stream_080033a8",
                "this": "parser",
                "bytec": "byteCount",
                "bytev": "byteVector",
                "bVar1": "currentByte",
                "sVar2": "outputIndex",
                "uVar3": "inputIndex"
            },
            "calling": [
                "processSysexMessage"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033cc": {
            "entrypoint": "0x080033cc",
            "current_name": "process_sysex_message_080033cc",
            "code": "\n/* DWARF original prototype: void  processSysexMessage_080033cc(FirmataParser * parser) */\n\nvoid __parsercall firmata::FirmataParser::processSysexMessage_080033cc(FirmataParser *parser)\n\n{\n  uint8_t firstChar;\n  size_t decodedSize;\n  uint8_t *dataPtr;\n  \n  dataPtr = parser->dataBuffer;\n  firstChar = *dataPtr;\n  if (firstChar == 'q') {\n    if (parser->currentStringCallback != (stringCallbackFunction)0x0) {\n      decodedSize = decodeByteStream(parser,parser->sysexBytesRead - 1,dataPtr + 1);\n      bufferDataAtPosition(parser,'\\0',decodedSize + 1);\n      (*parser->currentStringCallback)\n                (parser->currentStringCallbackContext,(char *)(parser->dataBuffer + 1));\n      return;\n    }\n  }\n  else if (firstChar == 'y') {\n    if (parser->currentReportFirmwareCallback != (versionCallbackFunction)0x0) {\n      if (parser->sysexBytesRead < 3) {\n        (*parser->currentReportFirmwareCallback)\n                  (parser->currentReportFirmwareCallbackContext,0,0,(char *)0x0);\n        return;\n      }\n      decodedSize = decodeByteStream(parser,parser->sysexBytesRead - 3,dataPtr + 3);\n      bufferDataAtPosition(parser,'\\0',decodedSize + 3);\n      dataPtr = parser->dataBuffer;\n      (*parser->currentReportFirmwareCallback)\n                (parser->currentReportFirmwareCallbackContext,(uint)dataPtr[1],(uint)dataPtr[2],\n                 (char *)(dataPtr + 3));\n      return;\n    }\n  }\n  else if (parser->currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*parser->currentSysexCallback)\n              (parser->currentSysexCallbackContext,firstChar,parser->sysexBytesRead - 1,dataPtr + 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "parser",
                "uVar1": "firstChar",
                "sVar2": "decodedSize",
                "puVar3": "dataPtr",
                "FUN_080033cc": "process_sysex_message_080033cc"
            },
            "calling": [
                "parse"
            ],
            "called": [
                "decodeByteStream",
                "bufferDataAtPosition"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800344a": {
            "entrypoint": "0x0800344a",
            "current_name": "reset_firmata_parser_0800344a",
            "code": "\n/* DWARF orindexgindexnal prototype: voindexd  systemReset(FindexrmataParser * parser) */\n\nvoindexd __parsercall findexrmata::FindexrmataParser::resetFirmataParser_0800344a(FindexrmataParser *parser)\n\n{\n  sindexze_t index;\n  \n  parser->isWaitingForData = 0;\n  parser->currentMultiByteCommand = '\\0';\n  parser->currentMultiByteChannel = '\\0';\n  for (index = 0; index < parser->bufferSize; index = index + 1) {\n    parser->buffer[index] = '\\0';\n  }\n  parser->isParsingSysex = false;\n  parser->numSysexBytesRead = 0;\n  indexf (parser->resetCallback != (CallbackFunction)0x0) {\n    (*parser->resetCallback)(parser->resetCallbackContext);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800344a": "reset_firmata_parser_0800344a",
                "this": "parser",
                "i": "index",
                "waitForData": "isWaitingForData",
                "executeMultiByteCommand": "currentMultiByteCommand",
                "multiByteChannel": "currentMultiByteChannel",
                "dataBufferSize": "bufferSize",
                "dataBuffer": "buffer",
                "parsingSysex": "isParsingSysex",
                "sysexBytesRead": "numSysexBytesRead",
                "currentSystemResetCallback": "resetCallback",
                "systemCallbackFunction": "CallbackFunction",
                "currentSystemResetCallbackContext": "resetCallbackContext"
            },
            "calling": [
                "parse"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "parse_08003474",
            "code": "\n/* DWARF original prototype: void  parse_08003474(Parser * this, uint8_t inputByte) */\n\nvoid __thiscall firmata::Parser::parse_08003474(Parser *this,uint8_t inputByte)\n\n{\n  byte bVar1;\n  uint input;\n  size_t position;\n  \n  input = (uint)inputByte;\n  if (this->isParsingSysex != false) {\n    if (input != 0xf7) {\n      bufferData(this,inputByte,this->sysexDataRead);\n      this->sysexDataRead = this->sysexDataRead + 1;\n      return;\n    }\n    this->isParsingSysex = false;\n    processSysexMessage(this);\n    return;\n  }\n  if ((this->isWaitingForData == 0) || (0x7f < input)) {\n    if (input < 0xf0) {\n      this->channel = inputByte & 0xf;\n      input = input & 0xf0;\n    }\n    if (input == 0xf0) {\n      this->isParsingSysex = true;\n      this->sysexDataRead = 0;\n      return;\n    }\n    if (input < 0xf1) {\n      if (input != 0xc0) {\n        if (input < 0xc1) {\n          if (input != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (input == 0xd0) goto LAB_0800359c;\n          if (input != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        this->isWaitingForData = 2;\n        this->command = (uint8_t)input;\n        return;\n      }\nLAB_0800359c:\n      this->isWaitingForData = 1;\n      this->command = (uint8_t)input;\n      return;\n    }\n    if (input != 0xf9) {\n      if (0xf9 < input) {\n        if (input == 0xff) {\n          resetSystem(this);\n          return;\n        }\n        return;\n      }\n      if (1 < input - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (this->reportVersionCallback != (systemCallbackFunction)0x0) {\n      (*this->reportVersionCallback)(this->reportVersionCallbackContext);\n    }\n  }\n  else {\n    position = this->isWaitingForData - 1;\n    this->isWaitingForData = position;\n    bufferData(this,inputByte,position);\n    if ((this->isWaitingForData == 0) && (bVar1 = this->command, bVar1 != 0)) {\n      if (bVar1 == 0xd0) {\n        if (this->reportDigitalCallback != (callbackFunction)0x0) {\n          (*this->reportDigitalCallback)\n                    (this->reportDigitalCallbackContext,this->channel,\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if (bVar1 < 0xd1) {\n        if (bVar1 == 0x90) {\n          if (this->digitalCallback != (callbackFunction)0x0) {\n            (*this->digitalCallback)\n                      (this->digitalCallbackContext,this->channel,\n                       (uint16_t)this->dataBuffer[1] + (uint16_t)*this->dataBuffer * 0x80);\n          }\n        }\n        else if ((bVar1 == 0xc0) && (this->reportAnalogCallback != (callbackFunction)0x0)) {\n          (*this->reportAnalogCallback)\n                    (this->reportAnalogCallbackContext,this->channel,\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if (bVar1 == 0xf4) {\n        if (this->pinModeCallback != (callbackFunction)0x0) {\n          (*this->pinModeCallback)\n                    (this->pinModeCallbackContext,this->dataBuffer[1],\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if (bVar1 == 0xf5) {\n        if (this->pinValueCallback != (callbackFunction)0x0) {\n          (*this->pinValueCallback)\n                    (this->pinValueCallbackContext,this->dataBuffer[1],\n                     (uint16_t)*this->dataBuffer);\n        }\n      }\n      else if ((bVar1 == 0xe0) && (this->analogCallback != (callbackFunction)0x0)) {\n        (*this->analogCallback)\n                  (this->analogCallbackContext,this->channel,\n                   (uint16_t)this->dataBuffer[1] + (uint16_t)*this->dataBuffer * 0x80);\n      }\n      this->command = '\\0';\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FirmataParser": "Parser",
                "inputData": "inputByte",
                "uVar2": "input",
                "pos": "position",
                "parsingSysex": "isParsingSysex",
                "sysexBytesRead": "sysexDataRead",
                "waitForData": "isWaitingForData",
                "multiByteChannel": "channel",
                "executeMultiByteCommand": "command",
                "currentReportVersionCallback": "reportVersionCallback",
                "currentReportVersionCallbackContext": "reportVersionCallbackContext",
                "currentReportDigitalCallback": "reportDigitalCallback",
                "currentReportDigitalCallbackContext": "reportDigitalCallbackContext",
                "currentDigitalCallback": "digitalCallback",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "currentReportAnalogCallback": "reportAnalogCallback",
                "currentReportAnalogCallbackContext": "reportAnalogCallbackContext",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "currentPinValueCallback": "pinValueCallback",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "currentAnalogCallback": "analogCallback",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "FUN_08003474": "parse_08003474",
                "bufferDataAtPosition": "bufferData",
                "systemReset": "resetSystem",
                "ushort": "uint16_t"
            },
            "calling": [
                "processInput"
            ],
            "called": [
                "processSysexMessage",
                "systemReset",
                "bufferDataAtPosition"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035b8": {
            "entrypoint": "0x080035b8",
            "current_name": "initialize_rcc_080035b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRCC_080035b8(void)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t hclkFreq;\n  PeriphClkInit PeriphClkInit;\n  ClkInitStruct RCC_ClkInitStruct;\n  OscInitStruct RCC_OscInitStruct;\n  \n  RCC_OscInitStruct.OscillatorType = 2;\n  RCC_OscInitStruct.HSIState = 1;\n  RCC_OscInitStruct.HSICalibrationValue = 0x10;\n  RCC_OscInitStruct.PLL.PLLState = 2;\n  RCC_OscInitStruct.PLL.PLLSource = 0;\n  RCC_OscInitStruct.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig((OscInitStruct_conflict *)&RCC_OscInitStruct);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig((ClkInitStruct_conflict *)&RCC_ClkInitStruct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection = 2;\n  PeriphClkInit.AdcClockSelection = 0x8000;\n  status = HAL_RCCEx_PeriphCLKConfig((PeriphClkInit_conflict *)&PeriphClkInit);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035b8": "initialize_rcc_080035b8",
                "HVar1": "status",
                "uVar2": "hclkFreq",
                "RCC_PeriphCLKInitTypeDef": "PeriphClkInit",
                "RCC_ClkInitTypeDef": "ClkInitStruct",
                "RCC_OscInitTypeDef": "OscInitStruct"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_RCCEx_PeriphCLKConfig",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003658": {
            "entrypoint": "0x08003658",
            "current_name": "initialize_system_08003658",
            "code": "\nvoid initializeSystem_08003658(void)\n\n{\n  int offset;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (offset = 0; (undefined4 *)(offset + 0x20000000) < &completed_8667; offset = offset + 4) {\n    *(undefined4 *)(offset + 0x20000000) = *(undefined4 *)(&_sidata + offset);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800368a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800368a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003658": "initialize_system_08003658",
                "iVar1": "offset",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a0": {
            "entrypoint": "0x080036a0",
            "current_name": "infinite_loop_080036a0",
            "code": "\nvoid infiniteLoop_080036a0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080036a0": "infinite_loop_080036a0"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a2": {
            "entrypoint": "0x080036a2",
            "current_name": "initialize_hw_config_080036a2",
            "code": "\nint initialize_hw_config_080036a2(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_080036a2": "initialize_hw_config_080036a2",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036ac": {
            "entrypoint": "0x080036ac",
            "current_name": "check_pin_validity_080036ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t checkPinValidity_080036ac(PinName_conflict pin)\n\n{\n  uint32_t foundIndex;\n  \n  if ((uint)((int)pin << 0x18) >> 0x1c < 5) {\n    for (foundIndex = 0; (foundIndex < 0x3c && ((int)pin != (int)(char)(&digitalPin)[foundIndex])); foundIndex = foundIndex + 1\n        ) {\n    }\n  }\n  else {\n    foundIndex = 0xffffffff;\n  }\n  return foundIndex;\n}\n\n",
            "renaming": {
                "FUN_080036ac": "check_pin_validity_080036ac",
                "p": "pin",
                "uVar1": "foundIndex"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "analogWriteCallback",
                "systemResetCallback",
                "setPinModeCallback",
                "checkDigitalInputs",
                "loop",
                "reportDigitalCallback",
                "enableI2CPins",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036d4": {
            "entrypoint": "0x080036d4",
            "current_name": "FUNC_080036d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080036d4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036d4": "FUNC_080036d4"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036d8": {
            "entrypoint": "0x080036d8",
            "current_name": "configure_tick_priority_080036d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTickPriority_080036d8(uint32_t tickPriority)\n\n{\n  uint32_t configStatus;\n  \n  configStatus = configureSysTick((uint32_t)((ulonglong)coreClock / (1000 / (ulonglong)tickFrequency))\n                            );\n  if (configStatus != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < tickPriority) {\n    return HAL_ERROR;\n  }\n  setSysTickPriority(sysTickInterrupt,tickPriority,0);\n  tickPriorityStatus = tickPriority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080036d8": "configure_tick_priority_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "configStatus",
                "HAL_SYSTICK_Config": "configureSysTick",
                "SystemCoreClock": "coreClock",
                "uwTickFreq": "tickFrequency",
                "HAL_NVIC_SetPriority": "setSysTickPriority",
                "SysTick_IRQn": "sysTickInterrupt",
                "uwTickPrio": "tickPriorityStatus"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003724": {
            "entrypoint": "0x08003724",
            "current_name": "initialize_hal_08003724",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_HAL_08003724(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  set_NVIC_priority_grouping(3);\n  initialize_tick(0xf);\n  initialize_Msp();\n  return HAL_success;\n}\n\n",
            "renaming": {
                "FUN_08003724": "initialize_hal_08003724",
                "HAL_NVIC_SetPriorityGrouping": "set_NVIC_priority_grouping",
                "HAL_InitTick": "initialize_tick",
                "HAL_MspInit": "initialize_Msp",
                "HAL_OK": "HAL_success"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003748": {
            "entrypoint": "0x08003748",
            "current_name": "increment_system_tick_08003748",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementSystemTick_08003748(void)\n\n{\n  currentTick = tickFrequency + currentTick;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003748": "increment_system_tick_08003748",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003760": {
            "entrypoint": "0x08003760",
            "current_name": "get_system_tick_count_08003760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTickCount_08003760(void)\n\n{\n  return systemTickCount;\n}\n\n",
            "renaming": {
                "FUN_08003760": "get_system_tick_count_08003760",
                "uwTick": "systemTickCount"
            },
            "calling": [
                "HAL_UART_Transmit",
                "uart_debug_write",
                "HAL_RCC_OscConfig",
                "HAL_ADCEx_Calibration_Start",
                "ADC_Enable",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCCEx_PeriphCLKConfig",
                "GetCurrentMilli",
                "i2c_master_read",
                "i2c_master_write",
                "HAL_RCC_ClockConfig",
                "HAL_ADC_PollForConversion",
                "ADC_ConversionStop_Disable"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376c": {
            "entrypoint": "0x0800376c",
            "current_name": "perform_adc_conversion_0800376c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict performADCConversion_0800376c(ADC_HandleTypeDef *adcHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t periphCLKFreq;\n  int conversionTime;\n  uint32_t systemCoreClock;\n  ADC_TypeDef *adcInstance;\n  uint cpuCycles;\n  uint32_t currentCycles;\n  \n  currentCycles = 0;\n  startTick = HAL_GetTick();\n  systemCoreClock = SystemCoreClock;\n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 0x100) == 0) {\n    if (((adcInstance->CR1 & 0x100) == 0) && ((adcInstance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adcHandle->Instance->SR & 2) != 0) goto LAB_0800387e;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (systemCoreClock = HAL_GetTick(), systemCoreClock - startTick <= timeout))));\n      adcHandle->State = adcHandle->State | 4;\n      adcHandle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      periphCLKFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->SMPR2 & 0x24924924) == 0) && ((adcInstance->SMPR1 & 0x924924) == 0)) {\n        if ((adcInstance->SMPR2 & 0x12492492) == 0) {\n          if ((adcInstance->SMPR1 & 0x492492) == 0) {\n            conversionTime = 0x14;\n          }\n          else {\n            conversionTime = 0x29;\n          }\n        }\n        else {\n          conversionTime = 0x29;\n        }\n      }\n      else if (((adcInstance->SMPR2 & 0x12492492) == 0) && ((adcInstance->SMPR1 & 0x492492) == 0)) {\n        conversionTime = 0x54;\n      }\n      else if ((adcInstance->SMPR2 & 0x249249) == 0) {\n        if ((adcInstance->SMPR1 & 0x249249) == 0) {\n          conversionTime = 0x54;\n        }\n        else {\n          conversionTime = 0xfc;\n        }\n      }\n      else {\n        conversionTime = 0xfc;\n      }\n      cpuCycles = (systemCoreClock / periphCLKFreq) * conversionTime;\n      for (; currentCycles <= cpuCycles && cpuCycles - currentCycles != 0;\n          currentCycles = currentCycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (systemCoreClock = HAL_GetTick(), timeout < systemCoreClock - startTick)))) {\n          adcHandle->State = adcHandle->State | 4;\n          adcHandle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_0800387e:\n      adcHandle->Instance->SR = 0xffffffed;\n      adcHandle->State = adcHandle->State | 0x200;\n      if ((adcHandle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adcHandle->Init).ContinuousConvMode == 0) {\n          adcHandle->State = adcHandle->State & 0xfffffeff;\n          if ((adcHandle->State & 0x1000) == 0) {\n            adcHandle->State = adcHandle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adcHandle->State = adcHandle->State | 0x20;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800376c": "perform_adc_conversion_0800376c",
                "hadc": "adcHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "periphCLKFreq",
                "iVar4": "conversionTime",
                "uVar5": "systemCoreClock",
                "pAVar6": "adcInstance",
                "uVar7": "cpuCycles",
                "Conversion_Timeout_CPU_cycles": "currentCycles"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038dc": {
            "entrypoint": "0x080038dc",
            "current_name": "get_adc_data_080038dc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_data_080038dc(ADC_HandleTypeDef *adc_handle)\n\n{\n  return adc_handle->adc_instance->data_register;\n}\n\n",
            "renaming": {
                "FUN_080038dc": "get_adc_data_080038dc",
                "hadc": "adc_handle",
                "Instance": "adc_instance",
                "DR": "data_register"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038e4": {
            "entrypoint": "0x080038e4",
            "current_name": "configure_adc_channel_080038e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_080038e4(ADC_HandleTypeDef *adcHandle,ADC_ChannelConfTypeDef *channelConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint multiplier;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adcHandle->Lock = HAL_LOCKED;\n    multiplier = channelConfig->Rank;\n    if (multiplier < 7) {\n      multiplier = multiplier * 5 - 5;\n      adcHandle->Instance->SQR3 =\n           channelConfig->Channel << (multiplier & 0xff) | adcHandle->Instance->SQR3 & ~(0x1f << (multiplier & 0xff));\n    }\n    else if (multiplier < 0xd) {\n      multiplier = multiplier * 5 - 0x23;\n      adcHandle->Instance->SQR2 =\n           channelConfig->Channel << (multiplier & 0xff) | adcHandle->Instance->SQR2 & ~(0x1f << (multiplier & 0xff));\n    }\n    else {\n      multiplier = multiplier * 5 - 0x41;\n      adcHandle->Instance->SQR1 =\n           channelConfig->Channel << (multiplier & 0xff) | adcHandle->Instance->SQR1 & ~(0x1f << (multiplier & 0xff));\n    }\n    multiplier = channelConfig->Channel;\n    if (multiplier < 10) {\n      adcHandle->Instance->SMPR2 =\n           channelConfig->SamplingTime << (multiplier * 3 & 0xff) |\n           adcHandle->Instance->SMPR2 & ~(7 << (multiplier * 3 & 0xff));\n    }\n    else {\n      multiplier = multiplier * 3 - 0x1e;\n      adcHandle->Instance->SMPR1 =\n           channelConfig->SamplingTime << (multiplier & 0xff) | adcHandle->Instance->SMPR1 & ~(7 << (multiplier & 0xff));\n    }\n    if (channelConfig->Channel - 0x10 < 2) {\n      if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (channelConfig->Channel == 0x10) {\n            for (loopIndex = (SystemCoreClock / 1000000) * 10; loopIndex != 0;\n                loopIndex = loopIndex - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080038e4": "configure_adc_channel_080038e4",
                "hadc": "adcHandle",
                "sConfig": "channelConfig",
                "HVar1": "status",
                "uVar2": "multiplier",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a1c": {
            "entrypoint": "0x08003a1c",
            "current_name": "get_state_08003a1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getState_08003a1c(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc->State;\n}\n\n",
            "renaming": {
                "FUN_08003a1c": "get_state_08003a1c"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a20": {
            "entrypoint": "0x08003a20",
            "current_name": "initialize_adc_08003a20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08003a20(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  uint32_t loopIndex;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    adcInstance->CR2 = adcInstance->CR2 | 1;\n    for (loopIndex = SystemCoreClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTime = HAL_GetTick();\n    do {\n      if ((adcHandle->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    adcHandle->State = adcHandle->State | 0x10;\n    adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003a20": "initialize_adc_08003a20",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pAVar4": "adcInstance",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003aa0": {
            "entrypoint": "0x08003aa0",
            "current_name": "adc_enable_and_configure_08003aa0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict adc_enable_and_configure_08003aa0(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adc_instance;\n  \n  if (adc_handle->Lock != HAL_LOCKED) {\n    adc_handle->Lock = HAL_LOCKED;\n    status = ADC_Enable(adc_handle);\n    if (status == HAL_OK) {\n      adc_handle->State = adc_handle->State & 0xfffffcfe | 0x100;\n      adc_instance = adc_handle->Instance;\n      if ((adc_instance == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        adc_handle->State = adc_handle->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          adc_handle->State = adc_handle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        adc_handle->State = adc_handle->State & 0xffefffff;\n        if ((adc_instance->CR1 & 0x400) != 0) {\n          adc_handle->State = adc_handle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((adc_handle->State & 0x1000) == 0) {\n        adc_handle->ErrorCode = 0;\n      }\n      else {\n        adc_handle->ErrorCode = adc_handle->ErrorCode & 0xfffffff9;\n      }\n      adc_handle->Lock = HAL_UNLOCKED;\n      adc_instance->SR = 0xfffffffd;\n      adc_instance = adc_handle->Instance;\n      if (((adc_instance->CR2 & 0xe0000) == 0xe0000) &&\n         ((adc_instance != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        adc_instance->CR2 = adc_instance->CR2 | 0x500000;\n      }\n      else {\n        adc_instance->CR2 = adc_instance->CR2 | 0x100000;\n      }\n    }\n    else {\n      adc_handle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08003aa0": "adc_enable_and_configure_08003aa0",
                "hadc": "adc_handle",
                "HVar1": "status",
                "pAVar2": "adc_instance"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003b8c": {
            "entrypoint": "0x08003b8c",
            "current_name": "check_adc_conversion_status_08003b8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict checkADCConversionStatus_08003b8c(ADC_HandleTypeDef *adcHandle)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  ADC_TypeDef *adcInstance;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adcInstance->CR2 = adcInstance->CR2 & 0xfffffffe;\n  startTick = HAL_GetTick();\n  do {\n    if ((adcHandle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    currentTick = HAL_GetTick();\n  } while (currentTick - startTick < 3);\n  adcHandle->State = adcHandle->State | 0x10;\n  adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08003b8c": "check_adc_conversion_status_08003b8c",
                "hadc": "adcHandle",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "pAVar3": "adcInstance"
            },
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_DeInit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003bd8": {
            "entrypoint": "0x08003bd8",
            "current_name": "initialize_adc_08003bd8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_ADC_08003bd8(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value_2;\n  uint value_3;\n  uint value_4;\n  uint32_t value_5;\n  \n  if (adc_handle == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (adc_handle->State == 0) {\n    adc_handle->ErrorCode = 0;\n    adc_handle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc_handle);\n  }\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (((adc_handle->State & 0x10) == 0) && (status == HAL_OK)) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    value_5 = (adc_handle->Init).ContinuousConvMode;\n    value_3 = (adc_handle->Init).DataAlign | (adc_handle->Init).ExternalTrigConv | value_5 << 1;\n    value_2 = (adc_handle->Init).ScanConvMode;\n    if (value_2 == 0x100) {\n      value_4 = 0x100;\n    }\n    else {\n      value_4 = 0;\n      if (value_2 == 1) {\n        value_4 = 0x100;\n      }\n    }\n    if ((adc_handle->Init).DiscontinuousConvMode == 1) {\n      if (value_5 == 0) {\n        value_4 = value_4 | ((adc_handle->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adc_handle->State = adc_handle->State | 0x20;\n        adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      }\n    }\n    adc_handle->Instance->CR1 = value_4 | adc_handle->Instance->CR1 & 0xffff16ff;\n    adc_handle->Instance->CR2 = adc_handle->Instance->CR2 & 0xffe1f7fd | value_3;\n    value_2 = (adc_handle->Init).ScanConvMode;\n    if ((value_2 == 0x100) || (value_2 == 1)) {\n      value_4 = ((adc_handle->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      value_4 = 0;\n    }\n    adc_handle->Instance->SQR1 = value_4 | adc_handle->Instance->SQR1 & 0xff0fffff;\n    if (value_3 != (adc_handle->Instance->CR2 & 0xff1f0efe)) {\n      adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n      adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adc_handle->ErrorCode = 0;\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adc_handle->State = adc_handle->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08003bd8": "initialize_adc_08003bd8",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "value_2",
                "uVar3": "value_3",
                "uVar4": "value_4",
                "uVar5": "value_5"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_ADC_MspInit",
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ce8": {
            "entrypoint": "0x08003ce8",
            "current_name": "stop_and_reset_adc_conversion_08003ce8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopAndResetADCConversion_08003ce8(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    adcHandle->State = adcHandle->State | 2;\n    status = disableADCConversionStop(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->instance->statusRegister = 0xffffffe0;\n      adcHandle->instance->controlRegister1 = adcHandle->instance->controlRegister1 & 0xff3f0000;\n      adcHandle->instance->controlRegister2 = adcHandle->instance->controlRegister2 & 0xff0106f0;\n      adcHandle->instance->sampleTimeRegister1 = adcHandle->instance->sampleTimeRegister1 & 0xff000000;\n      adcHandle->instance->sampleTimeRegister2 = adcHandle->instance->sampleTimeRegister2 & 0xc0000000;\n      adcHandle->instance->offsetRegister1 = adcHandle->instance->offsetRegister1 & 0xfffff000;\n      adcHandle->instance->offsetRegister2 = adcHandle->instance->offsetRegister2 & 0xfffff000;\n      adcHandle->instance->offsetRegister3 = adcHandle->instance->offsetRegister3 & 0xfffff000;\n      adcHandle->instance->offsetRegister4 = adcHandle->instance->offsetRegister4 & 0xfffff000;\n      adcHandle->instance->highThresholdRegister = adcHandle->instance->highThresholdRegister & 0xfffff000;\n      adcHandle->instance->lowThresholdRegister = adcHandle->instance->lowThresholdRegister & 0xfffff000;\n      adcHandle->instance->sequenceRegister1 = adcHandle->instance->sequenceRegister1 & 0xff000000;\n      adcHandle->instance->sequenceRegister1 = adcHandle->instance->sequenceRegister1 & 0xff000000;\n      adcHandle->instance->sequenceRegister2 = adcHandle->instance->sequenceRegister2 & 0xc0000000;\n      adcHandle->instance->sequenceRegister3 = adcHandle->instance->sequenceRegister3 & 0xc0000000;\n      adcHandle->instance->injectedSequenceRegister = adcHandle->instance->injectedSequenceRegister & 0xffc00000;\n      adcHandle->instance->injectedSequenceRegister = adcHandle->instance->injectedSequenceRegister & 0xffc00000;\n      HAL_ADC_MspDeInit(adcHandle);\n      adcHandle->errorCode = 0;\n      adcHandle->State = 0;\n    }\n    adcHandle->lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003ce8": "stop_and_reset_adc_conversion_08003ce8",
                "hadc": "adcHandle",
                "HVar1": "status",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "Instance": "instance",
                "SR": "statusRegister",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "SMPR1": "sampleTimeRegister1",
                "SMPR2": "sampleTimeRegister2",
                "JOFR1": "offsetRegister1",
                "JOFR2": "offsetRegister2",
                "JOFR3": "offsetRegister3",
                "JOFR4": "offsetRegister4",
                "HTR": "highThresholdRegister",
                "LTR": "lowThresholdRegister",
                "SQR1": "sequenceRegister1",
                "SQR2": "sequenceRegister2",
                "SQR3": "sequenceRegister3",
                "JSQR": "injectedSequenceRegister",
                "ErrorCode": "errorCode",
                "Lock": "lock"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003de4": {
            "entrypoint": "0x08003de4",
            "current_name": "stop_adc_conversion_08003de4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopADCConversion_08003de4(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle->Lock == ADC_LOCKED) {\n    return ADC_BUSY;\n  }\n  adcHandle->Lock = ADC_LOCKED;\n  status = disableADCConversionStop(adcHandle);\n  if (status == ADC_OK) {\n    adcHandle->adcState = adcHandle->adcState & 0xffffeefe | 1;\n  }\n  adcHandle->Lock = ADC_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003de4": "stop_adc_conversion_08003de4",
                "hadc": "adcHandle",
                "HVar1": "status",
                "HAL_LOCKED": "ADC_LOCKED",
                "HAL_BUSY": "ADC_BUSY",
                "HAL_OK": "ADC_OK",
                "HAL_UNLOCKED": "ADC_UNLOCKED",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "State": "adcState"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e20": {
            "entrypoint": "0x08003e20",
            "current_name": "perform_adc_conversion_08003e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict performADCConversion_08003e20(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t periphCLKFreq;\n  uint32_t systemCoreClock;\n  ADC_TypeDef *adcInstance;\n  uint32_t startTick;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adcHandle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (status == HAL_OK) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    systemCoreClock = SystemCoreClock;\n    periphCLKFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loopIndex = systemCoreClock / periphCLKFreq << 1; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    ADC_Enable(adcHandle);\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 | 8;\n    systemCoreClock = HAL_GetTick();\n    while (adcInstance = adcHandle->Instance, (adcInstance->CR2 & 8) != 0) {\n      periphCLKFreq = HAL_GetTick();\n      if (10 < periphCLKFreq - systemCoreClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcInstance->CR2 = adcInstance->CR2 | 4;\n    systemCoreClock = HAL_GetTick();\n    while ((adcHandle->Instance->CR2 & 4) != 0) {\n      periphCLKFreq = HAL_GetTick();\n      if (10 < periphCLKFreq - systemCoreClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n  }\n  adcHandle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003e20": "perform_adc_conversion_08003e20",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "periphCLKFreq",
                "uVar3": "systemCoreClock",
                "pAVar4": "adcInstance",
                "tickstart": "startTick",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable",
                "ADC_ConversionStop_Disable",
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0c": {
            "entrypoint": "0x08003f0c",
            "current_name": "set_priority_group_08003f0c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08003f0c(uint32_t priorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f0c": "set_priority_group_08003f0c",
                "PriorityGroup": "priorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f30": {
            "entrypoint": "0x08003f30",
            "current_name": "set_interrupt_priority_08003f30",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptPriority_08003f30(interruptNumber IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqNumber;\n  uint priorityOffset;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqNumber = (uint)IRQn;\n  priorityOffset = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityOffset;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityOffset + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityOffset - 3;\n  }\n  priorityOffset = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqNumber < 0) {\n    *(char *)((irqNumber & 0xf) + 0xe000ed14) = (char)(priorityOffset << 4);\n  }\n  else {\n    *(char *)(irqNumber + 0xe000e400) = (char)(priorityOffset << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn_Type_conflict": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "irqNumber",
                "uVar2": "priorityOffset",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits"
            },
            "calling": [
                "SystemClock_Config",
                "TimerPulseInit",
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "i2c_custom_init",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "set_irq_enable_flag_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQEnableFlag_08003f94(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)interruptNumber;\n  if (-1 < (int)interruptIndex) {\n    *(int *)((interruptIndex >> 5) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "set_irq_enable_flag_08003f94",
                "IRQn": "interruptNumber",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "TimerPulseInit",
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fb0": {
            "entrypoint": "0x08003fb0",
            "current_name": "configure_interrupt_08003fb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureInterrupt_08003fb0(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint irqValue;\n  \n  irqValue = (uint)interruptNumber;\n  if (-1 < (int)irqValue) {\n    *(int *)(((irqValue >> 5) + 0x20) * 4 + -0x1fff1f00) = 1 << (irqValue & 0x1f);\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fb0": "configure_interrupt_08003fb0",
                "IRQn": "interruptNumber",
                "uVar1": "irqValue"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd8": {
            "entrypoint": "0x08003fd8",
            "current_name": "set_ticks_08003fd8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t set_ticks_08003fd8(uint32_t ticks)\n\n{\n  if (ticks - 1 < 0x1000000) {\n    _DAT_e000e014 = ticks - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003fd8": "set_ticks_08003fd8",
                "TicksNumb": "ticks"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "set_interrupt_enable_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnable_08004004(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint convertedInterruptNumber;\n  \n  convertedInterruptNumber = (uint)interruptNumber;\n  if (-1 < (int)convertedInterruptNumber) {\n    *(int *)(((convertedInterruptNumber >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (convertedInterruptNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "set_interrupt_enable_08004004",
                "IRQn": "interruptNumber",
                "uVar1": "convertedInterruptNumber"
            },
            "calling": [
                "USART1_IRQHandler",
                "USART3_IRQHandler",
                "USART2_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004024": {
            "entrypoint": "0x08004024",
            "current_name": "set_clock_source_08004024",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08004024(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004024": "set_clock_source_08004024",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004044": {
            "entrypoint": "0x08004044",
            "current_name": "FUNC_08004044",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004044(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004044": "FUNC_08004044"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004046": {
            "entrypoint": "0x08004046",
            "current_name": "handle_sys_tick_interrupt_08004046",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08004046(void)\n\n{\n  callSysTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004046": "handle_sys_tick_interrupt_08004046",
                "HAL_SYSTICK_Callback": "callSysTickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004050": {
            "entrypoint": "0x08004050",
            "current_name": "set_dma_channel_configuration_08004050",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef set_DMA_channel_configuration_08004050(DMA_HandleTypeDef *dma_handle)\n\n{\n  DMA_Channel_TypeDef *current_channel;\n  \n  if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffff1;\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffffe;\n  current_channel = dma_handle->Instance;\n  if (current_channel == (DMA_Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dma_handle->State = HAL_DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  if (dma_handle->XferAbortCallback != (XferAbortCallback_func *)0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004050": "set_dma_channel_configuration_08004050",
                "hdma": "dma_handle",
                "pDVar1": "current_channel",
                "_func_void___DMA_HandleTypeDef_ptr_conflict": "XferAbortCallback_func",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "DMA_HandleTypeDef_conflict": "DMA_HandleTypeDef",
                "DMA_Channel_TypeDef_conflict": "DMA_Channel_TypeDef"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "configure_gpio_080040e8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_080040e8(GPIO_TypeDef *port,initParamsTypeDef *initParams)\n\n{\n  GPIO_TypeDef *currentPort;\n  uint pinBit;\n  uint pinMask;\n  uint pinNumber;\n  uint mode;\n  uint32_t speed;\n  int bitOffset;\n  uint32_t *configRegister;\n  int portOffset;\n  uint32_t tempRegister;\n  \n  speed = 0;\n  pinNumber = 0;\n  do {\n    if (0xf < pinNumber) {\n      return;\n    }\n    pinBit = 1 << (pinNumber & 0xff);\n    pinMask = initParams->Pin & pinBit;\n    if (pinBit == pinMask) {\n      mode = initParams->Mode;\n      if (mode == 0x12) {\n        speed = initParams->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          speed = initParams->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_0800423a;\n          if (mode == 1) {\n            speed = initParams->Speed;\n          }\n        }\n        else if (mode == 3) {\n          speed = 0;\n        }\n        else if (mode == 0x11) {\n          speed = initParams->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_0800423a:\n        if (initParams->Pull == 0) {\n          speed = 4;\n        }\n        else if (initParams->Pull == 1) {\n          port->BSRR = pinBit;\n          speed = 8;\n        }\n        else {\n          port->BRR = pinBit;\n          speed = 8;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_0800423a;\n      }\n      else if ((mode == 0x10310000) || ((mode == 0x10320000 || (mode == 0x10220000))))\n      goto LAB_0800423a;\n      pinBit = pinNumber;\n      currentPort = port;\n      if (0xff < pinMask) {\n        pinBit = pinNumber - 8;\n        currentPort = (GPIO_TypeDef *)&port->CRH;\n      }\n      currentPort->CRL = currentPort->CRL & ~(0xf << (pinBit << 2 & 0xff)) | speed << (pinBit << 2 & 0xff);\n      if ((initParams->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        bitOffset = (pinNumber & 3) << 2;\n        if (port == (GPIO_TypeDef *)0x40010800) {\n          portOffset = 0;\n        }\n        else if (port == (GPIO_TypeDef *)0x40010c00) {\n          portOffset = 1;\n        }\n        else if (port == (GPIO_TypeDef *)0x40011000) {\n          portOffset = 2;\n        }\n        else if (port == (GPIO_TypeDef *)0x40011400) {\n          portOffset = 3;\n        }\n        else {\n          portOffset = 4;\n        }\n        *(uint *)(((pinNumber >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((pinNumber >> 2) + 2) * 4 + 0x40010000) & ~(0xf << bitOffset) | portOffset << bitOffset;\n        if ((initParams->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinMask;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinMask;\n        }\n        if ((initParams->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinMask;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinMask;\n        }\n        if ((initParams->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinMask;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinMask;\n        }\n        if ((initParams->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinMask;\n        }\n        else {\n          _DAT_4001040c = pinMask | _DAT_4001040c;\n        }\n      }\n    }\n    pinNumber = pinNumber + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040e8": "configure_gpio_080040e8",
                "GPIOx": "port",
                "GPIO_Init": "initParams",
                "pGVar1": "currentPort",
                "uVar2": "pinBit",
                "uVar3": "pinMask",
                "uVar4": "pinNumber",
                "uVar5": "mode",
                "uVar6": "speed",
                "iVar7": "bitOffset",
                "configregister": "configRegister",
                "iVar8": "portOffset",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "uart_init",
                "HAL_TIM_PWM_MspInit",
                "HAL_ADC_MspInit",
                "digital_io_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042d4": {
            "entrypoint": "0x080042d4",
            "current_name": "check_gpio_pin_state_080042d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\npinState check_GPIO_PinState_080042d4(GPIO *gpio,uint16_t pin)\n\n{\n  pinState pinState;\n  \n  if (((uint)pin & gpio->IDR) == 0) {\n    pinState = GPIO_PIN_RESET;\n    return pinState;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_080042d4": "check_gpio_pin_state_080042d4",
                "GPIO_TypeDef": "GPIO",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "bitstatus": "pinState"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e2": {
            "entrypoint": "0x080042e2",
            "current_name": "set_gpio_pin_state_080042e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_gpio_pin_state_080042e2(GPIOType *GPIOx,uint16_t pin,pinState state)\n\n{\n  if (state == GPIO_PIN_RESET) {\n    GPIOx->BSRR = (uint)pin << 0x10;\n    return;\n  }\n  GPIOx->BSRR = (uint)pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042e2": "set_gpio_pin_state_080042e2",
                "GPIO_TypeDef": "GPIOType",
                "GPIO_Pin": "pin",
                "PinState": "state"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042f0": {
            "entrypoint": "0x080042f0",
            "current_name": "handle_gpio_interrupt_080042f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_interrupt_080042f0(uint16_t pin)\n\n{\n  if ((_DAT_40010414 & pin) != 0) {\n    _DAT_40010414 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042f0": "handle_gpio_interrupt_080042f0",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI0_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800430c": {
            "entrypoint": "0x0800430c",
            "current_name": "set_i2_c_device_address_0800430c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_0800430c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  if (i2cHandle->mode == HAL_I2C_MODE_MEM) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->i2cInstance->i2cDataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->i2cDataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->i2cInit).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == HAL_I2C_STATE_BUSY_TX) {\n      i2cHandle->i2cInstance->i2cDataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->i2cDataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->i2cInstance->i2cDataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->i2cInstance->i2cDataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800430c": "set_i2_c_device_address_0800430c",
                "hi2c": "i2cHandle",
                "Mode": "mode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "DR": "i2cDataRegister",
                "Devaddress": "deviceAddress",
                "Init": "i2cInit",
                "AddressingMode": "addressingMode",
                "State": "i2cState"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004396": {
            "entrypoint": "0x08004396",
            "current_name": "set_i2_c_device_address_08004396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict set_I2C_device_address_08004396(I2C_HandleTypeDef_conflict *I2C_handle)\n\n{\n  I2C_handle->I2C_instance->data_register = I2C_handle->device_address & 0xff;\n  return successful_operation;\n}\n\n",
            "renaming": {
                "FUN_08004396": "set_i2_c_device_address_08004396",
                "hi2c": "I2C_handle",
                "Instance": "I2C_instance",
                "DR": "data_register",
                "Devaddress": "device_address",
                "HAL_OK": "successful_operation"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043a2": {
            "entrypoint": "0x080043a2",
            "current_name": "update_i2_c_state_080043a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict updateI2CState_080043a2(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t tempVariable1;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  uint32_t tempRegister2;\n  uint32_t tempRegister3;\n  uint32_t tempRegister4;\n  uint32_t tempRegister5;\n  uint32_t tempRegister6;\n  uint32_t tempRegister7;\n  uint32_t tempRegister8;\n  uint32_t tempRegister9;\n  uint32_t tempRegister10;\n  \n  tempVariable1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (tempVariable1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((tempVariable1 == 4) || (tempVariable1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080043a2": "update_i2_c_state_080043a2",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "tempVariable1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "tmpreg_2": "tempRegister2",
                "tmpreg_3": "tempRegister3",
                "tmpreg_4": "tempRegister4",
                "tmpreg_5": "tempRegister5",
                "tmpreg_6": "tempRegister6",
                "tmpreg_7": "tempRegister7",
                "tmpreg_8": "tempRegister8",
                "tmpreg_9": "tempRegister9",
                "tmpreg_10": "tempRegister10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800457c": {
            "entrypoint": "0x0800457c",
            "current_name": "write_byte_to_i2_c_0800457c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict writeByteToI2C_0800457c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  byte *bufferValue;\n  \n  if (i2cHandle->transferCount != 0) {\n    bufferValue = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferValue + 1;\n    i2cHandle->i2cInstance->dataRegister = (uint)*bufferValue;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_Status_OK;\n}\n\n",
            "renaming": {
                "FUN_0800457c": "write_byte_to_i2_c_0800457c",
                "hi2c": "i2cHandle",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "HAL_OK": "HAL_Status_OK",
                "pbVar1": "bufferValue"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459c": {
            "entrypoint": "0x0800459c",
            "current_name": "read_from_i2_c_0800459c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict readFromI2C_0800459c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint8_t *puVar1;\n  \n  if (i2cHandle->transferCount != 0) {\n    puVar1 = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = puVar1 + 1;\n    *puVar1 = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800459c": "read_from_i2_c_0800459c",
                "hi2c": "i2cHandle",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045bc": {
            "entrypoint": "0x080045bc",
            "current_name": "FUNC_080045bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080045bc": "FUNC_080045bc"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080045c0": {
            "entrypoint": "0x080045c0",
            "current_name": "configure_i2_c_080045c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureI2C_080045c0(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  bool isClockSpeedValid;\n  uint32_t pclk1Freq;\n  uint i2cFreq;\n  uint riseTime;\n  uint32_t dutyCycle;\n  \n  if (i2cHandle == (I2C_HandleTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n    i2cHandle->Lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(i2cHandle);\n  }\n  i2cHandle->State = HAL_I2C_STATE_BUSY;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n  pclk1Freq = HAL_RCC_GetPCLK1Freq();\n  if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n    if (pclk1Freq < 2000000) {\n      isClockSpeedValid = true;\n    }\n    else {\n      isClockSpeedValid = false;\n    }\n  }\n  else {\n    isClockSpeedValid = pclk1Freq < 4000000;\n  }\n  if (isClockSpeedValid) {\n    return HAL_ERROR;\n  }\n  i2cFreq = pclk1Freq / 1000000;\n  i2cHandle->Instance->CR2 = i2cFreq;\n  if (100000 < (i2cHandle->Init).ClockSpeed) {\n    i2cFreq = (i2cFreq * 300) / 1000;\n  }\n  i2cHandle->Instance->TRISE = i2cFreq + 1;\n  i2cFreq = (i2cHandle->Init).ClockSpeed;\n  if (i2cFreq < 0x186a1) {\n    pclk1Freq = (pclk1Freq - 1) / (i2cFreq << 1) + 1 & 0xfff;\n    if (pclk1Freq < 4) {\n      pclk1Freq = 4;\n    }\n  }\n  else {\n    dutyCycle = (i2cHandle->Init).DutyCycle;\n    if (dutyCycle == 0) {\n      riseTime = (pclk1Freq - 1) / (i2cFreq * 3);\n    }\n    else {\n      riseTime = (pclk1Freq - 1) / (i2cFreq * 0x19);\n    }\n    if ((riseTime + 1 & 0xfff) == 0) {\n      pclk1Freq = 1;\n    }\n    else if (dutyCycle == 0) {\n      pclk1Freq = (pclk1Freq - 1) / (i2cFreq * 3) + 1 & 0xfff | 0x8000;\n    }\n    else {\n      pclk1Freq = (pclk1Freq - 1) / (i2cFreq * 0x19) + 1 & 0xfff | 0xc000;\n    }\n  }\n  i2cHandle->Instance->CCR = pclk1Freq;\n  i2cHandle->Instance->CR1 = (i2cHandle->Init).GeneralCallMode | (i2cHandle->Init).NoStretchMode;\n  i2cHandle->Instance->OAR1 = (i2cHandle->Init).AddressingMode | (i2cHandle->Init).OwnAddress1;\n  i2cHandle->Instance->OAR2 = (i2cHandle->Init).DualAddressMode | (i2cHandle->Init).OwnAddress2;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->PreviousState = 0;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080045c0": "configure_i2_c_080045c0",
                "hi2c": "i2cHandle",
                "bVar1": "isClockSpeedValid",
                "uVar2": "pclk1Freq",
                "uVar3": "i2cFreq",
                "uVar4": "riseTime",
                "uVar5": "dutyCycle"
            },
            "calling": [
                "i2c_custom_init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004728": {
            "entrypoint": "0x08004728",
            "current_name": "perform_i2_c_transfer_08004728",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nperformI2CTransfer_08004728(I2C_HandleTypeDef_conflict *i2cHandle,uint16_t deviceAddress,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t timeoutCount;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    timeoutCount = (SystemCoreClock / 25000) * 0x19;\n    do {\n      if (timeoutCount == 0) {\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2cInstance = i2cHandle->Instance;\n      timeoutCount = timeoutCount - 1;\n    } while ((i2cInstance->SR2 & 2) != 0);\n    if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n      i2cHandle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Devaddress = (uint)deviceAddress;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004728": "perform_i2_c_transfer_08004728",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "count": "timeoutCount"
            },
            "calling": [
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "perform_i2_c_transfer_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nperformI2CTransfer_080047f4(I2C_HandleTypeDef_conflict *i2cHandle,uint16_t deviceAddress,uint8_t *data,uint16_t dataSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t timeoutCount;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    timeoutCount = (SystemCoreClock / 25000) * 0x19;\n    do {\n      if (timeoutCount == 0) {\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2cInstance = i2cHandle->Instance;\n      timeoutCount = timeoutCount - 1;\n    } while ((i2cInstance->SR2 & 2) != 0);\n    if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n      i2cHandle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Devaddress = (uint)deviceAddress;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080047f4": "perform_i2_c_transfer_080047f4",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "pData": "data",
                "Size": "dataSize",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "count": "timeoutCount"
            },
            "calling": [
                "i2c_master_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048c8": {
            "entrypoint": "0x080048c8",
            "current_name": "configure_i2_c_080048c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_080048c8(I2C_HandleTypeDef_conflict *i2cHandle,uint8_t *dataPointer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataPointer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataPointer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080048c8": "configure_i2_c_080048c8",
                "hi2c": "i2cHandle",
                "pData": "dataPointer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004954": {
            "entrypoint": "0x08004954",
            "current_name": "listen_and_receive_data_08004954",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nlistenAndReceiveData_08004954(I2C_HandleTypeDef_conflict *i2cHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004954": "listen_and_receive_data_08004954",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049e0": {
            "entrypoint": "0x080049e0",
            "current_name": "initialize_i2_c_080049e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeI2C_080049e0(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  I2C_TypeDef_conflict *i2cTypeDefInstance;\n  \n  if (i2cHandle->currentState != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  i2cHandle->currentState = HAL_I2C_STATE_LISTEN;\n  i2cTypeDefInstance = i2cHandle->i2cInstance;\n  if ((i2cTypeDefInstance->CR1 & 1) == 0) {\n    i2cTypeDefInstance->CR1 = i2cTypeDefInstance->CR1 | 1;\n  }\n  i2cHandle->i2cInstance->CR1 = i2cHandle->i2cInstance->CR1 | 0x400;\n  i2cHandle->i2cInstance->CR2 = i2cHandle->i2cInstance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080049e0": "initialize_i2_c_080049e0",
                "hi2c": "i2cHandle",
                "State": "currentState",
                "Instance": "i2cInstance",
                "pIVar1": "i2cTypeDefInstance"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "i2c_attachSlaveTxEvent",
                "i2c_attachSlaveRxEvent",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a1e": {
            "entrypoint": "0x08004a1e",
            "current_name": "FUNC_08004a1e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a1e": "FUNC_08004a1e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a20": {
            "entrypoint": "0x08004a20",
            "current_name": "FUNC_08004a20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a20": "FUNC_08004a20"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a22": {
            "entrypoint": "0x08004a22",
            "current_name": "FUNC_08004a22",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a22": "FUNC_08004a22"
            },
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a24": {
            "entrypoint": "0x08004a24",
            "current_name": "transfer_data_08004a24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferData_08004a24(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  byte *dataPtr;\n  \n  i2cState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    dataPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataPtr + 1;\n    i2cHandle->Instance->DR = (uint)*dataPtr;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004a24": "transfer_data_08004a24",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pbVar2": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a74": {
            "entrypoint": "0x08004a74",
            "current_name": "FUNC_08004a74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a74": "FUNC_08004a74"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a76": {
            "entrypoint": "0x08004a76",
            "current_name": "process_i2_c_data_08004a76",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_08004a76(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict currentState;\n  uint8_t *dataBufferPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    dataBufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataBufferPointer + 1;\n    *dataBufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x22;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004a76": "process_i2_c_data_08004a76",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "dataBufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ac2": {
            "entrypoint": "0x08004ac2",
            "current_name": "handle_i2_c_addr_match_08004ac2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CAddrMatch_08004ac2(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004ac2": "handle_i2_c_addr_match_08004ac2",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004aec": {
            "entrypoint": "0x08004aec",
            "current_name": "reset_i2_c_state_08004aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetI2CState_08004aec(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  uint32_t current_transfer_options;\n  uint32_t current_state;\n  \n  if (((i2c_handle->XferOptions == 4) || (i2c_handle->XferOptions == 8)) &&\n     (i2c_handle->State == HAL_I2C_STATE_LISTEN)) {\n    i2c_handle->XferOptions = 0xffff0000;\n    i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n    i2c_handle->Instance->SR1 = 0xfffffbff;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n    i2c_handle->PreviousState = 0;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2c_handle);\n  }\n  else if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2c_handle->XferOptions = 0xffff0000;\n    i2c_handle->PreviousState = 0x21;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n    i2c_handle->Instance->SR1 = 0xfffffbff;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2c_handle);\n  }\n  else {\n    i2c_handle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004aec": "reset_i2_c_state_08004aec",
                "hi2c": "i2c_handle",
                "CurrentXferOptions": "current_transfer_options",
                "CurrentState": "current_state"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b80": {
            "entrypoint": "0x08004b80",
            "current_name": "FUNC_08004b80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b80": "FUNC_08004b80"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b82": {
            "entrypoint": "0x08004b82",
            "current_name": "process_i2_c_transfer_08004b82",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CTransfer_08004b82(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict currentState;\n  uint32_t currentI2CState;\n  byte *bufferPointer;\n  uint32_t currentTransferOptions;\n  uint32_t tempVar;\n  \n  currentState = i2cHandle->State;\n  tempVar = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == I2C_STATE_BUSY_TX)) {\n    if ((tempVar == 4) || ((tempVar == 8 || (tempVar == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = I2C_STATE_READY;\n      if (i2cHandle->Mode == I2C_MODE_MEM) {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = I2C_MODE_NONE;\n      i2cHandle->State = I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->Mode == I2C_MODE_MEM && (currentState == I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == I2C_MODE_MEM) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == I2C_STATE_BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == I2C_STATE_BUSY_TX) {\n          bufferPointer = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPointer + 1;\n          i2cHandle->Instance->DR = (uint)*bufferPointer;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004b82": "process_i2_c_transfer_08004b82",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "bufferPointer",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "tempVar",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RX"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "handle_i2_c_transfer_08004ccc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08004ccc(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "handle_i2_c_transfer_08004ccc",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d6a": {
            "entrypoint": "0x08004d6a",
            "current_name": "FUNC_08004d6a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d6a": "FUNC_08004d6a"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004d6c": {
            "entrypoint": "0x08004d6c",
            "current_name": "handle_i2_crx_08004d6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHALStatusTypeConflict handleI2CRX_08004d6c(I2CHandleConflict *i2cHandle)\n\n{\n  uint8_t *dataPtr;\n  \n  if (i2cHandle->State == I2CStateBusyRX) {\n    if (i2cHandle->transferCount < 4) {\n      if (i2cHandle->transferCount - 2 < 2) {\n        if (i2cHandle->transferOptions == 2) {\n          i2cHandle->i2cInstance->i2cControlReg1 = i2cHandle->i2cInstance->i2cControlReg1 | 0x400;\n        }\n        else {\n          i2cHandle->i2cInstance->i2cControlReg1 = i2cHandle->i2cInstance->i2cControlReg1 & 0xfffffbff;\n          i2cHandle->i2cInstance->i2cControlReg1 = i2cHandle->i2cInstance->i2cControlReg1 | 0x800;\n        }\n        i2cHandle->i2cInstance->i2cControlReg2 = i2cHandle->i2cInstance->i2cControlReg2 & 0xfffffbff;\n      }\n      else {\n        if (i2cHandle->transferOptions == 2) {\n          i2cHandle->i2cInstance->i2cControlReg1 = i2cHandle->i2cInstance->i2cControlReg1 | 0x400;\n        }\n        else {\n          i2cHandle->i2cInstance->i2cControlReg1 = i2cHandle->i2cInstance->i2cControlReg1 & 0xfffffbff;\n        }\n        i2cHandle->i2cInstance->i2cControlReg2 = i2cHandle->i2cInstance->i2cControlReg2 & 0xfffff8ff;\n        dataPtr = i2cHandle->bufferPtr;\n        i2cHandle->bufferPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->i2cInstance->dataReg;\n        i2cHandle->transferCount = i2cHandle->transferCount - 1;\n        i2cHandle->State = I2CStateReady;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == I2CModeMem) {\n          i2cHandle->Mode = I2CModeNone;\n          HAL_I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = I2CModeNone;\n          HAL_I2C_MasterRxCpltCallback(i2cHandle);\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandle->bufferPtr;\n      i2cHandle->bufferPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->i2cInstance->dataReg;\n      i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004d6c": "handle_i2_crx_08004d6c",
                "hi2c": "i2cHandle",
                "I2C_HandleTypeDef_conflict": "I2CHandleConflict",
                "HAL_StatusTypeDef_conflict": "HALStatusTypeConflict",
                "puVar1": "dataPtr",
                "HAL_I2C_STATE_BUSY_RX": "I2CStateBusyRX",
                "HAL_I2C_MODE_MEM": "I2CModeMem",
                "HAL_I2C_MODE_NONE": "I2CModeNone",
                "HAL_I2C_STATE_READY": "I2CStateReady",
                "Instance": "i2cInstance",
                "CR1": "i2cControlReg1",
                "CR2": "i2cControlReg2",
                "XferCount": "transferCount",
                "XferOptions": "transferOptions",
                "pBuffPtr": "bufferPtr",
                "DR": "dataReg"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e3c": {
            "entrypoint": "0x08004e3c",
            "current_name": "handle_i2_c_rx_transfer_08004e3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CRxTransfer_08004e3c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPointer;\n  \n  transferOptions = i2cHandle->transferOptions;\n  if (i2cHandle->transferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->hardwareInstance->controlReg1 = i2cHandle->hardwareInstance->controlReg1 & 0xfffffbff;\n    }\n    bufferPointer = i2cHandle->dataBufferPtr;\n    i2cHandle->dataBufferPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->hardwareInstance->dataReg;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->hardwareInstance->controlReg2 = i2cHandle->hardwareInstance->controlReg2 & 0xfffffcff;\n      i2cHandle->hardwareInstance->controlReg1 = i2cHandle->hardwareInstance->controlReg1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandle->hardwareInstance->controlReg1 = i2cHandle->hardwareInstance->controlReg1 | 0x400;\n      }\n      else {\n        i2cHandle->hardwareInstance->controlReg1 = i2cHandle->hardwareInstance->controlReg1 & 0xfffffbff;\n      }\n      i2cHandle->hardwareInstance->controlReg2 = i2cHandle->hardwareInstance->controlReg2 & 0xfffffcff;\n    }\n    bufferPointer = i2cHandle->dataBufferPtr;\n    i2cHandle->dataBufferPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->hardwareInstance->dataReg;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    bufferPointer = i2cHandle->dataBufferPtr;\n    i2cHandle->dataBufferPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->hardwareInstance->dataReg;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    i2cHandle->i2cState = HAL_I2C_STATE_READY;\n    i2cHandle->previousState = 0;\n    if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPointer = i2cHandle->dataBufferPtr;\n    i2cHandle->dataBufferPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->hardwareInstance->dataReg;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004e3c": "handle_i2_c_rx_transfer_08004e3c",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "bufferPointer",
                "CR1": "controlReg1",
                "CR2": "controlReg2",
                "DR": "dataReg",
                "XferOptions": "transferOptions",
                "XferCount": "transferCount",
                "pBuffPtr": "dataBufferPtr",
                "Instance": "hardwareInstance",
                "State": "i2cState",
                "PreviousState": "previousState",
                "Mode": "i2cMode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3a": {
            "entrypoint": "0x08004f3a",
            "current_name": "FUNC_08004f3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3a": "FUNC_08004f3a"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "update_i2_c_state_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateI2CState_08004f3c(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *bytePtr;\n  I2C_TypeDef_conflict *peripheralPtr;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  peripheralPtr = i2cHandle->Instance;\n  if ((peripheralPtr->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((peripheralPtr->SR1 & 0x40) != 0) {\n        bytePtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bytePtr + 1;\n        *bytePtr = (uint8_t)peripheralPtr->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((peripheralPtr->SR1 & 0x40) != 0) {\n        bytePtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bytePtr + 1;\n        *bytePtr = (uint8_t)peripheralPtr->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    peripheralPtr->CR2 = peripheralPtr->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          bytePtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bytePtr + 1;\n          *bytePtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "update_i2_c_state_08004f3c",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "bytePtr",
                "pIVar3": "peripheralPtr"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005084": {
            "entrypoint": "0x08005084",
            "current_name": "read_data_from_i2_c_08005084",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict readDataFromI2C_08005084(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict currentState;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentStateValue;\n  uint32_t temporaryRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005084": "read_data_from_i2_c_08005084",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentStateValue",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005188": {
            "entrypoint": "0x08005188",
            "current_name": "process_i2_c_interrupt_08005188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processI2CInterrupt_08005188(I2C_HandleTypeDef *handle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint SR1;\n  uint32_t SR1ITFlags;\n  uint CR2;\n  uint32_t ITSources;\n  uint SR2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = handle->Instance;\n  SR2 = i2cInstance->SR2;\n  SR1 = i2cInstance->SR1;\n  CR2 = i2cInstance->CR2;\n  if ((handle->Mode == HAL_I2C_MODE_MASTER) || (handle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((SR1 & 0x10001) == 0) || ((CR2 & 0x200) == 0)) {\n      if (((SR1 & 0x10008) == 0) || ((CR2 & 0x200) == 0)) {\n        if (((SR1 & 0x10002) != 0) && ((CR2 & 0x200) != 0)) {\n          I2C_Master_ADDR(handle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(handle);\n      }\n    }\n    else {\n      I2C_Master_SB(handle);\n    }\n    if ((SR2 & 0x100004) == 0) {\n      if ((((SR1 & 0x10040) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(handle);\n        return;\n      }\n      if (((SR1 & 0x10004) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(handle);\n        return;\n      }\n    }\n    else {\n      if ((((SR1 & 0x10080) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(handle);\n        return;\n      }\n      if (((SR1 & 0x10004) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((SR1 & 0x10002) != 0) && ((CR2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(handle);\n      return;\n    }\n    if (((SR1 & 0x10010) != 0) && ((CR2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(handle);\n      return;\n    }\n    if ((SR2 & 0x100004) == 0) {\n      if ((((SR1 & 0x10040) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(handle);\n        return;\n      }\n      if (((SR1 & 0x10004) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(handle);\n      }\n    }\n    else {\n      if ((((SR1 & 0x10080) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(handle);\n        return;\n      }\n      if (((SR1 & 0x10004) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005188": "process_i2_c_interrupt_08005188",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "hi2c": "handle",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "SR1",
                "sr1itflags": "SR1ITFlags",
                "uVar3": "CR2",
                "itsources": "ITSources",
                "uVar4": "SR2"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_MasterTransmit_TXE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_Master_ADD10",
                "I2C_MasterTransmit_BTF",
                "I2C_SlaveReceive_BTF",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052f0": {
            "entrypoint": "0x080052f0",
            "current_name": "handle_i2_c_state_080052f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_080052f0(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  I2C_TypeDef_conflict *i2cInstance;\n  uint32_t statusRegister;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x8000;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052f0": "handle_i2_c_state_080052f0",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "statusRegister",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053cc": {
            "entrypoint": "0x080053cc",
            "current_name": "reset_i2_c_peripheral_080053cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CPeripheral_080053cc(DMA_HandleTypeDef_conflict *dma)\n\n{\n  I2C_HandleTypeDef_conflict *i2cParent;\n  I2C_HandleTypeDef_conflict *i2c;\n  \n  i2cParent = (I2C_HandleTypeDef_conflict *)dma->Parent;\n  i2cParent->Instance->controlRegister1 = i2cParent->Instance->controlRegister1 & 0xfffffbff;\n  i2cParent->transferCount = 0;\n  i2cParent->dmaTx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  i2cParent->dmaRx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  if (i2cParent->currentState != HAL_I2C_STATE_ABORT) {\n    i2cParent->currentState = HAL_I2C_STATE_READY;\n    i2cParent->currentMode = HAL_I2C_MODE_NONE;\n    i2cParent->Instance->controlRegister1 = i2cParent->Instance->controlRegister1 & 0xfffffffe;\n    handleI2CError(i2cParent);\n    return;\n  }\n  i2cParent->currentState = HAL_I2C_STATE_READY;\n  i2cParent->currentMode = HAL_I2C_MODE_NONE;\n  i2cParent->error = 0;\n  i2cParent->Instance->controlRegister1 = i2cParent->Instance->controlRegister1 & 0xfffffffe;\n  handleI2CAbortComplete(i2cParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053cc": "reset_i2_c_peripheral_080053cc",
                "hdma": "dma",
                "hi2c_00": "i2cParent",
                "hi2c": "i2c",
                "XferCount": "transferCount",
                "hdmatx": "dmaTx",
                "hdmarx": "dmaRx",
                "State": "currentState",
                "Mode": "currentMode",
                "ErrorCode": "error",
                "CR1": "controlRegister1",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800542a": {
            "entrypoint": "0x0800542a",
            "current_name": "get_i2_c_state_0800542a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_I2C_currentStateTypeDef_conflict getI2CState_0800542a(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  return i2cHandle->currentState;\n}\n\n",
            "renaming": {
                "FUN_0800542a": "get_i2_c_state_0800542a",
                "hi2c": "i2cHandle",
                "State": "currentState"
            },
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005430": {
            "entrypoint": "0x08005430",
            "current_name": "get_i2_c_error_code_08005430",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getI2CErrorCode_08005430(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  return i2cHandle->error;\n}\n\n",
            "renaming": {
                "FUN_08005430": "get_i2_c_error_code_08005430",
                "hi2c": "i2cHandle",
                "ErrorCode": "error"
            },
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005434": {
            "entrypoint": "0x08005434",
            "current_name": "delay_function_08005434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayFunction_08005434(uint32_t milliseconds)\n\n{\n  bool isDelayNotZero;\n  uint32_t cycles;\n  \n  cycles = milliseconds * (SystemCoreClock / 8000);\n  do {\n    isDelayNotZero = cycles != 0;\n    cycles = cycles - 1;\n  } while (isDelayNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005434": "delay_function_08005434",
                "mdelay": "milliseconds",
                "Delay": "cycles",
                "bVar1": "isDelayNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005460": {
            "entrypoint": "0x08005460",
            "current_name": "configure_rcc_oscillators_08005460",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureRCCOscillators_08005460(RCC_OscInitTypeDef_conflict *oscillatorConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t currentTick;\n  uint32_t startTick;\n  bool isPredivZero;\n  uint32_t temporaryRegister;\n  \n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscillatorConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      startTick = oscillatorConfig->HSEState;\n      if (startTick == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (startTick == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (startTick == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscillatorConfig->HSEState == 0) {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    isPredivZero = (_DAT_4002101c & 0x10000000) == 0;\n    if (isPredivZero) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    startTick = oscillatorConfig->LSEState;\n    if (startTick == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (startTick == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (startTick == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscillatorConfig->LSEState == 0) {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isPredivZero) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  startTick = (oscillatorConfig->PLL).PLLState;\n  if (startTick == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (startTick == 2) {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscillatorConfig->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillatorConfig->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (oscillatorConfig->PLL).PLLSource | (oscillatorConfig->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        startTick = HAL_GetTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTick = HAL_GetTick();\n        } while (currentTick - startTick < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08005460": "configure_rcc_oscillators_08005460",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HVar1": "status",
                "uVar2": "currentTick",
                "uVar3": "startTick",
                "bVar4": "isPredivZero",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "RCC_Delay",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_system_clock_frequency_08005840",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSystemClockFrequency_08005840(void)\n\n{\n  uint32_t systemClockFrequency;\n  uint8_t predivFactorTable [2];\n  uint8_t pllmulFactorTable [16];\n  \n  pllmulFactorTable[12] = '\\x0e';\n  pllmulFactorTable[13] = '\\x0f';\n  pllmulFactorTable[14] = '\\x10';\n  pllmulFactorTable[15] = '\\x10';\n  pllmulFactorTable[8] = '\\n';\n  pllmulFactorTable[9] = '\\v';\n  pllmulFactorTable[10] = '\\f';\n  pllmulFactorTable[11] = '\\r';\n  pllmulFactorTable[4] = '\\x06';\n  pllmulFactorTable[5] = '\\a';\n  pllmulFactorTable[6] = '\\b';\n  pllmulFactorTable[7] = '\\t';\n  pllmulFactorTable[0] = '\\x02';\n  pllmulFactorTable[1] = '\\x03';\n  pllmulFactorTable[2] = '\\x04';\n  pllmulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      systemClockFrequency = (uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      systemClockFrequency = ((uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    systemClockFrequency = 8000000;\n  }\n  return systemClockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_system_clock_frequency_08005840",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllmulFactorTable",
                "uVar1": "systemClockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058ac": {
            "entrypoint": "0x080058ac",
            "current_name": "configure_clocks_080058ac",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureClocks_080058ac(RCC_ClkInitTypeDef_conflict *clockInitStruct,uint32_t latency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 & 7) < latency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | latency;\n    if (latency != (latency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockInitStruct->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | clockInitStruct->AHBCLKDivider;\n  }\n  if ((clockInitStruct->ClockType & 1) != 0) {\n    uVar3 = clockInitStruct->SYSCLKSource;\n    if (uVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 = uVar3 | _DAT_40021004 & 0xfffffffc;\n    uVar1 = HAL_GetTick();\n    if (clockInitStruct->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        uVar2 = HAL_GetTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (clockInitStruct->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        uVar2 = HAL_GetTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        uVar2 = HAL_GetTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (latency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | latency;\n    if (latency != (latency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockInitStruct->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | clockInitStruct->APB1CLKDivider;\n  }\n  if ((clockInitStruct->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | clockInitStruct->APB2CLKDivider << 3;\n  }\n  uVar1 = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = uVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080058ac": "configure_clocks_080058ac",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "latency"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a1c": {
            "entrypoint": "0x08005a1c",
            "current_name": "get_system_core_clock_08005a1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08005a1c(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08005a1c": "get_system_core_clock_08005a1c",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a28": {
            "entrypoint": "0x08005a28",
            "current_name": "get_adjusted_hclk_freq_08005a28",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08005a28(void)\n\n{\n  uint32_t adjustedHCLKFreq;\n  \n  adjustedHCLKFreq = getHCLKFreq();\n  return adjustedHCLKFreq >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08005a28": "get_adjusted_hclk_freq_08005a28",
                "uVar1": "adjustedHCLKFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "getTimerClkFreq",
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a48": {
            "entrypoint": "0x08005a48",
            "current_name": "get_clock_frequency_08005a48",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_clock_frequency_08005a48(void)\n\n{\n  uint32_t clock_frequency;\n  \n  clock_frequency = get_HCLK_frequency();\n  return clock_frequency >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08005a48": "get_clock_frequency_08005a48",
                "uVar1": "clock_frequency",
                "HAL_RCC_GetHCLKFreq": "get_HCLK_frequency"
            },
            "calling": [
                "getTimerClkFreq",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "configure_clocks_08005a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureClocks_08005a68(RCC_ClkInitTypeDef_conflict *clockConfig,uint32_t *flashLatency)\n\n{\n  clockConfig->ClockType = 0xf;\n  clockConfig->SYSCLKSource = _DAT_40021004 & 3;\n  clockConfig->AHBCLKDivider = _DAT_40021004 & 0xf0;\n  clockConfig->APB1CLKDivider = _DAT_40021004 & 0x700;\n  clockConfig->APB2CLKDivider = _DAT_40021004 >> 3 & 0x700;\n  *flashLatency = _DAT_40022000 & 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a68": "configure_clocks_08005a68",
                "RCC_ClkInitStruct": "clockConfig",
                "pFLatency": "flashLatency"
            },
            "calling": [
                "getTimerClkFreq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005aa4": {
            "entrypoint": "0x08005aa4",
            "current_name": "configure_periph_clk_08005aa4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphCLK_08005aa4(RCC_PeriphCLKInitTypeDef_conflict *peripheralClockInit)\n\n{\n  uint flag;\n  uint temp;\n  uint32_t startTime;\n  uint32_t currentTime;\n  bool isBitSet;\n  uint32_t temporaryRegister;\n  \n  if ((peripheralClockInit->PeriphClockSelection & 1) != 0) {\n    isBitSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = getElapsedTicks();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = getElapsedTicks();\n        if (100 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (peripheralClockInit->RTCClockSelection & 0x300))) {\n      temp = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      flag = _DAT_40021020 & 1;\n      _DAT_40021020 = temp;\n      if (flag != 0) {\n        startTime = getElapsedTicks();\n        while ((_DAT_40021020 & 2) == 0) {\n          currentTime = getElapsedTicks();\n          if (5000 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | peripheralClockInit->RTCClockSelection;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | peripheralClockInit->AdcClockSelection;\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | peripheralClockInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005aa4": "configure_periph_clk_08005aa4",
                "PeriphClkInit": "peripheralClockInit",
                "uVar1": "flag",
                "uVar2": "temp",
                "uVar3": "startTime",
                "uVar4": "currentTime",
                "bVar5": "isBitSet",
                "tmpreg": "temporaryRegister",
                "HAL_GetTick": "getElapsedTicks"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb8": {
            "entrypoint": "0x08005bb8",
            "current_name": "calculate_clock_frequency_08005bb8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08005bb8(uint32_t peripheralClock)\n\n{\n  uint32_t clockFrequency;\n  uint tempValue;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMultiplierTable [16];\n  \n  pllMultiplierTable[12] = '\\x0e';\n  pllMultiplierTable[13] = '\\x0f';\n  pllMultiplierTable[14] = '\\x10';\n  pllMultiplierTable[15] = '\\x10';\n  pllMultiplierTable[8] = '\\n';\n  pllMultiplierTable[9] = '\\v';\n  pllMultiplierTable[10] = '\\f';\n  pllMultiplierTable[11] = '\\r';\n  pllMultiplierTable[4] = '\\x06';\n  pllMultiplierTable[5] = '\\a';\n  pllMultiplierTable[6] = '\\b';\n  pllMultiplierTable[7] = '\\t';\n  pllMultiplierTable[0] = '\\x02';\n  pllMultiplierTable[1] = '\\x03';\n  pllMultiplierTable[2] = '\\x04';\n  pllMultiplierTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (peripheralClock == 2) {\n    clockFrequency = HAL_RCC_GetPCLK2Freq();\n    clockFrequency = clockFrequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheralClock == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      clockFrequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        tempValue = 4000000;\n      }\n      else {\n        tempValue = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      clockFrequency = tempValue * pllMultiplierTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        clockFrequency = (clockFrequency * 2) / 3;\n      }\n    }\n  }\n  else if (peripheralClock == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      clockFrequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      clockFrequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        clockFrequency = 0;\n      }\n      else {\n        clockFrequency = 0xf424;\n      }\n    }\n    else {\n      clockFrequency = 0;\n    }\n  }\n  else {\n    clockFrequency = 0;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08005bb8": "calculate_clock_frequency_08005bb8",
                "PeriphClk": "peripheralClock",
                "uVar1": "clockFrequency",
                "uVar2": "tempValue",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMultiplierTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb4": {
            "entrypoint": "0x08005cb4",
            "current_name": "handle_alarm_event_08005cb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_alarm_event_08005cb4(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (((rtc_handle->rtc_instance->control_high_register & 2) != 0) && ((rtc_handle->rtc_instance->control_low_register & 2) != 0)) {\n    handle_alarm_callback(rtc_handle);\n    rtc_handle->rtc_instance->control_low_register = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cb4": "handle_alarm_event_08005cb4",
                "hrtc": "rtc_handle",
                "Instance": "rtc_instance",
                "CRH": "control_high_register",
                "CRL": "control_low_register",
                "HAL_RTC_AlarmAEventCallback": "handle_alarm_callback"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cec": {
            "entrypoint": "0x08005cec",
            "current_name": "configure_tim_output_compare_08005cec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimOutputCompare_08005cec(TIM_TypeDef_conflict *timInstance,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t tempVar1;\n  uint32_t tempVar2;\n  uint tempVar3;\n  \n  timInstance->CCER = timInstance->CCER & 0xfffffffe;\n  tempVar2 = timInstance->CR2;\n  tempVar3 = outputCompareConfig->OCMode;\n  tempVar1 = timInstance->CCER & 0xfffffffd | outputCompareConfig->OCPolarity;\n  if (timInstance == (TIM_TypeDef_conflict *)0x40012c00) {\n    tempVar1 = (tempVar1 & 0xfffffff7 | outputCompareConfig->OCNPolarity) & 0xfffffffb;\n    tempVar2 = tempVar2 & 0xfffffcff | outputCompareConfig->OCIdleState | outputCompareConfig->OCNIdleState;\n  }\n  timInstance->CR2 = tempVar2;\n  timInstance->CCMR1 = timInstance->CCMR1 & 0xffffff8c | tempVar3;\n  timInstance->CCR1 = outputCompareConfig->Pulse;\n  timInstance->CCER = tempVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cec": "configure_tim_output_compare_08005cec",
                "TIMx": "timInstance",
                "OC_Config": "outputCompareConfig",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d48": {
            "entrypoint": "0x08005d48",
            "current_name": "configure_tim_output_compare_08005d48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimOutputCompare_08005d48(TimTypeDef *tim,TIM_OC_InitTypeDef *ocConfig)\n\n{\n  uint32_t ccer1;\n  uint32_t cr2;\n  uint ocMode;\n  \n  tim->ccer = tim->ccer & 0xfffffeff;\n  cr2 = tim->cr2;\n  ocMode = ocConfig->ocMode;\n  ccer1 = tim->ccer & 0xfffffdff | ocConfig->ocPolarity << 8;\n  if (tim == (TimTypeDef *)0x40012c00) {\n    ccer1 = (ccer1 & 0xfffff7ff | ocConfig->ocNegativePolarity << 8) & 0xfffffbff;\n    cr2 = cr2 & 0xffffcfff | ocConfig->ocIdleState << 4 | ocConfig->ocNegativeIdleState << 4;\n  }\n  tim->cr2 = cr2;\n  tim->ccmr2 = tim->ccmr2 & 0xffffff8c | ocMode;\n  tim->CCR3 = ocConfig->pulse;\n  tim->ccer = ccer1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d48": "configure_tim_output_compare_08005d48",
                "TIMx": "tim",
                "OC_Config": "ocConfig",
                "uVar1": "ccer1",
                "uVar2": "cr2",
                "uVar3": "ocMode",
                "TIM_TypeDef_conflict": "TimTypeDef",
                "CCER": "ccer",
                "CR2": "cr2",
                "OCMode": "ocMode",
                "OCPolarity": "ocPolarity",
                "OCNPolarity": "ocNegativePolarity",
                "OCIdleState": "ocIdleState",
                "OCNIdleState": "ocNegativeIdleState",
                "CCMR2": "ccmr2",
                "Pulse": "pulse"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dac": {
            "entrypoint": "0x08005dac",
            "current_name": "configure_output_compare_08005dac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureOutputCompare_08005dac(TIM_TypeDef_conflict *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t timerConfig;\n  uint32_t ocMode;\n  uint32_t ocPolarity;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  timerConfig = timer->CR2;\n  ocMode = outputCompareConfig->OCMode;\n  ocPolarity = outputCompareConfig->OCPolarity;\n  if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n    timerConfig = timerConfig & 0xffffbfff | outputCompareConfig->OCIdleState << 6;\n  }\n  timer->CR2 = timerConfig;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | ocMode << 8;\n  timer->CCR4 = outputCompareConfig->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | ocPolarity << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dac": "configure_output_compare_08005dac",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "timerConfig",
                "uVar2": "ocMode",
                "uVar3": "ocPolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005df4": {
            "entrypoint": "0x08005df4",
            "current_name": "deinitialize_timer_08005df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict deinitializeTimer_08005df4(TIM_HandleTypeDef_conflict *timer)\n\n{\n  TimType *timerInstance;\n  \n  timer->State = TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->controlRegister1 = timerInstance->controlRegister1 & 0xfffffffe;\n  }\n  deinitializeTimer_08005df4OC(timer);\n  timer->State = TIM_STATE_RESET;\n  timer->Lock = UNLOCKED;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08005df4": "deinitialize_timer_08005df4",
                "htim": "timer",
                "HAL_TIM_STATE_BUSY": "TIM_STATE_BUSY",
                "TIM_TypeDef_conflict": "TimType",
                "pTVar1": "timerInstance",
                "CCER": "captureCompareEnableRegister",
                "CR1": "controlRegister1",
                "HAL_TIM_OC_MspDeInit": "deinitializeTimerOC",
                "HAL_TIM_STATE_RESET": "TIM_STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_OK": "OK"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e2e": {
            "entrypoint": "0x08005e2e",
            "current_name": "reset_tim_config_08005e2e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetTimConfig_08005e2e(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  timerHandle->State = TIM_STATE_BUSY;\n  pTVar1 = timerHandle->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timerHandle);\n  timerHandle->State = TIM_STATE_RESET;\n  timerHandle->Lock = UNLOCKED;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08005e2e": "reset_tim_config_08005e2e",
                "htim": "timerHandle",
                "HAL_TIM_STATE_BUSY": "TIM_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "TIM_STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_OK": "OK"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e68": {
            "entrypoint": "0x08005e68",
            "current_name": "FUNC_08005e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e68": "FUNC_08005e68"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6a": {
            "entrypoint": "0x08005e6a",
            "current_name": "FUNC_08005e6a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6a": "FUNC_08005e6a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6c": {
            "entrypoint": "0x08005e6c",
            "current_name": "FUNC_08005e6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6c": "FUNC_08005e6c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6e": {
            "entrypoint": "0x08005e6e",
            "current_name": "handle_tim_interrupts_08005e6e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupts_08005e6e(TIM_HandleTypeDef_conflict *timHandle)\n\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timHandle->Channel = CHANNEL_1;\n    if ((timHandle->Instance->CCMR1 & 3) == 0) {\n      timerOcDelayElapsedCallback(timHandle);\n      timerPwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      timerIcCaptureCallback(timHandle);\n    }\n    timHandle->Channel = CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timHandle->Channel = CHANNEL_2;\n    if ((timHandle->Instance->CCMR1 & 0x300) == 0) {\n      timerOcDelayElapsedCallback(timHandle);\n      timerPwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      timerIcCaptureCallback(timHandle);\n    }\n    timHandle->Channel = CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timHandle->Channel = CHANNEL_3;\n    if ((timHandle->Instance->CCMR2 & 3) == 0) {\n      timerOcDelayElapsedCallback(timHandle);\n      timerPwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      timerIcCaptureCallback(timHandle);\n    }\n    timHandle->Channel = CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timHandle->Channel = CHANNEL_4;\n    if ((timHandle->Instance->CCMR2 & 0x300) == 0) {\n      timerOcDelayElapsedCallback(timHandle);\n      timerPwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      timerIcCaptureCallback(timHandle);\n    }\n    timHandle->Channel = CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    timerPeriodElapsedCallback(timHandle);\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    timerBreakCallback(timHandle);\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    timerTriggerCallback(timHandle);\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    timerCommutationCallback(timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6e": "handle_tim_interrupts_08005e6e",
                "htim": "timHandle",
                "pTVar1": "timerInstance",
                "HAL_TIM_ACTIVE_CHANNEL_1": "CHANNEL_1",
                "HAL_TIM_OC_DelayElapsedCallback": "timerOcDelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback": "timerPwmPulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback": "timerIcCaptureCallback",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "CHANNEL_CLEARED",
                "HAL_TIM_ACTIVE_CHANNEL_2": "CHANNEL_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "CHANNEL_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "CHANNEL_4",
                "HAL_TIM_PeriodElapsedCallback": "timerPeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback": "timerBreakCallback",
                "HAL_TIM_TriggerCallback": "timerTriggerCallback",
                "HAL_TIMEx_CommutationCallback": "timerCommutationCallback"
            },
            "calling": [
                "TIM4_IRQHandler",
                "TIM2_IRQHandler",
                "TIM3_IRQHandler",
                "TIM1_UP_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fe8": {
            "entrypoint": "0x08005fe8",
            "current_name": "configure_timer_08005fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_08005fe8(TIM_TypeDef_conflict *timer,TIM_Base_InitTypeDef_conflict *config)\n\n{\n  uint cr1Value;\n  \n  cr1Value = timer->CR1;\n  if ((((timer == (TIM_TypeDef_conflict *)0x40012c00) || (timer == (TIM_TypeDef_conflict *)0x40000000)\n       ) || (timer == (TIM_TypeDef_conflict *)0x40000400)) ||\n     (timer == (TIM_TypeDef_conflict *)0x40000800)) {\n    cr1Value = cr1Value & 0xffffff8f | config->CounterMode;\n  }\n  if (((timer == (TIM_TypeDef_conflict *)0x40012c00) || (timer == (TIM_TypeDef_conflict *)0x40000000))\n     || ((timer == (TIM_TypeDef_conflict *)0x40000400 || (timer == (TIM_TypeDef_conflict *)0x40000800)\n         ))) {\n    cr1Value = cr1Value & 0xfffffcff | config->ClockDivision;\n  }\n  timer->CR1 = cr1Value & 0xffffff7f | config->AutoReloadPreload;\n  timer->ARR = config->Period;\n  timer->PSC = config->Prescaler;\n  if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n    uRam40012c30 = config->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fe8": "configure_timer_08005fe8",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "cr1Value"
            },
            "calling": [
                "HAL_TIM_OC_Init",
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006060": {
            "entrypoint": "0x08006060",
            "current_name": "initialize_timer_08006060",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeTimer_08006060(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  if (timerHandle != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (timerHandle->State == resetState) {\n      timerHandle->Lock = unlocked;\n      HAL_TIM_OC_MspInit(timerHandle);\n    }\n    timerHandle->State = busyState;\n    setTimerConfiguration(timerHandle->Instance,&timerHandle->Init);\n    timerHandle->State = readyState;\n    return okStatus;\n  }\n  return errorStatus;\n}\n\n",
            "renaming": {
                "FUN_08006060": "initialize_timer_08006060",
                "htim": "timerHandle",
                "HAL_TIM_STATE_RESET": "resetState",
                "HAL_UNLOCKED": "unlocked",
                "TIM_Base_SetConfig": "setTimerConfiguration",
                "HAL_TIM_STATE_BUSY": "busyState",
                "HAL_TIM_STATE_READY": "readyState",
                "HAL_OK": "okStatus",
                "HAL_ERROR": "errorStatus"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "HAL_TIM_OC_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "initialize_timer_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeTimer_08006092(TIM_HandleTypeDef_conflict *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef_conflict *)0x0) {\n    if (timer->State == resetState) {\n      timer->Lock = unlocked;\n      initializePWM(timer);\n    }\n    timer->State = busyState;\n    setTimerConfig(timer->Instance,&timer->Init);\n    timer->State = readyState;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_08006092": "initialize_timer_08006092",
                "htim": "timer",
                "HAL_TIM_PWM_MspInit": "initializePWM",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_STATE_RESET": "resetState",
                "HAL_TIM_STATE_BUSY": "busyState",
                "HAL_TIM_STATE_READY": "readyState",
                "TIM_Base_SetConfig": "setTimerConfig",
                "HAL_OK": "success",
                "HAL_ERROR": "error"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060c4": {
            "entrypoint": "0x080060c4",
            "current_name": "configure_timer_output_compare_080060c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutputCompare_080060c4(TimerTypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint32_t ocMode;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2Value = timer->CR2;\n  ocMode = outputCompareConfig->OCMode;\n  ccerValue = timer->CCER & 0xffffffdf | outputCompareConfig->OCPolarity << 4;\n  if (timer == (TimerTypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xffffff7f | outputCompareConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2Value = cr2Value & 0xfffff3ff | outputCompareConfig->OCIdleState << 2 | outputCompareConfig->OCNIdleState << 2;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocMode << 8;\n  timer->CCR2 = outputCompareConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060c4": "configure_timer_output_compare_080060c4",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocMode",
                "TIM_TypeDef_conflict": "TimerTypeDef"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006128": {
            "entrypoint": "0x08006128",
            "current_name": "configure_tim_oc_08006128",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigure_TIM_OC_08006128(TIM_HandleTypeDef_conflict *TIM_handle,TIM_OC_InitTypeDef *OC_init_config,uint32_t channel_num)\n\n{\n  if (TIM_handle->Lock != HAL_LOCKED) {\n    TIM_handle->Lock = HAL_LOCKED;\n    TIM_handle->State = HAL_TIM_STATE_BUSY;\n    switch(channel_num) {\n    case 0:\n      TIM_OC1_SetConfig(TIM_handle->Instance,OC_init_config);\n      break;\n    case 4:\n      TIM_OC2_SetConfig(TIM_handle->Instance,OC_init_config);\n      break;\n    case 8:\n      TIM_OC3_SetConfig(TIM_handle->Instance,OC_init_config);\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(TIM_handle->Instance,OC_init_config);\n    }\n    TIM_handle->State = HAL_TIM_STATE_READY;\n    TIM_handle->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08006128": "configure_tim_oc_08006128",
                "htim": "TIM_handle",
                "sConfig": "OC_init_config",
                "Channel": "channel_num"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006186": {
            "entrypoint": "0x08006186",
            "current_name": "configure_output_compare_08006186",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureOutputCompare_08006186(TIM_HandleTypeDef_conflict *timer,TIM_OC_InitTypeDef *config,uint32_t channel)\n\n{\n  if (timer->Lock != HAL_LOCKED) {\n    timer->Lock = HAL_LOCKED;\n    timer->State = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timer->Instance,config);\n      timer->Instance->CCMR1 = timer->Instance->CCMR1 | 8;\n      timer->Instance->CCMR1 = timer->Instance->CCMR1 & 0xfffffffb;\n      timer->Instance->CCMR1 = timer->Instance->CCMR1 | config->OCFastMode;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timer->Instance,config);\n      timer->Instance->CCMR1 = timer->Instance->CCMR1 | 0x800;\n      timer->Instance->CCMR1 = timer->Instance->CCMR1 & 0xfffffbff;\n      timer->Instance->CCMR1 = timer->Instance->CCMR1 | config->OCFastMode << 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timer->Instance,config);\n      timer->Instance->CCMR2 = timer->Instance->CCMR2 | 8;\n      timer->Instance->CCMR2 = timer->Instance->CCMR2 & 0xfffffffb;\n      timer->Instance->CCMR2 = timer->Instance->CCMR2 | config->OCFastMode;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timer->Instance,config);\n      timer->Instance->CCMR2 = timer->Instance->CCMR2 | 0x800;\n      timer->Instance->CCMR2 = timer->Instance->CCMR2 & 0xfffffbff;\n      timer->Instance->CCMR2 = timer->Instance->CCMR2 | config->OCFastMode << 8;\n    }\n    timer->State = HAL_TIM_STATE_READY;\n    timer->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08006186": "configure_output_compare_08006186",
                "htim": "timer",
                "sConfig": "config",
                "Channel": "channel"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006262": {
            "entrypoint": "0x08006262",
            "current_name": "configure_tim_channel_08006262",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimChannel_08006262(TIM_TypeDef_conflict *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | state << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006262": "configure_tim_channel_08006262",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006280": {
            "entrypoint": "0x08006280",
            "current_name": "configure_timer_channel_interrupt_08006280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTimerChannelInterrupt_08006280(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channel)\n\n{\n  switch(channel) {\n  case 0:\n    timerHandle->timerInstance->interruptEnableRegister = timerHandle->timerInstance->interruptEnableRegister | 2;\n    break;\n  case 4:\n    timerHandle->timerInstance->interruptEnableRegister = timerHandle->timerInstance->interruptEnableRegister | 4;\n    break;\n  case 8:\n    timerHandle->timerInstance->interruptEnableRegister = timerHandle->timerInstance->interruptEnableRegister | 8;\n    break;\n  case 0xc:\n    timerHandle->timerInstance->interruptEnableRegister = timerHandle->timerInstance->interruptEnableRegister | 0x10;\n  }\n  configureChannelInterrupt(timerHandle->timerInstance,channel,1);\n  if (timerHandle->timerInstance == (TIM_TypeDef_conflict *)0x40012c00) {\n    unknownMemoryLocation = unknownMemoryLocation | 0x8000;\n  }\n  timerHandle->timerInstance->controlRegister = timerHandle->timerInstance->controlRegister | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006280": "configure_timer_channel_interrupt_08006280",
                "htim": "timerHandle",
                "Channel": "channel",
                "Instance": "timerInstance",
                "DIER": "interruptEnableRegister",
                "TIM_CCxChannelCmd": "configureChannelInterrupt",
                "uRam40012c44": "unknownMemoryLocation",
                "CR1": "controlRegister"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080062f4": {
            "entrypoint": "0x080062f4",
            "current_name": "configure_tim_channel_080062f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTIMChannel_080062f4(TIM_HandleTypeDef_conflict *TIMHandle,uint32_t channel)\n\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  switch(channel) {\n  case 0:\n    TIMHandle->Instance->DIER = TIMHandle->Instance->DIER & 0xfffffffd;\n    break;\n  case 4:\n    TIMHandle->Instance->DIER = TIMHandle->Instance->DIER & 0xfffffffb;\n    break;\n  case 8:\n    TIMHandle->Instance->DIER = TIMHandle->Instance->DIER & 0xfffffff7;\n    break;\n  case 0xc:\n    TIMHandle->Instance->DIER = TIMHandle->Instance->DIER & 0xffffffef;\n  }\n  TIM_CCxchannelCmd(TIMHandle->Instance,channel,0);\n  if (((TIMHandle->Instance == (TIM_TypeDef_conflict *)0x40012c00) && ((uRam40012c20 & 0x1111) == 0)) &&\n     ((uRam40012c20 & 0x444) == 0)) {\n    uRam40012c44 = uRam40012c44 & 0xffff7fff;\n  }\n  timerInstance = TIMHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080062f4": "configure_tim_channel_080062f4",
                "htim": "TIMHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006390": {
            "entrypoint": "0x08006390",
            "current_name": "enable_timer_channel_08006390",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict enableTimerChannel_08006390(TIM_HandleTypeDef_conflict *timer,uint32_t channel)\n\n{\n  configureChannelCommand(timer->Instance,channel,1);\n  if (timer->Instance == (TimerType *)0x40012c00) {\n    statusRegister = statusRegister | 0x8000;\n  }\n  timer->Instance->controlRegister1 = timer->Instance->controlRegister1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006390": "enable_timer_channel_08006390",
                "htim": "timer",
                "Channel": "channel",
                "TIM_CCxChannelCmd": "configureChannelCommand",
                "TIM_TypeDef_conflict": "TimerType",
                "uRam40012c44": "statusRegister",
                "CR1": "controlRegister1"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080063c0": {
            "entrypoint": "0x080063c0",
            "current_name": "disable_tim_channel_080063c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimChannel_080063c0(TIM_HandleTypeDef_conflict *timer,uint32_t channel)\n\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  TIM_CCxchannelCmd(timer->Instance,channel,0);\n  if (((timer->Instance == (TIM_TypeDef_conflict *)0x40012c00) && ((memoryAddress1 & 0x1111) == 0)) &&\n     ((memoryAddress1 & 0x444) == 0)) {\n    memoryAddress2 = memoryAddress2 & 0xffff7fff;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timer->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080063c0": "disable_tim_channel_080063c0",
                "htim": "timer",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "uRam40012c20": "memoryAddress1",
                "uRam40012c44": "memoryAddress2"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006420": {
            "entrypoint": "0x08006420",
            "current_name": "update_channel_state_08006420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08006420(TIM_TypeDef_conflict *timer,uint32_t channel,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006420": "update_channel_state_08006420",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800643c": {
            "entrypoint": "0x0800643c",
            "current_name": "configure_timer_channel_0800643c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configure_timer_channel_0800643c(TIM_HandleTypeDef_conflict *timer_handle,uint32_t channel)\n\n{\n  TIM_CCxNchannelCmd(timer_handle->timer_instance,channel,4);\n  timer_handle->timer_instance->BDTR = timer_handle->timer_instance->BDTR | 0x8000;\n  timer_handle->timer_instance->CR1 = timer_handle->timer_instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800643c": "configure_timer_channel_0800643c",
                "htim": "timer_handle",
                "Channel": "channel",
                "Instance": "timer_instance"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006460": {
            "entrypoint": "0x08006460",
            "current_name": "configure_timer_channel_08006460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureTimerChannel_08006460(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  TIM_CCxNchannelNumberCmd(timerHandle->Instance,channelNumber,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->breakAndDeadTimeRegister = timerInstance->breakAndDeadTimeRegister & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->controlRegister = timerInstance->controlRegister & 0xfffffffe;\n  }\n  return HAL_StatusTypeDef_OK;\n}\n\n",
            "renaming": {
                "FUN_08006460": "configure_timer_channel_08006460",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance",
                "CCER": "captureCompareEnableRegister",
                "BDTR": "breakAndDeadTimeRegister",
                "CR1": "controlRegister",
                "HAL_OK": "HAL_StatusTypeDef_OK"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064ac": {
            "entrypoint": "0x080064ac",
            "current_name": "FUNC_080064ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064ac": "FUNC_080064ac"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080064ae": {
            "entrypoint": "0x080064ae",
            "current_name": "FUNC_080064ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064ae": "FUNC_080064ae"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080064b0": {
            "entrypoint": "0x080064b0",
            "current_name": "reset_uart_080064b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_080064b0(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->Instance->control_register1 = uart_handle->Instance->control_register1 & 0xfffffedf;\n  uart_handle->Instance->control_register3 = uart_handle->Instance->control_register3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064b0": "reset_uart_080064b0",
                "huart": "uart_handle",
                "CR1": "control_register1",
                "CR3": "control_register3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064cc": {
            "entrypoint": "0x080064cc",
            "current_name": "transmit_data_080064cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transmitData_080064cc(UART_HandleTypeDef *uartHandler)\n\n{\n  uint16_t updatedTxCount;\n  byte *bufferPtr;\n  uint16_t *tempPointer;\n  \n  if (uartHandler->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandler->Init).WordLength == 0x1000) {\n    uartHandler->Instance->DR = *(ushort *)uartHandler->pTxBuffPtr & 0x1ff;\n    if ((uartHandler->Init).Parity == 0) {\n      uartHandler->pTxBuffPtr = uartHandler->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandler->pTxBuffPtr = uartHandler->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    bufferPtr = uartHandler->pTxBuffPtr;\n    uartHandler->pTxBuffPtr = bufferPtr + 1;\n    uartHandler->Instance->DR = (uint)*bufferPtr;\n  }\n  updatedTxCount = uartHandler->TxXferCount - 1;\n  uartHandler->TxXferCount = updatedTxCount;\n  if (updatedTxCount == 0) {\n    uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xffffff7f;\n    uartHandler->Instance->CR1 = uartHandler->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080064cc": "transmit_data_080064cc",
                "huart": "uartHandler",
                "uVar1": "updatedTxCount",
                "pbVar2": "bufferPtr",
                "tmp": "tempPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006538": {
            "entrypoint": "0x08006538",
            "current_name": "initialize_uart_08006538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08006538(UART_HandleTypeDef *UART_handle)\n\n{\n  uint32_t pclk1_freq;\n  uint32_t pclk1_freq_2;\n  uint32_t pclk1_freq_3;\n  uint32_t pclk1_freq_4;\n  uint32_t pclk1_freq_5;\n  uint32_t baud_rate;\n  uint32_t baud_rate_2;\n  uint32_t baud_rate_3;\n  uint32_t baud_rate_4;\n  USART_TypeDef *uart_instance;\n  \n  UART_handle->Instance->CR2 = UART_handle->Instance->CR2 & 0xffffcfff | (UART_handle->Init).StopBits;\n  UART_handle->Instance->CR1 =\n       (UART_handle->Init).WordLength | (UART_handle->Init).Parity | (UART_handle->Init).Mode |\n       UART_handle->Instance->CR1 & 0xffffe9f3;\n  UART_handle->Instance->CR3 = UART_handle->Instance->CR3 & 0xfffffcff | (UART_handle->Init).HwFlowCtl;\n  uart_instance = UART_handle->Instance;\n  if (uart_instance != (USART_TypeDef *)0x40013800) {\n    pclk1_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (UART_handle->Init).BaudRate;\n    pclk1_freq_2 = HAL_RCC_GetPCLK1Freq();\n    baud_rate_2 = (UART_handle->Init).BaudRate;\n    pclk1_freq_3 = HAL_RCC_GetPCLK1Freq();\n    baud_rate_3 = (UART_handle->Init).BaudRate;\n    pclk1_freq_4 = HAL_RCC_GetPCLK1Freq();\n    baud_rate_4 = (UART_handle->Init).BaudRate;\n    pclk1_freq_5 = HAL_RCC_GetPCLK1Freq();\n    uart_instance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk1_freq_4 * 0x19) / (baud_rate_4 << 2) +\n                                  (int)(((ulonglong)(pclk1_freq_5 * 0x19) /\n                                        (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclk1_freq_2 * 0x19) / (baud_rate_2 << 2) +\n                     (int)(((ulonglong)(pclk1_freq_3 * 0x19) / (ulonglong)(baud_rate_3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclk1_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk1_freq = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (UART_handle->Init).BaudRate;\n  pclk1_freq_2 = HAL_RCC_GetPCLK2Freq();\n  baud_rate_2 = (UART_handle->Init).BaudRate;\n  pclk1_freq_3 = HAL_RCC_GetPCLK2Freq();\n  baud_rate_3 = (UART_handle->Init).BaudRate;\n  pclk1_freq_4 = HAL_RCC_GetPCLK2Freq();\n  baud_rate_4 = (UART_handle->Init).BaudRate;\n  pclk1_freq_5 = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((pclk1_freq_4 * 0x19) / (baud_rate_4 << 2) +\n                                (int)(((ulonglong)(pclk1_freq_5 * 0x19) /\n                                      (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclk1_freq_2 * 0x19) / (baud_rate_2 << 2) +\n                   (int)(((ulonglong)(pclk1_freq_3 * 0x19) / (ulonglong)(baud_rate_3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclk1_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006538": "initialize_uart_08006538",
                "huart": "UART_handle",
                "uVar1": "pclk1_freq",
                "uVar2": "pclk1_freq_2",
                "uVar3": "pclk1_freq_3",
                "uVar4": "pclk1_freq_4",
                "uVar5": "pclk1_freq_5",
                "uVar6": "baud_rate",
                "uVar7": "baud_rate_2",
                "uVar8": "baud_rate_3",
                "uVar9": "baud_rate_4",
                "pUVar10": "uart_instance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066e8": {
            "entrypoint": "0x080066e8",
            "current_name": "check_flag_status_080066e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_desiredStatusTypeDef_conflict\ncheckFlagStatus_080066e8(UART_HandleTypeDef *uartHandle,uint32_t flag,flagdesiredStatus desiredStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flag & ~uartHandle->Instance->SR) == 0) != (bool)desiredStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080066e8": "check_flag_status_080066e8",
                "huart": "uartHandle",
                "Flag": "flag",
                "Status": "desiredStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800674c": {
            "entrypoint": "0x0800674c",
            "current_name": "FUNC_0800674c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800674c": "FUNC_0800674c"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800674e": {
            "entrypoint": "0x0800674e",
            "current_name": "initialize_uart_0800674e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUART_0800674e(UART_HandleTypeDef *uartHandle)\n\n{\n  if (uartHandle != (UART_HandleTypeDef *)0x0) {\n    if (uartHandle->gState == RESET_STATE) {\n      uartHandle->Lock = UNLOCKED_STATE;\n      initUartMsp(uartHandle);\n    }\n    uartHandle->gState = BUSY_STATE;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    setUartConfig(uartHandle);\n    uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffb7ff;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xffffffd5;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = READY_STATE;\n    uartHandle->RxState = READY_STATE;\n    return OK_STATUS;\n  }\n  return ERROR_STATUS;\n}\n\n",
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "huart": "uartHandle",
                "HAL_UART_STATE_RESET": "RESET_STATE",
                "HAL_UNLOCKED": "UNLOCKED_STATE",
                "HAL_UART_MspInit": "initUartMsp",
                "UART_SetConfig": "setUartConfig",
                "HAL_UART_STATE_BUSY": "BUSY_STATE",
                "HAL_UART_STATE_READY": "READY_STATE",
                "HAL_OK": "OK_STATUS",
                "HAL_ERROR": "ERROR_STATUS"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080067ac": {
            "entrypoint": "0x080067ac",
            "current_name": "transmit_data_080067ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ntransmitData_080067ac(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tickStart;\n  uint16_t *tmpPointer;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uartHandle->TxXferdataSize = dataSize;\n      uartHandle->TxXferCount = dataSize;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)dataBuffer & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 2);\n          }\n          else {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*dataBuffer;\n          dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080067ac": "transmit_data_080067ac",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "tmp": "tmpPointer"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "UART_WaitOnFlagUntilTimeout",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800688e": {
            "entrypoint": "0x0800688e",
            "current_name": "initialize_transmission_0800688e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeTransmission_0800688e(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800688e": "initialize_transmission_0800688e",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068d6": {
            "entrypoint": "0x080068d6",
            "current_name": "initialize_uart_receive_080068d6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_UART_receive_080068d6(UART_HandleTypeDef *uart_handle,uint8_t *receive_buffer,uint16_t buffer_size)\n\n{\n  if (uart_handle->receive_state != UART_STATE_READY) {\n    return HAL_UART_BUSY;\n  }\n  if (receive_buffer == (uint8_t *)0x0) {\n    return HAL_UART_ERROR;\n  }\n  if (buffer_size == 0) {\n    return HAL_UART_ERROR;\n  }\n  if (uart_handle->uart_lock != HAL_UART_LOCKED) {\n    uart_handle->receive_buffer_pointer = receive_buffer;\n    uart_handle->receive_transfer_size = buffer_size;\n    uart_handle->receive_transfer_count = buffer_size;\n    uart_handle->uart_error_code = 0;\n    uart_handle->receive_state = UART_STATE_BUSY_RX;\n    uart_handle->uart_lock = UART_UNLOCKED;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x100;\n    uart_handle->Instance->CR3 = uart_handle->Instance->CR3 | 1;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x20;\n    return HAL_UART_OK;\n  }\n  return HAL_UART_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080068d6": "initialize_uart_receive_080068d6",
                "huart": "uart_handle",
                "pData": "receive_buffer",
                "Size": "buffer_size",
                "RxState": "receive_state",
                "HAL_BUSY": "HAL_UART_BUSY",
                "HAL_ERROR": "HAL_UART_ERROR",
                "HAL_OK": "HAL_UART_OK",
                "HAL_LOCKED": "HAL_UART_LOCKED",
                "Lock": "uart_lock",
                "pRxBuffPtr": "receive_buffer_pointer",
                "RxXferSize": "receive_transfer_size",
                "RxXferCount": "receive_transfer_count",
                "ErrorCode": "uart_error_code",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_UART_STATE_BUSY_RX": "UART_STATE_BUSY_RX",
                "HAL_UNLOCKED": "UART_UNLOCKED"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006932": {
            "entrypoint": "0x08006932",
            "current_name": "configure_uart_08006932",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureUART_08006932(UART_HandleTypeDef *uartHandler)\n\n{\n  uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 & 0xffffffbf;\n  uartHandler->uartState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uartHandler);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08006932": "configure_uart_08006932",
                "huart": "uartHandler",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "gState": "uartState"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800694c": {
            "entrypoint": "0x0800694c",
            "current_name": "process_rx_data_0800694c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processRxData_0800694c(UART_HandleTypeDef *uartHandler)\n\n{\n  uint16_t *tmpPtr;\n  byte *bytePtr;\n  uint16_t remainingBytes;\n  uint8_t *uint8Ptr;\n  \n  if (uartHandler->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandler->Init).WordLength == 0x1000) {\n    if ((uartHandler->Init).Parity == 0) {\n      *(ushort *)uartHandler->pRxBuffPtr = (ushort)((uartHandler->Instance->DR << 0x17) >> 0x17);\n      uartHandler->pRxBuffPtr = uartHandler->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandler->pRxBuffPtr = (ushort)uartHandler->Instance->DR & 0xff;\n      uartHandler->pRxBuffPtr = uartHandler->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandler->Init).Parity == 0) {\n    uint8Ptr = uartHandler->pRxBuffPtr;\n    uartHandler->pRxBuffPtr = uint8Ptr + 1;\n    *uint8Ptr = (uint8_t)uartHandler->Instance->DR;\n  }\n  else {\n    bytePtr = uartHandler->pRxBuffPtr;\n    uartHandler->pRxBuffPtr = bytePtr + 1;\n    *bytePtr = (byte)uartHandler->Instance->DR & 0x7f;\n  }\n  remainingBytes = uartHandler->RxXferCount - 1;\n  uartHandler->RxXferCount = remainingBytes;\n  if (remainingBytes != 0) {\n    return HAL_OK;\n  }\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xffffffdf;\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xfffffeff;\n  uartHandler->Instance->CR3 = uartHandler->Instance->CR3 & 0xfffffffe;\n  uartHandler->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandler);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800694c": "process_rx_data_0800694c",
                "huart": "uartHandler",
                "tmp": "tmpPtr",
                "pbVar1": "bytePtr",
                "uVar2": "remainingBytes",
                "puVar3": "uint8Ptr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069ec": {
            "entrypoint": "0x080069ec",
            "current_name": "handle_uart_interrupt_080069ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_080069ec(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint cr1;\n  uint32_t cr1_interrupt_status;\n  USART_TypeDef *uart_instance;\n  uint32_t cr3_interrupt_status;\n  uint cr3_bit;\n  uint sr;\n  uint32_t interrupt_flags;\n  \n  uart_instance = uart_handle->Instance;\n  sr = uart_instance->SR;\n  cr1 = uart_instance->CR1;\n  if ((((sr & 0xf) == 0) && ((sr & 0x20) != 0)) && ((cr1 & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n  if (((sr & 0xf) == 0) || ((cr3_bit = uart_instance->CR3 & 1, cr3_bit == 0 && ((cr1 & 0x120) == 0)))) {\n    if (((sr & 0x80) != 0) && ((cr1 & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n    if (((sr & 0x40) != 0) && ((cr1 & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr & 1) != 0) && ((cr1 & 0x100) != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 1;\n    }\n    if (((sr & 4) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n    }\n    if (((sr & 2) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n    }\n    if (((sr & 8) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n    }\n    if (uart_handle->ErrorCode != 0) {\n      if (((sr & 0x20) != 0) && ((cr1 & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      if (((uart_handle->ErrorCode & 8) == 0) && ((uart_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handle);\n      uart_instance = uart_handle->Instance;\n      if ((uart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_instance->CR3 = uart_instance->CR3 & 0xffffffbf;\n      if (uart_handle->hdmarx == (DMA_HandleTypeDef_conflict *)0x0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069ec": "handle_uart_interrupt_080069ec",
                "huart": "uart_handle",
                "HVar1": "status",
                "uVar2": "cr1",
                "uVar4": "cr3_bit",
                "uVar5": "sr",
                "cr1its": "cr1_interrupt_status",
                "cr3its": "cr3_interrupt_status",
                "isrflags": "interrupt_flags",
                "pUVar3": "uart_instance"
            },
            "calling": [
                "USART1_IRQHandler",
                "USART3_IRQHandler",
                "USART2_IRQHandler"
            ],
            "called": [
                "UART_EndTransmit_IT",
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b0c": {
            "entrypoint": "0x08006b0c",
            "current_name": "reset_uart_08006b0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_08006b0c(DMA_HandleTypeDef_conflict *dma_handler)\n\n{\n  UART_HandleTypeDef *uart_handler;\n  UART_HandleTypeDef *uart;\n  \n  uart_handler = (UART_HandleTypeDef *)dma_handler->parent;\n  uart_handler->receive_transfer_count = 0;\n  uart_handler->transmit_transfer_count = 0;\n  handle_uart_error(uart_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b0c": "reset_uart_08006b0c",
                "hdma": "dma_handler",
                "huart_00": "uart_handler",
                "huart": "uart",
                "Parent": "parent",
                "RxXferCount": "receive_transfer_count",
                "TxXferCount": "transmit_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b1c": {
            "entrypoint": "0x08006b1c",
            "current_name": "get_state_combination_08006b1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef getStateCombination_08006b1c(UART_HandleTypeDef *uartHandle)\n\n{\n  return uartHandle->receiveState | uartHandle->generalState;\n}\n\n",
            "renaming": {
                "FUN_08006b1c": "get_state_combination_08006b1c",
                "huart": "uartHandle",
                "RxState": "receiveState",
                "gState": "generalState"
            },
            "calling": [
                "serial_rx_active",
                "serial_tx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b28": {
            "entrypoint": "0x08006b28",
            "current_name": "check_pin_state_08006b28",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinState_08006b28(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08006b28": "check_pin_state_08006b28",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "analogWrite",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b3e": {
            "entrypoint": "0x08006b3e",
            "current_name": "set_pin_mode_08006b3e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinMode_08006b3e(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t pinIndex;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)pinName & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b3e": "set_pin_mode_08006b3e",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex",
                "index": "pinIndex"
            },
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b5c": {
            "entrypoint": "0x08006b5c",
            "current_name": "clear_pin_in_map_08006b5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPinInMap_08006b5c(pinName pin,uint32_t *map)\n\n{\n  uint shiftedIndex;\n  uint32_t unshiftedIndex;\n  \n  shiftedIndex = (uint)((int)pin << 0x18) >> 0x1c;\n  map[shiftedIndex] = map[shiftedIndex] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b5c": "clear_pin_in_map_08006b5c",
                "PinName_conflict": "pinName",
                "uVar1": "shiftedIndex",
                "index": "unshiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b7c": {
            "entrypoint": "0x08006b7c",
            "current_name": "get_gpio_address_08006b7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * getGPIOAddress_08006b7c(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIOType *)0x40010800;\n  case 1:\n    return (GPIOType *)0x40010c00;\n  case 2:\n    return (GPIOType *)0x40011000;\n  case 3:\n    return (GPIOType *)0x40011400;\n  case 4:\n    return (GPIOType *)0x40011800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08006b7c": "get_gpio_address_08006b7c",
                "port_idx": "portIndex",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006bb8": {
            "entrypoint": "0x08006bb8",
            "current_name": "get_gpio_08006bb8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIO_08006bb8(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *gpioPointer;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    gpioPointer = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    gpioPointer = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    gpioPointer = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    gpioPointer = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    gpioPointer = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    gpioPointer = (GPIO_TypeDef *)0x0;\n  }\n  return gpioPointer;\n}\n\n",
            "renaming": {
                "FUN_08006bb8": "get_gpio_08006bb8",
                "port_idx": "portIndex",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4",
                "pGVar1": "gpioPointer"
            },
            "calling": [
                "uart_init",
                "HAL_TIM_PWM_MspInit",
                "HAL_ADC_MspInit",
                "digital_io_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c60": {
            "entrypoint": "0x08006c60",
            "current_name": "get_adc_function_08006c60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getADCFunction_08006c60(pin pin)\n\n{\n  uint32_t functionIndex;\n  uint32_t result;\n  \n  functionIndex = pinmap_result(pin,(PinMap_conflict *)&PinMap_ADC);\n  result = functionIndex << 0xc;\n  result = result >> 0x1b;\n  if (0x10 < result - 1) {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006c60": "get_adc_function_08006c60",
                "PinName_conflict": "pin",
                "uVar1": "functionIndex",
                "function": "result"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c7c": {
            "entrypoint": "0x08006c7c",
            "current_name": "pin_function_to_config_08006c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinFunctionToConfig_08006c7c(PinName_conflict pinConflictingName)\n\n{\n  uint32_t functionMapping;\n  uint32_t shiftedFunction;\n  \n  functionMapping = pinConflictingNamemap_shiftedFunction(pinConflictingName,(PinMap_conflict *)&PinMap_PWM);\n  shiftedFunction = functionMapping << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction == 3) {\n    return 8;\n  }\n  if (shiftedFunction != 4) {\n    if (shiftedFunction != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08006c7c": "pin_function_to_config_08006c7c",
                "pin": "pinConflictingName",
                "uVar1": "functionMapping",
                "function": "shiftedFunction"
            },
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ca8": {
            "entrypoint": "0x08006ca8",
            "current_name": "initialize_adc_gpio_08006ca8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_ADC_GPIO_08006ca8(ADC_HandleTypeDef *ADC_Handle)\n\n{\n  GPIO_TypeDef *GPIO_Port;\n  GPIO_TypeDef *GPIO_Port;\n  uint32_t temporary_register;\n  uint32_t temporary_register_1;\n  GPIO_InitTypeDef GPIO_Init_Struct;\n  \n  if (ADC_Handle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (ADC_Handle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  GPIO_Port = set_GPIO_Port_Clock((uint)((int)current_pin << 0x18) >> 0x1c);\n  GPIO_Init_Struct.Pin = 1 << (current_pin & 0xfU) & 0xffff;\n  GPIO_Init_Struct.Mode = 3;\n  GPIO_Init_Struct.Pull = 0;\n  HAL_GPIO_Init(GPIO_Port,&GPIO_Init_Struct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006ca8": "initialize_adc_gpio_08006ca8",
                "hadc": "ADC_Handle",
                "GPIOx": "GPIO_Port",
                "port": "GPIO_Port",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "GPIO_InitStruct": "GPIO_Init_Struct",
                "g_current_pin": "current_pin"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d24": {
            "entrypoint": "0x08006d24",
            "current_name": "configure_adc_protection_08006d24",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureADCProtection_08006d24(ADC_HandleTypeDef *adcHandle)\n\n{\n  if (adcHandle->Instance != (ADC_Register *)0x40012400) {\n    if (adcHandle->Instance == (ADC_Register *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d24": "configure_adc_protection_08006d24",
                "hadc": "adcHandle",
                "ADC_TypeDef": "ADC_Register"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d80": {
            "entrypoint": "0x08006d80",
            "current_name": "get_adc_value_08006d80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t get_adc_value_08006d80(PinName_conflict pin_name)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t adc_value;\n  uint16_t converted_value;\n  ADC_ChannelConfTypeDef adc_channel_config;\n  ADC_HandleTypeDef adc_handle;\n  \n  memset(&adc_handle,0,0x30);\n  adc_channel_config.Channel = 0;\n  adc_channel_config.Rank = 0;\n  adc_channel_config.SamplingTime = 0;\n  converted_value = 0;\n  adc_handle.Instance = (ADC_TypeDef *)pin_namemap_peripheral(pin_name,(PinMap_conflict *)&PinMap_ADC);\n  if (adc_handle.Instance == (ADC_TypeDef *)0x0) {\n    converted_value = 0;\n  }\n  else {\n    adc_handle.Init.DataAlign = 0;\n    adc_handle.Init.ScanConvMode = 0;\n    adc_handle.Init.ContinuousConvMode = 0;\n    adc_handle.Init.DiscontinuousConvMode = 0;\n    adc_handle.Init.ExternalTrigConv = 0xe0000;\n    adc_handle.State = 0;\n    adc_handle.Init.NbrOfConversion = 1;\n    adc_handle.Init.NbrOfDiscConversion = 0;\n    g_current_pin_name = pin_name;\n    status = HAL_ADC_Init(&adc_handle);\n    if (status == HAL_OK) {\n      adc_channel_config.Channel = get_adc_channel(pin_name);\n      if (adc_channel_config.Channel < 0x12) {\n        adc_channel_config.Rank = 1;\n        adc_channel_config.SamplingTime = 2;\n        status = HAL_ADC_ConfigChannel(&adc_handle,&adc_channel_config);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&adc_handle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&adc_handle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&adc_handle,10);\n              if (status == HAL_OK) {\n                adc_value = HAL_ADC_GetState(&adc_handle);\n                if ((adc_value & 0x200) != 0) {\n                  adc_value = HAL_ADC_GetValue(&adc_handle);\n                  converted_value = (uint16_t)adc_value;\n                }\n                status = HAL_ADC_Stop(&adc_handle);\n                if (status == HAL_OK) {\n                  status = HAL_ADC_DeInit(&adc_handle);\n                  if (status != HAL_OK) {\n                    converted_value = 0;\n                  }\n                }\n                else {\n                  converted_value = 0;\n                }\n              }\n              else {\n                converted_value = 0;\n              }\n            }\n            else {\n              converted_value = 0;\n            }\n          }\n          else {\n            converted_value = 0;\n          }\n        }\n        else {\n          converted_value = 0;\n        }\n      }\n      else {\n        converted_value = 0;\n      }\n    }\n    else {\n      converted_value = 0;\n    }\n  }\n  return converted_value;\n}\n\n",
            "renaming": {
                "FUN_08006d80": "get_adc_value_08006d80",
                "pin": "pin_name",
                "HVar1": "status",
                "uVar2": "adc_value",
                "uhADCxConvertedValue": "converted_value",
                "AdcChannelConf": "adc_channel_config",
                "AdcHandle": "adc_handle"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "memset",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_GetValue",
                "get_adc_channel",
                "pinmap_peripheral",
                "HAL_ADC_GetState",
                "HAL_ADC_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_DeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e68": {
            "entrypoint": "0x08006e68",
            "current_name": "initialize_pwm_08006e68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_PWM_08006e68(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  uint32_t function;\n  uint32_t function;\n  GPIO_TypeDef *port_1;\n  GPIO_TypeDef *port_2;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_init_settings;\n  \n  function = pinmap_function(g_current_pin,(PinMap_conflict *)&PinMap_PWM);\n  timer_enable_clock(timer_handle);\n  port_1 = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  GPIO_init_settings.Mode = 2;\n  GPIO_init_settings.Pull = 0;\n  GPIO_init_settings.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  switch((function << 0x11) >> 0x19) {\n  case 1:\n    tmpreg_10 = tmpreg_10 | 0x7000001;\n    break;\n  case 2:\n    tmpreg_10 = tmpreg_10 & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    tmpreg_10 = tmpreg_10 | 0x7000002;\n    break;\n  case 4:\n    tmpreg_10 = tmpreg_10 & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    tmpreg_10 = tmpreg_10 | 0x7000004;\n    break;\n  case 6:\n    tmpreg_10 = tmpreg_10 & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    tmpreg_10 = tmpreg_10 | 0x7000008;\n    break;\n  case 8:\n    tmpreg_10 = tmpreg_10 & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    tmpreg_10 = tmpreg_10 | 0x7000030;\n    break;\n  case 10:\n    tmpreg_1 = tmpreg_10 & 0xffffffcf;\n    tmpreg_10 = tmpreg_1 | 0x7000010;\n    break;\n  case 0xb:\n    tmpreg_2 = tmpreg_10 & 0xffffffcf;\n    tmpreg_10 = tmpreg_2 | 0x7000000;\n    break;\n  case 0xc:\n    tmpreg_10 = tmpreg_10 | 0x70000c0;\n    break;\n  case 0xd:\n    tmpreg_3 = tmpreg_10 & 0xffffff3f;\n    tmpreg_10 = tmpreg_3 | 0x7000040;\n    break;\n  case 0xe:\n    tmpreg_4 = tmpreg_10 & 0xffffff3f;\n    tmpreg_10 = tmpreg_4 | 0x7000000;\n    break;\n  case 0xf:\n    tmpreg_10 = tmpreg_10 | 0x7000300;\n    break;\n  case 0x10:\n    tmpreg_5 = tmpreg_10 & 0xfffffcff;\n    tmpreg_10 = tmpreg_5 | 0x7000200;\n    break;\n  case 0x11:\n    tmpreg_6 = tmpreg_10 & 0xfffffcff;\n    tmpreg_10 = tmpreg_6 | 0x7000100;\n    break;\n  case 0x12:\n    tmpreg_7 = tmpreg_10 & 0xfffffcff;\n    tmpreg_10 = tmpreg_7 | 0x7000000;\n    break;\n  case 0x13:\n    tmpreg_10 = tmpreg_10 | 0x7000c00;\n    break;\n  case 0x14:\n    tmpreg_8 = tmpreg_10 & 0xfffff3ff;\n    tmpreg_10 = tmpreg_8 | 0x7000800;\n    break;\n  case 0x15:\n    tmpreg_9 = tmpreg_10 & 0xfffff3ff;\n    tmpreg_10 = tmpreg_9 | 0x7000000;\n    break;\n  case 0x16:\n    tmpreg_10 = tmpreg_10 | 0x7001000;\n    break;\n  case 0x17:\n    tmpreg_10 = tmpreg_10 & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    tmpreg_10 = tmpreg_10 | 0x7008000;\n    break;\n  case 0x1c:\n    tmpreg_10 = tmpreg_10 & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    tmpreg_10 = tmpreg_10 & 0xf8ffffff;\n    break;\n  case 0x22:\n    tmpreg_11 = tmpreg_10 & 0xf8ffffff;\n    tmpreg_10 = tmpreg_11 | 0x1000000;\n    break;\n  case 0x23:\n    tmpreg_12 = tmpreg_10 & 0xf8ffffff;\n    tmpreg_10 = tmpreg_12 | 0x2000000;\n    break;\n  case 0x24:\n    tmpreg_10 = tmpreg_10 & 0xf8ffffff | 0x4000000;\n  }\n  GPIO_init_settings.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  HAL_GPIO_Init(port_1,&GPIO_init_settings);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e68": "initialize_pwm_08006e68",
                "htim": "timer_handle",
                "uVar1": "function",
                "GPIOx": "port_1",
                "port": "port_2",
                "GPIO_InitStruct": "GPIO_init_settings"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "timer_enable_clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007110": {
            "entrypoint": "0x08007110",
            "current_name": "disable_timer_clock_08007110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerClock_08007110(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  timer_disable_clock(timerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110",
                "htim": "timerHandle"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007118": {
            "entrypoint": "0x08007118",
            "current_name": "configure_pwm_output_08007118",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configure_pwm_output_08007118(pin pin,uint32_t clock_frequency,uint32_t pwm_period,uint32_t pwm_value,\n                 uint8_t initialize_pwm)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timer_clk_freq;\n  uint32_t timer_channel;\n  uint32_t pwm_function;\n  TIM_OC_InitTypeDef pwm_configuration;\n  TIM_HandleTypeDef_conflict timer_handle;\n  \n  memset(&timer_handle,0,0x40);\n  pwm_configuration.OCMode = 0;\n  pwm_configuration.Pulse = 0;\n  pwm_configuration.OCPolarity = 0;\n  pwm_configuration.OCNPolarity = 0;\n  pwm_configuration.OCFastMode = 0;\n  pwm_configuration.OCIdleState = 0;\n  pwm_configuration.OCNIdleState = 0;\n  timer_handle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM)\n  ;\n  if (timer_handle.Instance != (TIM_TypeDef_conflict *)0x0) {\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_frequency - 1;\n    timer_handle.Init.Period = pwm_period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = 0;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if (((initialize_pwm != '\\x01') ||\n        (g_current_pin = pin, status = HAL_TIM_PWM_Init(&timer_handle), status == HAL_OK)) &&\n       (((timer_clk_freq = get_pwm_channel(pin), timer_clk_freq == 0 ||\n         (((timer_clk_freq == 4 || (timer_clk_freq == 8)) || (timer_clk_freq == 0xc)))) || (timer_clk_freq == 0x18)))) {\n      pwm_configuration.OCMode = 0x60;\n      pwm_configuration.OCPolarity = 0;\n      pwm_configuration.OCFastMode = 0;\n      pwm_configuration.OCNPolarity = 0;\n      pwm_configuration.OCNIdleState = 0;\n      pwm_configuration.OCIdleState = 0;\n      pwm_configuration.Pulse = pwm_value;\n      status = HAL_TIM_PWM_ConfigChannel(&timer_handle,&pwm_configuration,timer_clk_freq);\n      if (status == HAL_OK) {\n        pwm_function = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n        if ((pwm_function & 0x100000) == 0) {\n          HAL_TIM_PWM_Start(&timer_handle,timer_clk_freq);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(&timer_handle,timer_clk_freq);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007118": "configure_pwm_output_08007118",
                "PinName_conflict": "pin",
                "clock_freq": "clock_frequency",
                "period": "pwm_period",
                "value": "pwm_value",
                "do_init": "initialize_pwm",
                "HVar1": "status",
                "uVar2": "timer_clk_freq",
                "timChannel": "timer_channel",
                "uVar3": "pwm_function",
                "timConfig": "pwm_configuration",
                "timHandle": "timer_handle"
            },
            "calling": [
                "analogWrite"
            ],
            "called": [
                "memset",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIMEx_PWMN_Start",
                "pinmap_function",
                "get_pwm_channel",
                "HAL_TIM_PWM_Start",
                "pinmap_peripheral",
                "getTimerClkFreq",
                "HAL_TIM_PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071e4": {
            "entrypoint": "0x080071e4",
            "current_name": "stop_pwm_channel_080071e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPWMChannel_080071e4(pinName pinName)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timerChannel;\n  uint32_t pinFunction;\n  TIM_HandleTypeDef_conflict timerHandle;\n  \n  timerHandle.Instance = (TIM_TypeDef_conflict *)pinNamemap_peripheral(pinName,(PinMap_conflict *)&PinMap_PWM)\n  ;\n  if ((timerHandle.Instance != (TIM_TypeDef_conflict *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pinName), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    pinFunction = pinNamemap_function(pinName,(PinMap_conflict *)&PinMap_PWM);\n    if ((pinFunction & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timerHandle,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timerHandle,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080071e4": "stop_pwm_channel_080071e4",
                "PinName_conflict": "pinName",
                "pin": "pinName",
                "Channel": "pwmChannel",
                "timChannel": "timerChannel",
                "uVar1": "pinFunction",
                "timHandle": "timerHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800723c": {
            "entrypoint": "0x0800723c",
            "current_name": "get_tick_0800723c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTick_0800723c(void)\n\n{\n  uint32_t tickValue;\n  \n  tickValue = HAL_GetTick();\n  return tickValue;\n}\n\n",
            "renaming": {
                "FUN_0800723c": "get_tick_0800723c",
                "uVar1": "tickValue"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007244": {
            "entrypoint": "0x08007244",
            "current_name": "FUNC_08007244",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007244(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007244": "FUNC_08007244"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007246": {
            "entrypoint": "0x08007246",
            "current_name": "handle_sys_tick_interrupt_08007246",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08007246(void)\n\n{\n  incrementSystemTickCount();\n  handleSysTickInterrupt_08007246Request();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007246": "handle_sys_tick_interrupt_08007246",
                "HAL_IncTick": "incrementSystemTickCount",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterruptRequest",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick",
                "noOsSystickHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007258": {
            "entrypoint": "0x08007258",
            "current_name": "initialize_pin_08007258",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePin_08007258(pinName pin,uint32_t pinMode,uint32_t pullMode)\n\n{\n  uint pinIndex;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  pinIndex = (uint)pin;\n  gpioPort = set_GPIO_Port_Clock((pinIndex << 0x18) >> 0x1c);\n  gpioInitStruct.Pin = 1 << (pinIndex & 0xf) & 0xffff;\n  gpioInitStruct.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pinIndex - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pinIndex == 0xf) || (pinIndex == 0x13)) || (pinIndex == 0x14)) {\n    tempRegister1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = tempRegister1 | 0x2000000;\n  }\n  gpioInitStruct.Mode = pinMode;\n  gpioInitStruct.Pull = pullMode;\n  HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007258": "initialize_pin_08007258",
                "PinName_conflict": "pinName",
                "mode": "pinMode",
                "pull": "pullMode",
                "uVar1": "pinIndex",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "GPIO_InitStructure": "gpioInitStruct"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d8": {
            "entrypoint": "0x080072d8",
            "current_name": "set_pin_state_080072d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_080072d8(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t state)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072d8": "set_pin_state_080072d8",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072f0": {
            "entrypoint": "0x080072f0",
            "current_name": "read_pin_state_080072f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readPinState_080072f0(GPIO_TypeDef *gpioPort,uint32_t gpioPin)\n\n{\n  GPIO_PinState pinState;\n  \n  pinState = HAL_GPIO_ReadPin(gpioPort,(uint16_t)gpioPin);\n  return (uint)pinState;\n}\n\n",
            "renaming": {
                "FUN_080072f0": "read_pin_state_080072f0",
                "port": "gpioPort",
                "pin": "gpioPin",
                "GVar1": "pinState"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072fa": {
            "entrypoint": "0x080072fa",
            "current_name": "initialize_system_080072fa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_080072fa(void)\n\n{\n  initialize_HAL();\n  configure_system_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_system_clock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007306": {
            "entrypoint": "0x08007306",
            "current_name": "find_peripheral_by_pin_08007306",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_by_pin_08007306(PinName_conflict target_pin,PinMap_conflict *LUIOHLODno_connection)\n\n{\n  while( true ) {\n    if (LUIOHLODno_connection->target_pin == no_connection) {\n      return (void *)0x0;\n    }\n    if (LUIOHLODno_connection->target_pin == target_pin) break;\n    LUIOHLODno_connection = LUIOHLODno_connection + 1;\n  }\n  return LUIOHLODno_connection->found_peripheral;\n}\n\n",
            "renaming": {
                "FUN_08007306": "find_peripheral_by_pin_08007306",
                "pin": "target_pin",
                "map": "pin_map",
                "NC": "no_connection",
                "peripheral": "found_peripheral"
            },
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007320": {
            "entrypoint": "0x08007320",
            "current_name": "find_peripheral_by_pin_08007320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_by_pin_08007320(PinName_conflict pin,PinMap_conflict *pin_map)\n\n{\n  void *peripheral;\n  \n  if (pin != NC) {\n    peripheral = pinpin_map_find_peripheral(pin,pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08007320": "find_peripheral_by_pin_08007320",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_write",
                "uart_init",
                "adc_read_value",
                "uart_debug_init",
                "pwm_stop",
                "pwm_start",
                "i2c_custom_init"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007332": {
            "entrypoint": "0x08007332",
            "current_name": "find_pin_by_peripheral_08007332",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPinByPeripheral_08007332(void *searchPeripheral,PinMap *pinMapping)\n\n{\n  while( true ) {\n    if (pinMapping->searchPeripheral == (void *)0x0) {\n      return NoConnection;\n    }\n    if (pinMapping->searchPeripheral == searchPeripheral) break;\n    pinMapping = pinMapping + 1;\n  }\n  return pinMapping->pin;\n}\n\n",
            "renaming": {
                "FUN_08007332": "find_pin_by_peripheral_08007332",
                "peripheral": "searchPeripheral",
                "map": "pinMapping",
                "NC": "NoConnection",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800734a": {
            "entrypoint": "0x0800734a",
            "current_name": "find_pin_name_0800734a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinName_0800734a(void *device,PinMap_conflict *pinMap)\n\n{\n  PinName_conflict foundPin;\n  \n  if (device != (void *)0x0) {\n    foundPin = pinpinMap_find_pin(device,pinMap);\n    return foundPin;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_0800734a": "find_pin_name_0800734a",
                "peripheral": "device",
                "map": "pinMap",
                "PVar1": "foundPin"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800735a": {
            "entrypoint": "0x0800735a",
            "current_name": "find_pin_function_0800735a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800735a(pinName desiredPin,pinMap *pinMapping)\n\n{\n  while( true ) {\n    if (pinMapping->desiredPin == NotConnected) {\n      return 0xffffffff;\n    }\n    if (pinMapping->desiredPin == desiredPin) break;\n    pinMapping = pinMapping + 1;\n  }\n  return pinMapping->function;\n}\n\n",
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "PinName_conflict": "pinName",
                "PinMap_conflict": "pinMap",
                "pin": "desiredPin",
                "map": "pinMapping",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007376": {
            "entrypoint": "0x08007376",
            "current_name": "find_pin_function_08007376",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08007376(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t result;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  result = find_function_in_map(pin_name,pin_map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "pinmap_find_function": "find_function_in_map",
                "uVar1": "result"
            },
            "calling": [
                "uart_init",
                "HAL_TIM_PWM_MspInit",
                "get_pwm_channel",
                "pwm_stop",
                "get_adc_channel",
                "pwm_start",
                "i2c_custom_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800738a": {
            "entrypoint": "0x0800738a",
            "current_name": "is_valid_pin_0800738a",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool isValidPin_0800738a(pinName pinInput,pinMap *pinMapPtr)\n\n{\n  if (pinInput == NC) {\n    return false;\n  }\n  while( true ) {\n    if (pinMapPtr->pinInput == NC) {\n      return false;\n    }\n    if (pinInput == pinMapPtr->pinInput) break;\n    pinMapPtr = pinMapPtr + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800738a": "is_valid_pin_0800738a",
                "PinName_conflict": "pinName",
                "PinMap_conflict": "pinMap",
                "pin": "pinInput",
                "map": "pinMapPtr"
            },
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback",
                "analogWrite",
                "pinMode",
                "enableI2CPins",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073ae": {
            "entrypoint": "0x080073ae",
            "current_name": "merge_pointers_080073ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_080073ae(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_080073ae": "merge_pointers_080073ae"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073c0": {
            "entrypoint": "0x080073c0",
            "current_name": "execute_rtc_callback_080073c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_RTC_callback_080073c0(RTC_HandleTypeDef *rtc_handler)\n\n{\n  if (callback_function != (callback_pointer)0x0) {\n    (*callback_function)(callback_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073c0": "execute_rtc_callback_080073c0",
                "hrtc": "rtc_handler",
                "RTCUserCallback": "callback_function",
                "voidCallbackPtr": "callback_pointer",
                "callbackUserData": "callback_data"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073d8": {
            "entrypoint": "0x080073d8",
            "current_name": "handle_rtc_alarm_080073d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleRTCAlarm_080073d8(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(&rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073d8": "handle_rtc_alarm_080073d8",
                "RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073e8": {
            "entrypoint": "0x080073e8",
            "current_name": "infinite_loop_080073e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080073e8(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080073e8": "infinite_loop_080073e8",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "SystemClock_Config",
                "_Error_Handler",
                "onReceiveService"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073ec": {
            "entrypoint": "0x080073ec",
            "current_name": "initialize_registers_080073ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_080073ec(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073ec": "initialize_registers_080073ec"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007438": {
            "entrypoint": "0x08007438",
            "current_name": "initialize_timers_08007438",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimers_08007438(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  \n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n    timer_handles[0] = timerHandle;\n  }\n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n    timer_handles[1] = timerHandle;\n  }\n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n    timer_handles[2] = timerHandle;\n  }\n  if (timerHandle->Instance == (TIM_TypeDef_conflict *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n    timer_handles[3] = timerHandle;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007438": "initialize_timers_08007438",
                "htim": "timerHandle",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3"
            },
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080074e0": {
            "entrypoint": "0x080074e0",
            "current_name": "update_timer_configuration_080074e0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateTimerConfiguration_080074e0(TIM_HandleTypeDef_conflict *timerConfig)\n\n{\n  if (timerConfig->timerInstance == (TimerTypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (timerConfig->timerInstance == (TimerTypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (timerConfig->timerInstance == (TimerTypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (timerConfig->timerInstance == (TimerTypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080074e0": "update_timer_configuration_080074e0",
                "htim": "timerConfig",
                "Instance": "timerInstance",
                "TIM_TypeDef_conflict": "TimerTypeDef"
            },
            "calling": [
                "HAL_TIM_OC_MspDeInit",
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007544": {
            "entrypoint": "0x08007544",
            "current_name": "get_timer_ir_qn_08007544",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerIRQn_08007544(TIM_TypeDef_conflict *timer)\n\n{\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (timer == (TIM_TypeDef_conflict *)0x40000400) {\n    return 0x1d;\n  }\n  if (timer < (TIM_TypeDef_conflict *)0x40000401) {\n    if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n      return 0x1c;\n    }\n  }\n  else {\n    if (timer == (TIM_TypeDef_conflict *)0x40000800) {\n      return 0x1e;\n    }\n    if (timer == (TIM_TypeDef_conflict *)0x40012c00) {\n      return 0x19;\n    }\n  }\n  iprintf(\"TIM: Unknown timerer IRQn\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007544": "get_timer_ir_qn_08007544",
                "tim": "timer"
            },
            "calling": [
                "TimerPulseInit",
                "TimerPulseDeinit"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007594": {
            "entrypoint": "0x08007594",
            "current_name": "identify_timer_instance_08007594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t identifyTimerInstance_08007594(TimerTypeDef *timer)\n\n{\n  if (timer == (TimerTypeDef *)0xffffffff) {\n    return '\\0';\n  }\n  if (timer == (TimerTypeDef *)0x40000400) {\n    return '\\x01';\n  }\n  if (timer < (TimerTypeDef *)0x40000401) {\n    if (timer == (TimerTypeDef *)0x40000000) {\n      return '\\x01';\n    }\n  }\n  else {\n    if (timer == (TimerTypeDef *)0x40000800) {\n      return '\\x01';\n    }\n    if (timer == (TimerTypeDef *)0x40012c00) {\n      return '\\x02';\n    }\n  }\n  iprintf(\"TIM: Unknown timerer instance\");\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08007594": "identify_timer_instance_08007594",
                "tim": "timer",
                "TIM_TypeDef_conflict": "TimerTypeDef"
            },
            "calling": [
                "getTimerClkFreq"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080075dc": {
            "entrypoint": "0x080075dc",
            "current_name": "get_timer_clock_frequency_080075dc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerClockFrequency_080075dc(TIM_TypeDef_conflict *timer)\n\n{\n  uint32_t apb2ClockDivider;\n  uint8_t timerClockSource;\n  uint32_t timerFrequency;\n  uint32_t apb1ClockDivider;\n  uint32_t flashLatency;\n  RCC_ClkInitTypeDef_conflict rccClockConfig;\n  \n  rccClockConfig.ClockType = 0;\n  rccClockConfig.SYSCLKSource = 0;\n  rccClockConfig.AHBCLKDivider = 0;\n  rccClockConfig.APB1CLKDivider = 0;\n  rccClockConfig.APB2CLKDivider = 0;\n  flashLatency = 0;\n  HAL_RCC_GetClockConfig(&rccClockConfig,&flashLatency);\n  timerClockSource = getTimerClkSrc(timer);\n  apb2ClockDivider = rccClockConfig.APB2CLKDivider;\n  apb1ClockDivider = rccClockConfig.APB1CLKDivider;\n  if (timerClockSource == '\\x01') {\n    timerFrequency = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timerClockSource == '\\x02') {\n    timerFrequency = HAL_RCC_GetPCLK2Freq();\n    apb1ClockDivider = apb2ClockDivider;\n  }\n  else {\n    iprintf(\"TIM: Unknown clock source\");\n    timerFrequency = 0;\n    apb1ClockDivider = 0;\n  }\n  if (apb1ClockDivider != 0x500) {\n    if (apb1ClockDivider < 0x501) {\n      if (apb1ClockDivider != 0x400) {\n        return timerFrequency;\n      }\n    }\n    else if ((apb1ClockDivider != 0x600) && (apb1ClockDivider != 0x700)) {\n      return timerFrequency;\n    }\n  }\n  return timerFrequency << 1;\n}\n\n",
            "renaming": {
                "FUN_080075dc": "get_timer_clock_frequency_080075dc",
                "tim": "timer",
                "uVar1": "apb2ClockDivider",
                "uVar2": "timerClockSource",
                "uVar3": "timerFrequency",
                "uVar4": "apb1ClockDivider",
                "pFLatency": "flashLatency",
                "clkconfig": "rccClockConfig"
            },
            "calling": [
                "TimerPulseInit",
                "pwm_start"
            ],
            "called": [
                "getTimerClkSrc",
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK2Freq",
                "iprintf",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007648": {
            "entrypoint": "0x08007648",
            "current_name": "initialize_timer_08007648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08007648(stimer_t_conflict *timerObject,uint16_t timerPeriod,uint16_t timerPulseWidth,\n                 _func_void_stimer_t_ptr_uint32_t_conflict *interruptHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timerClkFreq;\n  TIM_HandleTypeDef_conflict *timHandle;\n  TIM_HandleTypeDef_conflict *timerHandle;\n  TIM_OC_InitTypeDef ocConfig;\n  \n  ocConfig.OCMode = 0;\n  ocConfig.Pulse = 0;\n  ocConfig.OCPolarity = 0;\n  ocConfig.OCNPolarity = 0;\n  ocConfig.OCFastMode = 0;\n  ocConfig.OCIdleState = 0;\n  ocConfig.OCNIdleState = 0;\n  timerHandle = &timerObject->timHandle;\n  timerObject->timer = (TIM_TypeDef_conflict *)0x40000000;\n  (timerObject->timHandle).Instance = (TIM_TypeDef_conflict *)0x40000000;\n  (timerObject->timHandle).Init.Period = (uint)timerPeriod;\n  timerClkFreq = getTimerClkFreq((TIM_TypeDef_conflict *)0x40000000);\n  (timerObject->timHandle).Init.Prescaler = timerClkFreq / 1000000 - 1;\n  (timerObject->timHandle).Init.ClockDivision = 0;\n  (timerObject->timHandle).Init.CounterMode = 0;\n  (timerObject->timHandle).Init.RepetitionCounter = 0;\n  timerObject->interruptHandleOC = interruptHandle;\n  ocConfig.OCMode = 0;\n  ocConfig.OCPolarity = 0;\n  ocConfig.OCFastMode = 0;\n  ocConfig.OCNPolarity = 0;\n  ocConfig.OCIdleState = 0;\n  ocConfig.OCNIdleState = 0;\n  ocConfig.Pulse = (uint)timerPulseWidth;\n  timerClkFreq = getTimerIrq(timerObject->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timerClkFreq,0xe,0);\n  timerClkFreq = getTimerIrq(timerObject->timer);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timerClkFreq);\n  status = HAL_TIM_OC_Init(timerHandle);\n  if ((status == HAL_OK) && (status = HAL_TIM_OC_ConfigChannel(timerHandle,&ocConfig,0), status == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(timerHandle,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007648": "initialize_timer_08007648",
                "obj": "timerObject",
                "period": "timerPeriod",
                "pulseWidth": "timerPulseWidth",
                "irqHandle": "interruptHandle",
                "HVar1": "status",
                "uVar2": "timerClkFreq",
                "handle": "timHandle",
                "htim": "timerHandle",
                "sConfig": "ocConfig"
            },
            "calling": [
                "initISR"
            ],
            "called": [
                "HAL_TIM_OC_Start_IT",
                "getTimerIrq",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080076e0": {
            "entrypoint": "0x080076e0",
            "current_name": "disable_timer_interrupt_080076e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerInterrupt_080076e0(stimer_t_conflict *timerObject)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t irqNumber;\n  TIM_HandleTypeDef_conflict *timerHandle;\n  \n  timerObject->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  irqNumber = getTimerIrq(timerObject->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)irqNumber);\n  status = HAL_TIM_OC_DeInit(&timerObject->timerHandle);\n  if (status == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&timerObject->timerHandle,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080076e0": "disable_timer_interrupt_080076e0",
                "obj": "timerObject",
                "HVar1": "status",
                "uVar2": "irqNumber",
                "handle": "timerHandle"
            },
            "calling": [
                "finISR"
            ],
            "called": [
                "HAL_TIM_OC_Stop_IT",
                "getTimerIrq",
                "HAL_TIM_OC_DeInit",
                "HAL_NVIC_DisableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007708": {
            "entrypoint": "0x08007708",
            "current_name": "initialize_timer_08007708",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08007708(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  timer_enable_clock(timerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007708": "initialize_timer_08007708",
                "htim": "timerHandle"
            },
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "called": [
                "timer_enable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007710": {
            "entrypoint": "0x08007710",
            "current_name": "disable_timer_clock_08007710",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_08007710(TIM_HandleTypeDef_conflict *timer_handle)\n\n{\n  disable_timer_clock_08007710(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_timer_clock"
            },
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007718": {
            "entrypoint": "0x08007718",
            "current_name": "extract_timer_from_handle_08007718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nextracted_timer * extract_timer_from_handle_08007718(timer_handle *handle)\n\n{\n  return (extracted_timer *)&handle[-1].timer_lock;\n}\n\n",
            "renaming": {
                "FUN_08007718": "extract_timer_from_handle_08007718",
                "TIM_HandleTypeDef_conflict": "timer_handle",
                "stimer_t_conflict": "extracted_timer",
                "htim": "handle",
                "Lock": "timer_lock"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800771c": {
            "entrypoint": "0x0800771c",
            "current_name": "handle_timer_interrupt_0800771c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800771c(TIM_HandleTypeDef_conflict *timer)\n\n{\n  stimer_t_conflict *timerObject;\n  stimer_t_conflict *tempObject;\n  \n  timerObject = get_timer_tempObject(timer);\n  if ((timerObject->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) &&\n     (timer->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timerObject->irqHandleOC)(timerObject,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timer",
                "psVar1": "timerObject",
                "obj": "tempObject"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007736": {
            "entrypoint": "0x08007736",
            "current_name": "handle_timer_interrupt_08007736",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08007736(TIM_HandleTypeDef_conflict *timerHandle)\n\n{\n  stimer_t_conflict *timerObject;\n  stimer_t_conflict *object;\n  \n  timerObject = get_timer_object(timerHandle);\n  if (timerObject->irqHandle != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*timerObject->irqHandle)(timerObject);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007736": "handle_timer_interrupt_08007736",
                "htim": "timerHandle",
                "psVar1": "timerObject",
                "obj": "object"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007744": {
            "entrypoint": "0x08007744",
            "current_name": "get_timer_counter_08007744",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerCounter_08007744(stimer_t_conflict *timerObject)\n\n{\n  return ((timerObject->handle).Instance)->counterValue;\n}\n\n",
            "renaming": {
                "FUN_08007744": "get_timer_counter_08007744",
                "obj": "timerObject",
                "CNT": "counterValue"
            },
            "calling": [
                "ServoIrqHandle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800774a": {
            "entrypoint": "0x0800774a",
            "current_name": "set_timer_value_0800774a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setTimerValue_0800774a(stimer_t_conflict *timerConfig,uint32_t newValue)\n\n{\n  ((timerConfig->handle).Instance)->CNT = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800774a": "set_timer_value_0800774a",
                "obj": "timerConfig",
                "value": "newValue"
            },
            "calling": [
                "ServoIrqHandle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007750": {
            "entrypoint": "0x08007750",
            "current_name": "set_timer_channel_value_08007750",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setTimerChannelValue_08007750(stimer_t_conflict *timerObject,uint32_t channelIndex,uint32_t channelValue)\n\n{\n  (&((timerObject->handle).Instance)->CCR1)[channelIndex] = channelValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007750": "set_timer_channel_value_08007750",
                "obj": "timerObject",
                "channel": "channelIndex",
                "value": "channelValue"
            },
            "calling": [
                "ServoIrqHandle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007760": {
            "entrypoint": "0x08007760",
            "current_name": "handle_timer_interrupt_08007760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08007760(void)\n\n{\n  if (timerHandles[0] != (Timer_HandleTypeDef *)0x0) {\n    handleTimerIRQ(timerHandles[0]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007760": "handle_timer_interrupt_08007760",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef_conflict": "Timer_HandleTypeDef",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007774": {
            "entrypoint": "0x08007774",
            "current_name": "handle_tim_interrupt_08007774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupt_08007774(void)\n\n{\n  if (timerHandles[1] != (TimHandleConflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007774": "handle_tim_interrupt_08007774",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef_conflict": "TimHandleConflict"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007788": {
            "entrypoint": "0x08007788",
            "current_name": "handle_timer_irq_08007788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08007788(void)\n\n{\n  if (timerHandles[2] != (TimerHandleConflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007788": "handle_timer_irq_08007788",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800779c": {
            "entrypoint": "0x0800779c",
            "current_name": "handle_timer_interrupt_0800779c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800779c(void)\n\n{\n  if (timerHandles[3] != (TimerHandleConflict *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080077b0": {
            "entrypoint": "0x080077b0",
            "current_name": "initialize_i2_c_080077b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_080077b0(i2c_t_conflict *i2c,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                 uint32_t ownAddress,uint8_t master)\n\n{\n  void *a;\n  I2C_TypeDef_conflict *peripheralSDA;\n  void *b;\n  I2C_TypeDef_conflict *peripheralSCL;\n  I2C_TypeDef_conflict *i2cPeriphMerged;\n  GPIO_TypeDef *portClock;\n  GPIO_TypeDef *sclPort;\n  uint32_t function1;\n  uint32_t function2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_17;\n  uint32_t tmpreg_18;\n  uint32_t tmpreg_19;\n  uint32_t tmpreg_20;\n  uint32_t tmpreg_21;\n  uint32_t tmpreg_22;\n  uint32_t tmpreg_23;\n  uint32_t tmpreg_24;\n  uint32_t tmpreg_25;\n  uint32_t tmpreg_26;\n  uint32_t tmpreg_27;\n  uint32_t tmpreg_28;\n  uint32_t tmpreg_29;\n  I2C_HandleTypeDef_conflict *handle;\n  I2C_HandleTypeDef_conflict *hi2c;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_16;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (i2c != (i2c_t_conflict *)0x0) {\n    handle = &i2c->hi2c;\n    a = pinmap_peripheral(i2c->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n    b = pinmap_peripheral(i2c->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(\"ERROR: at least one I2C pin has no peripheral\\n\");\n    }\n    else {\n      i2cPeriphMerged = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      i2c->i2c = i2cPeriphMerged;\n      if (i2cPeriphMerged == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(\"ERROR: I2C pins mismatch\\n\");\n      }\n      else {\n        if (i2cPeriphMerged == (I2C_TypeDef_conflict *)0x40005400) {\n          _DAT_4002101c = _DAT_4002101c | 0x200000;\n          _DAT_40021010 = _DAT_40021010 & 0xffdfffff;\n          i2c->irq = I2C1_EV_IRQn;\n          i2c->irqER = I2C1_ER_IRQn;\n          i2c_hi2cs = handle;\n        }\n        if (i2c->i2c == (I2C_TypeDef_conflict *)0x40005800) {\n          _DAT_4002101c = _DAT_4002101c | 0x400000;\n          _DAT_40021010 = _DAT_40021010 & 0xffbfffff;\n          i2c->irq = I2C2_EV_IRQn;\n          i2c->irqER = I2C2_ER_IRQn;\n          I2C2_ER_IRQHandler::hi2c = handle;\n        }\n        portClock = set_GPIO_Port_Clock((uint)((int)i2c->scl << 0x18) >> 0x1c);\n        sclPort = (GPIO_TypeDef *)(int)i2c->scl;\n        gpioInitStruct.Pin = 1 << ((uint)sclPort & 0xf) & 0xffff;\n        function1 = pinmap_function(i2c->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        function2 = pinmap_function(i2c->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        gpioInitStruct.Mode = (function1 >> 3 & 1) << 4 | function2 & 7;\n        gpioInitStruct.Speed = 3;\n        function1 = pinmap_function(i2c->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        gpioInitStruct.Pull = (function1 << 0x1a) >> 0x1e;\n        function1 = pinmap_function(i2c->scl,(PinMap_conflict *)&PinMap_I2C_SCL);\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((function1 << 0x11) >> 0x19) {\n        case 1:\n          tmpreg_26 = tmpreg_26 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_26 = tmpreg_26 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_26 = tmpreg_26 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_26 = tmpreg_26 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_26 = tmpreg_26 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_26 = tmpreg_26 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_26 = tmpreg_26 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_26 = tmpreg_26 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_26 = tmpreg_26 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_3 = tmpreg_26 & 0xffffffcf;\n          tmpreg_26 = tmpreg_3 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_4 = tmpreg_26 & 0xffffffcf;\n          tmpreg_26 = tmpreg_4 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_26 = tmpreg_26 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_5 = tmpreg_26 & 0xffffff3f;\n          tmpreg_26 = tmpreg_5 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_6 = tmpreg_26 & 0xffffff3f;\n          tmpreg_26 = tmpreg_6 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_26 = tmpreg_26 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_7 = tmpreg_26 & 0xfffffcff;\n          tmpreg_26 = tmpreg_7 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_8 = tmpreg_26 & 0xfffffcff;\n          tmpreg_26 = tmpreg_8 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_9 = tmpreg_26 & 0xfffffcff;\n          tmpreg_26 = tmpreg_9 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_26 = tmpreg_26 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_10 = tmpreg_26 & 0xfffff3ff;\n          tmpreg_26 = tmpreg_10 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_11 = tmpreg_26 & 0xfffff3ff;\n          tmpreg_26 = tmpreg_11 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_26 = tmpreg_26 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_26 = tmpreg_26 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_26 = tmpreg_26 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_26 = tmpreg_26 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_12 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_12;\n          break;\n        case 0x22:\n          tmpreg_13 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_13 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_14 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_14 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_15 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_15 | 0x4000000;\n        }\n        HAL_GPIO_Init(portClock,&gpioInitStruct);\n        portClock = set_GPIO_Port_Clock((uint)((int)i2c->sda << 0x18) >> 0x1c);\n        gpioInitStruct.Pin = 1 << ((int)i2c->sda & 0xfU) & 0xffff;\n        function1 = pinmap_function(i2c->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        function2 = pinmap_function(i2c->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        gpioInitStruct.Mode = (function1 >> 3 & 1) << 4 | function2 & 7;\n        gpioInitStruct.Speed = 3;\n        function1 = pinmap_function(i2c->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        gpioInitStruct.Pull = (function1 << 0x1a) >> 0x1e;\n        function1 = pinmap_function(i2c->sda,(PinMap_conflict *)&PinMap_I2C_SDA);\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((function1 << 0x11) >> 0x19) {\n        case 1:\n          tmpreg_26 = tmpreg_26 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_26 = tmpreg_26 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_26 = tmpreg_26 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_26 = tmpreg_26 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_26 = tmpreg_26 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_26 = tmpreg_26 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_26 = tmpreg_26 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_26 = tmpreg_26 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_26 = tmpreg_26 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_17 = tmpreg_26 & 0xffffffcf;\n          tmpreg_26 = tmpreg_17 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_18 = tmpreg_26 & 0xffffffcf;\n          tmpreg_26 = tmpreg_18 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_26 = tmpreg_26 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_19 = tmpreg_26 & 0xffffff3f;\n          tmpreg_26 = tmpreg_19 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_20 = tmpreg_26 & 0xffffff3f;\n          tmpreg_26 = tmpreg_20 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_26 = tmpreg_26 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_21 = tmpreg_26 & 0xfffffcff;\n          tmpreg_26 = tmpreg_21 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_22 = tmpreg_26 & 0xfffffcff;\n          tmpreg_26 = tmpreg_22 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_23 = tmpreg_26 & 0xfffffcff;\n          tmpreg_26 = tmpreg_23 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_26 = tmpreg_26 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_24 = tmpreg_26 & 0xfffff3ff;\n          tmpreg_26 = tmpreg_24 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_25 = tmpreg_26 & 0xfffff3ff;\n          tmpreg_26 = tmpreg_25 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_26 = tmpreg_26 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_26 = tmpreg_26 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_26 = tmpreg_26 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_26 = tmpreg_26 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_26 = tmpreg_26 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_27 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_27 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_28 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_28 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_29 = tmpreg_26 & 0xf8ffffff;\n          tmpreg_26 = tmpreg_29 | 0x4000000;\n        }\n        HAL_GPIO_Init(portClock,&gpioInitStruct);\n        (i2c->hi2c).Instance = i2c->i2c;\n        (i2c->hi2c).Init.ClockSpeed = timing;\n        (i2c->hi2c).Init.DutyCycle = 0;\n        (i2c->hi2c).Init.OwnAddress1 = ownAddress;\n        (i2c->hi2c).Init.OwnAddress2 = 0xff;\n        (i2c->hi2c).Init.AddressingMode = addressingMode;\n        (i2c->hi2c).Init.DualAddressMode = 0;\n        (i2c->hi2c).Init.GeneralCallMode = 0;\n        (i2c->hi2c).Init.NoStretchMode = 0;\n        (i2c->hi2c).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(i2c->irq,0,1);\n        HAL_NVIC_EnableIRQ(i2c->irq);\n        HAL_NVIC_SetPriority(i2c->irqER,0,1);\n        HAL_NVIC_EnableIRQ(i2c->irqER);\n        HAL_I2C_Init(handle);\n        i2c->isMaster = master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080077b0": "initialize_i2_c_080077b0",
                "obj": "i2c",
                "i2c_sda": "peripheralSDA",
                "i2c_scl": "peripheralSCL",
                "pIVar1": "i2cPeriphMerged",
                "pGVar2": "portClock",
                "port": "sclPort",
                "uVar3": "function1",
                "uVar4": "function2",
                "hi2c": "handle",
                "handle": "hi2c",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "pinmap_function",
                "pinmap_peripheral",
                "pinmap_merge_peripheral",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_GPIO_Init",
                "iprintf",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e74": {
            "entrypoint": "0x08007e74",
            "current_name": "transmit_data_over_i2_c_08007e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict\ntransmitDataOverI2C_08007e74(i2c_t_conflict *i2cObject,uint8_t deviceAddress,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  HAL_StatusTypeDef_conflict transmitStatus;\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t elapsedTime;\n  uint timeout;\n  i2c_status_e_conflict result;\n  I2C_HandleTypeDef_conflict *i2cHandle;\n  \n  startTime = HAL_GetTick();\n  timeout = 0;\n  result = I2C_ERROR;\n  do {\n    i2cHandle = &i2cObject->handle;\n    transmitStatus = HAL_I2C_Master_Transmit_IT(i2cHandle,(ushort)deviceAddress,dataBuffer,dataSize);\n    if (transmitStatus == HAL_OK) {\n      result = I2C_OK;\n      while ((i2cState = HAL_I2C_GetState(i2cHandle), i2cState != HAL_I2C_STATE_READY && (result == I2C_OK))) {\n        elapsedTime = HAL_GetTick();\n        timeout = elapsedTime - startTime;\n        if (timeout < 0x65) {\n          elapsedTime = HAL_I2C_GetError(i2cHandle);\n          if (elapsedTime != 0) {\n            result = I2C_ERROR;\n          }\n        }\n        else {\n          result = I2C_TIMEOUT;\n        }\n      }\n    }\n    elapsedTime = HAL_I2C_GetError(i2cHandle);\n  } while ((elapsedTime == 4) && (timeout < 100));\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08007e74": "transmit_data_over_i2_c_08007e74",
                "obj": "i2cObject",
                "dev_address": "deviceAddress",
                "data": "dataBuffer",
                "size": "dataSize",
                "HVar1": "i2cState",
                "HVar2": "transmitStatus",
                "uVar3": "startTime",
                "tickstart": "currentTime",
                "uVar4": "elapsedTime",
                "uVar5": "timeout",
                "iVar6": "result",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "endTransmission"
            ],
            "called": [
                "HAL_I2C_GetError",
                "HAL_I2C_GetState",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ede": {
            "entrypoint": "0x08007ede",
            "current_name": "copy_data_to_i2_c_buffer_08007ede",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict copyDataToI2CBuffer_08007ede(i2c_t_conflict *i2cObject,uint8_t *sourceData,uint16_t dataSize)\n\n{\n  uint index;\n  \n  if (0x20 < dataSize) {\n    return I2C_ERROR;\n  }\n  for (index = 0; index < dataSize; index = index + 1 & 0xff) {\n    i2cObject->i2cTxRxBuffer[index] = sourceData[index];\n    i2cObject->i2cTxRxBufferSize = i2cObject->i2cTxRxBufferSize + '\\x01';\n  }\n  return I2C_OK;\n}\n\n",
            "renaming": {
                "FUN_08007ede": "copy_data_to_i2_c_buffer_08007ede",
                "obj": "i2cObject",
                "data": "sourceData",
                "size": "dataSize",
                "uVar1": "index"
            },
            "calling": [
                "write",
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f0e": {
            "entrypoint": "0x08007f0e",
            "current_name": "receive_data_from_i2_c_08007f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict\nreceiveDataFromI2C_08007f0e(i2c_t_conflict *i2cController,uint8_t deviceAddress,uint8_t *receivedData,uint16_t dataSize)\n\n{\n  HAL_I2C_StateTypeDef_conflict i2cState;\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  uint32_t elapsedTime;\n  uint timeout;\n  i2c_status_e_conflict result;\n  I2C_HandleTypeDef_conflict *i2cHandle;\n  \n  startTick = HAL_GetTick();\n  timeout = 0;\n  result = I2C_ERROR;\n  do {\n    i2cHandle = &i2cController->handle;\n    status = HAL_I2C_Master_Receive_IT(i2cHandle,(ushort)deviceAddress,receivedData,dataSize);\n    if (status == HAL_OK) {\n      result = I2C_OK;\n      while ((i2cState = HAL_I2C_GetState(i2cHandle), i2cState != HAL_I2C_STATE_READY && (result == I2C_OK))) {\n        elapsedTime = HAL_GetTick();\n        timeout = elapsedTime - startTick;\n        if (timeout < 0x65) {\n          elapsedTime = HAL_I2C_GetError(i2cHandle);\n          if (elapsedTime != 0) {\n            result = I2C_ERROR;\n          }\n        }\n        else {\n          result = I2C_TIMEOUT;\n        }\n      }\n    }\n    elapsedTime = HAL_I2C_GetError(i2cHandle);\n  } while ((elapsedTime == 4) && (timeout < 100));\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08007f0e": "receive_data_from_i2_c_08007f0e",
                "obj": "i2cController",
                "dev_address": "deviceAddress",
                "data": "receivedData",
                "size": "dataSize",
                "HVar1": "i2cState",
                "HVar2": "status",
                "uVar3": "startTick",
                "tickstart": "currentTick",
                "uVar4": "elapsedTime",
                "uVar5": "timeout",
                "iVar6": "result",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "HAL_I2C_GetError",
                "HAL_I2C_GetState",
                "HAL_GetTick",
                "HAL_I2C_Master_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f78": {
            "entrypoint": "0x08007f78",
            "current_name": "get_i2c_t_conflict_pointer_08007f78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nconflict_t * get_i2c_t_conflict_pointer_08007f78(I2C_HandleTypeDef_conflict *i2c_handle)\n\n{\n  return (conflict_t *)&i2c_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_08007f78": "get_i2c_t_conflict_pointer_08007f78",
                "hi2c": "i2c_handle",
                "i2c_t_conflict": "conflict_t",
                "EventCount": "event_count"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f7c": {
            "entrypoint": "0x08007f7c",
            "current_name": "configure_i2_c_08007f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureI2C_08007f7c(i2c_t_conflict *i2cObject,_func_void_uint8_t_ptr_int *receiveHandler)\n\n{\n  if (i2cObject != (i2c_t_conflict *)0x0) {\n    if (receiveHandler != (_func_void_uint8_t_ptr_int *)0x0) {\n      i2cObject->onSlaveReceiveHandler = receiveHandler;\n      HAL_I2C_EnableListen_IT(&i2cObject->handle);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f7c": "configure_i2_c_08007f7c",
                "obj": "i2cObject",
                "function": "receiveHandler",
                "i2c_onSlaveReceive": "onSlaveReceiveHandler"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f8e": {
            "entrypoint": "0x08007f8e",
            "current_name": "configure_i2_c_interrupt_08007f8e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureI2CInterrupt_08007f8e(i2c_t_conflict *i2cConfiguration,_func_void *interruptFunction)\n\n{\n  if (i2cConfiguration != (i2c_t_conflict *)0x0) {\n    if (interruptFunction != (_func_void *)0x0) {\n      i2cConfiguration->onSlaveTransmitCallback = interruptFunction;\n      HAL_I2C_EnableListen_IT(&i2cConfiguration->i2cHandle);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f8e": "configure_i2_c_interrupt_08007f8e",
                "obj": "i2cConfiguration",
                "function": "interruptFunction",
                "i2c_onSlaveTransmit": "onSlaveTransmitCallback",
                "handle": "i2cHandle"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007fa0": {
            "entrypoint": "0x08007fa0",
            "current_name": "FUNC_08007fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007fa0(I2C_HandleTypeDef_conflict *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t_conflict *piVar1;\n  i2c_t_conflict *obj;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode == (hi2c->Init).OwnAddress1) {\n    if (TransferDirection == '\\0') {\n      piVar1->i2cTxRxBufferSize = '\\0';\n      piVar1->slaveMode = '\\0';\n      if (piVar1->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*piVar1->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1->i2cTxRxBuffer,(ushort)piVar1->i2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007fa0": "FUNC_08007fa0"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007ff0": {
            "entrypoint": "0x08007ff0",
            "current_name": "enable_slave_mode_08007ff0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableSlaveMode_08007ff0(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  i2c_t_conflict *i2cObject;\n  i2c_t_conflict *i2cObject;\n  uint remainingBufferLength;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (((i2cObject->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObject->slaveMode == '\\x01')) &&\n     (remainingBufferLength = 0x20 - *(byte *)&(i2cObject->handle).XferSize & 0xff, remainingBufferLength != 0)) {\n    (*i2cObject->i2c_onSlaveReceive)(i2cObject->i2cTxRxBuffer,remainingBufferLength);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ff0": "enable_slave_mode_08007ff0",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "uVar2": "remainingBufferLength"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008020": {
            "entrypoint": "0x08008020",
            "current_name": "enable_listen_interrupt_08008020",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08008020(I2C_HandleTypeDef_conflict *i2cHandle)\n\n{\n  i2c_t_conflict *i2cObject;\n  i2c_t_conflict *i2cTempObject;\n  \n  i2cObject = get_i2c_i2cTempObject(i2cHandle);\n  if (i2cObject->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008020": "enable_listen_interrupt_08008020",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cTempObject"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008038": {
            "entrypoint": "0x08008038",
            "current_name": "handle_i2_c_event_irq_08008038",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEventIRQ_08008038(void)\n\n{\n  handleI2CEvent(handlePtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008038": "handle_i2_c_event_irq_08008038",
                "i2c_handles": "handlePtr",
                "HAL_I2C_EV_IRQHandler": "handleI2CEvent"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008048": {
            "entrypoint": "0x08008048",
            "current_name": "handle_i2_c_error_interrupt_08008048",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08008048(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008048": "handle_i2_c_error_interrupt_08008048"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008058": {
            "entrypoint": "0x08008058",
            "current_name": "handle_i2_c2_er_event_08008058",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C2_ER_event_08008058(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_error_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008058": "handle_i2_c2_er_event_08008058",
                "I2C2_ER_IRQHandler::handle": "i2c_error_handler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008068": {
            "entrypoint": "0x08008068",
            "current_name": "handle_i2_c2_error_interrupt_08008068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C2ErrorInterrupt_08008068(void)\n\n{\n  handleErrorInterrupt(handleI2C2Error);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008068": "handle_i2_c2_error_interrupt_08008068",
                "I2C2_ER_IRQHandler": "handleI2C2Error",
                "HAL_I2C_ER_IRQHandler": "handleErrorInterrupt",
                "I2C2_ER_IRQHandler::handle": "handleI2C2Error"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008078": {
            "entrypoint": "0x08008078",
            "current_name": "initialize_serial_port_08008078",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialPort_08008078(SerialPort *port)\n\n{\n  void *a;\n  USART_TypeDef *uart_transmit;\n  void *b;\n  USART_TypeDef *uart_receive;\n  USART_TypeDef *merged_peripheral;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_function;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_16;\n  UART_HandleTypeDef *uart_handle;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (port != (SerialPort *)0x0) {\n    a = pinmap_peripheral(port->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(port->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      merged_peripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      port->uart = merged_peripheral;\n      if (merged_peripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (merged_peripheral == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          port->index = '\\0';\n          port->irq = USART1_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          port->index = '\\x01';\n          port->irq = USART2_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          port->index = '\\x02';\n          port->irq = USART3_IRQn;\n        }\n        gpio_port = set_GPIO_Port_Clock((uint)((int)port->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(port->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpio_init_struct.Pin = 1 << (port->pin_rx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pin_function << 0x11) >> 0x19) {\n        case 1:\n          tmpreg_13 = tmpreg_13 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_13 = tmpreg_13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_13 = tmpreg_13 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_13 = tmpreg_13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_13 = tmpreg_13 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_13 = tmpreg_13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_13 = tmpreg_13 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_13 = tmpreg_13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_13 = tmpreg_13 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_4 = tmpreg_13 & 0xffffffcf;\n          tmpreg_13 = tmpreg_4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_5 = tmpreg_13 & 0xffffffcf;\n          tmpreg_13 = tmpreg_5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_13 = tmpreg_13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_6 = tmpreg_13 & 0xffffff3f;\n          tmpreg_13 = tmpreg_6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_7 = tmpreg_13 & 0xffffff3f;\n          tmpreg_13 = tmpreg_7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_13 = tmpreg_13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_8 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_9 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_10 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_13 = tmpreg_13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_11 = tmpreg_13 & 0xfffff3ff;\n          tmpreg_13 = tmpreg_11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_12 = tmpreg_13 & 0xfffff3ff;\n          tmpreg_13 = tmpreg_12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_13 = tmpreg_13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_13 = tmpreg_13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_13 = tmpreg_13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_13 = tmpreg_13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_13 = tmpreg_13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_14 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_15 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_16 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_16 | 0x4000000;\n        }\n        gpio_init_struct.Speed = 3;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        gpio_port = set_GPIO_Port_Clock((uint)((int)port->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(port->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpio_init_struct.Pin = 1 << (port->pin_tx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        uart_handlers[port->index] = &port->handle;\n        (port->handle).Instance = port->uart;\n        (port->handle).Init.BaudRate = port->baudrate;\n        (port->handle).Init.WordLength = port->databits;\n        (port->handle).Init.StopBits = port->stopbits;\n        (port->handle).Init.Parity = port->parity;\n        (port->handle).Init.Mode = 0xc;\n        (port->handle).Init.HwFlowCtl = 0;\n        (port->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&port->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008078": "initialize_serial_port_08008078",
                "serial_t": "SerialPort",
                "obj": "port",
                "uart_tx": "uart_transmit",
                "uart_rx": "uart_receive",
                "pUVar1": "merged_peripheral",
                "pGVar2": "gpio_port",
                "port": "gpio_port",
                "uVar3": "pin_function",
                "huart": "uart_handle",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "uart_debug_init",
                "begin"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_peripheral",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080084b0": {
            "entrypoint": "0x080084b0",
            "current_name": "initialize_serial_debug_080084b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_serial_debug_080084b0(void)\n\n{\n  void *peripheral_address;\n  \n  peripheral_address = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral_address != (void *)0x0) {\n    peripheral_address = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n    debug_serial.pin_rx = pinmap_pin(peripheral_address,(PinMap_conflict *)&PinMap_UART_RX);\n    debug_serial.pin_tx = PA_2;\n    debug_serial.baudrate = 0x2580;\n    debug_serial.parity = 0;\n    debug_serial.databits = 0;\n    debug_serial.stopbits = 0;\n    initialize_uart(&debug_serial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080084b0": "initialize_serial_debug_080084b0",
                "pvVar1": "peripheral_address",
                "serial_debug": "debug_serial",
                "uart_init": "initialize_uart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "uart_init",
                "pinmap_pin",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008500": {
            "entrypoint": "0x08008500",
            "current_name": "transmit_data_08008500",
            "code": "\n/* WARNING: Unknown calling convention */\n\ndataSize_t transmitData_08008500(uint8_t *dataBuffer,uint32_t dataSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  uint32_t tickstart;\n  void *uartPeriph;\n  USART_TypeDef *uartInstance;\n  uint32_t currentTime;\n  uint uartIndex;\n  \n  startTime = HAL_GetTick();\n  uartPeriph = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (uartPeriph == (void *)0x0) {\n    return 0;\n  }\n  uartIndex = 0;\n  while ((uartIndex < 5 &&\n         ((uart_handlers[uartIndex] == (UART_HandleTypeDef *)0x0 ||\n          (uartInstance = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[uartIndex]->Instance != uartInstance))))) {\n    uartIndex = uartIndex + 1 & 0xff;\n  }\n  if (4 < uartIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    uartIndex = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[uartIndex],dataBuffer,(uint16_t)dataSize,1000);\n    if (status == HAL_OK) {\n      return dataSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008500": "transmit_data_08008500",
                "data": "dataBuffer",
                "size": "dataSize",
                "HVar1": "status",
                "uVar2": "startTime",
                "pvVar3": "uartPeriph",
                "pUVar4": "uartInstance",
                "uVar5": "currentTime",
                "uVar6": "uartIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_UART_Transmit",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085b8": {
            "entrypoint": "0x080085b8",
            "current_name": "is_uart_in_transmission_080085b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t is_uart_in_transmission_080085b8(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_080085b8": "is_uart_in_transmission_080085b8",
                "obj": "serial_object",
                "HVar1": "uart_state"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085dc": {
            "entrypoint": "0x080085dc",
            "current_name": "check_uart_state_080085dc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_080085dc(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handler_array[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080085dc": "check_uart_state_080085dc",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "uart_handler_array"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008600": {
            "entrypoint": "0x08008600",
            "current_name": "receive_serial_data_08008600",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receive_serial_data_08008600(serial_t *serial_object,uchar *c)\n\n{\n  uint8_t is_active;\n  \n  if (serial_object == (serial_t *)0x0) {\n    return -1;\n  }\n  is_active = is_serial_rx_active(serial_object);\n  if (is_active == '\\0') {\n    *c = serial_object->received_data;\n    receive_data_interrupt(uart_handlers[serial_object->index],&serial_object->received_data,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008600": "receive_serial_data_08008600",
                "obj": "serial_object",
                "uVar1": "is_active",
                "serial_rx_active": "is_serial_rx_active",
                "recv": "received_data",
                "HAL_UART_Receive_IT": "receive_data_interrupt"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800863c": {
            "entrypoint": "0x0800863c",
            "current_name": "initialize_serial_communication_0800863c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_0800863c(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte index;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = serial_rx_active(serialObject);\n    if (rxActive == '\\0') {\n      index = serialObject->index;\n      receiveCallback[index] = serialCallback;\n      receiveCallbackObject[index] = serialObject;\n      setPriority(serialObject->irq,0,1);\n      enableIRQ(serialObject->irq);\n      receiveData(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800863c": "initialize_serial_communication_0800863c",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "index",
                "uVar2": "rxActive",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "receiveCallbackObject",
                "HAL_NVIC_SetPriority": "setPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_UART_Receive_IT": "receiveData"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008694": {
            "entrypoint": "0x08008694",
            "current_name": "initialize_serial_transmission_08008694",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialTransmission_08008694(serial_t *serialObject,_func_int_serial_t_ptr *serialCallback)\n\n{\n  byte indexValue;\n  \n  if (serialObject != (serial_t *)0x0) {\n    indexValue = serialObject->index;\n    tx_serialCallback[indexValue] = serialCallback;\n    tx_serialCallback_serialObject[indexValue] = serialObject;\n    HAL_NVIC_SetPriority(serialObject->irq,0,2);\n    HAL_NVIC_EnableIRQ(serialObject->irq);\n    HAL_UART_Transmit_IT(uart_handlers[serialObject->index],serialObject->tx_buff + serialObject->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008694": "initialize_serial_transmission_08008694",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "indexValue"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080086e8": {
            "entrypoint": "0x080086e8",
            "current_name": "find_uart_handler_index_080086e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_index_080086e8(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080086e8": "find_uart_handler_index_080086e8",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800870c": {
            "entrypoint": "0x0800870c",
            "current_name": "handle_uart_rx_callback_0800870c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_rx_callback_0800870c(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index_byte;\n  uint8_t index;\n  uint index_value;\n  \n  index_byte = uart_index(uart_handle);\n  index_value = (uint)index_byte;\n  if (index_value < 5) {\n    (*rx_callback[index_value])(rx_callback_obj[index_value]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800870c": "handle_uart_rx_callback_0800870c",
                "huart": "uart_handle",
                "bVar1": "index_byte",
                "uVar2": "index_value"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008730": {
            "entrypoint": "0x08008730",
            "current_name": "handle_uart_transmission_08008730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_transmission_08008730(UART_HandleTypeDef *uart_handler)\n\n{\n  byte index;\n  uint8_t byteIndex;\n  int status;\n  serial_t *serial_obj;\n  serial_t *tx_callback_obj;\n  uint unsignedIndex;\n  \n  index = uart_byteIndex(uart_handler);\n  unsignedIndex = (uint)index;\n  tx_callback_obj = tx_callback_serial_obj[unsignedIndex];\n  if ((unsignedIndex < 5) && (status = (*tx_callback[unsignedIndex])(tx_callback_obj), status != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[tx_callback_obj->byteIndex],tx_callback_obj->tx_buff + tx_callback_obj->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008730": "handle_uart_transmission_08008730",
                "huart": "uart_handler",
                "bVar1": "index",
                "index": "byteIndex",
                "iVar3": "status",
                "obj": "serial_obj",
                "psVar4": "tx_callback_obj",
                "uVar2": "unsignedIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800877c": {
            "entrypoint": "0x0800877c",
            "current_name": "initialize_uart_0800877c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_0800877c(UART_HandleTypeDef *UART_handle)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "UART_handle",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080087bc": {
            "entrypoint": "0x080087bc",
            "current_name": "handle_usart1_interrupt_080087bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART1_interrupt_080087bc(void)\n\n{\n  clear_pending_interrupt(interrupt_num);\n  handle_UART_interrupt(UART_handlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080087bc": "handle_usart1_interrupt_080087bc",
                "USART1_IRQn": "interrupt_num",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080087d4": {
            "entrypoint": "0x080087d4",
            "current_name": "handle_usart2_interrupt_080087d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_interrupt_080087d4(void)\n\n{\n  clear_pending_interrupt(USART2_interrupt_number);\n  handle_UART_interrupt(UART_interrupt_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080087d4": "handle_usart2_interrupt_080087d4",
                "USART2_IRQn": "USART2_interrupt_number",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "UART_interrupt_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080087ec": {
            "entrypoint": "0x080087ec",
            "current_name": "handle_usart3_irq_080087ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUSART3IRQ_080087ec(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3Interrupt);\n  if (uartHandlers[2] != (UartHandlerType *)0x0) {\n    HAL_UART_IRQHandler(uartHandlers[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080087ec": "handle_usart3_irq_080087ec",
                "USART3_IRQn": "USART3Interrupt",
                "uart_handlers": "uartHandlers",
                "UART_HandleTypeDef": "UartHandlerType"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008804": {
            "entrypoint": "0x08008804",
            "current_name": "adjust_heap_pointer_08008804",
            "code": "\nvoid * adjustHeapPointer_08008804(intptr_t sizeDelta)\n\n{\n  char *previousHeapEnd;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  previousHeapEnd = _sbrk::heap_end;\n  if (_sbrk::heap_end + sizeDelta <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + sizeDelta;\n    return previousHeapEnd;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008804": "adjust_heap_pointer_08008804",
                "__delta": "sizeDelta",
                "pcVar1": "previousHeapEnd",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008840": {
            "entrypoint": "0x08008840",
            "current_name": "check_file_descriptor_08008840",
            "code": "\nint check_file_descriptor_08008840(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008840": "check_file_descriptor_08008840",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008846": {
            "entrypoint": "0x08008846",
            "current_name": "set_special_flag_08008846",
            "code": "\nint setSpecialFlag_08008846(int fileDescriptor,stat *fileStat)\n\n{\n  *(undefined4 *)((int)&fileStat->deviceNumber + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008846": "set_special_flag_08008846",
                "__fd": "fileDescriptor",
                "__buf": "fileStat",
                "st_dev": "deviceNumber"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008850": {
            "entrypoint": "0x08008850",
            "current_name": "check_file_validity_08008850",
            "code": "\nint check_file_validity_08008850(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08008850": "check_file_validity_08008850",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008854": {
            "entrypoint": "0x08008854",
            "current_name": "get_file_offset_08008854",
            "code": "\n__off_t get_file_offset_08008854(int file_descriptor,__off_t offset,int reference_point)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008854": "get_file_offset_08008854",
                "__fd": "file_descriptor",
                "__offset": "offset",
                "__whence": "reference_point"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008858": {
            "entrypoint": "0x08008858",
            "current_name": "file_processing_function_08008858",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint file_processing_function_08008858(int file_handle,char *data_ptr,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008858": "file_processing_function_08008858",
                "file_UNUSED": "file_handle",
                "ptr_UNUSED": "data_ptr",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800885c": {
            "entrypoint": "0x0800885c",
            "current_name": "uart_debug_write_and_return_size_0800885c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint uart_debug_write_and_return_size_0800885c(int file_descriptor,char *data_buffer,int data_length)\n\n{\n  size_t sVar1;\n  \n  sVar1 = uart_debug_write((uint8_t *)data_buffer,data_length);\n  return sVar1;\n}\n\n",
            "renaming": {
                "FUN_0800885c": "uart_debug_write_and_return_size_0800885c",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_buffer",
                "len": "data_length"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008868": {
            "entrypoint": "0x08008868",
            "current_name": "endless_loop_08008868",
            "code": "\nvoid endlessLoop_08008868(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08008868": "endless_loop_08008868",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800886c": {
            "entrypoint": "0x0800886c",
            "current_name": "set_errno_value_0800886c",
            "code": "\nint setErrnoValue_0800886c(pid_t pid,int signal)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800886c": "set_errno_value_0800886c",
                "__pid": "pid",
                "__sig": "signal"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800887c": {
            "entrypoint": "0x0800887c",
            "current_name": "get_process_id_0800887c",
            "code": "\n\n\n__pid_t get_process_id_0800887c(void)\n\n{\n  process_id 1;\n}\n\n",
            "renaming": {
                "FUN_0800887c": "get_process_id_0800887c",
                "return": "process_id"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008880": {
            "entrypoint": "0x08008880",
            "current_name": "get_pin_value_08008880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_pin_value_08008880(uint32_t pin)\n\n{\n  bool isInRange;\n  PinName_conflict pinName;\n  uint16_t rawValue;\n  uint32_t convertedValue;\n  \n  if (pin < 0xe) {\n    if (pin + 0x2e < 0x3c) {\n      isInRange = true;\n    }\n    else {\n      isInRange = false;\n    }\n  }\n  else {\n    isInRange = pin < 0x3c;\n  }\n  if (isInRange) {\n    if (pin < 0xe) {\n      pin = pin + 0x2e;\n    }\n    pinName = (&digitalPin)[pin];\n  }\n  else {\n    pinName = NC;\n  }\n  if (pinName == NC) {\n    convertedValue = 0;\n  }\n  else {\n    rawValue = adc_read_value(pinName);\n    convertedValue = (uint32_t)rawValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(rawValue >> (0xcU - _readResolution & 0xff));\n      }\n      return convertedValue << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_08008880": "get_pin_value_08008880",
                "ulPin": "pin",
                "bVar1": "isInRange",
                "p": "pinName",
                "uVar2": "rawValue",
                "uVar3": "convertedValue"
            },
            "calling": [
                "loop",
                "reportAnalogCallback"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088e0": {
            "entrypoint": "0x080088e0",
            "current_name": "handle_pin_080088e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handlePin_080088e0(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isPWM;\n  PinName_conflict pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&pinMap)[pinNumber];\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isPWM = pinin_in_pininmapin(pin,(PinMapin_conflict *)&PWM_PinMap);\n    if (isPWM) {\n      isPWM = isPinConfigured(pin,outputPinConfigured);\n      if (!isPWM) {\n        setPinConfigured(pin,outputPinConfigured);\n      }\n      if (writeResolution != 8) {\n        if ((uint)writeResolution < 9) {\n          pinValue = pinValue << (8U - writeResolution & 0xff);\n        }\n        else {\n          pinValue = pinValue >> (writeResolution - 8U & 0xff);\n        }\n      }\n      startPWM(pin,0x3e418,0xff,pinValue,!isPWM);\n    }\n    else {\n      setPinMode(pinNumber,1);\n      if (writeResolution != 8) {\n        if ((uint)writeResolution < 9) {\n          pinValue = pinValue << (8U - writeResolution & 0xff);\n        }\n        else {\n          pinValue = pinValue >> (writeResolution - 8U & 0xff);\n        }\n      }\n      if (pinValue < 0x80) {\n        writeDigital(pinNumber,0);\n      }\n      else {\n        writeDigital(pinNumber,1);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088e0": "handle_pin_080088e0",
                "ulPin": "pinNumber",
                "ulValue": "pinValue",
                "_Var1": "isPWM",
                "p": "pin",
                "digitalPin": "pinMap",
                "NC": "NotConnected",
                "PinMap_PWM": "PWM_PinMap",
                "is_pin_configured": "isPinConfigured",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "set_pin_configured": "setPinConfigured",
                "_writeResolution": "writeResolution",
                "pwm_start": "startPWM",
                "pinMode": "setPinMode",
                "digitalWrite": "writeDigital"
            },
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "called": [
                "digitalWrite",
                "is_pin_configured",
                "pin_in_pinmap",
                "set_pin_configured",
                "pwm_start",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008990": {
            "entrypoint": "0x08008990",
            "current_name": "configure_pin_08008990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08008990(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isConfigured;\n  PinName_conflict pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&pinArray)[pinNumber];\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isConfigured = isPinConfigured(pin,outputPinConfiguredArray);\n    if (isConfigured) {\n      isConfigured = pinin_in_pininmapin(pin,(conflictingPinMap *)&PWMPinMap);\n      if (isConfigured) {\n        stopPWM(pin);\n      }\n      resetPinConfigured(pin,outputPinConfiguredArray);\n    }\n    switch(pinMode) {\n    case 0:\n      initializeDigitalIO(pin,0,0);\n      break;\n    case 1:\n      initializeDigitalIO(pin,1,0);\n      break;\n    case 2:\n      initializeDigitalIO(pin,0,1);\n      break;\n    case 3:\n      initializeDigitalIO(pin,0,2);\n    }\n    setPinConfigured(pin,digitalPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008990": "configure_pin_08008990",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isConfigured",
                "p": "pin",
                "digitalPin": "pinArray",
                "NC": "NotConnected",
                "g_anOutputPinConfigured": "outputPinConfiguredArray",
                "is_pin_configured": "isPinConfigured",
                "PinMap_conflict": "conflictingPinMap",
                "PinMap_PWM": "PWMPinMap",
                "pwm_stop": "stopPWM",
                "reset_pin_configured": "resetPinConfigured",
                "digital_io_init": "initializeDigitalIO",
                "g_digPinConfigured": "digitalPinConfigured",
                "set_pin_configured": "setPinConfigured"
            },
            "calling": [
                "digitalWriteCallback",
                "blinkVersion",
                "attach",
                "setPinModeCallback",
                "analogWrite"
            ],
            "called": [
                "digital_io_init",
                "is_pin_configured",
                "pin_in_pinmap",
                "pwm_stop",
                "set_pin_configured",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a24": {
            "entrypoint": "0x08008a24",
            "current_name": "update_pin_value_08008a24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinValue_08008a24(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConfigurationeDef *gpioPort;\n  PinName_conflict pinConfiguration;\n  uint mappedPin;\n  \n  if (pinNumber < 0x3c) {\n    mappedPin = (uint)(char)(&pinMapping)[pinNumber];\n  }\n  else {\n    mappedPin = 0xffffffff;\n  }\n  if ((mappedPin != 0xffffffff) &&\n     (isConfigured = isPinConfigured((PinName_conflict)mappedPin,configuredPins), isConfigured)) {\n    gpioPort = getGPIOPort((mappedPin << 0x18) >> 0x1c);\n    writeDigitalIO(gpioPort,1 << (mappedPin & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008a24": "update_pin_value_08008a24",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "p": "pinConfiguration",
                "uVar2": "mappedPin",
                "g_digPinConfigured": "configuredPins",
                "digitalPin": "pinMapping",
                "is_pin_configured": "isPinConfigured",
                "get_GPIO_Port": "getGPIOPort",
                "digital_io_write": "writeDigitalIO"
            },
            "calling": [
                "digitalWriteCallback",
                "setPinValueCallback",
                "strobeBlinkPin",
                "ServoIrqHandle",
                "setPinModeCallback",
                "analogWrite"
            ],
            "called": [
                "get_GPIO_Port",
                "is_pin_configured",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a6c": {
            "entrypoint": "0x08008a6c",
            "current_name": "read_digital_pin_value_08008a6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint readDigitalPinValue_08008a6c(uint32_t pinNumber)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinNameeDef *gpioPort;\n  uint32_t readValue;\n  PinName_conflict pinName;\n  uint mappedPinNumber;\n  \n  if (pinNumber < 0x3c) {\n    mappedPinNumber = (uint)(char)(&digitalPinMapping)[pinNumber];\n  }\n  else {\n    mappedPinNumber = 0xffffffff;\n  }\n  if (mappedPinNumber == 0xffffffff) {\n    mappedPinNumber = 0;\n  }\n  else {\n    isConfigured = isPinConfigured((PinName_conflict)mappedPinNumber,pinConfigurations);\n    if (isConfigured) {\n      gpioPort = getGPIOPort((mappedPinNumber << 0x18) >> 0x1c);\n      readValue = readDigitalIO(gpioPort,1 << (mappedPinNumber & 0xf) & 0xffff);\n      mappedPinNumber = readValue & 0xff;\n    }\n    else {\n      mappedPinNumber = 0;\n    }\n  }\n  if (mappedPinNumber != 0) {\n    mappedPinNumber = 1;\n  }\n  return mappedPinNumber;\n}\n\n",
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_value_08008a6c",
                "ulPin": "pinNumber",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "uVar2": "readValue",
                "p": "pinName",
                "uVar3": "mappedPinNumber",
                "digitalPin": "digitalPinMapping",
                "g_digPinConfigured": "pinConfigurations",
                "is_pin_configured": "isPinConfigured",
                "get_GPIO_Port": "getGPIOPort",
                "digital_io_read": "readDigitalIO"
            },
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "called": [
                "get_GPIO_Port",
                "is_pin_configured",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008abc": {
            "entrypoint": "0x08008abc",
            "current_name": "get_current_milliseconds_08008abc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_08008abc(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_08008abc": "get_current_milliseconds_08008abc",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ac4": {
            "entrypoint": "0x08008ac4",
            "current_name": "FUNC_08008ac4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008ac4": "FUNC_08008ac4"
            },
            "calling": [
                "blinkVersion",
                "strobeBlinkPin"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008ac6": {
            "entrypoint": "0x08008ac6",
            "current_name": "update_serial_tail_08008ac6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateSerialTail_08008ac6(serial_t_conflict *serialObject)\n\n{\n  ushort convertedTail;\n  uint16_t maskedTail;\n  int updatedTail;\n  \n  updatedTail = serialObject->tx_tail + 1;\n  convertedTail = (ushort)updatedTail;\n  maskedTail = convertedTail & 0x7f;\n  if (updatedTail == 0) {\n    maskedTail = -(-convertedTail & 0x7f);\n  }\n  serialObject->tx_tail = maskedTail;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008ac6": "update_serial_tail_08008ac6",
                "obj": "serialObject",
                "iVar3": "updatedTail",
                "uVar1": "convertedTail",
                "uVar2": "maskedTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008afa": {
            "entrypoint": "0x08008afa",
            "current_name": "calculate_available_space_08008afa",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialObject) */\n\nint __serialObjectcall HardwareSerial::calculateAvailableSpace_08008afa(HardwareSerial *serialObject)\n\n{\n  return ((serialObject->_serial).rx_head + 0x40) - (uint)(serialObject->_serial).rx_tail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08008afa": "calculate_available_space_08008afa",
                "this": "serialObject"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b0e": {
            "entrypoint": "0x08008b0e",
            "current_name": "get_next_byte_08008b0e",
            "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * serialObject) */\n\nint __serialObjectcall HardwareSerial::getNextByte_08008b0e(HardwareSerial *serialObject)\n\n{\n  uint rxTail;\n  \n  rxTail = (uint)(serialObject->_serial).rx_tail;\n  if ((serialObject->_serial).rxHead != rxTail) {\n    return (uint)(serialObject->_serial).rxBuffer[rxTail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "uVar1": "rxTail",
                "rx_head": "rxHead",
                "rx_buff": "rxBuffer",
                "FUN_08008b0e": "get_next_byte_08008b0e"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b2a": {
            "entrypoint": "0x08008b2a",
            "current_name": "read_from_serial_08008b2a",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serial_instance) */\n\nssize_t __serial_instancecall\nHardwareSerial::read_from_serial_08008b2a(HardwareSerial *serial_instance,int file_descriptor,void *buffer,size_t num_bytes)\n\n{\n  byte read_byte;\n  ushort rx_tail;\n  uchar c;\n  \n  rx_tail = (serial_instance->_serial).rx_tail;\n  if ((uint)(serial_instance->_serial).rx_head != (uint)rx_tail) {\n    read_byte = (serial_instance->_serial).rx_buff[rx_tail];\n    (serial_instance->_serial).rx_tail = rx_tail + 1 & 0x3f;\n    return (uint)read_byte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08008b2a": "read_from_serial_08008b2a",
                "this": "serial_instance",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__nbytes": "num_bytes",
                "bVar1": "read_byte",
                "uVar2": "rx_tail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b52": {
            "entrypoint": "0x08008b52",
            "current_name": "flush_08008b52",
            "code": "\n/* DWARF original prototype: void  flush_08008b52(HardwareSerial * serial) */\n\nvoid __serialcall HardwareSerial::flush_08008b52(HardwareSerial *serial)\n\n{\n  if (serial->isDataWritten != false) {\n    do {\n    } while ((serial->serialData).transmitHead != (serial->serialData).transmitTail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008b52": "flush_08008b52",
                "this": "serial",
                "_written": "isDataWritten",
                "_serial": "serialData",
                "tx_head": "transmitHead",
                "tx_tail": "transmitTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b66": {
            "entrypoint": "0x08008b66",
            "current_name": "receive_serial_data_08008b66",
            "code": "\n/* WARNING: Unknown callbufferIndexng conventbufferIndexon */\n\nvobufferIndexd HardwareSerbufferIndexal::receiveSerialData_08008b66(serbufferIndexal_t_conflbufferIndexct *serialObject)\n\n{\n  bufferIndexnt returnValue;\n  rx_buffer_bufferIndexndex_t bufferIndex;\n  ushort nextBufferIndex;\n  uchar c;\n  \n  returnValue = uart_getc((serbufferIndexal_t *)serialObject,&c);\n  bufferIndexf ((returnValue == 0) && (nextBufferIndex = serialObject->rx_head + 1 & 0x3f, nextBufferIndex != serialObject->rx_tabufferIndexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = nextBufferIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008b66": "receive_serial_data_08008b66",
                "obj": "serialObject",
                "iVar1": "returnValue",
                "i": "bufferIndex",
                "uVar2": "nextBufferIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ba4": {
            "entrypoint": "0x08008ba4",
            "current_name": "write_byte_buffer_08008ba4",
            "code": "\n/* DWARF ortx_buffer_indexgtx_buffer_indexnal prototype: stx_buffer_indexze_t  wrtx_buffer_indexte(HardwareSertx_buffer_indexal * thtx_buffer_indexs, utx_buffer_indexnt8_t c) */\n\nsstx_buffer_indexze_t __thtx_buffer_indexscall\nHardwareSertx_buffer_indexal::write_byte_buffer_08008ba4(HardwareSertx_buffer_indexal *thtx_buffer_indexs,tx_buffer_indexnt file_descriptor,votx_buffer_indexd *buffer,stx_buffer_indexze_t size)\n\n{\n  byte byte_value_1;\n  utx_buffer_indexnt8_t result;\n  byte byte_value_2;\n  tx_buffer_indexnt index;\n  utx_buffer_indexnt head_index;\n  transmit_bufferer_tx_buffer_indexndex_t tx_buffer_index;\n  \n  thtx_buffer_indexs->has_written = true;\n  head_index = (utx_buffer_indexnt)(thtx_buffer_indexs->serial).transmit_head;\n  index = head_index + 1;\n  byte_value_1 = (byte)index;\n  byte_value_2 = byte_value_1 & 0x7f;\n  tx_buffer_indexf (index == 0) {\n    byte_value_2 = -(-byte_value_1 & 0x7f);\n  }\n  do {\n  } whtx_buffer_indexle ((thtx_buffer_indexs->serial).transmit_tail == (ushort)byte_value_2);\n  (thtx_buffer_indexs->serial).transmit_buffer[head_index] = (utx_buffer_indexnt8_t)file_descriptor;\n  (thtx_buffer_indexs->serial).transmit_head = (ushort)byte_value_2;\n  result = is_transmit_active((sertx_buffer_indexal_t *)&thtx_buffer_indexs->serial);\n  tx_buffer_indexf (result == '\\0') {\n    attach_transmit_callback((sertx_buffer_indexal_t *)&thtx_buffer_indexs->serial,transmit_complete_irq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08008ba4": "write_byte_buffer_08008ba4",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "bVar1": "byte_value_1",
                "uVar2": "result",
                "bVar3": "byte_value_2",
                "iVar4": "index",
                "uVar5": "head_index",
                "i": "tx_buffer_index",
                "_written": "has_written",
                "_serial": "serial",
                "tx_head": "transmit_head",
                "tx_tail": "transmit_tail",
                "tx_buff": "transmit_buffer",
                "uart_attach_tx_callback": "attach_transmit_callback",
                "serial_tx_active": "is_transmit_active",
                "_tx_complete_irq": "transmit_complete_irq"
            },
            "calling": [],
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008bf4": {
            "entrypoint": "0x08008bf4",
            "current_name": "FUNC_08008bf4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08008bfa) */\n/* WARNING: Removing unreachable block (ram,0x08008c0c) */\n/* WARNING: Removing unreachable block (ram,0x08008c02) */\n/* WARNING: Removing unreachable block (ram,0x08008c14) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008bf4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008bf4": "FUNC_08008bf4"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008c20": {
            "entrypoint": "0x08008c20",
            "current_name": "initialize_serial_08008c20",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::initializeSerial_08008c20(HardwareSerial *serial,EVP_PKEY_CTX *context)\n\n{\n  (serial->serial_object).rx_buffer = serial->rx_buffer;\n  (serial->serial_object).rx_buffer_head = 0;\n  (serial->serial_object).rx_buffer_tail = 0;\n  (serial->serial_object).tx_buffer = serial->tx_buffer;\n  (serial->serial_object).tx_buffer_head = 0;\n  (serial->serial_object).tx_buffer_tail = 0;\n  return (int)serial;\n}\n\n",
            "renaming": {
                "FUN_08008c20": "initialize_serial_08008c20",
                "this": "serial",
                "ctx": "context",
                "_serial": "serial_object",
                "rx_buff": "rx_buffer",
                "_rx_buffer": "rx_buffer",
                "rx_head": "rx_buffer_head",
                "rx_tail": "rx_buffer_tail",
                "tx_buff": "tx_buffer",
                "_tx_buffer": "tx_buffer",
                "tx_head": "tx_buffer_head",
                "tx_tail": "tx_buffer_tail"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008c44": {
            "entrypoint": "0x08008c44",
            "current_name": "initialize_serial_08008c44",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialPort, ulong baudrate, byte configuration) */\n\nvoid __serialPortcall HardwareSerial::initializeSerial_08008c44(HardwareSerial *serialPort,ulong baudrate,byte configuration)\n\n{\n  byte configFlags;\n  int bitsSetting;\n  \n  (serialPort->_serial).baudraterate = baudrate;\n  serialPort->_configuration = configuration;\n  configFlags = configuration & 7;\n  if (configFlags == 4) {\n    bitsSetting = 7;\n  }\n  else if (configFlags == 6) {\n    bitsSetting = 8;\n  }\n  else if (configFlags == 2) {\n    bitsSetting = 6;\n  }\n  else {\n    bitsSetting = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    (serialPort->_serial).parity = 0x600;\n    bitsSetting = bitsSetting + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    (serialPort->_serial).parity = 0;\n  }\n  else {\n    (serialPort->_serial).parity = 0x400;\n    bitsSetting = bitsSetting + 1;\n  }\n  if ((configuration & 8) == 0) {\n    (serialPort->_serial).stopbits = 0;\n  }\n  else {\n    (serialPort->_serial).stopbits = 0x2000;\n  }\n  if (bitsSetting == 8) {\n    (serialPort->_serial).databits = 0;\n  }\n  else if (bitsSetting == 9) {\n    (serialPort->_serial).databits = 0x1000;\n  }\n  else {\n    bitsSetting = 0;\n  }\n  if (bitsSetting != 0) {\n    uart_init((serial_t *)&serialPort->_serial);\n    uart_attach_rx_callback((serial_t *)&serialPort->_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "FUN_08008c44": "initialize_serial_08008c44",
                "this": "serialPort",
                "baud": "baudrate",
                "config": "configuration",
                "bVar1": "configFlags",
                "iVar2": "bitsSetting"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "__assert_func",
                "uart_init",
                "uart_attach_rx_callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d00": {
            "entrypoint": "0x08008d00",
            "current_name": "initialize_rx_pin_08008d00",
            "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * serialObject, uint32_t pinIndex) */\n\nvoid __serialObjectcall HardwareSerial::initializeRxPin_08008d00(HardwareSerial *serialObject,uint32_t pinIndex)\n\n{\n  PinName rxPin;\n  \n  if (pinIndex < 0x3c) {\n    rxPin = (&digitalPins)[pinIndex];\n  }\n  else {\n    rxPin = notConnected;\n  }\n  (serialObject->_serial).pinpinIndex = rxPin;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "_rx": "pinIndex",
                "PVar1": "rxPin",
                "digitalPin": "digitalPins",
                "NC": "notConnected",
                "FUN_08008d00": "initialize_rx_pin_08008d00"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d18": {
            "entrypoint": "0x08008d18",
            "current_name": "set_tx_pin_08008d18",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serialPort, uint32_t pinIndex) */\n\nvoid __serialPortcall HardwareSerial::setTxPin_08008d18(HardwareSerial *serialPort,uint32_t pinIndex)\n\n{\n  PinName desiredPin;\n  \n  if (pinIndex < 0x3c) {\n    desiredPin = (pinMapping)[pinIndex];\n  }\n  else {\n    desiredPin = notConnectedPin;\n  }\n  (serialPort->_serial).pinpinIndex = desiredPin;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "_tx": "pinIndex",
                "PVar1": "desiredPin",
                "&digitalPin": "pinMapping",
                "NC": "notConnectedPin",
                "FUN_08008d18": "set_tx_pin_08008d18"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d30": {
            "entrypoint": "0x08008d30",
            "current_name": "initialize_serial_08008d30",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialObject, void *\n   peripheralObject) */\n\nHardwareSerial * __serialObjectcall HardwareSerial::initializeSerial_08008d30(HardwareSerial *serialObject,void *peripheralObject)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *ctx2;\n  \n  (serialObject->super_Stream).super_Print.write_error = 0;\n  (serialObject->super_Stream)._timeout = 1000;\n  (serialObject->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_0800aab8;\n  if (serialObject == &Serial2) {\n    setRx(&Serial2,0);\n    setTx(&Serial2,1);\n    ctx = ctx2;\n  }\n  else {\n    rxPin = pinmap_pin(peripheralObject,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialObject->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheralObject,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialObject->_serial).pin_tx = rxPin;\n    ctx = ctx1;\n  }\n  init(serialObject,ctx);\n  return serialObject;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "peripheral": "peripheralObject",
                "PVar1": "rxPin",
                "extraout_r1": "ctx1",
                "extraout_r1_00": "ctx2",
                "FUN_08008d30": "initialize_serial_08008d30"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init",
                "pinmap_pin",
                "setRx",
                "setTx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d8c": {
            "entrypoint": "0x08008d8c",
            "current_name": "initialize_serial_connection_08008d8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialConnection_08008d8c(int initializeFlag,int priorityValue)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priorityValue == 0xffff) {\n    createHardwareSerialObject(&Serial2,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d8c": "initialize_serial_connection_08008d8c",
                "__initialize_p": "initializeFlag",
                "__priority": "priorityValue",
                "HardwareSerial::HardwareSerial": "createHardwareSerialObject"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008db0": {
            "entrypoint": "0x08008db0",
            "current_name": "initialize_static_data_08008db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08008db0(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008db0": "initialize_static_data_08008db0"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008dbe": {
            "entrypoint": "0x08008dbe",
            "current_name": "print_ip_address_08008dbe",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * address, Print * printer) */\n\nsize_t __addresscall IPAddress::printIPAddress_08008dbe(IPAddress *address,Print *printer)\n\n{\n  size_t bytesPrinted;\n  size_t dotPrinted;\n  int byteIndex;\n  int totalPrinted;\n  \n  totalPrinted = 0;\n  for (byteIndex = 0; byteIndex < 3; byteIndex = byteIndex + 1) {\n    bytesPrinted = Print::printerrint(printer,(address->_address).bytes[byteIndex],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    totalPrinted = totalPrinted + bytesPrinted + dotPrinted;\n  }\n  bytesPrinted = Print::printerrint(printer,(address->_address).bytes[3],10);\n  return bytesPrinted + totalPrinted;\n}\n\n",
            "renaming": {
                "FUN_08008dbe": "print_ip_address_08008dbe",
                "this": "address",
                "p": "printer",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted",
                "iVar3": "byteIndex",
                "iVar4": "totalPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008df8": {
            "entrypoint": "0x08008df8",
            "current_name": "create_ip_address_08008df8",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::createIPAddress_08008df8(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_0800ab0c;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "FUN_08008df8": "create_ip_address_08008df8",
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e14": {
            "entrypoint": "0x08008e14",
            "current_name": "initialize_ip_address_08008e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08008e14(int isInitializationNeeded,int priorityLevel)\n\n{\n  if ((isInitializationNeeded == 1) && (priorityLevel == 0xffff)) {\n    createIPAddress(&invalidAddress,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008e14": "initialize_ip_address_08008e14",
                "__initialize_p": "isInitializationNeeded",
                "__priority": "priorityLevel",
                "IPAddress::IPAddress": "createIPAddress",
                "INADDR_NONE": "invalidAddress"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e40": {
            "entrypoint": "0x08008e40",
            "current_name": "initialize_and_destroy_08008e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_and_destroy_08008e40(void)\n\n{\n  initialize_statics_and_destructors(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008e40": "initialize_and_destroy_08008e40",
                "__static_initialization_and_destruction_0": "initialize_statics_and_destructors"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e4e": {
            "entrypoint": "0x08008e4e",
            "current_name": "print_data_08008e4e",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e62 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::print_data_08008e4e(Print *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *print_object;\n  int iteration_count;\n  \n  iteration_count = 0;\n  print_object = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return iteration_count;\n    }\n    print_object = (Print *)(**this->_vptr_Print)(print_object,(uint)*(byte *)file_descriptor,buffer,*this->_vptr_Print,size)\n    ;\n    if (print_object == (Print *)0x0) break;\n    iteration_count = iteration_count + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return iteration_count;\n}\n\n",
            "renaming": {
                "FUN_08008e4e": "print_data_08008e4e",
                "pPVar1": "print_object",
                "iVar2": "iteration_count",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e72": {
            "entrypoint": "0x08008e72",
            "current_name": "print_char_08008e72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e78 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * instance, char c) */\n\nsize_t __instancecall Print::printChar_08008e72(Print *instance,char c)\n\n{\n  size_t result;\n  \n  result = (**instance->_vptr_Print)(instance,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08008e72": "print_char_08008e72",
                "this": "instance",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e7c": {
            "entrypoint": "0x08008e7c",
            "current_name": "print_number_08008e7c",
            "code": "\n/* WARNING: Heritage AFTER dead redividendoval. Exadividendple locationumber: r0 : 0x08008ecc */\n/* WARNING: Restarted to delay deadcode elidividendinumberationumber for space: register */\n/* WARNING: Exceeded dividendaxidividendudividend restarts with dividendore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNudividendber(Prinumbert * thisPointer, ulonumberg number, uinumbert8_t base) */\n\nsize_t __thisPointercall Prinumbert::printNumber_08008e7c(Prinumbert *thisPointer,ulonumberg number,uinumbert8_t base)\n\n{\n  char charValue;\n  char c;\n  size_t stringLength;\n  size_t outputSize;\n  ulonumberg dividend;\n  uinumbert modulus;\n  uinumbert validBase;\n  uinumbert quotient;\n  char *buffer;\n  char buf [33];\n  \n  validBase = (uinumbert)base;\n  buf[32] = '\\0';\n  if (validBase < 2) {\n    validBase = 10;\n  }\n  buffer = buf + 0x20;\n  dividend = number;\n  do {\n    quotient = dividend / validBase;\n    modulus = (dividend & 0xff) - (quotient * validBase & 0xff) & 0xff;\n    buffer = buffer + -1;\n    charValue = (char)modulus;\n    if (modulus < 10) {\n      charValue = charValue + '0';\n    }\n    else {\n      charValue = charValue + '7';\n    }\n    *buffer = charValue;\n    dividend = quotient;\n  } while (quotient != 0);\n  if (buffer == (char *)0x0) {\n    outputSize = 0;\n  }\n  else {\n    stringLength = strlen(buffer);\n    outputSize = (*thisPointer->_vptr_Prinumbert[1])(stringLength,buffer,stringLength);\n  }\n  returnumber outputSize;\n}\n\n",
            "renaming": {
                "FUN_08008e7c": "print_number_08008e7c",
                "this": "thisPointer",
                "n": "number",
                "cVar1": "charValue",
                "sVar2": "stringLength",
                "sVar3": "outputSize",
                "m": "dividend",
                "uVar4": "modulus",
                "uVar5": "validBase",
                "uVar6": "quotient",
                "__s": "buffer",
                "strlen(__s)": "strlen(buffer)"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ed6": {
            "entrypoint": "0x08008ed6",
            "current_name": "print_number_or_character_08008ed6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08008ee8 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObject, ulonumberg number, inumbert base) */\n\nsize_t __printObjectcall Prinumbert::printNumberOrCharacter_08008ed6(Prinumbert *printObject,ulonumberg number,inumbert base)\n\n{\n  size_t result;\n  \n  if (base != 0) {\n    result = prinumbertNumber(printObject,number,(uinumbert8_t)base);\n    returnumber result;\n  }\n  result = (**printObject->_vptr_Prinumbert)(printObject,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08008ed6": "print_number_or_character_08008ed6",
                "this": "printObject",
                "n": "number",
                "sVar1": "result"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008eec": {
            "entrypoint": "0x08008eec",
            "current_name": "print_with_base_08008eec",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printer, uchar b, int numberBase) */\n\nsize_t __printercall Print::printWithBase_08008eec(Print *printer,uchar b,int numberBase)\n\n{\n  size_t result;\n  \n  result = print(printer,(uint)b,numberBase);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08008eec": "print_with_base_08008eec",
                "this": "printer",
                "base": "numberBase",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ef4": {
            "entrypoint": "0x08008ef4",
            "current_name": "map_value_to_range_08008ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nlong mapValueToRange_08008ef4(long inputValue,long inputMin,long inputMax,long outputMin,long outputMax)\n\n{\n  return (uint)((outputMax - outputMin) * (inputValue - inputMin)) / (uint)(inputMax - inputMin) + outputMin;\n}\n\n",
            "renaming": {
                "FUN_08008ef4": "map_value_to_range_08008ef4",
                "x": "inputValue",
                "in_min": "inputMin",
                "in_max": "inputMax",
                "out_min": "outputMin",
                "out_max": "outputMax"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f0c": {
            "entrypoint": "0x08008f0c",
            "current_name": "FUNC_08008f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f0c": "FUNC_08008f0c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008f0e": {
            "entrypoint": "0x08008f0e",
            "current_name": "initialize_encryption_08008f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEncryption_08008f0e(void)\n\n{\n  EVP_PKEY_CTX *encryptionContext;\n  \n  encryptionContext = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(encryptionContext);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f0e": "initialize_encryption_08008f0e",
                "ctx": "encryptionContext"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f1c": {
            "entrypoint": "0x08008f1c",
            "current_name": "initialize_and_run_08008f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeAndRun_08008f1c(void)\n\n{\n  initializeVariant();\n  setupEnvironment();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08008f1c": "initialize_and_run_08008f1c",
                "initVariant": "initializeVariant",
                "setup": "setupEnvironment",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "serialEventRun",
                "loop",
                "initVariant",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f3c": {
            "entrypoint": "0x08008f3c",
            "current_name": "count_set_bits_08008f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08008f3c(uint16_t inputValue)\n\n{\n  uint value;\n  uint8_t bitCount;\n  \n  bitCount = '\\0';\n  for (value = (uint)inputValue; value != 1; value = value >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08008f3c": "count_set_bits_08008f3c",
                "pin": "inputValue",
                "uVar1": "value",
                "uVar2": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f50": {
            "entrypoint": "0x08008f50",
            "current_name": "clear_gpio_irq_callbacks_08008f50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearGpioIrqCallbacks_08008f50(void *gpio_irq_conf)\n\n{\n  gpio_irq_conf_str *previous_node;\n  _Manager_type manager;\n  gpio_irq_conf_str *current_node;\n  \n  previous_node = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (current_node = previous_node, current_node != gpio_irq_conf) {\n    manager = current_node[-1].callback.super__Function_base._M_manager;\n    previous_node = current_node + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&current_node[-1].callback,(_Any_data *)&current_node[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f50": "clear_gpio_irq_callbacks_08008f50",
                "param_1": "gpio_irq_conf",
                "pgVar1": "previous_node",
                "p_Var2": "manager",
                "pgVar3": "current_node"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f78": {
            "entrypoint": "0x08008f78",
            "current_name": "initialize_gpio_irq_08008f78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_08008f78(int is_initialized,int priority_level)\n\n{\n  if (is_initialized != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    gpio_irq_configurations[0].irqnb = ExternalInterrupt0_IRQn;\n    gpio_irq_configurations[0].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[1].irqnb = ExternalInterrupt1_IRQn;\n    gpio_irq_configurations[1].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[2].irqnb = ExternalInterrupt2_IRQn;\n    gpio_irq_configurations[2].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[3].irqnb = ExternalInterrupt3_IRQn;\n    gpio_irq_configurations[3].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[4].irqnb = ExternalInterrupt4_IRQn;\n    gpio_irq_configurations[4].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[5].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_configurations[5].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[6].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_configurations[6].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[7].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_configurations[7].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[8].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_configurations[8].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[9].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_configurations[9].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[10].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_configurations[10].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[11].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_configurations[11].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[12].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_configurations[12].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[13].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_configurations[13].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[14].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_configurations[14].callback.function_manager = (_Manager_type)0x0;\n    gpio_irq_configurations[15].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_configurations[15].callback.function_manager = (_Manager_type)0x0;\n    atexit_handler(0,0x8008f51,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f78": "initialize_gpio_irq_08008f78",
                "__initialize_p": "is_initialized",
                "__priority": "priority_level",
                "gpio_irq_conf": "gpio_irq_configurations",
                "EXTI0_IRQn": "ExternalInterrupt0_IRQn",
                "EXTI1_IRQn": "ExternalInterrupt1_IRQn",
                "EXTI2_IRQn": "ExternalInterrupt2_IRQn",
                "EXTI3_IRQn": "ExternalInterrupt3_IRQn",
                "EXTI4_IRQn": "ExternalInterrupt4_IRQn",
                "EXTI9_5_IRQn": "ExternalInterrupt9_5_IRQn",
                "EXTI15_10_IRQn": "ExternalInterrupt15_10_IRQn",
                "super__Function_base._M_manager": "function_manager",
                "__aeabi_atexit": "atexit_handler"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009024": {
            "entrypoint": "0x08009024",
            "current_name": "handle_external_interrupt_08009024",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08009024(void)\n\n{\n  handleGPIOInterrupt(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009024": "handle_external_interrupt_08009024",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800902e": {
            "entrypoint": "0x0800902e",
            "current_name": "handle_exti_interrupt_0800902e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_exti_interrupt_0800902e(void)\n\n{\n  handle_gpio_exti_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800902e": "handle_exti_interrupt_0800902e",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_exti_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009038": {
            "entrypoint": "0x08009038",
            "current_name": "handle_external_interrupt_08009038",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08009038(void)\n\n{\n  handleGPIOExternalInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009038": "handle_external_interrupt_08009038",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009042": {
            "entrypoint": "0x08009042",
            "current_name": "handle_gpio_exti_08009042",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_08009042(void)\n\n{\n  handle_exti_interrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009042": "handle_gpio_exti_08009042",
                "HAL_GPIO_EXTI_IRQHandler": "handle_exti_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800904c": {
            "entrypoint": "0x0800904c",
            "current_name": "handle_external_interrupt_0800904c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800904c(void)\n\n{\n  handleGPIOExternalInterrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800904c": "handle_external_interrupt_0800904c",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009056": {
            "entrypoint": "0x08009056",
            "current_name": "handle_gpio_exti_interrupts_08009056",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupts_08009056(void)\n\n{\n  uint loop_counter;\n  \n  for (loop_counter = 0x20; loop_counter < 0x201; loop_counter = loop_counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loop_counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009056": "handle_gpio_exti_interrupts_08009056",
                "uVar1": "loop_counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800906c": {
            "entrypoint": "0x0800906c",
            "current_name": "handle_gpio_interrupts_0800906c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupts_0800906c(void)\n\n{\n  uint iterator;\n  \n  for (iterator = 0x400; iterator < 0x8001; iterator = iterator << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)iterator);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800906c": "handle_gpio_interrupts_0800906c",
                "uVar1": "iterator"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009084": {
            "entrypoint": "0x08009084",
            "current_name": "handle_function_call_08009084",
            "code": "\n/* DWARF original prototype: handleFunctionCall_08009084  operator()(function<handleFunctionCall_08009084()> * functionPointer) */\n\nhandleFunctionCall_08009084 __functionPointercall std::function<handleFunctionCall_08009084()>::handle_function_call_08009084(function<handleFunctionCall_08009084()> *functionPointer)\n\n{\n  if ((functionPointer->functionBase).manager != (_Manager_type)0x0) {\n    (*functionPointer->invoker)((_Any_data *)functionPointer);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPointer",
                "super__Function_base": "functionBase",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "void": "handleFunctionCall",
                "FUN_08009084": "handle_function_call_08009084"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009094": {
            "entrypoint": "0x08009094",
            "current_name": "handle_gpio_interrupt_08009094",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_08009094(uint16_t pinNumber)\n\n{\n  byte pinId;\n  uint8_t interruptId;\n  \n  pinId = get_pin_id(pinNumber);\n  if (gpio_irq_conf[pinId].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pinId].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009094": "handle_gpio_interrupt_08009094",
                "GPIO_Pin": "pinNumber",
                "bVar1": "pinId",
                "irq_id": "interruptId"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_static_data_080090b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080090b4(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_static_data_080090b4"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c2": {
            "entrypoint": "0x080090c2",
            "current_name": "register_exit_handler_080090c2",
            "code": "\nvoid registerExitHandler_080090c2(undefined4 exitHandler,undefined4 cleanupFunction)\n\n{\n  __cxa_atexit(cleanupFunction,exitHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090c2": "register_exit_handler_080090c2",
                "param_1": "exitHandler",
                "param_2": "cleanupFunction"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090cc": {
            "entrypoint": "0x080090cc",
            "current_name": "log_assertion_failure_080090cc",
            "code": "\nvoid logAssertionFailure_080090cc(undefined4 fileName,undefined4 lineNumber,char *functionName,undefined4 assertionMessage)\n\n{\n  char *separator;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    separator = functionName;\n  }\n  else {\n    separator = \", function: \";\n  }\n  fiprintf(*(FILE **)(fileStream + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertionMessage,fileName,lineNumber,separator,functionName,assertionMessage);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_080090cc": "log_assertion_failure_080090cc",
                "param_1": "fileName",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "assertionMessage",
                "pcVar1": "separator",
                "_impure_ptr": "fileStream"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009108": {
            "entrypoint": "0x08009108",
            "current_name": "left_shift_param2_by32_08009108",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009110) */\n\nlonglong leftShiftParam2By32_08009108(undefined4 param1,uint param2)\n\n{\n  return (ulonglong)param2 << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08009108": "left_shift_param2_by32_08009108",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009124": {
            "entrypoint": "0x08009124",
            "current_name": "print_formatted_output_08009124",
            "code": "\nint printFormattedOutput_08009124(FILE *file,char *formatString,...)\n\n{\n  int numCharsPrinted;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  undefined4 unusedVar4;\n  \n  unusedVar3 = unusedVar1;\n  unusedVar4 = unusedVar2;\n  numCharsPrinted = _vfiprintf_r(_impure_ptr,file,formatString,&unusedVar3,file,&unusedVar3);\n  return numCharsPrinted;\n}\n\n",
            "renaming": {
                "FUN_08009124": "print_formatted_output_08009124",
                "__stream": "file",
                "__format": "formatString",
                "iVar1": "numCharsPrinted",
                "in_r2": "unusedVar1",
                "in_r3": "unusedVar2",
                "uStack_8": "unusedVar3",
                "uStack_4": "unusedVar4"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009148": {
            "entrypoint": "0x08009148",
            "current_name": "initialize_pre_init_functions_08009148",
            "code": "\nvoid initializePreInitFunctions_08009148(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)preInitFunction)();\n  }\n  initialize();\n  for (index = 0; index != 0xc; index = index + 1) {\n    (*(code *)preInitFunction)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009148": "initialize_pre_init_functions_08009148",
                "iVar1": "index",
                "(&__preinit_array_end)[iVar1]": "preInitFunction",
                "_init": "initialize"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009190": {
            "entrypoint": "0x08009190",
            "current_name": "allocate_memory_08009190",
            "code": "\nvoid * allocateMemory_08009190(size_t size)\n\n{\n  void *allocatedMemory;\n  \n  allocatedMemory = (void *)_malloc_r(_impure_ptr,size);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a0": {
            "entrypoint": "0x080091a0",
            "current_name": "free_memory_080091a0",
            "code": "\nvoid freeMemory_080091a0(void *memoryBlock)\n\n{\n  _free_r(_impure_ptr,memoryBlock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091a0": "free_memory_080091a0",
                "__ptr": "memoryBlock"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091b0": {
            "entrypoint": "0x080091b0",
            "current_name": "copy_memory_080091b0",
            "code": "\nvoid * copy_memory_080091b0(void *destination,void *source,size_t length)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(length + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080091b0": "copy_memory_080091b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "_realloc_r",
                "write",
                "onReceiveService"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091c6": {
            "entrypoint": "0x080091c6",
            "current_name": "set_memory_080091c6",
            "code": "\nvoid * setMemory_080091c6(void *destination,int value,size_t size)\n\n{\n  undefined *currentByte;\n  \n  for (currentByte = (undefined *)destination; currentByte != (undefined *)(size + (int)destination); currentByte = currentByte + 1) {\n    *currentByte = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080091c6": "set_memory_080091c6",
                "__s": "destination",
                "__c": "value",
                "__n": "size",
                "puVar1": "currentByte"
            },
            "calling": [
                "std.isra.0",
                "__sfmoreglue",
                "adc_read_value",
                "begin",
                "flush",
                "pwm_start",
                "__sfp",
                "endTransmission"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091d8": {
            "entrypoint": "0x080091d8",
            "current_name": "allocate_memory_080091d8",
            "code": "\nvoid allocateMemory_080091d8(undefined4 *result,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int **nextFreePointer;\n  int **currentPointer;\n  int **nextPointer;\n  int *tempPointer;\n  int **previousPointer;\n  int **newMemoryChunk;\n  \n  if (size == 0) {\n    return;\n  }\n  newMemoryChunk = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newMemoryChunk = (int **)((int)newMemoryChunk + *(int *)(size + -4));\n  }\n  lockMemoryAllocation();\n  nextPointer = (int **)&freeMemoryList;\n  if (freeMemoryList == (int **)0x0) {\n    newMemoryChunk[1] = (int *)0x0;\n    currentPointer = nextFreePointer;\n    freeMemoryList = newMemoryChunk;\n  }\n  else {\n    nextPointer = freeMemoryList;\n    if (newMemoryChunk < freeMemoryList) {\n      currentPointer = (int **)*newMemoryChunk;\n      nextPointer = (int **)((int)newMemoryChunk + (int)currentPointer);\n      if (freeMemoryList == nextPointer) {\n        tempPointer = *freeMemoryList;\n        freeMemoryList = (int **)freeMemoryList[1];\n        nextPointer = (int **)((int)tempPointer + (int)currentPointer);\n        *newMemoryChunk = (int *)nextPointer;\n      }\n      newMemoryChunk[1] = (int *)freeMemoryList;\n      freeMemoryList = newMemoryChunk;\n    }\n    else {\n      do {\n        previousPointer = nextPointer;\n        nextPointer = (int **)previousPointer[1];\n        if (nextPointer == (int **)0x0) break;\n      } while (nextPointer <= newMemoryChunk);\n      currentPointer = (int **)*previousPointer;\n      if ((int **)((int)previousPointer + (int)currentPointer) == newMemoryChunk) {\n        currentPointer = (int **)((int)currentPointer + (int)*newMemoryChunk);\n        *previousPointer = (int *)currentPointer;\n        if (nextPointer == (int **)((int)previousPointer + (int)currentPointer)) {\n          tempPointer = *nextPointer;\n          nextPointer = (int **)nextPointer[1];\n          currentPointer = (int **)((int)currentPointer + (int)tempPointer);\n          *previousPointer = (int *)currentPointer;\n          previousPointer[1] = (int *)nextPointer;\n        }\n      }\n      else if (newMemoryChunk < (int **)((int)previousPointer + (int)currentPointer)) {\n        *result = 0xc;\n      }\n      else {\n        currentPointer = (int **)((int)newMemoryChunk + (int)*newMemoryChunk);\n        if (nextPointer == currentPointer) {\n          tempPointer = *nextPointer;\n          nextPointer = (int **)nextPointer[1];\n          currentPointer = (int **)((int)tempPointer + (int)*newMemoryChunk);\n          *newMemoryChunk = (int *)currentPointer;\n        }\n        newMemoryChunk[1] = (int *)nextPointer;\n        previousPointer[1] = (int *)newMemoryChunk;\n      }\n    }\n  }\n  unlockMemoryAllocation(result,currentPointer,nextPointer,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091d8": "allocate_memory_080091d8",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "extraout_r1": "nextFreePointer",
                "ppiVar1": "currentPointer",
                "ppiVar2": "nextPointer",
                "piVar3": "tempPointer",
                "ppiVar4": "previousPointer",
                "ppiVar5": "newMemoryChunk",
                "__malloc_lock": "lockMemoryAllocation",
                "__malloc_free_list": "freeMemoryList",
                "__malloc_unlock": "unlockMemoryAllocation"
            },
            "calling": [
                "free",
                "__swsetup_r",
                "__sflush_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009270": {
            "entrypoint": "0x08009270",
            "current_name": "allocate_memory_08009270",
            "code": "\nuint allocate_memory_08009270(undefined4 *error_code,uint size)\n\n{\n  uint *current_ptr;\n  int remaining_size;\n  uint *prev_ptr;\n  uint diff_size;\n  uint *prev_ptr_prev;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *error_code = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_ptr = __malloc_free_list;\n    prev_ptr_prev = __malloc_free_list;\n    while (prev_ptr = current_ptr, prev_ptr != (uint *)0x0) {\n      diff_size = *prev_ptr - allocated_size;\n      if (-1 < (int)diff_size) {\n        if (diff_size < 0xc) {\n          if (prev_ptr_prev == prev_ptr) {\n            current_ptr = (uint *)prev_ptr_prev[1];\n            __malloc_free_list = current_ptr;\n          }\n          else {\n            current_ptr = (uint *)prev_ptr[1];\n          }\n          if (prev_ptr_prev != prev_ptr) {\n            prev_ptr_prev[1] = (uint)current_ptr;\n            prev_ptr_prev = prev_ptr;\n          }\n        }\n        else {\n          *prev_ptr = diff_size;\n          *(uint *)((int)prev_ptr + diff_size) = allocated_size;\n          prev_ptr_prev = (uint *)((int)prev_ptr + diff_size);\n        }\n        goto LAB_080092d4;\n      }\n      prev_ptr_prev = prev_ptr;\n      current_ptr = (uint *)prev_ptr[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(error_code);\n    }\n    current_ptr = (uint *)_sbrk_r(error_code,allocated_size);\n    if ((current_ptr != (uint *)0xffffffff) &&\n       ((prev_ptr_prev = (uint *)((int)current_ptr + 3U & 0xfffffffc), current_ptr == prev_ptr_prev ||\n        (remaining_size = _sbrk_r(error_code,(int)prev_ptr_prev - (int)current_ptr), remaining_size != -1)))) {\n      *prev_ptr_prev = allocated_size;\nLAB_080092d4:\n      __malloc_unlock(error_code);\n      allocated_size = (int)prev_ptr_prev + 0xbU & 0xfffffff8;\n      remaining_size = allocated_size - (int)(prev_ptr_prev + 1);\n      if (remaining_size != 0) {\n        *(int *)((int)prev_ptr_prev + remaining_size) = -remaining_size;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *error_code = 0xc;\n    __malloc_unlock(error_code);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009270": "allocate_memory_08009270",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "current_ptr",
                "iVar2": "remaining_size",
                "puVar3": "prev_ptr",
                "uVar4": "diff_size",
                "puVar5": "prev_ptr_prev",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r",
                "_realloc_r",
                "malloc"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800932c": {
            "entrypoint": "0x0800932c",
            "current_name": "write_byte_to_buffer_0800932c",
            "code": "\nuint writeByteToBuffer_0800932c(undefined4 status,byte data,byte **buffer)\n\n{\n  uint result;\n  byte *bufferEnd;\n  \n  bufferEnd = buffer[2] + -1;\n  buffer[2] = bufferEnd;\n  if (((int)bufferEnd < 0) && (((int)bufferEnd < (int)buffer[6] || (data == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  bufferEnd = *buffer;\n  *buffer = bufferEnd + 1;\n  *bufferEnd = data;\n  return (uint)data;\n}\n\n",
            "renaming": {
                "FUN_0800932c": "write_byte_to_buffer_0800932c",
                "param_1": "status",
                "param_2": "data",
                "param_3": "buffer",
                "uVar1": "result",
                "pbVar2": "bufferEnd"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009358": {
            "entrypoint": "0x08009358",
            "current_name": "write_data_to_file_08009358",
            "code": "\nint writeDataToFile_08009358(undefined4 file,undefined4 mode,undefined *data,int length)\n\n{\n  int result;\n  undefined *end;\n  int count;\n  \n  end = data + length;\n  count = length;\n  do {\n    if (data == end) {\n      return 0;\n    }\n    result = __sfputc_r(file,*data,mode,length,count);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009358": "write_data_to_file_08009358",
                "param_1": "file",
                "param_2": "mode",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end",
                "iVar3": "count"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800937c": {
            "entrypoint": "0x0800937c",
            "current_name": "print_formatted_string_0800937c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009550) */\n\nint printFormattedString_0800937c(int formattingContext,undefined4 *stream,byte *formatString,int *bytesWritten)\n\n{\n  bool isDigit;\n  int status;\n  void *foundChar;\n  int *nextParam;\n  byte *currentChar;\n  byte *nextChar;\n  int previousStatus;\n  int integerValue;\n  int *paramStack;\n  uint flags;\n  int precision;\n  undefined4 localeInfo;\n  int fieldWidth;\n  int totalBytesWritten;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined zeroFlag;\n  undefined4 emulationId;\n  \n  paramStack = bytesWritten;\n  if ((formattingContext != 0) && (*(int *)(formattingContext + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(formattingContext + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(formattingContext + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(formattingContext + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1c)) || (stream[4] == 0)) &&\n     (integerValue = __swsetup_r(formattingContext,stream), integerValue != 0)) {\n    return -1;\n  }\n  totalBytesWritten = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  currentChar = formatString;\nLAB_080093be:\n  nextChar = currentChar;\n  if (*nextChar != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  currentChar = nextChar + 1;\n  if (*nextChar != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  integerValue = (int)nextChar - (int)formatString;\n  if (integerValue != 0) {\n    status = __sfputs_r(formattingContext,stream,formatString,integerValue);\n    if (status == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(stream + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalBytesWritten;\n    }\n    totalBytesWritten = totalBytesWritten + integerValue;\n  }\n  if (*nextChar == 0) goto LAB_08009568;\n  flags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  localeInfo = 0;\n  zeroFlag = 0;\n  emulationId = 0;\n  currentChar = nextChar + 1;\n  while( true ) {\n    foundChar = memchr(\"#-0+ \",(uint)*currentChar,5);\n    formatString = currentChar + 1;\n    if (foundChar == (void *)0x0) break;\n    flags = 1 << ((int)foundChar + 0xf7ff54b0U & 0xff) | flags;\n    currentChar = formatString;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    zeroFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    zeroFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    nextParam = paramStack + 1;\n    integerValue = *paramStack;\n    paramStack = nextParam;\n    if (integerValue < 0) {\n      fieldWidth = -integerValue;\n      flags = flags | 2;\n      goto LAB_080094a6;\n    }\n  }\n  else {\n    isDigit = false;\n    integerValue = fieldWidth;\n    formatString = currentChar;\n    while( true ) {\n      if (9 < *formatString - 0x30) break;\n      integerValue = integerValue * 10 + (*formatString - 0x30);\n      isDigit = true;\n      formatString = formatString + 1;\n    }\n    if (!isDigit) goto LAB_080094a6;\n  }\n  fieldWidth = integerValue;\nLAB_080094a6:\n  if (*formatString == 0x2e) {\n    if (formatString[1] == 0x2a) {\n      formatString = formatString + 2;\n      nextParam = paramStack + 1;\n      precision = *paramStack;\n      paramStack = nextParam;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isDigit = false;\n      integerValue = 0;\n      precision = 0;\n      while( true ) {\n        formatString = formatString + 1;\n        if (9 < *formatString - 0x30) break;\n        integerValue = integerValue * 10 + (*formatString - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = integerValue;\n      }\n    }\n  }\n  foundChar = memchr(&DAT_0800ab56,(uint)*formatString,3);\n  if (foundChar != (void *)0x0) {\n    formatString = formatString + 1;\n    flags = flags | 0x40 << ((int)foundChar + 0xf7ff54aaU & 0xff);\n  }\n  conversionSpecifier = *formatString;\n  formatString = formatString + 1;\n  foundChar = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (foundChar == (void *)0x0) {\n    previousStatus = _printf_i(formattingContext,&flags,stream,0x8009359,&paramStack);\n    if (previousStatus == -1) goto LAB_08009568;\n  }\n  else {\n    paramStack = (int *)(((int)paramStack + 7U & 0xfffffff8) + 8);\n  }\n  totalBytesWritten = totalBytesWritten + previousStatus;\n  currentChar = formatString;\n  goto LAB_080093be;\n}\n\n",
            "renaming": {
                "FUN_0800937c": "print_formatted_string_0800937c",
                "param_1": "formattingContext",
                "param_2": "stream",
                "param_3": "formatString",
                "param_4": "bytesWritten",
                "bVar1": "isDigit",
                "iVar2": "status",
                "pvVar3": "foundChar",
                "piVar4": "nextParam",
                "pbVar5": "currentChar",
                "pbVar6": "nextChar",
                "unaff_r9": "previousStatus",
                "iVar7": "integerValue",
                "local_8c": "paramStack",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "localeInfo",
                "local_7c": "fieldWidth",
                "local_74": "totalBytesWritten",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "zeroFlag",
                "local_30": "emulationId"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "__swsetup_r",
                "_printf_i",
                "__sinit",
                "memchr",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080095a8": {
            "entrypoint": "0x080095a8",
            "current_name": "process_data_080095a8",
            "code": "\nundefined4\nprocessData_080095a8(undefined4 input,uint *data,uint *output,undefined4 param,code *callback)\n\n{\n  int index;\n  int result;\n  uint maxValue;\n  uint increment;\n  bool isNonZero;\n  \n  maxValue = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxValue = data[2];\n  }\n  *output = maxValue;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *output = maxValue + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index = 0; index < (int)(data[3] - *output); index = index + 1) {\n      result = (*callback)(input,param,(int)data + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)data + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  increment = maxValue;\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxValue + 0x43) = 0x30;\n    increment = maxValue + 2;\n    *(undefined *)((int)data + maxValue + 0x44) = *(undefined *)((int)data + 0x45);\n  }\n  index = (*callback)(input,param,(int)data + 0x43,increment);\n  if (index != -1) {\n    maxValue = data[3];\n    isNonZero = (*data & 6) != 4;\n    if (isNonZero) {\n      maxValue = 0;\n    }\n    increment = 0;\n    if (!isNonZero) {\n      maxValue = maxValue - *output;\n    }\n    if (!isNonZero) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxValue = maxValue + (data[2] - data[4]);\n    }\n    while( true ) {\n      if (maxValue == increment) {\n        return 0;\n      }\n      index = (*callback)(input,param,(int)data + 0x1a,1);\n      if (index == -1) break;\n      increment = increment + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080095a8": "process_data_080095a8",
                "param_1": "input",
                "param_2": "data",
                "param_3": "output",
                "param_4": "param",
                "param_5": "callback",
                "iVar1": "index",
                "iVar2": "result",
                "uVar3": "maxValue",
                "uVar4": "increment",
                "bVar5": "isNonZero"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009698": {
            "entrypoint": "0x08009698",
            "current_name": "print_formatted_output_08009698",
            "code": "\nuint print_formatted_output_08009698(undefined4 format_string,uint *arg_list,undefined4 param_3,code *output_func,uint **arg_list_ptr)\n\n{\n  byte flag;\n  int result;\n  uint *arg_ptr;\n  void *found_ptr;\n  int func_result;\n  char *hex_chars;\n  uint flag_value;\n  uint **pp_arg_ptr;\n  char **pp_char_ptr;\n  uint value;\n  uint param_2_1;\n  char *char_ptr;\n  char *string;\n  uint local_arr [2];\n  \n  flag = *(byte *)(arg_list + 6);\n  string = (char *)((int)arg_list + 0x43);\n  if (flag != 0x6e) {\n    if (flag < 0x6f) {\n      if (flag != 99) {\n        if (flag < 100) {\n          if (flag == 0) goto LAB_08009852;\n          if (flag != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)arg_list + 0x45) = 0x58;\n          hex_chars = \"0123456789ABCDEF\";\nLAB_080097e2:\n          flag_value = *arg_list;\n          arg_ptr = *arg_list_ptr;\n          *arg_list_ptr = arg_ptr + 1;\n          if (((flag_value & 0x80) == 0) && ((int)(flag_value << 0x19) < 0)) {\n            value = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            value = *arg_ptr;\n          }\n          if ((int)(flag_value << 0x1f) < 0) {\n            *arg_list = flag_value | 0x20;\n          }\n          if (value == 0) {\n            *arg_list = *arg_list & 0xffffffdf;\n          }\n          flag_value = 0x10;\nLAB_08009778:\n          *(undefined *)((int)arg_list + 0x43) = 0;\n        }\n        else {\n          if ((flag != 100) && (flag != 0x69)) goto LAB_080096c8;\n          value = *arg_list;\n          arg_ptr = *arg_list_ptr;\n          if ((value & 0x80) == 0) {\n            *arg_list_ptr = arg_ptr + 1;\n            if ((value & 0x40) == 0) goto LAB_080096e8;\n            value = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *arg_list_ptr = arg_ptr + 1;\nLAB_080096e8:\n            value = *arg_ptr;\n          }\n          if ((int)value < 0) {\n            value = -value;\n            *(undefined *)((int)arg_list + 0x43) = 0x2d;\n          }\n          hex_chars = \"0123456789ABCDEF\";\n          flag_value = 10;\n        }\n        param_2_1 = arg_list[1];\n        arg_list[2] = param_2_1;\n        char_ptr = string;\n        if ((int)param_2_1 < 0) {\n          if (value != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(char *)((int)arg_list + 0x42) = *hex_chars;\n          char_ptr = (char *)((int)arg_list + 0x42);\n        }\n        else {\n          *arg_list = *arg_list & 0xfffffffb;\n          if (value == 0) {\n            if (param_2_1 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              param_2_1 = value / flag_value;\n              char_ptr = char_ptr + -1;\n              *char_ptr = hex_chars[value - flag_value * param_2_1];\n              value = param_2_1;\n            } while (param_2_1 != 0);\n          }\n        }\n        if (((flag_value == 8) && ((int)(*arg_list << 0x1f) < 0)) && ((int)arg_list[1] <= (int)arg_list[4]))\n        {\n          char_ptr[-1] = '0';\n          char_ptr = char_ptr + -1;\n        }\n        arg_list[4] = (int)string - (int)char_ptr;\n        string = char_ptr;\n        goto LAB_080097be;\n      }\n      arg_ptr = *arg_list_ptr;\n      *arg_list_ptr = arg_ptr + 1;\n      *(char *)((int)arg_list + 0x42) = (char)*arg_ptr;\nLAB_08009728:\n      string = (char *)((int)arg_list + 0x42);\n      value = 1;\n    }\n    else {\n      if (flag != 0x73) {\n        if (flag < 0x74) {\n          if (flag == 0x6f) {\nLAB_0800974e:\n            value = *arg_list;\n            arg_ptr = *arg_list_ptr;\n            if ((value & 0x80) == 0) {\n              *arg_list_ptr = arg_ptr + 1;\n              if ((value & 0x40) == 0) goto LAB_0800975c;\n              value = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *arg_list_ptr = arg_ptr + 1;\nLAB_0800975c:\n              value = *arg_ptr;\n            }\n            if (flag == 0x6f) {\n              flag_value = 8;\n            }\n            else {\n              flag_value = 10;\n            }\n            hex_chars = \"0123456789ABCDEF\";\n            goto LAB_08009778;\n          }\n          if (flag == 0x70) {\n            *arg_list = *arg_list | 0x20;\nLAB_0800970e:\n            hex_chars = \"0123456789abcdef\";\n            *(undefined *)((int)arg_list + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (flag == 0x75) goto LAB_0800974e;\n          if (flag == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)arg_list + 0x42) = flag;\n        goto LAB_08009728;\n      }\n      pp_char_ptr = (char **)*arg_list_ptr;\n      *arg_list_ptr = (uint *)(pp_char_ptr + 1);\n      string = *pp_char_ptr;\n      found_ptr = memchr(string,0,arg_list[1]);\n      if (found_ptr != (void *)0x0) {\n        arg_list[1] = (int)found_ptr - (int)string;\n      }\n      value = arg_list[1];\n    }\n    arg_list[4] = value;\n    *(undefined *)((int)arg_list + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  value = *arg_list;\n  pp_arg_ptr = (uint **)*arg_list_ptr;\n  flag_value = arg_list[5];\n  if ((value & 0x80) == 0) {\n    *arg_list_ptr = (uint *)(pp_arg_ptr + 1);\n    arg_ptr = *pp_arg_ptr;\n    if ((value & 0x40) == 0) goto LAB_0800983e;\n    *(short *)arg_ptr = (short)flag_value;\n  }\n  else {\n    *arg_list_ptr = (uint *)(pp_arg_ptr + 1);\n    arg_ptr = *pp_arg_ptr;\nLAB_0800983e:\n    *arg_ptr = flag_value;\n  }\nLAB_08009852:\n  arg_list[4] = 0;\nLAB_080097be:\n  result = _printf_common(format_string,arg_list,local_arr,param_3,output_func);\n  if ((result == -1) || (result = (*output_func)(format_string,param_3,string,arg_list[4]), result == -1)) {\nLAB_080097d2:\n    value = 0xffffffff;\n  }\n  else {\n    if ((int)(*arg_list << 0x1e) < 0) {\n      for (result = 0; result < (int)(arg_list[3] - local_arr[0]); result = result + 1) {\n        func_result = (*output_func)(format_string,param_3,(int)arg_list + 0x19,1);\n        if (func_result == -1) goto LAB_080097d2;\n      }\n    }\n    value = arg_list[3];\n    if ((int)arg_list[3] < (int)local_arr[0]) {\n      value = local_arr[0];\n    }\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_08009698": "print_formatted_output_08009698",
                "param_1": "format_string",
                "param_2": "arg_list",
                "param_4": "output_func",
                "param_5": "arg_list_ptr",
                "bVar1": "flag",
                "iVar2": "result",
                "puVar3": "arg_ptr",
                "pvVar4": "found_ptr",
                "iVar5": "func_result",
                "pcVar6": "hex_chars",
                "uVar7": "flag_value",
                "ppuVar8": "pp_arg_ptr",
                "ppcVar9": "pp_char_ptr",
                "uVar10": "value",
                "uVar11": "param_2_1",
                "pcVar12": "char_ptr",
                "__s": "string",
                "local_24": "local_arr"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098d8": {
            "entrypoint": "0x080098d8",
            "current_name": "formatted_print_080098d8",
            "code": "\nint formattedPrint_080098d8(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *currentChar;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  \n  impurePtr = _impure_ptr;\n  currentChar = formatString;\n  arg1 = in_r1;\n  arg2 = in_r2;\n  arg3 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&arg1,currentChar,&arg1);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_080098d8": "formatted_print_080098d8",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "pcVar2": "currentChar",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "calling": [
                "getTimerIrq",
                "uart_init",
                "getTimerClkSrc",
                "getTimerClkFreq",
                "i2c_custom_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009908": {
            "entrypoint": "0x08009908",
            "current_name": "reallocate_memory_08009908",
            "code": "\nvoid * reallocateMemory_08009908(void *originalPointer,size_t newSize)\n\n{\n  void *resultPointer;\n  \n  resultPointer = (void *)_realloc_r(_impure_ptr,originalPointer,newSize);\n  return resultPointer;\n}\n\n",
            "renaming": {
                "FUN_08009908": "reallocate_memory_08009908",
                "__ptr": "originalPointer",
                "__size": "newSize",
                "pvVar1": "resultPointer"
            },
            "calling": [
                "write",
                "allocateRxBuffer",
                "write"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009918": {
            "entrypoint": "0x08009918",
            "current_name": "allocate_memory_08009918",
            "code": "\nvoid allocateMemory_08009918(int *error,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009938": {
            "entrypoint": "0x08009938",
            "current_name": "find_character_in_string_08009938",
            "code": "\nchar * find_character_in_string_08009938(char *string,int character)\n\n{\n  byte *byte_pointer;\n  \n  do {\n    byte_pointer = (byte *)string;\n    if (*byte_pointer == 0) {\n      if ((character & 0xffU) != 0) {\n        byte_pointer = (byte *)0x0;\n      }\n      return (char *)byte_pointer;\n    }\n    string = (char *)(byte_pointer + 1);\n  } while ((character & 0xffU) != (uint)*byte_pointer);\n  return (char *)byte_pointer;\n}\n\n",
            "renaming": {
                "FUN_08009938": "find_character_in_string_08009938",
                "__s": "string",
                "__c": "character",
                "pbVar1": "byte_pointer"
            },
            "calling": [
                "strrchr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009954": {
            "entrypoint": "0x08009954",
            "current_name": "copy_string_08009954",
            "code": "\nchar * copy_string_08009954(char *destination,char *source,size_t size)\n\n{\n  char current_char;\n  size_t remaining_size;\n  char *dest_ptr;\n  char *dest_curr;\n  \n  dest_ptr = destination;\n  do {\n    dest_curr = dest_ptr;\n    remaining_size = size;\n    if (remaining_size == 0) {\n      return destination;\n    }\n    current_char = *source;\n    dest_ptr = dest_curr + 1;\n    *dest_curr = current_char;\n    source = source + 1;\n    size = remaining_size - 1;\n  } while (current_char != '\\0');\n  for (; dest_ptr != dest_curr + remaining_size; dest_ptr = dest_ptr + 1) {\n    *dest_ptr = '\\0';\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009954": "copy_string_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "pcVar3": "dest_ptr",
                "pcVar4": "dest_curr",
                "sVar2": "remaining_size",
                "cVar1": "current_char"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800997e": {
            "entrypoint": "0x0800997e",
            "current_name": "find_last_occurrence_0800997e",
            "code": "\nchar * find_last_occurrence_0800997e(char *str,int target)\n\n{\n  char *ptr_cur;\n  char *ptr_last;\n  \n  if (target != 0) {\n    ptr_last = (char *)0x0;\n    while (ptr_cur = strchr(str,target), ptr_cur != (char *)0x0) {\n      str = ptr_cur + 1;\n      ptr_last = ptr_cur;\n    }\n    return ptr_last;\n  }\n  ptr_last = strchr(str,0);\n  return ptr_last;\n}\n\n",
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_0800997e",
                "__s": "str",
                "__c": "target",
                "pcVar1": "ptr_cur",
                "pcVar2": "ptr_last"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "strchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099a4": {
            "entrypoint": "0x080099a4",
            "current_name": "find_substring_080099a4",
            "code": "\nchar * find_substring_080099a4(char *input_string,char *substring)\n\n{\n  char *current_char;\n  char *compare_char;\n  char *compare_substring;\n  \n  if (*input_string == '\\0') {\n    if (*substring != '\\0') {\n      input_string = (char *)0x0;\n    }\n    return input_string;\n  }\n  do {\n    current_char = input_string;\n    if (*current_char == '\\0') {\n      return (char *)0x0;\n    }\n    compare_substring = substring + -1;\n    compare_char = current_char + -1;\n    do {\n      compare_substring = compare_substring + 1;\n      if (*compare_substring == '\\0') {\n        return current_char;\n      }\n      compare_char = compare_char + 1;\n      input_string = current_char + 1;\n    } while (*compare_char == *compare_substring);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "input_string",
                "__needle": "substring",
                "pcVar1": "current_char",
                "pcVar2": "compare_char",
                "pcVar3": "compare_substring"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099dc": {
            "entrypoint": "0x080099dc",
            "current_name": "write_to_stream_080099dc",
            "code": "\nuint write_to_stream_080099dc(int stream_handle,uint character,int *stream,undefined4 buffer)\n\n{\n  int status;\n  uint byte_count;\n  undefined *pointer;\n  \n  if ((stream_handle != 0) && (*(int *)(stream_handle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(stream_handle + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(stream_handle + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(stream_handle + 0xc);\n  }\n  stream[2] = stream[6];\n  byte_count = (uint)*(ushort *)(stream + 3);\n  status = byte_count << 0x1c;\n  if (((status < 0) && (byte_count = stream[4], byte_count != 0)) ||\n     (status = __swsetup_r(stream_handle,stream,status,byte_count,buffer), status == 0)) {\n    character = character & 0xff;\n    status = *stream - stream[4];\n    if ((status < stream[5]) || (status = _fflush_r(stream_handle,stream), status == 0)) {\n      stream[2] = stream[2] + -1;\n      pointer = (undefined *)*stream;\n      *stream = (int)(pointer + 1);\n      *pointer = (char)character;\n      if (status + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      status = _fflush_r(stream_handle,stream);\n      if (status == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080099dc": "write_to_stream_080099dc",
                "param_1": "stream_handle",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "buffer",
                "iVar1": "status",
                "uVar2": "byte_count",
                "puVar3": "pointer"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a80": {
            "entrypoint": "0x08009a80",
            "current_name": "process_stream_08009a80",
            "code": "\nuint process_stream_08009a80(undefined4 *stream_info,undefined4 *stream_ptr)\n\n{\n  int impure_ptr;\n  uint result;\n  ushort stream_flags;\n  \n  impure_ptr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (stream_ptr == &__sf_fake_stdin) {\n    stream_ptr = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (stream_ptr == (undefined4 *)&__sf_fake_stdout) {\n    stream_ptr = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (stream_ptr == (undefined4 *)&__sf_fake_stderr) {\n    stream_ptr = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  stream_flags = *(ushort *)(stream_ptr + 3);\n  result = (uint)stream_flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *stream_info = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)stream_ptr[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)stream_ptr[0xd] != stream_ptr + 0x11) {\n          _free_r(stream_info);\n        }\n        stream_ptr[0xd] = 0;\n      }\n      *(ushort *)(stream_ptr + 3) = *(ushort *)(stream_ptr + 3) & 0xffdb;\n      stream_ptr[1] = 0;\n      *stream_ptr = stream_ptr[4];\n    }\n    *(ushort *)(stream_ptr + 3) = *(ushort *)(stream_ptr + 3) | 8;\n  }\n  if ((stream_ptr[4] == 0) && ((*(ushort *)(stream_ptr + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(stream_info,stream_ptr);\n  }\n  stream_flags = *(ushort *)(stream_ptr + 3);\n  result = stream_flags & 1;\n  if ((stream_flags & 1) == 0) {\n    if (-1 < (int)((uint)stream_flags << 0x1e)) {\n      result = stream_ptr[5];\n    }\n    stream_ptr[2] = result;\n  }\n  else {\n    stream_ptr[2] = 0;\n    stream_ptr[6] = -stream_ptr[5];\n  }\n  if (stream_ptr[4] == 0) {\n    stream_flags = *(ushort *)(stream_ptr + 3);\n    result = (int)(short)stream_flags & 0x80;\n    if (result != 0) {\nLAB_08009ab0:\n      *(ushort *)(stream_ptr + 3) = stream_flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009a80": "process_stream_08009a80",
                "param_1": "stream_info",
                "param_2": "stream_ptr",
                "iVar1": "impure_ptr",
                "uVar2": "result",
                "uVar3": "stream_flags"
            },
            "calling": [
                "_vfiprintf_r",
                "__swbuf_r"
            ],
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b5c": {
            "entrypoint": "0x08009b5c",
            "current_name": "terminate_process_08009b5c",
            "code": "\n\n\nvoid terminateProcess_08009b5c(void)\n\n{\n  raiseSignal(6);\n                    \n  exitProcess(1);\n}\n\n",
            "renaming": {
                "FUN_08009b5c": "terminate_process_08009b5c",
                "raise": "raiseSignal",
                "_exit": "exitProcess"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b6c": {
            "entrypoint": "0x08009b6c",
            "current_name": "process_input_08009b6c",
            "code": "\nundefined4 processInput_08009b6c(uint *dataPointer,int *paramArray)\n\n{\n  int var1;\n  int *var2;\n  uint var3;\n  ushort var4;\n  int var5;\n  code *functionPointer;\n  int var7;\n  uint var8;\n  bool flag;\n  \n  var4 = *(ushort *)(paramArray + 3);\n  var3 = (uint)var4;\n  if ((int)(var3 << 0x1c) < 0) {\n    var1 = paramArray[4];\n    if (var1 != 0) {\n      var5 = var3 << 0x1e;\n      flag = var5 != 0;\n      if (flag) {\n        var5 = 0;\n      }\n      var7 = *paramArray;\n      if (!flag) {\n        var5 = paramArray[5];\n      }\n      *paramArray = var1;\n      paramArray[2] = var5;\n      for (var7 = var7 - var1; 0 < var7; var7 = var7 - var5) {\n        var5 = (*(code *)paramArray[10])(dataPointer,paramArray[8],var1,var7);\n        if (var5 < 1) {\n          var4 = *(ushort *)(paramArray + 3);\n          goto LAB_08009c62;\n        }\n        var1 = var1 + var5;\n      }\n    }\n  }\n  else if (((0 < paramArray[1]) || (0 < paramArray[0x10])) &&\n          (functionPointer = (code *)paramArray[0xb], functionPointer != (code *)0x0)) {\n    var8 = *dataPointer;\n    *dataPointer = 0;\n    if ((var4 & 0x1000) == 0) {\n      var1 = (*functionPointer)(dataPointer,paramArray[8],var3 & 0x1000,1);\n      if ((var1 == -1) && (var3 = *dataPointer, var3 != 0)) {\n        if ((var3 != 0x1d) && (var3 != 0x16)) {\n          *(ushort *)(paramArray + 3) = *(ushort *)(paramArray + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *dataPointer = var8;\n        return 0;\n      }\n    }\n    else {\n      var1 = paramArray[0x15];\n    }\n    if (((int)((uint)*(ushort *)(paramArray + 3) << 0x1d) < 0) &&\n       (var1 = var1 - paramArray[1], paramArray[0xd] != 0)) {\n      var1 = var1 - paramArray[0x10];\n    }\n    var1 = (*(code *)paramArray[0xb])(dataPointer,paramArray[8],var1,0);\n    var4 = *(ushort *)(paramArray + 3);\n    if ((var1 == -1) &&\n       ((0x1d < *dataPointer || (-1 < (int)((0x20400001U >> (*dataPointer & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(paramArray + 3) = var4 | 0x40;\n      return 0xffffffff;\n    }\n    paramArray[1] = 0;\n    *paramArray = paramArray[4];\n    if (((int)((uint)var4 << 0x13) < 0) && ((var1 != -1 || (*dataPointer == 0)))) {\n      paramArray[0x15] = var1;\n    }\n    var2 = (int *)paramArray[0xd];\n    *dataPointer = var8;\n    if (var2 != (int *)0x0) {\n      if (var2 != paramArray + 0x11) {\n        _free_r(dataPointer);\n      }\n      paramArray[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009b6c": "process_input_08009b6c",
                "param_1": "dataPointer",
                "param_2": "paramArray",
                "iVar1": "var1",
                "piVar2": "var2",
                "uVar3": "var3",
                "uVar4": "var4",
                "iVar5": "var5",
                "pcVar6": "functionPointer",
                "iVar7": "var7",
                "uVar8": "var8",
                "bVar9": "flag"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009c7c": {
            "entrypoint": "0x08009c7c",
            "current_name": "check_and_flush_stdio_08009c7c",
            "code": "\nundefined4 check_and_flush_stdio_08009c7c(int file_descriptor,undefined4 *file_stream,undefined4 buffer,undefined4 buffer_size)\n\n{\n  undefined4 result;\n  \n  if (file_stream[4] != 0) {\n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n      __sinit();\n    }\n    if (file_stream == &stdin_stream) {\n      file_stream = *(undefined4 **)(file_descriptor + 4);\n    }\n    else if (file_stream == (undefined4 *)&stdout_stream) {\n      file_stream = *(undefined4 **)(file_descriptor + 8);\n    }\n    else if (file_stream == (undefined4 *)&stderr_stream) {\n      file_stream = *(undefined4 **)(file_descriptor + 0xc);\n    }\n    if (*(short *)(file_stream + 3) != 0) {\n      result = __sflush_r(file_descriptor,file_stream,buffer,buffer_size);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009c7c": "check_and_flush_stdio_08009c7c",
                "param_1": "file_descriptor",
                "param_2": "file_stream",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "uVar1": "result",
                "__sf_fake_stdin": "stdin_stream",
                "__sf_fake_stdout": "stdout_stream",
                "__sf_fake_stderr": "stderr_stream"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009cd0": {
            "entrypoint": "0x08009cd0",
            "current_name": "initialize_file_walk_08009cd0",
            "code": "\nvoid initialize_file_walk_08009cd0(undefined4 reent)\n\n{\n  file_walk(reent,0x8009c7d);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009cd0": "initialize_file_walk_08009cd0",
                "param_1": "reent",
                "_fwalk_reent": "file_walk"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009cdc": {
            "entrypoint": "0x08009cdc",
            "current_name": "initialize_data_08009cdc",
            "code": "\nvoid initializeData_08009cdc(undefined4 *data,undefined2 value1,undefined2 value2)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[0x19] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[8] = data;\n  data[9] = 0x800a021;\n  data[10] = 0x800a043;\n  data[0xb] = 0x800a07b;\n  data[0xc] = 0x800a09f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009cdc": "initialize_data_08009cdc",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d24": {
            "entrypoint": "0x08009d24",
            "current_name": "allocate_memory_and_initialize_08009d24",
            "code": "\nundefined4 * allocate_memory_and_initialize_08009d24(undefined4 num_elements,int element_size)\n\n{\n  undefined4 *ptr;\n  int total_size;\n  \n  total_size = (element_size + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(num_elements,total_size + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = element_size;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,total_size + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009d24": "allocate_memory_and_initialize_08009d24",
                "param_1": "num_elements",
                "param_2": "element_size",
                "puVar1": "ptr",
                "iVar2": "total_size"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d50": {
            "entrypoint": "0x08009d50",
            "current_name": "initialize_data_08009d50",
            "code": "\nvoid initializeData_08009d50(undefined1 *dataPtr)\n\n{\n  undefined4 result;\n  undefined1 *pointer;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    pointer = &globalData;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8009cd1;\n    if (dataPtr == &globalData) {\n      pointer = (undefined1 *)0x1;\n    }\n    if (dataPtr == &globalData) {\n      *(undefined1 **)(dataPtr + 0x18) = pointer;\n    }\n    result = getFloatFromMemory();\n    *(undefined4 *)(dataPtr + 4) = result;\n    result = getFloatFromMemory(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = result;\n    result = getFloatFromMemory(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = result;\n    processData(*(undefined4 *)(dataPtr + 4),4,0);\n    processData(*(undefined4 *)(dataPtr + 8),9,1);\n    processData(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009d50": "initialize_data_08009d50",
                "param_1": "dataPtr",
                "uVar1": "result",
                "puVar2": "pointer",
                "&impure_data": "&globalData",
                "__sfp": "getFloatFromMemory",
                "std_isra_0": "processData"
            },
            "calling": [
                "__swsetup_r",
                "_fflush_r",
                "_vfiprintf_r",
                "__swbuf_r",
                "iprintf",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009db0": {
            "entrypoint": "0x08009db0",
            "current_name": "initialize_data_structure_08009db0",
            "code": "\nint * initializeDataStructure_08009db0(undefined4 *errorFlag)\n\n{\n  int *currentNode;\n  int *nodePtr;\n  int **nodeListPtr;\n  \n  if (DAT_200000ac == 0) {\n    __sinit(&impure_data);\n  }\n  nodeListPtr = (int **)&DAT_200000dc;\n  do {\n    nodePtr = nodeListPtr[2];\n    currentNode = nodeListPtr[1];\n    while (currentNode = (int *)((int)currentNode + -1), -1 < (int)currentNode) {\n      if (*(short *)(nodePtr + 3) == 0) {\n        *(undefined2 *)((int)nodePtr + 0xe) = 0xffff;\n        nodePtr[0x19] = 0;\n        *(undefined2 *)(nodePtr + 3) = 1;\n        *nodePtr = 0;\n        nodePtr[2] = 0;\n        nodePtr[1] = 0;\n        nodePtr[4] = 0;\n        nodePtr[5] = 0;\n        nodePtr[6] = 0;\n        memset(nodePtr + 0x17,0,8);\n        nodePtr[0xd] = 0;\n        nodePtr[0xe] = 0;\n        nodePtr[0x12] = 0;\n        nodePtr[0x13] = 0;\n        return nodePtr;\n      }\n      nodePtr = nodePtr + 0x1a;\n    }\n    if (*nodeListPtr == (int *)0x0) {\n      currentNode = (int *)__sfmoreglue(errorFlag,4);\n      *nodeListPtr = currentNode;\n      if (currentNode == (int *)0x0) {\n        *errorFlag = 0xc;\n        return (int *)0x0;\n      }\n    }\n    nodeListPtr = (int **)*nodeListPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08009db0": "initialize_data_structure_08009db0",
                "param_1": "errorFlag",
                "piVar1": "currentNode",
                "piVar2": "nodePtr",
                "ppiVar3": "nodeListPtr"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "memset",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e28": {
            "entrypoint": "0x08009e28",
            "current_name": "process_data_08009e28",
            "code": "\nuint processData_08009e28(int inputValue,code *callbackFunction,undefined4 param3,undefined4 param4)\n\n{\n  uint result;\n  int increment;\n  int *pointer;\n  int innerValue;\n  uint combinedResult;\n  int rowCount;\n  \n  combinedResult = 0;\n  for (pointer = (int *)(inputValue + 0x48); pointer != (int *)0x0; pointer = (int *)*pointer) {\n    innerValue = pointer[2];\n    rowCount = pointer[1];\n    while (rowCount = rowCount + -1, -1 < rowCount) {\n      if ((1 < *(ushort *)(innerValue + 0xc)) && (increment = *(short *)(innerValue + 0xe) + 1, increment != 0)) {\n        result = (*callbackFunction)(inputValue,innerValue,param3,increment,param4);\n        combinedResult = combinedResult | result;\n      }\n      innerValue = innerValue + 0x68;\n    }\n  }\n  return combinedResult;\n}\n\n",
            "renaming": {
                "FUN_08009e28": "process_data_08009e28",
                "param_1": "inputValue",
                "param_2": "callbackFunction",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result",
                "iVar2": "increment",
                "piVar3": "pointer",
                "iVar4": "innerValue",
                "uVar5": "combinedResult",
                "iVar6": "rowCount"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e64": {
            "entrypoint": "0x08009e64",
            "current_name": "check_file_permissions_08009e64",
            "code": "\nundefined4 checkFilePermissions_08009e64(undefined4 fileDescriptor,int fileInfo,undefined4 *result,uint *isExecutable)\n\n{\n  int status;\n  undefined4 permission;\n  undefined statusBuffer [4];\n  uint fileType;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (status = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),statusBuffer), status < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      permission = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileType & 0xf000) == 0x2000);\n  }\n  permission = 0x400;\nLAB_08009ea4:\n  *result = permission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009e64": "check_file_permissions_08009e64",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "result",
                "param_4": "isExecutable",
                "iVar1": "status",
                "uVar2": "permission",
                "auStack_4c": "statusBuffer",
                "local_48": "fileType"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009eac": {
            "entrypoint": "0x08009eac",
            "current_name": "process_data_08009eac",
            "code": "\nvoid processData_08009eac(int data,int *ptr)\n\n{\n  ushort result;\n  int allocatedPtr;\n  int size;\n  int *tempPtr;\n  \n  if (-1 < (int)((uint)*(ushort *)(ptr + 3) << 0x1e)) {\n    size = data;\n    tempPtr = ptr;\n    result = __swhatbuf_r(data,ptr,&size,&tempPtr);\n    allocatedPtr = _malloc_r(data,size);\n    if (allocatedPtr != 0) {\n      *(undefined4 *)(data + 0x28) = 0x8009cd1;\n      *ptr = allocatedPtr;\n      *(ushort *)(ptr + 3) = *(ushort *)(ptr + 3) | 0x80;\n      ptr[4] = allocatedPtr;\n      ptr[5] = size;\n      if ((tempPtr != (int *)0x0) &&\n         (allocatedPtr = _isatty_r(data,(int)*(short *)((int)ptr + 0xe)), allocatedPtr != 0)) {\n        *(ushort *)(ptr + 3) = *(ushort *)(ptr + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(ptr + 3) = result | *(ushort *)(ptr + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(ptr + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(ptr + 3) = *(ushort *)(ptr + 3) & 0xfffc | 2;\n  }\n  *ptr = (int)ptr + 0x47;\n  ptr[4] = (int)ptr + 0x47;\n  ptr[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009eac": "process_data_08009eac",
                "param_1": "data",
                "param_2": "ptr",
                "uVar1": "result",
                "iVar2": "allocatedPtr",
                "local_18": "size",
                "local_14": "tempPtr"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "__swhatbuf_r",
                "_isatty_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f2c": {
            "entrypoint": "0x08009f2c",
            "current_name": "find_byte_in_memory_08009f2c",
            "code": "\nvoid * find_byte_in_memory_08009f2c(void *memory,int search_byte,size_t size)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  \n  pbVar1 = (byte *)memory;\n  do {\n    pbVar2 = pbVar1;\n    if (pbVar2 == (byte *)(size + (int)memory)) {\n      return (void *)0x0;\n    }\n    pbVar1 = pbVar2 + 1;\n  } while ((uint)*pbVar2 != (search_byte & 0xffU));\n  return pbVar2;\n}\n\n",
            "renaming": {
                "FUN_08009f2c": "find_byte_in_memory_08009f2c",
                "__s": "memory",
                "__c": "search_byte",
                "__n": "size"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f48": {
            "entrypoint": "0x08009f48",
            "current_name": "FUNC_08009f48",
            "code": "\nvoid FUNC_08009f48(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009f48": "FUNC_08009f48"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009f4a": {
            "entrypoint": "0x08009f4a",
            "current_name": "FUNC_08009f4a",
            "code": "\nvoid FUNC_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009f4a": "FUNC_08009f4a"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009f4c": {
            "entrypoint": "0x08009f4c",
            "current_name": "resize_and_copy_memory_08009f4c",
            "code": "\nvoid * resizeAndCopyMemory_08009f4c(undefined4 context,void *source,uint size,undefined4 flags)\n\n{\n  void *resizedMemory;\n  uint usableSize;\n  \n  if (source != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      resizedMemory = (void *)0x0;\n    }\n    else {\n      usableSize = _malloc_usable_size_r();\n      resizedMemory = source;\n      if ((usableSize < size) && (resizedMemory = (void *)_malloc_r(context,size), resizedMemory != (void *)0x0))\n      {\n        memcpy(resizedMemory,source,size);\n        _free_r(context,source);\n      }\n    }\n    return resizedMemory;\n  }\n  resizedMemory = (void *)_malloc_r(context,size,size,flags);\n  return resizedMemory;\n}\n\n",
            "renaming": {
                "FUN_08009f4c": "resize_and_copy_memory_08009f4c",
                "param_1": "context",
                "param_2": "source",
                "param_3": "size",
                "param_4": "flags",
                "pvVar1": "resizedMemory",
                "uVar2": "usableSize"
            },
            "calling": [
                "realloc"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f98": {
            "entrypoint": "0x08009f98",
            "current_name": "execute_function_08009f98",
            "code": "\nundefined4 execute_function_08009f98(undefined4 *result,uint index,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t pid;\n  undefined4 return_value;\n  int data;\n  code *function_ptr;\n  \n  if (0x1f < index) {\n    *result = 0x16;\n    return 0xffffffff;\n  }\n  data = result[0x11];\n  if ((data != 0) && (function_ptr = *(code **)(data + index * 4), function_ptr != (code *)0x0)) {\n    if (function_ptr != (code *)0x1) {\n      if (function_ptr == (code *)0xffffffff) {\n        *result = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(data + index * 4) = 0;\n      (*function_ptr)(index);\n    }\n    return 0;\n  }\n  pid = _getpid_r();\n  return_value = _kill_r(result,pid,index,param_4);\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_08009f98": "execute_function_08009f98",
                "param_1": "result",
                "param_2": "index",
                "_Var1": "pid",
                "uVar2": "return_value",
                "iVar3": "data",
                "pcVar4": "function_ptr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009fe8": {
            "entrypoint": "0x08009fe8",
            "current_name": "handle_signal_08009fe8",
            "code": "\nint handle_signal_08009fe8(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009fe8": "handle_signal_08009fe8",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009ff8": {
            "entrypoint": "0x08009ff8",
            "current_name": "kill_process_08009ff8",
            "code": "\nvoid kill_process_08009ff8(int *error_code,__pid_t process_id,int signal)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _kill(process_id,signal);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009ff8": "kill_process_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "iVar1": "result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a01c": {
            "entrypoint": "0x0800a01c",
            "current_name": "FUN_0800a01c",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a020": {
            "entrypoint": "0x0800a020",
            "current_name": "update_data_0800a020",
            "code": "\nvoid updateData_0800a020(undefined4 param_1,int data)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isSuccess;\n  \n  readResult = _read_r(param_1,(int)*(short *)(data + 0xe));\n  isSuccess = -1 < readResult;\n  if (isSuccess) {\n    updatedValue = *(int *)(data + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(data + 0xc) & 0xffffefff;\n  }\n  if (isSuccess) {\n    *(uint *)(data + 0x54) = updatedValue;\n  }\n  if (!isSuccess) {\n    *(short *)(data + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a020": "update_data_0800a020",
                "param_2": "data",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isSuccess"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a042": {
            "entrypoint": "0x0800a042",
            "current_name": "file_write_and_seek_0800a042",
            "code": "\nvoid fileWriteAndSeek_0800a042(undefined4 fileDescriptor,int dataPointer,undefined4 buffer,undefined4 count)\n\n{\n  if ((int)((uint)*(UnsignedShort *)(dataPointer + 0xc) << 0x17) < 0) {\n    lseek(fileDescriptor,(int)*(short *)(dataPointer + 0xe),0,2);\n  }\n  *(UnsignedShort *)(dataPointer + 0xc) = *(UnsignedShort *)(dataPointer + 0xc) & 0xefff;\n  write(fileDescriptor,(int)*(short *)(dataPointer + 0xe),buffer,count);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a042": "file_write_and_seek_0800a042",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "param_3": "buffer",
                "param_4": "count",
                "ushort": "UnsignedShort",
                "_lseek_r": "lseek",
                "_write_r": "write"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a07a": {
            "entrypoint": "0x0800a07a",
            "current_name": "update_file_position_0800a07a",
            "code": "\nvoid updateFilePosition_0800a07a(undefined4 fileDescriptor,int structPointer)\n\n{\n  int fileSeekResult;\n  ushort updatedFlags;\n  bool isSeekFailed;\n  \n  fileSeekResult = _lseek_r(fileDescriptor,(int)*(short *)(structPointer + 0xe));\n  isSeekFailed = fileSeekResult == -1;\n  if (isSeekFailed) {\n    updatedFlags = *(ushort *)(structPointer + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(structPointer + 0x54) = fileSeekResult;\n    updatedFlags = *(ushort *)(structPointer + 0xc) | 0x1000;\n  }\n  if (isSeekFailed) {\n    *(ushort *)(structPointer + 0xc) = updatedFlags;\n  }\n  if (!isSeekFailed) {\n    *(ushort *)(structPointer + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a07a": "update_file_position_0800a07a",
                "param_1": "fileDescriptor",
                "param_2": "structPointer",
                "iVar1": "fileSeekResult",
                "uVar2": "updatedFlags",
                "bVar3": "isSeekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a09e": {
            "entrypoint": "0x0800a09e",
            "current_name": "close_file_handle_0800a09e",
            "code": "\nvoid closeFileHandle_0800a09e(undefined4 fileHandle,int buffer)\n\n{\n  _close_r(fileHandle,(int)*(short *)(buffer + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a09e": "close_file_handle_0800a09e",
                "param_1": "fileHandle",
                "param_2": "buffer"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0a8": {
            "entrypoint": "0x0800a0a8",
            "current_name": "write_to_file_with_error_handling_0800a0a8",
            "code": "\nvoid write_to_file_with_error_handling_0800a0a8(int *error_code,int file_descriptor,char *buffer,int buffer_size)\n\n{\n  int write_result;\n  \n  errno = 0;\n  write_result = _write(file_descriptor,buffer,buffer_size);\n  if ((write_result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0a8": "write_to_file_with_error_handling_0800a0a8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "iVar1": "write_result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0cc": {
            "entrypoint": "0x0800a0cc",
            "current_name": "close_file_with_error_handling_0800a0cc",
            "code": "\nvoid closeFileWithErrorHandling_0800a0cc(int *errorFlag,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0cc": "close_file_with_error_handling_0800a0cc",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0ec": {
            "entrypoint": "0x0800a0ec",
            "current_name": "get_file_stat_0800a0ec",
            "code": "\nvoid get_file_stat_0800a0ec(int *error_code,int file_descriptor,stat *stat_buffer)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,stat_buffer);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0ec": "get_file_stat_0800a0ec",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "stat_buffer",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a110": {
            "entrypoint": "0x0800a110",
            "current_name": "check_terminal_validity_0800a110",
            "code": "\nvoid checkTerminalValidity_0800a110(int *error,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  errno = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a110": "check_terminal_validity_0800a110",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a130": {
            "entrypoint": "0x0800a130",
            "current_name": "seek_and_store_error_0800a130",
            "code": "\nvoid seekAndStoreError_0800a130(int *errorPointer,int fileDescriptor,__off_t offset,int whence)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,whence);\n  if ((result == -1) && (errno != 0)) {\n    *errorPointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a130": "seek_and_store_error_0800a130",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a154": {
            "entrypoint": "0x0800a154",
            "current_name": "calculate_0800a154",
            "code": "\nint calculate_0800a154(undefined4 result,int input)\n\n{\n  int accumulated_sum;\n  \n  accumulated_sum = *(int *)(input + -4) + -4;\n  if (*(int *)(input + -4) < 0) {\n    accumulated_sum = accumulated_sum + *(int *)(input + accumulated_sum);\n  }\n  return accumulated_sum;\n}\n\n",
            "renaming": {
                "FUN_0800a154": "calculate_0800a154",
                "param_1": "result",
                "param_2": "input",
                "iVar1": "accumulated_sum"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a168": {
            "entrypoint": "0x0800a168",
            "current_name": "read_file_0800a168",
            "code": "\nvoid readFile_0800a168(int *error,int fileDescriptor,char *buffer,int numBytes)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,numBytes);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a168": "read_file_0800a168",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "numBytes",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a18c": {
            "entrypoint": "0x0800a18c",
            "current_name": "abort_and_throw_bad_function_call_0800a18c",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abort_and_throw_bad_function_call_0800a18c(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800a18c": "abort_and_throw_bad_function_call_0800a18c"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a194": {
            "entrypoint": "0x0800a194",
            "current_name": "set_default_ids_0800a194",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::set_default_ids_0800a194(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a194": "set_default_ids_0800a194"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a258": {
            "entrypoint": "0x0800a258",
            "current_name": "initialize_c_type_0800a258",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCType_0800a258(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a258": "initialize_c_type_0800a258"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a31c": {
            "entrypoint": "0x0800a31c",
            "current_name": "initialize_standard_locales_0800a31c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeStandardLocales_0800a31c(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a31c": "initialize_standard_locales_0800a31c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a3a0": {
            "entrypoint": "0x0800a3a0",
            "current_name": "initializectype_byname_0800a3a0",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializectype_byname_0800a3a0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a3a0": "initializectype_byname_0800a3a0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a424": {
            "entrypoint": "0x0800a424",
            "current_name": "FUNC_0800a424",
            "code": "\nvoid FUNC_0800a424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a424": "FUNC_0800a424"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800a430": {
            "entrypoint": "0x0800a430",
            "current_name": "FUNC_0800a430",
            "code": "\nvoid FUNC_0800a430(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a430": "FUNC_0800a430"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 236107,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_0800018c",
            "FUN_080001a8",
            "FUN_08000214",
            "FUN_080002ec",
            "FUN_08000488",
            "FUN_080004d4",
            "FUN_08000500",
            "FUN_08000588",
            "FUN_080005e0",
            "FUN_080005f8",
            "FUN_08000a64",
            "FUN_08000aec",
            "FUN_08000be8",
            "FUN_08000c18",
            "FUN_08000ef8",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001bf8",
            "FUN_08001c08",
            "FUN_08001c18",
            "FUN_08001cd0",
            "FUN_080022f8",
            "FUN_08002400",
            "FUN_0800242c",
            "FUN_08002444",
            "FUN_08002578",
            "FUN_08002580",
            "FUN_080025ac",
            "FUN_08002634",
            "FUN_08002644",
            "FUN_0800267c",
            "FUN_080026b0",
            "FUN_080026f8",
            "FUN_0800270c",
            "FUN_08002720",
            "FUN_0800274c",
            "FUN_08002774",
            "FUN_08002798",
            "FUN_080027f0",
            "FUN_0800288c",
            "FUN_0800291c",
            "FUN_08002948",
            "FUN_08002968",
            "FUN_08002a1c",
            "FUN_08002a26",
            "FUN_08002a30",
            "FUN_08002a58",
            "FUN_08002ac0",
            "FUN_08002acc",
            "FUN_08002b00",
            "FUN_08002b68",
            "FUN_08002c00",
            "FUN_08002c14",
            "FUN_08002c1e",
            "FUN_08002c2c",
            "FUN_08002c40",
            "FUN_08002c54",
            "FUN_08002c68",
            "FUN_08002c7c",
            "FUN_08002c90",
            "FUN_08002ca4",
            "FUN_08002cb8",
            "FUN_08002cd0",
            "FUN_08002ce0",
            "FUN_08002dbc",
            "FUN_08002ddc",
            "FUN_08002dea",
            "FUN_08002df6",
            "FUN_08002e1a",
            "FUN_08002e26",
            "FUN_08002e44",
            "FUN_08002ec4",
            "FUN_08002ed2",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08002f0a",
            "FUN_08002f14",
            "FUN_08002f1e",
            "FUN_08002f2c",
            "FUN_08002f84",
            "FUN_08002f94",
            "FUN_08002fa0",
            "FUN_08002fa8",
            "FUN_08002fba",
            "FUN_08002fc2",
            "FUN_08002fca",
            "FUN_08003002",
            "FUN_08003048",
            "FUN_0800306c",
            "FUN_0800307a",
            "FUN_08003106",
            "FUN_0800314e",
            "FUN_08003154",
            "FUN_08003158",
            "FUN_0800319e",
            "FUN_080031ce",
            "FUN_0800322c",
            "FUN_0800325a",
            "FUN_080032a2",
            "FUN_080032bc",
            "FUN_08003306",
            "FUN_08003346",
            "FUN_08003350",
            "FUN_08003366",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_080033a8",
            "FUN_080033cc",
            "FUN_0800344a",
            "FUN_08003474",
            "FUN_080035b8",
            "FUN_08003658",
            "FUN_080036a0",
            "FUN_080036a2",
            "FUN_080036ac",
            "FUN_080036d8",
            "FUN_08003724",
            "FUN_08003748",
            "FUN_08003760",
            "FUN_0800376c",
            "FUN_080038dc",
            "FUN_080038e4",
            "FUN_08003a1c",
            "FUN_08003a20",
            "FUN_08003aa0",
            "FUN_08003b8c",
            "FUN_08003bd8",
            "FUN_08003ce8",
            "FUN_08003de4",
            "FUN_08003e20",
            "FUN_08003f0c",
            "FUN_08003f30",
            "FUN_08003f94",
            "FUN_08003fb0",
            "FUN_08003fd8",
            "FUN_08004004",
            "FUN_08004024",
            "FUN_08004046",
            "FUN_08004050",
            "FUN_080040e8",
            "FUN_080042d4",
            "FUN_080042e2",
            "FUN_080042f0",
            "FUN_0800430c",
            "FUN_08004396",
            "FUN_080043a2",
            "FUN_0800457c",
            "FUN_0800459c",
            "FUN_080045c0",
            "FUN_08004728",
            "FUN_080047f4",
            "FUN_080048c8",
            "FUN_08004954",
            "FUN_080049e0",
            "FUN_08004a24",
            "FUN_08004a76",
            "FUN_08004ac2",
            "FUN_08004aec",
            "FUN_08004b82",
            "FUN_08004ccc",
            "FUN_08004d6c",
            "FUN_08004e3c",
            "FUN_08004f3c",
            "FUN_08005084",
            "FUN_08005188",
            "FUN_080052f0",
            "FUN_080053cc",
            "FUN_0800542a",
            "FUN_08005430",
            "FUN_08005434",
            "FUN_08005460",
            "FUN_08005840",
            "FUN_080058ac",
            "FUN_08005a1c",
            "FUN_08005a28",
            "FUN_08005a48",
            "FUN_08005a68",
            "FUN_08005aa4",
            "FUN_08005bb8",
            "FUN_08005cb4",
            "FUN_08005cec",
            "FUN_08005d48",
            "FUN_08005dac",
            "FUN_08005df4",
            "FUN_08005e2e",
            "FUN_08005e6e",
            "FUN_08005fe8",
            "FUN_08006060",
            "FUN_08006092",
            "FUN_080060c4",
            "FUN_08006128",
            "FUN_08006186",
            "FUN_08006262",
            "FUN_08006280",
            "FUN_080062f4",
            "FUN_08006390",
            "FUN_080063c0",
            "FUN_08006420",
            "FUN_0800643c",
            "FUN_08006460",
            "FUN_080064b0",
            "FUN_080064cc",
            "FUN_08006538",
            "FUN_080066e8",
            "FUN_0800674e",
            "FUN_080067ac",
            "FUN_0800688e",
            "FUN_080068d6",
            "FUN_08006932",
            "FUN_0800694c",
            "FUN_080069ec",
            "FUN_08006b0c",
            "FUN_08006b1c",
            "FUN_08006b28",
            "FUN_08006b3e",
            "FUN_08006b5c",
            "FUN_08006b7c",
            "FUN_08006bb8",
            "FUN_08006c60",
            "FUN_08006c7c",
            "FUN_08006ca8",
            "FUN_08006d24",
            "FUN_08006d80",
            "FUN_08006e68",
            "FUN_08007110",
            "FUN_08007118",
            "FUN_080071e4",
            "FUN_0800723c",
            "FUN_08007246",
            "FUN_08007258",
            "FUN_080072d8",
            "FUN_080072f0",
            "FUN_080072fa",
            "FUN_08007306",
            "FUN_08007320",
            "FUN_08007332",
            "FUN_0800734a",
            "FUN_0800735a",
            "FUN_08007376",
            "FUN_0800738a",
            "FUN_080073ae",
            "FUN_080073c0",
            "FUN_080073d8",
            "FUN_080073e8",
            "FUN_080073ec",
            "FUN_08007438",
            "FUN_080074e0",
            "FUN_08007544",
            "FUN_08007594",
            "FUN_080075dc",
            "FUN_08007648",
            "FUN_080076e0",
            "FUN_08007708",
            "FUN_08007710",
            "FUN_08007718",
            "FUN_0800771c",
            "FUN_08007736",
            "FUN_08007744",
            "FUN_0800774a",
            "FUN_08007750",
            "FUN_08007760",
            "FUN_08007774",
            "FUN_08007788",
            "FUN_0800779c",
            "FUN_080077b0",
            "FUN_08007e74",
            "FUN_08007ede",
            "FUN_08007f0e",
            "FUN_08007f78",
            "FUN_08007f7c",
            "FUN_08007f8e",
            "FUN_08007fa0",
            "FUN_08007ff0",
            "FUN_08008020",
            "FUN_08008038",
            "FUN_08008048",
            "FUN_08008058",
            "FUN_08008068",
            "FUN_08008078",
            "FUN_080084b0",
            "FUN_08008500",
            "FUN_080085b8",
            "FUN_080085dc",
            "FUN_08008600",
            "FUN_0800863c",
            "FUN_08008694",
            "FUN_080086e8",
            "FUN_0800870c",
            "FUN_08008730",
            "FUN_0800877c",
            "FUN_080087bc",
            "FUN_080087d4",
            "FUN_080087ec",
            "FUN_08008804",
            "FUN_08008840",
            "FUN_08008846",
            "FUN_08008850",
            "FUN_08008854",
            "FUN_08008858",
            "FUN_0800885c",
            "FUN_08008868",
            "FUN_0800886c",
            "FUN_0800887c",
            "FUN_08008880",
            "FUN_080088e0",
            "FUN_08008990",
            "FUN_08008a24",
            "FUN_08008a6c",
            "FUN_08008abc",
            "FUN_08008ac6",
            "FUN_08008afa",
            "FUN_08008b0e",
            "FUN_08008b2a",
            "FUN_08008b52",
            "FUN_08008b66",
            "FUN_08008ba4",
            "FUN_08008c20",
            "FUN_08008c44",
            "FUN_08008d00",
            "FUN_08008d18",
            "FUN_08008d30",
            "FUN_08008d8c",
            "FUN_08008db0",
            "FUN_08008dbe",
            "FUN_08008df8",
            "FUN_08008e14",
            "FUN_08008e40",
            "FUN_08008e4e",
            "FUN_08008e72",
            "FUN_08008e7c",
            "FUN_08008ed6",
            "FUN_08008eec",
            "FUN_08008ef4",
            "FUN_08008f0e",
            "FUN_08008f1c",
            "FUN_08008f3c",
            "FUN_08008f50",
            "FUN_08008f78",
            "FUN_08009024",
            "FUN_0800902e",
            "FUN_08009038",
            "FUN_08009042",
            "FUN_0800904c",
            "FUN_08009056",
            "FUN_0800906c",
            "FUN_08009084",
            "FUN_08009094",
            "FUN_080090b4",
            "FUN_080090c2",
            "FUN_080090cc",
            "FUN_08009108",
            "FUN_08009124",
            "FUN_08009148",
            "FUN_08009190",
            "FUN_080091a0",
            "FUN_080091b0",
            "FUN_080091c6",
            "FUN_080091d8",
            "FUN_08009270",
            "FUN_0800932c",
            "FUN_08009358",
            "FUN_0800937c",
            "FUN_080095a8",
            "FUN_08009698",
            "FUN_080098d8",
            "FUN_08009908",
            "FUN_08009918",
            "FUN_08009938",
            "FUN_08009954",
            "FUN_0800997e",
            "FUN_080099a4",
            "FUN_080099dc",
            "FUN_08009a80",
            "FUN_08009b5c",
            "FUN_08009b6c",
            "FUN_08009c7c",
            "FUN_08009cd0",
            "FUN_08009cdc",
            "FUN_08009d24",
            "FUN_08009d50",
            "FUN_08009db0",
            "FUN_08009e28",
            "FUN_08009e64",
            "FUN_08009eac",
            "FUN_08009f2c",
            "FUN_08009f4c",
            "FUN_08009f98",
            "FUN_08009fe8",
            "FUN_08009ff8",
            "FUN_0800a020",
            "FUN_0800a042",
            "FUN_0800a07a",
            "FUN_0800a09e",
            "FUN_0800a0a8",
            "FUN_0800a0cc",
            "FUN_0800a0ec",
            "FUN_0800a110",
            "FUN_0800a130",
            "FUN_0800a154",
            "FUN_0800a168",
            "FUN_0800a18c",
            "FUN_0800a194",
            "FUN_0800a258",
            "FUN_0800a31c",
            "FUN_0800a3a0"
        ]
    ],
    "locked_functions": []
}