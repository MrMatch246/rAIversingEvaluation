{
    "functions": {
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "initialize_completed_flag_08000188",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000194) */\n\nundefined4 initialize_completed_flag_08000188(undefined4 input_param)\n\n{\n  if ((char)flag_variable == '\\0') {\n    flag_variable._0_1_ = '\\x01';\n  }\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000188": "initialize_completed_flag_08000188",
                "param_1": "input_param",
                "completed_8911": "flag_variable"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "concatenate_parameters_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b2) */\n\nundefined8 concatenate_parameters_080001ac(undefined4 first_parameter,undefined4 second_parameter)\n\n{\n  return CONCAT44(second_parameter,first_parameter);\n}\n\n",
            "renaming": {
                "FUN_080001ac": "concatenate_parameters_080001ac",
                "param_1": "first_parameter",
                "param_2": "second_parameter"
            },
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001c8": {
            "entrypoint": "0x080001c8",
            "current_name": "FUNC_080001c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001c8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001c8": "FUNC_080001c8"
            },
            "calling": [
                "coolant_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001d4": {
            "entrypoint": "0x080001d4",
            "current_name": "FUNC_080001d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001d4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d4": "FUNC_080001d4"
            },
            "calling": [
                "coolant_stop"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001e0": {
            "entrypoint": "0x080001e0",
            "current_name": "FUNC_080001e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001e0": "FUNC_080001e0"
            },
            "calling": [
                "coolant_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001ec": {
            "entrypoint": "0x080001ec",
            "current_name": "FUNC_080001ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001ec": "FUNC_080001ec"
            },
            "calling": [
                "coolant_stop"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001f8": {
            "entrypoint": "0x080001f8",
            "current_name": "initialize_coolant_system_080001f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_coolant_system_080001f8(void)\n\n{\n  coolant_mode = '\\0';\n  stop_coolant_flow();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001f8": "initialize_coolant_system_080001f8",
                "current_coolant_mode": "coolant_mode",
                "coolant_stop": "stop_coolant_flow"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "coolant_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000210": {
            "entrypoint": "0x08000210",
            "current_name": "turn_off_coolant_system_08000210",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid turnOffCoolantSystem_08000210(void)\n\n{\n  turnOffCoolantMist();\n  turnOffCoolantFlood();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000210": "turn_off_coolant_system_08000210",
                "coolant_mist_off": "turnOffCoolantMist",
                "coolant_flood_off": "turnOffCoolantFlood"
            },
            "calling": [
                "mc_reset",
                "coolant_run",
                "coolant_init"
            ],
            "called": [
                "coolant_mist_off",
                "coolant_flood_off"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000220": {
            "entrypoint": "0x08000220",
            "current_name": "set_coolant_mode_08000220",
            "code": "\nvoid setCoolantMode_08000220(uint8_t newMode)\n\n{\n  uint8_t localMode;\n  \n  if (newMode != currentMode) {\n    plan_synchronize();\n    if (newMode == '\\x01') {\n      coolant_flood_on();\n      currentMode = newMode;\n    }\n    else if (newMode == '\\x02') {\n      coolant_mist_on();\n      currentMode = newMode;\n    }\n    else {\n      coolant_stop();\n      currentMode = newMode;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000220": "set_coolant_mode_08000220",
                "mode": "newMode",
                "mode_local": "localMode",
                "current_coolant_mode": "currentMode"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "coolant_mist_on",
                "plan_synchronize",
                "coolant_flood_on",
                "coolant_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000268": {
            "entrypoint": "0x08000268",
            "current_name": "calculate_elapsed_time_since_startup_08000268",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint64_t calculateElapsedTimeSinceStartup_08000268(void)\n\n{\n  uint32_t currentTickValue;\n  \n  currentTickValue = HAL_GetTick();\n  return (uint64_t)((currentTickValue + 1) * 1000 - _DAT_e000e018 / 0xa8);\n}\n\n",
            "renaming": {
                "FUN_08000268": "calculate_elapsed_time_since_startup_08000268",
                "uVar1": "currentTickValue"
            },
            "calling": [
                "_delay_us"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002a0": {
            "entrypoint": "0x080002a0",
            "current_name": "delay_function_080002a0",
            "code": "\nvoid delayFunction_080002a0(uint milliseconds)\n\n{\n  uint milliseconds_local;\n  \n  HAL_Delay(milliseconds);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002a0": "delay_function_080002a0",
                "_ms": "milliseconds"
            },
            "calling": [
                "mc_dwell"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002b6": {
            "entrypoint": "0x080002b6",
            "current_name": "delay_execution_080002b6",
            "code": "\nvoid delayExecution_080002b6(uint microseconds)\n\n{\n  uint upperBits;\n  bool isTimeoutReached;\n  uint64_t currentTime;\n  uint64_t elapsedTime;\n  uint localMicroseconds;\n  uint64_t timeout;\n  \n  currentTime = get_currentmicrosecondsecs();\n  do {\n    elapsedTime = get_currentmicrosecondsecs();\n    upperBits = (uint)(elapsedTime >> 0x20);\n    timeout._0_4_ = (uint)(currentTime + microseconds);\n    timeout._4_4_ = (uint)(currentTime + microseconds >> 0x20);\n    isTimeoutReached = timeout._4_4_ <= upperBits;\n    if (upperBits == timeout._4_4_) {\n      isTimeoutReached = (uint)timeout <= (uint)elapsedTime;\n    }\n  } while (!isTimeoutReached);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002b6": "delay_execution_080002b6",
                "_us": "microseconds",
                "uVar1": "upperBits",
                "bVar2": "isTimeoutReached",
                "uVar3": "currentTime",
                "uVar4": "elapsedTime",
                "_us_local": "localMicroseconds"
            },
            "calling": [],
            "called": [
                "get_current_usecs"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002f0": {
            "entrypoint": "0x080002f0",
            "current_name": "initialize_eeprom_080002f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEEPROM_080002f0(void)\n\n{\n  memset(EEPROM_data,0xff,4);\n  EEPROM_ready = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002f0": "initialize_eeprom_080002f0",
                "eeprom_data": "EEPROM_data",
                "eeprom_ready": "EEPROM_ready"
            },
            "calling": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum",
                "eeprom_get_char",
                "memcpy_from_eeprom_with_checksum"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000310": {
            "entrypoint": "0x08000310",
            "current_name": "get_eeprom_data_08000310",
            "code": "\nchar getEepromData_08000310(uint address)\n\n{\n  uint localAddress;\n  \n  if (eeprom_ready == 0) {\n    eeprom_init();\n  }\n  return eeprom_data[address & 0x3ff];\n}\n\n",
            "renaming": {
                "FUN_08000310": "get_eeprom_data_08000310",
                "addr": "address",
                "addr_local": "localAddress"
            },
            "calling": [
                "read_global_settings",
                "memcpy_from_eeprom_with_checksum"
            ],
            "called": [
                "eeprom_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000340": {
            "entrypoint": "0x08000340",
            "current_name": "write_to_eeprom_08000340",
            "code": "\nvoid writeToEEPROM_08000340(uint address,uchar value)\n\n{\n  uchar localValue;\n  uint localAddress;\n  \n  if (eeprom_ready == 0) {\n    eeprom_init();\n  }\n  eeprom_data[address & 0x3ff] = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000340": "write_to_eeprom_08000340",
                "addr": "address",
                "new_value": "value",
                "new_value_local": "localValue",
                "addr_local": "localAddress"
            },
            "calling": [
                "write_global_settings",
                "memcpy_to_eeprom_with_checksum"
            ],
            "called": [
                "eeprom_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000374": {
            "entrypoint": "0x08000374",
            "current_name": "copy_memory_with_checksum_08000374",
            "code": "\nvoid copyMemoryWithChecksum_08000374(uint dst,char *src,uint numBytes)\n\n{\n  uint remainingBytes;\n  char *currentByte;\n  uint currentDst;\n  uchar checksum;\n  \n  checksum = '\\0';\n  remainingBytes = numBytes;\n  currentByte = src;\n  currentDst = dst;\n  if (eeprom_ready == 0) {\n    eeprom_init();\n    currentByte = src;\n    currentDst = dst;\n  }\n  for (; remainingBytes != 0; remainingBytes = remainingBytes - 1) {\n    checksum = (checksum != '\\0') + *currentByte;\n    eeprom_put_char(currentDst,*currentByte);\n    currentByte = currentByte + 1;\n    currentDst = currentDst + 1;\n  }\n  eeprom_put_char(currentDst,checksum);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000374": "copy_memory_with_checksum_08000374",
                "destination": "dst",
                "source": "src",
                "size": "numBytes",
                "size_local": "remainingBytes",
                "source_local": "currentByte",
                "destination_local": "currentDst"
            },
            "calling": [
                "write_global_settings",
                "settings_write_coord_data",
                "settings_store_startup_line"
            ],
            "called": [
                "eeprom_init",
                "eeprom_put_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003ec": {
            "entrypoint": "0x080003ec",
            "current_name": "validate_eeprom_data_080003ec",
            "code": "\nint validate_eeprom_data_080003ec(char *output,uint input,uint length)\n\n{\n  char current_char;\n  uint remaining_length;\n  uint current_index;\n  char *current_output;\n  uchar current_data;\n  uchar calculated_checksum;\n  \n  calculated_checksum = '\\0';\n  remaining_length = length;\n  current_index = input;\n  current_output = output;\n  if (is_eeprom_ready == 0) {\n    initialize_eeprom();\n    current_index = input;\n    current_output = output;\n  }\n  for (; remaining_length != 0; remaining_length = remaining_length - 1) {\n    current_char = read_eeprom_character(current_index);\n    calculated_checksum = current_char + (calculated_checksum != '\\0');\n    *current_output = current_char;\n    current_index = current_index + 1;\n    current_output = current_output + 1;\n  }\n  current_char = read_eeprom_character(current_index);\n  return (uint)((uint)calculated_checksum == (int)current_char);\n}\n\n",
            "renaming": {
                "FUN_080003ec": "validate_eeprom_data_080003ec",
                "destination": "output",
                "source": "input",
                "size": "length",
                "size_local": "remaining_length",
                "source_local": "current_index",
                "destination_local": "current_output",
                "data": "current_data",
                "checksum": "calculated_checksum",
                "eeprom_ready": "is_eeprom_ready",
                "eeprom_init": "initialize_eeprom",
                "eeprom_get_char": "read_eeprom_character",
                "cVar1": "current_char"
            },
            "calling": [
                "settings_read_startup_line",
                "read_global_settings",
                "settings_read_coord_data"
            ],
            "called": [
                "eeprom_init",
                "eeprom_get_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000478": {
            "entrypoint": "0x08000478",
            "current_name": "set_plane_axes_08000478",
            "code": "\nvoid setPlaneAxes_08000478(uint8_t newAxis0,uint8_t newAxis1,uint8_t newAxis2)\n\n{\n  uint8_t localAxis2;\n  uint8_t localAxis1;\n  uint8_t localAxis0;\n  \n  gc.plane_newAxis0 = newAxis0;\n  gc.plane_newAxis1 = newAxis1;\n  gc.plane_newAxis2 = newAxis2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000478": "set_plane_axes_08000478",
                "axis_0": "newAxis0",
                "axis_1": "newAxis1",
                "axis_2": "newAxis2",
                "axis_2_local": "localAxis2",
                "axis_1_local": "localAxis1",
                "axis_0_local": "localAxis0"
            },
            "calling": [
                "gc_execute_line",
                "gc_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004ac": {
            "entrypoint": "0x080004ac",
            "current_name": "initialize_printer_080004ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePrinter_080004ac(void)\n\n{\n  uint8_t coordDataStatus;\n  \n  memset(&gc,0,0x38);\n  gc.feed_rate = settings.default_feed_rate;\n  select_plane('\\0','\\x01','\\x02');\n  gc.absolute_mode = '\\x01';\n  coordDataStatus = settings_read_coord_data(gc.coord_select,gc.coord_system);\n  if (coordDataStatus == '\\0') {\n    report_status_message('\\n');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004ac": "initialize_printer_080004ac",
                "uVar1": "coordDataStatus"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "select_plane",
                "report_status_message",
                "settings_read_coord_data",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004fc": {
            "entrypoint": "0x080004fc",
            "current_name": "convert_to_position_080004fc",
            "code": "\nvoid convertToPosition_080004fc(int32_t x_input,int32_t y_input,int32_t z_input)\n\n{\n  undefined4 uVar1;\n  int32_t z_input_local;\n  int32_t y_input_local;\n  int32_t x_input_local;\n  \n  uVar1 = __floatsisf(x_input);\n  gc.position[0] = (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[0]);\n  uVar1 = __floatsisf(y_input);\n  gc.position[1] = (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[1]);\n  uVar1 = __floatsisf(z_input);\n  gc.position[2] = (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[2]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004fc": "convert_to_position_080004fc",
                "x": "x_input",
                "y": "y_input",
                "z": "z_input"
            },
            "calling": [
                "sys_sync_current_position"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fdiv"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800056c": {
            "entrypoint": "0x0800056c",
            "current_name": "convert_to_inches_0800056c",
            "code": "\nfloat convertToInches_0800056c(float inputValue)\n\n{\n  undefined4 conversionFactor;\n  undefined8 convertedValue;\n  float result;\n  \n  if (gc.inches_mode != '\\0') {\n    convertedValue = __aeabi_f2d(conversionFactor);\n    convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0x66666666,0x40396666);\n    inputValue = (float)__truncdfsf2((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20));\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_0800056c": "convert_to_inches_0800056c",
                "value": "inputValue",
                "in_r0": "conversionFactor",
                "uVar1": "convertedValue",
                "value_local": "result"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "__aeabi_f2d",
                "__muldf3",
                "__truncdfsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005b4": {
            "entrypoint": "0x080005b4",
            "current_name": "parse_gcode_080005b4",
            "code": "\nuint8_t parseGcode_080005b4(char *gcodeLine)\n\n{\n  uint8_t status;\n  int EFCgValueDCLYIM;\n  float valueFloat;\n  undefined4 LgValueUCTgValuePJFV;\n  undefined4 extraOutUint;\n  undefined4 extraOutUint1;\n  undefined4 extraOutUint2;\n  undefined4 extraOutUint3;\n  undefined4 extraOutUint4;\n  undefined4 extraOutUint5;\n  undefined4 extraOutUint6;\n  uint extraOutUint7;\n  undefined4 IFONOgValuegValueLKW;\n  undefined4 EPHVUYMDFextraOutUint9;\n  uint uVar6;\n  float fVar7;\n  float value_00;\n  undefined8 extraOutDouble1;\n  undefined8 KBBIIXWSgValueW;\n  undefined8 EPHVUYMDFextraOutDouble3;\n  undefined8 extraOutDouble4;\n  undefined8 extraOutDouble5;\n  undefined8 ZEWgValueVgValueBMRV;\n  undefined8 extraOutDouble7;\n  undefined8 extraOutDouble8;\n  undefined8 gValueFMVVOQYgValueF;\n  undefined8 extraOutDouble10;\n  undefined8 HAJJKYgValueMNQ;\n  undefined8 VXAOOXSPgValueK;\n  undefined8 extraOutDouble13;\n  undefined8 extraOutDouble14;\n  undefined8 extraOutDouble15;\n  undefined8 extraOutDouble16;\n  undefined8 extraOutDouble17;\n  undefined8 extraOutDouble18;\n  undefined8 extraOutDouble19;\n  float yCoordinate_00;\n  undefined8 extraOutDouble20;\n  undefined8 YgValueSMDCZHFL;\n  float exCoordinatetraout_s2;\n  float exCoordinatetraout_s2_00;\n  float exCoordinatetraout_s2_01;\n  float exCoordinatetraout_s2_02;\n  float exCoordinatetraout_s2_03;\n  float exCoordinatetraout_s2_04;\n  float exCoordinatetraout_s2_05;\n  float exCoordinatetraout_s2_06;\n  float exCoordinatetraout_s2_07;\n  float exCoordinatetraout_s2_08;\n  float exCoordinatetraout_s2_09;\n  float exCoordinatetraout_s2_10;\n  float exCoordinatetraout_s2_11;\n  float exCoordinatetraout_s2_12;\n  float exCoordinatetraout_s2_13;\n  float exCoordinatetraout_s2_14;\n  float exCoordinatetraout_s2_15;\n  float exCoordinatetraout_s2_16;\n  float exCoordinatetraout_s2_17;\n  float exCoordinatetraout_s3;\n  float exCoordinatetraout_s3_00;\n  float exCoordinatetraout_s3_01;\n  float exCoordinatetraout_s3_02;\n  float exCoordinatetraout_s3_03;\n  float exCoordinatetraout_s3_04;\n  float exCoordinatetraout_s3_05;\n  float exCoordinatetraout_s3_06;\n  float exCoordinatetraout_s3_07;\n  float exCoordinatetraout_s3_08;\n  float exCoordinatetraout_s3_09;\n  float exCoordinatetraout_s3_10;\n  float exCoordinatetraout_s3_11;\n  float exCoordinatetraout_s3_12;\n  float exCoordinatetraout_s3_13;\n  float exCoordinatetraout_s3_14;\n  float exCoordinatetraout_s3_15;\n  float exCoordinatetraout_s3_16;\n  float exCoordinatetraout_s3_17;\n  undefined8 uVar8;\n  undefined4 CYgValueAHVIZCK;\n  undefined4 stackVar2;\n  undefined4 stackVar3;\n  undefined4 ZLZQgValueCPUgValueL;\n  char *localLine;\n  float coordinateData2 [3];\n  float coordinateData1 [3];\n  float QQDLKMCgValueTV [3];\n  float offsetData [3];\n  float OZDJgValueJHXLR [3];\n  float value;\n  char commandLetter;\n  uint8_t characterCounter;\n  float yCoordinate;\n  float xCoordinate;\n  uint8_t isClockwise;\n  float hDividedByD;\n  uint8_t i3;\n  uint8_t WNQIYPYXgValueY;\n  uint8_t i1;\n  uint8_t i;\n  uint8_t l;\n  float r;\n  float p;\n  uint8_t groupNumber;\n  uint8_t RQTHgValueUNEUS;\n  uint8_t absoluteOverride;\n  float inverseFeedRate;\n  uint8_t axisWords;\n  uint16_t modalGroupWords;\n  int intValue;\n  \n  if (sysState == '\\xCoordinate06') {\n    status = '\\f';\n  }\n  else {\n    characterCounter = '\\0';\n    modalGroupWords = 0;\n    axisWords = '\\0';\n    inverseFeedRate = -1.0;\n    absoluteOverride = '\\0';\n    RQTHgValueUNEUS = '\\0';\n    memset(OZDJgValueJHXLR,0,0xCoordinatec);\n    memset(offsetData,0,0xCoordinatec);\n    gcStatusCode = '\\0';\n    groupNumber = '\\0';\n    while (EFCgValueDCLYIM = nexCoordinatet_statement(&commandLetter,&value,gcodeLine,&characterCounter), EFCgValueDCLYIM != 0) {\n      LgValueUCTgValuePJFV = __aeabi_f2d(value);\n      trunc((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n      intValue = __aeabi_d2iz(LgValueUCTgValuePJFV,extraOutUint1);\n      if (commandLetter == 'gValue') {\n        switch(intValue) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0xCoordinate50:\n          groupNumber = '\\xCoordinate02';\n          break;\n        case 4:\n        case 10:\n        case 0xCoordinate1c:\n        case 0xCoordinate1e:\n        case 0xCoordinate35:\n        case 0xCoordinate5c:\n          groupNumber = '\\xCoordinate01';\n          break;\n        case 0xCoordinate11:\n        case 0xCoordinate12:\n        case 0xCoordinate13:\n          groupNumber = '\\xCoordinate03';\n          break;\n        case 0xCoordinate14:\n        case 0xCoordinate15:\n          groupNumber = '\\a';\n          break;\n        case 0xCoordinate36:\n        case 0xCoordinate37:\n        case 0xCoordinate38:\n        case 0xCoordinate39:\n        case 0xCoordinate3a:\n        case 0xCoordinate3b:\n          groupNumber = '\\t';\n          break;\n        case 0xCoordinate5a:\n        case 0xCoordinate5b:\n          groupNumber = '\\xCoordinate04';\n          break;\n        case 0xCoordinate5d:\n        case 0xCoordinate5e:\n          groupNumber = '\\xCoordinate06';\n        }\n        switch(intValue) {\n        case 0:\n          gcMotionMode = '\\0';\n          break;\n        case 1:\n          gcMotionMode = '\\xCoordinate01';\n          break;\n        case 2:\n          gcMotionMode = '\\xCoordinate02';\n          break;\n        case 3:\n          gcMotionMode = '\\xCoordinate03';\n          break;\n        case 4:\n          RQTHgValueUNEUS = '\\xCoordinate01';\n          break;\n        default:\n          gcStatusCode = '\\xCoordinate03';\n          break;\n        case 10:\n          RQTHgValueUNEUS = '\\xCoordinate02';\n          break;\n        case 0xCoordinate11:\n          select_plane('\\0','\\xCoordinate01','\\xCoordinate02');\n          break;\n        case 0xCoordinate12:\n          select_plane('\\xCoordinate02','\\0','\\xCoordinate01');\n          break;\n        case 0xCoordinate13:\n          select_plane('\\xCoordinate01','\\xCoordinate02','\\0');\n          break;\n        case 0xCoordinate14:\n          gcInchesMode = '\\xCoordinate01';\n          break;\n        case 0xCoordinate15:\n          gcInchesMode = '\\0';\n          break;\n        case 0xCoordinate1c:\n        case 0xCoordinate1e:\n          LgValueUCTgValuePJFV = __aeabi_fmul(value,0xCoordinate41200000);\n          LgValueUCTgValuePJFV = __aeabi_f2d(LgValueUCTgValuePJFV);\n          trunc((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n          intValue = __aeabi_d2iz(LgValueUCTgValuePJFV,extraOutUint2);\n          switch(intValue) {\n          case 0xCoordinate118:\n            RQTHgValueUNEUS = '\\xCoordinate03';\n            break;\n          case 0xCoordinate119:\n            RQTHgValueUNEUS = '\\xCoordinate04';\n            break;\n          default:\n            gcStatusCode = '\\xCoordinate03';\n            break;\n          case 300:\n            RQTHgValueUNEUS = '\\xCoordinate05';\n            break;\n          case 0xCoordinate12d:\n            RQTHgValueUNEUS = '\\xCoordinate06';\n          }\n          break;\n        case 0xCoordinate35:\n          absoluteOverride = '\\xCoordinate01';\n          break;\n        case 0xCoordinate36:\n        case 0xCoordinate37:\n        case 0xCoordinate38:\n        case 0xCoordinate39:\n        case 0xCoordinate3a:\n        case 0xCoordinate3b:\n          TLRVSMZgValueAQ = (char)intValue + 0xCoordinateca;\n          break;\n        case 0xCoordinate50:\n          gcMotionMode = '\\xCoordinate04';\n          break;\n        case 0xCoordinate5a:\n          gcAbsoluteMode = '\\xCoordinate01';\n          break;\n        case 0xCoordinate5b:\n          gcAbsoluteMode = '\\0';\n          break;\n        case 0xCoordinate5c:\n          LgValueUCTgValuePJFV = __aeabi_fmul(value,0xCoordinate41200000);\n          LgValueUCTgValuePJFV = __aeabi_f2d(LgValueUCTgValuePJFV);\n          trunc((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n          intValue = __aeabi_d2iz(LgValueUCTgValuePJFV,extraOutUint3);\n          if (intValue == 0xCoordinate398) {\n            RQTHgValueUNEUS = '\\a';\n          }\n          else if (intValue == 0xCoordinate399) {\n            RQTHgValueUNEUS = '\\b';\n          }\n          else {\n            gcStatusCode = '\\xCoordinate03';\n          }\n          break;\n        case 0xCoordinate5d:\n          SgValueXgValueBVYXEF = '\\xCoordinate01';\n          break;\n        case 0xCoordinate5e:\n          SgValueXgValueBVYXEF = '\\0';\n        }\n      }\n      else if (commandLetter == 'M') {\n        if (intValue == 0xCoordinate1e) {\nLAB_08000b96:\n          groupNumber = '\\xCoordinate05';\n        }\n        else if (intValue < 0xCoordinate1f) {\n          if (intValue < 3) {\n            if (-1 < intValue) goto LAB_08000b96;\n          }\n          else if (intValue - 3U < 3) {\n            groupNumber = '\\b';\n          }\n        }\n        switch(intValue) {\n        case 0:\n          gcProgramFlow = '\\xCoordinate01';\n          break;\n        case 1:\n          break;\n        case 2:\n        case 0xCoordinate1e:\n          gcProgramFlow = '\\xCoordinate02';\n          break;\n        case 3:\n          gcSpindleDirection = '\\xCoordinate01';\n          break;\n        case 4:\n          gcSpindleDirection = -1;\n          break;\n        case 5:\n          gcSpindleDirection = '\\0';\n          break;\n        default:\n          gcStatusCode = '\\xCoordinate03';\n          break;\n        case 7:\n          gValuegValueUEUWTDDH = '\\xCoordinate02';\n          break;\n        case 8:\n          gValuegValueUEUWTDDH = '\\xCoordinate01';\n          break;\n        case 9:\n          gValuegValueUEUWTDDH = '\\0';\n        }\n      }\n      if (groupNumber != '\\0') {\n        if (((int)(uint)modalGroupWords >> groupNumber & 1U) == 0) {\n          modalGroupWords = modalGroupWords | (ushort)(1 << groupNumber);\n        }\n        else {\n          gcStatusCode = '\\xCoordinate05';\n        }\n        groupNumber = '\\0';\n      }\n    }\n    status = gcStatusCode;\n    if (gcStatusCode == '\\0') {\n      p = 0.0;\n      r = 0.0;\n      l = '\\0';\n      characterCounter = '\\0';\nswitchD_08000d18_caseD_47:\n      EFCgValueDCLYIM = nexCoordinatet_statement(&commandLetter,&value,gcodeLine,&characterCounter);\n      if (EFCgValueDCLYIM != 0) {\n        fVar7 = (float)extraOutDouble1;\n        switch(commandLetter) {\n        case 'F':\n          EFCgValueDCLYIM = __aeabi_fcmple(value,0);\n          if (EFCgValueDCLYIM != 0) {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          if (SgValueXgValueBVYXEF == '\\0') {\n            fVar7 = value;\n            to_millimeters(value_00);\n            gcFeedRate = fVar7;\n          }\n          else {\n            fVar7 = value;\n            to_millimeters(value_00);\n            inverseFeedRate = fVar7;\n          }\n          break;\n        case 'gValue':\n        case 'M':\n        case 'N':\n          break;\n        default:\n          gcStatusCode = '\\xCoordinate03';\n          break;\n        case 'I':\n        case 'J':\n        case 'K':\n          uVar6 = (uint)(byCoordinatete)commandLetter;\n          valueFloat = value;\n          to_millimeters(fVar7);\n          offsetData[uVar6 - 0xCoordinate49] = valueFloat;\n          break;\n        case 'L':\n          LgValueUCTgValuePJFV = __aeabi_f2d(value);\n          trunc((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n          l = __aeabi_d2uiz(LgValueUCTgValuePJFV,extraOutUint4);\n          break;\n        case 'P':\n          p = value;\n          break;\n        case 'R':\n          valueFloat = value;\n          to_millimeters(fVar7);\n          r = valueFloat;\n          break;\n        case 'S':\n          EFCgValueDCLYIM = __aeabi_fcmplt(value,0);\n          if (EFCgValueDCLYIM != 0) {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          break;\n        case 'T':\n          EFCgValueDCLYIM = __aeabi_fcmplt(value,0);\n          if (EFCgValueDCLYIM != 0) {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          LgValueUCTgValuePJFV = __aeabi_f2d(value);\n          trunc((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n          gcTool = __aeabi_d2uiz(LgValueUCTgValuePJFV,extraOutUint5);\n          break;\n        case 'X':\n          OZDJgValueJHXLR[0] = value;\n          to_millimeters(fVar7);\n          axisWords = axisWords | 1;\n          break;\n        case 'Y':\n          OZDJgValueJHXLR[1] = value;\n          to_millimeters(fVar7);\n          axisWords = axisWords | 2;\n          break;\n        case 'Z':\n          OZDJgValueJHXLR[2] = value;\n          to_millimeters(fVar7);\n          axisWords = axisWords | 4;\n        }\n        goto switchD_08000d18_caseD_47;\n      }\n      status = gcStatusCode;\n      if (gcStatusCode == '\\0') {\n        uVar8 = extraOutDouble1;\n        fVar7 = exCoordinatetraout_s2;\n        valueFloat = exCoordinatetraout_s3;\n        if (sysState != '\\a') {\n          spindle_run(gcSpindleDirection);\n          coolant_run(gValuegValueUEUWTDDH);\n          uVar8 = KBBIIXWSgValueW;\n          fVar7 = exCoordinatetraout_s2_00;\n          valueFloat = exCoordinatetraout_s3_00;\n        }\n        if ((modalGroupWords & 0xCoordinate200) != 0) {\n          status = settings_read_QQDLKMCgValueTV(TLRVSMZgValueAQ,QQDLKMCgValueTV);\n          if (status == '\\0') {\n            return '\\n';\n          }\n          BTTZgValueXHKMU[0] = QQDLKMCgValueTV[0];\n          BTTZgValueXHKMU[1] = QQDLKMCgValueTV[1];\n          BTTZgValueXHKMU[2] = QQDLKMCgValueTV[2];\n          uVar8 = EPHVUYMDFextraOutDouble3;\n          fVar7 = exCoordinatetraout_s2_01;\n          valueFloat = exCoordinatetraout_s3_01;\n        }\n        switch(RQTHgValueUNEUS) {\n        case '\\xCoordinate01':\n          EFCgValueDCLYIM = __aeabi_fcmplt(p,0);\n          uVar8 = extraOutDouble4;\n          fVar7 = exCoordinatetraout_s2_02;\n          valueFloat = exCoordinatetraout_s3_02;\n          if (EFCgValueDCLYIM == 0) {\n            if (sysState != '\\a') {\n              mc_dwell((float)extraOutDouble4);\n              uVar8 = extraOutDouble5;\n              fVar7 = exCoordinatetraout_s2_03;\n              valueFloat = exCoordinatetraout_s3_03;\n            }\n          }\n          else {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          break;\n        case '\\xCoordinate02':\n          LgValueUCTgValuePJFV = __aeabi_f2d(p);\n          trunc((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n          intValue = __aeabi_d2iz(LgValueUCTgValuePJFV,extraOutUint6);\n          uVar8 = ZEWgValueVgValueBMRV;\n          fVar7 = exCoordinatetraout_s2_04;\n          valueFloat = exCoordinatetraout_s3_04;\n          if ((((l == '\\xCoordinate02') || (l == '\\xCoordinate14')) && (-1 < intValue)) && (intValue < 7)) {\n            if ((axisWords == '\\0') && (l == '\\xCoordinate02')) {\n              gcStatusCode = '\\xCoordinate06';\n            }\n            else {\n              if (intValue < 1) {\n                intValue = (int)TLRVSMZgValueAQ;\n              }\n              else {\n                intValue = intValue + -1;\n              }\n              status = settings_read_QQDLKMCgValueTV((uint8_t)intValue,coordinateData2);\n              if (status == '\\0') {\n                return '\\n';\n              }\n              for (i = '\\0'; i < 3; i = i + '\\xCoordinate01') {\n                if (((int)(uint)axisWords >> i & 1U) != 0) {\n                  if (l == '\\xCoordinate14') {\n                    uVar6 = (uint)i;\n                    fVar7 = (float)__aeabi_fsub(gc.position[i],OZDJgValueJHXLR[i]);\n                    coordinateData2[uVar6] = fVar7;\n                  }\n                  else {\n                    coordinateData2[i] = OZDJgValueJHXLR[i];\n                  }\n                }\n              }\n              settings_write_QQDLKMCgValueTV((uint8_t)intValue,coordinateData2);\n              uVar8 = extraOutDouble7;\n              fVar7 = exCoordinatetraout_s2_05;\n              valueFloat = exCoordinatetraout_s3_05;\n              if (intValue == (uint)TLRVSMZgValueAQ) {\n                BTTZgValueXHKMU[0] = coordinateData2[0];\n                BTTZgValueXHKMU[1] = coordinateData2[1];\n                BTTZgValueXHKMU[2] = coordinateData2[2];\n              }\n            }\n          }\n          else {\n            gcStatusCode = '\\xCoordinate03';\n          }\n          axisWords = '\\0';\n          break;\n        case '\\xCoordinate03':\n        case '\\xCoordinate05':\n          if (axisWords != '\\0') {\n            for (i1 = '\\0'; i1 < 3; i1 = i1 + '\\xCoordinate01') {\n              if (((int)(uint)axisWords >> i1 & 1U) == 0) {\n                OZDJgValueJHXLR[i1] = gc.position[i1];\n              }\n              else if (gcAbsoluteMode == '\\0') {\n                uVar6 = (uint)i1;\n                fVar7 = (float)__addsf3(OZDJgValueJHXLR[i1],gc.position[i1]);\n                OZDJgValueJHXLR[uVar6] = fVar7;\n                uVar8 = gValueFMVVOQYgValueF;\n                fVar7 = exCoordinatetraout_s2_07;\n                valueFloat = exCoordinatetraout_s3_07;\n              }\n              else {\n                fVar7 = OZDJgValueJHXLR[i1];\n                LgValueUCTgValuePJFV = __addsf3(BTTZgValueXHKMU[i1],CHYgValueNRTVXU[i1]);\n                uVar6 = (uint)i1;\n                fVar7 = (float)__addsf3(fVar7,LgValueUCTgValuePJFV);\n                OZDJgValueJHXLR[uVar6] = fVar7;\n                uVar8 = extraOutDouble8;\n                fVar7 = exCoordinatetraout_s2_06;\n                valueFloat = exCoordinatetraout_s3_06;\n              }\n            }\n            mc_gcodeLine((float)uVar8,(float)((ulonglong)uVar8 >> 0xCoordinate20),fVar7,valueFloat,SUB41(OZDJgValueJHXLR[0],0));\n          }\n          if (RQTHgValueUNEUS == '\\xCoordinate05') {\n            status = settings_read_QQDLKMCgValueTV('\\a',coordinateData1);\n            uVar8 = extraOutDouble10;\n            fVar7 = exCoordinatetraout_s2_08;\n            valueFloat = exCoordinatetraout_s3_08;\n            if (status == '\\0') {\n              return '\\n';\n            }\n          }\n          else {\n            status = settings_read_QQDLKMCgValueTV('\\xCoordinate06',coordinateData1);\n            uVar8 = HAJJKYgValueMNQ;\n            fVar7 = exCoordinatetraout_s2_09;\n            valueFloat = exCoordinatetraout_s3_09;\n            if (status == '\\0') {\n              return '\\n';\n            }\n          }\n          CYgValueAHVIZCK = 0;\n          mc_gcodeLine((float)uVar8,(float)((ulonglong)uVar8 >> 0xCoordinate20),fVar7,valueFloat,\n                  SUB41(coordinateData1[0],0));\n          gc.position[0] = coordinateData1[0];\n          gc.position[1] = coordinateData1[1];\n          gc.position[2] = coordinateData1[2];\n          axisWords = '\\0';\n          uVar8 = VXAOOXSPgValueK;\n          fVar7 = exCoordinatetraout_s2_10;\n          valueFloat = exCoordinatetraout_s3_10;\n          break;\n        case '\\xCoordinate04':\n        case '\\xCoordinate06':\n          if (RQTHgValueUNEUS == '\\xCoordinate06') {\n            settings_write_QQDLKMCgValueTV('\\a',gc.position);\n            uVar8 = extraOutDouble13;\n            fVar7 = exCoordinatetraout_s2_11;\n            valueFloat = exCoordinatetraout_s3_11;\n          }\n          else {\n            settings_write_QQDLKMCgValueTV('\\xCoordinate06',gc.position);\n            uVar8 = extraOutDouble14;\n            fVar7 = exCoordinatetraout_s2_12;\n            valueFloat = exCoordinatetraout_s3_12;\n          }\n          break;\n        case '\\a':\n          if (axisWords == '\\0') {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          else {\n            for (WNQIYPYXgValueY = '\\0'; WNQIYPYXgValueY < 3; WNQIYPYXgValueY = WNQIYPYXgValueY + '\\xCoordinate01') {\n              if (((int)(uint)axisWords >> WNQIYPYXgValueY & 1U) != 0) {\n                LgValueUCTgValuePJFV = __aeabi_fsub(gc.position[WNQIYPYXgValueY],BTTZgValueXHKMU[WNQIYPYXgValueY]);\n                uVar6 = (uint)WNQIYPYXgValueY;\n                fVar7 = (float)__aeabi_fsub(LgValueUCTgValuePJFV,OZDJgValueJHXLR[WNQIYPYXgValueY]);\n                CHYgValueNRTVXU[uVar6] = fVar7;\n                uVar8 = extraOutDouble15;\n                fVar7 = exCoordinatetraout_s2_13;\n                valueFloat = exCoordinatetraout_s3_13;\n              }\n            }\n          }\n          axisWords = '\\0';\n          break;\n        case '\\b':\n          memset(CHYgValueNRTVXU,0,0xCoordinatec);\n          uVar8 = extraOutDouble16;\n          fVar7 = exCoordinatetraout_s2_14;\n          valueFloat = exCoordinatetraout_s3_14;\n        }\n        if (((modalGroupWords & 4) != 0) || (axisWords != '\\0')) {\n          if ((SgValueXgValueBVYXEF != '\\0') &&\n             ((EFCgValueDCLYIM = __aeabi_fcmplt(inverseFeedRate,0), uVar8 = extraOutDouble17,\n              fVar7 = exCoordinatetraout_s2_15, valueFloat = exCoordinatetraout_s3_15, EFCgValueDCLYIM != 0 &&\n              (gcMotionMode != '\\xCoordinate04')))) {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          if (((absoluteOverride != '\\0') && (gcMotionMode != '\\0')) &&\n             (gcMotionMode != '\\xCoordinate01')) {\n            gcStatusCode = '\\xCoordinate06';\n          }\n          if (gcStatusCode != '\\0') {\n            return gcStatusCode;\n          }\n          for (i3 = '\\0'; i3 < 3; i3 = i3 + '\\xCoordinate01') {\n            if (((int)(uint)axisWords >> i3 & 1U) == 0) {\n              OZDJgValueJHXLR[i3] = gc.position[i3];\n            }\n            else if (absoluteOverride == '\\0') {\n              if (gcAbsoluteMode == '\\0') {\n                uVar6 = (uint)i3;\n                fVar7 = (float)__addsf3(OZDJgValueJHXLR[i3],gc.position[i3]);\n                OZDJgValueJHXLR[uVar6] = fVar7;\n                uVar8 = extraOutDouble19;\n                fVar7 = exCoordinatetraout_s2_17;\n                valueFloat = exCoordinatetraout_s3_17;\n              }\n              else {\n                fVar7 = OZDJgValueJHXLR[i3];\n                LgValueUCTgValuePJFV = __addsf3(BTTZgValueXHKMU[i3],CHYgValueNRTVXU[i3]);\n                uVar6 = (uint)i3;\n                fVar7 = (float)__addsf3(fVar7,LgValueUCTgValuePJFV);\n                OZDJgValueJHXLR[uVar6] = fVar7;\n                uVar8 = extraOutDouble18;\n                fVar7 = exCoordinatetraout_s2_16;\n                valueFloat = exCoordinatetraout_s3_16;\n              }\n            }\n          }\n          if (gcMotionMode < 5) {\n            yCoordinate_00 = (float)((ulonglong)uVar8 >> 0xCoordinate20);\n            switch(gcMotionMode) {\n            case '\\0':\n              if (axisWords == '\\0') {\n                gcStatusCode = '\\xCoordinate06';\n              }\n              else {\n                mc_gcodeLine((float)uVar8,yCoordinate_00,fVar7,valueFloat,SUB41(OZDJgValueJHXLR[0],0));\n              }\n              break;\n            case '\\xCoordinate01':\n              if (axisWords == '\\0') {\n                gcStatusCode = '\\xCoordinate06';\n              }\n              else {\n                mc_gcodeLine((float)uVar8,yCoordinate_00,fVar7,valueFloat,SUB41(OZDJgValueJHXLR[0],0));\n              }\n              break;\n            default:\n              axisWords = axisWords & ~(byCoordinatete)(1 << gc.plane_axCoordinateis_2);\n              if ((axisWords == 0) ||\n                 (((EFCgValueDCLYIM = __aeabi_fcmpeq(r,0), EFCgValueDCLYIM != 0 &&\n                   (EFCgValueDCLYIM = __aeabi_fcmpeq(offsetData[gc.plane_axCoordinateis_0],0), EFCgValueDCLYIM != 0)) &&\n                  (EFCgValueDCLYIM = __aeabi_fcmpeq(offsetData[gc.plane_axCoordinateis_1],0), EFCgValueDCLYIM != 0)))) {\n                gcStatusCode = '\\xCoordinate06';\n              }\n              else {\n                EFCgValueDCLYIM = __aeabi_fcmpeq(r,0);\n                if (EFCgValueDCLYIM == 0) {\n                  xCoordinate = (float)__aeabi_fsub(OZDJgValueJHXLR[gc.plane_axCoordinateis_0],gc.position[gc.plane_axCoordinateis_0]);\n                  yCoordinate = (float)__aeabi_fsub(OZDJgValueJHXLR[gc.plane_axCoordinateis_1],gc.position[gc.plane_axCoordinateis_1]);\n                  memset(offsetData,0,0xCoordinatec);\n                  LgValueUCTgValuePJFV = __aeabi_fmul(r,0xCoordinate40800000);\n                  LgValueUCTgValuePJFV = __aeabi_fmul(LgValueUCTgValuePJFV,r);\n                  extraOutUint = __aeabi_fmul(xCoordinate,xCoordinate);\n                  LgValueUCTgValuePJFV = __aeabi_fsub(LgValueUCTgValuePJFV,extraOutUint);\n                  extraOutUint = __aeabi_fmul(yCoordinate,yCoordinate);\n                  hDividedByD = (float)__aeabi_fsub(LgValueUCTgValuePJFV,extraOutUint);\n                  EFCgValueDCLYIM = __aeabi_fcmplt(hDividedByD,0);\n                  if (EFCgValueDCLYIM != 0) {\n                    gcStatusCode = '\\xCoordinate04';\n                    return '\\xCoordinate04';\n                  }\n                  LgValueUCTgValuePJFV = __aeabi_f2d(hDividedByD);\n                  sqrt((double)CONCAT44(stackVar2,CYgValueAHVIZCK));\n                  extraOutUint = __aeabi_f2d(xCoordinate);\n                  __aeabi_f2d(yCoordinate);\n                  hyCoordinatepot((double)CONCAT44(stackVar2,CYgValueAHVIZCK),\n                        (double)CONCAT44(ZLZQgValueCPUgValueL,stackVar3));\n                  uVar8 = __divdf3(LgValueUCTgValuePJFV,extraOutUint7 ^ 0xCoordinate80000000,extraOutUint,IFONOgValuegValueLKW);\n                  hDividedByD = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0xCoordinate20));\n                  if (gcMotionMode == '\\xCoordinate03') {\n                    hDividedByD = (float)((uint)hDividedByD ^ 0xCoordinate80000000);\n                  }\n                  EFCgValueDCLYIM = __aeabi_fcmplt(r,0);\n                  if (EFCgValueDCLYIM != 0) {\n                    hDividedByD = (float)((uint)hDividedByD ^ 0xCoordinate80000000);\n                    r = (float)((uint)r ^ 0xCoordinate80000000);\n                  }\n                  LgValueUCTgValuePJFV = __aeabi_fmul(yCoordinate,hDividedByD);\n                  LgValueUCTgValuePJFV = __aeabi_fsub(xCoordinate,LgValueUCTgValuePJFV);\n                  uVar6 = (uint)gc.plane_axCoordinateis_0;\n                  fVar7 = (float)__aeabi_fmul(LgValueUCTgValuePJFV,0xCoordinate3f000000);\n                  offsetData[uVar6] = fVar7;\n                  LgValueUCTgValuePJFV = __aeabi_fmul(xCoordinate,hDividedByD);\n                  LgValueUCTgValuePJFV = __addsf3(LgValueUCTgValuePJFV,yCoordinate);\n                  uVar6 = (uint)gc.plane_axCoordinateis_1;\n                  fVar7 = (float)__aeabi_fmul(LgValueUCTgValuePJFV,0xCoordinate3f000000);\n                  offsetData[uVar6] = fVar7;\n                  uVar8 = extraOutDouble20;\n                }\n                else {\n                  LgValueUCTgValuePJFV = __aeabi_f2d(offsetData[gc.plane_axCoordinateis_0]);\n                  __aeabi_f2d(offsetData[gc.plane_axCoordinateis_1]);\n                  hyCoordinatepot((double)CONCAT44(stackVar2,CYgValueAHVIZCK),\n                        (double)CONCAT44(ZLZQgValueCPUgValueL,stackVar3));\n                  r = (float)__truncdfsf2(LgValueUCTgValuePJFV,EPHVUYMDFextraOutUint9);\n                  uVar8 = YgValueSMDCZHFL;\n                }\n                isClockwise = gcMotionMode == '\\xCoordinate02';\n                fVar7 = inverseFeedRate;\n                if (SgValueXgValueBVYXEF == '\\0') {\n                  fVar7 = gcFeedRate;\n                }\n                mc_arc(gc.position,OZDJgValueJHXLR,offsetData,gc.plane_axCoordinateis_0,gc.plane_axCoordinateis_1,gc.plane_axCoordinateis_2,\n                       (float)uVar8,SUB41(fVar7,0),(float)((ulonglong)uVar8 >> 0xCoordinate20),\n                       SgValueXgValueBVYXEF);\n              }\n              break;\n            case '\\xCoordinate04':\n              if (axisWords != '\\0') {\n                gcStatusCode = '\\xCoordinate06';\n              }\n            }\n          }\n          if (gcStatusCode != '\\0') {\n            return gcStatusCode;\n          }\n          gc.position[0] = OZDJgValueJHXLR[0];\n          gc.position[1] = OZDJgValueJHXLR[1];\n          gc.position[2] = OZDJgValueJHXLR[2];\n        }\n        status = gcStatusCode;\n        if (gcProgramFlow != '\\0') {\n          plan_syCoordinatenchronize();\n          sysAutoStart = '\\0';\n          if (gcProgramFlow == '\\xCoordinate02') {\n            mc_reset();\n            status = gcStatusCode;\n          }\n          else {\n            gcProgramFlow = '\\0';\n            status = gcStatusCode;\n          }\n        }\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080005b4": "parse_gcode_080005b4",
                "line": "gcodeLine",
                "uVar1": "status",
                "iVar2": "result",
                "fVar3": "valueFloat",
                "uVar4": "valueUint",
                "uVar5": "extraOutUint",
                "extraout_r1": "extraOutUint1",
                "extraout_r1_00": "extraOutUint2",
                "extraout_r1_01": "extraOutUint3",
                "extraout_r1_02": "extraOutUint4",
                "extraout_r1_03": "extraOutUint5",
                "extraout_r1_04": "extraOutUint6",
                "extraout_r1_05": "extraOutUint7",
                "extraout_r1_06": "extraOutUint8",
                "extraout_r1_07": "extraOutUint9",
                "extraout_d0": "extraOutDouble1",
                "extraout_d0_00": "extraOutDouble2",
                "extraout_d0_01": "extraOutDouble3",
                "extraout_d0_02": "extraOutDouble4",
                "extraout_d0_03": "extraOutDouble5",
                "extraout_d0_04": "extraOutDouble6",
                "extraout_d0_05": "extraOutDouble7",
                "extraout_d0_06": "extraOutDouble8",
                "extraout_d0_07": "extraOutDouble9",
                "extraout_d0_08": "extraOutDouble10",
                "extraout_d0_09": "extraOutDouble11",
                "extraout_d0_10": "extraOutDouble12",
                "extraout_d0_11": "extraOutDouble13",
                "extraout_d0_12": "extraOutDouble14",
                "extraout_d0_13": "extraOutDouble15",
                "extraout_d0_14": "extraOutDouble16",
                "extraout_d0_15": "extraOutDouble17",
                "extraout_d0_16": "extraOutDouble18",
                "extraout_d0_17": "extraOutDouble19",
                "extraout_d0_18": "extraOutDouble20",
                "extraout_d0_19": "extraOutDouble21",
                "in_stack_ffffff48": "stackVar1",
                "in_stack_ffffff4c": "stackVar2",
                "in_stack_ffffff50": "stackVar3",
                "in_stack_ffffff54": "stackVar4",
                "line_local": "localLine",
                "coord_data_2": "coordinateData2",
                "coord_data_1": "coordinateData1",
                "coord_data": "coordinateData",
                "offset": "offsetData",
                "target": "targetData",
                "letter": "commandLetter",
                "char_counter": "characterCounter",
                "y": "yCoordinate",
                "x": "xCoordinate",
                "isclockwise": "isClockwise",
                "h_x2_div_d": "hDividedByD",
                "i_3": "i3",
                "i_2": "i2",
                "i_1": "i1",
                "group_number": "groupNumber",
                "non_modal_action": "nonModalAction",
                "absolute_override": "absoluteOverride",
                "inverse_feed_rate": "inverseFeedRate",
                "axis_words": "axisWords",
                "modal_group_words": "modalGroupWords",
                "int_value": "intValue",
                "sys.state": "sysState",
                "gc.status_code": "gcStatusCode",
                "gc.motion_mode": "gcMotionMode",
                "gc.inches_mode": "gcInchesMode",
                "gc.tool": "gcTool",
                "gc.coord_select": "gcCoordSelect",
                "gc.absolute_mode": "gcAbsoluteMode",
                "gc.coord_system": "gcCoordinateSystem",
                "gc.coord_offset": "gcCoordinateOffset",
                "gc.feed_rate": "gcFeedRate",
                "gc.spindle_direction": "gcSpindleDirection",
                "gc.coolant_mode": "gcCoolantMode",
                "gc.inverse_feed_rate_mode": "gcInverseFeedRateMode",
                "gc.program_flow": "gcProgramFlow",
                "sys.auto_start": "sysAutoStart",
                "G": "gValue"
            },
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "called": [
                "__truncdfsf2",
                "settings_write_coord_data",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fcmple",
                "__aeabi_fcmplt",
                "__divdf3",
                "select_plane",
                "trunc",
                "plan_synchronize",
                "to_millimeters",
                "sqrt",
                "settings_read_coord_data",
                "mc_reset",
                "mc_line",
                "coolant_run",
                "next_statement",
                "__aeabi_fsub",
                "__addsf3",
                "mc_dwell",
                "hypot",
                "mc_arc",
                "__aeabi_fmul",
                "__aeabi_d2iz",
                "memset",
                "__aeabi_fcmpeq",
                "spindle_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800184c": {
            "entrypoint": "0x0800184c",
            "current_name": "extract_letter_and_float_0800184c",
            "code": "\nint extractLetterAndFloat_0800184c(char *letter_ptr,float *float_ptr,char *string,uint8_t *char_counter_ptr)\n\n{\n  int result;\n  uint8_t *char_counter;\n  char *line;\n  float *float_ptr;\n  char *letter;\n  \n  if (string[*char_counter_ptr] == '\\0') {\n    result = 0;\n  }\n  else {\n    *letter_ptr = string[*char_counter_ptr];\n    if (((byte)*letter_ptr < 0x41) || (0x5a < (byte)*letter_ptr)) {\n      status_code = '\\x02';\n      result = 0;\n    }\n    else {\n      *char_counter_ptr = *char_counter_ptr + '\\x01';\n      result = read_float(string,char_counter_ptr,float_ptr);\n      if (result == 0) {\n        status_code = '\\x01';\n        result = 0;\n      }\n      else {\n        result = 1;\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800184c": "extract_letter_and_float_0800184c",
                "letter": "letter_ptr",
                "line": "string",
                "char_counter": "char_counter_ptr",
                "char_counter_local": "char_counter",
                "line_local": "line",
                "float_ptr_local": "float_ptr",
                "letter_local": "letter",
                "gc.status_code": "status_code",
                "iVar1": "result"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "read_float"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018cc": {
            "entrypoint": "0x080018cc",
            "current_name": "update_flag_with_x_080018cc",
            "code": "\n\n\nvoid updateFlagWithX_080018cc(uint32_t inputValue)\n\n{\n  uint32_t localX;\n  uint32_t value;\n  \n  _DAT_40021014 = inputValue | _DAT_40021014 & 0inputValuefffffaaf;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018cc": "update_flag_with_x_080018cc",
                "x": "inputValue",
                "x_local": "localX",
                "val": "value"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018fc": {
            "entrypoint": "0x080018fc",
            "current_name": "update_value_080018fc",
            "code": "\n\n\nvoid updateValue_080018fc(uint32_t inputValue)\n\n{\n  uint32_t tempVal;\n  uint32_t newValue;\n  \n  _DAT_40021014 = inputValue | _DAT_40021014 & 0inputValuefffff55f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018fc": "update_value_080018fc",
                "x": "inputValue",
                "x_local": "tempVal",
                "val": "newValue"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800192c": {
            "entrypoint": "0x0800192c",
            "current_name": "check_limits_enabled_0800192c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkLimitsEnabled_0800192c(void)\n\n{\n  areLimitsEnabled = (int)((inputSettings.flags & 8) != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800192c": "check_limits_enabled_0800192c",
                "settings": "inputSettings",
                "limits_enabled": "areLimitsEnabled"
            },
            "calling": [
                "grbl_main",
                "settings_store_global_setting"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800195c": {
            "entrypoint": "0x0800195c",
            "current_name": "check_and_reset_mc_0800195c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_reset_mc_0800195c(void)\n\n{\n  if ((system.state != '\\x06') && ((system.execution_flag & 0x20) == 0)) {\n    reset_machine();\n    system.execution_flag = system.execution_flag | 0x40;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800195c": "check_and_reset_mc_0800195c",
                "sys": "system",
                "mc_reset": "reset_machine",
                "execute": "execution_flag"
            },
            "calling": [
                "debounce_on_handler"
            ],
            "called": [
                "mc_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001994": {
            "entrypoint": "0x08001994",
            "current_name": "perform_motion_08001994",
            "code": "\n/* WARNING: Variable defined which should be unmapped: homingSpeed-local */\n\nvoid performMotion_08001994(uint8_t motionMask,int8_t direction,_Bool pinInversion,float homingSpeed)\n\n{\n  bool isNotPinInverted;\n  uint16_t stepInversion;\n  undefined4 accelerationFactor;\n  undefined4 divisionFactor;\n  int stepDelay;\n  uint uVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  uint32_t maxStepCount;\n  undefined4 in_r3;\n  uint32_t minStepCount;\n  undefined8 convertedValue;\n  float localHomingSpeed;\n  undefined unknownStackVariable;\n  _Bool localPinInversion;\n  int8_t localDirection;\n  uint8_t localMotionMask;\n  uint32_t stepCounts [3];\n  uint16_t stepBits0;\n  uint32_t minimumDeltaT;\n  uint32_t deltaRate;\n  float distance;\n  uint32_t stepEventCount;\n  uint32_t limitState;\n  uint16_t stepBits;\n  uint32_t trapCounter;\n  uint32_t stepRate;\n  uint32_t stepDelay;\n  int32_t counterZ;\n  int32_t counterY;\n  int32_t counterX;\n  uint16_t directionBits;\n  uint32_t deltaT;\n  uint8_t distanceFlag;\n  \n  isNotPinInverted = !pinInversion;\n  memset(stepCounts,0,0xc);\n  distanceFlag = (motionMask & 1) != 0;\n  if ((bool)distanceFlag) {\n    __aeabi_f2d(settings.stepCounts_per_mm[0]);\n    stepCounts[0] = lround((double)CONCAT17(motionMask,\n                                       CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,in_r3)))))\n    ;\n  }\n  if ((motionMask & 2) != 0) {\n    distanceFlag = distanceFlag + '\\x01';\n    __aeabi_f2d(settings.stepCounts_per_mm[1]);\n    stepCounts[1] = lround((double)CONCAT17(motionMask,\n                                       CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,in_r3)))))\n    ;\n  }\n  if ((motionMask & 4) != 0) {\n    distanceFlag = distanceFlag + '\\x01';\n    __aeabi_f2d(settings.stepCounts_per_mm[2]);\n    stepCounts[2] = lround((double)CONCAT17(motionMask,\n                                       CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,in_r3)))))\n    ;\n  }\n  maxStepCount = stepCounts[2];\n  if (stepCounts[2] < stepCounts[1]) {\n    maxStepCount = stepCounts[1];\n  }\n  minStepCount = stepCounts[0];\n  if (stepCounts[0] < maxStepCount) {\n    minStepCount = maxStepCount;\n  }\n  convertedValue = __floatunsidf(minStepCount);\n  accelerationFactor = __floatunsidf(distanceFlag);\n  sqrt((double)CONCAT17(motionMask,CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,in_r3)))));\n  convertedValue = __divdf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),accelerationFactor,extraout_r1);\n  accelerationFactor = __truncdfsf2((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20));\n  divisionFactor = __aeabi_fmul(settings.acceleration,accelerationFactor);\n  divisionFactor = __aeabi_fdiv(divisionFactor,0x453b8000);\n  divisionFactor = __aeabi_f2d(divisionFactor);\n  ceil((double)CONCAT17(motionMask,CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,in_r3)))));\n  stepDelay = __aeabi_d2uiz(divisionFactor,extraout_r1_00);\n  divisionFactor = __floatunsidf(distanceFlag);\n  sqrt((double)CONCAT17(motionMask,CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,in_r3)))));\n  convertedValue = __aeabi_f2d(in_r3);\n  convertedValue = __muldf3(divisionFactor,extraout_r1_01,(int)convertedValue,(int)((ulonglong)convertedValue >> 0x20));\n  divisionFactor = __truncdfsf2((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20));\n  accelerationFactor = __aeabi_fmul(accelerationFactor,divisionFactor);\n  accelerationFactor = __aeabi_fdiv(0x4c64e1c0,accelerationFactor);\n  __aeabi_f2d(accelerationFactor);\n  uVar6 = lround((double)CONCAT17(motionMask,\n                                  CONCAT16(direction,CONCAT15(isNotPinInverted,CONCAT14(unknownStackVariable,divisionFactor)))));\n  stepInversion = settings.step_invert_mask;\n  deltaT = 75000;\n  if (uVar6 < 75000) {\n    deltaT = uVar6;\n  }\n  directionBits = settings.dirn_invert_mask ^ settings.homing_dir_mask & 0xaa0;\n  if (direction == '\\0') {\n    directionBits = directionBits ^ 0xaa0;\n  }\n  dirn_wr((uint)directionBits);\n  step_wr((uint)stepInversion);\n  counterZ = -(minStepCount >> 1);\n  stepDelay = deltaT - settings.pulse_microsecondistance;\n  stepRate = 0;\n  trapCounter = 10000;\n  localMotionMask = motionMask;\n  counterY = counterZ;\n  counterX = counterZ;\n  while( true ) {\n    stepBits = stepInversion;\n    limitState = debounce_rd();\n    if (isNotPinInverted) {\n      limitState = limitState ^ 0x1e;\n    }\n    if (((localMotionMask & 1) != 0) && (counterX = counterX + stepCounts[0], 0 < counterX)) {\n      if ((limitState & 0x10) == 0) {\n        localMotionMask = localMotionMask & 0xfe;\n      }\n      else {\n        stepBits = stepInversion ^ 0x10;\n      }\n      counterX = counterX - minStepCount;\n    }\n    if (((localMotionMask & 2) != 0) && (counterY = counterY + stepCounts[1], 0 < counterY)) {\n      if ((limitState & 8) == 0) {\n        localMotionMask = localMotionMask & 0xfd;\n      }\n      else {\n        stepBits = stepBits ^ 0x440;\n      }\n      counterY = counterY - minStepCount;\n    }\n    if (((localMotionMask & 4) != 0) && (counterZ = counterZ + stepCounts[2], 0 < counterZ)) {\n      if ((limitState & 4) == 0) {\n        localMotionMask = localMotionMask & 0xfb;\n      }\n      else {\n        stepBits = stepBits ^ 0x100;\n      }\n      counterZ = counterZ - minStepCount;\n    }\n    if ((localMotionMask == '\\0') || ((sys.execute & 0x10) != 0)) break;\n    step_wr((uint)stepBits);\n    delay_us((uint)settings.pulse_microsecondistance);\n    step_wr((uint)stepInversion);\n    delay_us(stepDelay);\n    if ((uVar6 < deltaT) && (trapCounter = deltaT + trapCounter, 20000 < trapCounter)) {\n      trapCounter = trapCounter - 20000;\n      stepRate = stepDelay + stepRate;\n      deltaT = 60000000 / stepRate;\n      if (60000000 / stepRate < uVar6) {\n        deltaT = uVar6;\n      }\n      stepDelay = deltaT - settings.pulse_microsecondistance;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001994": "perform_motion_08001994",
                "cycle_mask": "motionMask",
                "pos_dir": "direction",
                "invert_pin": "pinInversion",
                "homing_rate": "homingSpeed",
                "bVar1": "isNotPinInverted",
                "uVar2": "stepInversion",
                "uVar3": "accelerationFactor",
                "uVar4": "divisionFactor",
                "iVar5": "stepDelay",
                "uVar7": "maxStepCount",
                "uVar8": "minStepCount",
                "uVar9": "convertedValue",
                "homing_rate_local": "localHomingSpeed",
                "uStack_64": "unknownStackVariable",
                "invert_pin_local": "localPinInversion",
                "pos_dir_local": "localDirection",
                "cycle_mask_local": "localMotionMask",
                "steps": "stepCounts",
                "step_bits0": "stepBits0",
                "dt_min": "minimumDeltaT",
                "delta_rate": "deltaRate",
                "ds": "distance",
                "step_event_count": "stepEventCount",
                "limit_state": "limitState",
                "step_bits": "stepBits",
                "trap_counter": "trapCounter",
                "step_rate": "stepRate",
                "step_delay": "stepDelay",
                "counter_z": "counterZ",
                "counter_y": "counterY",
                "counter_x": "counterX",
                "dirn_bits": "directionBits",
                "dt": "deltaT",
                "dist": "distanceFlag"
            },
            "calling": [
                "limits_go_home"
            ],
            "called": [
                "__muldf3",
                "delay_us",
                "__truncdfsf2",
                "sqrt",
                "__aeabi_d2uiz",
                "lround",
                "__aeabi_fdiv",
                "__floatunsidf",
                "debounce_rd",
                "__aeabi_f2d",
                "step_wr",
                "dirn_wr",
                "ceil",
                "__aeabi_fmul",
                "__divdf3",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d4c": {
            "entrypoint": "0x08001d4c",
            "current_name": "perform_homing_08001d4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performHoming_08001d4c(void)\n\n{\n  char cVar1;\n  float currentHomingRate;\n  float nextHomingRate;\n  float intermediateValue;\n  float previousHomingRate;\n  float nextIntermediateValue;\n  float currentIntermediateValue;\n  int8_t cycleCount;\n  \n  st_wake_up();\n  homing_cycle('\\x04','\\x01',false,currentHomingRate);\n  homing_cycle('\\x03','\\x01',false,nextHomingRate);\n  delay_ms(settings.homing_debounce_delay);\n  cycleCount = '\\x02';\n  currentIntermediateValue = intermediateValue;\n  while (cVar1 = cycleCount + -1, cycleCount != '\\0') {\n    homing_cycle('\\a','\\0',true,currentIntermediateValue);\n    delay_ms(settings.homing_debounce_delay);\n    currentIntermediateValue = previousHomingRate;\n    cycleCount = cVar1;\n    if ('\\0' < cVar1) {\n      homing_cycle('\\a','\\x01',false,previousHomingRate);\n      delay_ms(settings.homing_debounce_delay);\n      currentIntermediateValue = nextIntermediateValue;\n    }\n  }\n  st_go_idle();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d4c": "perform_homing_08001d4c",
                "homing_rate": "currentHomingRate",
                "homing_rate_00": "nextHomingRate",
                "extraout_s0": "intermediateValue",
                "homing_rate_01": "previousHomingRate",
                "extraout_s0_00": "nextIntermediateValue",
                "homing_rate_02": "currentIntermediateValue",
                "n_cycle": "cycleCount"
            },
            "calling": [
                "mc_go_home"
            ],
            "called": [
                "st_wake_up",
                "st_go_idle",
                "delay_ms",
                "homing_cycle"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ddc": {
            "entrypoint": "0x08001ddc",
            "current_name": "initialize_cnc_system_08001ddc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeCNCSystem_08001ddc(void)\n\n{\n  initializeSerial();\n  initializeSettings();\n  initializeST();\n  memset(&system,0,0x14);\n  abortFlag = '\\x01';\n  systemState = '\\x01';\n  do {\n    if (abortFlag != '\\0') {\n      resetReadBuffer();\n      initializePlan();\n      initializeGC();\n      initializeProtocol();\n      initializeSpindle();\n      initializeCoolant();\n      initializeLimits();\n      resetST();\n      syncCurrentPosition();\n      abortFlag = '\\0';\n      system.execute = '\\0';\n      if ((systemSettings.flags & 2) != 0) {\n        autoStart = '\\x01';\n      }\n      if ((systemState == '\\x01') && ((systemSettings.flags & 0x10) != 0)) {\n        systemState = '\\x06';\n      }\n      if (systemState == '\\x06') {\n        sendFeedbackMessage('\\x02');\n      }\n      else {\n        systemState = '\\0';\n        executeStartupProtocol();\n      }\n    }\n    executeRuntimeProtocol();\n    processProtocol();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001ddc": "initialize_cnc_system_08001ddc",
                "serial_init": "initializeSerial",
                "settings_init": "initializeSettings",
                "st_init": "initializeST",
                "sys": "system",
                "serial_reset_read_buffer": "resetReadBuffer",
                "plan_init": "initializePlan",
                "gc_init": "initializeGC",
                "protocol_init": "initializeProtocol",
                "spindle_init": "initializeSpindle",
                "coolant_init": "initializeCoolant",
                "limits_init": "initializeLimits",
                "st_reset": "resetST",
                "sys_sync_current_position": "syncCurrentPosition",
                "settings": "systemSettings",
                "sys.auto_start": "autoStart",
                "sys.state": "systemState",
                "sys.abort": "abortFlag",
                "report_feedback_message": "sendFeedbackMessage",
                "protocol_execute_startup": "executeStartupProtocol",
                "protocol_execute_runtime": "executeRuntimeProtocol",
                "protocol_process": "processProtocol"
            },
            "calling": [
                "main"
            ],
            "called": [
                "protocol_init",
                "sys_sync_current_position",
                "report_feedback_message",
                "settings_init",
                "spindle_init",
                "protocol_execute_runtime",
                "limits_init",
                "serial_reset_read_buffer",
                "plan_init",
                "st_init",
                "protocol_execute_startup",
                "serial_init",
                "gc_init",
                "protocol_process",
                "coolant_init",
                "memset",
                "st_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e98": {
            "entrypoint": "0x08001e98",
            "current_name": "execute_line_08001e98",
            "code": "\nvoid executeLine_08001e98(float targetX,float targetY,float targetZ,float speed,uint8_t isSpeedInverted)\n\n{\n  uint8_t isBufferFull;\n  float localX;\n  float localY;\n  float localZ;\n  float localSpeed;\n  float localSpeed;\n  float localZ;\n  float localY;\n  float localX;\n  \n  if (systemState != '\\a') {\n    do {\n      executeRuntime();\n      if (abortFlag != '\\0') {\n        return;\n      }\n      isBufferFull = checkBufferFull();\n    } while (isBufferFull != '\\0');\n    bufferLine(localX,localY,localZ,localSpeed,isSpeedInverted);\n    if (systemState == '\\0') {\n      systemState = '\\targetX02';\n    }\n    if (autoStartFlag != '\\0') {\n      cycleStart();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e98": "execute_line_08001e98",
                "x": "targetX",
                "y": "targetY",
                "z": "targetZ",
                "feed_rate": "speed",
                "invert_feed_rate": "isSpeedInverted",
                "uVar1": "isBufferFull",
                "x_00": "localX",
                "y_00": "localY",
                "z_00": "localZ",
                "feed_rate_00": "localSpeed",
                "feed_rate_local": "localSpeed",
                "z_local": "localZ",
                "y_local": "localY",
                "x_local": "localX",
                "sys.state": "systemState",
                "sys.abort": "abortFlag",
                "sys.auto_start": "autoStartFlag",
                "st_cycle_start": "cycleStart",
                "plan_check_full_buffer": "checkBufferFull",
                "plan_buffer_line": "bufferLine",
                "protocol_execute_runtime": "executeRuntime"
            },
            "calling": [
                "mc_go_home",
                "gc_execute_line",
                "mc_arc"
            ],
            "called": [
                "plan_check_full_buffer",
                "protocol_execute_runtime",
                "st_cycle_start",
                "plan_buffer_line"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f00": {
            "entrypoint": "0x08001f00",
            "current_name": "arc_interpolation_08001f00",
            "code": "\n/* WARNING: Variable defined which should be unmapped: xAxis-local */\n\nvoid arcInterpolation_08001f00(float *startPosition,float *endPosition,float *positionOffset,uint8_t xAxis,uint8_t yAxis,\n                 uint8_t zAxis,float feedRate,uint8_t invertFeedRate,float arcRadius,\n                 uint8_t clockwise)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int iVar6;\n  float fVar7;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  float extraout_s2;\n  float z;\n  float extraout_s2_00;\n  float extraout_s3;\n  float feedRate_00;\n  float extraout_s3_00;\n  float feedRate_01;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  undefined3 in_stack_00000009;\n  undefined4 in_stack_00000010;\n  char in_stack_00000014;\n  uint in_stack_ffffff78;\n  undefined4 in_stack_ffffff7c;\n  undefined3 uStack_80;\n  uint8_t xAxis_local;\n  float *positionOffset_local;\n  float *endPosition_local;\n  float *startPosition_local;\n  float arc_endPosition [3];\n  float r_axisi;\n  float sin_Ti;\n  float cos_Ti;\n  float sin_T;\n  float cos_T;\n  float linear_per_segment;\n  float theta_per_segment;\n  uint16_t segments;\n  float millimeters_of_travel;\n  float rt_axis1;\n  float rt_axis0;\n  float linear_travel;\n  float center_axis1;\n  float center_axis0;\n  int8_t count;\n  uint16_t i;\n  float angular_travel;\n  float r_axis1;\n  float r_axis0;\n  \n  _uStack_80 = CONCAT13(xAxis,uStack_80);\n  center_axis0 = (float)__addsf3(feedRate,startPosition[xAxis],positionOffset[xAxis]);\n  center_axis1 = (float)__addsf3(startPosition[yAxis],positionOffset[yAxis]);\n  uVar1 = __aeabi_fsub(endPosition[zAxis],startPosition[zAxis]);\n  r_axis0 = (float)((uint)positionOffset[xAxis] ^ 0x80000000);\n  r_axis1 = (float)((uint)positionOffset[yAxis] ^ 0x80000000);\n  uVar2 = __aeabi_fsub(endPosition[xAxis],center_axis0);\n  uVar3 = __aeabi_fsub(endPosition[yAxis],center_axis1);\n  uVar4 = __aeabi_fmul(r_axis0,uVar3);\n  uVar5 = __aeabi_fmul(r_axis1,uVar2);\n  uVar4 = __aeabi_fsub(uVar4,uVar5);\n  uVar8 = __aeabi_f2d(uVar4);\n  uVar2 = __aeabi_fmul(r_axis0,uVar2);\n  uVar3 = __aeabi_fmul(r_axis1,uVar3);\n  uVar2 = __addsf3(uVar2,uVar3);\n  uVar9 = __aeabi_f2d(uVar2);\n  uVar8 = atan2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar9,\n                (int)((ulonglong)uVar9 >> 0x20));\n  angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  if (in_stack_00000014 == '\\0') {\n    iVar6 = __aeabi_fcmple(angular_travel,0);\n    if (iVar6 != 0) {\n      uVar8 = __aeabi_f2d(angular_travel);\n      uVar8 = __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),0x54442d18,0x401921fb);\n      angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  else {\n    iVar6 = __aeabi_fcmpge(angular_travel,0);\n    if (iVar6 != 0) {\n      uVar8 = __aeabi_f2d(angular_travel);\n      uVar8 = __subdf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),0x54442d18,0x401921fb);\n      angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  uVar2 = __aeabi_fmul(angular_travel,in_stack_00000010);\n  uVar2 = __aeabi_f2d(uVar2);\n  __aeabi_f2d(uVar1 & 0x7fffffff);\n  hypot((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78),(double)CONCAT44(positionOffset,_uStack_80));\n  uVar2 = __truncdfsf2(uVar2,extraout_r1);\n  iVar6 = __aeabi_fcmpeq(uVar2,0);\n  if (iVar6 == 0) {\n    uVar2 = __aeabi_fdiv(uVar2,settings.mm_per_arc_segment);\n    uVar2 = __aeabi_f2d(uVar2);\n    floor((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n    segments = __aeabi_d2uiz(uVar2,extraout_r1_00);\n    if (clockwise != '\\0') {\n      uVar2 = __floatsisf(segments);\n      __aeabi_fmul(_invertFeedRate,uVar2);\n    }\n    uVar2 = __floatsisf(segments);\n    sin_T = (float)__aeabi_fdiv(angular_travel,uVar2);\n    uVar2 = __floatsisf(segments);\n    linear_per_segment = (float)__aeabi_fdiv(uVar1,uVar2);\n    uVar8 = __aeabi_f2d(sin_T);\n    uVar8 = __muldf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),0,0x3fe00000);\n    uVar9 = __aeabi_f2d(sin_T);\n    uVar8 = __muldf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar9,\n                     (int)((ulonglong)uVar9 >> 0x20));\n    uVar8 = __subdf3(0,0x3ff00000,(int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    cos_T = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    count = '\\0';\n    theta_per_segment = sin_T;\n    arc_endPosition[zAxis] = startPosition[zAxis];\n    uVar8 = extraout_d0;\n    fVar7 = extraout_s2;\n    feedRate_01 = extraout_s3;\n    for (i = 1; i < segments; i = i + 1) {\n      if ((int)count < (int)(uint)settings.n_arc_correction) {\n        uVar2 = __aeabi_fmul(r_axis0,sin_T);\n        uVar3 = __aeabi_fmul(r_axis1,cos_T);\n        fVar7 = (float)__addsf3(uVar2,uVar3);\n        uVar2 = __aeabi_fmul(r_axis0,cos_T);\n        uVar3 = __aeabi_fmul(r_axis1,sin_T);\n        r_axis0 = (float)__aeabi_fsub(uVar2,uVar3);\n        count = count + '\\x01';\n        r_axis1 = fVar7;\n      }\n      else {\n        uVar2 = __floatsisf(i);\n        uVar2 = __aeabi_fmul(uVar2,theta_per_segment);\n        uVar2 = __aeabi_f2d(uVar2);\n        cos((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar2 = __truncdfsf2(uVar2,extraout_r1_01);\n        uVar3 = __floatsisf(i);\n        uVar3 = __aeabi_fmul(uVar3,theta_per_segment);\n        uVar3 = __aeabi_f2d(uVar3);\n        sin((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar3 = __truncdfsf2(uVar3,extraout_r1_02);\n        uVar4 = __aeabi_fmul((uint)positionOffset[xAxis] ^ 0x80000000,uVar2);\n        uVar5 = __aeabi_fmul(positionOffset[yAxis],uVar3);\n        r_axis0 = (float)__addsf3(uVar4,uVar5);\n        uVar3 = __aeabi_fmul((uint)positionOffset[xAxis] ^ 0x80000000,uVar3);\n        uVar2 = __aeabi_fmul(positionOffset[yAxis],uVar2);\n        r_axis1 = (float)__aeabi_fsub(uVar3,uVar2);\n        count = '\\0';\n      }\n      fVar7 = (float)__addsf3(center_axis0,r_axis0);\n      arc_endPosition[xAxis] = fVar7;\n      fVar7 = (float)__addsf3(center_axis1,r_axis1);\n      arc_endPosition[yAxis] = fVar7;\n      fVar7 = (float)__addsf3(arc_endPosition[zAxis],linear_per_segment);\n      arc_endPosition[zAxis] = fVar7;\n      in_stack_ffffff78 = (uint)clockwise;\n      mc_line((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 >> 0x20),z,feedRate_00,\n              SUB41(arc_endPosition[0],0));\n      if (sys.abort != '\\0') {\n        return;\n      }\n      uVar8 = extraout_d0_01;\n      fVar7 = extraout_s2_00;\n      feedRate_01 = extraout_s3_00;\n    }\n    mc_line((float)uVar8,(float)((ulonglong)uVar8 >> 0x20),fVar7,feedRate_01,SUB41(*endPosition,0));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f00": "arc_interpolation_08001f00",
                "position": "startPosition",
                "target": "endPosition",
                "offset": "positionOffset",
                "axis_0": "xAxis",
                "axis_1": "yAxis",
                "axis_linear": "zAxis",
                "feed_rate": "feedRate",
                "invert_feed_rate": "invertFeedRate",
                "radius": "arcRadius",
                "isclockwise": "clockwise"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "__floatsisf",
                "sin",
                "__muldf3",
                "__truncdfsf2",
                "__aeabi_dadd",
                "__aeabi_d2uiz",
                "__aeabi_fdiv",
                "atan2",
                "mc_line",
                "__subdf3",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fcmple",
                "hypot",
                "__aeabi_fmul",
                "cos",
                "__aeabi_fcmpge",
                "__aeabi_fcmpeq",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002408": {
            "entrypoint": "0x08002408",
            "current_name": "calculate_delay_08002408",
            "code": "\n/* WARNING: Variteration_countable defiteration_countned whiteration_countch should be unmapped: input_seconds-local */\n\nvoiteration_countd calculate_delay_08002408(float input_seconds)\n\n{\n  uiteration_countnt16_t calculated_ms;\n  undefiteration_countned4 constant_1;\n  undefiteration_countned4 multiplied_seconds;\n  undefiteration_countned4 multiplied_i;\n  undefiteration_countned4 unused_1;\n  undefiteration_countned4 unused_2;\n  undefiteration_countned4 unused_3;\n  float local_seconds;\n  uiteration_countnt16_t iteration_count;\n  \n  multiplied_seconds = __aeabiteration_count_fmul(input_seconds,constant_1,0x41a00000);\n  multiplied_seconds = __aeabiteration_count_f2d(multiplied_seconds);\n  floor((double)CONCAT44(constant_1,unused_3));\n  iteration_count = __aeabiteration_count_d2uiteration_countz(multiplied_seconds,unused_1);\n  plan_synchroniteration_countze();\n  multiplied_seconds = __aeabiteration_count_fmul(constant_1,0x447a0000);\n  multiplied_i = __floatsiteration_countsf((uiteration_countnt)iteration_count * 0x32);\n  multiplied_seconds = __aeabiteration_count_fsub(multiplied_seconds,multiplied_i);\n  multiplied_seconds = __aeabiteration_count_f2d(multiplied_seconds);\n  floor((double)CONCAT44(constant_1,unused_3));\n  calculated_ms = __aeabiteration_count_d2uiteration_countz(multiplied_seconds,unused_2);\n  delay_calculated_ms(calculated_ms);\n  whiteration_countle ((iteration_count != 0 && (protocol_execute_runtiteration_countme(), sys.abort == '\\0'))) {\n    _delay_calculated_ms(0x32);\n    iteration_count = iteration_count - 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002408": "calculate_delay_08002408",
                "seconds": "input_seconds",
                "ms": "calculated_ms",
                "in_r0": "constant_1",
                "uVar1": "multiplied_seconds",
                "uVar2": "multiplied_i",
                "extraout_r1": "unused_1",
                "extraout_r1_00": "unused_2",
                "uStack_20": "unused_3",
                "seconds_local": "local_seconds",
                "i": "iteration_count"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_f2d",
                "plan_synchronize",
                "__aeabi_fsub",
                "__aeabi_fmul",
                "__aeabi_d2uiz",
                "delay_ms",
                "protocol_execute_runtime",
                "_delay_ms",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024c4": {
            "entrypoint": "0x080024c4",
            "current_name": "initialize_080024c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_080024c4(void)\n\n{\n  uint8_t inverted_feed_rate;\n  undefined4 converted_value;\n  undefined8 multiplied_value;\n  float z_coordinate;\n  float feed_rate;\n  int8_t z_direction;\n  int8_t y_direction;\n  int8_t x_direction;\n  \n  sys.state = '\\x05';\n  limits_enabled = 0;\n  limits_go_home();\n  protocol_execute_runtime();\n  if (sys.abort == '\\0') {\n    memset(sys.position,0,0xc);\n    sync_current_position();\n    sys.state = '\\0';\n    if ((homing_direction_mask & 0x20) == 0) {\n      x_direction = -1;\n    }\n    else {\n      x_direction = '\\x01';\n    }\n    if ((homing_direction_mask & 0x80) == 0) {\n      y_direction = -1;\n    }\n    else {\n      y_direction = '\\x01';\n    }\n    if ((homing_direction_mask & 0x200) == 0) {\n      z_direction = -1;\n    }\n    else {\n      z_direction = '\\x01';\n    }\n    converted_value = __floatsisf((int)x_direction);\n    inverted_feed_rate = __aeabi_fmul(converted_value,homing_pulloff);\n    converted_value = __floatsisf((int)y_direction);\n    __aeabi_fmul(converted_value,homing_pulloff);\n    converted_value = __floatsisf((int)z_direction);\n    multiplied_value = __aeabi_fmul(converted_value,homing_pulloff);\n    move_axis((float)multiplied_value,(float)((ulonglong)multiplied_value >> 0x20),z_coordinate,feed_rate,inverted_feed_rate);\n    start_cycle();\n    synchronize_plan();\n    sync_current_position();\n    if ((flags & 8) != 0) {\n      limits_enabled = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024c4": "initialize_080024c4",
                "invert_feed_rate": "inverted_feed_rate",
                "uVar1": "converted_value",
                "uVar2": "multiplied_value",
                "z": "z_coordinate",
                "z_dir": "z_direction",
                "y_dir": "y_direction",
                "x_dir": "x_direction",
                "settings.homing_dir_mask": "homing_direction_mask",
                "settings.homing_pulloff": "homing_pulloff",
                "mc_line": "move_axis",
                "st_cycle_start": "start_cycle",
                "plan_synchronize": "synchronize_plan",
                "sys_sync_current_position": "sync_current_position",
                "settings.flags": "flags"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "__floatsisf",
                "sys_sync_current_position",
                "limits_go_home",
                "plan_synchronize",
                "__aeabi_fmul",
                "protocol_execute_runtime",
                "st_cycle_start",
                "mc_line",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "disable_execute_and_idle_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_execute_and_idle_080025e8(void)\n\n{\n  if ((execution_flag & 0x10) == 0) {\n    execution_flag = execution_flag | 0x10;\n    stop_spindle();\n    stop_coolant();\n    if (system_state - 3 < 3) {\n      execution_flag = execution_flag | 0x20;\n      go_idle();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "disable_execute_and_idle_080025e8",
                "sys.execute": "execution_flag",
                "spindle_stop": "stop_spindle",
                "coolant_stop": "stop_coolant",
                "sys.state": "system_state",
                "st_go_idle": "go_idle"
            },
            "calling": [
                "gc_execute_line",
                "limits_isr",
                "protocol_execute_line",
                "serial_rx_hook",
                "buttons_isr"
            ],
            "called": [
                "spindle_stop",
                "st_go_idle",
                "coolant_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002638": {
            "entrypoint": "0x08002638",
            "current_name": "parse_float_08002638",
            "code": "\nint parse_float_08002638(char *input_str,uint8_t *counter,float *result_ptr)\n\n{\n  byte isdigit;\n  bool is_negative;\n  bool has_dot;\n  uchar *char_ptr;\n  uchar *line_ptr;\n  int success;\n  undefined8 float_temp;\n  float *local_result_ptr;\n  uint8_t *local_counter;\n  char *local_input_str;\n  float float_val;\n  _Bool is_decimal;\n  uint8_t num_digits;\n  int8_t exponent;\n  uint32_t integer_val;\n  _Bool is_negative_flag;\n  uchar c;\n  char *current_ptr;\n  \n  line_ptr = (uchar *)(input_str + *counter);\n  char_ptr = line_ptr + 1;\n  c = *line_ptr;\n  is_negative = false;\n  if (c == '-') {\n    is_negative = true;\n    c = *char_ptr;\n    current_ptr = (char *)(line_ptr + 2);\n  }\n  else {\n    current_ptr = (char *)char_ptr;\n    if (c == '+') {\n      current_ptr = (char *)(line_ptr + 2);\n      c = *char_ptr;\n    }\n  }\n  integer_val = 0;\n  exponent = '\\0';\n  num_digits = '\\0';\n  has_dot = false;\n  do {\n    isdigit = c - 0x30;\n    if (isdigit < 10) {\n      num_digits = num_digits + 1;\n      if (num_digits < 9) {\n        if (has_dot) {\n          exponent = exponent + -1;\n        }\n        integer_val = (uint)isdigit + integer_val * 10;\n      }\n      else if (!has_dot) {\n        exponent = exponent + '\\x01';\n      }\n    }\n    else {\n      if ((isdigit != 0xfe) || (has_dot)) {\n        if (num_digits == '\\0') {\n          success = 0;\n        }\n        else {\n          float_val = (float)__floatunsisf(integer_val);\n          success = __aeabi_fcmpeq(float_val,0);\n          if (success == 0) {\n            for (; exponent < -1; exponent = exponent + '\\x02') {\n              float_temp = __aeabi_f2d(float_val);\n              float_temp = __muldf3((int)float_temp,(int)((ulonglong)float_temp >> 0x20),0x47ae147b,0x3f847ae1);\n              float_val = (float)__truncdfsf2((int)float_temp,(int)((ulonglong)float_temp >> 0x20));\n            }\n            if (exponent < '\\0') {\n              float_temp = __aeabi_f2d(float_val);\n              float_temp = __muldf3((int)float_temp,(int)((ulonglong)float_temp >> 0x20),0x9999999a,0x3fb99999);\n              float_val = (float)__truncdfsf2((int)float_temp,(int)((ulonglong)float_temp >> 0x20));\n            }\n            else {\n              for (; '\\0' < exponent; exponent = exponent + -1) {\n                float_val = (float)__aeabi_fmul(float_val,0x41200000);\n              }\n            }\n          }\n          if (is_negative) {\n            *result_ptr = (float)((uint)float_val ^ 0x80000000);\n          }\n          else {\n            *result_ptr = float_val;\n          }\n          *counter = ((char)current_ptr - (char)input_str) + 0xff;\n          success = 1;\n        }\n        return success;\n      }\n      has_dot = true;\n    }\n    c = *current_ptr;\n    current_ptr = current_ptr + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002638": "parse_float_08002638",
                "line": "input_str",
                "char_counter": "counter",
                "float_ptr": "result_ptr",
                "bVar1": "isdigit",
                "bVar2": "is_negative",
                "bVar3": "has_dot",
                "puVar4": "char_ptr",
                "puVar5": "line_ptr",
                "iVar6": "success",
                "uVar7": "float_temp",
                "float_ptr_local": "local_result_ptr",
                "char_counter_local": "local_counter",
                "line_local": "local_input_str",
                "fval": "float_val",
                "isdecimal": "is_decimal",
                "ndigit": "num_digits",
                "exp": "exponent",
                "intval": "integer_val",
                "isnegative": "is_negative_flag",
                "ptr": "current_ptr"
            },
            "calling": [
                "protocol_execute_line",
                "next_statement"
            ],
            "called": [
                "__aeabi_f2d",
                "__muldf3",
                "__floatunsisf",
                "__truncdfsf2",
                "__aeabi_fmul",
                "__aeabi_fcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002814": {
            "entrypoint": "0x08002814",
            "current_name": "delay_milliseconds_08002814",
            "code": "\nvoid delayMilliseconds_08002814(uint16_t milliseconds)\n\n{\n  uint16_t milliseconds_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08002814": "delay_milliseconds_08002814",
                "ms": "milliseconds"
            },
            "calling": [
                "limits_go_home",
                "mc_dwell",
                "report_alarm_message"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002828": {
            "entrypoint": "0x08002828",
            "current_name": "extract_data_08002828",
            "code": "\nvoid extract_data_08002828(uint32_t input_value)\n\n{\n  uint32_t local_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08002828": "extract_data_08002828",
                "us": "input_value",
                "us_local": "local_value"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800283a": {
            "entrypoint": "0x0800283a",
            "current_name": "set_current_position_0800283a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_current_position_0800283a(void)\n\n{\n  plan_set_current_position_0800283a(pos_x,pos_y,pos_z);\n  gc_set_current_position_0800283a(pos_x,pos_y,pos_z);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800283a": "set_current_position_0800283a",
                "sys.position[0]": "pos_x",
                "sys.position[1]": "pos_y",
                "sys.position[2]": "pos_z"
            },
            "calling": [
                "mc_go_home",
                "grbl_main"
            ],
            "called": [
                "gc_set_current_position",
                "plan_set_current_position"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002870": {
            "entrypoint": "0x08002870",
            "current_name": "update_block_index_08002870",
            "code": "\nuint8_t updateBlockIndex_08002870(uint8_t originalBlockIndex)\n\n{\n  uint8_t updatedBlockIndex;\n  \n  updatedBlockIndex = originalBlockIndex + '\\x01';\n  if (updatedBlockIndex == '\\x12') {\n    updatedBlockIndex = '\\0';\n  }\n  return updatedBlockIndex;\n}\n\n",
            "renaming": {
                "FUN_08002870": "update_block_index_08002870",
                "block_index": "originalBlockIndex",
                "block_index_local": "updatedBlockIndex"
            },
            "calling": [
                "plan_reset_buffer",
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "plan_discard_current_block",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002896": {
            "entrypoint": "0x08002896",
            "current_name": "add_block_index_08002896",
            "code": "\nuint8_t addBlockIndex_08002896(uint8_t inputIndex)\n\n{\n  uint8_t localIndex;\n  \n  localIndex = inputIndex;\n  if (inputIndex == '\\0') {\n    localIndex = '\\x12';\n  }\n  return localIndex + 0xff;\n}\n\n",
            "renaming": {
                "FUN_08002896": "add_block_index_08002896",
                "block_index": "inputIndex",
                "block_index_local": "localIndex"
            },
            "calling": [
                "planner_reverse_pass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028bc": {
            "entrypoint": "0x080028bc",
            "current_name": "calculate_acceleration_080028bc",
            "code": "\nfloat calculateAcceleration_080028bc(float initialRate,float targetRate,float acceleration)\n\n{\n  undefined4 initialRateSquared;\n  undefined4 targetRateSquared;\n  undefined4 accelerationTimesTwo;\n  undefined4 initialRateSquared;\n  undefined4 accelerationTimesTwo;\n  float result;\n  float accelerationLocal;\n  float targetRateLocal;\n  float initialRateLocal;\n  \n  targetRateSquared = __aeabi_fmul(initialRateSquared,initialRateSquared);\n  accelerationTimesTwo = __aeabi_fmul(initialRateSquared,initialRateSquared);\n  targetRateSquared = __aeabi_fsub(targetRateSquared,accelerationTimesTwo);\n  accelerationTimesTwo = __addsf3(accelerationTimesTwo,accelerationTimesTwo);\n  result = (float)__aeabi_fdiv(targetRateSquared,accelerationTimesTwo);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080028bc": "calculate_acceleration_080028bc",
                "initial_rate": "initialRate",
                "target_rate": "targetRate",
                "in_r0": "initialRateSquared",
                "uVar1": "targetRateSquared",
                "uVar2": "accelerationTimesTwo",
                "in_r1": "initialRateSquared",
                "in_r2": "accelerationTimesTwo",
                "fVar3": "result",
                "acceleration_local": "accelerationLocal",
                "target_rate_local": "targetRateLocal",
                "initial_rate_local": "initialRateLocal"
            },
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "called": [
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fdiv"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002908": {
            "entrypoint": "0x08002908",
            "current_name": "calculate_velocity_08002908",
            "code": "\nfloat calculate_velocity_08002908(float initial_rate,float final_rate,float acceleration,float distance)\n\n{\n  undefined4 temp_1;\n  undefined4 temp_2;\n  undefined4 temp_3;\n  undefined4 temp_4;\n  undefined4 temp_5;\n  undefined4 temp_6;\n  float result;\n  float distance_local;\n  float acceleration_local;\n  float final_rate_local;\n  float initial_rate_local;\n  \n  temp_2 = __addsf3(temp_5,temp_5);\n  temp_2 = __aeabi_fmul(temp_2,temp_6);\n  temp_3 = __aeabi_fmul(temp_1,temp_1);\n  temp_2 = __aeabi_fsub(temp_2,temp_3);\n  temp_3 = __aeabi_fmul(temp_4,temp_4);\n  temp_2 = __addsf3(temp_2,temp_3);\n  temp_3 = __aeabi_fmul(temp_5,0x40800000);\n  result = (float)__aeabi_fdiv(temp_2,temp_3);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002908": "calculate_velocity_08002908",
                "in_r0": "temp_1",
                "uVar1": "temp_2",
                "uVar2": "temp_3",
                "in_r1": "temp_4",
                "in_r2": "temp_5",
                "in_r3": "temp_6",
                "fVar3": "result"
            },
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "called": [
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fdiv"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002978": {
            "entrypoint": "0x08002978",
            "current_name": "calculate_velocity_08002978",
            "code": "\n/* WARNING: Variable defined which should be unmapped: distance-local */\n\nfloat calculateVelocity_08002978(float acceleration,float targetVelocity,float distance)\n\n{\n  undefined4 temp1;\n  undefined4 accelerationSquared;\n  undefined4 temp4;\n  undefined4 temp2;\n  undefined4 extraout_r1;\n  undefined4 temp3;\n  float calculatedVelocity;\n  undefined4 temp5;\n  float localDistance;\n  float localTargetVelocity;\n  float localAcceleration;\n  \n  accelerationSquared = __aeabi_fmul(acceleration,temp2,temp2);\n  temp4 = __addsf3(temp1,temp1);\n  temp4 = __aeabi_fmul(temp4,temp3);\n  accelerationSquared = __aeabi_fsub(accelerationSquared,temp4);\n  accelerationSquared = __aeabi_f2d(accelerationSquared);\n  sqrt((double)CONCAT44(temp3,temp5));\n  calculatedVelocity = (float)__truncdfsf2(accelerationSquared,extraout_r1);\n  return calculatedVelocity;\n}\n\n",
            "renaming": {
                "FUN_08002978": "calculate_velocity_08002978",
                "target_velocity": "targetVelocity",
                "in_r0": "temp1",
                "in_r1": "temp2",
                "in_r2": "temp3",
                "uVar1": "accelerationSquared",
                "uVar2": "temp4",
                "fVar3": "calculatedVelocity",
                "uStack_20": "temp5",
                "distance_local": "localDistance",
                "target_velocity_local": "localTargetVelocity",
                "acceleration_local": "localAcceleration"
            },
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__truncdfsf2",
                "__addsf3",
                "sqrt",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029d8": {
            "entrypoint": "0x080029d8",
            "current_name": "update_entry_speed_080029d8",
            "code": "\nvoid updateEntrySpeed_080029d8(block_t *previousBlock,block_t *currentBlock,block_t *nextBlock)\n\n{\n  int comparisonResult;\n  uint flippedAcceleration;\n  float newEntrySpeed;\n  float localAcceleration;\n  float localAcceleration_00;\n  float localTargetVelocity;\n  float localTargetVelocity_00;\n  float localDistance;\n  float localDistance_00;\n  block_t *localNextBlock;\n  block_t *localCurrentBlock;\n  block_t *localPreviousBlock;\n  \n  if (((currentBlock != (block_t *)0x0) && (nextBlock != (block_t *)0x0)) &&\n     (comparisonResult = __aeabi_fcmpeq(currentBlock->entry_speed,currentBlock->max_entry_speed), comparisonResult == 0)) {\n    if ((currentBlock->nominal_length_flag == '\\0') &&\n       (comparisonResult = __aeabi_fcmpgt(currentBlock->max_entry_speed,nextBlock->entry_speed), comparisonResult != 0)) {\n      newEntrySpeed = currentBlock->max_entry_speed;\n      flippedAcceleration = (uint)settings.localAcceleration ^ 0x80000000;\n      max_allowable_speed(localAcceleration,localTargetVelocity,localDistance);\n      comparisonResult = __aeabi_fcmplt(newEntrySpeed,flippedAcceleration);\n      if (comparisonResult == 0) {\n        newEntrySpeed = (float)((uint)settings.localAcceleration ^ 0x80000000);\n        max_allowable_speed(localAcceleration_00,localTargetVelocity_00,localDistance_00);\n      }\n      else {\n        newEntrySpeed = currentBlock->max_entry_speed;\n      }\n      currentBlock->entry_speed = newEntrySpeed;\n    }\n    else {\n      currentBlock->entry_speed = currentBlock->max_entry_speed;\n    }\n    currentBlock->recalculate_flag = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029d8": "update_entry_speed_080029d8",
                "previous": "previousBlock",
                "current": "currentBlock",
                "next": "nextBlock",
                "iVar1": "comparisonResult",
                "uVar2": "flippedAcceleration",
                "fVar3": "newEntrySpeed",
                "acceleration": "localAcceleration",
                "acceleration_00": "localAcceleration_00",
                "target_velocity": "localTargetVelocity",
                "target_velocity_00": "localTargetVelocity_00",
                "distance": "localDistance",
                "distance_00": "localDistance_00",
                "next_local": "localNextBlock",
                "current_local": "localCurrentBlock",
                "previous_local": "localPreviousBlock"
            },
            "calling": [
                "planner_reverse_pass"
            ],
            "called": [
                "__aeabi_fcmplt",
                "__aeabi_fcmpgt",
                "__aeabi_fcmpeq",
                "max_allowable_speed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a94": {
            "entrypoint": "0x08002a94",
            "current_name": "process_block_buffer_08002a94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processBlockBuffer_08002a94(void)\n\n{\n  Block *nextBlock;\n  Block *blocks [3];\n  uint8_t currentIndex;\n  \n  currentIndex = bufferHead;\n  blocks[0] = (Block *)0x0;\n  blocks[1] = (Block *)0x0;\n  while (nextBlock = blocks[1], currentIndex != bufferTail) {\n    currentIndex = getPrevBlockIndex(currentIndex);\n    blocks[1] = blocks[0];\n    executeReversePassKernel(buffer + currentIndex,blocks[0],nextBlock);\n    blocks[0] = buffer + currentIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a94": "process_block_buffer_08002a94",
                "block_t": "Block",
                "block_index": "currentIndex",
                "block_buffer_head": "bufferHead",
                "block": "blocks",
                "block_buffer_tail": "bufferTail",
                "next": "nextBlock",
                "prev_block_index": "getPrevBlockIndex",
                "planner_reverse_pass_kernel": "executeReversePassKernel",
                "block_buffer": "buffer"
            },
            "calling": [
                "planner_recalculate"
            ],
            "called": [
                "prev_block_index",
                "planner_reverse_pass_kernel"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002afc": {
            "entrypoint": "0x08002afc",
            "current_name": "update_entry_speed_if_needed_08002afc",
            "code": "\nvoid updateEntrySpeedIfNeeded_08002afc(block_t *previousBlock,block_t *currentBlock,block_t *nextBlock)\n\n{\n  int comparisonResult;\n  uint flippedAcceleration;\n  float newEntrySpeed;\n  float currentAcceleration;\n  float currentAcceleration_00;\n  float targetVelocity;\n  float targetVelocity_00;\n  float currentDistance;\n  float currentDistance_00;\n  block_t *nextBlockLocal;\n  block_t *currentBlockLocal;\n  block_t *previousBlockLocal;\n  float entrySpeed;\n  \n  if (((previousBlock != (block_t *)0x0) && (previousBlock->nominal_length_flag == '\\0')) &&\n     (comparisonResult = __aeabi_fcmplt(previousBlock->entrySpeed,currentBlock->entrySpeed), comparisonResult != 0)) {\n    newEntrySpeed = currentBlock->entrySpeed;\n    flippedAcceleration = (uint)settings.currentAcceleration ^ 0x80000000;\n    max_allowable_speed(currentAcceleration,targetVelocity,currentDistance);\n    comparisonResult = __aeabi_fcmplt(newEntrySpeed,flippedAcceleration);\n    if (comparisonResult == 0) {\n      newEntrySpeed = (float)((uint)settings.currentAcceleration ^ 0x80000000);\n      max_allowable_speed(currentAcceleration_00,targetVelocity_00,currentDistance_00);\n    }\n    else {\n      newEntrySpeed = currentBlock->entrySpeed;\n    }\n    comparisonResult = __aeabi_fcmpeq(newEntrySpeed,currentBlock->entrySpeed);\n    if (comparisonResult == 0) {\n      currentBlock->entrySpeed = newEntrySpeed;\n      currentBlock->recalculate_flag = '\\x01';\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002afc": "update_entry_speed_if_needed_08002afc",
                "previous": "previousBlock",
                "current": "currentBlock",
                "next": "nextBlock",
                "iVar1": "comparisonResult",
                "uVar2": "flippedAcceleration",
                "fVar3": "newEntrySpeed",
                "acceleration": "currentAcceleration",
                "target_velocity": "targetVelocity",
                "target_velocity_00": "targetVelocity_00",
                "distance": "currentDistance",
                "next_local": "nextBlockLocal",
                "current_local": "currentBlockLocal",
                "previous_local": "previousBlockLocal",
                "entry_speed": "entrySpeed"
            },
            "calling": [
                "planner_forward_pass"
            ],
            "called": [
                "__aeabi_fcmplt",
                "max_allowable_speed",
                "__aeabi_fcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ba8": {
            "entrypoint": "0x08002ba8",
            "current_name": "planner_forward_pass_08002ba8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid planner_forward_pass_08002ba8(void)\n\n{\n  block_array_t *previous_block;\n  uint block_index_uint;\n  block_array_t *block_array [3];\n  uint8_t current_block_index;\n  \n  block_array[1] = (block_array_t *)0x0;\n  block_array[2] = (block_array_t *)0x0;\n  current_block_index = buffer_tail;\n  while (previous_block = block_array[1], current_block_index != buffer_head) {\n    block_array[1] = block_array[2];\n    block_index_uint = (uint)current_block_index;\n    planner_pass_kernel(previous_block,block_array[2],block_array_buffer + block_index_uint);\n    current_block_index = get_next_block_index(current_block_index);\n    block_array[2] = block_array_buffer + block_index_uint;\n  }\n  planner_pass_kernel(block_array[1],block_array[2],(block_array_t *)0x0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ba8": "planner_forward_pass_08002ba8",
                "block": "block_array",
                "uVar1": "block_index_uint",
                "block_index": "current_block_index",
                "previous": "previous_block",
                "block_buffer_tail": "buffer_tail",
                "block_buffer_head": "buffer_head",
                "planner_forward_pass_kernel": "planner_pass_kernel",
                "next_block_index": "get_next_block_index"
            },
            "calling": [
                "planner_recalculate"
            ],
            "called": [
                "planner_forward_pass_kernel",
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c18": {
            "entrypoint": "0x08002c18",
            "current_name": "compute_acceleration_steps_08002c18",
            "code": "\n/* WARNING: Variable defined which should be unmapped: exitFactor-local */\n\nvoid computeAccelerationSteps_08002c18(inputBlock_t *inputBlock,float entryFactor,float exitFactor)\n\n{\n  undefined4 initialRateFactor;\n  uint32_t initialRate;\n  int rateDelta;\n  int finalRate;\n  uint accelerateSteps;\n  undefined4 rateFactor1;\n  undefined4 rateFactor2;\n  undefined4 rateFactor3;\n  undefined4 rateFactor4;\n  undefined4 rateFactor5;\n  undefined4 rateFactor6;\n  undefined4 rateFactor7;\n  float acceleration;\n  float deceleration;\n  float intersectionAcceleration;\n  float intersectionDistance;\n  undefined8 temp1;\n  undefined4 temp2;\n  float exitFactorLocal;\n  float entryFactorLocal;\n  inputBlock_t *inputBlockLocal;\n  int32_t decelerateSteps;\n  int32_t accelerationPerMinute;\n  int32_t plateauSteps;\n  int32_t accelerateSteps;\n  \n  initialRateFactor = __floatunsisf(entryFactor,inputBlock->nominal_rate);\n  initialRateFactor = __aeabi_fmul(initialRateFactor,rateFactor1);\n  initialRateFactor = __aeabi_f2d(initialRateFactor);\n  ceil((double)CONCAT44(rateFactor7,temp2));\n  initialRate = __aeabi_d2uiz(initialRateFactor,rateFactor2);\n  inputBlock->initial_rate = initialRate;\n  initialRateFactor = __floatunsisf(inputBlock->nominal_rate);\n  initialRateFactor = __aeabi_fmul(initialRateFactor,rateFactor7);\n  initialRateFactor = __aeabi_f2d(initialRateFactor);\n  ceil((double)CONCAT44(rateFactor7,temp2));\n  initialRate = __aeabi_d2uiz(initialRateFactor,rateFactor3);\n  inputBlock->final_rate = initialRate;\n  temp1 = __aeabi_i2d(inputBlock->rate_delta * 0x32);\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x404e0000);\n  rateDelta = __aeabi_d2iz((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  initialRateFactor = __floatunsisf(inputBlock->initial_rate);\n  __floatunsisf(inputBlock->nominal_rate);\n  temp1 = __floatsisf(rateDelta);\n  estimate_acceleration_intersectionDistance((float)temp1,(float)((ulonglong)temp1 >> 0x20),acceleration);\n  initialRateFactor = __aeabi_f2d(initialRateFactor);\n  ceil((double)CONCAT44(rateFactor7,temp2));\n  accelerateSteps = __aeabi_d2iz(initialRateFactor,rateFactor4);\n  initialRateFactor = __floatunsisf(inputBlock->nominal_rate);\n  __floatunsisf(inputBlock->final_rate);\n  temp1 = __floatsisf(-rateDelta);\n  estimate_acceleration_intersectionDistance((float)temp1,(float)((ulonglong)temp1 >> 0x20),deceleration);\n  initialRateFactor = __aeabi_f2d(initialRateFactor);\n  floor((double)CONCAT44(rateFactor7,temp2));\n  finalRate = __aeabi_d2iz(initialRateFactor,rateFactor5);\n  plateauSteps = (inputBlock->step_event_count - accelerateSteps) - finalRate;\n  if (plateauSteps < 0) {\n    initialRateFactor = __floatunsisf(inputBlock->initial_rate);\n    __floatunsisf(inputBlock->final_rate);\n    __floatsisf(rateDelta);\n    temp1 = __floatsisf(inputBlock->step_event_count);\n    intersection_intersectionDistance((float)temp1,(float)((ulonglong)temp1 >> 0x20),intersectionAcceleration,intersectionDistance);\n    initialRateFactor = __aeabi_f2d(initialRateFactor);\n    ceil((double)CONCAT44(rateFactor7,temp2));\n    accelerateSteps = __aeabi_d2iz(initialRateFactor,rateFactor6);\n    accelerateSteps = accelerateSteps & ~((int)accelerateSteps >> 0x1f);\n    accelerateSteps = inputBlock->step_event_count;\n    if ((int)accelerateSteps <= inputBlock->step_event_count) {\n      accelerateSteps = accelerateSteps;\n    }\n    plateauSteps = 0;\n  }\n  inputBlock->accelerate_until = accelerateSteps;\n  inputBlock->decelerate_after = plateauSteps + accelerateSteps;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c18": "compute_acceleration_steps_08002c18",
                "block": "inputBlock",
                "entry_factor": "entryFactor",
                "exit_factor": "exitFactor",
                "uVar1": "initialRateFactor",
                "uVar2": "initialRate",
                "iVar3": "rateDelta",
                "iVar4": "finalRate",
                "uVar5": "accelerateSteps",
                "in_r1": "rateFactor1",
                "extraout_r1": "rateFactor2",
                "extraout_r1_00": "rateFactor3",
                "extraout_r1_01": "rateFactor4",
                "extraout_r1_02": "rateFactor5",
                "extraout_r1_03": "rateFactor6",
                "in_r2": "rateFactor7",
                "acceleration_00": "deceleration",
                "acceleration_01": "intersectionAcceleration",
                "distance": "intersectionDistance",
                "uVar6": "temp1",
                "uStack_38": "temp2",
                "exit_factor_local": "exitFactorLocal",
                "entry_factor_local": "entryFactorLocal",
                "block_local": "inputBlockLocal",
                "decelerate_steps": "decelerateSteps",
                "acceleration_per_minute": "accelerationPerMinute",
                "plateau_steps": "plateauSteps",
                "accelerate_steps": "accelerateSteps"
            },
            "calling": [
                "planner_recalculate_trapezoids"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_f2d",
                "__muldf3",
                "intersection_distance",
                "__floatunsisf",
                "ceil",
                "__aeabi_d2uiz",
                "__aeabi_fmul",
                "estimate_acceleration_distance",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e08": {
            "entrypoint": "0x08002e08",
            "current_name": "calculate_and_update_trapezoids_08002e08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculate_and_update_trapezoids_08002e08(void)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  block_t *current_block;\n  block_t *next_block;\n  uint8_t current_index;\n  \n  next_block = (block_t *)0x0;\n  current_index = buffer_tail;\n  while (current_index != buffer_head) {\n    uVar1 = (uint)current_index;\n    if ((next_block != (block_t *)0x0) &&\n       ((next_block->needs_recalculation != '\\0' || (buffer[uVar1].needs_recalculation != '\\0')))) {\n      __aeabi_fdiv(next_block->current_entry_speed,next_block->current_nominal_speed);\n      uVar2 = __aeabi_fdiv(buffer[uVar1].current_entry_speed,next_block->current_nominal_speed);\n      calculate_and_update_trapezoid_for_block(next_block,(float)uVar2,(float)((ulonglong)uVar2 >> 0x20));\n      next_block->needs_recalculation = '\\0';\n    }\n    current_index = next_block_current_index(current_index);\n    next_block = buffer + uVar1;\n  }\n  __aeabi_fdiv(next_block->current_entry_speed,next_block->current_nominal_speed);\n  uVar2 = __aeabi_fdiv(0,next_block->current_nominal_speed);\n  calculate_and_update_trapezoid_for_block(next_block,(float)uVar2,(float)((ulonglong)uVar2 >> 0x20));\n  next_block->needs_recalculation = '\\0';\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e08": "calculate_and_update_trapezoids_08002e08",
                "current": "current_block",
                "next": "next_block",
                "block_index": "current_index",
                "block_buffer_tail": "buffer_tail",
                "block_buffer_head": "buffer_head",
                "block_buffer": "buffer",
                "recalculate_flag": "needs_recalculation",
                "entry_speed": "current_entry_speed",
                "nominal_speed": "current_nominal_speed",
                "calculate_trapezoid_for_block": "calculate_and_update_trapezoid_for_block"
            },
            "calling": [
                "planner_recalculate"
            ],
            "called": [
                "calculate_trapezoid_for_block",
                "__aeabi_fdiv",
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002edc": {
            "entrypoint": "0x08002edc",
            "current_name": "calculate_trapezoids_08002edc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculate_trapezoids_08002edc(void)\n\n{\n  perform_reverse_pass();\n  perform_forward_pass();\n  recalculate_trapezoid_coordinates();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002edc": "calculate_trapezoids_08002edc",
                "planner_reverse_pass": "perform_reverse_pass",
                "planner_forward_pass": "perform_forward_pass",
                "planner_recalculate_trapezoids": "recalculate_trapezoid_coordinates"
            },
            "calling": [
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "called": [
                "planner_reverse_pass",
                "planner_recalculate_trapezoids",
                "planner_forward_pass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ef0": {
            "entrypoint": "0x08002ef0",
            "current_name": "update_block_buffer_08002ef0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateBlockBuffer_08002ef0(void)\n\n{\n  currentTail = currentHead;\n  nextHead = next_block_index(currentHead);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ef0": "update_block_buffer_08002ef0",
                "block_buffer_tail": "currentTail",
                "block_buffer_head": "currentHead",
                "next_buffer_head": "nextHead"
            },
            "calling": [
                "plan_init"
            ],
            "called": [
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f24": {
            "entrypoint": "0x08002f24",
            "current_name": "initialize_buffer_08002f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_buffer_08002f24(void)\n\n{\n  reset_buffer();\n  memset(&buffer,0,0x1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f24": "initialize_buffer_08002f24",
                "plan_reset_buffer": "reset_buffer",
                "pl": "buffer"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "plan_reset_buffer",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f40": {
            "entrypoint": "0x08002f40",
            "current_name": "update_block_buffer_tail_08002f40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_block_buffer_tail_08002f40(void)\n\n{\n  if (head_index != tail_index) {\n    tail_index = get_next_index(tail_index);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f40": "update_block_buffer_tail_08002f40",
                "block_buffer_head": "head_index",
                "block_buffer_tail": "tail_index",
                "next_block_index": "get_next_index"
            },
            "calling": [
                "step_period_isr"
            ],
            "called": [
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f74": {
            "entrypoint": "0x08002f74",
            "current_name": "get_next_block_08002f74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nblock_t * get_next_block_08002f74(void)\n\n{\n  block_t *next_block;\n  \n  if (current_head == current_tail) {\n    next_block = (block_t *)0x0;\n  }\n  else {\n    next_block = block_buffer + current_tail;\n  }\n  return next_block;\n}\n\n",
            "renaming": {
                "FUN_08002f74": "get_next_block_08002f74",
                "block_buffer_head": "current_head",
                "block_buffer_tail": "current_tail",
                "pbVar1": "next_block"
            },
            "calling": [
                "plan_synchronize",
                "step_period_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fac": {
            "entrypoint": "0x08002fac",
            "current_name": "is_buffer_tail_equal_to_next_buffer_head_08002fac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t is_buffer_tail_equal_to_next_buffer_head_08002fac(void)\n\n{\n  return block_buffer_tail == next_buffer_head;\n}\n\n",
            "renaming": {
                "FUN_08002fac": "is_buffer_tail_equal_to_next_buffer_head_08002fac"
            },
            "calling": [
                "mc_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fd4": {
            "entrypoint": "0x08002fd4",
            "current_name": "execute_until_abort_08002fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_until_abort_08002fd4(void)\n\n{\n  block_t *current_block;\n  \n  while ((current_block = plan_get_current_block(), current_block != (block_t *)0x0 || (system_state == '\\x03'))) {\n    protocol_execute_runtime();\n    if (abort_flag != '\\0') {\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fd4": "execute_until_abort_08002fd4",
                "pbVar1": "current_block",
                "sys.state": "system_state",
                "sys.abort": "abort_flag"
            },
            "calling": [
                "gc_execute_line",
                "mc_go_home",
                "mc_dwell",
                "coolant_run",
                "spindle_run"
            ],
            "called": [
                "protocol_execute_runtime",
                "plan_get_current_block"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003004": {
            "entrypoint": "0x08003004",
            "current_name": "calculate_junction_speed_08003004",
            "code": "\n/* WARNING: Variable defined which should be unmapped: feedRate-local */\n\nvoid calculateJunctionSpeed_08003004(float posX,float posY,float posZ,float feedRate,uint8_t invertFeedRate)\n\n{\n  undefined4 stepsX;\n  long currentPosX;\n  long currentPosY;\n  long currentPosZ;\n  undefined4 stepsY;\n  undefined4 stepsZ;\n  undefined4 distanceSquared;\n  undefined4 temp;\n  float distance;\n  int32_t rateDelta;\n  float unitVecX;\n  float unitVecY;\n  float unitVecZ;\n  int condition;\n  float acceleration;\n  undefined4 in_r1;\n  undefined4 eposXtraout_r1;\n  undefined4 eposXtraout_r1_00;\n  undefined4 eposXtraout_r1_01;\n  undefined4 eposXtraout_r1_02;\n  undefined4 eposXtraout_r1_03;\n  undefined4 eposXtraout_r1_04;\n  undefined4 in_r2;\n  uint maxSteps;\n  undefined4 in_r3;\n  uint bufferIndex;\n  block_t *block;\n  uint32_t difference;\n  uint maxDiff;\n  undefined8 eposXtraout_d0;\n  undefined8 eposXtraout_d0_00;\n  undefined8 eposXtraout_d0_01;\n  undefined8 eposXtraout_d0_02;\n  undefined8 eposXtraout_d0_03;\n  undefined8 eposXtraout_d0_04;\n  float eposXtraout_s2;\n  float eposXtraout_s2_00;\n  float eposXtraout_s2_01;\n  float eposXtraout_s2_02;\n  float eposXtraout_s2_03;\n  float eposXtraout_s2_04;\n  undefined8 deltaSpeed;\n  undefined8 inversedNorm;\n  undefined8 tempSpeed;\n  char conditionFlag;\n  float localFeedRate;\n  float localPosZ;\n  float localPosY;\n  float localPosX;\n  float direction [3];\n  float deltaDistance [3];\n  int32_t targetPosition [3];\n  float allowableSpeed;\n  float sinThetaD2;\n  float cosTheta;\n  float inverseMillimeters;\n  block_t *block;\n  float junctionSpeed;\n  float inverseMinute;\n  \n  bufferIndex = (uint)block_buffer_head;\n  block = block_buffer + bufferIndex;\n  stepsX = __aeabi_fmul(posX,settings.steps_per_mm[0],invertFeedRate);\n  __aeabi_f2d(stepsX);\n  currentPosX = lround((double)CONCAT44(in_r2,in_r3));\n  stepsX = __aeabi_fmul(settings.steps_per_mm[1],in_r1);\n  __aeabi_f2d(stepsX);\n  currentPosY = lround((double)CONCAT44(in_r2,in_r3));\n  stepsX = __aeabi_fmul(settings.steps_per_mm[2],in_r2);\n  __aeabi_f2d(stepsX);\n  currentPosZ = lround((double)CONCAT44(in_r2,in_r3));\n  block->direction_bits = 0;\n  if (currentPosX < pl.position[0]) {\n    block->direction_bits = block->direction_bits | 0posX20;\n  }\n  if (currentPosY < pl.position[1]) {\n    block->direction_bits = block->direction_bits | 0posX880;\n  }\n  if (currentPosZ < pl.position[2]) {\n    block->direction_bits = block->direction_bits | 0posX200;\n  }\n  difference = currentPosX - pl.position[0];\n  if ((int)difference < 0) {\n    difference = -difference;\n  }\n  block_buffer[bufferIndex].steps_posX = difference;\n  difference = currentPosY - pl.position[1];\n  if ((int)difference < 0) {\n    difference = -difference;\n  }\n  block_buffer[bufferIndex].steps_posY = difference;\n  difference = currentPosZ - pl.position[2];\n  if ((int)difference < 0) {\n    difference = -difference;\n  }\n  block_buffer[bufferIndex].steps_posZ = difference;\n  maxSteps = block_buffer[bufferIndex].steps_posZ;\n  if (block_buffer[bufferIndex].steps_posZ < block_buffer[bufferIndex].steps_posY) {\n    maxSteps = block_buffer[bufferIndex].steps_posY;\n  }\n  maxDiff = block_buffer[bufferIndex].steps_posX;\n  if (block_buffer[bufferIndex].steps_posX < maxSteps) {\n    maxDiff = maxSteps;\n  }\n  block_buffer[bufferIndex].step_event_count = maxDiff;\n  if (block_buffer[bufferIndex].step_event_count != 0) {\n    stepsX = __floatsisf(currentPosX - pl.position[0]);\n    stepsX = __aeabi_fdiv(stepsX,settings.steps_per_mm[0]);\n    stepsY = __floatsisf(currentPosY - pl.position[1]);\n    stepsY = __aeabi_fdiv(stepsY,settings.steps_per_mm[1]);\n    stepsZ = __floatsisf(currentPosZ - pl.position[2]);\n    stepsZ = __aeabi_fdiv(stepsZ,settings.steps_per_mm[2]);\n    distanceSquared = __aeabi_fmul(stepsX,stepsX);\n    temp = __aeabi_fmul(stepsY,stepsY);\n    distanceSquared = __addsf3(distanceSquared,temp);\n    temp = __aeabi_fmul(stepsZ,stepsZ);\n    distanceSquared = __addsf3(distanceSquared,temp);\n    distanceSquared = __aeabi_f2d(distanceSquared);\n    sqrt((double)CONCAT44(in_r2,in_r3));\n    distance = (float)__truncdfsf2(distanceSquared,eposXtraout_r1);\n    block_buffer[bufferIndex].millimeters = distance;\n    distanceSquared = __aeabi_fdiv(0posX3f800000,block_buffer[bufferIndex].millimeters);\n    if (conditionFlag == '\\0') {\n      inverseMinute = (float)__aeabi_fmul(in_r3,distanceSquared);\n    }\n    else {\n      inverseMinute = (float)__aeabi_fdiv(0posX3f800000,in_r3);\n    }\n    distance = (float)__aeabi_fmul(block_buffer[bufferIndex].millimeters,inverseMinute);\n    block_buffer[bufferIndex].nominal_speed = distance;\n    temp = __floatsisf(block_buffer[bufferIndex].step_event_count);\n    temp = __aeabi_fmul(temp,inverseMinute);\n    temp = __aeabi_f2d(temp);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    difference = __aeabi_d2uiposZ(temp,eposXtraout_r1_00);\n    block_buffer[bufferIndex].nominal_rate = difference;\n    temp = __floatsisf(block_buffer[bufferIndex].step_event_count);\n    temp = __aeabi_fmul(temp,distanceSquared);\n    temp = __aeabi_fmul(temp,settings.acceleration);\n    temp = __aeabi_fdiv(temp,0posX453b8000);\n    temp = __aeabi_f2d(temp);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    rateDelta = __aeabi_d2iposZ(temp,eposXtraout_r1_01);\n    block_buffer[bufferIndex].rate_delta = rateDelta;\n    unitVecX = (float)__aeabi_fmul(stepsX,distanceSquared);\n    unitVecY = (float)__aeabi_fmul(stepsY,distanceSquared);\n    unitVecZ = (float)__aeabi_fmul(stepsZ,distanceSquared);\n    junctionSpeed = 0.0;\n    deltaSpeed = eposXtraout_d0;\n    distance = eposXtraout_s2;\n    if ((block_buffer_head != block_buffer_tail) &&\n       (condition = __aeabi_fcmpgt(pl.previous_nominal_speed,0), deltaSpeed = eposXtraout_d0_00,\n       distance = eposXtraout_s2_00, condition != 0)) {\n      stepsX = __aeabi_fmul((uint)pl.previous_direction[0] ^ 0posX80000000,unitVecX);\n      stepsY = __aeabi_fmul(pl.previous_direction[1],unitVecY);\n      stepsX = __aeabi_fsub(stepsX,stepsY);\n      stepsY = __aeabi_fmul(pl.previous_direction[2],unitVecZ);\n      stepsX = __aeabi_fsub(stepsX,stepsY);\n      deltaSpeed = __aeabi_f2d(stepsX);\n      condition = __aeabi_dcmplt((int)deltaSpeed,(int)((ulonglong)deltaSpeed >> 0posX20),0posX66666666,0posX3fee6666);\n      deltaSpeed = eposXtraout_d0_01;\n      distance = eposXtraout_s2_01;\n      if (condition != 0) {\n        condition = __aeabi_fcmplt(pl.previous_nominal_speed,block_buffer[bufferIndex].nominal_speed);\n        junctionSpeed = pl.previous_nominal_speed;\n        if (condition == 0) {\n          junctionSpeed = block_buffer[bufferIndex].nominal_speed;\n        }\n        deltaSpeed = __aeabi_f2d(stepsX);\n        condition = __aeabi_dcmpgt((int)deltaSpeed,(int)((ulonglong)deltaSpeed >> 0posX20),0posX66666666,0posXbfee6666);\n        deltaSpeed = eposXtraout_d0_02;\n        distance = eposXtraout_s2_02;\n        if (condition != 0) {\n          deltaSpeed = __aeabi_f2d(stepsX);\n          deltaSpeed = __subdf3(0,0posX3ff00000,(int)deltaSpeed,(int)((ulonglong)deltaSpeed >> 0posX20));\n          stepsX = __muldf3((int)deltaSpeed,(int)((ulonglong)deltaSpeed >> 0posX20),0,0posX3fe00000);\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          stepsX = __truncdfsf2(stepsX,eposXtraout_r1_02);\n          deltaSpeed = __aeabi_f2d(junctionSpeed);\n          stepsY = __aeabi_fmul(settings.acceleration,settings.junction_deviation);\n          stepsY = __aeabi_fmul(stepsY,stepsX);\n          inversedNorm = __aeabi_f2d(stepsY);\n          tempSpeed = __aeabi_f2d(stepsX);\n          tempSpeed = __subdf3(0,0posX3ff00000,(int)tempSpeed,(int)((ulonglong)tempSpeed >> 0posX20));\n          stepsY = __divdf3((int)inversedNorm,(int)((ulonglong)inversedNorm >> 0posX20),(int)tempSpeed,\n                           (int)((ulonglong)tempSpeed >> 0posX20));\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          condition = __aeabi_dcmplt((int)deltaSpeed,(int)((ulonglong)deltaSpeed >> 0posX20),stepsY,eposXtraout_r1_03)\n          ;\n          deltaSpeed = eposXtraout_d0_03;\n          distance = eposXtraout_s2_03;\n          if (condition == 0) {\n            stepsY = __aeabi_fmul(settings.acceleration,settings.junction_deviation);\n            stepsY = __aeabi_fmul(stepsY,stepsX);\n            deltaSpeed = __aeabi_f2d(stepsY);\n            inversedNorm = __aeabi_f2d(stepsX);\n            inversedNorm = __subdf3(0,0posX3ff00000,(int)inversedNorm,(int)((ulonglong)inversedNorm >> 0posX20));\n            stepsX = __divdf3((int)deltaSpeed,(int)((ulonglong)deltaSpeed >> 0posX20),(int)inversedNorm,\n                             (int)((ulonglong)inversedNorm >> 0posX20));\n            sqrt((double)CONCAT44(in_r2,in_r3));\n            junctionSpeed = (float)__truncdfsf2(stepsX,eposXtraout_r1_04);\n            deltaSpeed = eposXtraout_d0_04;\n            distance = eposXtraout_s2_04;\n          }\n        }\n      }\n    }\n    block_buffer[bufferIndex].maposX_entrposY_speed = junctionSpeed;\n    acceleration = (float)((uint)settings.acceleration ^ 0posX80000000);\n    maposX_allowable_speed((float)deltaSpeed,(float)((ulonglong)deltaSpeed >> 0posX20),distance);\n    condition = __aeabi_fcmplt(junctionSpeed,acceleration);\n    distance = acceleration;\n    if (condition != 0) {\n      distance = junctionSpeed;\n    }\n    block_buffer[bufferIndex].entrposY_speed = distance;\n    condition = __aeabi_fcmpge(acceleration,block_buffer[bufferIndex].nominal_speed);\n    if (condition == 0) {\n      block_buffer[bufferIndex].nominal_length_flag = '\\0';\n    }\n    else {\n      block_buffer[bufferIndex].nominal_length_flag = '\\posX01';\n    }\n    block_buffer[bufferIndex].recalculate_flag = '\\posX01';\n    pl.previous_nominal_speed = block_buffer[bufferIndex].nominal_speed;\n    block_buffer_head = neposXt_buffer_head;\n    pl.previous_direction[0] = unitVecX;\n    pl.previous_direction[1] = unitVecY;\n    pl.previous_direction[2] = unitVecZ;\n    neposXt_buffer_head = neposXt_block_indeposX(neposXt_buffer_head);\n    pl.position[0] = currentPosX;\n    pl.position[1] = currentPosY;\n    pl.position[2] = currentPosZ;\n    planner_recalculate();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003004": "calculate_junction_speed_08003004",
                "x": "posX",
                "y": "posY",
                "z": "posZ",
                "feed_rate": "feedRate",
                "invert_feed_rate": "invertFeedRate",
                "uVar1": "stepsX",
                "lVar2": "currentPosX",
                "lVar3": "currentPosY",
                "lVar4": "currentPosZ",
                "uVar5": "stepsY",
                "uVar6": "stepsZ",
                "uVar7": "distanceSquared",
                "uVar8": "temp",
                "fVar9": "distance",
                "iVar10": "rateDelta",
                "fVar11": "unitVecX",
                "fVar12": "unitVecY",
                "fVar13": "unitVecZ",
                "iVar14": "condition",
                "fVar15": "acceleration",
                "uVar16": "maxSteps",
                "uVar17": "bufferIndex",
                "uVar19": "difference",
                "uVar20": "maxDiff",
                "pbVar18": "block",
                "uVar21": "deltaSpeed",
                "uVar22": "inversedNorm",
                "uVar23": "tempSpeed",
                "in_stack_00000000": "conditionFlag",
                "feed_rate_local": "localFeedRate",
                "z_local": "localPosZ",
                "y_local": "localPosY",
                "x_local": "localPosX",
                "unit_vec": "direction",
                "delta_mm": "deltaDistance",
                "target": "targetPosition",
                "v_allowable": "allowableSpeed",
                "sin_theta_d2": "sinThetaD2",
                "cos_theta": "cosTheta",
                "inverse_millimeters": "inverseMillimeters",
                "vmax_junction": "junctionSpeed",
                "inverse_minute": "inverseMinute"
            },
            "calling": [
                "mc_line"
            ],
            "called": [
                "__floatsisf",
                "__muldf3",
                "__truncdfsf2",
                "sqrt",
                "__aeabi_d2uiz",
                "__aeabi_fdiv",
                "lround",
                "planner_recalculate",
                "__subdf3",
                "max_allowable_speed",
                "__aeabi_f2d",
                "ceil",
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_dcmplt",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "__aeabi_fcmpgt",
                "next_block_index",
                "__aeabi_d2iz",
                "__divdf3",
                "__aeabi_fcmpge",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ec": {
            "entrypoint": "0x080035ec",
            "current_name": "set_position_080035ec",
            "code": "\nvoid setPosition_080035ec(int32_t newX,int32_t newY,int32_t newZ)\n\n{\n  int32_t localZ;\n  int32_t localY;\n  int32_t localX;\n  \n  pl.position[0] = newX;\n  pl.position[1] = newY;\n  pl.position[2] = newZ;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ec": "set_position_080035ec",
                "x": "newX",
                "y": "newY",
                "z": "newZ",
                "z_local": "localZ",
                "y_local": "localY",
                "x_local": "localX"
            },
            "calling": [
                "sys_sync_current_position"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003618": {
            "entrypoint": "0x08003618",
            "current_name": "update_block_buffer_entry_08003618",
            "code": "\nvoid updateBlockBufferEntry_08003618(int32_t remainingStepEvents)\n\n{\n  undefined4 millimetersPerEvent;\n  undefined4 originalStepEventCount;\n  uint bufferTail;\n  float currentMillimeters;\n  int32_t localRemainingStepEvents;\n  currentBlock_t *currentBlock;\n  \n  bufferTail = (uint)currentBlock_buffer_tail;\n  currentMillimeters = currentBlock_buffer[bufferTail].millimeters;\n  millimetersPerEvent = __floatsisf(remainingStepEvents);\n  millimetersPerEvent = __aeabi_fmul(currentMillimeters,millimetersPerEvent);\n  originalStepEventCount = __floatsisf(currentBlock_buffer[bufferTail].step_event_count);\n  currentMillimeters = (float)__aeabi_fdiv(millimetersPerEvent,originalStepEventCount);\n  currentBlock_buffer[bufferTail].millimeters = currentMillimeters;\n  currentBlock_buffer[bufferTail].step_event_count = remainingStepEvents;\n  currentBlock_buffer[bufferTail].entry_speed = 0.0;\n  currentBlock_buffer[bufferTail].max_entry_speed = 0.0;\n  currentBlock_buffer[bufferTail].nominal_length_flag = '\\0';\n  currentBlock_buffer[bufferTail].recalculate_flag = '\\x01';\n  planner_recalculate();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003618": "update_block_buffer_entry_08003618",
                "step_events_remaining": "remainingStepEvents",
                "uVar1": "millimetersPerEvent",
                "uVar2": "originalStepEventCount",
                "uVar3": "bufferTail",
                "fVar4": "currentMillimeters",
                "step_events_remaining_local": "localRemainingStepEvents",
                "block": "currentBlock"
            },
            "calling": [
                "st_cycle_reinitialize"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fdiv",
                "planner_recalculate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800369c": {
            "entrypoint": "0x0800369c",
            "current_name": "print_string_0800369c",
            "code": "\nvoid print_string_0800369c(char *string_to_print)\n\n{\n  char *current_character;\n  \n  current_character = string_to_print;\n  while (*current_character != '\\0') {\n    string_to_printerial_write(*current_character);\n    current_character = current_character + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800369c": "print_string_0800369c",
                "s": "string_to_print",
                "s_local": "current_character"
            },
            "calling": [
                "protocol_execute_startup",
                "report_startup_line"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036c6": {
            "entrypoint": "0x080036c6",
            "current_name": "output_string_080036c6",
            "code": "\nvoid outputString_080036c6(char *inputString)\n\n{\n  char *currentChar;\n  \n  currentChar = inputString;\n  while (*currentChar != '\\0') {\n    inputStringerial_write(*currentChar);\n    currentChar = currentChar + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036c6": "output_string_080036c6",
                "s": "inputString",
                "s_local": "currentChar"
            },
            "calling": [
                "report_status_message",
                "report_grbl_help",
                "report_init_message",
                "report_grbl_settings",
                "report_feedback_message",
                "report_realtime_status",
                "report_gcode_modes",
                "report_gcode_parameters",
                "report_startup_line",
                "report_alarm_message"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f0": {
            "entrypoint": "0x080036f0",
            "current_name": "print_bits_080036f0",
            "code": "\nvoindexd print_bits_080036f0(uindexnumbert number,indexnumbert num_bits)\n\n{\n  uindexnumbert8_t bit_value;\n  indexnumbert local_num_bits;\n  uindexnumbert local_number;\n  indexnumbert index;\n  uindexnumbert32_t bit_mask;\n  \n  bit_mask = 1 << (num_bits - 1U & 0xff);\n  for (index = 0; index < num_bits; index = index + 1) {\n    indexf ((bit_mask & number) == 0) {\n      bit_value = '0';\n    }\n    else {\n      bit_value = '1';\n    }\n    serindexal_wrindexte(bit_value);\n    bit_mask = bit_mask >> 1;\n  }\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_080036f0": "print_bits_080036f0",
                "n": "number",
                "bits": "num_bits",
                "data": "bit_value",
                "bits_local": "local_num_bits",
                "n_local": "local_number",
                "i": "index",
                "mask": "bit_mask"
            },
            "calling": [
                "print_uint8_base2",
                "print_uint16_base2"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003740": {
            "entrypoint": "0x08003740",
            "current_name": "print_binary_number_08003740",
            "code": "\nvoid print_binary_number_08003740(uiinput_numbert8_t input_number)\n\n{\n  uiinput_numbert8_t local_number;\n  \n  priinput_numbert_base2((uiinput_numbert)input_number,8);\n  returinput_number;\n}\n\n",
            "renaming": {
                "FUN_08003740": "print_binary_number_08003740",
                "n": "input_number",
                "n_local": "local_number"
            },
            "calling": [],
            "called": [
                "print_base2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800375c": {
            "entrypoint": "0x0800375c",
            "current_name": "print_binary_representation_0800375c",
            "code": "\nvoid print_binary_representation_0800375c(uinumbert16_t number)\n\n{\n  uinumbert16_t local_number;\n  \n  prinumbert_base2((uinumbert)number,0x10);\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_0800375c": "print_binary_representation_0800375c",
                "n": "number",
                "n_local": "local_number"
            },
            "calling": [
                "report_grbl_settings"
            ],
            "called": [
                "print_base2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003778": {
            "entrypoint": "0x08003778",
            "current_name": "print_number_08003778",
            "code": "\nvoindexd print_number_08003778(ulonumberg number)\n\n{\n  uindexnumbert temp1;\n  ulonumberg local_number;\n  uindexnumbert8_t stack_variable;\n  uchar buffer [10];\n  uindexnumbert8_t index;\n  \n  index = '\\0';\n  local_number = number;\n  indexf (number == 0) {\n    serindexal_wrindexte('0');\n  }\n  else {\n    for (; local_number != 0; local_number = local_number / 10) {\n      temp1 = (uindexnumbert)index;\n      index = index + '\\x01';\n      buffer[temp1] = (char)(local_number % 10) + '0';\n    }\n    for (; index != '\\0'; index = index + 0xff) {\n      serindexal_wrindexte(buffer[index - 1]);\n    }\n  }\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_08003778": "print_number_08003778",
                "n": "number",
                "uVar1": "temp1",
                "n_local": "local_number",
                "uStack_15": "stack_variable",
                "buf": "buffer",
                "i": "index"
            },
            "calling": [
                "printInteger"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "print_absolute_value_080037fc",
            "code": "\nvoid print_absolute_value_080037fc(lonumberg number)\n\n{\n  lonumberg absolute_value;\n  \n  absolute_value = number;\n  if (number < 0) {\n    write_minus_sign('-');\n    absolute_value = -number;\n  }\n  print_positive_number(absolute_value);\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "print_absolute_value_080037fc",
                "n": "number",
                "n_local": "absolute_value",
                "serial_write": "write_minus_sign",
                "print_uint32_base10": "print_positive_number"
            },
            "calling": [
                "report_grbl_settings",
                "report_gcode_modes",
                "report_startup_line"
            ],
            "called": [
                "serial_write",
                "print_uint32_base10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003826": {
            "entrypoint": "0x08003826",
            "current_name": "convert_float_to_decimal_string_08003826",
            "code": "\nvocounterd convertFloatToDecimalString_08003826(float inputValue)\n\n{\n  float tempValue;\n  counterinputValuet isNegative;\n  uinputValuedefcounterinputValueed4 floatSum;\n  byte bufferIndex;\n  ucounterinputValuet tempIndex;\n  float absoluteValue;\n  ucounterinputValuet8_t tempVariable;\n  uchar buffer [10];\n  ucounterinputValuet32_t a;\n  ucounterinputValuet8_t counter;\n  ucounterinputValuet8_t decimalPlaces;\n  \n  isNegative = __aeabcounter_fcmplt(tempValue,0);\n  absoluteValue = tempValue;\n  counterf (isNegative != 0) {\n    sercounteral_wrcounterte('-');\n    absoluteValue = (float)((ucounterinputValuet)tempValue ^ 0x80000000);\n  }\n  for (decimalPlaces = settcounterinputValuegs.deccountermal_places; 1 < decimalPlaces; decimalPlaces = decimalPlaces + 0xfe) {\n    absoluteValue = (float)__aeabcounter_fmul(absoluteValue,0x42c80000);\n  }\n  counterf (decimalPlaces != '\\0') {\n    absoluteValue = (float)__aeabcounter_fmul(absoluteValue,0x41200000);\n  }\n  floatSum = __addsf3(absoluteValue,0x3f000000);\n  counter = '\\0';\n  a = __aeabcounter_f2counterz(floatSum);\n  buffer[settcounterinputValuegs.deccountermal_places] = '.';\n  for (; a != 0; a = a / 10) {\n    counterf (counter == settcounterinputValuegs.deccountermal_places) {\n      counter = counter + '\\x01';\n    }\n    tempIndex = (ucounterinputValuet)counter;\n    counter = counter + '\\x01';\n    buffer[tempIndex] = (char)(a % 10) + '0';\n  }\n  whcounterle (counter < settcounterinputValuegs.deccountermal_places) {\n    tempIndex = (ucounterinputValuet)counter;\n    counter = counter + '\\x01';\n    buffer[tempIndex] = '0';\n  }\n  counterf (counter == settcounterinputValuegs.deccountermal_places) {\n    bufferIndex = counter + 1;\n    counter = counter + '\\x02';\n    buffer[bufferIndex] = '0';\n  }\n  for (; counter != '\\0'; counter = counter + 0xff) {\n    sercounteral_wrcounterte(buffer[counter - 1]);\n  }\n  returinputValue;\n}\n\n",
            "renaming": {
                "FUN_08003826": "convert_float_to_decimal_string_08003826",
                "n": "inputValue",
                "in_r0": "tempValue",
                "iVar1": "isNegative",
                "uVar2": "floatSum",
                "bVar3": "bufferIndex",
                "uVar4": "tempIndex",
                "n_local": "absoluteValue",
                "uStack_1d": "tempVariable",
                "buf": "buffer",
                "i": "counter",
                "decimals": "decimalPlaces"
            },
            "calling": [
                "report_grbl_settings",
                "report_realtime_status",
                "report_gcode_modes",
                "report_gcode_parameters"
            ],
            "called": [
                "serial_write",
                "__addsf3",
                "__aeabi_f2iz",
                "__aeabi_fcmplt",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003980": {
            "entrypoint": "0x08003980",
            "current_name": "initialize_character_counters_08003980",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeCharacterCounters_08003980(void)\n\n{\n  char_counter = '\\0';\n  iscomment = '\\0';\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003980": "initialize_character_counters_08003980"
            },
            "calling": [
                "protocol_init",
                "protocol_process"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080039a0": {
            "entrypoint": "0x080039a0",
            "current_name": "initialize_protocol_080039a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeProtocol_080039a0(void)\n\n{\n  resetLineBuffer();\n  displayInitMessage();\n  areButtonsEnabled = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080039a0": "initialize_protocol_080039a0",
                "protocol_reset_line_buffer": "resetLineBuffer",
                "report_init_message": "displayInitMessage",
                "buttons_enabled": "areButtonsEnabled"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "report_init_message",
                "protocol_reset_line_buffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080039bc": {
            "entrypoint": "0x080039bc",
            "current_name": "process_startup_lines_080039bc",
            "code": "\n/* WARNING: Uline_numberkline_numberowline_number calliline_numberg coline_numberveline_numbertioline_number */\n\nvoid process_startup_lines_080039bc(void)\n\n{\n  uiline_numbert8_t success;\n  uiline_numbert8_t line_number;\n  \n  for (line_number = '\\0'; line_number < 2; line_number = line_number + '\\x01') {\n    success = settiline_numbergs_read_startup_liline_numbere(line_number,liline_numbere);\n    if (success == '\\0') {\n      report_status_message('\\line_number');\n    }\n    else if (liline_numbere[0] != '\\0') {\n      priline_numbertStriline_numberg(liline_numbere);\n      success = gc_execute_liline_numbere(liline_numbere);\n      report_status_message(success);\n    }\n  }\n  returline_number;\n}\n\n",
            "renaming": {
                "FUN_080039bc": "process_startup_lines_080039bc",
                "uVar1": "success",
                "n": "line_number"
            },
            "calling": [
                "grbl_main",
                "protocol_execute_line"
            ],
            "called": [
                "gc_execute_line",
                "report_status_message",
                "printString",
                "settings_read_startup_line"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a18": {
            "entrypoint": "0x08003a18",
            "current_name": "check_button_and_execute_08003a18",
            "code": "\nvoid checkButtonAndExecute_08003a18(uint32_t inputButtons)\n\n{\n  uint32_t localButtons;\n  \n  if ((inputButtons & 0x80) == 0) {\n    if ((inputButtons & 0x40) == 0) {\n      if ((inputButtons & 0x20) != 0) {\n        sys.execute = sys.execute | 2;\n      }\n    }\n    else {\n      sys.execute = sys.execute | 8;\n    }\n  }\n  else {\n    mc_reset();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003a18": "check_button_and_execute_08003a18",
                "buttons": "inputButtons",
                "buttons_local": "localButtons"
            },
            "calling": [
                "debounce_on_handler"
            ],
            "called": [
                "mc_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a74": {
            "entrypoint": "0x08003a74",
            "current_name": "handle_execution_08003a74",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08003ad2) */\n/* WARNING: Unknown calling convention */\n\nvoid handle_execution_08003a74(void)\n\n{\n  uint8_t execution_flags;\n  uint8_t runtime_execution;\n  \n  execution_flags = system_execution;\n  if (system_execution != '\\0') {\n    if ((system_execution & 0x60) != 0) {\n      system_state = '\\x06';\n      if ((system_execution & 0x40) != 0) {\n        report_alarm(-1);\n        report_feedback('\\x01');\n        do {\n        } while( true );\n      }\n      report_alarm(-2);\n      system_execution = system_execution & 0x9f;\n    }\n    if ((execution_flags & 0x10) == 0) {\n      if ((execution_flags & 1) != 0) {\n        report_realtime();\n        system_execution = system_execution & 0xfe;\n      }\n      if ((execution_flags & 8) != 0) {\n        set_feed_hold();\n        system_execution = system_execution & 0xf7;\n      }\n      if ((execution_flags & 4) != 0) {\n        cycle_reinitialize();\n        system_execution = system_execution & 0xfb;\n      }\n      if ((execution_flags & 2) != 0) {\n        cycle_start();\n        if ((system_flags & 2) != 0) {\n          auto_start = '\\x01';\n        }\n        system_execution = system_execution & 0xfd;\n      }\n    }\n    else {\n      abort = '\\x01';\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003a74": "handle_execution_08003a74",
                "uVar1": "execution_flags",
                "rt_exec": "runtime_execution",
                "sys.execute": "system_execution",
                "sys.state": "system_state",
                "report_alarm_message": "report_alarm",
                "report_feedback_message": "report_feedback",
                "report_realtime_status": "report_realtime",
                "st_feed_hold": "set_feed_hold",
                "st_cycle_reinitialize": "cycle_reinitialize",
                "st_cycle_start": "cycle_start",
                "settings.flags": "system_flags",
                "sys.auto_start": "auto_start",
                "sys.abort": "abort"
            },
            "calling": [
                "mc_go_home",
                "grbl_main",
                "plan_synchronize",
                "mc_dwell",
                "protocol_process",
                "mc_line"
            ],
            "called": [
                "report_feedback_message",
                "st_feed_hold",
                "report_realtime_status",
                "st_cycle_start",
                "report_alarm_message",
                "st_cycle_reinitialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003b98": {
            "entrypoint": "0x08003b98",
            "current_name": "process_gcode_command_08003b98",
            "code": "\n/* WARNING: Variable defined which should be unmapped: command-local */\n\nuint8_t processGcodeCommand_08003b98(char *command)\n\n{\n  byte firstChar;\n  uint8_t returnValue;\n  int result;\n  undefined4 conversionResult;\n  undefined4 extraReturnValue;\n  uint counter;\n  float convertedValue;\n  undefined4 tempValue;\n  char *localCommand;\n  float floatValue;\n  float floatParameter;\n  uint8_t characterCounter;\n  uint8_t helperVariable;\n  \n  if (*command != '$') {\n    returnValue = executeLine(command);\n    return returnValue;\n  }\n  characterCounter = '\\x01';\n  helperVariable = '\\0';\n  firstChar = command[1];\n  if (firstChar == 0) {\n    reportGrblHelp();\n    return '\\0';\n  }\n  if ((0x58 < firstChar) || (firstChar < 0x23)) goto switchD_08003bdc_caseD_25;\n  switch(firstChar) {\n  case 0x23:\n    characterCounter = '\\x02';\n    if (command[2] != '\\0') {\n      return '\\x03';\n    }\n    reportGcodeParameters();\n    break;\n  case 0x24:\n    characterCounter = '\\x02';\n    if (command[2] != '\\0') {\n      return '\\x03';\n    }\n    reportGrblSettings();\n    break;\n  case 0x43:\n    characterCounter = '\\x02';\n    if (command[2] != '\\0') {\n      return '\\x03';\n    }\n    if (systemState == '\\a') {\n      mc_reset();\n      reportFeedbackMessage('\\x05');\n    }\n    else {\n      if (systemState != '\\0') {\n        return '\\v';\n      }\n      systemState = '\\a';\n      reportFeedbackMessage('\\x04');\n    }\n    break;\n  case 0x47:\n    characterCounter = '\\x02';\n    if (command[2] != '\\0') {\n      return '\\x03';\n    }\n    reportGcodeModes();\n    break;\n  case 0x48:\n    if ((flags & 0x10) == 0) {\n      return '\\a';\n    }\n    if ((systemState != '\\0') && (systemState != '\\x06')) {\n      return '\\v';\n    }\n    mc_go_home();\n    if (abort == '\\0') {\n      executeStartupProtocol();\n    }\n    break;\n  case 0x4e:\n    characterCounter = '\\x02';\n    if (command[2] == '\\0') {\n      for (helperVariable = '\\0'; helperVariable < 2; helperVariable = helperVariable + '\\x01') {\n        returnValue = readStartupLine(helperVariable,command);\n        if (returnValue == '\\0') {\n          reportStatusMessage('\\n');\n        }\n        else {\n          report_startup_command(helperVariable,command);\n        }\n      }\n      return '\\0';\n    }\n    helperVariable = '\\x01';\n  default:\nswitchD_08003bdc_caseD_25:\n    result = readFloat(command,&characterCounter,&floatParameter);\n    if (result == 0) {\n      return '\\x01';\n    }\n    firstChar = characterCounter + 1;\n    if (command[characterCounter] != '=') {\n      return '\\x03';\n    }\n    characterCounter = firstChar;\n    if (helperVariable == '\\0') {\n      result = readFloat(command,&characterCounter,&floatValue);\n      if (result == 0) {\n        return '\\x01';\n      }\n      if (command[characterCounter] == '\\0') {\n        result = convertFloatToInt(floatParameter);\n        returnValue = storeGlobalSetting(result,convertedValue);\n        return returnValue;\n      }\n      return '\\x03';\n    }\n    do {\n      command[(uint)characterCounter - (uint)firstChar] = command[characterCounter];\n      counter = (uint)characterCounter;\n      characterCounter = characterCounter + '\\x01';\n    } while (command[counter] != '\\0');\n    helperVariable = firstChar;\n    helperVariable = executeLine(command);\n    if (helperVariable != '\\0') {\n      return helperVariable;\n    }\n    conversionResult = convertFloatToDouble(floatParameter);\n    truncate((double)CONCAT44(command,tempValue));\n    helperVariable = convertDoubleToUint(conversionResult,extraReturnValue);\n    storeStartupLine(helperVariable,command);\n    break;\n  case 0x58:\n    characterCounter = '\\x02';\n    if (command[2] != '\\0') {\n      return '\\x03';\n    }\n    if (systemState == '\\x06') {\n      reportFeedbackMessage('\\x03');\n      systemState = '\\0';\n    }\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08003b98": "process_gcode_command_08003b98",
                "line": "command",
                "bVar1": "firstChar",
                "uVar2": "returnValue",
                "iVar3": "result",
                "uVar4": "conversionResult",
                "extraout_r1": "extraReturnValue",
                "uVar5": "counter",
                "value_00": "convertedValue",
                "uStack_20": "tempValue",
                "line_local": "localCommand",
                "value": "floatValue",
                "parameter": "floatParameter",
                "char_counter": "characterCounter",
                "helper_var": "helperVariable",
                "settings.flags": "flags",
                "sys.state": "systemState",
                "sys.abort": "abort",
                "settings_read_startup_line": "readStartupLine",
                "settings_store_global_setting": "storeGlobalSetting",
                "gc_execute_line": "executeLine",
                "settings_store_startup_line": "storeStartupLine",
                "report_grbl_help": "reportGrblHelp",
                "report_gcode_parameters": "reportGcodeParameters",
                "report_grbl_settings": "reportGrblSettings",
                "report_feedback_message": "reportFeedbackMessage",
                "report_gcode_modes": "reportGcodeModes",
                "protocol_execute_startup": "executeStartupProtocol",
                "report_status_message": "reportStatusMessage",
                "read_float": "readFloat",
                "__aeabi_f2iz": "convertFloatToInt",
                "__aeabi_f2d": "convertFloatToDouble",
                "__aeabi_d2uiz": "convertDoubleToUint",
                "trunc": "truncate"
            },
            "calling": [
                "protocol_process"
            ],
            "called": [
                "report_status_message",
                "trunc",
                "report_grbl_settings",
                "report_feedback_message",
                "settings_read_startup_line",
                "__aeabi_d2uiz",
                "settings_store_startup_line",
                "mc_reset",
                "gc_execute_line",
                "mc_go_home",
                "report_grbl_help",
                "__aeabi_f2d",
                "read_float",
                "protocol_execute_startup",
                "__aeabi_f2iz",
                "report_gcode_modes",
                "settings_store_global_setting",
                "report_startup_line",
                "report_gcode_parameters"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f34": {
            "entrypoint": "0x08003f34",
            "current_name": "process_serial_input_08003f34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_serial_input_08003f34(void)\n\n{\n  uint8_t process_status;\n  byte input_byte;\n  uint char_index;\n  uint8_t c;\n  \n  while( true ) {\n    while( true ) {\n      input_byte = serial_read();\n      if (input_byte == 0xff) {\n        return;\n      }\n      if ((input_byte == 10) || (input_byte == 0xd)) break;\n      if (in_comment == '\\0') {\n        if ((0x20 < input_byte) && (input_byte != 0x2f)) {\n          if (input_byte == 0x28) {\n            in_comment = '\\x01';\n          }\n          else if (char_index_counter == 0xff) {\n            display_status_message('\\r');\n            reset_line_buffer();\n          }\n          else if ((input_byte < 0x61) || (0x7a < input_byte)) {\n            char_index = (uint)char_index_counter;\n            char_index_counter = char_index_counter + '\\x01';\n            input_line[char_index] = input_byte;\n          }\n          else {\n            char_index = (uint)char_index_counter;\n            char_index_counter = char_index_counter + '\\x01';\n            input_line[char_index] = input_byte - 0x20;\n          }\n        }\n      }\n      else if (input_byte == 0x29) {\n        in_comment = '\\0';\n      }\n    }\n    execute_runtime_protocol();\n    if (abort_flag != '\\0') break;\n    if (char_index_counter == '\\0') {\n      display_status_message('\\0');\n    }\n    else {\n      input_line[char_index_counter] = '\\0';\n      process_status = execute_line_protocol(input_line);\n      display_status_message(process_status);\n    }\n    reset_line_buffer();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f34": "process_serial_input_08003f34",
                "status_code": "process_status",
                "bVar1": "input_byte",
                "uVar2": "char_index",
                "iscomment": "in_comment",
                "char_counter": "char_index_counter",
                "line": "input_line",
                "report_status_message": "display_status_message",
                "protocol_reset_line_buffer": "reset_line_buffer",
                "sys.abort": "abort_flag",
                "protocol_execute_runtime": "execute_runtime_protocol",
                "protocol_execute_line": "execute_line_protocol"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "serial_read",
                "report_status_message",
                "protocol_execute_line",
                "protocol_reset_line_buffer",
                "protocol_execute_runtime"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004030": {
            "entrypoint": "0x08004030",
            "current_name": "print_status_message_08004030",
            "code": "\nvoid printStatusMessage_08004030(uint8_t statusCode)\n\n{\n  uint8_t localStatusCode;\n  \n  if (statusCode == '\\0') {\n    printPgmString(\"ok\\r\\n\");\n  }\n  else {\n    printPgmString(\"error: \");\n    switch(statusCode) {\n    case '\\x01':\n      printPgmString(\"Bad number format\");\n      break;\n    case '\\x02':\n      printPgmString(\"Expected command letter\");\n      break;\n    case '\\x03':\n      printPgmString(\"Unsupported statement\");\n      break;\n    case '\\x04':\n      printPgmString(\"Invalid radius\");\n      break;\n    case '\\x05':\n      printPgmString(\"Modal group violation\");\n      break;\n    case '\\x06':\n      printPgmString(\"Invalid statement\");\n      break;\n    case '\\a':\n      printPgmString(\"Setting disabled\");\n      break;\n    case '\\b':\n      printPgmString(\"Value < 0.0\");\n      break;\n    case '\\t':\n      printPgmString(\"Value < 3 usec\");\n      break;\n    case '\\n':\n      printPgmString(\"EEPROM read fail. Using defaults\");\n      break;\n    case '\\v':\n      printPgmString(\"Busy or queued\");\n      break;\n    case '\\f':\n      printPgmString(\"Alarm lock\");\n      break;\n    case '\\r':\n      printPgmString(\"Line overflow\");\n    }\n    printPgmString(\"\\r\\n\");\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004030": "print_status_message_08004030",
                "status_code": "statusCode",
                "status_code_local": "localStatusCode"
            },
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup",
                "gc_init",
                "settings_init",
                "protocol_process",
                "report_gcode_parameters"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004148": {
            "entrypoint": "0x08004148",
            "current_name": "print_alarm_message_08004148",
            "code": "\nvoid printAlarmMessage_08004148(int8_t alarmCode)\n\n{\n  int8_t localAlarmCode;\n  \n  printPgmString(\"ALARM: \");\n  if (alarmCode == -2) {\n    printPgmString(\"Abort during cycle\");\n  }\n  else if (alarmCode == -1) {\n    printPgmString(\"Hard limit\");\n  }\n  printPgmString(\". MPos?\\r\\n\");\n  delay_ms(500);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004148": "print_alarm_message_08004148",
                "alarm_code": "alarmCode",
                "alarm_code_local": "localAlarmCode"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [
                "delay_ms",
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a0": {
            "entrypoint": "0x080041a0",
            "current_name": "print_message_080041a0",
            "code": "\nvoid printMessage_080041a0(uint8_t code)\n\n{\n  uint8_t local_code;\n  \n  printPgmString(\"[\");\n  switch(code) {\n  case '\\x01':\n    printPgmString(\"Reset to continue\");\n    break;\n  case '\\x02':\n    printPgmString(\"\\'$H\\'|\\'$X\\' to unlock\");\n    break;\n  case '\\x03':\n    printPgmString(\"Caution: Unlocked\");\n    break;\n  case '\\x04':\n    printPgmString(\"Enabled\");\n    break;\n  case '\\x05':\n    printPgmString(\"Disabled\");\n  }\n  printPgmString(\"]\\r\\n\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a0": "print_message_080041a0",
                "message_code": "code",
                "message_code_local": "local_code"
            },
            "calling": [
                "grbl_main",
                "protocol_execute_line",
                "protocol_execute_runtime"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004228": {
            "entrypoint": "0x08004228",
            "current_name": "print_startup_message_08004228",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printStartupMessage_08004228(void)\n\n{\n  printMessage(\"\\r\\nGrbl 0.8c [\\'$\\' for help]\\r\\n\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004228": "print_startup_message_08004228",
                "printPgmString": "printMessage"
            },
            "calling": [
                "protocol_init"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800423c": {
            "entrypoint": "0x0800423c",
            "current_name": "print_and_save_grbl_settings_0800423c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printAndSaveGrblSettings_0800423c(void)\n\n{\n  printProgramString(\n                \"$$ (view Grbl settings)\\r\\n$# (view # parameters)\\r\\n$G (view parser state)\\r\\n$N (view startup blocks)\\r\\n$x=value (save Grbl setting)\\r\\n$Nx=line (save startup block)\\r\\n$C (check gcode mode)\\r\\n$X (kill alarm lock)\\r\\n$H (run homing cycle)\\r\\n~ (cycle start)\\r\\n! (feed hold)\\r\\n? (current status)\\r\\nctrl-x (reset Grbl)\\r\\n\"\n                );\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800423c": "print_and_save_grbl_settings_0800423c",
                "printPgmString": "printProgramString"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004250": {
            "entrypoint": "0x08004250",
            "current_name": "print_settings_08004250",
            "code": "\n/* WARNING: UxStepPerMmkxStepPerMmowxStepPerMm callixStepPerMmg coxStepPerMmvexStepPerMmtioxStepPerMm */\n\nvoid printSettings_08004250(void)\n\n{\n  float xStepPerMm;\n  float yStepPerMm;\n  float zStepPerMm;\n  float defaultFeedRate;\n  float defaultSeekRate;\n  float acceleration;\n  float junctionDeviation;\n  float arcPerSegment;\n  float homingFeedRate;\n  float homingSeekRate;\n  float homingPullOff;\n  \n  prixStepPerMmtPgmStrixStepPerMmg(\"$0=\");\n  prixStepPerMmtFloat(xStepPerMm);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (x, step/mm)\\r\\xStepPerMm$1=\");\n  prixStepPerMmtFloat(yStepPerMm);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (y, step/mm)\\r\\xStepPerMm$2=\");\n  prixStepPerMmtFloat(zStepPerMm);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (z, step/mm)\\r\\xStepPerMm$3=\");\n  prixStepPerMmtIxStepPerMmteger(stepPulse);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (step pulse, usec)\\r\\xStepPerMm$4=\");\n  prixStepPerMmtFloat(defaultFeedRate);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (default feed, mm/mixStepPerMm)\\r\\xStepPerMm$5=\");\n  prixStepPerMmtFloat(defaultSeekRate);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (default seek, mm/mixStepPerMm)\\r\\xStepPerMm$6=\");\n  prixStepPerMmtIxStepPerMmteger(stepPortInvertMask);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (step port ixStepPerMmvert mask, ixStepPerMmt:\");\n  prixStepPerMmt_uixStepPerMmt16_base2(stepPortInvertMask);\n  prixStepPerMmtPgmStrixStepPerMmg(\")\\r\\xStepPerMm$7=\");\n  prixStepPerMmtIxStepPerMmteger(stepIdleDelay);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (step idle delay, msec)\\r\\xStepPerMm$8=\");\n  acceleration = (float)__aeabi_fdiv(settixStepPerMmgs.acceleratioxStepPerMm,0x45610000);\n  prixStepPerMmtFloat(acceleration);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (acceleratioxStepPerMm, mm/sec^2)\\r\\xStepPerMm$9=\");\n  prixStepPerMmtFloat(junctionDeviation);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (juxStepPerMmctioxStepPerMm deviatioxStepPerMm, mm)\\r\\xStepPerMm$10=\");\n  prixStepPerMmtFloat(arcPerSegment);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (arc, mm/segmexStepPerMmt)\\r\\xStepPerMm$11=\");\n  prixStepPerMmtIxStepPerMmteger(nArcCorrection);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (xStepPerMm-arc correctioxStepPerMm, ixStepPerMmt)\\r\\xStepPerMm$12=\");\n  prixStepPerMmtIxStepPerMmteger(nDecimals);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (xStepPerMm-decimals, ixStepPerMmt)\\r\\xStepPerMm$13=\");\n  prixStepPerMmtIxStepPerMmteger((uixStepPerMmt)((flags & 1) != 0));\n  prixStepPerMmtPgmStrixStepPerMmg(\" (report ixStepPerMmches, bool)\\r\\xStepPerMm$14=\");\n  prixStepPerMmtIxStepPerMmteger((uixStepPerMmt)((flags & 2) != 0));\n  prixStepPerMmtPgmStrixStepPerMmg(\" (auto start, bool)\\r\\xStepPerMm$15=\");\n  prixStepPerMmtIxStepPerMmteger((uixStepPerMmt)((flags & 4) != 0));\n  prixStepPerMmtPgmStrixStepPerMmg(\" (ixStepPerMmvert step exStepPerMmable, bool)\\r\\xStepPerMm$16=\");\n  prixStepPerMmtIxStepPerMmteger((uixStepPerMmt)((flags & 8) != 0));\n  prixStepPerMmtPgmStrixStepPerMmg(\" (hard limits, bool)\\r\\xStepPerMm$17=\");\n  prixStepPerMmtIxStepPerMmteger((uixStepPerMmt)((flags & 0x10) != 0));\n  prixStepPerMmtPgmStrixStepPerMmg(\" (homixStepPerMmg cycle, bool)\\r\\xStepPerMm$18=\");\n  prixStepPerMmtIxStepPerMmteger(homingDirInvertMask);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (homixStepPerMmg dir ixStepPerMmvert mask, ixStepPerMmt:\");\n  prixStepPerMmt_uixStepPerMmt16_base2(homingDirInvertMask);\n  prixStepPerMmtPgmStrixStepPerMmg(\")\\r\\xStepPerMm$19=\");\n  prixStepPerMmtFloat(homingFeedRate);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (homixStepPerMmg feed, mm/mixStepPerMm)\\r\\xStepPerMm$20=\");\n  prixStepPerMmtFloat(homingSeekRate);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (homixStepPerMmg seek, mm/mixStepPerMm)\\r\\xStepPerMm$21=\");\n  prixStepPerMmtIxStepPerMmteger(homingDebounceDelay);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (homixStepPerMmg debouxStepPerMmce, msec)\\r\\xStepPerMm$22=\");\n  prixStepPerMmtFloat(homingPullOff);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (homixStepPerMmg pull-off, mm)\\r\\xStepPerMm$23=\");\n  prixStepPerMmtIxStepPerMmteger(dirPortInvertMask);\n  prixStepPerMmtPgmStrixStepPerMmg(\" (dir port ixStepPerMmvert mask, ixStepPerMmt:\");\n  prixStepPerMmt_uixStepPerMmt16_base2(dirPortInvertMask);\n  prixStepPerMmtPgmStrixStepPerMmg(\")\\r\\xStepPerMm\");\n  returxStepPerMm;\n}\n\n",
            "renaming": {
                "FUN_08004250": "print_settings_08004250",
                "n": "xStepPerMm",
                "n_00": "yStepPerMm",
                "n_01": "zStepPerMm",
                "n_02": "defaultFeedRate",
                "n_03": "defaultSeekRate",
                "n_04": "acceleration",
                "n_05": "junctionDeviation",
                "n_06": "arcPerSegment",
                "n_07": "homingFeedRate",
                "n_08": "homingSeekRate",
                "n_09": "homingPullOff",
                "settings.pulse_microseconds": "stepPulse",
                "settings.step_invert_mask": "stepPortInvertMask",
                "settings.stepper_idle_lock_time": "stepIdleDelay",
                "settings.n_arc_correction": "nArcCorrection",
                "settings.decimal_places": "nDecimals",
                "settings.flags": "flags",
                "settings.homing_dir_mask": "homingDirInvertMask",
                "settings.homing_debounce_delay": "homingDebounceDelay",
                "settings.dirn_invert_mask": "dirPortInvertMask",
                "(uint)settings.pulse_microseconds": "stepPulse",
                "(uint)settings.step_invert_mask": "stepPortInvertMask",
                "(uint)settings.stepper_idle_lock_time": "stepIdleDelay",
                "(uint)settings.n_arc_correction": "nArcCorrection",
                "(uint)settings.decimal_places": "nDecimals",
                "(uint)settings.homing_dir_mask": "homingDirInvertMask",
                "(uint)settings.homing_debounce_delay": "homingDebounceDelay",
                "(uint)settings.dirn_invert_mask": "dirPortInvertMask"
            },
            "calling": [
                "protocol_execute_line",
                "settings_init"
            ],
            "called": [
                "printFloat",
                "__aeabi_fdiv",
                "printPgmString",
                "print_uint16_base2",
                "printInteger"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044e8": {
            "entrypoint": "0x080044e8",
            "current_name": "print_coordinate_data_080044e8",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd printCoordinateData_080044e8(voindexd)\n\n{\n  uindexnt8_t errorCode;\n  float tempFloat0;\n  float tempFloat1;\n  float tempFloat2;\n  float tempFloat3;\n  float tempFloat4;\n  float tempFloat5;\n  float tempFloat6;\n  float tempFloat7;\n  float tempFloat8;\n  float tempFloat9;\n  float tempFloat10;\n  float tempFloat11;\n  float currentFloat;\n  float tempFloat12;\n  float tempFloat13;\n  undefindexned8 doubleValue;\n  float coordinateData [3];\n  uindexnt8_t index;\n  uindexnt8_t coordinateSelect;\n  \n  coordinateSelect = '\\0';\n  whindexle( true ) {\n    indexf (7 < coordinateSelect) {\n      prindexntPgmStrindexng(\"[G92:\");\n      currentFloat = tempFloat11;\n      for (index = '\\0'; index < 3; index = index + '\\x01') {\n        indexf ((settindexngs.flags & 1) == 0) {\n          prindexntFloat(currentFloat);\n        }\n        else {\n          doubleValue = __aeabindex_f2d(gc.coord_offset[index]);\n          doubleValue = __muldf3((indexnt)doubleValue,(indexnt)((ulonglong)doubleValue >> 0x20),0x57e16865,0x3fa42851);\n          currentFloat = (float)__truncdfsf2((indexnt)doubleValue,(indexnt)((ulonglong)doubleValue >> 0x20));\n          prindexntFloat(currentFloat);\n        }\n        indexf (index < 2) {\n          prindexntPgmStrindexng(\",\");\n          currentFloat = tempFloat12;\n        }\n        else {\n          prindexntPgmStrindexng(\"]\\r\\n\");\n          currentFloat = tempFloat13;\n        }\n      }\n      return;\n    }\n    errorCode = settindexngs_read_coordinateData(coordinateSelect,coordinateData);\n    indexf (errorCode == '\\0') break;\n    prindexntPgmStrindexng(\"[G\");\n    currentFloat = tempFloat0;\n    swindextch(coordinateSelect) {\n    case '\\0':\n      prindexntPgmStrindexng(\"54:\");\n      currentFloat = tempFloat1;\n      break;\n    case '\\x01':\n      prindexntPgmStrindexng(\"55:\");\n      currentFloat = tempFloat2;\n      break;\n    case '\\x02':\n      prindexntPgmStrindexng(\"56:\");\n      currentFloat = tempFloat3;\n      break;\n    case '\\x03':\n      prindexntPgmStrindexng(\"57:\");\n      currentFloat = tempFloat4;\n      break;\n    case '\\x04':\n      prindexntPgmStrindexng(\"58:\");\n      currentFloat = tempFloat5;\n      break;\n    case '\\x05':\n      prindexntPgmStrindexng(\"59:\");\n      currentFloat = tempFloat6;\n      break;\n    case '\\x06':\n      prindexntPgmStrindexng(\"28:\");\n      currentFloat = tempFloat7;\n      break;\n    case '\\a':\n      prindexntPgmStrindexng(\"30:\");\n      currentFloat = tempFloat8;\n    }\n    for (index = '\\0'; index < 3; index = index + '\\x01') {\n      indexf ((settindexngs.flags & 1) == 0) {\n        prindexntFloat(currentFloat);\n      }\n      else {\n        doubleValue = __aeabindex_f2d(coordinateData[index]);\n        doubleValue = __muldf3((indexnt)doubleValue,(indexnt)((ulonglong)doubleValue >> 0x20),0x57e16865,0x3fa42851);\n        currentFloat = (float)__truncdfsf2((indexnt)doubleValue,(indexnt)((ulonglong)doubleValue >> 0x20));\n        prindexntFloat(currentFloat);\n      }\n      indexf (index < 2) {\n        prindexntPgmStrindexng(\",\");\n        currentFloat = tempFloat9;\n      }\n      else {\n        prindexntPgmStrindexng(\"]\\r\\n\");\n        currentFloat = tempFloat10;\n      }\n    }\n    coordinateSelect = coordinateSelect + '\\x01';\n  }\n  report_status_message('\\n');\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044e8": "print_coordinate_data_080044e8",
                "uVar1": "errorCode",
                "uVar3": "doubleValue",
                "coord_data": "coordinateData",
                "i": "index",
                "coord_select": "coordinateSelect",
                "extraout_s0": "tempFloat0",
                "extraout_s0_00": "tempFloat1",
                "extraout_s0_01": "tempFloat2",
                "extraout_s0_02": "tempFloat3",
                "extraout_s0_03": "tempFloat4",
                "extraout_s0_04": "tempFloat5",
                "extraout_s0_05": "tempFloat6",
                "extraout_s0_06": "tempFloat7",
                "extraout_s0_07": "tempFloat8",
                "extraout_s0_08": "tempFloat9",
                "extraout_s0_09": "tempFloat10",
                "extraout_s0_10": "tempFloat11",
                "fVar2": "currentFloat",
                "extraout_s0_11": "tempFloat12",
                "extraout_s0_12": "tempFloat13"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "report_status_message",
                "__aeabi_f2d",
                "__muldf3",
                "printFloat",
                "__truncdfsf2",
                "settings_read_coord_data",
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046d0": {
            "entrypoint": "0x080046d0",
            "current_name": "print_g_code_settings_080046d0",
            "code": "\n/* WARNING: UfeedRateInIncheskfeedRateInInchesowfeedRateInInches callifeedRateInInchesg cofeedRateInInchesvefeedRateInInchestiofeedRateInInches */\n\nvoid printGCodeSettings_080046d0(void)\n\n{\n  float feedRateInInches;\n  float feedRateInMillimeters;\n  ufeedRateInInchesdefifeedRateInInchesed8 tempVariable;\n  \n  switch(motionMode) {\n  case '\\0':\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\"[G0\");\n    break;\n  case '\\x01':\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\"[G1\");\n    break;\n  case '\\x02':\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\"[G2\");\n    break;\n  case '\\x03':\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\"[G3\");\n    break;\n  case '\\x04':\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\"[G80\");\n  }\n  prifeedRateInInchestPgmStrifeedRateInInchesg(\" G\");\n  prifeedRateInInchestIfeedRateInInchesteger(coordSelect + 0x36);\n  if (planeAxis0 == '\\0') {\n    if (planeAxis1 == '\\x01') {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" G17\");\n    }\n    else {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" G18\");\n    }\n  }\n  else {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G19\");\n  }\n  if (inchesMode == '\\0') {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G21\");\n  }\n  else {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G20\");\n  }\n  if (absoluteMode == '\\0') {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G91\");\n  }\n  else {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G90\");\n  }\n  if (inverseFeedRateMode == '\\0') {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G94\");\n  }\n  else {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" G93\");\n  }\n  if (programFlow == '\\x02') {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" M2\");\n  }\n  else if (programFlow < 3) {\n    if (programFlow == '\\0') {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" M0\");\n    }\n    else if (programFlow == '\\x01') {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" M1\");\n    }\n  }\n  if (spindleDirection == '\\x01') {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" M3\");\n  }\n  else if (spindleDirection < '\\x02') {\n    if (spindleDirection == -1) {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" M4\");\n    }\n    else if (spindleDirection == '\\0') {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" M5\");\n    }\n  }\n  if (coolantMode == '\\x02') {\n    prifeedRateInInchestPgmStrifeedRateInInchesg(\" M7\");\n  }\n  else if (coolantMode < 3) {\n    if (coolantMode == '\\0') {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" M9\");\n    }\n    else if (coolantMode == '\\x01') {\n      prifeedRateInInchestPgmStrifeedRateInInchesg(\" M8\");\n    }\n  }\n  prifeedRateInInchestPgmStrifeedRateInInchesg(\" T\");\n  prifeedRateInInchestIfeedRateInInchesteger((uifeedRateInInchest)tool);\n  prifeedRateInInchestPgmStrifeedRateInInchesg(\" F\");\n  if (inchesMode == '\\0') {\n    prifeedRateInInchestFloat(feedRateInInches);\n  }\n  else {\n    tempVariable = __aeabi_f2d(feedRate);\n    tempVariable = __muldf3((ifeedRateInInchest)tempVariable,(ifeedRateInInchest)((ulofeedRateInInchesglofeedRateInInchesg)tempVariable >> 0x20),0x57e16865,0x3fa42851);\n    feedRateInMillimeters = (float)__trufeedRateInInchescdfsf2((ifeedRateInInchest)tempVariable,(ifeedRateInInchest)((ulofeedRateInInchesglofeedRateInInchesg)tempVariable >> 0x20));\n    prifeedRateInInchestFloat(feedRateInMillimeters);\n  }\n  prifeedRateInInchestPgmStrifeedRateInInchesg(\"]\\r\\feedRateInInches\");\n  returfeedRateInInches;\n}\n\n",
            "renaming": {
                "FUN_080046d0": "print_g_code_settings_080046d0",
                "gc.motion_mode": "motionMode",
                "gc.coord_select": "coordSelect",
                "gc.plane_axis_0": "planeAxis0",
                "gc.plane_axis_1": "planeAxis1",
                "gc.inches_mode": "inchesMode",
                "gc.absolute_mode": "absoluteMode",
                "gc.inverse_feed_rate_mode": "inverseFeedRateMode",
                "gc.program_flow": "programFlow",
                "gc.spindle_direction": "spindleDirection",
                "gc.coolant_mode": "coolantMode",
                "gc.tool": "tool",
                "gc.feed_rate": "feedRate",
                "n": "feedRateInInches",
                "n_00": "feedRateInMillimeters",
                "uVar1": "tempVariable"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "__aeabi_f2d",
                "__muldf3",
                "printFloat",
                "__truncdfsf2",
                "printPgmString",
                "printInteger"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004900": {
            "entrypoint": "0x08004900",
            "current_name": "print_integer_with_line_08004900",
            "code": "\nvoid printIntegerWithLine_08004900(uiinputNumbert8_t inputNumber,char *inputString)\n\n{\n  char *localString;\n  uiinputNumbert8_t localNumber;\n  \n  priinputNumbertPgmStriinputNumberg(\"$N\");\n  priinputNumbertIinputNumberteger((uiinputNumbert)inputNumber);\n  priinputNumbertPgmStriinputNumberg(\"=\");\n  priinputNumbertStriinputNumberg(inputString);\n  priinputNumbertPgmStriinputNumberg(\"\\r\\inputNumber\");\n  returinputNumber;\n}\n\n",
            "renaming": {
                "FUN_08004900": "print_integer_with_line_08004900",
                "n": "inputNumber",
                "line": "inputString",
                "line_local": "localString",
                "n_local": "localNumber"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "printString",
                "printPgmString",
                "printInteger"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004940": {
            "entrypoint": "0x08004940",
            "current_name": "print_position_and_state_08004940",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd printPositionAndState_08004940(voindexd)\n\n{\n  undefindexned4 convertedPosition;\n  float convertedFloat;\n  float extraOutput0;\n  float extraOutput00;\n  float extraOutput01;\n  float extraOutput02;\n  undefindexned8 doubleVar1;\n  undefindexned8 doubleVar2;\n  float printedPosition [3];\n  indexnt32_t currentPosition [3];\n  uindexnt8_t index;\n  \n  currentPosition[0] = sys.posindextindexon[0];\n  currentPosition[1] = sys.posindextindexon[1];\n  currentPosition[2] = sys.posindextindexon[2];\n  swindextch(sys.state) {\n  case '\\0':\n    prindexntPgmStrindexng(\"<Idle\");\n    break;\n  case '\\x02':\n    prindexntPgmStrindexng(\"<Queue\");\n    break;\n  case '\\x03':\n    prindexntPgmStrindexng(\"<Run\");\n    break;\n  case '\\x04':\n    prindexntPgmStrindexng(\"<Hold\");\n    break;\n  case '\\x05':\n    prindexntPgmStrindexng(\"<Home\");\n    break;\n  case '\\x06':\n    prindexntPgmStrindexng(\"<Alarm\");\n    break;\n  case '\\a':\n    prindexntPgmStrindexng(\"<Check\");\n  }\n  prindexntPgmStrindexng(\",MPos:\");\n  for (index = '\\0'; index < 3; index = index + '\\x01') {\n    convertedPosition = __floatsindexsf(currentPosition[index]);\n    convertedFloat = (float)__aeabindex_fdindexv(convertedPosition,settindexngs.steps_per_mm[index]);\n    printedPosition[index] = convertedFloat;\n    convertedFloat = extraOutput0;\n    indexf ((settindexngs.flags & 1) != 0) {\n      doubleVar1 = __aeabindex_f2d(printedPosition[index]);\n      doubleVar1 = __muldf3((indexnt)doubleVar1,(indexnt)((ulonglong)doubleVar1 >> 0x20),0x57e16865,0x3fa42851);\n      convertedFloat = (float)__truncdfsf2((indexnt)doubleVar1,(indexnt)((ulonglong)doubleVar1 >> 0x20));\n      printedPosition[index] = convertedFloat;\n      convertedFloat = extraOutput00;\n    }\n    prindexntFloat(convertedFloat);\n    prindexntPgmStrindexng(\",\");\n  }\n  prindexntPgmStrindexng(\"WPos:\");\n  for (index = '\\0'; index < 3; index = index + '\\x01') {\n    indexf ((settindexngs.flags & 1) == 0) {\n      convertedFloat = printedPosition[index];\n      convertedPosition = __addsf3(gc.coord_system[index],gc.coord_offset[index]);\n      convertedFloat = (float)__aeabindex_fsub(convertedFloat,convertedPosition);\n      printedPosition[index] = convertedFloat;\n      convertedFloat = extraOutput02;\n    }\n    else {\n      doubleVar1 = __aeabindex_f2d(printedPosition[index]);\n      convertedPosition = __addsf3(gc.coord_system[index],gc.coord_offset[index]);\n      doubleVar2 = __aeabindex_f2d(convertedPosition);\n      doubleVar2 = __muldf3((indexnt)doubleVar2,(indexnt)((ulonglong)doubleVar2 >> 0x20),0x57e16865,0x3fa42851);\n      doubleVar1 = __subdf3((indexnt)doubleVar1,(indexnt)((ulonglong)doubleVar1 >> 0x20),(indexnt)doubleVar2,\n                       (indexnt)((ulonglong)doubleVar2 >> 0x20));\n      convertedFloat = (float)__truncdfsf2((indexnt)doubleVar1,(indexnt)((ulonglong)doubleVar1 >> 0x20));\n      printedPosition[index] = convertedFloat;\n      convertedFloat = extraOutput01;\n    }\n    prindexntFloat(convertedFloat);\n    indexf (index < 2) {\n      prindexntPgmStrindexng(\",\");\n    }\n  }\n  prindexntPgmStrindexng(\">\\r\\n\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004940": "print_position_and_state_08004940",
                "uVar1": "convertedPosition",
                "fVar2": "convertedFloat",
                "extraout_s0": "extraOutput0",
                "extraout_s0_00": "extraOutput00",
                "extraout_s0_01": "extraOutput01",
                "extraout_s0_02": "extraOutput02",
                "uVar3": "doubleVar1",
                "uVar4": "doubleVar2",
                "print_position": "printedPosition",
                "current_position": "currentPosition",
                "i": "index"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_f2d",
                "__muldf3",
                "printFloat",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fdiv",
                "printPgmString",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bc0": {
            "entrypoint": "0x08004bc0",
            "current_name": "write_line_to_eeprom_08004bc0",
            "code": "\nvoid write_line_to_eeprom_08004bc0(uiline_numbert8_t line_number,char *input_line)\n\n{\n  char *local_line;\n  uiline_numbert8_t local_line_number;\n  uiline_numbert16_t eeprom_address;\n  \n  memcpy_to_eeprom_with_checksum((uiline_numbert)(ushort)((ushort)line_number * 0x101 + 0x300),input_line,0x100);\n  returline_number;\n}\n\n",
            "renaming": {
                "FUN_08004bc0": "write_line_to_eeprom_08004bc0",
                "n": "line_number",
                "line": "input_line",
                "line_local": "local_line",
                "n_local": "local_line_number",
                "addr": "eeprom_address"
            },
            "calling": [
                "protocol_execute_line",
                "settings_read_startup_line"
            ],
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bf4": {
            "entrypoint": "0x08004bf4",
            "current_name": "write_coord_data_to_eeprom_08004bf4",
            "code": "\nvoid writeCoordDataToEEPROM_08004bf4(uint8_t dataSelector,float *dataToWrite)\n\n{\n  float *localDataPointer;\n  uint8_t localDataSelector;\n  uint16_t address;\n  \n  memcpy_to_eeprom_with_checksum\n            ((uint)(ushort)((ushort)dataSelector * 0xd + 0x200),(char *)dataToWrite,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bf4": "write_coord_data_to_eeprom_08004bf4",
                "coord_select": "dataSelector",
                "coord_data": "dataToWrite",
                "coord_data_local": "localDataPointer",
                "coord_select_local": "localDataSelector",
                "addr": "address"
            },
            "calling": [
                "gc_execute_line",
                "settings_read_coord_data"
            ],
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c2a": {
            "entrypoint": "0x08004c2a",
            "current_name": "initialize_eeprom_settings_08004c2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEEPROMSettings_08004c2a(void)\n\n{\n  writeCharToEEPROM(0,'\\x05');\n  writeSettingsToEEPROMWithChecksum(1,(char *)&settings,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c2a": "initialize_eeprom_settings_08004c2a",
                "eeprom_put_char": "writeCharToEEPROM",
                "memcpy_to_eeprom_with_checksum": "writeSettingsToEEPROMWithChecksum"
            },
            "calling": [
                "settings_reset",
                "settings_store_global_setting"
            ],
            "called": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "initialize_settings_08004c48",
            "code": "\nvoid initializeSettings_08004c48(_Bool resetAll)\n\n{\n  _Bool resetAllLocal;\n  \n  if (resetAll) {\n    settings.stepsPerMmX = 157.4803;\n    settings.stepsPerMmY = 157.4803;\n    settings.stepsPerMmZ = 157.4803;\n    settings.pulseMicroseconds = '\\n';\n    settings.defaultFeedRate = 250.0;\n    settings.defaultSeekRate = 500.0;\n    settings.acceleration = 36000.0;\n    settings.mmPerArcSegment = 0.1;\n    settings.stepInvertMask = 0;\n    settings.dirInvertMask = 0xa80;\n    settings.junctionDeviation = 0.05;\n  }\n  settings.flags = '\\x12';\n  settings.homingDirMask = 0;\n  settings.homingFeedRate = 25.0;\n  settings.homingSeekRate = 250.0;\n  settings.homingDebounceDelay = 100;\n  settings.homingPulloff = 1.0;\n  settings.stepperIdleLockTime = '\\x19';\n  settings.decimalPlaces = '\\x03';\n  settings.nArcCorrection = '\\x19';\n  saveSettings();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "initialize_settings_08004c48",
                "reset_all": "resetAll",
                "reset_all_local": "resetAllLocal",
                "settings.steps_per_mm[0]": "settings.stepsPerMmX",
                "settings.steps_per_mm[1]": "settings.stepsPerMmY",
                "settings.steps_per_mm[2]": "settings.stepsPerMmZ",
                "settings.pulse_microseconds": "settings.pulseMicroseconds",
                "settings.default_feed_rate": "settings.defaultFeedRate",
                "settings.default_seek_rate": "settings.defaultSeekRate",
                "settings.mm_per_arc_segment": "settings.mmPerArcSegment",
                "settings.step_invert_mask": "settings.stepInvertMask",
                "settings.dirn_invert_mask": "settings.dirInvertMask",
                "settings.junction_deviation": "settings.junctionDeviation",
                "settings.homing_dir_mask": "settings.homingDirMask",
                "settings.homing_feed_rate": "settings.homingFeedRate",
                "settings.homing_seek_rate": "settings.homingSeekRate",
                "settings.homing_debounce_delay": "settings.homingDebounceDelay",
                "settings.homing_pulloff": "settings.homingPulloff",
                "settings.stepper_idle_lock_time": "settings.stepperIdleLockTime",
                "settings.decimal_places": "settings.decimalPlaces",
                "settings.n_arc_correction": "settings.nArcCorrection",
                "write_global_settings": "saveSettings"
            },
            "calling": [
                "read_global_settings",
                "settings_init"
            ],
            "called": [
                "write_global_settings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d2c": {
            "entrypoint": "0x08004d2c",
            "current_name": "load_line_from_eeprom_08004d2c",
            "code": "\nuiline_numbert8_t load_line_from_eeprom_08004d2c(uiline_numbert8_t line_number,char *output_line)\n\n{\n  iline_numbert iVar1;\n  char *local_line;\n  uiline_numbert8_t local_line_number;\n  uiline_numbert16_t address;\n  \n  iVar1 = memcpy_from_eeprom_with_checksum(output_line,(uiline_numbert)(ushort)((ushort)line_number * 0x101 + 0x300),0x100);\n  if (iVar1 == 0) {\n    *output_line = '\\0';\n    settiline_numbergs_store_startup_output_line(line_number,output_line);\n  }\n  returline_number iVar1 != 0;\n}\n\n",
            "renaming": {
                "FUN_08004d2c": "load_line_from_eeprom_08004d2c",
                "n": "line_number",
                "line": "output_line",
                "line_local": "local_line",
                "n_local": "local_line_number",
                "addr": "address"
            },
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "called": [
                "settings_store_startup_line",
                "memcpy_from_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d7c": {
            "entrypoint": "0x08004d7c",
            "current_name": "update_coord_data_08004d7c",
            "code": "\nuint8_t update_coord_data_08004d7c(uint8_t selection,float *data)\n\n{\n  int iVar1;\n  float *local_data;\n  uint8_t local_selection;\n  uint16_t address;\n  \n  iVar1 = copy_from_eeprom_with_checksum\n                    ((char *)data,(uint)(ushort)((ushort)selection * 0xd + 0x200),0xc);\n  if (iVar1 == 0) {\n    set_to_zero(data,0,0xc);\n    write_coord_data(selection,data);\n  }\n  return iVar1 != 0;\n}\n\n",
            "renaming": {
                "FUN_08004d7c": "update_coord_data_08004d7c",
                "coord_select": "selection",
                "coord_data": "data",
                "coord_data_local": "local_data",
                "coord_select_local": "local_selection",
                "addr": "address",
                "memcpy_from_eeprom_with_checksum": "copy_from_eeprom_with_checksum",
                "memset": "set_to_zero",
                "settings_write_coord_data": "write_coord_data"
            },
            "calling": [
                "gc_execute_line",
                "gc_init",
                "settings_init",
                "report_gcode_parameters"
            ],
            "called": [
                "settings_write_coord_data",
                "memcpy_from_eeprom_with_checksum",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004dd2": {
            "entrypoint": "0x08004dd2",
            "current_name": "check_and_load_settings_08004dd2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t checkAndLoadSettings_08004dd2(void)\n\n{\n  byte eepromValue;\n  int memcpyResult;\n  uint8_t firmwareVersion;\n  \n  eepromValue = eeprom_get_char(0);\n  if (eepromValue == 5) {\n    memcpyResult = memcpy_from_eeprom_with_checksum((char *)&settings,1,0x40);\n    if (memcpyResult == 0) {\n      return '\\0';\n    }\n  }\n  else {\n    if (4 < eepromValue) {\n      return '\\0';\n    }\n    memcpyResult = memcpy_from_eeprom_with_checksum((char *)&settings,1,0x28);\n    if (memcpyResult == 0) {\n      return '\\0';\n    }\n    settings_reset(false);\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "FUN_08004dd2": "check_and_load_settings_08004dd2",
                "bVar1": "eepromValue",
                "iVar2": "memcpyResult",
                "version": "firmwareVersion"
            },
            "calling": [
                "settings_init"
            ],
            "called": [
                "settings_reset",
                "eeprom_get_char",
                "memcpy_from_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e30": {
            "entrypoint": "0x08004e30",
            "current_name": "update_settings_08004e30",
            "code": "\n/* WARNING: Variable defined which should be unmapped: settingValue-local */\n\nuint8_t updateSettings_08004e30(int settingId,float settingValue)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  float threshold;\n  undefined4 output1;\n  undefined4 output2;\n  undefined4 output3;\n  undefined4 output4;\n  undefined4 output5;\n  undefined4 output6;\n  undefined4 output7;\n  undefined4 output8;\n  float localValue;\n  int localParameter;\n  \n  switch(settingId) {\n  case 0:\n  case 1:\n  case 2:\n    iVar1 = __aeabi_fcmple(settingValue,threshold,0);\n    if (iVar1 != 0) {\n      return '\\b';\n    }\n    settings.steps_per_mm[settingId] = threshold;\n    break;\n  case 3:\n    iVar1 = __aeabi_fcmplt(threshold,0x40400000);\n    if (iVar1 != 0) {\n      return '\\t';\n    }\n    uVar2 = __aeabi_f2d(threshold);\n    round((double)CONCAT44(settingId,threshold));\n    settings.pulse_microseconds = __aeabi_d2uiz(uVar2,output1);\n    break;\n  case 4:\n    settings.default_feed_rate = threshold;\n    break;\n  case 5:\n    settings.default_seek_rate = threshold;\n    break;\n  case 6:\n    uVar2 = __aeabi_f2d(threshold);\n    trunc((double)CONCAT44(settingId,threshold));\n    settings.step_invert_mask = __aeabi_d2uiz(uVar2,output2);\n    break;\n  case 7:\n    uVar2 = __aeabi_f2d(threshold);\n    round((double)CONCAT44(settingId,threshold));\n    settings.stepper_idle_lock_time = __aeabi_d2uiz(uVar2,output3);\n    break;\n  case 8:\n    uVar2 = __aeabi_fmul(threshold,0x42700000);\n    settings.acceleration = (float)__aeabi_fmul(uVar2,0x42700000);\n    break;\n  case 9:\n    settings.junction_deviation = (float)((uint)threshold & 0x7fffffff);\n    break;\n  case 10:\n    settings.mm_per_arc_segment = threshold;\n    break;\n  case 0xb:\n    uVar2 = __aeabi_f2d(threshold);\n    round((double)CONCAT44(settingId,threshold));\n    settings.n_arc_correction = __aeabi_d2uiz(uVar2,output4);\n    break;\n  case 0xc:\n    uVar2 = __aeabi_f2d(threshold);\n    round((double)CONCAT44(settingId,threshold));\n    settings.decimal_places = __aeabi_d2uiz(uVar2,output5);\n    break;\n  case 0xd:\n    iVar1 = __aeabi_fcmpeq(threshold,0);\n    if (iVar1 == 0) {\n      settings.flags = settings.flags | 1;\n    }\n    else {\n      settings.flags = settings.flags & 0xfe;\n    }\n    break;\n  case 0xe:\n    iVar1 = __aeabi_fcmpeq(threshold,0);\n    if (iVar1 == 0) {\n      settings.flags = settings.flags | 2;\n    }\n    else {\n      settings.flags = settings.flags & 0xfd;\n    }\n    break;\n  case 0xf:\n    iVar1 = __aeabi_fcmpeq(threshold,0);\n    if (iVar1 == 0) {\n      settings.flags = settings.flags | 4;\n    }\n    else {\n      settings.flags = settings.flags & 0xfb;\n    }\n    break;\n  case 0x10:\n    iVar1 = __aeabi_fcmpeq(threshold,0);\n    if (iVar1 == 0) {\n      settings.flags = settings.flags | 8;\n    }\n    else {\n      settings.flags = settings.flags & 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    iVar1 = __aeabi_fcmpeq(threshold,0);\n    if (iVar1 == 0) {\n      settings.flags = settings.flags | 0x10;\n    }\n    else {\n      settings.flags = settings.flags & 0xef;\n    }\n    break;\n  case 0x12:\n    uVar2 = __aeabi_f2d(threshold);\n    trunc((double)CONCAT44(settingId,threshold));\n    settings.homing_dir_mask = __aeabi_d2uiz(uVar2,output6);\n    break;\n  case 0x13:\n    settings.homing_feed_rate = threshold;\n    break;\n  case 0x14:\n    settings.homing_seek_rate = threshold;\n    break;\n  case 0x15:\n    uVar2 = __aeabi_f2d(threshold);\n    round((double)CONCAT44(settingId,threshold));\n    settings.homing_debounce_delay = __aeabi_d2uiz(uVar2,output7);\n    break;\n  case 0x16:\n    settings.homing_pulloff = threshold;\n    break;\n  case 0x17:\n    uVar2 = __aeabi_f2d(threshold);\n    trunc((double)CONCAT44(settingId,threshold));\n    settings.dirn_invert_mask = __aeabi_d2uiz(uVar2,output8);\n    break;\n  default:\n    return '\\x06';\n  }\n  write_global_settings();\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08004e30": "update_settings_08004e30",
                "parameter": "settingId",
                "value": "settingValue",
                "in_r1": "threshold",
                "extraout_r1": "output1",
                "extraout_r1_00": "output2",
                "extraout_r1_01": "output3",
                "extraout_r1_02": "output4",
                "extraout_r1_03": "output5",
                "extraout_r1_04": "output6",
                "extraout_r1_05": "output7",
                "extraout_r1_06": "output8",
                "value_local": "localValue",
                "parameter_local": "localParameter"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "__aeabi_f2d",
                "limits_init",
                "trunc",
                "write_global_settings",
                "__aeabi_fcmple",
                "__aeabi_fcmplt",
                "__aeabi_d2uiz",
                "__aeabi_fmul",
                "round",
                "__aeabi_fcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051b4": {
            "entrypoint": "0x080051b4",
            "current_name": "handle_global_settings_080051b4",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd handle_global_settings_080051b4(voindexd)\n\n{\n  uindexnt8_t status;\n  float coordinates [3];\n  uindexnt8_t index;\n  \n  status = read_global_settindexngs();\n  indexf (status == '\\0') {\n    report_status_message('\\n');\n    settindexngs_reset(true);\n    report_grbl_settindexngs();\n  }\n  for (index = '\\0'; index < 8; index = index + '\\x01') {\n    status = settindexngs_read_coordinates(index,coordinates);\n    indexf (status == '\\0') {\n      report_status_message('\\n');\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080051b4": "handle_global_settings_080051b4",
                "uVar1": "status",
                "coord_data": "coordinates",
                "i": "index"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "report_status_message",
                "report_grbl_settings",
                "read_global_settings",
                "settings_reset",
                "settings_read_coord_data"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005208": {
            "entrypoint": "0x08005208",
            "current_name": "FUNC_08005208",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005208(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005208": "FUNC_08005208"
            },
            "calling": [
                "spindle_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005214": {
            "entrypoint": "0x08005214",
            "current_name": "FUNC_08005214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005214(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005214": "FUNC_08005214"
            },
            "calling": [
                "spindle_stop"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005220": {
            "entrypoint": "0x08005220",
            "current_name": "FUNC_08005220",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005220(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005220": "FUNC_08005220"
            },
            "calling": [
                "spindle_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800522c": {
            "entrypoint": "0x0800522c",
            "current_name": "FUNC_0800522c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800522c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800522c": "FUNC_0800522c"
            },
            "calling": [
                "spindle_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005238": {
            "entrypoint": "0x08005238",
            "current_name": "stop_spindle_08005238",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopSpindle_08005238(void)\n\n{\n  currentDirection = '\\0';\n  spindle_stop();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005238": "stop_spindle_08005238",
                "current_direction": "currentDirection"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "spindle_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005250": {
            "entrypoint": "0x08005250",
            "current_name": "turn_off_spindle_08005250",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid turn_off_spindle_08005250(void)\n\n{\n  spindle_off();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005250": "turn_off_spindle_08005250"
            },
            "calling": [
                "spindle_init",
                "mc_reset",
                "spindle_run"
            ],
            "called": [
                "spindle_off"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800525c": {
            "entrypoint": "0x0800525c",
            "current_name": "update_spindle_direction_0800525c",
            "code": "\nvoid updateSpindleDirection_0800525c(int8_t newDirection)\n\n{\n  int8_t localDirection;\n  \n  if ((int)newDirection != (uint)currentDirection) {\n    plan_synchronize();\n    if (newDirection == '\\0') {\n      spindle_stop();\n      currentDirection = newDirection;\n    }\n    else {\n      if (newDirection < '\\x01') {\n        spindle_rev();\n      }\n      else {\n        spindle_fwd();\n      }\n      spindle_on();\n      currentDirection = newDirection;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800525c": "update_spindle_direction_0800525c",
                "direction": "newDirection",
                "direction_local": "localDirection",
                "current_direction": "currentDirection"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "spindle_fwd",
                "spindle_stop",
                "plan_synchronize",
                "spindle_rev",
                "spindle_on"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052ac": {
            "entrypoint": "0x080052ac",
            "current_name": "update_register_080052ac",
            "code": "\n\n\nvoid updateRegister_080052ac(uint32_t input)\n\n{\n  uint32_t localValue;\n  uint32_t value;\n  \n  _DAT_40021014 = input | _DAT_40021014 & 0inputfffffaaf;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052ac": "update_register_080052ac",
                "x": "input",
                "x_local": "localValue",
                "val": "value"
            },
            "calling": [
                "st_init",
                "step_delay_isr",
                "step_pulse_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052dc": {
            "entrypoint": "0x080052dc",
            "current_name": "update_register_value_080052dc",
            "code": "\n\n\nvoid updateRegisterValue_080052dc(uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  uint32_t newValue;\n  \n  _DAT_40021014 = inputValue | _DAT_40021014 & 0inputValuefffff55f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052dc": "update_register_value_080052dc",
                "x": "inputValue",
                "x_local": "localValue",
                "val": "newValue"
            },
            "calling": [
                "step_period_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800530c": {
            "entrypoint": "0x0800530c",
            "current_name": "FUNC_0800530c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800530c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800530c": "FUNC_0800530c"
            },
            "calling": [
                "st_go_idle"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005318": {
            "entrypoint": "0x08005318",
            "current_name": "FUNC_08005318",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005318(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005318": "FUNC_08005318"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005324": {
            "entrypoint": "0x08005324",
            "current_name": "set_step_period_by_minute_08005324",
            "code": "\nvoid setStepPeriodByMinute_08005324(uint32_t inputStepsPerMinute)\n\n{\n  uint32_t adjustedStepsPerMinute;\n  uint32_t calculatedTicks;\n  \n  adjustedStepsPerMinute = inputStepsPerMinute;\n  if (inputStepsPerMinute < 800) {\n    adjustedStepsPerMinute = 800;\n  }\n  st.cycles_per_step_event = 1260000000 / adjustedStepsPerMinute;\n  set_step_period(st.cycles_per_step_event);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005324": "set_step_period_by_minute_08005324",
                "steps_per_minute": "inputStepsPerMinute",
                "steps_per_minute_local": "adjustedStepsPerMinute",
                "ticks": "calculatedTicks"
            },
            "calling": [
                "step_period_isr",
                "st_cycle_reinitialize",
                "st_reset"
            ],
            "called": [
                "set_step_period"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005360": {
            "entrypoint": "0x08005360",
            "current_name": "update_trapezoid_counter_08005360",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint updateTrapezoidCounter_08005360(void)\n\n{\n  bool isExceededThreshold;\n  \n  tickCycleCounter = cyclesPerStepEvent + tickCycleCounter;\n  isExceededThreshold = 420000 < tickCycleCounter;\n  if (isExceededThreshold) {\n    tickCycleCounter = tickCycleCounter - 420000;\n  }\n  return (uint)isExceededThreshold;\n}\n\n",
            "renaming": {
                "FUN_08005360": "update_trapezoid_counter_08005360",
                "st.trapezoid_tick_cycle_counter": "tickCycleCounter",
                "st.cycles_per_step_event": "cyclesPerStepEvent",
                "bVar1": "isExceededThreshold"
            },
            "calling": [
                "step_period_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "perform_movement_080053a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performMovement_080053a0(void)\n\n{\n  int iterationResult;\n  \n  writeDirection((uint)directionBits);\n  savedStepBits = stepBits;\n  if (currentBlock == (block_t *)0x0) {\n    currentBlock = getCurrentBlockPlan();\n    if (currentBlock == (block_t *)0x0) {\n      goIdle();\n      system.execute = system.execute | 4;\n    }\n    else {\n      if (system.stateate == '\\x03') {\n        adjustedRateOfTrapezoid = currentBlock->initial_rate;\n        setStepEventsPerMinute(adjustedRateOfTrapezoid);\n        state.trapezoid_tick_cycle_counter = 210000;\n      }\n      minSafeRate = (currentBlock->rate_delta >> 1) + currentBlock->rate_delta;\n      counterX = -(currentBlock->stateep_event_count >> 1);\n      eventCount = currentBlock->stateep_event_count;\n      stepEventsCompleted = 0;\n      counterY = counterX;\n      counterZ = counterX;\n    }\n  }\n  if (currentBlock != (block_t *)0x0) {\n    directionBits = currentBlock->direction_bits;\n    stepBits = 0;\n    counterX = currentBlock->stateeps_x + counterX;\n    if (0 < counterX) {\n      stepBits = 0x10;\n      counterX = counterX - eventCount;\n      if ((directionBits & 0x20) == 0) {\n        system.position[0] = system.position[0] + 1;\n      }\n      else {\n        system.position[0] = system.position[0] + -1;\n      }\n    }\n    counterY = currentBlock->stateeps_y + counterY;\n    if (0 < counterY) {\n      stepBits = stepBits | 0x440;\n      counterY = counterY - eventCount;\n      if ((directionBits & 0x80) == 0) {\n        system.position[1] = system.position[1] + 1;\n      }\n      else {\n        system.position[1] = system.position[1] + -1;\n      }\n    }\n    counterZ = currentBlock->stateeps_z + counterZ;\n    if (0 < counterZ) {\n      stepBits = stepBits | 0x100;\n      counterZ = counterZ - eventCount;\n      if ((directionBits & 0x200) == 0) {\n        system.position[2] = system.position[2] + 1;\n      }\n      else {\n        system.position[2] = system.position[2] + -1;\n      }\n    }\n    stepEventsCompleted = stepEventsCompleted + 1;\n    if (stepEventsCompleted < (uint)currentBlock->stateep_event_count) {\n      if (system.stateate == '\\x04') {\n        iterationResult = iterateTrapezoidCycleCounter();\n        if (iterationResult != 0) {\n          if ((uint)currentBlock->rate_delta < adjustedRateOfTrapezoid) {\n            adjustedRateOfTrapezoid = adjustedRateOfTrapezoid - currentBlock->rate_delta;\n            setStepEventsPerMinute(adjustedRateOfTrapezoid);\n          }\n          else {\n            goIdle();\n            system.execute = system.execute | 4;\n          }\n        }\n      }\n      else if (stepEventsCompleted < currentBlock->accelerate_until) {\n        iterationResult = iterateTrapezoidCycleCounter();\n        if (iterationResult != 0) {\n          adjustedRateOfTrapezoid = adjustedRateOfTrapezoid + currentBlock->rate_delta;\n          if (currentBlock->nominal_rate <= adjustedRateOfTrapezoid) {\n            adjustedRateOfTrapezoid = currentBlock->nominal_rate;\n          }\n          setStepEventsPerMinute(adjustedRateOfTrapezoid);\n        }\n      }\n      else if (stepEventsCompleted < currentBlock->decelerate_after) {\n        if (adjustedRateOfTrapezoid != currentBlock->nominal_rate) {\n          adjustedRateOfTrapezoid = currentBlock->nominal_rate;\n          setStepEventsPerMinute(adjustedRateOfTrapezoid);\n        }\n      }\n      else if (stepEventsCompleted == currentBlock->decelerate_after) {\n        if (adjustedRateOfTrapezoid == currentBlock->nominal_rate) {\n          state.trapezoid_tick_cycle_counter = 210000;\n        }\n        else {\n          state.trapezoid_tick_cycle_counter = 420000 - state.trapezoid_tick_cycle_counter;\n        }\n      }\n      else {\n        iterationResult = iterateTrapezoidCycleCounter();\n        if (iterationResult != 0) {\n          if (minSafeRate < adjustedRateOfTrapezoid) {\n            adjustedRateOfTrapezoid = adjustedRateOfTrapezoid - currentBlock->rate_delta;\n          }\n          else {\n            adjustedRateOfTrapezoid = adjustedRateOfTrapezoid >> 1;\n          }\n          if (adjustedRateOfTrapezoid < currentBlock->final_rate) {\n            adjustedRateOfTrapezoid = currentBlock->final_rate;\n          }\n          setStepEventsPerMinute(adjustedRateOfTrapezoid);\n        }\n      }\n    }\n    else {\n      stepBits = 0;\n      currentBlock = (block_t *)0x0;\n      plan_discard_currentBlock();\n    }\n  }\n  stepBits = stepBits ^ settings.stepInvertMask;\n  directionBits = directionBits ^ settings.directionInvertMask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "perform_movement_080053a0",
                "iVar1": "iterationResult",
                "dirn_wr": "writeDirection",
                "dirn_bits": "directionBits",
                "saved_step_bits": "savedStepBits",
                "current_block": "currentBlock",
                "plan_get_current_block": "getCurrentBlockPlan",
                "st_go_idle": "goIdle",
                "sys": "system",
                "st": "state",
                "set_step_events_per_minute": "setStepEventsPerMinute",
                "st.trapezoid_adjusted_rate": "adjustedRateOfTrapezoid",
                "st.min_safe_rate": "minSafeRate",
                "st.counter_x": "counterX",
                "st.event_count": "eventCount",
                "st.counter_y": "counterY",
                "st.counter_z": "counterZ",
                "st.step_events_completed": "stepEventsCompleted",
                "step_bits": "stepBits",
                "iterate_trapezoid_cycle_counter": "iterateTrapezoidCycleCounter",
                "settings.step_invert_mask": "settings.stepInvertMask",
                "settings.dirn_invert_mask": "settings.directionInvertMask"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "dirn_wr",
                "iterate_trapezoid_cycle_counter",
                "st_go_idle",
                "plan_discard_current_block",
                "set_step_events_per_minute",
                "plan_get_current_block"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "invert_step_settings_08005760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid invert_step_settings_08005760(void)\n\n{\n  write_step((uint)mask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005760": "invert_step_settings_08005760",
                "settings.step_invert_mask": "mask",
                "step_wr": "write_step"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "step_wr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005778": {
            "entrypoint": "0x08005778",
            "current_name": "execute_step_wrapping_08005778",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_step_wrapping_08005778(void)\n\n{\n  step_wr((uint)step_bits);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005778": "execute_step_wrapping_08005778",
                "saved_step_bits": "step_bits"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "step_wr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005790": {
            "entrypoint": "0x08005790",
            "current_name": "enable_stepper_motor_08005790",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableStepperMotor_08005790(void)\n\n{\n  stepper_motor_enable();\n  if (sys.state == '\\x03') {\n    stepInvertMask = sysSettings.step_invert_mask;\n    dirnInvertMask = sysSettings.dirn_invert_mask;\n    setStepPulseDelay(0x69);\n    setStepPulseTime((pulseMicroseconds + 5) * 0x15);\n    enableStepISR();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005790": "enable_stepper_motor_08005790",
                "settings": "sysSettings",
                "step_bits": "stepInvertMask",
                "dirn_bits": "dirnInvertMask",
                "set_step_pulse_delay": "setStepPulseDelay",
                "set_step_pulse_time": "setStepPulseTime",
                "settings.pulse_microseconds": "pulseMicroseconds",
                "step_isr_enable": "enableStepISR"
            },
            "calling": [
                "limits_go_home",
                "st_init",
                "st_cycle_start"
            ],
            "called": [
                "step_isr_enable",
                "stepper_motor_enable",
                "set_step_pulse_delay",
                "set_step_pulse_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e4": {
            "entrypoint": "0x080057e4",
            "current_name": "disable_stepper_motor_080057e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_stepper_motor_080057e4(void)\n\n{\n  step_isr_disable();\n  if ((settings_data.stepper_idle_lock_time != 0xff) || ((system_data.execute & 0x20) != 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e4": "disable_stepper_motor_080057e4",
                "settings": "settings_data",
                "sys": "system_data"
            },
            "calling": [
                "limits_go_home",
                "st_init",
                "step_period_isr",
                "mc_reset"
            ],
            "called": [
                "stepper_motor_disable",
                "step_isr_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005814": {
            "entrypoint": "0x08005814",
            "current_name": "initialize_function_08005814",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFunction_08005814(void)\n\n{\n  memset(&state,0,0x24);\n  setEventRate(800);\n  currentBlock = (block_t *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005814": "initialize_function_08005814",
                "st": "state",
                "set_step_events_per_minute": "setEventRate",
                "current_block": "currentBlock"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "set_step_events_per_minute",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "perform_step_operations_0800583c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performStepOperations_0800583c(void)\n\n{\n  step_wr((uint)configurations.stepInvertMask);\n  st_wake_up();\n  st_go_idle();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "perform_step_operations_0800583c",
                "settings": "configurations",
                "step_invert_mask": "stepInvertMask"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "st_wake_up",
                "st_go_idle",
                "step_wr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800585c": {
            "entrypoint": "0x0800585c",
            "current_name": "transition_state_and_wake_0800585c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transition_state_and_wake_0800585c(void)\n\n{\n  if (current_state == '\\x02') {\n    current_state = '\\x03';\n    perform_wake_up;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800585c": "transition_state_and_wake_0800585c",
                "sys.state": "current_state",
                "st_wake_up()": "perform_wake_up"
            },
            "calling": [
                "mc_go_home",
                "protocol_execute_runtime",
                "mc_line"
            ],
            "called": [
                "st_wake_up"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800587c": {
            "entrypoint": "0x0800587c",
            "current_name": "update_state_0800587c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_state_0800587c(void)\n\n{\n  if (current_state == '\\x03') {\n    current_state = '\\x04';\n    auto_start = '\\0';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800587c": "update_state_0800587c",
                "sys.state": "current_state",
                "sys.auto_start": "auto_start"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058a0": {
            "entrypoint": "0x080058a0",
            "current_name": "initialize_system_state_080058a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_state_080058a0(void)\n\n{\n  if (current_block_ptr == (BlockStruct *)0x0) {\n    system_state = '\\0';\n  }\n  else {\n    reinitialize_plan_cycle(current_block_ptr->step_event_count - completed_step_events);\n    adjusted_trapezoid_rate = 0;\n    set_step_events_frequency(0);\n    tick_cycle_counter = 210000;\n    completed_step_events = 0;\n    system_state = '\\x02';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058a0": "initialize_system_state_080058a0",
                "current_block": "current_block_ptr",
                "block_t": "BlockStruct",
                "sys.state": "system_state",
                "plan_cycle_reinitialize": "reinitialize_plan_cycle",
                "st.step_events_completed": "completed_step_events",
                "st.trapezoid_adjusted_rate": "adjusted_trapezoid_rate",
                "set_step_events_per_minute": "set_step_events_frequency",
                "st.trapezoid_tick_cycle_counter": "tick_cycle_counter"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [
                "plan_cycle_reinitialize",
                "set_step_events_per_minute"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "check_and_set_execution_permissions_08005900",
            "code": "\nint check_and_set_execution_permissions_08005900(uint8_t input_data)\n\n{\n  uint8_t local_data;\n  int return_code;\n  \n  if (input_data == '~') {\n    sys.execute = sys.execute | 2;\n    return 1;\n  }\n  if (input_data < 0x7f) {\n    if (input_data == '?') {\n      sys.execute = sys.execute | 1;\n      return 1;\n    }\n    if (input_data < 0x40) {\n      if (input_data == '\\x18') {\n        mc_reset();\n        return 1;\n      }\n      if (input_data == '!') {\n        sys.execute = sys.execute | 8;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005900": "check_and_set_execution_permissions_08005900",
                "data": "input_data",
                "data_local": "local_data",
                "rc": "return_code"
            },
            "calling": [
                "serial_read"
            ],
            "called": [
                "mc_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800597c": {
            "entrypoint": "0x0800597c",
            "current_name": "extract_data_0800597c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t extract_data_0800597c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_0800597c": "extract_data_0800597c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005984": {
            "entrypoint": "0x08005984",
            "current_name": "get_afl_call_result_08005984",
            "code": "\nint getAflCallResult_08005984(int inputTicks)\n\n{\n  uint32_t aflCallResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflCallResult = aflCall(1,inputTicks,0);\n  }\n  else {\n    aflCallResult = 0;\n  }\n  return aflCallResult;\n}\n\n",
            "renaming": {
                "FUN_08005984": "get_afl_call_result_08005984",
                "ticks": "inputTicks",
                "uVar1": "aflCallResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059b4": {
            "entrypoint": "0x080059b4",
            "current_name": "initialize_system_080059b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nSystemStatus initializeSystem_080059b4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  configureSysTick(16000);\n  setPriorityGrouping(3);\n  initializeMsp();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080059b4": "initialize_system_080059b4",
                "HAL_StatusTypeDef": "SystemStatus",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_MspInit": "initializeMsp"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "reset_hardware_080059f8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetHardware_080059f8(void)\n\n{\n  _DAT_40023820 = 0;\n  _DAT_40023824 = 0;\n  _DAT_40023810 = 0;\n  _DAT_40023814 = 0;\n  _DAT_40023818 = 0;\n  HAL_MspDeInit();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "reset_hardware_080059f8"
            },
            "calling": [],
            "called": [
                "HAL_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a50": {
            "entrypoint": "0x08005a50",
            "current_name": "FUNC_08005a50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a50(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a50": "FUNC_08005a50"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a5c": {
            "entrypoint": "0x08005a5c",
            "current_name": "FUNC_08005a5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a5c": "FUNC_08005a5c"
            },
            "calling": [
                "HAL_DeInit"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "increment_tick_08005a68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTick_08005a68(void)\n\n{\n  tick = tick + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a68": "increment_tick_08005a68",
                "uwTick": "tick"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a84": {
            "entrypoint": "0x08005a84",
            "current_name": "get_system_tick_08005a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_system_tick_08005a84(void)\n\n{\n  return system_tick;\n}\n\n",
            "renaming": {
                "FUN_08005a84": "get_system_tick_08005a84",
                "uwTick": "system_tick"
            },
            "calling": [
                "get_current_usecs",
                "HAL_RCC_ClockConfig",
                "SysTick_Handler",
                "HAL_RCC_OscConfig",
                "HAL_Delay"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a98": {
            "entrypoint": "0x08005a98",
            "current_name": "delay_ms_08005a98",
            "code": "\nvoid delay_ms_08005a98(uint32_t ms)\n\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  uint32_t delay;\n  uint32_t target_delay;\n  \n  start_time = HAL_GetTick();\n  do {\n    current_time = HAL_GetTick();\n  } while (current_time < ms + start_time);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a98": "delay_ms_08005a98",
                "Delay": "ms",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "Delay_local": "delay",
                "timingdelay": "target_delay"
            },
            "calling": [
                "_delay_ms"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ac4": {
            "entrypoint": "0x08005ac4",
            "current_name": "get_constant_value_08005ac4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getConstantValue_08005ac4(void)\n\n{\n  return 0x1000000;\n}\n\n",
            "renaming": {
                "FUN_08005ac4": "get_constant_value_08005ac4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ad4": {
            "entrypoint": "0x08005ad4",
            "current_name": "get_high_word_08005ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_high_word_08005ad4(void)\n\n{\n  return _DAT_e0042000 >> 0x10;\n}\n\n",
            "renaming": {
                "FUN_08005ad4": "get_high_word_08005ad4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005aec": {
            "entrypoint": "0x08005aec",
            "current_name": "get_lower_12_bits_08005aec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_lower_12_bits_08005aec(void)\n\n{\n  return _DAT_e0042000 & 0xfff;\n}\n\n",
            "renaming": {
                "FUN_08005aec": "get_lower_12_bits_08005aec"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b04": {
            "entrypoint": "0x08005b04",
            "current_name": "set_flag_08005b04",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setFlag_08005b04(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 | 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b04": "set_flag_08005b04"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b20": {
            "entrypoint": "0x08005b20",
            "current_name": "clear_lowest_bit_08005b20",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearLowestBit_08005b20(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 & 0xfffffffe;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b20": "clear_lowest_bit_08005b20"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "enable_interrupt_flag_08005b3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableInterruptFlag_08005b3c(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 | 2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "enable_interrupt_flag_08005b3c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b58": {
            "entrypoint": "0x08005b58",
            "current_name": "clear_interrupt_flag_08005b58",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearInterruptFlag_08005b58(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 & 0xfffffffd;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b58": "clear_interrupt_flag_08005b58"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b74": {
            "entrypoint": "0x08005b74",
            "current_name": "set_flag_in_memory_08005b74",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setFlagInMemory_08005b74(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b74": "set_flag_in_memory_08005b74"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b90": {
            "entrypoint": "0x08005b90",
            "current_name": "clear_interrupt_flag_08005b90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearInterruptFlag_08005b90(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 & 0xfffffffb;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b90": "clear_interrupt_flag_08005b90"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bac": {
            "entrypoint": "0x08005bac",
            "current_name": "initialize_data_08005bac",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_08005bac(void)\n\n{\n  _DAT_42270400 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bac": "initialize_data_08005bac"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc4": {
            "entrypoint": "0x08005bc4",
            "current_name": "reset_global_variable_08005bc4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid resetGlobalVariable_08005bc4(void)\n\n{\n  _DAT_42270400 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bc4": "reset_global_variable_08005bc4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bdc": {
            "entrypoint": "0x08005bdc",
            "current_name": "configure_interrupt_priority_08005bdc",
            "code": "\nvoid configureInterruptPriority_08005bdc(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bdc": "configure_interrupt_priority_08005bdc",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c30": {
            "entrypoint": "0x08005c30",
            "current_name": "check_ticks_validity_08005c30",
            "code": "\n\n\nuint32_t checkTicksValidity_08005c30(uint32_t inputTicks)\n\n{\n  bool isTicksValid;\n  uint32_t localTicks;\n  \n  isTicksValid = inputTicks - 1 < 0x1000000;\n  if (isTicksValid) {\n    _DAT_e000e014 = inputTicks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!isTicksValid;\n}\n\n",
            "renaming": {
                "FUN_08005c30": "check_ticks_validity_08005c30",
                "ticks": "inputTicks",
                "bVar1": "isTicksValid",
                "ticks_local": "localTicks"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c74": {
            "entrypoint": "0x08005c74",
            "current_name": "initialize_memory_08005c74",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08005c74(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x4003010;\n  _DAT_40023884 = 0x20003000;\n  _DAT_40023800 = _DAT_40023800 & 0xfaf2ffff | 0x81;\n  _DAT_4002380c = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c74": "initialize_memory_08005c74"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cec": {
            "entrypoint": "0x08005cec",
            "current_name": "initialize_rcc_oscillators_08005cec",
            "code": "\n\n\nHAL_StatusTypeDef initializeRCCOscillators_08005cec(RCC_OscInitTypeDef *oscillatorConfig)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  RCC_OscInitTypeDef *localOscillatorConfig;\n  uint32_t result2;\n  uint32_t result3;\n  uint32_t result4;\n  uint32_t result5;\n  uint32_t result6;\n  uint32_t result7;\n  uint32_t result;\n  uint32_t result1;\n  uint32_t timeout;\n  \n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0x400000)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (oscillatorConfig->HSEState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      _DAT_40023800 = (uint3)_DAT_40023800;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x20000) != 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 5000 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = CONCAT12((char)oscillatorConfig->HSEState,_DAT_40023800);\n      if (oscillatorConfig->HSEState == 1) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (startTime + 5000 <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (startTime + 5000 <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42470000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = oscillatorConfig->HSICalibrationValue << 3 | _DAT_40023800 & 0xffffff07;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    _DAT_40007000 = _DAT_40007000 | 0x100;\n    startTime = HAL_GetTick();\n    while ((_DAT_40007000 & 0x100) == 0) {\n      currentTime = HAL_GetTick();\n      if (startTime + 100 <= currentTime) {\n        return HAL_TIMEOUT;\n      }\n    }\n    _DAT_40023870 = _DAT_40023870 & 0xffffff00;\n    startTime = HAL_GetTick();\n    while ((_DAT_40023870 & 2) != 0) {\n      currentTime = HAL_GetTick();\n      if (startTime + 5000 <= currentTime) {\n        return HAL_TIMEOUT;\n      }\n    }\n    _DAT_40023870 = CONCAT31(DAT_40023870_1,(char)oscillatorConfig->LSEState);\n    if (oscillatorConfig->LSEState == 1) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 5000 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 5000 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->PLL).PLLState != 0) {\n    if ((_DAT_40023808 & 0xc) == 8) {\n      return HAL_ERROR;\n    }\n    if ((oscillatorConfig->PLL).PLLState == 2) {\n      _DAT_42470060 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x2000000) != 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023804 =\n           (oscillatorConfig->PLL).PLLQ << 0x18 |\n           (oscillatorConfig->PLL).PLLM | (oscillatorConfig->PLL).PLLN << 6 |\n           (((oscillatorConfig->PLL).PLLP >> 1) - 1) * 0x10000 | (oscillatorConfig->PLL).PLLSource\n           | 0x20000000;\n      _DAT_42470060 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x2000000) == 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470060 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x2000000) != 0) {\n        currentTime = HAL_GetTick();\n        if (startTime + 100 <= currentTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005cec": "initialize_rcc_oscillators_08005cec",
                "RCC_OscInitStruct": "oscillatorConfig",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "RCC_OscInitStruct_local": "localOscillatorConfig",
                "result_2": "result2",
                "result_3": "result3",
                "result_4": "result4",
                "result_5": "result5",
                "result_6": "result6",
                "result_7": "result7",
                "result_1": "result1"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800618c": {
            "entrypoint": "0x0800618c",
            "current_name": "initialize_clocks_and_sys_tick_0800618c",
            "code": "\n\n\nHAL_StatusTypeDef initializeClocksAndSysTick_0800618c(RCC_ClkInitTypeDef *clockInitStruct,uint32_t latency)\n\n{\n  uint32_t currentTick;\n  uint timeoutTick;\n  uint32_t localLatency;\n  RCC_ClkInitTypeDef *localClockInitStruct;\n  uint32_t timeout;\n  \n  if ((_DAT_40023c00 & 0xf) < latency) {\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)latency);\n    if (latency != (latency & 0xf)) {\n      return error;\n    }\n    if ((clockInitStruct->ClockType & 1) != 0) {\n      if (clockInitStruct->SYSCLKSource == 1) {\n        if ((_DAT_40023800 & 0x20000) == 0) {\n          return error;\n        }\n      }\n      else if ((clockInitStruct->SYSCLKSource != 2) && ((_DAT_40023800 & 2) == 0)) {\n        return error;\n      }\n      _DAT_40023808 = clockInitStruct->SYSCLKSource | _DAT_40023808 & 0xfffffffc;\n      currentTick = getTick();\n      timeoutTick = currentTick + 5000;\n      if (clockInitStruct->SYSCLKSource == 1) {\n        while ((_DAT_40023808 & 0xc) != 4) {\n          currentTick = getTick();\n          if (timeoutTick <= currentTick) {\n            return timeoutError;\n          }\n        }\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        while ((_DAT_40023808 & 0xc) != 8) {\n          currentTick = getTick();\n          if (timeoutTick <= currentTick) {\n            return timeoutError;\n          }\n        }\n      }\n      else {\n        while ((_DAT_40023808 & 0xc) != 0) {\n          currentTick = getTick();\n          if (timeoutTick <= currentTick) {\n            return timeoutError;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if ((clockInitStruct->ClockType & 1) != 0) {\n      if (clockInitStruct->SYSCLKSource == 1) {\n        if ((_DAT_40023800 & 0x20000) == 0) {\n          return error;\n        }\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        if ((_DAT_40023800 & 0x2000000) == 0) {\n          return error;\n        }\n      }\n      else if ((_DAT_40023800 & 2) == 0) {\n        return error;\n      }\n      _DAT_40023808 = clockInitStruct->SYSCLKSource | _DAT_40023808 & 0xfffffffc;\n      currentTick = getTick();\n      timeoutTick = currentTick + 5000;\n      if (clockInitStruct->SYSCLKSource == 1) {\n        while ((_DAT_40023808 & 0xc) != 4) {\n          currentTick = getTick();\n          if (timeoutTick <= currentTick) {\n            return timeoutError;\n          }\n        }\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        while ((_DAT_40023808 & 0xc) != 8) {\n          currentTick = getTick();\n          if (timeoutTick <= currentTick) {\n            return timeoutError;\n          }\n        }\n      }\n      else {\n        while ((_DAT_40023808 & 0xc) != 0) {\n          currentTick = getTick();\n          if (timeoutTick <= currentTick) {\n            return timeoutError;\n          }\n        }\n      }\n    }\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)latency);\n    if (latency != (latency & 0xf)) {\n      return error;\n    }\n  }\n  if ((clockInitStruct->ClockType & 2) != 0) {\n    _DAT_40023808 = clockInitStruct->AHBCLKDivider | _DAT_40023808 & 0xffffff0f;\n  }\n  if ((clockInitStruct->ClockType & 4) != 0) {\n    _DAT_40023808 = clockInitStruct->APB1CLKDivider | _DAT_40023808 & 0xffffe3ff;\n  }\n  if ((clockInitStruct->ClockType & 8) != 0) {\n    _DAT_40023808 = clockInitStruct->APB2CLKDivider << 3 | _DAT_40023808 & 0xffff1fff;\n  }\n  currentTick = getHCLKFreq();\n  configureSysTick(currentTick / 1000);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800618c": "initialize_clocks_and_sys_tick_0800618c",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "latency",
                "uVar1": "currentTick",
                "uVar2": "timeoutTick",
                "FLatency_local": "localLatency",
                "RCC_ClkInitStruct_local": "localClockInitStruct",
                "HAL_ERROR": "error",
                "HAL_GetTick": "getTick",
                "HAL_TIMEOUT": "timeoutError",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq",
                "SysTick_Config": "configureSysTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "SysTick_Config",
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800640c": {
            "entrypoint": "0x0800640c",
            "current_name": "configure_rcc_mco_0800640c",
            "code": "\n\n\nvoid configure_RCC_MCO_0800640c(uint32_t MCOx,uint32_t MCOSource,uint32_t MCODiv)\n\n{\n  uint32_t local_MCODiv;\n  uint32_t local_MCOSource;\n  uint32_t local_MCOx;\n  GPIO_InitTypeDef GPIO_config;\n  \n  if (MCOx == 0) {\n    _DAT_40023830 = _DAT_40023830 | 1;\n    GPIO_config.Pin = 0x100;\n    GPIO_config.Mode = 2;\n    GPIO_config.Speed = 3;\n    GPIO_config.Pull = 0;\n    GPIO_config.Alternate = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40020000,&GPIO_config);\n    _DAT_40023808 = MCODiv | MCOSource | _DAT_40023808 & 0xf89fffff;\n  }\n  else {\n    _DAT_40023830 = _DAT_40023830 | 4;\n    GPIO_config.Pin = 0x200;\n    GPIO_config.Mode = 2;\n    GPIO_config.Speed = 3;\n    GPIO_config.Pull = 0;\n    GPIO_config.Alternate = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40020800,&GPIO_config);\n    _DAT_40023808 = MCOSource | MCODiv << 3 | _DAT_40023808 & 0x7ffffff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800640c": "configure_rcc_mco_0800640c",
                "RCC_MCOx": "MCOx",
                "RCC_MCOSource": "MCOSource",
                "RCC_MCODiv": "MCODiv",
                "RCC_MCODiv_local": "local_MCODiv",
                "RCC_MCOSource_local": "local_MCOSource",
                "RCC_MCOx_local": "local_MCOx",
                "GPIO_InitStruct": "GPIO_config"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064bc": {
            "entrypoint": "0x080064bc",
            "current_name": "initialize_status_080064bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeStatus_080064bc(void)\n\n{\n  _DAT_4247004c = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064bc": "initialize_status_080064bc"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064d4": {
            "entrypoint": "0x080064d4",
            "current_name": "initialize_data_080064d4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_080064d4(void)\n\n{\n  _DAT_4247004c = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064d4": "initialize_data_080064d4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064ec": {
            "entrypoint": "0x080064ec",
            "current_name": "calculate_sys_clock_freq_080064ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSysClockFreq_080064ec(void)\n\n{\n  uint clkConfig;\n  uint32_t result1;\n  uint32_t result2;\n  uint32_t result3;\n  uint32_t result4;\n  uint32_t result5;\n  uint32_t result6;\n  uint32_t result7;\n  uint32_t result8;\n  uint32_t pllp;\n  uint32_t pllm;\n  uint32_t sysClockFreq;\n  uint32_t pllvco;\n  \n  clkConfig = _DAT_40023808 & 0xc;\n  if (clkConfig == 8) {\n    if ((_DAT_40023804 & 0x400000) == 0) {\n      pllvco = ((_DAT_40023804 & 0x7fc0) >> 6) * (16000000 / (_DAT_40023804 & 0x3f));\n    }\n    else {\n      pllvco = ((_DAT_40023804 & 0x7fc0) >> 6) * (8000000 / (_DAT_40023804 & 0x3f));\n    }\n    return pllvco / ((((_DAT_40023804 & 0x30000) >> 0x10) + 1) * 2);\n  }\n  if (clkConfig < 9) {\n    if (clkConfig == 0) {\n      return 16000000;\n    }\n    if (clkConfig == 4) {\n      return 8000000;\n    }\n  }\n  return 16000000;\n}\n\n",
            "renaming": {
                "FUN_080064ec": "calculate_sys_clock_freq_080064ec",
                "uVar1": "clkConfig",
                "result_6": "result1",
                "result_7": "result2",
                "result_4": "result3",
                "result_5": "result4",
                "result_2": "result5",
                "result_3": "result6",
                "result": "result7",
                "result_1": "result8",
                "sysclockfreq": "sysClockFreq"
            },
            "calling": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006628": {
            "entrypoint": "0x08006628",
            "current_name": "get_system_clock_frequency_08006628",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemClockFrequency_08006628(void)\n\n{\n  uint32_t sysClockFreq;\n  uint32_t returnValue;\n  uint32_t returnValue1;\n  \n  sysClockFreq = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = sysClockFreq >> \"\"[(_DAT_40023808 & 0xf0) >> 4];\n  return sysClockFreq >> \"\"[(_DAT_40023808 & 0xf0) >> 4];\n}\n\n",
            "renaming": {
                "FUN_08006628": "get_system_clock_frequency_08006628",
                "uVar1": "sysClockFreq",
                "result": "returnValue",
                "result_1": "returnValue1"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006680": {
            "entrypoint": "0x08006680",
            "current_name": "get_hclk_frequency_08006680",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_08006680(void)\n\n{\n  uint32_t HCLKFreq;\n  uint32_t shiftedFrequency;\n  uint32_t finalFrequency;\n  \n  HCLKFreq = HAL_RCC_GetHCLKFreq();\n  return HCLKFreq >> \"\"[(_DAT_40023808 & 0x1c00) >> 10];\n}\n\n",
            "renaming": {
                "FUN_08006680": "get_hclk_frequency_08006680",
                "uVar1": "HCLKFreq",
                "result": "shiftedFrequency",
                "result_1": "finalFrequency"
            },
            "calling": [
                "set_baud_rate"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066cc": {
            "entrypoint": "0x080066cc",
            "current_name": "get_adjusted_hclk_freq_080066cc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_080066cc(void)\n\n{\n  uint32_t hclkFreq;\n  uint32_t adjustedFreq;\n  uint32_t shiftedFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> \"\"[(_DAT_40023808 & 0xe000) >> 0xd];\n}\n\n",
            "renaming": {
                "FUN_080066cc": "get_adjusted_hclk_freq_080066cc",
                "uVar1": "hclkFreq",
                "result": "adjustedFreq",
                "result_1": "shiftedFreq"
            },
            "calling": [
                "set_baud_rate"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006718": {
            "entrypoint": "0x08006718",
            "current_name": "initialize_rcc_oscillators_08006718",
            "code": "\n\n\nvoid initializeRCCOscillators_08006718(RCC_OscInitTypeDef *oscillatorConfig)\n\n{\n  RCC_OscInitTypeDef *oscillatorConfig_local;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  \n  oscillatorConfig->OscillatorType = 0xf;\n  if ((_DAT_40023800 & 0x40000) == 0x40000) {\n    oscillatorConfig->HSEState = 5;\n  }\n  else if ((_DAT_40023800 & 0x10000) == 0x10000) {\n    oscillatorConfig->HSEState = 1;\n  }\n  else {\n    oscillatorConfig->HSEState = 0;\n  }\n  if ((_DAT_40023800 & 1) == 1) {\n    oscillatorConfig->HSIState = 1;\n  }\n  else {\n    oscillatorConfig->HSIState = 0;\n  }\n  oscillatorConfig->HSICalibrationValue = (_DAT_40023800 & 0xf8) >> 3;\n  if ((_DAT_40023870 & 4) == 4) {\n    oscillatorConfig->LSEState = 5;\n  }\n  else if ((_DAT_40023870 & 1) == 1) {\n    oscillatorConfig->LSEState = 1;\n  }\n  else {\n    oscillatorConfig->LSEState = 0;\n  }\n  if ((_DAT_40023874 & 1) == 1) {\n    oscillatorConfig->LSIState = 1;\n  }\n  else {\n    oscillatorConfig->LSIState = 0;\n  }\n  if ((_DAT_40023800 & 0x1000000) == 0x1000000) {\n    (oscillatorConfig->PLL).PLLState = 2;\n  }\n  else {\n    (oscillatorConfig->PLL).PLLState = 1;\n  }\n  (oscillatorConfig->PLL).PLLSource = _DAT_40023804 & 0x400000;\n  (oscillatorConfig->PLL).PLLM = _DAT_40023804 & 0x3f;\n  (oscillatorConfig->PLL).PLLN = (_DAT_40023804 & 0x7fc0) >> 6;\n  (oscillatorConfig->PLL).PLLP = ((_DAT_40023804 & 0x30000) + 0x10000) * 2 >> 0x10;\n  (oscillatorConfig->PLL).PLLQ = (_DAT_40023804 & 0xf000000) >> 0x18;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006718": "initialize_rcc_oscillators_08006718",
                "RCC_OscInitStruct": "oscillatorConfig",
                "RCC_OscInitStruct_local": "oscillatorConfig_local"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068bc": {
            "entrypoint": "0x080068bc",
            "current_name": "initialize_clock_configuration_080068bc",
            "code": "\n\n\nvoid initializeClockConfiguration_080068bc(RCC_ClkInitTypeDef *clockConfig,uint32_t *flashLatency)\n\n{\n  uint32_t *localFlashLatency;\n  RCC_ClkInitTypeDef *localClockConfig;\n  \n  clockConfig->ClockType = 0xf;\n  clockConfig->SYSCLKSource = _DAT_40023808 & 3;\n  clockConfig->AHBCLKDivider = _DAT_40023808 & 0xf0;\n  clockConfig->APB1CLKDivider = _DAT_40023808 & 0x1c00;\n  clockConfig->APB2CLKDivider = _DAT_40023808 >> 3 & 0x1c00;\n  *flashLatency = _DAT_40023c00 & 0xf;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080068bc": "initialize_clock_configuration_080068bc",
                "RCC_ClkInitStruct": "clockConfig",
                "pFLatency": "flashLatency",
                "pFLatency_local": "localFlashLatency",
                "RCC_ClkInitStruct_local": "localClockConfig"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800691c": {
            "entrypoint": "0x0800691c",
            "current_name": "handle_interrupt_0800691c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupt_0800691c(void)\n\n{\n  if ((_DAT_4002380c & 0x80) == 0x80) {\n    HAL_RCC_CCSCallback();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800691c": "handle_interrupt_0800691c"
            },
            "calling": [],
            "called": [
                "HAL_RCC_CCSCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006944": {
            "entrypoint": "0x08006944",
            "current_name": "FUNC_08006944",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08006944(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006944": "FUNC_08006944"
            },
            "calling": [
                "HAL_RCC_NMI_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006950": {
            "entrypoint": "0x08006950",
            "current_name": "configure_priority_group_08006950",
            "code": "\n\n\nvoid configurePriorityGroup_08006950(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  uint32_t registerValue;\n  uint32_t temporaryPriorityGroup;\n  \n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (priorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006950": "configure_priority_group_08006950",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "temporaryPriorityGroup"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006998": {
            "entrypoint": "0x08006998",
            "current_name": "get_shifted_bits_08006998",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_shifted_bits_08006998(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_08006998": "get_shifted_bits_08006998"
            },
            "calling": [
                "HAL_NVIC_GetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069b4": {
            "entrypoint": "0x080069b4",
            "current_name": "set_interrupt_flag_080069b4",
            "code": "\nvoid setInterruptFlag_080069b4(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069b4": "set_interrupt_flag_080069b4",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_EnableIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "set_irq_priority_080069e4",
            "code": "\nvoid set_IRQ_priority_080069e4(interrupt_number_Type interrupt_number)\n\n{\n  interrupt_number_Type local_interrupt_number;\n  \n  *(int *)((((uint)(int)interrupt_number >> 5) + 0x20) * 4 + -0x1fff1f00) = 1 << (interrupt_number & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "set_irq_priority_080069e4",
                "IRQn": "interrupt_number",
                "IRQn_local": "local_interrupt_number"
            },
            "calling": [
                "HAL_NVIC_DisableIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006a18": {
            "entrypoint": "0x08006a18",
            "current_name": "get_ir_qn_bit_08006a18",
            "code": "\nuint32_t get_IRQn_bit_08006a18(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  return (uint)((*(uint *)((((uint)(int)IRQn >> 5) + 0x40) * 4 + -0x1fff1f00) & 1 << (IRQn & 0x1fU))\n               != 0);\n}\n\n",
            "renaming": {
                "FUN_08006a18": "get_ir_qn_bit_08006a18"
            },
            "calling": [
                "HAL_NVIC_GetPendingIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006a58": {
            "entrypoint": "0x08006a58",
            "current_name": "set_interrupt_priority_08006a58",
            "code": "\nvoid setInterruptPriority_08006a58(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)((((uint)(int)interruptNumber >> 5) + 0x40) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006a58": "set_interrupt_priority_08006a58",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_SetPendingIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006a8c": {
            "entrypoint": "0x08006a8c",
            "current_name": "set_irq_enable_08006a8c",
            "code": "\nvoid setIRQEnable_08006a8c(irqNumber_Type irqNumber)\n\n{\n  irqNumber_Type localIRQNumber;\n  \n  *(int *)((((uint)(int)irqNumber >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (irqNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006a8c": "set_irq_enable_08006a8c",
                "IRQn": "irqNumber",
                "IRQn_local": "localIRQNumber"
            },
            "calling": [
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "is_irq_enabled_08006ac0",
            "code": "\nuint32_t is_IRQ_enabled_08006ac0(interrupt_number_Type interrupt_number)\n\n{\n  interrupt_number_Type local_interrupt_number;\n  \n  return (uint)((*(uint *)((((uint)(int)interrupt_number >> 5) + 0x80) * 4 + -0x1fff1f00) & 1 << (interrupt_number & 0x1fU))\n               != 0);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "is_irq_enabled_08006ac0",
                "IRQn": "interrupt_number",
                "IRQn_local": "local_interrupt_number"
            },
            "calling": [
                "HAL_NVIC_GetActive"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b00": {
            "entrypoint": "0x08006b00",
            "current_name": "set_interrupt_priority_08006b00",
            "code": "\nvoid setInterruptPriority_08006b00(interruptNumber_Type interruptNumber,uint32_t priorityLevel)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((priorityLevel & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((priorityLevel & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b00": "set_interrupt_priority_08006b00",
                "IRQn": "interruptNumber",
                "priority": "priorityLevel",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "SysTick_Config",
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b54": {
            "entrypoint": "0x08006b54",
            "current_name": "get_interrupt_priority_08006b54",
            "code": "\nuint32_t getInterruptPriority_08006b54(interruptNumber_Type interruptNumber)\n\n{\n  byte priorityValue;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    priorityValue = *(byte *)(((byte)interruptNumber & 0xf) + 0xe000ed14);\n  }\n  else {\n    priorityValue = *(byte *)(interruptNumber + -0x1fff1c00);\n  }\n  return (uint)(priorityValue >> 4);\n}\n\n",
            "renaming": {
                "FUN_08006b54": "get_interrupt_priority_08006b54",
                "IRQn": "interruptNumber",
                "bVar1": "priorityValue",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ba0": {
            "entrypoint": "0x08006ba0",
            "current_name": "calculate_priority_08006ba0",
            "code": "\nuint32_t calculatePriority_08006ba0(uint32_t priorityGroup,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint numPriorityBits;\n  uint numSubPriorityBits;\n  uint32_t subPriority_local;\n  uint32_t preemptPriority_local;\n  uint32_t priorityGroup_local;\n  uint32_t numSubPriorityBits;\n  uint32_t numPreemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  numPriorityBits = priorityGroup & 7;\n  numSubPriorityBits = 7 - numPriorityBits;\n  if (3 < numSubPriorityBits) {\n    numSubPriorityBits = 4;\n  }\n  if (numPriorityBits + 4 < 7) {\n    numPriorityBits = 0;\n  }\n  else {\n    numPriorityBits = numPriorityBits - 3;\n  }\n  return subPriority & (1 << (numPriorityBits & 0xff)) - 1U |\n         ((1 << (numSubPriorityBits & 0xff)) - 1U & preemptPriority) << (numPriorityBits & 0xff);\n}\n\n",
            "renaming": {
                "FUN_08006ba0": "calculate_priority_08006ba0",
                "PriorityGroup": "priorityGroup",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "numPriorityBits",
                "uVar2": "numSubPriorityBits",
                "SubPriority_local": "subPriority_local",
                "PreemptPriority_local": "preemptPriority_local",
                "PriorityGroup_local": "priorityGroup_local",
                "SubPriorityBits": "numSubPriorityBits",
                "PreemptPriorityBits": "numPreemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c04": {
            "entrypoint": "0x08006c04",
            "current_name": "calculate_priority_08006c04",
            "code": "\nvoid calculatePriority_08006c04(uint32_t taskPriority,uint32_t taskPriorityGroup,uint32_t *pPreempttaskPriority,\n                 uint32_t *pSubtaskPriority)\n\n{\n  uint groupBitsRemaining;\n  uint remainingBits;\n  uint32_t *pSubtaskPriority_local;\n  uint32_t *pPreempttaskPriority_local;\n  uint32_t taskPriorityGroup_local;\n  uint32_t taskPriority_local;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t taskPriorityGroupTmp;\n  \n  groupBitsRemaining = taskPriorityGroup & 7;\n  remainingBits = 7 - groupBitsRemaining;\n  if (3 < remainingBits) {\n    remainingBits = 4;\n  }\n  if (groupBitsRemaining + 4 < 7) {\n    groupBitsRemaining = 0;\n  }\n  else {\n    groupBitsRemaining = groupBitsRemaining - 3;\n  }\n  *pPreempttaskPriority = (1 << (remainingBits & 0xff)) - 1U & taskPriority >> (groupBitsRemaining & 0xff);\n  *pSubtaskPriority = (1 << (groupBitsRemaining & 0xff)) - 1U & taskPriority;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c04": "calculate_priority_08006c04",
                "Priority": "taskPriority",
                "PriorityGroup": "taskPriorityGroup",
                "uVar1": "groupBitsRemaining",
                "uVar2": "remainingBits",
                "PriorityGroup_local": "taskPriorityGroup_local",
                "Priority_local": "taskPriority_local",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "taskPriorityGroupTmp"
            },
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c70": {
            "entrypoint": "0x08006c70",
            "current_name": "continuous_loop_08006c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid continuousLoop_08006c70(void)\n\n{\n  syncBar(0xf);\n  syncBar(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006c70": "continuous_loop_08006c70",
                "DataSynchronizationBarrier": "syncBar"
            },
            "calling": [
                "HAL_NVIC_SystemReset"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c9c": {
            "entrypoint": "0x08006c9c",
            "current_name": "check_tick_validity_08006c9c",
            "code": "\n\n\nuint32_t checkTickValidity_08006c9c(uint32_t inputTicks)\n\n{\n  bool isTicksValid;\n  uint32_t localTicks;\n  \n  isTicksValid = inputTicks - 1 < 0x1000000;\n  if (isTicksValid) {\n    _DAT_e000e014 = inputTicks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!isTicksValid;\n}\n\n",
            "renaming": {
                "FUN_08006c9c": "check_tick_validity_08006c9c",
                "ticks": "inputTicks",
                "bVar1": "isTicksValid",
                "ticks_local": "localTicks"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ce0": {
            "entrypoint": "0x08006ce0",
            "current_name": "set_nvic_priority_grouping_08006ce0",
            "code": "\nvoid setNVICPriorityGrouping_08006ce0(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  \n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006ce0": "set_nvic_priority_grouping_08006ce0",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cf6": {
            "entrypoint": "0x08006cf6",
            "current_name": "set_irq_priority_08006cf6",
            "code": "\nvoid setIRQPriority_08006cf6(interruptNumber_Type interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint32_t priorityGroup;\n  uint32_t subPriorityLocal;\n  uint32_t preemptPriorityLocal;\n  interruptNumber_Type interruptNumberLocal;\n  uint32_t priorityGrouping;\n  \n  priorityGroup = NVIC_GetPriorityGrouping();\n  priorityGroup = NVIC_EncodePriority(priorityGroup,preemptPriority,subPriority);\n  NVIC_SetPriority(interruptNumber,priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cf6": "set_irq_priority_08006cf6",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroup",
                "SubPriority_local": "subPriorityLocal",
                "PreemptPriority_local": "preemptPriorityLocal",
                "IRQn_local": "interruptNumberLocal",
                "prioritygroup": "priorityGrouping"
            },
            "calling": [
                "enable_tim_interrupt"
            ],
            "called": [
                "NVIC_EncodePriority",
                "NVIC_SetPriority",
                "NVIC_GetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d2e": {
            "entrypoint": "0x08006d2e",
            "current_name": "enable_interrupt_08006d2e",
            "code": "\nvoid enableInterrupt_08006d2e(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  NVIC_EnableIRQ(interruptNumber);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d2e": "enable_interrupt_08006d2e",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d4a": {
            "entrypoint": "0x08006d4a",
            "current_name": "disable_irq_08006d4a",
            "code": "\nvoid disableIrq_08006d4a(irq_Type irq)\n\n{\n  irq_Type localIrq;\n  \n  NVIC_DisableIRQ(irq);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d4a": "disable_irq_08006d4a",
                "IRQn": "irq",
                "IRQn_local": "localIrq"
            },
            "calling": [],
            "called": [
                "NVIC_DisableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d66": {
            "entrypoint": "0x08006d66",
            "current_name": "reset_system_08006d66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_system_08006d66(void)\n\n{\n  reset_interrupts();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d66": "reset_system_08006d66",
                "NVIC_SystemReset": "reset_interrupts"
            },
            "calling": [],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d72": {
            "entrypoint": "0x08006d72",
            "current_name": "configure_sys_tick_08006d72",
            "code": "\nuint32_t configureSysTick_08006d72(uint32_t ticksNumber)\n\n{\n  uint32_t configStatus;\n  uint32_t localTicksNumber;\n  \n  configStatus = SysTick_Config(ticksNumber);\n  return configStatus;\n}\n\n",
            "renaming": {
                "FUN_08006d72": "configure_sys_tick_08006d72",
                "TicksNumb": "ticksNumber",
                "TicksNumb_local": "localTicksNumber",
                "uVar1": "configStatus"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8a": {
            "entrypoint": "0x08006d8a",
            "current_name": "get_priority_grouping_08006d8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPriorityGrouping_08006d8a(void)\n\n{\n  uint32_t priorityGroup;\n  \n  priorityGroup = NVIC_GetPriorityGrouping();\n  return priorityGroup;\n}\n\n",
            "renaming": {
                "FUN_08006d8a": "get_priority_grouping_08006d8a",
                "uVar1": "priorityGroup"
            },
            "calling": [],
            "called": [
                "NVIC_GetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d98": {
            "entrypoint": "0x08006d98",
            "current_name": "decode_irq_priority_08006d98",
            "code": "\nvoid decodeIRQPriority_08006d98(interruptNumber_Type interruptNumber,uint32_t priorityGroup,uint32_t *pPreemptinterruptPriority,\n                 uint32_t *pSubinterruptPriority)\n\n{\n  uint32_t interruptPriority;\n  uint32_t *pSubinterruptPriority_local;\n  uint32_t *pPreemptinterruptPriority_local;\n  uint32_t priorityGroup_local;\n  interruptNumber_Type interruptNumber_local;\n  \n  interruptPriority = NVIC_GetinterruptPriority(interruptNumber);\n  NVIC_DecodeinterruptPriority(interruptPriority,priorityGroup,pPreemptinterruptPriority,pSubinterruptPriority);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d98": "decode_irq_priority_08006d98",
                "IRQn": "interruptNumber",
                "PriorityGroup": "priorityGroup",
                "Priority": "interruptPriority",
                "PriorityGroup_local": "priorityGroup_local",
                "IRQn_local": "interruptNumber_local"
            },
            "calling": [],
            "called": [
                "NVIC_GetPriority",
                "NVIC_DecodePriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc4": {
            "entrypoint": "0x08006dc4",
            "current_name": "set_pending_irq_08006dc4",
            "code": "\nvoid setPendingIRQ_08006dc4(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  NVIC_SetPendingIRQ(interruptNumber);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006dc4": "set_pending_irq_08006dc4",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [],
            "called": [
                "NVIC_SetPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006de0": {
            "entrypoint": "0x08006de0",
            "current_name": "get_pending_irq_08006de0",
            "code": "\nuint32_t getPendingIRQ_08006de0(IRQn IRQn)\n\n{\n  uint32_t pendingIRQ;\n  IRQn localIRQn;\n  \n  pendingIRQ = NVIC_GetPendingIRQ(IRQn);\n  return pendingIRQ;\n}\n\n",
            "renaming": {
                "FUN_08006de0": "get_pending_irq_08006de0",
                "IRQn_Type": "IRQn",
                "IRQn_local": "localIRQn",
                "uVar1": "pendingIRQ"
            },
            "calling": [],
            "called": [
                "NVIC_GetPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dfe": {
            "entrypoint": "0x08006dfe",
            "current_name": "clear_pending_irq_08006dfe",
            "code": "\nvoid clearPendingIRQ_08006dfe(irqType_Type irqType)\n\n{\n  irqType_Type localIRQ;\n  \n  NVIC_ClearPendingIRQ(irqType);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006dfe": "clear_pending_irq_08006dfe",
                "IRQn": "irqType",
                "IRQn_local": "localIRQ"
            },
            "calling": [],
            "called": [
                "NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e1a": {
            "entrypoint": "0x08006e1a",
            "current_name": "get_active_interrupt_priority_08006e1a",
            "code": "\nuint32_t getActiveInterruptPriority_08006e1a(interruptNumber_Type interruptNumber)\n\n{\n  uint32_t activePriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  activePriority = NVIC_GetActive(interruptNumber);\n  return activePriority;\n}\n\n",
            "renaming": {
                "FUN_08006e1a": "get_active_interrupt_priority_08006e1a",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber",
                "uVar1": "activePriority"
            },
            "calling": [],
            "called": [
                "NVIC_GetActive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e38": {
            "entrypoint": "0x08006e38",
            "current_name": "set_clk_source_08006e38",
            "code": "\n\n\nvoid setCLKSource_08006e38(uint32_t source)\n\n{\n  uint32_t localSource;\n  \n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e38": "set_clk_source_08006e38",
                "CLKSource": "source",
                "CLKSource_local": "localSource"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e70": {
            "entrypoint": "0x08006e70",
            "current_name": "handle_sys_tick_callback_08006e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickCallback_08006e70(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e70": "handle_sys_tick_callback_08006e70"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e7c": {
            "entrypoint": "0x08006e7c",
            "current_name": "FUNC_08006e7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08006e7c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e7c": "FUNC_08006e7c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006e88": {
            "entrypoint": "0x08006e88",
            "current_name": "configure_gpio_08006e88",
            "code": "\n\n\nvoid configureGPIO_08006e88(GPIO *gpioInstance,GPIO_Config *gpioConfig)\n\n{\n  uint32_t alternateValue;\n  uint bitMask;\n  uint pinCheckValue;\n  int gpioIndex;\n  GPIO_Config *local_GPIO_Config;\n  GPIO *local_gpioInstance;\n  uint32_t temporary;\n  uint32_t currentValue;\n  uint32_t positionValue;\n  uint32_t bitPosition;\n  \n  for (bitPosition = 0; bitPosition < 0x10; bitPosition = bitPosition + 1) {\n    bitMask = 1 << (bitPosition & 0xff);\n    pinCheckValue = gpioConfig->Pin & bitMask;\n    if (pinCheckValue == bitMask) {\n      if ((gpioConfig->Mode == 2) || (gpioConfig->Mode == 0x12)) {\n        alternateValue = gpioConfig->Alternate;\n        gpioInstance->AFR[bitPosition >> 3] = gpioInstance->AFR[bitPosition >> 3] & ~(0xf << ((bitPosition & 7) << 2));\n        gpioInstance->AFR[bitPosition >> 3] = gpioInstance->AFR[bitPosition >> 3] | alternateValue << ((bitPosition & 7) << 2);\n      }\n      gpioInstance->MODER = gpioInstance->MODER & ~(3 << ((bitPosition & 0x7f) << 1));\n      gpioInstance->MODER = gpioInstance->MODER | (gpioConfig->Mode & 3) << ((bitPosition & 0x7f) << 1);\n      if ((((gpioConfig->Mode == 1) || (gpioConfig->Mode == 2)) || (gpioConfig->Mode == 0x11)) ||\n         (gpioConfig->Mode == 0x12)) {\n        gpioInstance->OSPEEDR = gpioInstance->OSPEEDR & ~(3 << ((bitPosition & 0x7f) << 1));\n        gpioInstance->OSPEEDR = gpioInstance->OSPEEDR | gpioConfig->Speed << ((bitPosition & 0x7f) << 1);\n        gpioInstance->OTYPER = gpioInstance->OTYPER & ~(1 << (bitPosition & 0xff));\n        gpioInstance->OTYPER = gpioInstance->OTYPER | (gpioConfig->Mode >> 4 & 1) << (bitPosition & 0xff);\n      }\n      gpioInstance->PUPDR = gpioInstance->PUPDR & ~(3 << ((bitPosition & 0x7f) << 1));\n      gpioInstance->PUPDR = gpioInstance->PUPDR | gpioConfig->Pull << ((bitPosition & 0x7f) << 1);\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800) =\n             ~(0xf << ((bitPosition & 3) << 2)) & *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800);\n        if (gpioInstance == (GPIO *)0x40020000) {\n          gpioIndex = 0;\n        }\n        else if (gpioInstance == (GPIO *)0x40020400) {\n          gpioIndex = 1;\n        }\n        else if (gpioInstance == (GPIO *)0x40020800) {\n          gpioIndex = 2;\n        }\n        else if (gpioInstance == (GPIO *)0x40020c00) {\n          gpioIndex = 3;\n        }\n        else if (gpioInstance == (GPIO *)0x40021000) {\n          gpioIndex = 4;\n        }\n        else if (gpioInstance == (GPIO *)0x40021400) {\n          gpioIndex = 5;\n        }\n        else if (gpioInstance == (GPIO *)0x40021800) {\n          gpioIndex = 6;\n        }\n        else if (gpioInstance == (GPIO *)0x40021c00) {\n          gpioIndex = 7;\n        }\n        else if (gpioInstance == (GPIO *)0x40022000) {\n          gpioIndex = 8;\n        }\n        else if (gpioInstance == (GPIO *)0x40022400) {\n          gpioIndex = 9;\n        }\n        else {\n          gpioIndex = 10;\n        }\n        *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800) =\n             gpioIndex << ((bitPosition & 3) << 2) | *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800);\n        _DAT_40013c00 = ~pinCheckValue & _DAT_40013c00;\n        _DAT_40013c04 = ~pinCheckValue & _DAT_40013c04;\n        if ((gpioConfig->Mode & 0x10000) != 0) {\n          _DAT_40013c00 = pinCheckValue | _DAT_40013c00;\n        }\n        if ((gpioConfig->Mode & 0x20000) != 0) {\n          _DAT_40013c04 = pinCheckValue | _DAT_40013c04;\n        }\n        _DAT_40013c08 = ~pinCheckValue & _DAT_40013c08;\n        _DAT_40013c0c = ~pinCheckValue & _DAT_40013c0c;\n        if ((gpioConfig->Mode & 0x100000) != 0) {\n          _DAT_40013c08 = pinCheckValue | _DAT_40013c08;\n        }\n        if ((gpioConfig->Mode & 0x200000) != 0) {\n          _DAT_40013c0c = pinCheckValue | _DAT_40013c0c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e88": "configure_gpio_08006e88",
                "GPIO_TypeDef": "GPIO",
                "GPIO_InitTypeDef": "GPIO_Config",
                "GPIOx": "gpioInstance",
                "GPIO_Init": "gpioConfig",
                "uVar1": "alternateValue",
                "uVar2": "bitMask",
                "uVar3": "pinCheckValue",
                "iVar4": "gpioIndex",
                "GPIO_Init_local": "local_GPIO_Config",
                "GPIOx_local": "local_gpioInstance",
                "temp": "temporary",
                "iocurrent": "currentValue",
                "ioposition": "positionValue",
                "position": "bitPosition"
            },
            "calling": [
                "gpio_init",
                "HAL_RCC_MCOConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071d0": {
            "entrypoint": "0x080071d0",
            "current_name": "configure_gpio_080071d0",
            "code": "\n\n\nvoid configureGPIO_080071d0(GPIO_TypeDef *gpioPort,uint32_t pinMask)\n\n{\n  uint bitMask;\n  uint bitCheck;\n  uint32_t localPinMask;\n  GPIO_TypeDef *localGpioPort;\n  uint32_t temporary;\n  uint32_t ioCurrent;\n  uint32_t ioPosition;\n  uint32_t bitPosition;\n  \n  for (bitPosition = 0; bitPosition < 0x10; bitPosition = bitPosition + 1) {\n    bitMask = 1 << (bitPosition & 0xff);\n    bitCheck = bitMask & pinMask;\n    if (bitCheck == bitMask) {\n      gpioPort->MODER = gpioPort->MODER & ~(3 << ((bitPosition & 0x7f) << 1));\n      gpioPort->AFR[bitPosition >> 3] = gpioPort->AFR[bitPosition >> 3] & ~(0xf << ((bitPosition & 7) << 2));\n      gpioPort->OSPEEDR = gpioPort->OSPEEDR & ~(3 << ((bitPosition & 0x7f) << 1));\n      gpioPort->OTYPER = gpioPort->OTYPER & ~(1 << (bitPosition & 0xff));\n      gpioPort->PUPDR = gpioPort->PUPDR & ~(3 << ((bitPosition & 0x7f) << 1));\n      *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800) =\n           ~(0xf << ((bitPosition & 3) << 2)) & *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800);\n      _DAT_40013c00 = ~bitCheck & _DAT_40013c00;\n      _DAT_40013c04 = ~bitCheck & _DAT_40013c04;\n      _DAT_40013c08 = ~bitCheck & _DAT_40013c08;\n      _DAT_40013c0c = ~bitCheck & _DAT_40013c0c;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080071d0": "configure_gpio_080071d0",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinMask",
                "GPIO_Pin_local": "localPinMask",
                "GPIOx_local": "localGpioPort",
                "tmp": "temporary",
                "iocurrent": "ioCurrent",
                "ioposition": "ioPosition",
                "position": "bitPosition",
                "uVar1": "bitMask",
                "uVar2": "bitCheck"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007310": {
            "entrypoint": "0x08007310",
            "current_name": "check_gpio_pin_state_08007310",
            "code": "\npinState check_GPIO_PinState_08007310(GPIO_structure *GPIO_port,uint16_t pin)\n\n{\n  uint16_t local_pin;\n  GPIO_structure *local_GPIO_port;\n  pinState state;\n  \n  return ((uint)pin & GPIO_port->IDR) != 0;\n}\n\n",
            "renaming": {
                "FUN_08007310": "check_gpio_pin_state_08007310",
                "GPIO_TypeDef": "GPIO_structure",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin",
                "GPIO_Pin_local": "local_pin",
                "GPIOx_local": "local_GPIO_port",
                "bitstatus": "state"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800733e": {
            "entrypoint": "0x0800733e",
            "current_name": "toggle_pin_state_0800733e",
            "code": "\nvoid togglePinState_0800733e(GPIO_TypeDef *pinPort,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  pinNumberState localPinState;\n  uint16_t localPinNumber;\n  GPIO_TypeDef *localPinPort;\n  \n  if (pinState == GPIO_PIN_RESET) {\n    pinPort->BSRRH = pinNumber;\n  }\n  else {\n    pinPort->BSRRL = pinNumber;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800733e": "toggle_pin_state_0800733e",
                "GPIOx": "pinPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState",
                "PinState_local": "localPinState",
                "GPIO_Pin_local": "localPinNumber",
                "GPIOx_local": "localPinPort"
            },
            "calling": [
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800736c": {
            "entrypoint": "0x0800736c",
            "current_name": "toggle_gpio_pin_0800736c",
            "code": "\nvoid toggle_GPIO_Pin_0800736c(GPIO_TypeDef *GPIO_port,uint16_t pin_number)\n\n{\n  uint16_t local_pin_number;\n  GPIO_TypeDef *local_GPIO_port;\n  \n  GPIO_port->ODR = GPIO_port->ODR ^ (uint)pin_number;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800736c": "toggle_gpio_pin_0800736c",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin_number",
                "GPIO_Pin_local": "local_pin_number",
                "GPIOx_local": "local_GPIO_port"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800738e": {
            "entrypoint": "0x0800738e",
            "current_name": "handle_gpio_interrupt_0800738e",
            "code": "\n\n\nvoid handle_gpio_interrupt_0800738e(uint16_t pin)\n\n{\n  uint16_t local_pin;\n  \n  if ((pin & _DAT_40013c14) != 0) {\n    _DAT_40013c14 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800738e": "handle_gpio_interrupt_0800738e",
                "GPIO_Pin": "pin",
                "GPIO_Pin_local": "local_pin"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073c0": {
            "entrypoint": "0x080073c0",
            "current_name": "process_gpio_pin_080073c0",
            "code": "\nvoid process_GPIO_Pin_080073c0(uint16_t pin)\n\n{\n  uint16_t pin_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_080073c0": "process_gpio_pin_080073c0",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073d4": {
            "entrypoint": "0x080073d4",
            "current_name": "set_bit_080073d4",
            "code": "\nvoid setBit_080073d4(iinputNumbert inputNumber)\n\n{\n  iinputNumbert localNumber;\n  \n  *(short *)((inputNumber >> 4) * 0x400 + 0x4002001a) = (short)(1 << (inputNumber & 0xfU));\n  returinputNumber;\n}\n\n",
            "renaming": {
                "FUN_080073d4": "set_bit_080073d4",
                "n": "inputNumber",
                "n_local": "localNumber"
            },
            "calling": [
                "debounce_off_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007402": {
            "entrypoint": "0x08007402",
            "current_name": "set_bit_in_memory_08007402",
            "code": "\nvoid setBitInMemory_08007402(iinputNumbert inputNumber)\n\n{\n  iinputNumbert localNumber;\n  \n  *(short *)((inputNumber >> 4) * 0x400 + 0x40020018) = (short)(1 << (inputNumber & 0xfU));\n  returinputNumber;\n}\n\n",
            "renaming": {
                "FUN_08007402": "set_bit_in_memory_08007402",
                "n": "inputNumber",
                "n_local": "localNumber"
            },
            "calling": [
                "debounce_on_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007430": {
            "entrypoint": "0x08007430",
            "current_name": "infinite_loop_08007430",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08007430(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08007430": "infinite_loop_08007430"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007436": {
            "entrypoint": "0x08007436",
            "current_name": "initialize_clock_08007436",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeClock_08007436(void)\n\n{\n  HAL_StatusTypeDef status;\n  RCC_OscInitTypeDef oscillatorConfig;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  oscillatorConfig.OscillatorType = 1;\n  oscillatorConfig.HSEState = 1;\n  oscillatorConfig.PLL.PLLState = 2;\n  oscillatorConfig.PLL.PLLSource = 0x400000;\n  oscillatorConfig.PLL.PLLM = 8;\n  oscillatorConfig.PLL.PLLN = 0x150;\n  oscillatorConfig.PLL.PLLP = 2;\n  oscillatorConfig.PLL.PLLQ = 7;\n  status = HAL_RCC_OscConfig(&oscillatorConfig);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x1400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0x1000;\n  status = HAL_RCC_ClockConfig(&RCC_ClkInitStruct,5);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007436": "initialize_clock_08007436",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HVar1": "status"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_RCC_ClockConfig",
                "Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080074c8": {
            "entrypoint": "0x080074c8",
            "current_name": "handle_bits_080074c8",
            "code": "\nvoid handleBits_080074c8(uint32_t inputBits)\n\n{\n  uint32_t localBits;\n  \n  if ((inputBits & 1) != 0) {\n    gpio_set(0x3e);\n  }\n  if ((limits_enabled != 0) && ((inputBits & 0x1e) != 0)) {\n    limits_isr();\n  }\n  if ((buttons_enabled != 0) && ((inputBits & 0x80) != 0)) {\n    buttons_isr(inputBits);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080074c8": "handle_bits_080074c8",
                "bits": "inputBits",
                "bits_local": "localBits"
            },
            "calling": [
                "debounce_isr"
            ],
            "called": [
                "limits_isr",
                "gpio_set",
                "buttons_isr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007520": {
            "entrypoint": "0x08007520",
            "current_name": "clear_gpio_if_lsb_set_08007520",
            "code": "\nvoid clearGPIOIfLSBSet_08007520(uint32_t inputBits)\n\n{\n  uint32_t localBits;\n  \n  if ((inputBits & 1) != 0) {\n    gpio_clr(0x3e);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007520": "clear_gpio_if_lsb_set_08007520",
                "bits": "inputBits",
                "bits_local": "localBits"
            },
            "calling": [
                "debounce_isr"
            ],
            "called": [
                "gpio_clr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007540": {
            "entrypoint": "0x08007540",
            "current_name": "initialize_system_08007540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeSystem_08007540(void)\n\n{\n  initializeHal();\n  configureSystemClock();\n  initializeGPIO();\n  initializeTimers();\n  initializeDebounce();\n  initializeUSART();\n  startForkServer(0);\n  runGrblMain();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007540": "initialize_system_08007540",
                "HAL_Init": "initializeHal",
                "SystemClock_Config": "configureSystemClock",
                "gpio_init": "initializeGPIO",
                "timers_init": "initializeTimers",
                "debounce_init": "initializeDebounce",
                "usart_init": "initializeUSART",
                "startForkserver": "startForkServer",
                "grbl_main": "runGrblMain"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "SystemClock_Config",
                "gpio_init",
                "grbl_main",
                "usart_init",
                "HAL_Init",
                "debounce_init",
                "timers_init",
                "startForkserver"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800756c": {
            "entrypoint": "0x0800756c",
            "current_name": "initialize_memory_0800756c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_0800756c(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800756c": "initialize_memory_0800756c"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080075c8": {
            "entrypoint": "0x080075c8",
            "current_name": "initialize_system_core_clock_080075c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemCoreClock_080075c8(void)\n\n{\n  uint uVar1;\n  uint32_t multiplierFactor;\n  uint32_t source;\n  uint32_t dividerFactor;\n  uint32_t temporary;\n  uint32_t voltageControlOscillator;\n  \n  uVar1 = _DAT_40023808 & 0xc;\n  if (uVar1 == 8) {\n    if ((_DAT_40023804 >> 0x16 & 1) == 0) {\n      voltageControlOscillator = (_DAT_40023804 >> 6 & 0x1ff) * (16000000 / (_DAT_40023804 & 0x3f));\n    }\n    else {\n      voltageControlOscillator = (_DAT_40023804 >> 6 & 0x1ff) * (8000000 / (_DAT_40023804 & 0x3f));\n    }\n    SystemCoreClock = voltageControlOscillator / (((_DAT_40023804 >> 0x10 & 3) + 1) * 2);\n    goto LAB_0800768a;\n  }\n  if (uVar1 < 9) {\n    if (uVar1 == 0) {\n      SystemCoreClock = 16000000;\n      goto LAB_0800768a;\n    }\n    if (uVar1 == 4) {\n      SystemCoreClock = 8000000;\n      goto LAB_0800768a;\n    }\n  }\n  SystemCoreClock = 16000000;\nLAB_0800768a:\n  SystemCoreClock = SystemCoreClock >> AHBPrescTable[_DAT_40023808 >> 4 & 0xf];\n  return;\n}\n\n",
            "renaming": {
                "FUN_080075c8": "initialize_system_core_clock_080075c8",
                "pllm": "multiplierFactor",
                "pllsource": "source",
                "pllp": "dividerFactor",
                "tmp": "temporary",
                "pllvco": "voltageControlOscillator"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080076c8": {
            "entrypoint": "0x080076c8",
            "current_name": "update_bit_080076c8",
            "code": "\nvoid updateBit_080076c8(inumt num)\n\n{\n  inumt localNum;\n  \n  *(uinumt *)((num >> 4) * 0x400 + 0x40020014) =\n       *(uinumt *)((num >> 4) * 0x400 + 0x40020014) ^ 1 << (num & 0xfU);\n  returnum;\n}\n\n",
            "renaming": {
                "FUN_080076c8": "update_bit_080076c8",
                "n": "num",
                "n_local": "localNum"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800770e": {
            "entrypoint": "0x0800770e",
            "current_name": "FUNC_0800770e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800770e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800770e": "FUNC_0800770e"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800771a": {
            "entrypoint": "0x0800771a",
            "current_name": "infinite_loop_0800771a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_0800771a(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800771a": "infinite_loop_0800771a"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007720": {
            "entrypoint": "0x08007720",
            "current_name": "run_infinite_loop_08007720",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runInfiniteLoop_08007720(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08007720": "run_infinite_loop_08007720"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007726": {
            "entrypoint": "0x08007726",
            "current_name": "infinite_loop_08007726",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08007726(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08007726": "infinite_loop_08007726"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800772c": {
            "entrypoint": "0x0800772c",
            "current_name": "endless_loop_0800772c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid endlessLoop_0800772c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800772c": "endless_loop_0800772c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007732": {
            "entrypoint": "0x08007732",
            "current_name": "FUNC_08007732",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007732(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007732": "FUNC_08007732"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800773e": {
            "entrypoint": "0x0800773e",
            "current_name": "FUNC_0800773e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800773e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800773e": "FUNC_0800773e"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800774a": {
            "entrypoint": "0x0800774a",
            "current_name": "FUNC_0800774a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800774a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800774a": "FUNC_0800774a"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007756": {
            "entrypoint": "0x08007756",
            "current_name": "update_tick_08007756",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTick_08007756(void)\n\n{\n  uint32_t currentTick;\n  uint32_t tickCount;\n  \n  currentTick = HAL_GetTick();\n  if ((currentTick & 0x1ff) == 0) {\n    gpio_toggle(0x3c);\n  }\n  if ((currentTick & 0xf) == 0) {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007756": "update_tick_08007756",
                "uVar1": "currentTick",
                "ticks": "tickCount"
            },
            "calling": [],
            "called": [
                "HAL_GetTick",
                "debounce_isr",
                "gpio_toggle",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800778c": {
            "entrypoint": "0x0800778c",
            "current_name": "initialize_gpio_pins_0800778c",
            "code": "\n\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeGPIOPins_0800778c(voindexd)\n\n{\n  GPIO_INFO *gpioInfoEntry;\n  GPIO_InindextTypeDef gpioInitStruct;\n  GPIO_INFO *gpioInfo;\n  indexnt index;\n  \n  for (index = 0; (uindexnt)index < 0x11; index = index + 1) {\n    gpioInfoEntry = gpioInfo_indexnfo + index;\n    _DAT_40023830 = _DAT_40023830 | 1 << (gpioInfoEntry->num >> 4 & 0xff);\n    gpioInitStruct.Pindexn = 1 << (gpioInfoEntry->num & 0xf);\n    gpioInitStruct.Mode = gpioInfo_indexnfo[index].mode;\n    gpioInitStruct.Pull = gpioInfo_indexnfo[index].pull;\n    gpioInitStruct.Speed = gpioInfo_indexnfo[index].speed;\n    gpioInitStruct.Alternate = gpioInfo_indexnfo[index].alt;\n    HAL_GPIO_Inindext((GPIO_TypeDef *)(((gpioInfoEntry->num >> 4) + 0x100080) * 0x400),&gpioInitStruct);\n    indexf (-1 < gpioInfo_indexnfo[index].indexnindext) {\n      HAL_GPIO_WrindextePindexn((GPIO_TypeDef *)(((gpioInfoEntry->num >> 4) + 0x100080) * 0x400),\n                        (uindexnt16_t)(1 << (gpioInfoEntry->num & 0xf)),(GPIO_PindexnState)gpioInfo_indexnfo[index].indexnindext);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800778c": "initialize_gpio_pins_0800778c",
                "pGVar1": "gpioInfoEntry",
                "GPIO_InitStruct": "gpioInitStruct",
                "gpio": "gpioInfo",
                "i": "index"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007854": {
            "entrypoint": "0x08007854",
            "current_name": "get_bit_value_08007854",
            "code": "\niinput_numbert get_bit_value_08007854(iinput_numbert input_number)\n\n{\n  iinput_numbert shifted_index;\n  \n  returinput_number *(uiinput_numbert *)((input_number >> 4) * 0x400 + 0x40020010) >> (input_number & 0xfU) & 1;\n}\n\n",
            "renaming": {
                "FUN_08007854": "get_bit_value_08007854",
                "n": "input_number",
                "n_local": "shifted_index"
            },
            "calling": [
                "debounce_input"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007884": {
            "entrypoint": "0x08007884",
            "current_name": "read_gpio_pins_08007884",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t read_gpio_pins_08007884(void)\n\n{\n  int pin_1_value;\n  int pin_2_value;\n  int pin_3_value;\n  int pin_4_value;\n  int pin_5_value;\n  uint pin_0_value;\n  \n  pin_1_value = gpio_rd(0x36);\n  pin_2_value = gpio_rd(0x37);\n  pin_3_value = gpio_rd(0x38);\n  pin_4_value = gpio_rd(0x39);\n  pin_5_value = gpio_rd(0xf);\n  pin_0_value = gpio_rd(0);\n  return pin_0_value | pin_1_value << 4 | pin_2_value << 3 | pin_3_value << 2 | pin_4_value << 1 | pin_5_value << 7;\n}\n\n",
            "renaming": {
                "FUN_08007884": "read_gpio_pins_08007884",
                "iVar1": "pin_1_value",
                "iVar2": "pin_2_value",
                "iVar3": "pin_3_value",
                "iVar4": "pin_4_value",
                "iVar5": "pin_5_value",
                "uVar6": "pin_0_value"
            },
            "calling": [
                "debounce_isr"
            ],
            "called": [
                "gpio_rd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078d0": {
            "entrypoint": "0x080078d0",
            "current_name": "process_bits_080078d0",
            "code": "\nvoid processBits_080078d0(uint32_t inputBits)\n\n{\n  uint updatedBits;\n  int baseAddress;\n  undefined4 registerValue;\n  undefined4 coprocessorValue;\n  uint comparisonValue;\n  int updatedAddress;\n  int registerBase;\n  char negativeFlag;\n  undefined carryFlag;\n  char overflowFlag;\n  undefined4 coprocessorConfig;\n  uint32_t localBits;\n  \n  if (negativeFlag != overflowFlag) {\n    updatedAddress = baseAddress + inputBits * 0x200;\n  }\n  if ((bool)overflowFlag) {\n    updatedBits = inputBits * 0x40000000;\n    carryFlag = comparisonValue <= updatedBits;\n    overflowFlag = SBORROW4(updatedBits,comparisonValue);\n    negativeFlag = (int)(updatedBits - comparisonValue) < 0;\n  }\n  if (!(bool)carryFlag) {\n    *(int *)(registerBase + inputBits * -0x40000000) = updatedAddress;\n  }\n  if (negativeFlag == overflowFlag) {\n    software_interrupt(0xb083);\n  }\n  else {\n    coprocessor_store(6,coprocessorConfig,inputBits);\n    *(undefined4 *)inputBits = registerValue;\n    software_interrupt(0x6078);\n  }\n  if ((bool)negativeFlag) {\n    stackPointer = (stackBase *)(&stack0x00000000 + registerBase * 0x4000);\n  }\n  *(undefined4 *)((int)stackPointer + -4) = coprocessorValue;\n  *(undefined4 *)((int)stackPointer + -0xc) = 0;\n  *(undefined4 *)((int)stackPointer + -0x10) = 0;\n  while (*(int *)((int)stackPointer + -0x10) < 4) {\n    *(uint32_t *)((int)stackPointer + -0xc) =\n         debounce.sample[*(int *)((int)stackPointer + -0x10)] |\n         *(uint *)((int)stackPointer + -0xc);\n    *(int *)((int)stackPointer + -0x10) = *(int *)((int)stackPointer + -0x10) + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078d0": "process_bits_080078d0",
                "bits": "inputBits",
                "uVar1": "updatedBits",
                "in_r3": "baseAddress",
                "unaff_r4": "registerValue",
                "unaff_r7": "coprocessorValue",
                "unaff_r8": "comparisonValue",
                "unaff_r11": "updatedAddress",
                "in_r12": "registerBase",
                "in_NG": "negativeFlag",
                "in_CY": "carryFlag",
                "in_OV": "overflowFlag",
                "in_cr4": "coprocessorConfig",
                "bits_local": "localBits",
                "register0x00000054": "stackPointer",
                "BADSPACEBASE": "stackBase"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078e2": {
            "entrypoint": "0x080078e2",
            "current_name": "update_array_080078e2",
            "code": "\nvoid updateArray_080078e2(uint32_t numBits)\n\n{\n  uint uVar1;\n  int offset;\n  undefined4 value;\n  uint maxValue;\n  int newOffset;\n  int array;\n  char isNegative;\n  undefined isCarry;\n  char isOverflow;\n  undefined4 coprocessorRegister;\n  uint32_t counter;\n  \n  if (isNegative != isOverflow) {\n    newOffset = offset + numBits * 0x200;\n  }\n  if ((bool)isOverflow) {\n    uVar1 = numBits * 0x40000000;\n    isCarry = maxValue <= uVar1;\n    isOverflow = SBORROW4(uVar1,maxValue);\n    isNegative = (int)(uVar1 - maxValue) < 0;\n  }\n  if (!(bool)isCarry) {\n    *(int *)(array + numBits * -0x40000000) = newOffset;\n  }\n  if (isNegative != isOverflow) {\n    coprocessor_store(6,coprocessorRegister,numBits);\n    *(undefined4 *)numBits = value;\n  }\n  for (counter = 0; (int)counter < 4; counter = counter + 1) {\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078e2": "update_array_080078e2",
                "bits": "numBits",
                "in_r3": "offset",
                "unaff_r4": "value",
                "unaff_r8": "maxValue",
                "unaff_r11": "newOffset",
                "in_r12": "array",
                "in_NG": "isNegative",
                "in_CY": "isCarry",
                "in_OV": "isOverflow",
                "in_cr4": "coprocessorRegister",
                "bits_local": "counter"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078f4": {
            "entrypoint": "0x080078f4",
            "current_name": "get_state_from_debounce_080078f4",
            "code": "\n/* WARNING: Unknown callloopIndexng conventloopIndexon */\n\nuloopIndexnt32_t getStateFromDebounce_080078f4(voloopIndexd)\n\n{\n  loopIndexnt loopIndex;\n  uloopIndexnt32_t currentState;\n  \n  currentState = 0;\n  for (loopIndex = 0; loopIndex < 4; loopIndex = loopIndex + 1) {\n    currentState = debounce.sample[loopIndex] | currentState;\n  }\n  return currentState;\n}\n\n",
            "renaming": {
                "FUN_080078f4": "get_state_from_debounce_080078f4",
                "i": "loopIndex",
                "state": "currentState"
            },
            "calling": [
                "debounce_isr",
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007930": {
            "entrypoint": "0x08007930",
            "current_name": "debounce_state_update_08007930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid debounceStateUpdate_08007930(void)\n\n{\n  int index;\n  uint32_t prevState;\n  uint32_t newState;\n  uint changedBits;\n  uint32_t bitsToTurnOff;\n  uint32_t bitsToTurnOn;\n  uint32_t debounceState;\n  DEBOUNCE_CTRL *db;\n  \n  index = debounce.idx;\n  prevState = debounce.debounceState;\n  if (debounce_ready != 0) {\n    prevState = debounce_input();\n    debounce.sample[index] = prevState;\n    if (debounce.idx == 3) {\n      debounce.idx = 0;\n    }\n    else {\n      debounce.idx = debounce.idx + 1;\n    }\n    newState = debounce_rd();\n    prevState = debounce.debounceState;\n    if (newState != debounce.debounceState) {\n      changedBits = ~newState & debounce.debounceState;\n      if ((~debounce.debounceState & newState) != 0) {\n        debounce_on_handler(~debounce.debounceState & newState);\n      }\n      prevState = newState;\n      if (changedBits != 0) {\n        debounce_off_handler(changedBits);\n      }\n    }\n  }\n  debounce.debounceState = prevState;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007930": "debounce_state_update_08007930",
                "iVar1": "index",
                "uVar2": "prevState",
                "uVar3": "newState",
                "bits": "changedBits",
                "off_bits": "bitsToTurnOff",
                "on_bits": "bitsToTurnOn",
                "state": "debounceState"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "debounce_input",
                "debounce_off_handler",
                "debounce_on_handler",
                "debounce_rd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079c0": {
            "entrypoint": "0x080079c0",
            "current_name": "initialize_debounce_080079c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDebounce_080079c0(void)\n\n{\n  memset(&debounceData,0,0x18);\n  isDebounceReady = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080079c0": "initialize_debounce_080079c0",
                "debounce": "debounceData",
                "debounce_ready": "isDebounceReady"
            },
            "calling": [
                "main"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e0": {
            "entrypoint": "0x080079e0",
            "current_name": "set_interrupt_priority_080079e0",
            "code": "\nvoid setInterruptPriority_080079e0(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080079e0": "set_interrupt_priority_080079e0",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "enable_tim_interrupt"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007a10": {
            "entrypoint": "0x08007a10",
            "current_name": "update_tim_type_def_08007a10",
            "code": "\n\n\nvoid update_TIM_TypeDef_08007a10(TIM_TypeDef *tim_struct)\n\n{\n  TIM_TypeDef *local_tim_struct;\n  \n  if (tim_struct == (TIM_TypeDef *)&DAT_40000000) {\n    _DAT_40023840 = _DAT_40023840 | 1;\n  }\n  else if (tim_struct == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 | 2;\n  }\n  else if (tim_struct == (TIM_TypeDef *)&DAT_40000800) {\n    _DAT_40023840 = _DAT_40023840 | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007a10": "update_tim_type_def_08007a10",
                "tim": "tim_struct",
                "tim_local": "local_tim_struct"
            },
            "calling": [
                "step_timer_init",
                "g540_timer_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007a70": {
            "entrypoint": "0x08007a70",
            "current_name": "configure_timer_interrupt_08007a70",
            "code": "\nvoid configureTimerInterrupt_08007a70(TimType *timer,uint32_t priority,uint32_t subpriority)\n\n{\n  uint32_t localSubpriority;\n  uint32_t localPriority;\n  TimType *localTimer;\n  uint32_t interrupt;\n  \n  if (timer == (TimType *)&DAT_40000000) {\n    interrupt._0_1_ = TIM2_IRQn;\n  }\n  else if (timer == (TimType *)0x40000400) {\n    interrupt._0_1_ = TIM3_IRQn;\n  }\n  else {\n    if (timer != (TimType *)&DAT_40000800) {\n      return;\n    }\n    interrupt._0_1_ = TIM4_IRQn;\n  }\n  HAL_NVIC_SetPriority((IRQn_Type)interrupt,priority,subpriority);\n  NVIC_EnableIRQ((IRQn_Type)interrupt);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007a70": "configure_timer_interrupt_08007a70",
                "tim": "timer",
                "pre": "priority",
                "sub": "subpriority",
                "sub_local": "localSubpriority",
                "pre_local": "localPriority",
                "tim_local": "localTimer",
                "irq": "interrupt",
                "TIM_TypeDef": "TimType"
            },
            "calling": [
                "step_timer_init"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ad0": {
            "entrypoint": "0x08007ad0",
            "current_name": "initialize_ti_mx_08007ad0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIMx_08007ad0(void)\n\n{\n  TIM_TypeDef *TIM_instance;\n  \n  enable_TIM_clock((TIM_TypeDef *)&DAT_40000000);\n  _DAT_40000000 = 0;\n  _DAT_40000004 = 0;\n  _DAT_40000008 = 0;\n  _DAT_4000000c = 0;\n  _DAT_40000010 = 0;\n  _DAT_40000018 = 0;\n  _DAT_4000001c = 0;\n  _DAT_40000020 = 0;\n  _DAT_40000024 = 0;\n  _DAT_40000028 = SystemCoreClock / 42000000 - 1;\n  _DAT_4000002c = 0;\n  _DAT_40000034 = 0;\n  _DAT_40000038 = 0;\n  _DAT_4000003c = 0;\n  _DAT_40000040 = 0;\n  _DAT_40000048 = 0;\n  _DAT_4000004c = 0;\n  enable_TIM_interrupt((TIM_TypeDef *)&DAT_40000000,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ad0": "initialize_ti_mx_08007ad0",
                "TIMx": "TIM_instance",
                "enable_tim_clock": "enable_TIM_clock",
                "enable_tim_interrupt": "enable_TIM_interrupt"
            },
            "calling": [
                "timers_init"
            ],
            "called": [
                "enable_tim_clock",
                "enable_tim_interrupt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007b70": {
            "entrypoint": "0x08007b70",
            "current_name": "initialize_ti_mx_08007b70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIMx_08007b70(void)\n\n{\n  TIM_TypeDef *timer;\n  uint32_t configEnable;\n  \n  configEnable = 1;\n  if (_DAT_40000034 != 0) {\n    configEnable = 3;\n  }\n  if (_DAT_40000038 != 0) {\n    configEnable = configEnable | 4;\n  }\n  _DAT_4000000c = _DAT_4000000c | configEnable;\n  _DAT_40000000 = _DAT_40000000 | 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007b70": "initialize_ti_mx_08007b70",
                "TIMx": "timer",
                "enable": "configEnable"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007bc2": {
            "entrypoint": "0x08007bc2",
            "current_name": "initialize_tim_08007bc2",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIM_08007bc2(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  _DAT_40000000 = _DAT_40000000 & 0xfffffffe;\n  _DAT_4000000c = _DAT_4000000c & 0xfffffff8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007bc2": "initialize_tim_08007bc2",
                "TIMx": "timer"
            },
            "calling": [
                "st_go_idle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007bf0": {
            "entrypoint": "0x08007bf0",
            "current_name": "update_timer_ticks_08007bf0",
            "code": "\n\n\nvoid updateTimerTicks_08007bf0(uint32_t newTicks)\n\n{\n  uint32_t localTicks;\n  uint32_t savedTicks;\n  TIM_TypeDef *timerInstance;\n  \n  _DAT_4000002c = newTicks;\n  if (newTicks <= _DAT_40000024) {\n    _DAT_40000024 = newTicks;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007bf0": "update_timer_ticks_08007bf0",
                "ticks": "newTicks",
                "ticks_local": "localTicks",
                "saved": "savedTicks",
                "TIMx": "timerInstance"
            },
            "calling": [
                "set_step_events_per_minute"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007c40": {
            "entrypoint": "0x08007c40",
            "current_name": "set_timer_ticks_08007c40",
            "code": "\n\n\nvoid setTimerTicks_08007c40(uint32_t newTicks)\n\n{\n  uint32_t localTicks;\n  TIM_TypeDef *timerPeripheral;\n  \n  _DAT_40000034 = newTicks;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007c40": "set_timer_ticks_08007c40",
                "ticks": "newTicks",
                "ticks_local": "localTicks",
                "TIMx": "timerPeripheral"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007c5e": {
            "entrypoint": "0x08007c5e",
            "current_name": "set_tick_count_08007c5e",
            "code": "\n\n\nvoid setTickCount_08007c5e(uint32_t tickValue)\n\n{\n  uint32_t localTicks;\n  TIM_TypeDef *timerInstance;\n  \n  _DAT_40000038 = tickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007c5e": "set_tick_count_08007c5e",
                "ticks": "tickValue",
                "ticks_local": "localTicks",
                "TIMx": "timerInstance"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007c7c": {
            "entrypoint": "0x08007c7c",
            "current_name": "handle_interrupts_08007c7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_interrupts_08007c7c(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  if (((_DAT_40000010 & 2) != 0) && ((_DAT_4000000c & 2) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffd;\n    step_delay_isr();\n  }\n  if (((_DAT_40000010 & 4) != 0) && ((_DAT_4000000c & 4) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffb;\n    step_pulse_isr();\n  }\n  if (((_DAT_40000010 & 1) != 0) && ((_DAT_4000000c & 1) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffe;\n    step_period_isr();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007c7c": "handle_interrupts_08007c7c",
                "TIMx": "timer"
            },
            "calling": [],
            "called": [
                "step_delay_isr",
                "step_period_isr",
                "step_pulse_isr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007d08": {
            "entrypoint": "0x08007d08",
            "current_name": "initialize_timer_08007d08",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08007d08(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  enableTimerClock((TIM_TypeDef *)&DAT_40000800);\n  _DAT_40000800 = 0x80;\n  _DAT_40000804 = 0;\n  _DAT_40000808 = 0;\n  _DAT_4000080c = 0;\n  _DAT_40000810 = 0;\n  _DAT_40000818 = 0x6800;\n  _DAT_4000081c = 0;\n  _DAT_40000820 = 0;\n  _DAT_40000824 = 0;\n  _DAT_40000828 = systemCoreClock / 4800000 - 1;\n  _DAT_4000082c = 199;\n  _DAT_40000834 = 0;\n  _DAT_40000838 = 100;\n  _DAT_4000083c = 0;\n  _DAT_40000840 = 0;\n  _DAT_40000848 = 0;\n  _DAT_4000084c = 0;\n  _DAT_40000814 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007d08": "initialize_timer_08007d08",
                "TIMx": "timer",
                "SystemCoreClock": "systemCoreClock",
                "enable_tim_clock": "enableTimerClock"
            },
            "calling": [
                "timers_init"
            ],
            "called": [
                "enable_tim_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007da8": {
            "entrypoint": "0x08007da8",
            "current_name": "initialize_ti_mx_08007da8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIMx_08007da8(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  _DAT_40000820 = _DAT_40000820 | 0x10;\n  _DAT_40000800 = _DAT_40000800 | 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007da8": "initialize_ti_mx_08007da8",
                "TIMx": "timer"
            },
            "calling": [
                "timers_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007dd8": {
            "entrypoint": "0x08007dd8",
            "current_name": "initialize_tim_peripherals_08007dd8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIM_peripherals_08007dd8(void)\n\n{\n  TIM_TypeDef *timer_peripheral;\n  \n  _DAT_40000800 = _DAT_40000800 & 0xfffffffe;\n  _DAT_40000820 = _DAT_40000820 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007dd8": "initialize_tim_peripherals_08007dd8",
                "TIMx": "timer_peripheral"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e08": {
            "entrypoint": "0x08007e08",
            "current_name": "initialize_timer_08007e08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_timer_08007e08(void)\n\n{\n  initialize_step_timer();\n  initialize_g540_timer();\n  start_g540_timer();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007e08": "initialize_timer_08007e08",
                "step_timer_init": "initialize_step_timer",
                "g540_timer_init": "initialize_g540_timer",
                "g540_timer_start": "start_g540_timer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "step_timer_init",
                "g540_timer_start",
                "g540_timer_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e1c": {
            "entrypoint": "0x08007e1c",
            "current_name": "send_character_08007e1c",
            "code": "\n\n\nvoid sendCharacter_08007e1c(char c)\n\n{\n  char localCharacter;\n  USART_TypeDef *serialPort;\n  \n  do {\n  } while ((_DAT_40004400 & 0x80) == 0);\n  _DAT_40004404 = (uint)(byte)c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007e1c": "send_character_08007e1c",
                "c_local": "localCharacter",
                "usart": "serialPort"
            },
            "calling": [
                "serial_write",
                "__io_putchar"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e4c": {
            "entrypoint": "0x08007e4c",
            "current_name": "FUNC_08007e4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007e4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007e4c": "FUNC_08007e4c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007e58": {
            "entrypoint": "0x08007e58",
            "current_name": "check_usart_status_08007e58",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint check_USART_status_08007e58(void)\n\n{\n  USART_TypeDef *usart_device;\n  \n  return (unsigned_integer)((_DAT_40004400 & 0x20) != 0);\n}\n\n",
            "renaming": {
                "FUN_08007e58": "check_usart_status_08007e58",
                "usart": "usart_device",
                "uint": "unsigned_integer"
            },
            "calling": [
                "serial_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e84": {
            "entrypoint": "0x08007e84",
            "current_name": "get_usart_data_08007e84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nchar getUSARTData_08007e84(void)\n\n{\n  USART_TypeDef *usartInstance;\n  \n  return (char)_DAT_40004404;\n}\n\n",
            "renaming": {
                "FUN_08007e84": "get_usart_data_08007e84",
                "usart": "usartInstance"
            },
            "calling": [
                "serial_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ea4": {
            "entrypoint": "0x08007ea4",
            "current_name": "configure_usart_08007ea4",
            "code": "\n\n\nvoid configureUsart_08007ea4(USART_TypeDef *usartPtr)\n\n{\n  USART_TypeDef *localUsartPtr;\n  \n  if (usartPtr == (USART_TypeDef *)0x40011000) {\n    _DAT_40023844 = _DAT_40023844 | 0x10;\n  }\n  else if (usartPtr == (USART_TypeDef *)&DAT_40004400) {\n    _DAT_40023840 = _DAT_40023840 | 0x20000;\n  }\n  else if (usartPtr == (USART_TypeDef *)0x40004800) {\n    _DAT_40023840 = _DAT_40023840 | 0x40000;\n  }\n  else if (usartPtr == (USART_TypeDef *)0x40004c00) {\n    _DAT_40023840 = _DAT_40023840 | 0x80000;\n  }\n  else if (usartPtr == (USART_TypeDef *)0x40005000) {\n    _DAT_40023840 = _DAT_40023840 | 0x100000;\n  }\n  else if (usartPtr == (USART_TypeDef *)0x40011400) {\n    _DAT_40023844 = _DAT_40023844 | 0x20;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ea4": "configure_usart_08007ea4",
                "usart": "usartPtr",
                "usart_local": "localUsartPtr"
            },
            "calling": [
                "usart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f54": {
            "entrypoint": "0x08007f54",
            "current_name": "configure_usart_08007f54",
            "code": "\nvoid configureUSART_08007f54(USART_TypeDef *usart,int baudRate)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  int baudRate_local;\n  USART_TypeDef *usart_local;\n  \n  if ((usart->CR1 & 0x8000) == 0) {\n    if ((usart == (USART_TypeDef *)0x40011000) || (usart == (USART_TypeDef *)0x40011400)) {\n      pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n      pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n      pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n      usart->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) << 4 |\n                   (((pclkFreq2 * 0x19) / (uint)(baudRate << 2) +\n                    (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) * -100)\n                    * 0x10 + 0x32) / 100 & 0xf;\n    }\n    else {\n      pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n      pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n      pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n      usart->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) << 4 |\n                   (((pclkFreq2 * 0x19) / (uint)(baudRate << 2) +\n                    (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) * -100)\n                    * 0x10 + 0x32) / 100 & 0xf;\n    }\n  }\n  else if ((usart == (USART_TypeDef *)0x40011000) || (usart == (USART_TypeDef *)0x40011400)) {\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n    usart->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) << 4 |\n                 (((pclkFreq2 * 0x19) / (uint)(baudRate << 1) +\n                  (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) * -100) *\n                  0x10 + 0x32) / 100 & 0xf;\n  }\n  else {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    usart->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) << 4 |\n                 (((pclkFreq2 * 0x19) / (uint)(baudRate << 1) +\n                  (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) * -100) *\n                  0x10 + 0x32) / 100 & 0xf;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f54": "configure_usart_08007f54",
                "baud": "baudRate",
                "baud_local": "baudRate_local",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3"
            },
            "calling": [
                "usart_init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008190": {
            "entrypoint": "0x08008190",
            "current_name": "initialize_usart_08008190",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeUsart_08008190(void)\n\n{\n  uint32_t value;\n  USART_TypeDef *usartDevice;\n  \n  enable_usartDevice_clock((USART_TypeDef *)&DAT_40004400);\n  _DAT_4000440c = _DAT_4000440c & 0xffff400c | 0xc;\n  _DAT_40004410 = _DAT_40004410 & 0xffff8090;\n  _DAT_40004414 = _DAT_40004414 & 0xfffff000;\n  _DAT_40004400 = _DAT_40004400 & 0xfffffc00;\n  set_baud_rate((USART_TypeDef *)&DAT_40004400,0x1c200);\n  _DAT_4000440c = _DAT_4000440c | 0x2000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008190": "initialize_usart_08008190",
                "val": "value",
                "usart": "usartDevice"
            },
            "calling": [
                "main"
            ],
            "called": [
                "set_baud_rate",
                "enable_usart_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008244": {
            "entrypoint": "0x08008244",
            "current_name": "FUNC_08008244",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008244(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008244": "FUNC_08008244"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008250": {
            "entrypoint": "0x08008250",
            "current_name": "print_data_08008250",
            "code": "\nvoid printData_08008250(uint8_t inputData)\n\n{\n  uint8_t localData;\n  \n  usart_putc(inputData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008250": "print_data_08008250",
                "data": "inputData",
                "data_local": "localData"
            },
            "calling": [
                "printString",
                "print_base2",
                "printFloat",
                "printPgmString",
                "print_uint32_base10",
                "printInteger"
            ],
            "called": [
                "usart_putc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800826a": {
            "entrypoint": "0x0800826a",
            "current_name": "print_character_0800826a",
            "code": "\nint print_character_0800826a(int character)\n\n{\n  int local_character;\n  \n  usart_putc((characterar)character);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800826a": "print_character_0800826a",
                "ch": "character",
                "ch_local": "local_character"
            },
            "calling": [],
            "called": [
                "usart_putc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008286": {
            "entrypoint": "0x08008286",
            "current_name": "check_and_read_serial_data_08008286",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_and_read_serial_data_08008286(void)\n\n{\n  uint8_t received_data;\n  int is_data_available;\n  uint8_t c;\n  \n  is_data_available = usart_tstc();\n  if (is_data_available != 0) {\n    received_data = usart_getc();\n    is_data_available = serial_rx_hook(received_data);\n    if (is_data_available == 0) {\n      return received_data;\n    }\n  }\n  return 0xff;\n}\n\n",
            "renaming": {
                "FUN_08008286": "check_and_read_serial_data_08008286",
                "iVar1": "is_data_available",
                "data": "received_data"
            },
            "calling": [
                "protocol_process"
            ],
            "called": [
                "usart_getc",
                "usart_tstc",
                "serial_rx_hook"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080082ba": {
            "entrypoint": "0x080082ba",
            "current_name": "FUNC_080082ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080082ba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080082ba": "FUNC_080082ba"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080082c8": {
            "entrypoint": "0x080082c8",
            "current_name": "add_and_xor_080082c8",
            "code": "\nvoid addAndXor_080082c8(undefined4 result,uint value)\n\n{\n  __aeabi_dadd(result,value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080082c8": "add_and_xor_080082c8",
                "param_1": "result",
                "param_2": "value"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080082d0": {
            "entrypoint": "0x080082d0",
            "current_name": "reverse_bits_080082d0",
            "code": "\nulonglong reverseBits_080082d0(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int bitIndex1;\n  byte bitResult;\n  uint carry;\n  uint input1Modified;\n  uint input2Modified;\n  uint result1;\n  uint result2;\n  int bitIndex2;\n  uint bitwiseXOR;\n  uint carryBit1;\n  uint carryBit2;\n  uint shiftedInput1;\n  bool isCarry;\n  bool isCondition;\n  bool tempBool;\n  \n  result1 = input4 ^ 0x80000000;\n  bitwiseXOR = input2 << 1;\n  input4 = input4 << 1;\n  isCarry = ((input2 ^ result1) & 0x7fffffff) == 0;\n  isCondition = isCarry && input1 == input3;\n  if (!isCarry || input1 != input3) {\n    isCondition = (bitwiseXOR | input1) == 0;\n  }\n  if (!isCondition) {\n    isCondition = (input4 | input3) == 0;\n  }\n  bitIndex2 = (int)bitwiseXOR >> 0x15;\n  if (!isCondition) {\n    isCondition = bitIndex2 == -1;\n  }\n  bitIndex1 = (int)input4 >> 0x15;\n  if (!isCondition) {\n    isCondition = bitIndex1 == -1;\n  }\n  if (isCondition) {\n    if (bitIndex2 == -1 || bitIndex1 == -1) {\n      bitwiseXOR = result1;\n      carryBit2 = input3;\n      if (bitIndex2 == -1) {\n        bitwiseXOR = input2;\n        carryBit2 = input1;\n      }\n      if (bitIndex2 != -1 || bitIndex1 != -1) {\n        input3 = carryBit2;\n        result1 = bitwiseXOR;\n      }\n      isCondition = (carryBit2 | bitwiseXOR << 0xc) == 0;\n      if (isCondition) {\n        isCondition = (input3 | result1 << 0xc) == 0;\n      }\n      if (isCondition) {\n        isCondition = bitwiseXOR == result1;\n      }\n      if (!isCondition) {\n        bitwiseXOR = bitwiseXOR | 0x80000;\n      }\n      return CONCAT44(bitwiseXOR,carryBit2);\n    }\n    if (((input2 ^ result1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((bitwiseXOR | input1) == 0) {\n        input1 = input3;\n        input2 = result1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != result1) {\n      return 0;\n    }\n    if (bitwiseXOR >> 0x15 == 0) {\n      isCondition = (input1 & 0x80000000) != 0;\n      result1 = input2 * 2 + (uint)isCondition;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)isCondition)) {\n        result1 = result1 | 0x80000000;\n      }\n      return CONCAT44(result1,input1 << 1);\n    }\n    if (bitwiseXOR < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  bitwiseXOR = bitwiseXOR >> 0x15;\n  input4 = input4 >> 0x15;\n  carryBit2 = input4 - bitwiseXOR;\n  isCondition = carryBit2 != 0;\n  if (input4 < bitwiseXOR) {\n    carryBit2 = -carryBit2;\n  }\n  carryBit1 = input1;\n  result2 = input2;\n  if (isCondition && bitwiseXOR <= input4) {\n    bitwiseXOR = bitwiseXOR + carryBit2;\n    carryBit1 = input3;\n    result2 = result1;\n    input3 = input1;\n    result1 = input2;\n  }\n  if (0x36 < carryBit2) {\n    return CONCAT44(result2,carryBit1);\n  }\n  input1Modified = result2 & 0xfffff | 0x100000;\n  if ((result2 & 0x80000000) != 0) {\n    isCondition = carryBit1 != 0;\n    carryBit1 = -carryBit1;\n    input1Modified = -input1Modified - (uint)isCondition;\n  }\n  result2 = result1 & 0xfffff | 0x100000;\n  if ((result1 & 0x80000000) != 0) {\n    isCondition = input3 != 0;\n    input3 = -input3;\n    result2 = -result2 - (uint)isCondition;\n  }\n  if (bitwiseXOR == carryBit2) {\n    result2 = result2 ^ 0x100000;\n    if (bitwiseXOR == 0) {\n      input1Modified = input1Modified ^ 0x100000;\n      bitwiseXOR = 1;\n    }\n    else {\n      carryBit2 = carryBit2 - 1;\n    }\n  }\n  result1 = -carryBit2 + 0x20;\n  if ((int)carryBit2 < 0x21) {\n    shiftedInput1 = input3 << (result1 & 0xff);\n    input3 = input3 >> (carryBit2 & 0xff);\n    carry = carryBit1 + input3;\n    input2Modified = result2 << (result1 & 0xff);\n    result1 = carry + input2Modified;\n    input1Modified = input1Modified + CARRY4(carryBit1,input3) + ((int)result2 >> (carryBit2 & 0xff)) +\n            (uint)CARRY4(carry,input2Modified);\n  }\n  else {\n    shiftedInput1 = result2 << (-carryBit2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      shiftedInput1 = shiftedInput1 | 2;\n    }\n    result2 = (int)result2 >> (carryBit2 - 0x20 & 0xff);\n    result1 = carryBit1 + result2;\n    input1Modified = input1Modified + ((int)result2 >> 0x1f) + (uint)CARRY4(carryBit1,result2);\n  }\n  input2 = input1Modified & 0x80000000;\n  carryBit2 = input1Modified;\n  if ((int)input1Modified < 0) {\n    isCondition = shiftedInput1 == 0;\n    shiftedInput1 = -shiftedInput1;\n    carryBit2 = -result1;\n    result1 = -(uint)!isCondition - result1;\n    carryBit2 = -(uint)(isCondition <= carryBit2) - input1Modified;\n  }\n  if (0xfffff < carryBit2) {\n    carryBit1 = bitwiseXOR - 1;\n    if (0x1fffff < carryBit2) {\n      carryBit1 = carryBit2 & 1;\n      carryBit2 = carryBit2 >> 1;\n      bitResult = (byte)result1;\n      result1 = (uint)(carryBit1 != 0) << 0x1f | result1 >> 1;\n      shiftedInput1 = (uint)(bitResult & 1) << 0x1f | shiftedInput1 >> 1;\n      carryBit1 = bitwiseXOR;\n      if (0xffbfffff < bitwiseXOR * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    isCondition = 0x7fffffff < shiftedInput1;\n    if (shiftedInput1 == 0x80000000) {\n      isCondition = (result1 & 1) != 0;\n    }\n    return CONCAT44(carryBit2 + carryBit1 * 0x100000 + (uint)CARRY4(result1,(uint)isCondition) | input2,\n                    result1 + isCondition);\n  }\n  isCarry = (shiftedInput1 & 0x80000000) != 0;\n  shiftedInput1 = shiftedInput1 << 1;\n  carryBit1 = result1 * 2;\n  isCondition = CARRY4(result1,result1);\n  result1 = result1 * 2 + (uint)isCarry;\n  carryBit2 = carryBit2 * 2 + (uint)(isCondition || CARRY4(carryBit1,(uint)isCarry));\n  carryBit1 = bitwiseXOR - 2;\n  if (bitwiseXOR - 1 != 0 && 0xfffff < carryBit2) goto LAB_080083e0;\n  result2 = result1;\n  bitwiseXOR = carryBit2;\n  if (carryBit2 == 0) {\n    result2 = 0;\n    bitwiseXOR = result1;\n  }\n  bitIndex2 = LZCOUNT(bitwiseXOR);\n  if (carryBit2 == 0) {\n    bitIndex2 = bitIndex2 + 0x20;\n  }\n  carryBit2 = bitIndex2 - 0xb;\n  tempBool = SBORROW4(carryBit2,0x20);\n  result1 = bitIndex2 - 0x2b;\n  isCondition = (int)result1 < 0;\n  isCarry = result1 == 0;\n  if ((int)carryBit2 < 0x20) {\n    tempBool = SCARRY4(result1,0xc);\n    bitIndex2 = bitIndex2 + -0x1f;\n    isCondition = bitIndex2 < 0;\n    isCarry = bitIndex2 == 0;\n    result1 = carryBit2;\n    if (!isCarry && isCondition == tempBool) {\n      result2 = bitwiseXOR << (carryBit2 & 0xff);\n      bitwiseXOR = bitwiseXOR >> (0xcU - bitIndex2 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (isCarry || isCondition != tempBool) {\n    shiftedInput1 = 0x20 - result1;\n  }\n  bitwiseXOR = bitwiseXOR << (result1 & 0xff);\n  if (isCarry || isCondition != tempBool) {\n    bitwiseXOR = bitwiseXOR | result2 >> (shiftedInput1 & 0xff);\n  }\n  if (isCarry || isCondition != tempBool) {\n    result2 = result2 << (result1 & 0xff);\n  }\nLAB_08008458:\n  if ((int)carryBit2 <= (int)carryBit1) {\n    return CONCAT44(bitwiseXOR + (carryBit1 - carryBit2) * 0x100000 | input2,result2);\n  }\n  result1 = ~(carryBit1 - carryBit2);\n  if ((int)result1 < 0x1f) {\n    bitIndex2 = result1 - 0x13;\n    if (bitIndex2 != 0 && bitIndex2 < 0 == SCARRY4(result1 - 0x1f,0xc)) {\n      return CONCAT44(input1Modified,result2 >> (0x20 - (0xcU - bitIndex2) & 0xff) | bitwiseXOR << (0xcU - bitIndex2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result1 = result1 + 1;\n    return CONCAT44(input2 | bitwiseXOR >> (result1 & 0xff),\n                    result2 >> (result1 & 0xff) | bitwiseXOR << (0x20 - result1 & 0xff));\n  }\n  return CONCAT44(input1Modified,bitwiseXOR >> (result1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080082d0": "reverse_bits_080082d0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "bitIndex1",
                "bVar2": "bitResult",
                "uVar3": "carry",
                "uVar4": "input1Modified",
                "uVar5": "input2Modified",
                "uVar6": "result1",
                "uVar7": "result2",
                "iVar8": "bitIndex2",
                "uVar9": "bitwiseXOR",
                "uVar10": "carryBit1",
                "uVar11": "carryBit2",
                "uVar12": "shiftedInput1",
                "bVar13": "isCarry",
                "bVar14": "isCondition",
                "bVar15": "tempBool"
            },
            "calling": [
                "sin",
                "__ieee754_rem_pio2",
                "__ieee754_atan2",
                "atan",
                "report_realtime_status",
                "__kernel_rem_pio2",
                "__kernel_sin",
                "plan_buffer_line",
                "__ieee754_sqrt",
                "mc_arc",
                "__ieee754_hypot",
                "cos",
                "__kernel_cos"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080082d4": {
            "entrypoint": "0x080082d4",
            "current_name": "calculate_sum_080082d4",
            "code": "\nulonglong calculate_sum_080082d4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp1;\n  byte temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp7 = input2 << 1;\n  temp9 = input4 << 1;\n  flag1 = ((input2 ^ input4) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (temp7 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (temp9 | input3) == 0;\n  }\n  temp6 = (int)temp7 >> 0x15;\n  if (!flag2) {\n    flag2 = temp6 == -1;\n  }\n  temp1 = (int)temp9 >> 0x15;\n  if (!flag2) {\n    flag2 = temp1 == -1;\n  }\n  if (flag2) {\n    if (temp6 == -1 || temp1 == -1) {\n      temp9 = input4;\n      temp7 = input3;\n      if (temp6 == -1) {\n        temp9 = input2;\n        temp7 = input1;\n      }\n      if (temp6 != -1 || temp1 != -1) {\n        input3 = temp7;\n        input4 = temp9;\n      }\n      flag2 = (temp7 | temp9 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = temp9 == input4;\n      }\n      if (!flag2) {\n        temp9 = temp9 | 0x80000;\n      }\n      return CONCAT44(temp9,temp7);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp7 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (temp7 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      temp9 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        temp9 = temp9 | 0x80000000;\n      }\n      return CONCAT44(temp9,input1 << 1);\n    }\n    if (temp7 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp7 = temp7 >> 0x15;\n  temp9 = temp9 >> 0x15;\n  temp10 = temp9 - temp7;\n  flag2 = temp10 != 0;\n  if (temp9 < temp7) {\n    temp10 = -temp10;\n  }\n  temp8 = input1;\n  temp5 = input2;\n  if (flag2 && temp7 <= temp9) {\n    temp7 = temp7 + temp10;\n    temp8 = input3;\n    temp5 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < temp10) {\n    return CONCAT44(temp5,temp8);\n  }\n  temp9 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    flag2 = temp8 != 0;\n    temp8 = -temp8;\n    temp9 = -temp9 - (uint)flag2;\n  }\n  temp5 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)flag2;\n  }\n  if (temp7 == temp10) {\n    temp5 = temp5 ^ 0x100000;\n    if (temp7 == 0) {\n      temp9 = temp9 ^ 0x100000;\n      temp7 = 1;\n    }\n    else {\n      temp10 = temp10 - 1;\n    }\n  }\n  temp12 = -temp10 + 0x20;\n  if ((int)temp10 < 0x21) {\n    temp11 = input3 << (temp12 & 0xff);\n    input3 = input3 >> (temp10 & 0xff);\n    temp3 = temp8 + input3;\n    temp4 = temp5 << (temp12 & 0xff);\n    temp12 = temp3 + temp4;\n    temp9 = temp9 + CARRY4(temp8,input3) + ((int)temp5 >> (temp10 & 0xff)) +\n            (uint)CARRY4(temp3,temp4);\n  }\n  else {\n    temp11 = temp5 << (-temp10 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp11 = temp11 | 2;\n    }\n    temp5 = (int)temp5 >> (temp10 - 0x20 & 0xff);\n    temp12 = temp8 + temp5;\n    temp9 = temp9 + ((int)temp5 >> 0x1f) + (uint)CARRY4(temp8,temp5);\n  }\n  input2 = temp9 & 0x80000000;\n  temp10 = temp9;\n  if ((int)temp9 < 0) {\n    flag2 = temp11 == 0;\n    temp11 = -temp11;\n    temp10 = -temp12;\n    temp12 = -(uint)!flag2 - temp12;\n    temp10 = -(uint)(flag2 <= temp10) - temp9;\n  }\n  if (0xfffff < temp10) {\n    temp8 = temp7 - 1;\n    if (0x1fffff < temp10) {\n      temp9 = temp10 & 1;\n      temp10 = temp10 >> 1;\n      temp2 = (byte)temp12;\n      temp12 = (uint)(temp9 != 0) << 0x1f | temp12 >> 1;\n      temp11 = (uint)(temp2 & 1) << 0x1f | temp11 >> 1;\n      temp8 = temp7;\n      if (0xffbfffff < temp7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    flag2 = 0x7fffffff < temp11;\n    if (temp11 == 0x80000000) {\n      flag2 = (temp12 & 1) != 0;\n    }\n    return CONCAT44(temp10 + temp8 * 0x100000 + (uint)CARRY4(temp12,(uint)flag2) | input2,\n                    temp12 + flag2);\n  }\n  flag1 = (temp11 & 0x80000000) != 0;\n  temp11 = temp11 << 1;\n  temp8 = temp12 * 2;\n  flag2 = CARRY4(temp12,temp12);\n  temp12 = temp12 * 2 + (uint)flag1;\n  temp10 = temp10 * 2 + (uint)(flag2 || CARRY4(temp8,(uint)flag1));\n  temp8 = temp7 - 2;\n  if (temp7 - 1 != 0 && 0xfffff < temp10) goto LAB_080083e0;\n  temp5 = temp12;\n  temp7 = temp10;\n  if (temp10 == 0) {\n    temp5 = 0;\n    temp7 = temp12;\n  }\n  temp6 = LZCOUNT(temp7);\n  if (temp10 == 0) {\n    temp6 = temp6 + 0x20;\n  }\n  temp12 = temp6 - 0xb;\n  flag3 = SBORROW4(temp12,0x20);\n  temp10 = temp6 - 0x2b;\n  flag2 = (int)temp10 < 0;\n  flag1 = temp10 == 0;\n  if ((int)temp12 < 0x20) {\n    flag3 = SCARRY4(temp10,0xc);\n    temp6 = temp6 + -0x1f;\n    flag2 = temp6 < 0;\n    flag1 = temp6 == 0;\n    temp10 = temp12;\n    if (!flag1 && flag2 == flag3) {\n      temp5 = temp7 << (temp12 & 0xff);\n      temp7 = temp7 >> (0xcU - temp6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp11 = 0x20 - temp10;\n  }\n  temp7 = temp7 << (temp10 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp7 = temp7 | temp5 >> (temp11 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp5 = temp5 << (temp10 & 0xff);\n  }\nLAB_08008458:\n  if ((int)temp12 <= (int)temp8) {\n    return CONCAT44(temp7 + (temp8 - temp12) * 0x100000 | input2,temp5);\n  }\n  temp10 = ~(temp8 - temp12);\n  if ((int)temp10 < 0x1f) {\n    temp6 = temp10 - 0x13;\n    if (temp6 != 0 && temp6 < 0 == SCARRY4(temp10 - 0x1f,0xc)) {\n      return CONCAT44(temp9,temp5 >> (0x20 - (0xcU - temp6) & 0xff) | temp7 << (0xcU - temp6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp10 = temp10 + 1;\n    return CONCAT44(input2 | temp7 >> (temp10 & 0xff),\n                    temp5 >> (temp10 & 0xff) | temp7 << (0x20 - temp10 & 0xff));\n  }\n  return CONCAT44(temp9,temp7 >> (temp10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080082d4": "calculate_sum_080082d4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "bVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "iVar6": "temp6",
                "uVar7": "temp7",
                "uVar8": "temp8",
                "uVar9": "temp9",
                "uVar10": "temp10",
                "uVar11": "temp11",
                "uVar12": "temp12",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "trunc",
                "__ieee754_atan2",
                "atan",
                "__aeabi_drsub",
                "__kernel_rem_pio2",
                "round",
                "__kernel_sin",
                "scalbn",
                "ceil",
                "__ieee754_sqrt",
                "mc_arc",
                "__ieee754_hypot",
                "__kernel_cos",
                "floor"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800854c": {
            "entrypoint": "0x0800854c",
            "current_name": "shift_and_concatenate_0800854c",
            "code": "\nulonglong shiftAndConcatenate_0800854c(uint input)\n\n{\n  uint shiftedValue;\n  uint shiftAmount;\n  int bitCount;\n  uint shiftLimit;\n  uint remainingBits;\n  bool isNegative;\n  bool isEqual;\n  bool isBorrow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  shiftedValue = 0;\n  bitCount = LZCOUNT(input);\n  shiftLimit = bitCount + 0x15;\n  isBorrow = SBORROW4(shiftLimit,0x20);\n  shiftAmount = bitCount - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isEqual = shiftAmount == 0;\n  if (shiftLimit < 0x20) {\n    isBorrow = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isEqual = bitCount + 1 == 0;\n    shiftAmount = shiftLimit;\n    if (!isEqual && isBorrow == false) {\n      shiftedValue = input << shiftLimit;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (isEqual || isNegative != isBorrow) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isEqual || isNegative != isBorrow) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isEqual || isNegative != isBorrow) {\n    shiftedValue = 0 << (shiftAmount & 0xff);\n  }\nLAB_08008458:\n  if (shiftLimit < 0x433) {\n    return CONCAT44(input + (0x432 - shiftLimit) * 0x100000,shiftedValue);\n  }\n  shiftAmount = ~(0x432 - shiftLimit);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  bitCount = shiftAmount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(input >> (shiftAmount & 0xff),\n                    shiftedValue >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(shiftedValue >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800854c": "shift_and_concatenate_0800854c",
                "param_1": "input",
                "uVar1": "shiftedValue",
                "uVar2": "shiftAmount",
                "iVar3": "bitCount",
                "uVar4": "shiftLimit",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isEqual",
                "bVar7": "isBorrow"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800856c": {
            "entrypoint": "0x0800856c",
            "current_name": "extract_bits_0800856c",
            "code": "\nulonglong extractBits_0800856c(uint number)\n\n{\n  uint result;\n  uint absNumber;\n  uint shift;\n  int leadingZeros;\n  uint shifted;\n  uint sign;\n  uint mask;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (number == 0) {\n    return 0;\n  }\n  sign = number & 0x80000000;\n  absNumber = number;\n  if ((int)sign < 0) {\n    absNumber = -number;\n  }\n  result = 0;\n  leadingZeros = LZCOUNT(absNumber);\n  shifted = leadingZeros + 0x15;\n  isCarry = SBORROW4(shifted,0x20);\n  shift = leadingZeros - 0xb;\n  isNegative = (int)shift < 0;\n  isZero = shift == 0;\n  if (shifted < 0x20) {\n    isCarry = SCARRY4(shift,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shift = shifted;\n    if (!isZero && isCarry == false) {\n      result = absNumber << shifted;\n      absNumber = absNumber >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    mask = 0x20 - shift;\n  }\n  absNumber = absNumber << (shift & 0xff);\n  if (isZero || isNegative != isCarry) {\n    absNumber = absNumber | 0U >> (mask & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    result = 0 << (shift & 0xff);\n  }\nLAB_08008458:\n  if (shifted < 0x433) {\n    return CONCAT44(absNumber + (0x432 - shifted) * 0x100000 | sign,result);\n  }\n  shift = ~(0x432 - shifted);\n  if (0x1e < (int)shift) {\n    return CONCAT44(number,absNumber >> (shift - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shift - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shift - 0x1f,0xc)) {\n    shift = shift + 1;\n    return CONCAT44(sign | absNumber >> (shift & 0xff),\n                    result >> (shift & 0xff) | absNumber << (0x20 - shift & 0xff));\n  }\n  return CONCAT44(number,result >> (0x20 - (0xcU - leadingZeros) & 0xff) | absNumber << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800856c": "extract_bits_0800856c",
                "param_1": "number",
                "uVar1": "result",
                "uVar2": "absNumber",
                "uVar3": "shift",
                "iVar4": "leadingZeros",
                "uVar5": "shifted",
                "uVar6": "sign",
                "in_r12": "mask",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "isCarry"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "calculate_trapezoid_for_block",
                "__kernel_rem_pio2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008590": {
            "entrypoint": "0x08008590",
            "current_name": "process_data_08008590",
            "code": "\nulonglong processData_08008590(uint input,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint flag;\n  uint temp;\n  uint result;\n  uint shiftedInput;\n  uint temp2;\n  int bitCount;\n  uint shiftAmount;\n  uint temp3;\n  bool isCountNegative;\n  bool isInputZero;\n  bool isShiftNegative;\n  \n  temp2 = input << 1;\n  isInputZero = temp2 == 0;\n  flag = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftedInput = (uint)((int)temp2 >> 3) >> 1;\n  result = flag | shiftedInput;\n  input = input << 0x1d;\n  if (!isInputZero) {\n    param4 = temp2 & 0xff000000;\n    isInputZero = param4 == 0;\n  }\n  if (!isInputZero) {\n    isInputZero = param4 == 0xff000000;\n  }\n  if (!isInputZero) {\n    return CONCAT44(result,input) ^ 0x3800000000000000;\n  }\n  if ((temp2 & 0xffffff) == 0) {\n    return CONCAT44(result,input);\n  }\n  if (param4 == 0xff000000) {\n    return CONCAT44(result,input) | 0x8000000000000;\n  }\n  temp = input;\n  temp2 = shiftedInput;\n  if (shiftedInput == 0) {\n    temp = 0;\n    temp2 = input;\n  }\n  bitCount = LZCOUNT(temp2);\n  if (shiftedInput == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  shiftAmount = bitCount - 0xb;\n  isShiftNegative = SBORROW4(shiftAmount,0x20);\n  shiftedInput = bitCount - 0x2b;\n  isInputZero = (int)shiftedInput < 0;\n  isCountNegative = shiftedInput == 0;\n  if ((int)shiftAmount < 0x20) {\n    isShiftNegative = SCARRY4(shiftedInput,0xc);\n    bitCount = bitCount + -0x1f;\n    isInputZero = bitCount < 0;\n    isCountNegative = bitCount == 0;\n    shiftedInput = shiftAmount;\n    if (!isCountNegative && isInputZero == isShiftNegative) {\n      temp = temp2 << (shiftAmount & 0xff);\n      temp2 = temp2 >> (0xcU - bitCount & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (isCountNegative || isInputZero != isShiftNegative) {\n    temp3 = 0x20 - shiftedInput;\n  }\n  temp2 = temp2 << (shiftedInput & 0xff);\n  if (isCountNegative || isInputZero != isShiftNegative) {\n    temp2 = temp2 | temp >> (temp3 & 0xff);\n  }\n  if (isCountNegative || isInputZero != isShiftNegative) {\n    temp = temp << (shiftedInput & 0xff);\n  }\nLAB_08008458:\n  if ((int)shiftAmount < 0x381) {\n    return CONCAT44(temp2 + (0x380 - shiftAmount) * 0x100000 | flag,temp);\n  }\n  shiftedInput = ~(0x380 - shiftAmount);\n  if (0x1e < (int)shiftedInput) {\n    return CONCAT44(result,temp2 >> (shiftedInput - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bitCount = shiftedInput - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftedInput - 0x1f,0xc)) {\n    shiftedInput = shiftedInput + 1;\n    return CONCAT44(flag | temp2 >> (shiftedInput & 0xff),\n                    temp >> (shiftedInput & 0xff) | temp2 << (0x20 - shiftedInput & 0xff));\n  }\n  return CONCAT44(result,temp >> (0x20 - (0xcU - bitCount) & 0xff) | temp2 << (0xcU - bitCount & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008590": "process_data_08008590",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "flag",
                "uVar2": "temp",
                "uVar3": "result",
                "uVar4": "shiftedInput",
                "uVar5": "temp2",
                "uVar7": "shiftAmount",
                "iVar6": "bitCount",
                "bVar8": "isCountNegative",
                "bVar9": "isInputZero",
                "bVar10": "isShiftNegative",
                "in_r12": "temp3"
            },
            "calling": [
                "to_millimeters",
                "calculate_trapezoid_for_block",
                "report_realtime_status",
                "homing_cycle",
                "max_allowable_speed",
                "plan_buffer_line",
                "gc_execute_line",
                "protocol_execute_line",
                "read_float",
                "mc_dwell",
                "mc_arc",
                "report_gcode_modes",
                "settings_store_global_setting",
                "report_gcode_parameters"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085d4": {
            "entrypoint": "0x080085d4",
            "current_name": "compute_concatenation_080085d4",
            "code": "\nulonglong computeConcatenation_080085d4(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint input1Copy;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  uint temp6;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  temp5 = 0x432;\n  temp6 = input2 >> 0x16;\n  if (temp6 != 0) {\n    temp5 = 3;\n    if (input2 >> 0x19 != 0) {\n      temp5 = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      temp5 = temp5 + 3;\n    }\n    temp2 = temp5 - ((int)input2 >> 0x1f);\n    temp6 = input1 << (0x20 - temp2 & 0xff);\n    input1 = input1 >> (temp2 & 0xff) | input2 << (0x20 - temp2 & 0xff);\n    input2 = input2 >> (temp2 & 0xff);\n    temp5 = temp2 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp2 = input2 & 1;\n      input2 = input2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(temp2 != 0) << 0x1f | input1 >> 1;\n      temp6 = (uint)(bit1 & 1) << 0x1f | temp6 >> 1;\n      temp5 = temp5 + 1;\n      if (0xffbfffff < (uint)(temp5 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080083e0:\n    bool2 = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      bool2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + temp5 * 0x100000 + (uint)CARRY4(input1,(uint)bool2),input1 + bool2\n                   );\n  }\n  bool1 = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  temp2 = input1 * 2;\n  bool2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)bool1;\n  input2 = input2 * 2 + (uint)(bool2 || CARRY4(temp2,(uint)bool1));\n  bool2 = temp5 != 0;\n  temp5 = temp5 + -1;\n  if (bool2 && 0xfffff < input2) goto LAB_080083e0;\n  input1Copy = input1;\n  temp2 = input2;\n  if (input2 == 0) {\n    input1Copy = 0;\n    temp2 = input1;\n  }\n  temp3 = LZCOUNT(temp2);\n  if (input2 == 0) {\n    temp3 = temp3 + 0x20;\n  }\n  temp4 = temp3 - 0xb;\n  bool3 = SBORROW4(temp4,0x20);\n  temp1 = temp3 - 0x2b;\n  bool2 = (int)temp1 < 0;\n  bool1 = temp1 == 0;\n  if ((int)temp4 < 0x20) {\n    bool3 = SCARRY4(temp1,0xc);\n    temp3 = temp3 + -0x1f;\n    bool2 = temp3 < 0;\n    bool1 = temp3 == 0;\n    temp1 = temp4;\n    if (!bool1 && bool2 == bool3) {\n      input1Copy = temp2 << (temp4 & 0xff);\n      temp2 = temp2 >> (0xcU - temp3 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bool1 || bool2 != bool3) {\n    temp6 = 0x20 - temp1;\n  }\n  temp2 = temp2 << (temp1 & 0xff);\n  if (bool1 || bool2 != bool3) {\n    temp2 = temp2 | input1Copy >> (temp6 & 0xff);\n  }\n  if (bool1 || bool2 != bool3) {\n    input1Copy = input1Copy << (temp1 & 0xff);\n  }\nLAB_08008458:\n  if ((int)temp4 <= temp5) {\n    return CONCAT44(temp2 + (temp5 - temp4) * 0x100000,input1Copy);\n  }\n  temp6 = ~(temp5 - temp4);\n  if ((int)temp6 < 0x1f) {\n    temp5 = temp6 - 0x13;\n    if (temp5 != 0 && temp5 < 0 == SCARRY4(temp6 - 0x1f,0xc)) {\n      return (ulonglong)(input1Copy >> (0x20 - (0xcU - temp5) & 0xff) | temp2 << (0xcU - temp5 & 0xff));\n    }\n    temp6 = temp6 + 1;\n    return CONCAT44(temp2 >> (temp6 & 0xff),input1Copy >> (temp6 & 0xff) | temp2 << (0x20 - temp6 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp2 >> (temp6 - 0x1f & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080085d4": "compute_concatenation_080085d4",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "input1Copy",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "iVar7": "temp5",
                "uVar8": "temp6",
                "bVar9": "bool1",
                "bVar10": "bool2",
                "bVar11": "bool3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085e4": {
            "entrypoint": "0x080085e4",
            "current_name": "calculate_unsigned_division_080085e4",
            "code": "\nulonglong calculateUnsignedDivision_080085e4(uint dividend,uint divisor)\n\n{\n  byte bitResult;\n  uint tempDividend;\n  uint tempDivisor;\n  uint tempValue;\n  int shiftCount;\n  uint remainder;\n  int bitCount;\n  uint signBit;\n  uint signDividend;\n  bool isCarry;\n  bool isOverflow;\n  bool isSubtraction;\n  \n  if ((dividend | divisor) == 0) {\n    return CONCAT44(divisor,dividend);\n  }\n  signBit = divisor & 0x80000000;\n  tempDivisor = divisor;\n  if ((int)signBit < 0) {\n    isOverflow = dividend != 0;\n    dividend = -dividend;\n    tempDivisor = -divisor - (uint)isOverflow;\n  }\n  bitCount = 0x432;\n  signDividend = tempDivisor >> 0x16;\n  if (signDividend != 0) {\n    bitCount = 3;\n    if (tempDivisor >> 0x19 != 0) {\n      bitCount = 6;\n    }\n    if (tempDivisor >> 0x1c != 0) {\n      bitCount = bitCount + 3;\n    }\n    tempValue = bitCount - ((int)tempDivisor >> 0x1f);\n    signDividend = dividend << (0x20 - tempValue & 0xff);\n    dividend = dividend >> (tempValue & 0xff) | tempDivisor << (0x20 - tempValue & 0xff);\n    tempDivisor = tempDivisor >> (tempValue & 0xff);\n    bitCount = tempValue + 0x432;\n  }\n  if (0xfffff < tempDivisor) {\n    if (0x1fffff < tempDivisor) {\n      tempValue = tempDivisor & 1;\n      tempDivisor = tempDivisor >> 1;\n      bitResult = (byte)dividend;\n      dividend = (uint)(tempValue != 0) << 0x1f | dividend >> 1;\n      signDividend = (uint)(bitResult & 1) << 0x1f | signDividend >> 1;\n      bitCount = bitCount + 1;\n      if (0xffbfffff < (uint)(bitCount * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080083e0:\n    isOverflow = 0x7fffffff < signDividend;\n    if (signDividend == 0x80000000) {\n      isOverflow = (dividend & 1) != 0;\n    }\n    return CONCAT44(tempDivisor + bitCount * 0x100000 + (uint)CARRY4(dividend,(uint)isOverflow) | signBit,\n                    dividend + isOverflow);\n  }\n  isCarry = (signDividend & 0x80000000) != 0;\n  signDividend = signDividend << 1;\n  tempValue = dividend * 2;\n  isOverflow = CARRY4(dividend,dividend);\n  dividend = dividend * 2 + (uint)isCarry;\n  tempDivisor = tempDivisor * 2 + (uint)(isOverflow || CARRY4(tempValue,(uint)isCarry));\n  isOverflow = bitCount != 0;\n  bitCount = bitCount + -1;\n  if (isOverflow && 0xfffff < tempDivisor) goto LAB_080083e0;\n  tempDividend = dividend;\n  tempValue = tempDivisor;\n  if (tempDivisor == 0) {\n    tempDividend = 0;\n    tempValue = dividend;\n  }\n  shiftCount = LZCOUNT(tempValue);\n  if (tempDivisor == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  remainder = shiftCount - 0xb;\n  isSubtraction = SBORROW4(remainder,0x20);\n  tempDivisor = shiftCount - 0x2b;\n  isOverflow = (int)tempDivisor < 0;\n  isCarry = tempDivisor == 0;\n  if ((int)remainder < 0x20) {\n    isSubtraction = SCARRY4(tempDivisor,0xc);\n    shiftCount = shiftCount + -0x1f;\n    isOverflow = shiftCount < 0;\n    isCarry = shiftCount == 0;\n    tempDivisor = remainder;\n    if (!isCarry && isOverflow == isSubtraction) {\n      tempDividend = tempValue << (remainder & 0xff);\n      tempValue = tempValue >> (0xcU - shiftCount & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (isCarry || isOverflow != isSubtraction) {\n    signDividend = 0x20 - tempDivisor;\n  }\n  tempValue = tempValue << (tempDivisor & 0xff);\n  if (isCarry || isOverflow != isSubtraction) {\n    tempValue = tempValue | tempDividend >> (signDividend & 0xff);\n  }\n  if (isCarry || isOverflow != isSubtraction) {\n    tempDividend = tempDividend << (tempDivisor & 0xff);\n  }\nLAB_08008458:\n  if ((int)remainder <= bitCount) {\n    return CONCAT44(tempValue + (bitCount - remainder) * 0x100000 | signBit,tempDividend);\n  }\n  tempDivisor = ~(bitCount - remainder);\n  if ((int)tempDivisor < 0x1f) {\n    bitCount = tempDivisor - 0x13;\n    if (bitCount != 0 && bitCount < 0 == SCARRY4(tempDivisor - 0x1f,0xc)) {\n      return CONCAT44(divisor,tempDividend >> (0x20 - (0xcU - bitCount) & 0xff) |\n                              tempValue << (0xcU - bitCount & 0xff)) & 0x80000000ffffffff;\n    }\n    tempDivisor = tempDivisor + 1;\n    return CONCAT44(signBit | tempValue >> (tempDivisor & 0xff),\n                    tempDividend >> (tempDivisor & 0xff) | tempValue << (0x20 - tempDivisor & 0xff));\n  }\n  return CONCAT44(divisor,tempValue >> (tempDivisor - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080085e4": "calculate_unsigned_division_080085e4",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "bitResult",
                "uVar2": "tempDividend",
                "uVar3": "tempDivisor",
                "uVar4": "tempValue",
                "iVar5": "shiftCount",
                "uVar6": "remainder",
                "iVar7": "bitCount",
                "uVar8": "signBit",
                "uVar9": "signDividend",
                "bVar10": "isCarry",
                "bVar11": "isOverflow",
                "bVar12": "isSubtraction"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008640": {
            "entrypoint": "0x08008640",
            "current_name": "calculate_product_08008640",
            "code": "\nulonglong calculate_product_08008640(undefined4 x,uint y,uint result,uint result_upper)\n\n{\n  ulonglong product_upper;\n  longlong temp;\n  uint combined_exponent_without_sign;\n  uint uVar4_shifted;\n  int sum_uVar4_uVar5;\n  uint uVar6_updated;\n  uint z_upper;\n  uint uVar7_overflow;\n  uint result_lower;\n  bool is_lower_overflow;\n  bool is_upper_carry_set;\n  bool is_upper_overflow;\n  ulonglong product;\n  \n  product = CONCAT44(y,x);\n  uVar7_overflow = 0x7ff;\n  uVar4_shifted = y >> 0x14 & 0x7ff;\n  is_lower_overflow = uVar4_shifted == 0;\n  if (!is_lower_overflow) {\n    z_upper = result_upper >> 0x14 & 0x7ff;\n    is_lower_overflow = z_upper == 0;\n  }\n  if (!is_lower_overflow) {\n    is_lower_overflow = uVar4_shifted == 0x7ff;\n  }\n  if (!is_lower_overflow) {\n    is_lower_overflow = z_upper == 0x7ff;\n  }\n  if (is_lower_overflow) {\n    product = calculate_bitwise_xor_0800881c();\n  }\n  combined_exponent_without_sign = (uint)(product >> 0x20);\n  sum_uVar4_uVar5 = uVar4_shifted + z_upper;\n  uVar4_shifted = combined_exponent_without_sign ^ result_upper;\n  combined_exponent_without_sign = combined_exponent_without_sign & ~(uVar7_overflow << 0x15);\n  result_upper = result_upper & ~(uVar7_overflow << 0x15);\n  is_lower_overflow = ((uint)product | combined_exponent_without_sign << 0xc) == 0;\n  if (!is_lower_overflow) {\n    is_lower_overflow = (result | result_upper << 0xc) == 0;\n  }\n  combined_exponent_without_sign = combined_exponent_without_sign | 0x100000;\n  result_upper = result_upper | 0x100000;\n  if (is_lower_overflow) {\n    result = (uint)product | result;\n    result_upper = (uVar4_shifted & 0x80000000 | combined_exponent_without_sign) ^ result_upper;\n    uVar4_shifted = uVar7_overflow >> 1;\n    is_upper_overflow = SBORROW4(sum_uVar4_uVar5,uVar4_shifted);\n    uVar6_updated = sum_uVar4_uVar5 - uVar4_shifted;\n    is_lower_overflow = uVar6_updated == 0;\n    combined_exponent_without_sign = uVar6_updated;\n    if (!is_lower_overflow && (int)uVar4_shifted <= sum_uVar4_uVar5) {\n      is_upper_overflow = SBORROW4(uVar7_overflow,uVar6_updated);\n      combined_exponent_without_sign = uVar7_overflow - uVar6_updated;\n      is_lower_overflow = uVar7_overflow == uVar6_updated;\n    }\n    if (!is_lower_overflow && (int)combined_exponent_without_sign < 0 == is_upper_overflow) {\n      result_upper = result_upper | uVar6_updated * 0x100000;\n    }\n    if (!is_lower_overflow && (int)combined_exponent_without_sign < 0 == is_upper_overflow) {\n      return CONCAT44(result_upper,result);\n    }\n    result_upper = result_upper | 0x100000;\n    uVar7_overflow = 0;\n    is_upper_overflow = SBORROW4(uVar6_updated,1);\n    uVar6_updated = uVar6_updated - 1;\n    is_lower_overflow = uVar6_updated == 0;\n    uVar4_shifted = uVar6_updated;\n  }\n  else {\n    product_upper = (product & 0xffffffff) * (ulonglong)result;\n    product = (product & 0xffffffff) * (ulonglong)result_upper +\n             (ulonglong)combined_exponent_without_sign * (ulonglong)result + (product_upper >> 0x20);\n    result_lower = (uint)product;\n    temp = (ulonglong)combined_exponent_without_sign * (ulonglong)result_upper + (product >> 0x20);\n    uVar7_overflow = (uint)temp;\n    combined_exponent_without_sign = (uint)((ulonglong)temp >> 0x20);\n    if ((int)product_upper != 0) {\n      result_lower = result_lower | 1;\n    }\n    uVar6_updated = (sum_uVar4_uVar5 + -0x3ff) - (uint)(combined_exponent_without_sign < 0x200);\n    if (combined_exponent_without_sign < 0x200) {\n      is_lower_overflow = (result_lower & 0x80000000) != 0;\n      result_lower = result_lower << 1;\n      temp = CONCAT44(combined_exponent_without_sign * 2 + (uint)(CARRY4(uVar7_overflow,uVar7_overflow) || CARRY4(uVar7_overflow * 2,(uint)is_lower_overflow)),\n                       uVar7_overflow * 2 + (uint)is_lower_overflow);\n    }\n    result_upper = uVar4_shifted & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    result = (uint)temp << 0xb | result_lower >> 0x15;\n    uVar7_overflow = result_lower * 0x800;\n    is_upper_carry_set = 0xfc < uVar6_updated;\n    is_upper_overflow = SBORROW4(uVar6_updated,0xfd);\n    combined_exponent_without_sign = uVar6_updated - 0xfd;\n    is_lower_overflow = combined_exponent_without_sign == 0;\n    uVar4_shifted = combined_exponent_without_sign;\n    if (is_upper_carry_set && !is_lower_overflow) {\n      is_upper_carry_set = 0x6ff < combined_exponent_without_sign;\n      is_upper_overflow = SBORROW4(combined_exponent_without_sign,0x700);\n      uVar4_shifted = uVar6_updated - 0x7fd;\n      is_lower_overflow = combined_exponent_without_sign == 0x700;\n    }\n    if (!is_upper_carry_set || is_lower_overflow) {\n      is_lower_overflow = 0x7fffffff < uVar7_overflow;\n      if (uVar7_overflow == 0x80000000) {\n        is_lower_overflow = (result_lower >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(result_upper + uVar6_updated * 0x100000 + (uint)CARRY4(result,(uint)is_lower_overflow),result + is_lower_overflow\n                     );\n    }\n  }\n  if (!is_lower_overflow && (int)uVar4_shifted < 0 == is_upper_overflow) {\n    return (ulonglong)(result_upper & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_upper_carry_set = SCARRY4(uVar6_updated,0x36);\n  is_lower_overflow = (int)(uVar6_updated + 0x36) < 0;\n  is_upper_overflow = uVar6_updated == 0xffffffca;\n  if (is_upper_overflow || is_lower_overflow != is_upper_carry_set) {\n    result = 0;\n  }\n  if (is_upper_overflow || is_lower_overflow != is_upper_carry_set) {\n    result_upper = result_upper & 0x80000000;\n  }\n  if (is_upper_overflow || is_lower_overflow != is_upper_carry_set) {\n    return CONCAT44(result_upper,result);\n  }\n  uVar4_shifted = -uVar6_updated;\n  combined_exponent_without_sign = uVar4_shifted - 0x20;\n  if (0x1f < (int)uVar4_shifted) {\n    uVar6_updated = result >> (combined_exponent_without_sign & 0xff) | result_upper << (0x20 - combined_exponent_without_sign & 0xff);\n    uVar4_shifted = (result_upper >> (combined_exponent_without_sign & 0xff) & ~((result_upper & 0x80000000) >> (combined_exponent_without_sign & 0xff))) -\n            ((int)uVar6_updated >> 0x1f);\n    if ((uVar7_overflow | result << (0x20 - combined_exponent_without_sign & 0xff) | uVar6_updated << 1) == 0) {\n      uVar4_shifted = uVar4_shifted & ~(uVar6_updated >> 0x1f);\n    }\n    return CONCAT44(result_upper,uVar4_shifted) & 0x80000000ffffffff;\n  }\n  sum_uVar4_uVar5 = uVar4_shifted - 0x14;\n  if (sum_uVar4_uVar5 == 0 || sum_uVar4_uVar5 < 0 != SCARRY4(combined_exponent_without_sign,0xc)) {\n    result_lower = result << (uVar6_updated + 0x20 & 0xff);\n    combined_exponent_without_sign = result >> (uVar4_shifted & 0xff) | result_upper << (uVar6_updated + 0x20 & 0xff);\n    uVar6_updated = combined_exponent_without_sign + -((int)result_lower >> 0x1f);\n    if ((uVar7_overflow | result_lower << 1) == 0) {\n      uVar6_updated = uVar6_updated & ~(result_lower >> 0x1f);\n    }\n    return CONCAT44((result_upper & 0x80000000) +\n                    ((result_upper & 0x7fffffff) >> (uVar4_shifted & 0xff)) +\n                    (uint)CARRY4(combined_exponent_without_sign,-((int)result_lower >> 0x1f)),uVar6_updated);\n  }\n  uVar4_shifted = 0xc - sum_uVar4_uVar5;\n  uVar6_updated = result << (uVar4_shifted & 0xff);\n  uVar4_shifted = result >> (0x20 - uVar4_shifted & 0xff) | result_upper << (uVar4_shifted & 0xff);\n  combined_exponent_without_sign = uVar4_shifted + -((int)uVar6_updated >> 0x1f);\n  if ((uVar7_overflow | uVar6_updated << 1) == 0) {\n    combined_exponent_without_sign = combined_exponent_without_sign & ~(uVar6_updated >> 0x1f);\n  }\n  return CONCAT44((result_upper & 0x80000000) + (uint)CARRY4(uVar4_shifted,-((int)uVar6_updated >> 0x1f)),combined_exponent_without_sign);\n}\n\n",
            "renaming": {
                "FUN_08008640": "calculate_product_08008640",
                "param_1": "x",
                "param_2": "y",
                "param_3": "result",
                "param_4": "result_upper",
                "uVar1": "product_upper",
                "lVar2": "temp",
                "uVar3": "combined_exponent_without_sign",
                "uVar4": "uVar4_shifted",
                "iVar5": "sum_uVar4_uVar5",
                "uVar6": "uVar6_updated",
                "unaff_r5": "z_upper",
                "uVar7": "uVar7_overflow",
                "uVar8": "result_lower",
                "bVar9": "is_lower_overflow",
                "bVar10": "is_upper_carry_set",
                "bVar11": "is_upper_overflow",
                "uVar12": "product"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "to_millimeters",
                "calculate_trapezoid_for_block",
                "atan",
                "report_realtime_status",
                "__kernel_rem_pio2",
                "homing_cycle",
                "__kernel_sin",
                "plan_buffer_line",
                "scalbn",
                "read_float",
                "__ieee754_sqrt",
                "mc_arc",
                "__ieee754_hypot",
                "report_gcode_modes",
                "__kernel_cos",
                "report_gcode_parameters"
            ],
            "called": [
                "FUN_0800881c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800881c": {
            "entrypoint": "0x0800881c",
            "current_name": "calculate_bitwise_xor_0800881c",
            "code": "\nulonglong calculate_bitwise_xor_0800881c(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result_1;\n  uint result_2;\n  uint result_3;\n  uint result_4;\n  uint constant_1;\n  bool is_zero;\n  \n  result_3 = constant_1 & input_4 >> 0x14;\n  if (result_2 != constant_1 && result_3 != constant_1) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (result_2 == 0) {\n      result_4 = input_2 & 0x80000000;\n      do {\n        result_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(result_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | result_4;\n      if (result_3 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      result_3 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(result_3 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  result_4 = input_2;\n  if (((!is_zero) && ((result_2 != constant_1 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((result_3 != constant_1 || (input_1 = input_3, result_4 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(result_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800881c": "calculate_bitwise_xor_0800881c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result_1",
                "unaff_r4": "result_2",
                "uVar2": "result_3",
                "uVar3": "result_4",
                "in_r12": "constant_1",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008894": {
            "entrypoint": "0x08008894",
            "current_name": "calculate_floating_point_08008894",
            "code": "\nulonglong calculateFloatingPoint_08008894(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  uint mask1;\n  uint mask2;\n  uint mask3;\n  uint mask4;\n  uint mask5;\n  uint mask6;\n  uint value2_shifted;\n  int difference;\n  uint result1;\n  uint unaff_r5;\n  uint result2;\n  uint result3;\n  uint result4;\n  uint mask13;\n  bool isZero;\n  bool isEqual;\n  bool overflow;\n  undefined8 calculated_result;\n  \n  calculated_result = CONCAT44(value2,value1);\n  mask13 = 0x7ff;\n  value2_shifted = value2 >> 0x14 & 0x7ff;\n  isZero = value2_shifted == 0;\n  if (!isZero) {\n    unaff_r5 = value4 >> 0x14 & 0x7ff;\n    isZero = unaff_r5 == 0;\n  }\n  if (!isZero) {\n    isZero = value2_shifted == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = unaff_r5 == 0x7ff;\n  }\n  if (isZero) {\n    calculated_result = calculate_double_precision_08008a02();\n  }\n  result1 = (uint)((ulonglong)calculated_result >> 0x20);\n  result3 = (uint)calculated_result;\n  difference = value2_shifted - unaff_r5;\n  if ((value3 | value4 << 0xc) == 0) {\n    value2_shifted = (result1 ^ value4) & 0x80000000 | result1 & 0xfffff;\n    overflow = SCARRY4(difference,mask13 >> 1);\n    result1 = difference + (mask13 >> 1);\n    isZero = (int)result1 < 0;\n    isEqual = result1 == 0;\n    if (!isEqual && isZero == overflow) {\n      overflow = SBORROW4(mask13,result1);\n      isZero = (int)(mask13 - result1) < 0;\n      isEqual = mask13 == result1;\n    }\n    if (!isEqual && isZero == overflow) {\n      value2_shifted = value2_shifted | result1 * 0x100000;\n    }\n    if (!isEqual && isZero == overflow) {\n      return CONCAT44(value2_shifted,result3);\n    }\n    value2_shifted = value2_shifted | 0x100000;\n    mask13 = 0;\n    isEqual = SBORROW4(result1,1);\n    result1 = result1 - 1;\n    isZero = result1 == 0;\n    mask3 = result1;\n  }\n  else {\n    mask3 = (value4 << 0xc) >> 4 | 0x10000000 | value3 >> 0x18;\n    mask13 = value3 << 8;\n    result2 = (result1 << 0xc) >> 4 | 0x10000000 | result3 >> 0x18;\n    result3 = result3 * 0x100;\n    value2_shifted = (result1 ^ value4) & 0x80000000;\n    isZero = mask3 <= result2;\n    if (result2 == mask3) {\n      isZero = mask13 <= result3;\n    }\n    difference = difference + (uint)isZero;\n    result1 = difference + 0x3fd;\n    if (isZero == false) {\n      mask3 = mask3 >> 1;\n      mask13 = (uint)((value3 >> 0x18 & 1) != 0) << 0x1f | mask13 >> 1;\n    }\n    result4 = result3 - mask13;\n    result2 = (result2 - mask3) - (uint)(result3 < mask13);\n    mask4 = mask3 >> 1;\n    mask1 = (uint)((mask3 & 1) != 0) << 0x1f | mask13 >> 1;\n    result3 = 0x100000;\n    mask3 = 0x80000;\n    while( true ) {\n      isZero = mask1 <= result4;\n      if (mask4 < result2 || result2 - mask4 < (uint)isZero) {\n        result4 = result4 - mask1;\n        result3 = result3 | mask3;\n        result2 = (result2 - mask4) - (uint)!isZero;\n      }\n      mask5 = mask4 >> 1;\n      mask1 = (uint)((mask4 & 1) != 0) << 0x1f | mask1 >> 1;\n      isEqual = mask1 <= result4;\n      isZero = result2 - mask5 < (uint)isEqual;\n      mask13 = result2;\n      if (mask5 < result2 || isZero) {\n        result4 = result4 - mask1;\n        mask13 = (result2 - mask5) - (uint)!isEqual;\n      }\n      if (mask5 < result2 || isZero) {\n        result3 = result3 | mask3 >> 1;\n      }\n      result2 = mask4 >> 2;\n      mask2 = (uint)((mask5 & 1) != 0) << 0x1f | mask1 >> 1;\n      isEqual = mask2 <= result4;\n      isZero = mask13 - result2 < (uint)isEqual;\n      mask5 = mask13;\n      if (result2 < mask13 || isZero) {\n        result4 = result4 - mask2;\n        mask5 = (mask13 - result2) - (uint)!isEqual;\n      }\n      if (result2 < mask13 || isZero) {\n        result3 = result3 | mask3 >> 2;\n      }\n      mask6 = mask4 >> 3;\n      mask1 = (uint)((result2 & 1) != 0) << 0x1f | mask2 >> 1;\n      isEqual = mask1 <= result4;\n      isZero = mask5 - mask6 < (uint)isEqual;\n      result2 = mask5;\n      if (mask6 < mask5 || isZero) {\n        result4 = result4 - mask1;\n        result2 = (mask5 - mask6) - (uint)!isEqual;\n      }\n      if (mask6 < mask5 || isZero) {\n        result3 = result3 | mask3 >> 3;\n      }\n      mask13 = result2 | result4;\n      if (mask13 == 0) break;\n      result2 = result2 << 4 | result4 >> 0x1c;\n      result4 = result4 << 4;\n      mask4 = mask4 & 0xfffffff8 | mask1 >> 0x1d;\n      mask1 = (mask2 >> 1) << 3;\n      mask3 = mask3 >> 4;\n      if (mask3 == 0) {\n        mask6 = mask4;\n        if ((value2_shifted & 0x100000) != 0) goto LAB_080089b2;\n        value2_shifted = value2_shifted | result3;\n        result3 = 0;\n        mask3 = 0x80000000;\n      }\n    }\n    if ((value2_shifted & 0x100000) == 0) {\n      value2_shifted = value2_shifted | result3;\n      result3 = 0;\n    }\nLAB_080089b2:\n    overflow = 0xfc < result1;\n    isEqual = SBORROW4(result1,0xfd);\n    mask4 = difference + 0x300;\n    isZero = mask4 == 0;\n    mask3 = mask4;\n    if (overflow && !isZero) {\n      overflow = 0x6ff < mask4;\n      isEqual = SBORROW4(mask4,0x700);\n      mask3 = difference - 0x400;\n      isZero = mask4 == 0x700;\n    }\n    if (!overflow || isZero) {\n      isZero = mask6 <= result2;\n      if (result2 == mask6) {\n        isZero = mask1 <= result4;\n      }\n      if (result2 == mask6 && result4 == mask1) {\n        isZero = (result3 & 1) != 0;\n      }\n      return CONCAT44(value2_shifted + result1 * 0x100000 + (uint)CARRY4(result3,(uint)isZero),result3 + isZero);\n    }\n  }\n  if (!isZero && (int)mask3 < 0 == isEqual) {\n    return (ulonglong)(value2_shifted & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  overflow = SCARRY4(result1,0x36);\n  isZero = (int)(result1 + 0x36) < 0;\n  isEqual = result1 == 0xffffffca;\n  if (isEqual || isZero != overflow) {\n    result3 = 0;\n  }\n  if (isEqual || isZero != overflow) {\n    value2_shifted = value2_shifted & 0x80000000;\n  }\n  if (isEqual || isZero != overflow) {\n    return CONCAT44(value2_shifted,result3);\n  }\n  mask3 = -result1;\n  result2 = mask3 - 0x20;\n  if (0x1f < (int)mask3) {\n    mask3 = result3 >> (result2 & 0xff) | value2_shifted << (0x20 - result2 & 0xff);\n    result1 = (value2_shifted >> (result2 & 0xff) & ~((value2_shifted & 0x80000000) >> (result2 & 0xff))) -\n            ((int)mask3 >> 0x1f);\n    if ((mask13 | result3 << (0x20 - result2 & 0xff) | mask3 << 1) == 0) {\n      result1 = result1 & ~(mask3 >> 0x1f);\n    }\n    return CONCAT44(value2_shifted,result1) & 0x80000000ffffffff;\n  }\n  difference = mask3 - 0x14;\n  if (difference != 0 && difference < 0 == SCARRY4(result2,0xc)) {\n    result1 = 0xc - difference;\n    mask3 = result3 << (result1 & 0xff);\n    result3 = result3 >> (0x20 - result1 & 0xff) | value2_shifted << (result1 & 0xff);\n    result1 = result3 + -((int)mask3 >> 0x1f);\n    if ((mask13 | mask3 << 1) == 0) {\n      result1 = result1 & ~(mask3 >> 0x1f);\n    }\n    return CONCAT44((value2_shifted & 0x80000000) + (uint)CARRY4(result3,-((int)mask3 >> 0x1f)),result1);\n  }\n  result2 = result3 << (result1 + 0x20 & 0xff);\n  result3 = result3 >> (mask3 & 0xff) | value2_shifted << (result1 + 0x20 & 0xff);\n  result1 = result3 + -((int)result2 >> 0x1f);\n  if ((mask13 | result2 << 1) == 0) {\n    result1 = result1 & ~(result2 >> 0x1f);\n  }\n  return CONCAT44((value2_shifted & 0x80000000) +\n                  ((value2_shifted & 0x7fffffff) >> (mask3 & 0xff)) +\n                  (uint)CARRY4(result3,-((int)result2 >> 0x1f)),result1);\n}\n\n",
            "renaming": {
                "FUN_08008894": "calculate_floating_point_08008894",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "mask1",
                "uVar2": "mask2",
                "uVar3": "mask3",
                "uVar4": "mask4",
                "uVar5": "mask5",
                "uVar6": "mask6",
                "uVar7": "value2_shifted",
                "iVar8": "difference",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar14": "isZero",
                "bVar15": "isEqual",
                "bVar16": "overflow",
                "uVar17": "calculated_result"
            },
            "calling": [
                "gc_execute_line",
                "__ieee754_atan2",
                "__ieee754_sqrt",
                "sqrt",
                "atan",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [
                "FUN_08008a02"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a02": {
            "entrypoint": "0x08008a02",
            "current_name": "calculate_double_precision_08008a02",
            "code": "\nulonglong calculate_double_precision_08008a02(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint mask;\n  bool is_zero;\n  \n  temp_3 = mask & input_4 >> 0x14;\n  temp_4 = input_2;\n  if (temp_2 != mask || temp_3 != mask) {\n    if (temp_2 == mask) {\n      if (((input_1 | input_2 << 0xc) == 0) && (input_1 = input_3, temp_4 = input_4, temp_3 != mask)\n         ) {\nLAB_08008874:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (temp_3 == mask) {\n      input_1 = input_3;\n      temp_4 = input_4;\n      if ((input_3 | input_4 << 0xc) == 0) {\nLAB_08008838:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (input_1 | input_2 << 1) == 0;\n      if (!is_zero) {\n        is_zero = (input_3 | input_4 << 1) == 0;\n      }\n      if (!is_zero) {\n        if (temp_2 == 0) {\n          temp_4 = input_2 & 0x80000000;\n          do {\n            temp_1 = input_1 & 0x80000000;\n            input_1 = input_1 << 1;\n            input_2 = input_2 * 2 + (uint)(temp_1 != 0);\n          } while ((input_2 & 0x100000) == 0);\n          input_2 = input_2 | temp_4;\n          if (temp_3 != 0) {\n            return CONCAT44(input_2,input_1);\n          }\n        }\n        do {\n          temp_4 = input_3 & 0x80000000;\n          input_3 = input_3 << 1;\n          input_4 = input_4 * 2 + (uint)(temp_4 != 0);\n        } while ((input_4 & 0x100000) == 0);\n        return CONCAT44(input_2,input_1);\n      }\n      if ((input_1 | input_2 << 1) != 0) goto LAB_08008874;\n      if ((input_3 | input_4 << 1) != 0) goto LAB_08008838;\n    }\n  }\n  return CONCAT44(temp_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08008a02": "calculate_double_precision_08008a02",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "unaff_r4": "temp_2",
                "uVar2": "temp_3",
                "uVar3": "temp_4",
                "in_r12": "mask",
                "bVar4": "is_zero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a64": {
            "entrypoint": "0x08008a64",
            "current_name": "check_parameters_08008a64",
            "code": "\nuint check_parameters_08008a64(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isSmaller;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isSmaller = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isSmaller = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isSmaller) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008a64": "check_parameters_08008a64",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isSmaller"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a6c": {
            "entrypoint": "0x08008a6c",
            "current_name": "check_equality_and_comparison_08008a6c",
            "code": "\nuint checkEqualityAndComparison_08008a6c(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isValuesZero;\n  bool isComparisonTrue;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isValuesZero = (value1 | value2 << 1) == 0;\n  if (isValuesZero) {\n    isValuesZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isValuesZero) {\n    isValuesZero = value2 == value4;\n  }\n  if (isValuesZero) {\n    isValuesZero = value1 == value3;\n  }\n  if (!isValuesZero) {\n    result = value2 ^ value4;\n    isValuesZero = result == 0;\n    if (-1 < (int)result) {\n      isValuesZero = value2 == value4;\n    }\n    isComparisonTrue = -1 < (int)result && value4 <= value2;\n    if (isValuesZero) {\n      isComparisonTrue = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isComparisonTrue) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008a6c": "check_equality_and_comparison_08008a6c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isValuesZero",
                "bVar3": "isComparisonTrue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a74": {
            "entrypoint": "0x08008a74",
            "current_name": "check_params_08008a74",
            "code": "\nuint check_params_08008a74(uint input1,uint input2,uint input3,uint shiftedInput4)\n\n{\n  uint result1;\n  bool isZero;\n  bool isGreater;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(shiftedInput4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(shiftedInput4 << 1) >> 0x15 == -1 && ((input3 | shiftedInput4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    isZero = (input3 | shiftedInput4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input2 == shiftedInput4;\n  }\n  if (isZero) {\n    isZero = input1 == input3;\n  }\n  if (!isZero) {\n    result1 = input2 ^ shiftedInput4;\n    isZero = result1 == 0;\n    if (-1 < (int)result1) {\n      isZero = input2 == shiftedInput4;\n    }\n    isGreater = -1 < (int)result1 && shiftedInput4 <= input2;\n    if (isZero) {\n      isGreater = input3 <= input1;\n    }\n    shiftedInput4 = (int)shiftedInput4 >> 0x1f;\n    if (!isGreater) {\n      shiftedInput4 = ~shiftedInput4;\n    }\n    return shiftedInput4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008a74": "check_params_08008a74",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "shiftedInput4",
                "uVar1": "result1",
                "bVar2": "isZero",
                "bVar3": "isGreater"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "compare_floating_point_values_08008af0",
            "code": "\nvoid compareFloatingPointValues_08008af0(undefined4 result,undefined4 status,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "compare_floating_point_values_08008af0",
                "param_1": "result",
                "param_2": "status",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b00": {
            "entrypoint": "0x08008b00",
            "current_name": "convert_float_to_undefined_08008b00",
            "code": "\nundefined4 convertFloatToUndefined_08008b00(undefined4 value)\n\n{\n  undefinedConversion();\n  result value;\n}\n\n",
            "renaming": {
                "FUN_08008b00": "convert_float_to_undefined_08008b00",
                "param_1": "value",
                "__nedf2": "undefinedConversion",
                "return": "result"
            },
            "calling": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b10": {
            "entrypoint": "0x08008b10",
            "current_name": "compare_characters_08008b10",
            "code": "\nbool compareCharacters_08008b10(void)\n\n{\n  char result;\n  \n  __aeabi_cdcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08008b10": "compare_characters_08008b10",
                "in_ZR": "result"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b24": {
            "entrypoint": "0x08008b24",
            "current_name": "is_carry_equal_zero_08008b24",
            "code": "\nbool is_carry_equal_zero_08008b24(void)\n\n{\n  char carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return carry_flag == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08008b24": "is_carry_equal_zero_08008b24",
                "in_CY": "carry_flag"
            },
            "calling": [
                "sqrt",
                "__ieee754_hypot",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b38": {
            "entrypoint": "0x08008b38",
            "current_name": "check_zero_equality_08008b38",
            "code": "\nbool check_zero_equality_08008b38(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_08008b38": "check_zero_equality_08008b38",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b4c": {
            "entrypoint": "0x08008b4c",
            "current_name": "is_cdr_less_or_equal_08008b4c",
            "code": "\nbool is_cdr_less_or_equal_08008b4c(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_08008b4c": "is_cdr_less_or_equal_08008b4c",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "__kernel_rem_pio2"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b60": {
            "entrypoint": "0x08008b60",
            "current_name": "check_if_char_is_null_08008b60",
            "code": "\nbool checkIfCharIsNull_08008b60(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdrcmple();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08008b60": "check_if_char_is_null_08008b60",
                "in_CY": "inputChar"
            },
            "calling": [
                "ceil",
                "atan",
                "plan_buffer_line",
                "floor"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b74": {
            "entrypoint": "0x08008b74",
            "current_name": "check_parameters_08008b74",
            "code": "\nundefined4 check_parameters_08008b74(uint uint1,int int1,uint uint2,int int2)\n\n{\n  if ((((int1 << 1) >> 0x15 != -1) || ((uint1 | int1 << 0xc) == 0)) &&\n     (((int2 << 1) >> 0x15 != -1 || ((uint2 | int2 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08008b74": "check_parameters_08008b74",
                "param_1": "uint1",
                "param_2": "int1",
                "param_3": "uint2",
                "param_4": "int2"
            },
            "calling": [
                "sqrt"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ba0": {
            "entrypoint": "0x08008ba0",
            "current_name": "convert_number_08008ba0",
            "code": "\nuint convertNumber_08008ba0(uint input1,uint input2)\n\n{\n  uint convertedValue;\n  int tempVar;\n  uint remainder;\n  \n  tempVar = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < tempVar) {\n      return 0;\n    }\n    convertedValue = tempVar >> 0x15;\n    remainder = -convertedValue - 0x3e1;\n    if (convertedValue < 0xfffffc20 && remainder != 0) {\n      convertedValue = (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (remainder & 0xff);\n      if ((input2 & 0x80000000) != 0) {\n        convertedValue = -convertedValue;\n      }\n      return convertedValue;\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  input2 = input2 & 0x80000000;\n  if (input2 == 0) {\n    input2 = 0x7fffffff;\n  }\n  return input2;\n}\n\n",
            "renaming": {
                "FUN_08008ba0": "convert_number_08008ba0",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "convertedValue",
                "iVar2": "tempVar",
                "uVar3": "remainder"
            },
            "calling": [
                "gc_execute_line",
                "__ieee754_rem_pio2",
                "calculate_trapezoid_for_block",
                "lround",
                "__kernel_rem_pio2",
                "__kernel_sin",
                "__kernel_cos",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008bf0": {
            "entrypoint": "0x08008bf0",
            "current_name": "calculate_shifted_value_08008bf0",
            "code": "\nuint calculate_shifted_value_08008bf0(uint input_value1,uint input_value2)\n\n{\n  int shifted_value;\n  uint shift_amount;\n  \n  if ((input_value2 & 0x80000000) != 0) {\n    return 0;\n  }\n  shifted_value = input_value2 * 2 + 0x200000;\n  if (input_value2 * 2 < 0xffe00000) {\n    if (-1 < shifted_value) {\n      return 0;\n    }\n    shift_amount = -(shifted_value >> 0x15) - 0x3e1;\n    if (-1 < (int)shift_amount) {\n      return (input_value2 << 0xb | 0x80000000 | input_value1 >> 0x15) >> (shift_amount & 0xff);\n    }\n  }\n  else if ((input_value1 | input_value2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008bf0": "calculate_shifted_value_08008bf0",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "iVar1": "shifted_value",
                "uVar2": "shift_amount"
            },
            "calling": [
                "gc_execute_line",
                "protocol_execute_line",
                "calculate_trapezoid_for_block",
                "mc_dwell",
                "mc_arc",
                "homing_cycle",
                "settings_store_global_setting",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008c30": {
            "entrypoint": "0x08008c30",
            "current_name": "compute_floating_point_value_08008c30",
            "code": "\nuint computeFloatingPointValue_08008c30(uint inputFloat,uint inputBits)\n\n{\n  uint result;\n  uint doubleBits;\n  uint adjustedBits;\n  uint oneMinusBits;\n  bool isZero;\n  bool isInRange;\n  \n  doubleBits = inputBits * 2;\n  isInRange = doubleBits < 0x70000000;\n  adjustedBits = doubleBits + 0x90000000;\n  result = adjustedBits;\n  if (!isInRange) {\n    oneMinusBits = doubleBits + 0x8fe00000;\n    result = oneMinusBits;\n  }\n  isZero = result == 0;\n  if (!isInRange && adjustedBits >= 0x200000) {\n    isZero = oneMinusBits == 0x1fc00000;\n  }\n  if (((isInRange || adjustedBits < 0x200000) || 0x1fc00000 < oneMinusBits) || isZero) {\n    if ((inputBits & 0x40000000) != 0) {\n      if (((int)doubleBits >> 0x15 == -1) && ((inputFloat | inputBits << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputBits & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(doubleBits + 0x92e00000) < 0 != SCARRY4(adjustedBits,0x2e00000)) {\n      return inputBits & 0x80000000;\n    }\n    doubleBits = 0x18 - (doubleBits + 0x92e00000 >> 0x15);\n    result = inputFloat >> (doubleBits & 0xff);\n    if (inputFloat << (0x20 - doubleBits & 0xff) != 0) {\n      result = result | 1;\n    }\n    adjustedBits = inputBits & 0x1fffff | 0x100000;\n    inputFloat = result | adjustedBits << (0x20 - doubleBits & 0xff);\n    adjustedBits = (adjustedBits >> (doubleBits & 0xff)) << 1;\n  }\n  result = (inputBits & 0x80000000 | inputFloat >> 0x1d) + adjustedBits * 4 + (uint)(0x7fffffff < inputFloat * 8);\n  if (inputFloat * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08008c30": "compute_floating_point_value_08008c30",
                "param_1": "inputFloat",
                "param_2": "inputBits",
                "uVar1": "result",
                "uVar2": "doubleBits",
                "uVar3": "adjustedBits",
                "in_r12": "oneMinusBits",
                "bVar4": "isZero",
                "bVar5": "isInRange"
            },
            "calling": [
                "gc_execute_line",
                "to_millimeters",
                "read_float",
                "mc_arc",
                "report_realtime_status",
                "homing_cycle",
                "report_gcode_modes",
                "max_allowable_speed",
                "plan_buffer_line",
                "report_gcode_parameters"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008cd0": {
            "entrypoint": "0x08008cd0",
            "current_name": "convert_to_positive_float_08008cd0",
            "code": "\nvoid convertToPositiveFloat_08008cd0(uint num)\n\n{\n  __addsf3(num ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008cd0": "convert_to_positive_float_08008cd0",
                "param_1": "num"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008cd8": {
            "entrypoint": "0x08008cd8",
            "current_name": "calculate_floating_point_08008cd8",
            "code": "\nuint calculateFloatingPoint_08008cd8(uint exponent,uint significand,undefined4 sign_bit,uint round_bit)\n\n{\n  int exponent_shifted;\n  int exponent_shifted_2;\n  uint exponent_significand_xor;\n  uint exponent_significand_xor_shifted;\n  uint result;\n  uint shift_count;\n  uint exponent_difference;\n  bool flag;\n  \n  exponent_significand_xor = significand ^ 0x80000000;\n  result = exponent << 1;\n  flag = result == 0;\n  if (!flag) {\n    round_bit = significand << 1;\n    flag = round_bit == 0;\n  }\n  if (!flag) {\n    flag = result == round_bit;\n  }\n  exponent_shifted = (int)result >> 0x18;\n  if (!flag) {\n    flag = exponent_shifted == -1;\n  }\n  if (!flag) {\n    flag = (int)round_bit >> 0x18 == -1;\n  }\n  if (flag) {\n    exponent_shifted_2 = (int)(significand << 1) >> 0x18;\n    if (exponent_shifted == -1 || exponent_shifted_2 == -1) {\n      result = exponent_significand_xor;\n      if (exponent_shifted == -1) {\n        result = exponent;\n      }\n      if (exponent_shifted != -1 || exponent_shifted_2 != -1) {\n        exponent_significand_xor = result;\n      }\n      flag = (result & 0x7fffff) == 0;\n      if (flag) {\n        flag = (exponent_significand_xor & 0x7fffff) == 0;\n      }\n      if (flag) {\n        flag = result == exponent_significand_xor;\n      }\n      if (!flag) {\n        result = result | 0x400000;\n      }\n      return result;\n    }\n    if (((exponent ^ exponent_significand_xor) & 0x7fffffff) != 0) {\n      if (result == 0) {\n        exponent = exponent_significand_xor;\n      }\n      return exponent;\n    }\n    if (exponent != exponent_significand_xor) {\n      return 0;\n    }\n    if ((result & 0xff000000) == 0) {\n      exponent_significand_xor = exponent << 1;\n      if ((exponent & 0x80000000) != 0) {\n        exponent_significand_xor = exponent_significand_xor | 0x80000000;\n      }\n      return exponent_significand_xor;\n    }\n    if (result < 0xfe000000) {\n      return exponent + 0x800000;\n    }\n    exponent = exponent & 0x80000000;\nLAB_08008e12:\n    return exponent | 0x7f800000;\n  }\n  result = result >> 0x18;\n  round_bit = round_bit >> 0x18;\n  exponent_difference = round_bit - result;\n  flag = exponent_difference != 0;\n  shift_count = result;\n  if (flag && result <= round_bit) {\n    shift_count = result + exponent_difference;\n  }\n  if (flag && result <= round_bit) {\n    exponent_significand_xor = exponent_significand_xor ^ exponent;\n  }\n  if (flag && result <= round_bit) {\n    exponent = exponent ^ exponent_significand_xor;\n  }\n  if (flag && result <= round_bit) {\n    exponent_significand_xor = exponent_significand_xor ^ exponent;\n  }\n  if (round_bit < result) {\n    exponent_difference = -exponent_difference;\n  }\n  if (0x19 < exponent_difference) {\n    return exponent;\n  }\n  result = exponent & 0xffffff | 0x800000;\n  if ((exponent & 0x80000000) != 0) {\n    result = -result;\n  }\n  exponent_significand_xor_shifted = exponent_significand_xor & 0xffffff | 0x800000;\n  if ((exponent_significand_xor & 0x80000000) != 0) {\n    exponent_significand_xor_shifted = -exponent_significand_xor_shifted;\n  }\n  if (shift_count == exponent_difference) {\n    exponent_significand_xor_shifted = exponent_significand_xor_shifted ^ 0x800000;\n    if (shift_count == 0) {\n      result = result ^ 0x800000;\n      shift_count = 1;\n    }\n    else {\n      exponent_difference = exponent_difference - 1;\n    }\n  }\n  result = result + ((int)exponent_significand_xor_shifted >> (exponent_difference & 0xff));\n  exponent_significand_xor_shifted = exponent_significand_xor_shifted << (0x20 - exponent_difference & 0xff);\n  exponent = result & 0x80000000;\n  if ((int)result < 0) {\n    flag = exponent_significand_xor_shifted != 0;\n    exponent_significand_xor_shifted = -exponent_significand_xor_shifted;\n    result = -result - (uint)flag;\n  }\n  if (result < 0x800000) {\n    exponent_significand_xor = exponent_significand_xor_shifted & 0x80000000;\n    exponent_significand_xor_shifted = exponent_significand_xor_shifted << 1;\n    result = result * 2 + (uint)(exponent_significand_xor != 0);\n    exponent_significand_xor = shift_count - 2;\n    if (shift_count - 1 == 0 || result < 0x800000) {\n      exponent_difference = LZCOUNT(result) - 8;\n      result = result << (exponent_difference & 0xff);\n      if ((int)exponent_significand_xor < (int)exponent_difference) {\n        result = result >> (-(exponent_significand_xor - exponent_difference) & 0xff);\n      }\n      else {\n        result = result + (exponent_significand_xor - exponent_difference) * 0x800000;\n      }\n      return result | exponent;\n    }\n  }\n  else {\n    exponent_significand_xor = shift_count - 1;\n    if (0xffffff < result) {\n      exponent_significand_xor = result & 1;\n      result = result >> 1;\n      exponent_significand_xor_shifted = (uint)(exponent_significand_xor != 0) << 0x1f | exponent_significand_xor_shifted >> 1;\n      exponent_significand_xor = shift_count;\n      if (0xfd < shift_count) goto LAB_08008e12;\n    }\n  }\n  result = result + exponent_significand_xor * 0x800000 + (uint)(0x7fffffff < exponent_significand_xor_shifted);\n  if (exponent_significand_xor_shifted == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result | exponent;\n}\n\n",
            "renaming": {
                "FUN_08008cd8": "calculate_floating_point_08008cd8",
                "param_1": "exponent",
                "param_2": "significand",
                "param_3": "sign_bit",
                "param_4": "round_bit",
                "iVar1": "exponent_shifted",
                "iVar2": "exponent_shifted_2",
                "uVar3": "exponent_significand_xor",
                "uVar4": "exponent_significand_xor_shifted",
                "uVar5": "result",
                "uVar6": "shift_count",
                "uVar7": "exponent_difference",
                "bVar8": "flag"
            },
            "calling": [
                "gc_execute_line",
                "intersection_distance",
                "mc_dwell",
                "mc_arc",
                "report_realtime_status",
                "estimate_acceleration_distance",
                "max_allowable_speed",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008cdc": {
            "entrypoint": "0x08008cdc",
            "current_name": "calculate_floating_point_08008cdc",
            "code": "\nuint calculateFloatingPoint_08008cdc(uint operand1,uint operand2,undefined4 flag,uint controlWord)\n\n{\n  int exponent1;\n  int exponent2;\n  uint fraction1;\n  uint fraction2;\n  uint exponentDiff;\n  uint shiftAmount;\n  bool isEqual;\n  \n  fraction2 = operand1 << 1;\n  isEqual = fraction2 == 0;\n  if (!isEqual) {\n    controlWord = operand2 << 1;\n    isEqual = controlWord == 0;\n  }\n  if (!isEqual) {\n    isEqual = fraction2 == controlWord;\n  }\n  exponent1 = (int)fraction2 >> 0x18;\n  if (!isEqual) {\n    isEqual = exponent1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)controlWord >> 0x18 == -1;\n  }\n  if (isEqual) {\n    exponent2 = (int)(operand2 << 1) >> 0x18;\n    if (exponent1 == -1 || exponent2 == -1) {\n      fraction2 = operand2;\n      if (exponent1 == -1) {\n        fraction2 = operand1;\n      }\n      if (exponent1 != -1 || exponent2 != -1) {\n        operand2 = fraction2;\n      }\n      isEqual = (fraction2 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (operand2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = fraction2 == operand2;\n      }\n      if (!isEqual) {\n        fraction2 = fraction2 | 0x400000;\n      }\n      return fraction2;\n    }\n    if (((operand1 ^ operand2) & 0x7fffffff) != 0) {\n      if (fraction2 == 0) {\n        operand1 = operand2;\n      }\n      return operand1;\n    }\n    if (operand1 != operand2) {\n      return 0;\n    }\n    if ((fraction2 & 0xff000000) == 0) {\n      fraction2 = operand1 << 1;\n      if ((operand1 & 0x80000000) != 0) {\n        fraction2 = fraction2 | 0x80000000;\n      }\n      return fraction2;\n    }\n    if (fraction2 < 0xfe000000) {\n      return operand1 + 0x800000;\n    }\n    operand1 = operand1 & 0x80000000;\nLAB_08008e12:\n    return operand1 | 0x7f800000;\n  }\n  fraction2 = fraction2 >> 0x18;\n  controlWord = controlWord >> 0x18;\n  shiftAmount = controlWord - fraction2;\n  isEqual = shiftAmount != 0;\n  exponentDiff = fraction2;\n  if (isEqual && fraction2 <= controlWord) {\n    exponentDiff = fraction2 + shiftAmount;\n  }\n  if (isEqual && fraction2 <= controlWord) {\n    operand2 = operand2 ^ operand1;\n  }\n  if (isEqual && fraction2 <= controlWord) {\n    operand1 = operand1 ^ operand2;\n  }\n  if (isEqual && fraction2 <= controlWord) {\n    operand2 = operand2 ^ operand1;\n  }\n  if (controlWord < fraction2) {\n    shiftAmount = -shiftAmount;\n  }\n  if (0x19 < shiftAmount) {\n    return operand1;\n  }\n  fraction2 = operand1 & 0xffffff | 0x800000;\n  if ((operand1 & 0x80000000) != 0) {\n    fraction2 = -fraction2;\n  }\n  fraction1 = operand2 & 0xffffff | 0x800000;\n  if ((operand2 & 0x80000000) != 0) {\n    fraction1 = -fraction1;\n  }\n  if (exponentDiff == shiftAmount) {\n    fraction1 = fraction1 ^ 0x800000;\n    if (exponentDiff == 0) {\n      fraction2 = fraction2 ^ 0x800000;\n      exponentDiff = 1;\n    }\n    else {\n      shiftAmount = shiftAmount - 1;\n    }\n  }\n  fraction2 = fraction2 + ((int)fraction1 >> (shiftAmount & 0xff));\n  fraction1 = fraction1 << (0x20 - shiftAmount & 0xff);\n  operand1 = fraction2 & 0x80000000;\n  if ((int)fraction2 < 0) {\n    isEqual = fraction1 != 0;\n    fraction1 = -fraction1;\n    fraction2 = -fraction2 - (uint)isEqual;\n  }\n  if (fraction2 < 0x800000) {\n    shiftAmount = fraction1 & 0x80000000;\n    fraction1 = fraction1 << 1;\n    fraction2 = fraction2 * 2 + (uint)(shiftAmount != 0);\n    shiftAmount = exponentDiff - 2;\n    if (exponentDiff - 1 == 0 || fraction2 < 0x800000) {\n      exponentDiff = LZCOUNT(fraction2) - 8;\n      fraction2 = fraction2 << (exponentDiff & 0xff);\n      if ((int)shiftAmount < (int)exponentDiff) {\n        fraction2 = fraction2 >> (-(shiftAmount - exponentDiff) & 0xff);\n      }\n      else {\n        fraction2 = fraction2 + (shiftAmount - exponentDiff) * 0x800000;\n      }\n      return fraction2 | operand1;\n    }\n  }\n  else {\n    shiftAmount = exponentDiff - 1;\n    if (0xffffff < fraction2) {\n      shiftAmount = fraction2 & 1;\n      fraction2 = fraction2 >> 1;\n      fraction1 = (uint)(shiftAmount != 0) << 0x1f | fraction1 >> 1;\n      shiftAmount = exponentDiff;\n      if (0xfd < exponentDiff) goto LAB_08008e12;\n    }\n  }\n  fraction2 = fraction2 + shiftAmount * 0x800000 + (uint)(0x7fffffff < fraction1);\n  if (fraction1 == 0x80000000) {\n    fraction2 = fraction2 & 0xfffffffe;\n  }\n  return fraction2 | operand1;\n}\n\n",
            "renaming": {
                "FUN_08008cdc": "calculate_floating_point_08008cdc",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "flag",
                "param_4": "controlWord",
                "iVar1": "exponent1",
                "iVar2": "exponent2",
                "uVar3": "fraction1",
                "uVar4": "fraction2",
                "uVar5": "exponentDiff",
                "uVar6": "shiftAmount",
                "bVar7": "isEqual"
            },
            "calling": [
                "gc_execute_line",
                "printFloat",
                "intersection_distance",
                "mc_arc",
                "__aeabi_frsub",
                "report_realtime_status",
                "estimate_acceleration_distance",
                "max_allowable_speed",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e3c": {
            "entrypoint": "0x08008e3c",
            "current_name": "convert_to_unsigned_08008e3c",
            "code": "\nuint convertToUnsigned_08008e3c(uint inputValue)\n\n{\n  uint leadingZeroCount;\n  uint shiftAmount;\n  int constant;\n  uint mask;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeroCount = LZCOUNT(inputValue);\n  shiftAmount = leadingZeroCount - 8;\n  constant = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZeroCount) {\n    mask = 0 << (shiftAmount & 0xff);\n    leadingZeroCount = constant + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      leadingZeroCount = leadingZeroCount & 0xfffffffe;\n    }\n    return leadingZeroCount;\n  }\n  shiftAmount = inputValue << leadingZeroCount + 0x18;\n  leadingZeroCount = constant + ((inputValue >> (0x20 - (leadingZeroCount + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZeroCount = leadingZeroCount & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZeroCount;\n}\n\n",
            "renaming": {
                "FUN_08008e3c": "convert_to_unsigned_08008e3c",
                "param_1": "inputValue",
                "uVar1": "leadingZeroCount",
                "uVar2": "shiftAmount",
                "iVar3": "constant",
                "uVar4": "mask"
            },
            "calling": [
                "calculate_trapezoid_for_block",
                "read_float"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e44": {
            "entrypoint": "0x08008e44",
            "current_name": "calculate_value_08008e44",
            "code": "\nuint calculateValue_08008e44(uint input)\n\n{\n  uint leadingZeros;\n  uint shiftCount;\n  uint signBit;\n  int result;\n  \n  signBit = input & 0x80000000;\n  if ((int)signBit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(input);\n  shiftCount = leadingZeros - 8;\n  result = ((signBit | 0x4b000000) - 0x800000) + shiftCount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftCount & 0xff);\n    signBit = result + (input << (shiftCount & 0xff)) +\n            (0U >> (0x20 - shiftCount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftCount = input << leadingZeros + 0x18;\n  signBit = result + ((input >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftCount >> 0x1f));\n  if ((shiftCount & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftCount >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08008e44": "calculate_value_08008e44",
                "param_1": "input",
                "uVar1": "leadingZeros",
                "uVar2": "shiftCount",
                "uVar3": "signBit",
                "iVar4": "result",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "gc_set_current_position",
                "mc_go_home",
                "calculate_trapezoid_for_block",
                "mc_dwell",
                "mc_arc",
                "report_realtime_status",
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e60": {
            "entrypoint": "0x08008e60",
            "current_name": "calculate_08008e60",
            "code": "\nuint calculate_08008e60(uint input_1,uint input_2)\n\n{\n  uint output;\n  uint temp;\n  uint shift_count;\n  uint shifted;\n  int constant;\n  \n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  output = input_1;\n  temp = input_2;\n  if (input_2 == 0) {\n    output = 0;\n    temp = input_1;\n  }\n  constant = 0x5b000000;\n  if (input_2 == 0) {\n    constant = 0x4b000000;\n  }\n  shift_count = LZCOUNT(temp);\n  shifted = shift_count - 8;\n  constant = constant + -0x800000 + shifted * -0x800000;\n  if (shift_count < 8) {\n    shifted = temp << shift_count + 0x18;\n    temp = constant + ((temp >> (0x20 - (shift_count + 0x18) & 0xff)) - ((int)shifted >> 0x1f));\n    if ((output | shifted << 1) == 0) {\n      temp = temp & ~(shifted >> 0x1f);\n    }\n    return temp;\n  }\n  shift_count = output << (shifted & 0xff);\n  temp = constant + (temp << (shifted & 0xff)) +\n          (output >> (0x20 - shifted & 0xff)) + (uint)(0x7fffffff < shift_count);\n  if (shift_count == 0x80000000) {\n    temp = temp & 0xfffffffe;\n  }\n  return temp;\n}\n\n",
            "renaming": {
                "FUN_08008e60": "calculate_08008e60",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "output",
                "uVar2": "temp",
                "uVar3": "shift_count",
                "uVar4": "shifted",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e70": {
            "entrypoint": "0x08008e70",
            "current_name": "calculate_result_08008e70",
            "code": "\nuint calculate_result_08008e70(uint input1,uint input2)\n\n{\n  uint abs_input2;\n  uint abs_input1;\n  uint shifted_count;\n  uint shift_amount;\n  uint sign_bit;\n  int intermediate_result;\n  bool is_input1_nonzero;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  sign_bit = input2 & 0x80000000;\n  if ((int)sign_bit < 0) {\n    is_input1_nonzero = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)is_input1_nonzero;\n  }\n  abs_input1 = input1;\n  abs_input2 = input2;\n  if (input2 == 0) {\n    abs_input1 = 0;\n    abs_input2 = input1;\n  }\n  sign_bit = sign_bit | 0x5b000000;\n  if (input2 == 0) {\n    sign_bit = sign_bit + 0xf0000000;\n  }\n  shifted_count = LZCOUNT(abs_input2);\n  shift_amount = shifted_count - 8;\n  intermediate_result = (sign_bit - 0x800000) + shift_amount * -0x800000;\n  if (shifted_count < 8) {\n    shift_amount = abs_input2 << shifted_count + 0x18;\n    sign_bit = intermediate_result + ((abs_input2 >> (0x20 - (shifted_count + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((abs_input1 | shift_amount << 1) == 0) {\n      sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n    }\n    return sign_bit;\n  }\n  shifted_count = abs_input1 << (shift_amount & 0xff);\n  sign_bit = intermediate_result + (abs_input2 << (shift_amount & 0xff)) +\n          (abs_input1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shifted_count);\n  if (shifted_count == 0x80000000) {\n    sign_bit = sign_bit & 0xfffffffe;\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08008e70": "calculate_result_08008e70",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "abs_input2",
                "uVar2": "abs_input1",
                "uVar3": "shifted_count",
                "uVar4": "shift_amount",
                "uVar5": "sign_bit",
                "iVar6": "intermediate_result",
                "bVar7": "is_input1_nonzero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008eec": {
            "entrypoint": "0x08008eec",
            "current_name": "calculate_floating_point_08008eec",
            "code": "\nuint calculateFloatingPoint_08008eec(uint num1,uint num2,undefined4 var3,uint var4)\n\n{\n  longlong longVar1;\n  uint result;\n  uint exponent1;\n  int sumExponents;\n  int var5;\n  uint var6;\n  int var7;\n  uint exponent2;\n  bool isZero;\n  bool var10;\n  \n  exponent1 = num1 >> 0x17 & 0xff;\n  isZero = exponent1 == 0;\n  if (!isZero) {\n    var4 = num2 >> 0x17 & 0xff;\n    isZero = var4 == 0;\n  }\n  if (!isZero) {\n    isZero = exponent1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = var4 == 0xff;\n  }\n  if (isZero) {\n    var4 = num2 >> 0x17 & 0xff;\n    if (exponent1 == 0xff || var4 == 0xff) {\n      isZero = num1 == 0 || num1 == 0x80000000;\n      result = num2;\n      if (num1 != 0 && num1 != 0x80000000) {\n        isZero = num2 == 0;\n        result = num1;\n      }\n      if (!isZero) {\n        isZero = num2 == 0x80000000;\n      }\n      exponent2 = result;\n      if (((isZero) || ((exponent1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((var4 == 0xff && (exponent2 = num2, (num2 & 0x7fffff) != 0)))) {\n        return exponent2 | 0x7fc00000;\n      }\n      result = result ^ num2;\n      goto LAB_0800903c;\n    }\n    isZero = (num1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (num2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (num1 ^ num2) & 0x80000000;\n    }\n    isZero = exponent1 == 0;\n    result = num1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        num1 = num1 << 1;\n        isZero = (num1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      exponent1 = exponent1 - 1;\n    }\n    num1 = num1 | result;\n    isZero = var4 == 0;\n    result = num2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        num2 = num2 << 1;\n        isZero = (num2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      var4 = var4 - 1;\n    }\n    num2 = num2 | result;\n  }\n  sumExponents = exponent1 + var4;\n  exponent2 = num1 ^ num2;\n  exponent1 = num1 << 9;\n  isZero = exponent1 == 0;\n  if (!isZero) {\n    num2 = num2 << 9;\n    isZero = num2 == 0;\n  }\n  if (isZero) {\n    if (exponent1 == 0) {\n      num2 = num2 << 9;\n    }\n    result = exponent2 & 0x80000000 | num1 & 0x7fffff | num2 >> 9;\n    var10 = SBORROW4(sumExponents,0x7f);\n    var5 = sumExponents + -0x7f;\n    isZero = var5 == 0;\n    var7 = var5;\n    if (!isZero && 0x7e < sumExponents) {\n      var10 = SBORROW4(0xff,var5);\n      var7 = 0xff - var5;\n      isZero = var5 == 0xff;\n    }\n    if (!isZero && var7 < 0 == var10) {\n      result = result | var5 * 0x800000;\n    }\n    if (!isZero && var7 < 0 == var10) {\n      return result;\n    }\n    result = result | 0x800000;\n    var6 = 0;\n    var10 = SBORROW4(var5,1);\n    exponent2 = sumExponents - 0x80;\n    isZero = exponent2 == 0;\n    exponent1 = exponent2;\n  }\n  else {\n    longVar1 = (ulonglong)(exponent1 >> 5 | 0x8000000) * (ulonglong)(num2 >> 5 | 0x8000000);\n    var6 = (uint)longVar1;\n    result = (uint)((ulonglong)longVar1 >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | var6 >> 0x1f;\n      var6 = var6 << 1;\n    }\n    result = exponent2 & 0x80000000 | result;\n    exponent2 = (sumExponents + -0x7f) - (uint)isZero;\n    var10 = SBORROW4(exponent2,0xfd);\n    isZero = exponent2 == 0xfd;\n    exponent1 = exponent2 - 0xfd;\n    if (exponent2 < 0xfe) {\n      result = result + exponent2 * 0x800000 + (uint)(0x7fffffff < var6);\n      if (var6 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)exponent1 < 0 != var10) {\n    isZero = (int)(exponent2 + 0x19) < 0;\n    if (exponent2 == 0xffffffe7 || isZero != SCARRY4(exponent2,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (exponent2 != 0xffffffe7 && isZero == SCARRY4(exponent2,0x19)) {\n      exponent1 = (result << 1) >> (-exponent2 & 0xff);\n      exponent2 = result << (exponent2 + 0x20 & 0xff);\n      exponent1 = ((uint)((result & 0x80000000) != 0) << 0x1f | exponent1 >> 1) + (uint)((byte)exponent1 & 1);\n      if ((var6 | exponent2 << 1) == 0) {\n        exponent1 = exponent1 & ~(exponent2 >> 0x1f);\n      }\n      return exponent1;\n    }\n    return result;\n  }\nLAB_0800903c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08008eec": "calculate_floating_point_08008eec",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "var3",
                "param_4": "var4",
                "lVar1": "longVar1",
                "uVar2": "result",
                "uVar3": "exponent1",
                "iVar4": "sumExponents",
                "iVar5": "var5",
                "uVar6": "var6",
                "iVar7": "var7",
                "uVar8": "exponent2",
                "bVar9": "isZero",
                "bVar10": "var10"
            },
            "calling": [
                "printFloat",
                "calculate_trapezoid_for_block",
                "estimate_acceleration_distance",
                "plan_cycle_reinitialize",
                "homing_cycle",
                "max_allowable_speed",
                "plan_buffer_line",
                "gc_execute_line",
                "mc_go_home",
                "intersection_distance",
                "read_float",
                "mc_dwell",
                "mc_arc",
                "settings_store_global_setting"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009054": {
            "entrypoint": "0x08009054",
            "current_name": "calculate_float_08009054",
            "code": "\nuint calculateFloat_08009054(uint input1,uint input2,undefined4 flag,uint flag2)\n\n{\n  uint temp1;\n  uint temp2;\n  int diff;\n  uint carry;\n  int sum;\n  uint result;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp2 = input1 >> 0x17 & 0xff;\n  condition1 = temp2 == 0;\n  if (!condition1) {\n    flag2 = input2 >> 0x17 & 0xff;\n    condition1 = flag2 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp2 == 0xff;\n  }\n  if (!condition1) {\n    condition1 = flag2 == 0xff;\n  }\n  if (condition1) {\n    flag2 = input2 >> 0x17 & 0xff;\n    result = input1;\n    if (temp2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (result = input2, flag2 == 0xff)) {\nLAB_0800904a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (flag2 == 0xff) {\n        result = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08009000:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      condition1 = (input1 & 0x7fffffff) == 0;\n      if (!condition1) {\n        condition1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!condition1) {\n        condition1 = temp2 == 0;\n        result = input1 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input1 = input1 << 1;\n            condition1 = (input1 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          temp2 = temp2 - 1;\n        }\n        input1 = input1 | result;\n        condition1 = flag2 == 0;\n        result = input2 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input2 = input2 << 1;\n            condition1 = (input2 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          flag2 = flag2 - 1;\n        }\n        input2 = input2 | result;\n        goto LAB_0800906c;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_0800906c:\n    diff = temp2 - flag2;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      condition3 = SCARRY4(diff,0x7f);\n      sum = diff + 0x7f;\n      condition1 = sum < 0;\n      condition2 = sum == 0;\n      if (!condition2 && condition1 == condition3) {\n        condition3 = SBORROW4(0xff,sum);\n        condition1 = 0xff - sum < 0;\n        condition2 = sum == 0xff;\n      }\n      if (!condition2 && condition1 == condition3) {\n        input1 = input1 | sum * 0x800000;\n      }\n      if (!condition2 && condition1 == condition3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      temp2 = 0;\n      condition2 = SBORROW4(sum,1);\n      carry = diff + 0x7e;\n      condition1 = carry == 0;\n      result = carry;\n    }\n    else {\n      temp1 = (input2 << 9) >> 4 | 0x10000000;\n      temp2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      condition1 = temp1 <= temp2;\n      if (!condition1) {\n        temp2 = temp2 << 1;\n      }\n      carry = diff + 0x7d + (uint)condition1;\n      result = 0x800000;\n      do {\n        if (temp1 <= temp2) {\n          temp2 = temp2 - temp1;\n          input1 = input1 | result;\n        }\n        condition1 = temp1 >> 1 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 1);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 1;\n        }\n        condition1 = temp1 >> 2 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 2);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 2;\n        }\n        condition1 = temp1 >> 3 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 3);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 3;\n        }\n        temp2 = temp2 * 0x10;\n        condition1 = temp2 == 0;\n        if (!condition1) {\n          result = result >> 4;\n          condition1 = result == 0;\n        }\n      } while (!condition1);\n      condition2 = SBORROW4(carry,0xfd);\n      condition1 = carry == 0xfd;\n      result = carry - 0xfd;\n      if (carry < 0xfe) {\n        input1 = input1 + carry * 0x800000 + (uint)(temp1 <= temp2);\n        if (temp2 - temp1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (condition1 || (int)result < 0 != condition2) {\n      condition1 = (int)(carry + 0x19) < 0;\n      if (carry == 0xffffffe7 || condition1 != SCARRY4(carry,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (carry == 0xffffffe7 || condition1 != SCARRY4(carry,0x19)) {\n        return input1;\n      }\n      result = (input1 << 1) >> (-carry & 0xff);\n      carry = input1 << (carry + 0x20 & 0xff);\n      result = ((uint)((input1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((temp2 | carry << 1) == 0) {\n        result = result & ~(carry >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08009054": "calculate_float_08009054",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "flag",
                "param_4": "flag2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "diff",
                "uVar4": "carry",
                "iVar5": "sum",
                "uVar6": "result",
                "bVar7": "condition1",
                "bVar8": "condition2",
                "bVar9": "condition3"
            },
            "calling": [
                "gc_set_current_position",
                "intersection_distance",
                "report_grbl_settings",
                "planner_recalculate_trapezoids",
                "mc_arc",
                "report_realtime_status",
                "estimate_acceleration_distance",
                "plan_cycle_reinitialize",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800918c": {
            "entrypoint": "0x0800918c",
            "current_name": "calculate_result_0800918c",
            "code": "\nuint calculate_result_0800918c(uint input_1,uint input_2)\n\n{\n  bool is_negative_result;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_inputs;\n  bool is_zero_result;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_inputs = double_input_1 | input_2 & 0x7fffffff;\n  is_zero_result = combined_inputs == 0;\n  if (!is_zero_result) {\n    combined_inputs = input_1 ^ input_2;\n    is_zero_result = combined_inputs == 0;\n  }\n  is_negative_result = -1 < (int)combined_inputs;\n  if (is_negative_result) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero_result = input_1 == 0;\n  }\n  if ((is_negative_result && double_input_2 <= double_input_1) && !is_zero_result) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_result || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero_result) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_0800918c": "calculate_result_0800918c",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative_result",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_inputs",
                "bVar5": "is_zero_result"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009194": {
            "entrypoint": "0x08009194",
            "current_name": "check_overflow_and_condition_08009194",
            "code": "\nuint check_overflow_and_condition_08009194(uint input_1,uint input_2)\n\n{\n  bool is_overflow;\n  uint input1_multiplied;\n  uint input2_multiplied;\n  uint combined;\n  bool is_zero;\n  \n  input1_multiplied = input_1 * 2;\n  input2_multiplied = input_2 * 2;\n  if (((int)input1_multiplied >> 0x18 == -1 || (int)input2_multiplied >> 0x18 == -1) &&\n     ((((int)input1_multiplied >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input2_multiplied >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined = input1_multiplied | input_2 & 0x7fffffff;\n  is_zero = combined == 0;\n  if (!is_zero) {\n    combined = input_1 ^ input_2;\n    is_zero = combined == 0;\n  }\n  is_overflow = -1 < (int)combined;\n  if (is_overflow) {\n    input_1 = input1_multiplied + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_overflow && input2_multiplied <= input1_multiplied) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_overflow || input2_multiplied > input1_multiplied) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08009194": "check_overflow_and_condition_08009194",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_overflow",
                "uVar2": "input1_multiplied",
                "uVar3": "input2_multiplied",
                "uVar4": "combined",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800919c": {
            "entrypoint": "0x0800919c",
            "current_name": "check_overflow_0800919c",
            "code": "\nuint checkOverflow_0800919c(uint input_1,uint input_2)\n\n{\n  bool isOverflow;\n  uint doubleInput_1;\n  uint doubleInput_2;\n  uint combinedInput;\n  bool isZero;\n  \n  doubleInput_1 = input_1 * 2;\n  doubleInput_2 = input_2 * 2;\n  if (((int)doubleInput_1 >> 0x18 == -1 || (int)doubleInput_2 >> 0x18 == -1) &&\n     ((((int)doubleInput_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)doubleInput_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combinedInput = doubleInput_1 | input_2 & 0x7fffffff;\n  isZero = combinedInput == 0;\n  if (!isZero) {\n    combinedInput = input_1 ^ input_2;\n    isZero = combinedInput == 0;\n  }\n  isOverflow = -1 < (int)combinedInput;\n  if (isOverflow) {\n    input_1 = doubleInput_1 + input_2 * -2;\n    isZero = input_1 == 0;\n  }\n  if ((isOverflow && doubleInput_2 <= doubleInput_1) && !isZero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!isOverflow || doubleInput_2 > doubleInput_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!isZero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_0800919c": "check_overflow_0800919c",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "doubleInput_1",
                "uVar3": "doubleInput_2",
                "uVar4": "combinedInput",
                "bVar1": "isOverflow",
                "bVar5": "isZero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091fc": {
            "entrypoint": "0x080091fc",
            "current_name": "compare_floats_080091fc",
            "code": "\nvoid compareFloats_080091fc(undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cfcmpeq(float2,float1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091fc": "compare_floats_080091fc",
                "param_1": "float1",
                "param_2": "float2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009204": {
            "entrypoint": "0x08009204",
            "current_name": "concatenate_params_08009204",
            "code": "\nundefined8 concatenateParams_08009204(undefined4 firstParam,undefined4 secondParam)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParam,firstParam);\n}\n\n",
            "renaming": {
                "FUN_08009204": "concatenate_params_08009204",
                "param_1": "firstParam",
                "param_2": "secondParam"
            },
            "calling": [
                "__aeabi_fcmple",
                "__aeabi_fcmplt",
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009214": {
            "entrypoint": "0x08009214",
            "current_name": "check_not_zero_08009214",
            "code": "\nbool check_not_zero_08009214(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08009214": "check_not_zero_08009214",
                "in_ZR": "input_character"
            },
            "calling": [
                "gc_execute_line",
                "read_float",
                "planner_forward_pass_kernel",
                "mc_arc",
                "settings_store_global_setting",
                "planner_reverse_pass_kernel"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009228": {
            "entrypoint": "0x08009228",
            "current_name": "is_cy_null_08009228",
            "code": "\nbool is_CY_null_08009228(void)\n\n{\n  char input_char_CY;\n  \n  __aeabi_cfcmpeq();\n  return input_char_CY == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08009228": "is_cy_null_08009228",
                "in_CY": "input_char_CY"
            },
            "calling": [
                "gc_execute_line",
                "printFloat",
                "planner_forward_pass_kernel",
                "settings_store_global_setting",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800923c": {
            "entrypoint": "0x0800923c",
            "current_name": "compare_floats_without_carry_flag_0800923c",
            "code": "\nbool compareFloatsWithoutCarryFlag_0800923c(void)\n\n{\n  undefined isZeroResult;\n  undefined carryFlag;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)carryFlag || (bool)isZeroResult;\n}\n\n",
            "renaming": {
                "FUN_0800923c": "compare_floats_without_carry_flag_0800923c",
                "in_ZR": "isZeroResult",
                "in_CY": "carryFlag"
            },
            "calling": [
                "gc_execute_line",
                "mc_arc",
                "settings_store_global_setting"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009250": {
            "entrypoint": "0x08009250",
            "current_name": "check_leq_zero_08009250",
            "code": "\nbool check_leq_zero_08009250(void)\n\n{\n  undefined is_zero_equal;\n  undefined carry_flag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carry_flag || (bool)is_zero_equal;\n}\n\n",
            "renaming": {
                "FUN_08009250": "check_leq_zero_08009250",
                "in_ZR": "is_zero_equal",
                "in_CY": "carry_flag"
            },
            "calling": [
                "mc_arc",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009264": {
            "entrypoint": "0x08009264",
            "current_name": "is_input_null_08009264",
            "code": "\nbool is_input_null_08009264(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08009264": "is_input_null_08009264",
                "in_CY": "input_char"
            },
            "calling": [
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009278": {
            "entrypoint": "0x08009278",
            "current_name": "convert_to_signed_int_08009278",
            "code": "\nuint convertToSignedInt_08009278(uint num)\n\n{\n  uint shiftedNum;\n  uint difference;\n  \n  if (num << 1 < 0x7f000000) {\n    return 0;\n  }\n  shiftedNum = (num << 1) >> 0x18;\n  difference = 0x9e - shiftedNum;\n  if (shiftedNum < 0x9f && difference != 0) {\n    shiftedNum = (num << 8 | 0x80000000) >> (difference & 0xff);\n    if ((num & 0x80000000) != 0) {\n      shiftedNum = -shiftedNum;\n    }\n    return shiftedNum;\n  }\n  if ((difference == 0xffffff9f) && ((num & 0x7fffff) != 0)) {\n    return 0;\n  }\n  num = num & 0x80000000;\n  if (num == 0) {\n    num = 0x7fffffff;\n  }\n  return num;\n}\n\n",
            "renaming": {
                "FUN_08009278": "convert_to_signed_int_08009278",
                "param_1": "num",
                "uVar1": "shiftedNum",
                "uVar2": "difference"
            },
            "calling": [
                "printFloat",
                "protocol_execute_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080092c4": {
            "entrypoint": "0x080092c4",
            "current_name": "initialize_system_080092c4",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_080092c4(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8911; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&__fini_array_end + index);\n  }\n  for (pointer = &completed_8911; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x80092fa;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x080092fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080092c4": "initialize_system_080092c4",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "SystemInit",
                "__libc_init_array",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009314": {
            "entrypoint": "0x08009314",
            "current_name": "run_infinite_loop_08009314",
            "code": "\nvoid runInfiniteLoop_08009314(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08009314": "run_infinite_loop_08009314"
            },
            "calling": [
                "DMA1_Stream3_IRQHandler"
            ],
            "called": [
                "DMA1_Stream3_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009318": {
            "entrypoint": "0x08009318",
            "current_name": "calculate_double_value_08009318",
            "code": "\ndouble calculateDoubleValue_08009318(double inputValue)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint shiftedAmount;\n  uint shiftedValue;\n  double finalResult;\n  double result1;\n  double result2;\n  double result3;\n  undefined8 comparisonResult;\n  \n  shiftedValue = (tempVar2 << 1) >> 0x15;\n  shiftedAmount = shiftedValue - 0x3ff;\n  if ((int)shiftedAmount < 0x14) {\n    if ((int)shiftedAmount < 0) {\n      comparisonResult = addDouble(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)comparisonResult,(int)((ulonglong)comparisonResult >> 0x20),0,0);\n      finalResult = result2;\n    }\n    else if ((tempVar2 & 0xfffff >> (shiftedAmount & 0xff) | tempVar1) != 0) {\n      comparisonResult = addDouble(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)comparisonResult,(int)((ulonglong)comparisonResult >> 0x20),0,0);\n      finalResult = result1;\n    }\n  }\n  else if ((int)shiftedAmount < 0x34) {\n    if ((0xffffffffU >> (shiftedValue - 0x413 & 0xff) & tempVar1) != 0) {\n      comparisonResult = addDouble(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)comparisonResult,(int)((ulonglong)comparisonResult >> 0x20),0,0);\n      finalResult = result3;\n    }\n  }\n  else if (shiftedAmount == 0x400) {\n    finalResult = (double)addDouble();\n  }\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_08009318": "calculate_double_value_08009318",
                "__x": "inputValue",
                "in_r0": "tempVar1",
                "in_r1": "tempVar2",
                "uVar1": "shiftedAmount",
                "uVar2": "shiftedValue",
                "__aeabi_dadd": "addDouble",
                "extraout_d0": "result1",
                "extraout_d0_00": "result2",
                "extraout_d0_01": "result3",
                "uVar3": "comparisonResult",
                "in_d0": "finalResult"
            },
            "calling": [
                "calculate_trapezoid_for_block",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_dadd",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009410": {
            "entrypoint": "0x08009410",
            "current_name": "trig_function_08009410",
            "code": "\ndouble trigFunction_08009410(double input)\n\n{\n  undefined4 unusedVar1;\n  uint remainderFlag;\n  uint unusedVar2;\n  double result;\n  undefined4 localVar1;\n  undefined4 unusedVar3;\n  undefined4 localVar2;\n  undefined4 unusedVar4;\n  \n  if (0x3fe921fb < (unusedVar2 & 0x7fffffff)) {\n    if ((unusedVar2 & 0x7fffffff) < 0x7ff00000) {\n      remainderFlag = calculateRemainder(unusedVar1,unusedVar2,&localVar1);\n      remainderFlag = remainderFlag & 3;\n      if (remainderFlag == 1) {\n        result = (double)calculateSin(localVar1,unusedVar3,localVar2,unusedVar4,1);\n      }\n      else if (remainderFlag == 2) {\n        result = (double)calculateCos(localVar1,unusedVar3,localVar2,unusedVar4);\n      }\n      else if (remainderFlag == 0) {\n        result = (double)calculateCos(localVar1,unusedVar3,localVar2,unusedVar4);\n      }\n      else {\n        result = (double)calculateSin(localVar1,unusedVar3,localVar2,unusedVar4,1);\n      }\n    }\n    else {\n      result = (double)subtractDoubleFloat();\n    }\n    return result;\n  }\n  result = (double)calculateCos(unusedVar1,unusedVar2,0,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009410": "trig_function_08009410",
                "__x": "input",
                "in_r0": "unusedVar1",
                "in_r1": "unusedVar2",
                "uVar1": "remainderFlag",
                "dVar2": "result",
                "local_28": "localVar1",
                "uStack_24": "unusedVar3",
                "local_20": "localVar2",
                "uStack_1c": "unusedVar4",
                "__ieee754_rem_pio2": "calculateRemainder",
                "__kernel_sin": "calculateSin",
                "__kernel_cos": "calculateCos",
                "__subdf3": "subtractDoubleFloat"
            },
            "calling": [
                "mc_arc"
            ],
            "called": [
                "__ieee754_rem_pio2",
                "__kernel_sin",
                "__kernel_cos",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094c0": {
            "entrypoint": "0x080094c0",
            "current_name": "process_double_080094c0",
            "code": "\ndouble processDouble_080094c0(double inputValue)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint shiftAmount;\n  uint shiftedValue;\n  double outputValue;\n  double result1;\n  double result2;\n  double result3;\n  undefined8 sum;\n  \n  shiftedValue = (tempVar2 << 1) >> 0x15;\n  shiftAmount = shiftedValue - 0x3ff;\n  if ((int)shiftAmount < 0x14) {\n    if ((int)shiftAmount < 0) {\n      sum = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)sum,(int)((ulonglong)sum >> 0x20),0,0);\n      outputValue = result3;\n    }\n    else if ((tempVar2 & 0xfffff >> (shiftAmount & 0xff) | tempVar1) != 0) {\n      sum = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)sum,(int)((ulonglong)sum >> 0x20),0,0);\n      outputValue = result1;\n    }\n  }\n  else if ((int)shiftAmount < 0x34) {\n    if ((0xffffffffU >> (shiftedValue - 0x413 & 0xff) & tempVar1) != 0) {\n      sum = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)sum,(int)((ulonglong)sum >> 0x20),0,0);\n      outputValue = result2;\n    }\n  }\n  else if (shiftAmount == 0x400) {\n    outputValue = (double)__aeabi_dadd();\n  }\n  return outputValue;\n}\n\n",
            "renaming": {
                "FUN_080094c0": "process_double_080094c0",
                "__x": "inputValue",
                "in_r0": "tempVar1",
                "in_r1": "tempVar2",
                "uVar1": "shiftAmount",
                "uVar2": "shiftedValue",
                "extraout_d0": "result1",
                "extraout_d0_00": "result2",
                "extraout_d0_01": "result3",
                "in_d0": "outputValue",
                "uVar3": "sum"
            },
            "calling": [
                "calculate_trapezoid_for_block",
                "mc_dwell",
                "mc_arc",
                "__kernel_rem_pio2"
            ],
            "called": [
                "__aeabi_dadd",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080095b8": {
            "entrypoint": "0x080095b8",
            "current_name": "calculate_exponent_080095b8",
            "code": "\nlong calculateExponent_080095b8(double input)\n\n{\n  uint decimalPart;\n  uint integerPart;\n  uint shiftedBit;\n  uint shiftedBits;\n  uint modifiedFrac;\n  long sign;\n  uint exponent;\n  \n  shiftedBits = (integerPart << 1) >> 0x15;\n  exponent = shiftedBits - 0x3ff;\n  if ((int)integerPart < 0) {\n    sign = -1;\n  }\n  else {\n    sign = 1;\n  }\n  modifiedFrac = integerPart & 0xfffff | 0x100000;\n  if ((int)exponent < 0x14) {\n    if ((int)exponent < 0) {\n      if (exponent != 0xffffffff) {\n        sign = 0;\n      }\n      return sign;\n    }\n    modifiedFrac = modifiedFrac + (0x80000 >> (exponent & 0xff)) >> (0x14 - exponent & 0xff);\n  }\n  else {\n    if (0x1e < exponent) {\n      sign = __aeabi_d2iz();\n      return sign;\n    }\n    if ((int)exponent < 0x34) {\n      shiftedBit = 0x80000000 >> (shiftedBits - 0x413 & 0xff);\n      if (CARRY4(shiftedBit,decimalPart) != false) {\n        modifiedFrac = modifiedFrac + 1;\n      }\n      modifiedFrac = modifiedFrac << (shiftedBits - 0x413 & 0xff);\n      if (exponent != 0x14) {\n        modifiedFrac = modifiedFrac | shiftedBit + decimalPart >> (0x34 - exponent & 0xff);\n      }\n    }\n    else {\n      modifiedFrac = modifiedFrac << (shiftedBits - 0x413 & 0xff) | decimalPart << (shiftedBits - 0x433 & 0xff);\n    }\n  }\n  return modifiedFrac * sign;\n}\n\n",
            "renaming": {
                "FUN_080095b8": "calculate_exponent_080095b8",
                "__x": "input",
                "in_r0": "decimalPart",
                "in_r1": "integerPart",
                "uVar1": "shiftedBit",
                "uVar2": "shiftedBits",
                "uVar3": "modifiedFrac",
                "lVar4": "sign",
                "uVar5": "exponent"
            },
            "calling": [
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_d2iz"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009654": {
            "entrypoint": "0x08009654",
            "current_name": "calculate_modified_value_08009654",
            "code": "\ndouble calculateModifiedValue_08009654(double inputValue)\n\n{\n  int variable1;\n  int exponent;\n  double result;\n  \n  exponent = ((uint)(variable1 << 1) >> 0x15) - 0x3ff;\n  if (((0x13 < exponent) && (0x33 < exponent)) && (exponent == 0x400)) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009654": "calculate_modified_value_08009654",
                "__x": "inputValue",
                "in_r1": "variable1",
                "iVar1": "exponent",
                "in_d0": "result"
            },
            "calling": [
                "settings_store_global_setting"
            ],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e8": {
            "entrypoint": "0x080096e8",
            "current_name": "calculate_trigonometric_value_080096e8",
            "code": "\ndouble calculate_trigonometric_value_080096e8(double input_angle)\n\n{\n  undefined4 low_bits;\n  uint rem_pio2_result;\n  uint high_bits;\n  double trigonometric_value;\n  undefined4 quadrant;\n  undefined4 q1;\n  undefined4 q2;\n  undefined4 q3;\n  \n  if (0x3fe921fb < (high_bits & 0x7fffffff)) {\n    if ((high_bits & 0x7fffffff) < 0x7ff00000) {\n      rem_pio2_result = __ieee754_rem_pio2(low_bits,high_bits,&quadrant);\n      rem_pio2_result = rem_pio2_result & 3;\n      if (rem_pio2_result == 1) {\n        trigonometric_value = (double)__kernel_cos(quadrant,q1,q2,q3);\n      }\n      else if (rem_pio2_result == 2) {\n        trigonometric_value = (double)__kernel_sin(quadrant,q1,q2,q3,1);\n      }\n      else if (rem_pio2_result == 0) {\n        trigonometric_value = (double)__kernel_sin(quadrant,q1,q2,q3,1);\n      }\n      else {\n        trigonometric_value = (double)__kernel_cos(quadrant,q1,q2,q3);\n      }\n    }\n    else {\n      trigonometric_value = (double)__subdf3();\n    }\n    return trigonometric_value;\n  }\n  trigonometric_value = (double)__kernel_sin(low_bits,high_bits,0,0,0);\n  return trigonometric_value;\n}\n\n",
            "renaming": {
                "FUN_080096e8": "calculate_trigonometric_value_080096e8",
                "__x": "input_angle",
                "in_r0": "low_bits",
                "in_r1": "high_bits",
                "uVar1": "rem_pio2_result",
                "dVar2": "trigonometric_value",
                "local_28": "quadrant",
                "uStack_24": "q1",
                "local_20": "q2",
                "uStack_1c": "q3"
            },
            "calling": [
                "mc_arc"
            ],
            "called": [
                "__ieee754_rem_pio2",
                "__kernel_sin",
                "__kernel_cos",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009798": {
            "entrypoint": "0x08009798",
            "current_name": "calculate_exponent_08009798",
            "code": "\ndouble calculateExponent_08009798(double input)\n\n{\n  int shiftedInput;\n  int exponent;\n  double result;\n  \n  exponent = ((uint)(shiftedInput << 1) >> 0x15) - 0x3ff;\n  if (exponent < 0x14) {\n    if (exponent < 0) {\n      return result;\n    }\n  }\n  else {\n    if (exponent < 0x34) {\n      return result;\n    }\n    if (exponent != 0x400) {\n      return result;\n    }\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009798": "calculate_exponent_08009798",
                "__x": "input",
                "in_r1": "shiftedInput",
                "iVar1": "exponent",
                "in_d0": "result"
            },
            "calling": [
                "gc_execute_line",
                "protocol_execute_line",
                "settings_store_global_setting"
            ],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009818": {
            "entrypoint": "0x08009818",
            "current_name": "FUN_08009818",
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) >> 0x1f) < 0x7ff00001) &&\n     (uVar4 = param_2 & 0x7fffffff, (uVar4 | (-param_1 | param_1) >> 0x1f) < 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != 0x7ff00000)) &&\n       (uVar4 != 0x7ff00000)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if (((int)(uVar4 - uVar3) < 0x3d00000) &&\n         ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2,param_3,param_4);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
            "renaming": {},
            "calling": [
                "mc_arc"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800981c": {
            "entrypoint": "0x0800981c",
            "current_name": "calculate_hypotenuse_0800981c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080098b6) */\n\ndouble calculate_hypotenuse_0800981c(double x,double y)\n\n{\n  int isValid;\n  undefined4 *errnoPtr;\n  double result;\n  double hypotenuse;\n  double hypotenuse_2;\n  double hypotenuse_3;\n  double final_hypotenuse;\n  double error_hypotenuse;\n  int value_1;\n  char *value_2;\n  \n  result = (double)__ieee754_hypot();\n  if ((((__fdlib_version != -1) &&\n       (isValid = finite((double)CONCAT44(value_2,value_1)), result = hypotenuse,\n       isValid == 0)) &&\n      (isValid = finite((double)CONCAT44(value_2,value_1)), result = hypotenuse_2\n      , isValid != 0)) &&\n     ((isValid = finite((double)CONCAT44(value_2,value_1)), result = hypotenuse_3\n      , isValid != 0 &&\n      (((__fdlib_version != '\\0' && (__fdlib_version == '\\x02')) ||\n       (isValid = matherr((exception *)&stack0xffffffb0), result = error_hypotenuse, isValid == 0)))))) {\n    errnoPtr = (undefined4 *)__errno();\n    *errnoPtr = 0x22;\n    result = final_hypotenuse;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800981c": "calculate_hypotenuse_0800981c",
                "__x": "x",
                "__y": "y",
                "iVar1": "isValid",
                "puVar2": "errnoPtr",
                "dVar3": "result",
                "extraout_d0": "hypotenuse",
                "extraout_d0_00": "hypotenuse_2",
                "extraout_d0_01": "hypotenuse_3",
                "extraout_d0_02": "final_hypotenuse",
                "extraout_d0_03": "error_hypotenuse",
                "in_stack_ffffffb0": "value_1",
                "in_stack_ffffffb4": "value_2"
            },
            "calling": [
                "gc_execute_line",
                "mc_arc"
            ],
            "called": [
                "__errno",
                "finite",
                "__ieee754_hypot",
                "matherr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098d0": {
            "entrypoint": "0x080098d0",
            "current_name": "calculate_sqrt_080098d0",
            "code": "\ndouble calculateSqrt_080098d0(double inputValue)\n\n{\n  char versionFlag;\n  int comparisonResult;\n  undefined4 *errnoPointer;\n  int *errorPointer;\n  double result;\n  double tempResult1;\n  double tempResult2;\n  double tempResult3;\n  double tempResult4;\n  double tempResult5;\n  undefined exceptionData [24];\n  undefined8 exceptionValue;\n  int exceptionCode;\n  \n  result = (double)__ieee754_sqrt();\n  versionFlag = __fdlib_version;\n  if (((__fdlib_version == -1) || (exceptionCode = __unorddf2(), result = tempResult1, exceptionCode != 0)) ||\n     (comparisonResult = __aeabi_dcmplt(), result = tempResult2, comparisonResult == 0)) {\n    return result;\n  }\n  exceptionData._0_4_ = 1;\n  exceptionData._4_4_ = \"sqrt\";\n  if (versionFlag == '\\0') {\n    exceptionValue = 0.0;\nLAB_0800996c:\n    comparisonResult = matherr((exception *)exceptionData);\n    result = tempResult4;\n    if (comparisonResult != 0) goto joined_r0x0800997a;\n  }\n  else {\n    exceptionValue = (double)__divdf3(0,0,0,0);\n    if (versionFlag != '\\x02') goto LAB_0800996c;\n  }\n  errnoPointer = (undefined4 *)__errno();\n  *errnoPointer = 0x21;\n  result = tempResult3;\njoined_r0x0800997a:\n  if (exceptionCode != 0) {\n    errorPointer = (int *)__errno();\n    *errorPointer = exceptionCode;\n    result = tempResult5;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080098d0": "calculate_sqrt_080098d0",
                "__x": "inputValue",
                "cVar1": "versionFlag",
                "iVar2": "comparisonResult",
                "puVar3": "errnoPointer",
                "piVar4": "errorPointer",
                "dVar5": "result",
                "extraout_d0": "tempResult1",
                "extraout_d0_00": "tempResult2",
                "extraout_d0_01": "tempResult3",
                "extraout_d0_02": "tempResult4",
                "extraout_d0_03": "tempResult5",
                "local_50": "exceptionData",
                "local_38": "exceptionValue",
                "local_30": "exceptionCode"
            },
            "calling": [
                "gc_execute_line",
                "homing_cycle",
                "max_allowable_speed",
                "plan_buffer_line"
            ],
            "called": [
                "__errno",
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__divdf3",
                "matherr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009990": {
            "entrypoint": "0x08009990",
            "current_name": "calculate_atan_08009990",
            "code": "\nvoid calculateAtan_08009990(uint input1,uint input2,uint input3,uint input4,double input5)\n\n{\n  int tempVar1;\n  undefined4 tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  undefined8 tempVar6;\n  \n  tempVar4 = input4 & 0x7fffffff;\n  if (((tempVar4 | (-input3 | input3) >> 0x1f) < 0x7ff00001) &&\n     (tempVar5 = input2 & 0x7fffffff, (tempVar5 | (-input1 | input1) >> 0x1f) < 0x7ff00001)) {\n    if ((input4 + 0xc0100000 | input3) == 0) {\n      atan(input5);\n      return;\n    }\n    tempVar3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n    if (((((tempVar5 | input1) != 0) && ((tempVar4 | input3) != 0)) && (tempVar4 != 0x7ff00000)) &&\n       (tempVar5 != 0x7ff00000)) {\n      tempVar1 = (int)(tempVar5 - tempVar4) >> 0x14;\n      if (((int)(tempVar5 - tempVar4) < 0x3d00000) &&\n         ((-1 < (int)input4 || (tempVar1 + 0x3c < 0 == SCARRY4(tempVar1,0x3c))))) {\n        __divdf3(input1,input2,input3,input4);\n        fabs((double)CONCAT44(tempVar2,input4));\n        atan((double)CONCAT44(tempVar2,input4));\n      }\n      if (tempVar3 != 1) {\n        if (tempVar3 == 2) {\n          tempVar6 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20));\n        }\n        else if (tempVar3 != 0) {\n          tempVar6 = __subdf3();\n          __subdf3((int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(input3,input4,input1,input2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009990": "calculate_atan_08009990",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "iVar1": "tempVar1",
                "unaff_r4": "tempVar2",
                "uVar2": "tempVar3",
                "uVar3": "tempVar4",
                "uVar4": "tempVar5",
                "uVar5": "tempVar6"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b24": {
            "entrypoint": "0x08009b24",
            "current_name": "calculate_square_root_08009b24",
            "code": "\nuint calculateSquareRoot_08009b24(uint inputA,uint inputB,uint inputC,uint inputD)\n\n{\n  undefined4 result1;\n  int comparisonResult;\n  uint result2;\n  int result2Int;\n  undefined4 result3;\n  int result3Int;\n  uint maxValue;\n  undefined4 upperPart1;\n  undefined4 lowerPart1;\n  undefined8 upperPart2;\n  undefined8 lowerPart2;\n  undefined8 result4;\n  undefined8 result5;\n  int shiftCount;\n  \n  inputB = inputB & 0x7fffffff;\n  inputD = inputD & 0x7fffffff;\n  result2 = inputA;\n  maxValue = inputB;\n  if (inputB < inputD) {\n    result2 = inputC;\n    inputC = inputA;\n    maxValue = inputD;\n    inputD = inputB;\n  }\n  if (0x3c00000 < (int)(maxValue - inputD)) {\n    result2 = __aeabi_dadd(result2,maxValue,inputC,inputD);\n    return result2;\n  }\n  if (maxValue < 0x5f300001) {\n    shiftCount = 0;\n  }\n  else {\n    if (0x7fefffff < maxValue) {\n      if ((maxValue & 0xfffff | result2) != 0) {\n        result2 = __aeabi_dadd(result2,maxValue,inputC,inputD);\n      }\n      if ((inputD ^ 0x7ff00000 | inputC) != 0) {\n        return result2;\n      }\n      return inputC;\n    }\n    maxValue = maxValue + 0xda800000;\n    inputD = inputD + 0xda800000;\n    shiftCount = 600;\n  }\n  lowerPart2 = CONCAT44(maxValue,result2);\n  upperPart2 = CONCAT44(inputD,inputC);\n  if ((int)inputD < 0x20b00000) {\n    if ((int)inputD < 0x100000) {\n      if ((inputD | inputC) == 0) {\n        return result2;\n      }\n      upperPart2 = __muldf3(inputC,inputD,0,0x7fd00000);\n      lowerPart2 = __muldf3(result2,maxValue,0,0x7fd00000);\n      shiftCount = shiftCount + -0x3fe;\n    }\n    else {\n      maxValue = maxValue + 0x25800000;\n      lowerPart2 = CONCAT44(maxValue,result2);\n      inputD = inputD + 0x25800000;\n      upperPart2 = CONCAT44(inputD,inputC);\n      shiftCount = shiftCount + -600;\n    }\n  }\n  lowerPart1 = (undefined4)((ulonglong)lowerPart2 >> 0x20);\n  upperPart1 = (undefined4)lowerPart2;\n  result3Int = (int)((ulonglong)upperPart2 >> 0x20);\n  result3 = (undefined4)upperPart2;\n  upperPart2 = __subdf3(upperPart1,lowerPart1,result3,result3Int);\n  result2Int = (int)((ulonglong)upperPart2 >> 0x20);\n  result1 = (undefined4)upperPart2;\n  comparisonResult = __aeabi_dcmplt(result3,result3Int,result1,result2Int);\n  if (comparisonResult == 0) {\n    upperPart2 = __muldf3(0,inputD,0);\n    lowerPart2 = __muldf3(result1,result2Int + -0x80000000,result1,result2Int);\n    result4 = __aeabi_dadd(upperPart1,lowerPart1,upperPart1,lowerPart1);\n    result4 = __subdf3((int)result4,(int)((ulonglong)result4 >> 0x20),0,maxValue + 0x100000);\n    result4 = __muldf3((int)result4,(int)((ulonglong)result4 >> 0x20),result3,result3Int);\n    result5 = __subdf3(result3,result3Int,0,inputD);\n    result5 = __muldf3((int)result5,(int)((ulonglong)result5 >> 0x20),0,maxValue + 0x100000);\n    result4 = __aeabi_dadd((int)result4,(int)((ulonglong)result4 >> 0x20),(int)result5,\n                          (int)((ulonglong)result5 >> 0x20));\n    lowerPart2 = __subdf3((int)lowerPart2,(int)((ulonglong)lowerPart2 >> 0x20),(int)result4,\n                      (int)((ulonglong)result4 >> 0x20));\n    __subdf3((int)upperPart2,(int)((ulonglong)upperPart2 >> 0x20),(int)lowerPart2,\n             (int)((ulonglong)lowerPart2 >> 0x20));\n    upperPart2 = __ieee754_sqrt();\n  }\n  else {\n    upperPart2 = __muldf3(0,maxValue,0,maxValue);\n    lowerPart2 = __muldf3(result3,result3Int + -0x80000000,result3,result3Int);\n    result4 = __aeabi_dadd(upperPart1,lowerPart1,0,maxValue);\n    result5 = __subdf3(upperPart1,lowerPart1,0,maxValue);\n    result4 = __muldf3((int)result4,(int)((ulonglong)result4 >> 0x20),(int)result5,\n                      (int)((ulonglong)result5 >> 0x20));\n    lowerPart2 = __subdf3((int)lowerPart2,(int)((ulonglong)lowerPart2 >> 0x20),(int)result4,\n                      (int)((ulonglong)result4 >> 0x20));\n    __subdf3((int)upperPart2,(int)((ulonglong)upperPart2 >> 0x20),(int)lowerPart2,\n             (int)((ulonglong)lowerPart2 >> 0x20));\n    upperPart2 = __ieee754_sqrt();\n  }\n  result2 = (uint)upperPart2;\n  if (shiftCount != 0) {\n    result2 = __muldf3(result2,(int)((ulonglong)upperPart2 >> 0x20),0,shiftCount * 0x100000 + 0x3ff00000);\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_08009b24": "calculate_square_root_08009b24",
                "param_1": "inputA",
                "param_2": "inputB",
                "param_3": "inputC",
                "param_4": "inputD",
                "uVar1": "result1",
                "iVar2": "comparisonResult",
                "uVar3": "result2",
                "iVar4": "result2Int",
                "uVar5": "result3",
                "iVar6": "result3Int",
                "uVar7": "maxValue",
                "uVar8": "upperPart1",
                "uVar9": "lowerPart1",
                "uVar10": "upperPart2",
                "uVar11": "lowerPart2",
                "uVar12": "result4",
                "uVar13": "result5",
                "local_3c": "shiftCount"
            },
            "calling": [
                "hypot"
            ],
            "called": [
                "__muldf3",
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d78": {
            "entrypoint": "0x08009d78",
            "current_name": "calculate_double_08009d78",
            "code": "\nint calculateDouble_08009d78(undefined4 inputDouble,uint inputUint,undefined8 *outputArray)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  undefined4 temp7;\n  undefined4 temp8;\n  uint absInputUint;\n  int result;\n  undefined8 temp9;\n  undefined8 temp10;\n  undefined8 temp11;\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  undefined4 temp12;\n  undefined4 temp13;\n  undefined8 temp14;\n  undefined8 temp15;\n  undefined8 temp16;\n  \n  absInputUint = inputUint & 0x7fffffff;\n  if (absInputUint < 0x3fe921fc) {\n    *(undefined4 *)outputArray = inputDouble;\n    *(uint *)((int)outputArray + 4) = inputUint;\n    *(undefined4 *)(outputArray + 1) = 0;\n    *(undefined4 *)((int)outputArray + 0xc) = 0;\n    return 0;\n  }\n  if (absInputUint < 0x4002d97c) {\n    if ((int)inputUint < 1) {\n      temp9 = __aeabi_dadd(inputDouble,inputUint,0x54400000,0x3ff921fb);\n      temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n      temp1 = (undefined4)temp9;\n      if (absInputUint != 0x3ff921fb) {\n        temp9 = __aeabi_dadd(temp1,temp2,0x1a626331,0x3dd0b461);\n        *outputArray = temp9;\n        temp9 = __subdf3(temp1,temp2);\n        temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x1a626331,0x3dd0b461);\n        outputArray[1] = temp9;\n        return -1;\n      }\n      temp9 = __aeabi_dadd(temp1,temp2,0x1a600000,0x3dd0b461);\n      temp1 = (undefined4)((ulonglong)temp9 >> 0x20);\n      temp10 = __aeabi_dadd((int)temp9,temp1,0x2e037073,0x3ba3198a);\n      *outputArray = temp10;\n      temp9 = __subdf3((int)temp9,temp1);\n      temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x2e037073,0x3ba3198a);\n      outputArray[1] = temp9;\n      return -1;\n    }\n    temp9 = __subdf3();\n    temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp1 = (undefined4)temp9;\n    if (absInputUint != 0x3ff921fb) {\n      temp9 = __subdf3(temp1,temp2,0x1a626331,0x3dd0b461);\n      *outputArray = temp9;\n      temp9 = __subdf3(temp1,temp2);\n      temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x1a626331,0x3dd0b461);\n      outputArray[1] = temp9;\n      return 1;\n    }\n    temp9 = __subdf3(temp1,temp2,0x1a600000,0x3dd0b461);\n    temp1 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp10 = __subdf3((int)temp9,temp1,0x2e037073,0x3ba3198a);\n    *outputArray = temp10;\n    temp9 = __subdf3((int)temp9,temp1);\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x2e037073,0x3ba3198a);\n    outputArray[1] = temp9;\n    return 1;\n  }\n  if (0x413921fb < absInputUint) {\n    if (0x7fefffff < absInputUint) {\n      temp9 = __subdf3(inputDouble,inputUint,inputDouble,inputUint);\n      outputArray[1] = temp9;\n      *outputArray = temp9;\n      return 0;\n    }\n    result = ((int)absInputUint >> 0x14) + -0x416;\n    __aeabi_d2iz();\n    temp14 = __aeabi_i2d();\n    temp9 = __subdf3(inputDouble,absInputUint + result * -0x100000,(int)temp14,\n                      (int)((ulonglong)temp14 >> 0x20));\n    temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x41700000);\n    __aeabi_d2iz();\n    temp15 = __aeabi_i2d();\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20));\n    temp16 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x41700000);\n    __aeabi_dcmpeq((int)temp16,(int)((ulonglong)temp16 >> 0x20),0,0);\n    result = __kernel_rem_pio2(&temp14,outputArray,result);\n    if (-1 < (int)inputUint) {\n      return result;\n    }\n    *(int *)((int)outputArray + 4) = *(int *)((int)outputArray + 4) + -0x80000000;\n    *(int *)((int)outputArray + 0xc) = *(int *)((int)outputArray + 0xc) + -0x80000000;\n    return -result;\n  }\n  fabs((double)CONCAT44(stackVar2,stackVar1));\n  temp9 = __muldf3();\n  __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x3fe00000);\n  result = __aeabi_d2iz();\n  temp9 = __aeabi_i2d();\n  temp5 = (undefined4)((ulonglong)temp9 >> 0x20);\n  temp1 = (undefined4)temp9;\n  temp9 = __muldf3(temp1,temp5,0x54400000,0x3ff921fb);\n  temp9 = __subdf3(inputDouble,temp4,(int)temp9,(int)((ulonglong)temp9 >> 0x20));\n  temp6 = (undefined4)((ulonglong)temp9 >> 0x20);\n  temp2 = (undefined4)temp9;\n  temp10 = __muldf3(temp1,temp5,0x1a626331,0x3dd0b461);\n  if ((0x1f < result) || (*(uint *)(&npio2_hw + (result + -1) * 4) == absInputUint)) {\n    temp11 = __subdf3(temp2,temp6,(int)temp10,(int)((ulonglong)temp10 >> 0x20));\n    if ((int)((absInputUint >> 0x14) - ((uint)((int)((ulonglong)temp11 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    temp10 = __muldf3(temp1,temp5,0x1a600000,0x3dd0b461);\n    temp7 = (undefined4)((ulonglong)temp10 >> 0x20);\n    temp9 = __subdf3(temp2,temp6,(int)temp10,temp7);\n    temp8 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp3 = (undefined4)temp9;\n    temp11 = __subdf3(temp2,temp6,temp3,temp8);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,temp7);\n    temp11 = __muldf3(temp1,temp5,0x2e037073,0x3ba3198a);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,\n                      (int)((ulonglong)temp10 >> 0x20));\n    temp11 = __subdf3(temp3,temp8,(int)temp10,(int)((ulonglong)temp10 >> 0x20));\n    if ((int)(((int)absInputUint >> 0x14) - ((uint)((int)((ulonglong)temp11 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    temp10 = __muldf3(temp1,temp5,0x2e000000,0x3ba3198a);\n    temp2 = (undefined4)((ulonglong)temp10 >> 0x20);\n    temp9 = __subdf3(temp3,temp8,(int)temp10,temp2);\n    temp11 = __subdf3(temp3,temp8);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,temp2);\n    temp11 = __muldf3(temp1,temp5,0x252049c1,0x397b839a);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,\n                      (int)((ulonglong)temp10 >> 0x20));\n  }\n  temp11 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                    (int)((ulonglong)temp10 >> 0x20));\nLAB_0800a0ce:\n  temp13 = (undefined4)((ulonglong)temp9 >> 0x20);\n  temp12 = (undefined4)temp9;\n  *outputArray = temp11;\n  temp9 = __subdf3(temp12,temp13);\n  temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                    (int)((ulonglong)temp10 >> 0x20));\n  outputArray[1] = temp9;\n  if ((int)inputUint < 0) {\n    *(int *)outputArray = (int)temp11;\n    *(int *)((int)outputArray + 4) = (int)((ulonglong)temp11 >> 0x20) + -0x80000000;\n    *(int *)(outputArray + 1) = (int)temp9;\n    *(int *)((int)outputArray + 0xc) = (int)((ulonglong)temp9 >> 0x20) + -0x80000000;\n    result = -result;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009d78": "calculate_double_08009d78",
                "param_1": "inputDouble",
                "param_2": "inputUint",
                "param_3": "outputArray",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "extraout_r1": "temp4",
                "uVar4": "temp5",
                "uVar5": "temp6",
                "uVar6": "temp7",
                "uVar7": "temp8",
                "uVar8": "absInputUint",
                "iVar9": "result",
                "uVar10": "temp9",
                "uVar11": "temp10",
                "uVar12": "temp11",
                "in_stack_ffffffa8": "stackVar1",
                "in_stack_ffffffac": "stackVar2",
                "local_50": "temp12",
                "uStack_4c": "temp13",
                "local_40": "temp14",
                "local_38": "temp15",
                "local_30": "temp16"
            },
            "calling": [
                "sin",
                "cos"
            ],
            "called": [
                "__muldf3",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__kernel_rem_pio2",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a1bc": {
            "entrypoint": "0x0800a1bc",
            "current_name": "calculate_sum_0800a1bc",
            "code": "\nuint calculateSum_0800a1bc(uint input1,uint input2)\n\n{\n  uint result1;\n  int count1;\n  uint result2;\n  undefined4 result3;\n  uint result4;\n  uint result5;\n  uint result6;\n  uint result7;\n  uint result8;\n  int count2;\n  uint result9;\n  uint result10;\n  undefined8 result11;\n  \n  if ((~input2 & 0x7ff00000) == 0) {\n    result11 = __muldf3(input1,input2,input1,input2);\n    result6 = __aeabi_dadd((int)result11,(int)((ulonglong)result11 >> 0x20),input1,input2);\n    return result6;\n  }\n  if ((int)input2 < 1) {\n    if ((input2 & 0x7fffffff | input1) == 0) {\n      return input1;\n    }\n    if (input2 != 0) {\n      result11 = __subdf3(input1,input2,input1);\n      result3 = (undefined4)((ulonglong)result11 >> 0x20);\n      result6 = __divdf3((int)result11,result3,(int)result11,result3);\n      return result6;\n    }\n    do {\n      result8 = input1;\n      result6 = result8 >> 0xb;\n      input2 = input2 - 0x15;\n      input1 = result8 << 0x15;\n    } while (result6 == 0);\n    result1 = input2;\n    if (-1 < (int)result8) goto LAB_0800a290;\n    result10 = 0x20;\n    result4 = 0xffffffff;\n    result8 = input1;\n  }\n  else {\n    result1 = (int)input2 >> 0x14;\n    result6 = input2;\n    result8 = input1;\n    if (result1 != 0) goto LAB_0800a1da;\nLAB_0800a290:\n    result8 = 0;\n    result10 = result6;\n    do {\n      result4 = result8;\n      result6 = result10 << 1;\n      count2 = result10 << 0xc;\n      result8 = result4 + 1;\n      result10 = result6;\n    } while (-1 < count2);\n    result10 = 0x20 - result8;\n    input2 = result1;\n    result8 = input1 << (result8 & 0xff);\n  }\n  result6 = input1 >> (result10 & 0xff) | result6;\n  result1 = input2 - result4;\nLAB_0800a1da:\n  result6 = result6 & 0xfffff | 0x100000;\n  if (-1 < (int)(result1 << 0x1f)) {\n    result6 = result6 * 2 - ((int)result8 >> 0x1f);\n    result8 = result8 << 1;\n  }\n  result10 = 0;\n  result6 = result6 * 2 - ((int)result8 >> 0x1f);\n  result8 = result8 << 1;\n  result1 = 0;\n  count2 = 0x16;\n  result4 = 0x200000;\n  do {\n    count1 = result1 + result4;\n    if (count1 <= (int)result6) {\n      result6 = result6 - count1;\n      result1 = count1 + result4;\n      result10 = result10 + result4;\n    }\n    count2 = count2 + -1;\n    result6 = result6 * 2 - ((int)result8 >> 0x1f);\n    result4 = result4 >> 1;\n    result8 = result8 << 1;\n  } while (count2 != 0);\n  count1 = 0x20;\n  result5 = 0x80000000;\n  count2 = 0;\n  result4 = 0;\n  do {\n    result2 = result5 + count2;\n    result9 = result1;\n    if ((int)result1 < (int)result6) {\n      if ((int)result2 < 0) {\nLAB_0800a26a:\n        if (-1 < (int)(result2 + result5)) {\n          result9 = result1 + 1;\n        }\n      }\n      result7 = result6 - result1;\n      result1 = result9;\n      if (result8 < result2) {\n        result7 = result7 - 1;\n      }\nLAB_0800a262:\n      count2 = result2 + result5;\n      result8 = result8 - result2;\n      result4 = result4 + result5;\n      result6 = result7;\n    }\n    else if ((result6 == result1) && (result2 <= result8)) {\n      if ((int)result2 < 0) goto LAB_0800a26a;\n      result7 = 0;\n      result1 = result6;\n      goto LAB_0800a262;\n    }\n    count1 = count1 + -1;\n    result5 = result5 >> 1;\n    result6 = result6 * 2 - ((int)result8 >> 0x1f);\n    result8 = result8 << 1;\n    if (count1 == 0) {\n      if ((result6 | result8) == 0) {\n        result4 = result4 >> 1;\n      }\n      else if (result4 == 0xffffffff) {\n        result10 = result10 + 1;\n        result4 = 0;\n      }\n      else {\n        result4 = result4 + 1 >> 1;\n      }\n      if ((result10 & 1) != 0) {\n        result4 = result4 | 0x80000000;\n      }\n      return result4;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800a1bc": "calculate_sum_0800a1bc",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "iVar2": "count1",
                "uVar3": "result2",
                "uVar4": "result3",
                "uVar5": "result4",
                "uVar6": "result5",
                "uVar7": "result6",
                "uVar8": "result7",
                "uVar9": "result8",
                "iVar10": "count2",
                "uVar11": "result9",
                "uVar12": "result10",
                "uVar13": "result11"
            },
            "calling": [
                "sqrt",
                "__ieee754_hypot"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a348": {
            "entrypoint": "0x0800a348",
            "current_name": "calculate_inverse_0800a348",
            "code": "\nundefined4 calculate_inverse_0800a348(undefined4 dividend,uint divisor,undefined4 numerator,undefined4 denominator)\n\n{\n  int is_zero;\n  undefined4 dividend_low;\n  undefined4 dividend_high;\n  uint abs_divisor;\n  undefined8 result1_high;\n  undefined8 result1_low;\n  undefined8 result2;\n  undefined4 result2_high;\n  undefined4 result2_low;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  \n  abs_divisor = divisor & 0x7fffffff;\n  if (abs_divisor < 0x3e400000) {\n    is_zero = __aeabi_d2iz();\n    if (is_zero == 0) {\n      return 0;\n    }\n    result1_high = __muldf3(dividend,divisor,dividend,divisor);\n    dividend_high = (undefined4)((ulonglong)result1_high >> 0x20);\n    dividend_low = (undefined4)result1_high;\n    result1_low = __muldf3(dividend_low,dividend_high,0xbe8838d4,0xbda8fae9);\n    result1_low = __aeabi_dadd((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0xbdb4b1c4,0x3e21ee9e);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __subdf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x809c52ad,0x3e927e4f);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __aeabi_dadd((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x19cb1590,0x3efa01a0);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __subdf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x16c15177,0x3f56c16c);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __aeabi_dadd((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x5555554c,0x3fa55555);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n  }\n  else {\n    result1_high = __muldf3(dividend,divisor,dividend,divisor);\n    dividend_high = (undefined4)((ulonglong)result1_high >> 0x20);\n    dividend_low = (undefined4)result1_high;\n    result1_low = __muldf3(dividend_low,dividend_high,0xbe8838d4,0xbda8fae9);\n    result1_low = __aeabi_dadd((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0xbdb4b1c4,0x3e21ee9e);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __subdf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x809c52ad,0x3e927e4f);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __aeabi_dadd((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x19cb1590,0x3efa01a0);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __subdf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x16c15177,0x3f56c16c);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    result1_low = __aeabi_dadd((int)result1_low,(int)((ulonglong)result1_low >> 0x20),0x5555554c,0x3fa55555);\n    result1_low = __muldf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),dividend_low,dividend_high);\n    if (0x3fd33332 < abs_divisor) {\n      if (abs_divisor < 0x3fe90001) {\n        is_zero = abs_divisor - 0x200000;\n        result1_high = __subdf3(0,0x3ff00000,0,is_zero);\n      }\n      else {\n        is_zero = 0x3fd20000;\n        result1_high = 0x3fe7000000000000;\n      }\n      uStack_24 = (undefined4)((ulonglong)result1_high >> 0x20);\n      uStack_28 = (undefined4)result1_high;\n      result1_high = __muldf3(dividend_low,dividend_high,0,0x3fe00000);\n      result1_high = __subdf3((int)result1_high,(int)((ulonglong)result1_high >> 0x20),0,is_zero);\n      result1_low = __muldf3(dividend_low,dividend_high,(int)result1_low,(int)((ulonglong)result1_low >> 0x20));\n      result2 = __muldf3(dividend,divisor,numerator,denominator);\n      result1_low = __subdf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),(int)result2,\n                       (int)((ulonglong)result2 >> 0x20));\n      result1_high = __subdf3((int)result1_high,(int)((ulonglong)result1_high >> 0x20),(int)result1_low,\n                       (int)((ulonglong)result1_low >> 0x20));\n      dividend_low = __subdf3(uStack_28,uStack_24,(int)result1_high,(int)((ulonglong)result1_high >> 0x20));\n      return dividend_low;\n    }\n  }\n  result2_low = (undefined4)((ulonglong)result1_low >> 0x20);\n  result2_high = (undefined4)result1_low;\n  dividend_low = (undefined4)((ulonglong)result1_high >> 0x20);\n  result1_low = __muldf3((int)result1_high,dividend_low,0,0x3fe00000);\n  result1_high = __muldf3((int)result1_high,dividend_low,result2_high,result2_low);\n  result2 = __muldf3(dividend,divisor,numerator,denominator);\n  result1_high = __subdf3((int)result1_high,(int)((ulonglong)result1_high >> 0x20),(int)result2,\n                   (int)((ulonglong)result2 >> 0x20));\n  result1_high = __subdf3((int)result1_low,(int)((ulonglong)result1_low >> 0x20),(int)result1_high,\n                   (int)((ulonglong)result1_high >> 0x20));\n  dividend_low = __subdf3(0,0x3ff00000,(int)result1_high,(int)((ulonglong)result1_high >> 0x20));\n  return dividend_low;\n}\n\n",
            "renaming": {
                "FUN_0800a348": "calculate_inverse_0800a348",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "numerator",
                "param_4": "denominator",
                "iVar1": "is_zero",
                "uVar2": "dividend_low",
                "uVar3": "dividend_high",
                "uVar4": "abs_divisor",
                "uVar5": "result1_high",
                "uVar6": "result1_low",
                "uVar7": "result2",
                "local_30": "result2_high",
                "uStack_2c": "result2_low",
                "local_28": "uStack_28"
            },
            "calling": [
                "sin",
                "cos"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a5a0": {
            "entrypoint": "0x0800a5a0",
            "current_name": "calculate_result_0800a5a0",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint calculateResult_0800a5a0(int input,undefined8 *output,int size,int dataOffset,int calculationType,int calculationData)\n\n{\n  undefined4 *ptr1;\n  uint result;\n  undefined4 value1;\n  uint value2;\n  undefined4 temp;\n  int index;\n  uint *ptr2;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  uint **ptrArray;\n  int calculationOffset;\n  int innerIndex;\n  undefined4 *innerPtr;\n  undefined4 innerValue1;\n  uint innerValue2;\n  uint *innerPtr2;\n  int innerIndex2;\n  int init_jk_value;\n  undefined8 *outerPtr;\n  undefined8 *outerPtr2;\n  undefined8 *tempPtr1;\n  undefined4 *tempPtr2;\n  undefined8 *tempPtr3;\n  undefined4 tempValue1;\n  int outerIndex;\n  undefined4 *presult4;\n  bool bVar25;\n  undefined8 result6;\n  undefined8 result7;\n  undefined8 result8;\n  undefined4 in_stack_fffffd78;\n  int local_280;\n  int local_26c;\n  uint *local_260 [2];\n  uint local_258 [20];\n  undefined8 tempValue3;\n  undefined4 tempResult1;\n  undefined4 tempResult2;\n  undefined8 tempResult3;\n  undefined8 tempValue4;\n  \n  init_jk_value = *(int *)(&init_jk + calculationType * 4);\n  calculationOffset = dataOffset + -1;\n  local_260[1] = (uint *)output;\n  if (size + 0x14 < 0 == SCARRY4(size,0x14)) {\n    local_26c = (size + -3) / 0x18;\n    innerIndex = (local_26c + 1) * -0x18;\n  }\n  else {\n    innerIndex = -0x18;\n    local_26c = 0;\n  }\n  size = size + innerIndex;\n  innerIndex = local_26c - calculationOffset;\n  if (-1 < init_jk_value + calculationOffset) {\n    outerIndex = init_jk_value + calculationOffset + 1 + innerIndex;\n    tempPtr1 = &tempValue3;\n    do {\n      while (innerIndex < 0) {\n        innerIndex = innerIndex + 1;\n        *(undefined4 *)tempPtr1 = 0;\n        *(undefined4 *)((int)tempPtr1 + 4) = 0;\n        tempPtr1 = tempPtr1 + 1;\n        if (innerIndex == outerIndex) goto LAB_0800a626;\n      }\n      result7 = __aeabi_i2d(*(undefined4 *)(calculationData + innerIndex * 4));\n      innerIndex = innerIndex + 1;\n      *tempPtr1 = result7;\n      tempPtr1 = tempPtr1 + 1;\n    } while (innerIndex != outerIndex);\n  }\nLAB_0800a626:\n  innerPtr = (undefined4 *)(input + -8);\n  if (-1 < init_jk_value) {\n    outerPtr = &tempValue3 + dataOffset;\n    outerIndex = init_jk_value + dataOffset;\n    innerIndex = calculationOffset;\n    tempPtr1 = &tempValue4;\n    do {\n      if (calculationOffset < 0) {\n        result7 = 0;\n      }\n      else {\n        result7 = 0;\n        presult4 = innerPtr;\n        tempPtr3 = outerPtr;\n        do {\n          tempPtr2 = presult4 + 2;\n          result6 = __muldf3(*tempPtr2,presult4[3],*(undefined4 *)(tempPtr3 + -1),\n                            *(undefined4 *)((int)tempPtr3 + -4));\n          result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                                (int)((ulonglong)result6 >> 0x20));\n          presult4 = tempPtr2;\n          tempPtr3 = tempPtr3 + -1;\n        } while (tempPtr2 != innerPtr + dataOffset * 2);\n      }\n      innerIndex = innerIndex + 1;\n      *tempPtr1 = result7;\n      outerPtr = outerPtr + 1;\n      tempPtr1 = tempPtr1 + 1;\n    } while (innerIndex != outerIndex);\n  }\n  local_260[0] = local_258 + init_jk_value + -1;\n  local_280 = init_jk_value;\n  do {\n    outerIndex = *(int *)(&tempValue4 + local_280);\n    result7 = CONCAT44(*(undefined4 *)((int)&tempValue4 + local_280 * 8 + 4),outerIndex);\n    innerIndex = local_280;\n    if (0 < local_280) {\n      tempPtr1 = &tempValue4 + local_280;\n      ptr2 = local_258;\n      do {\n        temp4 = (undefined4)((ulonglong)result7 >> 0x20);\n        __muldf3((int)result7,temp4,0,0x3e700000);\n        __aeabi_d2iz();\n        result6 = __aeabi_i2d();\n        value1 = (undefined4)((ulonglong)result6 >> 0x20);\n        result8 = __muldf3((int)result6,value1,0,0x41700000);\n        __subdf3((int)result7,temp4,(int)result8,(int)((ulonglong)result8 >> 0x20));\n        result = __aeabi_d2iz();\n        outerPtr = tempPtr1 + -1;\n        temp4 = *(undefined4 *)outerPtr;\n        innerValue1 = *(undefined4 *)((int)tempPtr1 + -4);\n        *ptr2 = result;\n        result7 = __aeabi_dadd((int)result6,value1,temp4,innerValue1);\n        outerIndex = (int)result7;\n        tempPtr1 = outerPtr;\n        ptr2 = ptr2 + 1;\n      } while (outerPtr != &tempValue4);\n    }\n    scalbn((double)CONCAT44(innerIndex,in_stack_fffffd78),outerIndex);\n    __muldf3();\n    floor((double)CONCAT44(innerIndex,in_stack_fffffd78));\n    result7 = __muldf3();\n    result7 = __subdf3(outerIndex,temp,(int)result7,(int)((ulonglong)result7 >> 0x20));\n    result = __aeabi_d2iz();\n    result6 = __aeabi_i2d();\n    result7 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                      (int)((ulonglong)result6 >> 0x20));\n    temp4 = (undefined4)((ulonglong)result7 >> 0x20);\n    value1 = (undefined4)result7;\n    if (size < 1) {\n      if (size == 0) {\n        outerIndex = (int)local_258[innerIndex + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      outerIndex = __aeabi_dcmpge(value1,temp4,0,0x3fe00000);\n      if (outerIndex != 0) {\n        result = result + 1;\n        if (innerIndex < 1) {\n          result7 = __subdf3(0,0x3ff00000,value1,temp4);\n          outerIndex = 2;\n          goto LAB_0800a7a4;\n        }\n        outerIndex = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      index = (int)local_258[innerIndex + -1] >> (0x18U - size & 0xff);\n      innerValue2 = local_258[innerIndex + -1] - (index << (0x18U - size & 0xff));\n      outerIndex = (int)innerValue2 >> (0x17U - size & 0xff);\n      local_258[innerIndex + -1] = innerValue2;\n      result = result + index;\njoined_r0x0800a8b8:\n      if (0 < outerIndex) {\n        result = result + 1;\n        if (innerIndex < 1) {\n          bVar25 = false;\n        }\n        else {\nLAB_0800a8c8:\n          if (local_258[0] == 0) {\n            bVar25 = false;\n            if (innerIndex != 1) {\n              ptr2 = local_258;\n              index = 1;\n              do {\n                ptr2 = ptr2 + 1;\n                if (*ptr2 != 0) {\n                  innerIndex2 = index + 1;\n                  innerValue2 = *ptr2;\n                  goto LAB_0800a8e2;\n                }\n                index = index + 1;\n              } while (index != innerIndex);\n              bVar25 = false;\n            }\n          }\n          else {\n            innerIndex2 = 1;\n            index = 0;\n            innerValue2 = local_258[0];\nLAB_0800a8e2:\n            local_258[index] = 0x1000000 - innerValue2;\n            if (innerIndex2 < innerIndex) {\n              innerValue2 = local_258[innerIndex2];\n              ptr2 = local_258 + innerIndex2;\n              while( true ) {\n                innerPtr2 = ptr2 + 1;\n                *ptr2 = 0xffffff - innerValue2;\n                if (innerPtr2 == local_258 + innerIndex) break;\n                innerValue2 = *innerPtr2;\n                ptr2 = innerPtr2;\n              }\n            }\n            bVar25 = true;\n          }\n        }\n        if (0 < size) {\n          if (size == 1) {\n            local_258[innerIndex + -1] = local_258[innerIndex + -1] & 0x7fffff;\n          }\n          else if (size == 2) {\n            local_258[innerIndex + -1] = local_258[innerIndex + -1] & 0x3fffff;\n          }\n        }\n        if (outerIndex == 2) {\n          result7 = __subdf3(0,0x3ff00000,value1,temp4);\n          if (bVar25) {\n            value1 = 0;\n            scalbn((double)CONCAT44(innerIndex,in_stack_fffffd78),0);\n            result7 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),value1,temp1);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    innerIndex2 = (int)result7;\n    index = __aeabi_dcmpeq(innerIndex2,(int)((ulonglong)result7 >> 0x20),0,0);\n    if (index == 0) {\n      scalbn((double)CONCAT44(innerIndex,in_stack_fffffd78),innerIndex2);\n      calculationOffset = __aeabi_dcmpge();\n      if (calculationOffset == 0) {\n        index = innerIndex;\n        innerValue2 = __aeabi_d2iz(innerIndex2,temp3);\n        local_258[index] = innerValue2;\n        innerIndex = index;\n      }\n      else {\n        __muldf3(innerIndex2,temp3,0,0x3e700000);\n        innerValue2 = __aeabi_d2iz();\n        result7 = __aeabi_i2d();\n        result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),0,0x41700000);\n        __subdf3(innerIndex2,temp3,(int)result7,(int)((ulonglong)result7 >> 0x20));\n        calculationOffset = innerIndex;\n        value2 = __aeabi_d2iz();\n        index = innerIndex + 1;\n        local_258[innerIndex] = value2;\n        local_258[index] = innerValue2;\n        innerIndex = calculationOffset;\n      }\n      goto LAB_0800a9f6;\n    }\n    index = innerIndex + -1;\n    if (init_jk_value <= index) {\n      innerValue2 = 0;\n      ptr2 = local_258 + innerIndex + 0x3fffffff;\n      do {\n        innerPtr2 = ptr2 + -1;\n        innerValue2 = innerValue2 | *ptr2;\n        ptr2 = innerPtr2;\n      } while (innerPtr2 != local_260[0]);\n      if (innerValue2 != 0) break;\n    }\n    if (local_258[init_jk_value + -1] == 0) {\n      local_280 = 1;\n      ptrArray = local_260 + init_jk_value;\n      do {\n        ptr2 = *ptrArray;\n        local_280 = local_280 + 1;\n        ptrArray = ptrArray + -1;\n      } while (ptr2 == (uint *)0x0);\n      local_280 = innerIndex + local_280;\n    }\n    else {\n      local_280 = innerIndex + 1;\n    }\n    outerIndex = innerIndex + 1;\n    presult4 = (undefined4 *)(calculationData + (outerIndex + local_26c + 0x3fffffff) * 4);\n    tempPtr1 = &tempValue3 + innerIndex + dataOffset;\n    outerPtr = &tempValue4 + outerIndex;\n    do {\n      presult4 = presult4 + 1;\n      result7 = __aeabi_i2d(*presult4);\n      *tempPtr1 = result7;\n      tempPtr3 = tempPtr1 + 1;\n      if (calculationOffset < 0) {\n        result6 = 0;\n      }\n      else {\n        result6 = 0;\n        tempPtr2 = innerPtr;\n        while( true ) {\n          tempPtr1 = tempPtr1 + -1;\n          ptr1 = tempPtr2 + 2;\n          result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),*ptr1,tempPtr2[3]);\n          result6 = __aeabi_dadd((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result7,\n                                (int)((ulonglong)result7 >> 0x20));\n          if (ptr1 == innerPtr + dataOffset * 2) break;\n          result7 = *tempPtr1;\n          tempPtr2 = ptr1;\n        }\n      }\n      *outerPtr = result6;\n      outerIndex = outerIndex + 1;\n      tempPtr1 = tempPtr3;\n      outerPtr = outerPtr + 1;\n    } while (outerIndex <= local_280);\n  } while( true );\n  if (local_258[index] == 0) {\n    ptr2 = local_258 + innerIndex + 0x3ffffffe;\n    do {\n      innerValue2 = *ptr2;\n      index = index + -1;\n      ptr2 = ptr2 + -1;\n    } while (innerValue2 == 0);\n  }\nLAB_0800a9f6:\n  value1 = 0;\n  scalbn((double)CONCAT44(innerIndex,in_stack_fffffd78),0);\n  result7 = CONCAT44(temp2,value1);\n  if (index < 0) {\n    if (2 < calculationType) {\n      if (calculationType == 3) {\n        tempPtr1 = (undefined8 *)&tempResult1;\n        result7 = 0;\nLAB_0800abe4:\n        if (outerIndex == 0) {\n          value1 = *(undefined4 *)(tempPtr1 + 1);\n          temp4 = *(undefined4 *)((int)tempPtr1 + 0xc);\n          *local_260[1] = tempResult1;\n          *(undefined4 *)((int)local_260[1] + 4) = tempResult2;\n          *(undefined8 *)((int)local_260[1] + 0x10) = result7;\n          *(undefined4 *)((int)local_260[1] + 8) = value1;\n          *(undefined4 *)((int)local_260[1] + 0xc) = temp4;\n          return result & 7;\n        }\n        calculationOffset = *(int *)((int)tempPtr1 + 4);\n        *(int *)((int)local_260[1] + 0x10) = (int)result7;\n        init_jk_value = *(int *)((int)tempPtr1 + 0xc);\n        *(undefined4 *)((int)local_260[1] + 8) = *(undefined4 *)(tempPtr1 + 1);\n        *(int *)((int)local_260[1] + 0x14) = (int)((ulonglong)result7 >> 0x20) + -0x80000000;\n        value1 = *(undefined4 *)tempPtr1;\n        *(int *)((int)local_260[1] + 4) = calculationOffset + -0x80000000;\n        *(int *)((int)local_260[1] + 0xc) = init_jk_value + -0x80000000;\n        *local_260[1] = value1;\n        return result & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (calculationType < 1) {\n      if (calculationType != 0) goto LAB_0800ab0e;\n      result7 = 0;\nLAB_0800aafc:\n      calculationOffset = (int)((ulonglong)result7 >> 0x20);\n      if (outerIndex != 0) {\n        calculationOffset = calculationOffset + -0x80000000;\n      }\n      *local_260[1] = (int)result7;\n      *(int *)((int)local_260[1] + 4) = calculationOffset;\nLAB_0800ab0e:\n      return result & 7;\n    }\n    result7 = 0;\n  }\n  else {\n    outerPtr = &tempValue4 + index;\n    ptr2 = local_258 + index + 1;\n    tempPtr1 = &tempValue4 + index + 1;\n    do {\n      value1 = (undefined4)((ulonglong)result7 >> 0x20);\n      ptr2 = ptr2 + -1;\n      result6 = __aeabi_i2d(*ptr2);\n      result6 = __muldf3((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result7,value1);\n      tempPtr1 = tempPtr1 + -1;\n      *tempPtr1 = result6;\n      result7 = __muldf3((int)result7,value1,0,0x3e700000);\n    } while (ptr2 != local_258);\n    tempPtr1 = (undefined8 *)&tempResult1;\n    calculationOffset = 0;\n    do {\n      if (init_jk_value < 0) {\n        result7 = 0;\n      }\n      else {\n        value1 = 0x40000000;\n        temp4 = 0x3ff921fb;\n        result7 = 0;\n        innerIndex = 0;\n        tempPtr3 = outerPtr;\n        innerPtr = &DAT_0800c028;\n        while( true ) {\n          result6 = __muldf3(*(undefined4 *)tempPtr3,*(undefined4 *)((int)tempPtr3 + 4),value1,temp4);\n          result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                                (int)((ulonglong)result6 >> 0x20));\n          innerIndex = innerIndex + 1;\n          if ((init_jk_value < innerIndex) || (calculationOffset < innerIndex)) break;\n          value1 = *innerPtr;\n          temp4 = innerPtr[1];\n          tempPtr3 = tempPtr3 + 1;\n          innerPtr = innerPtr + 2;\n        }\n      }\n      bVar25 = calculationOffset != index;\n      tempPtr1[calculationOffset] = result7;\n      outerPtr = outerPtr + -1;\n      calculationOffset = calculationOffset + 1;\n    } while (bVar25);\n    if (2 < calculationType) {\n      if (calculationType == 3) {\n        if (index != 0) {\n          outerPtr = tempPtr1 + index;\n          result7 = *outerPtr;\n          do {\n            temp4 = (undefined4)((ulonglong)result7 >> 0x20);\n            value1 = (undefined4)result7;\n            innerValue1 = *(undefined4 *)(outerPtr + -1);\n            tempValue1 = *(undefined4 *)((int)outerPtr + -4);\n            result7 = __aeabi_dadd(value1,temp4,innerValue1,tempValue1);\n            result6 = __subdf3(innerValue1,tempValue1,(int)result7,(int)((ulonglong)result7 >> 0x20));\n            result6 = __aeabi_dadd((int)result6,(int)((ulonglong)result6 >> 0x20),value1,temp4);\n            *outerPtr = result6;\n            outerPtr = outerPtr + -1;\n            *outerPtr = result7;\n          } while (tempPtr1 != outerPtr);\n          if (1 < index) {\n            tempPtr3 = tempPtr1 + index;\n            result7 = *tempPtr3;\n            outerPtr = tempPtr3;\n            do {\n              temp4 = (undefined4)((ulonglong)result7 >> 0x20);\n              value1 = (undefined4)result7;\n              innerValue1 = *(undefined4 *)(outerPtr + -1);\n              tempValue1 = *(undefined4 *)((int)outerPtr + -4);\n              result7 = __aeabi_dadd(value1,temp4,innerValue1,tempValue1);\n              result6 = __subdf3(innerValue1,tempValue1,(int)result7,(int)((ulonglong)result7 >> 0x20));\n              result6 = __aeabi_dadd((int)result6,(int)((ulonglong)result6 >> 0x20),value1,temp4);\n              *outerPtr = result6;\n              outerPtr = outerPtr + -1;\n              *outerPtr = result7;\n            } while (&tempResult3 != outerPtr);\n            result7 = 0;\n            outerPtr2 = tempPtr1 + 2;\n            outerPtr = tempPtr3 + 1;\n            do {\n              tempPtr3 = outerPtr + -1;\n              result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),\n                                    *(undefined4 *)tempPtr3,*(undefined4 *)((int)outerPtr + -4));\n              outerPtr = tempPtr3;\n            } while (outerPtr2 != tempPtr3);\n            goto LAB_0800abe4;\n          }\n        }\n        result7 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (calculationType < 1) {\n      if (calculationType != 0) goto LAB_0800ab0e;\n      result7 = 0;\n      outerPtr = tempPtr1 + index + 1;\n      do {\n        tempPtr3 = outerPtr + -1;\n        result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),*(undefined4 *)tempPtr3,\n                              *(undefined4 *)((int)outerPtr + -4));\n        outerPtr = tempPtr3;\n      } while (tempPtr1 != tempPtr3);\n      goto LAB_0800aafc;\n    }\n    result7 = 0;\n    outerPtr = tempPtr1 + index + 1;\n    do {\n      tempPtr3 = outerPtr + -1;\n      result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),*(undefined4 *)tempPtr3,\n                            *(undefined4 *)((int)outerPtr + -4));\n      outerPtr = tempPtr3;\n    } while (tempPtr1 != tempPtr3);\n  }\n  calculationOffset = (int)((ulonglong)result7 >> 0x20);\n  value1 = (undefined4)result7;\n  if (outerIndex == 0) {\n    *(undefined8 *)local_260[1] = result7;\n    result7 = __subdf3(tempResult1,tempResult2,value1,calculationOffset);\n    if (index < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    calculationOffset = 1;\n    tempPtr1 = (undefined8 *)&tempResult1;\n    do {\n      result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),\n                            *(undefined4 *)(tempPtr1 + 1),*(undefined4 *)((int)tempPtr1 + 0xc));\n      calculationOffset = calculationOffset + 1;\n      tempPtr1 = tempPtr1 + 1;\n    } while (calculationOffset <= index);\n    if (outerIndex == 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_260[1] = value1;\n    *(int *)((int)local_260[1] + 4) = calculationOffset + -0x80000000;\n    result7 = __subdf3(tempResult1,tempResult2,value1,calculationOffset);\n    if (0 < index) goto LAB_0800ad04;\n  }\n  result7 = CONCAT44((int)((ulonglong)result7 >> 0x20) + -0x80000000,(int)result7);\nLAB_0800ad26:\n  *(undefined8 *)((int)local_260[1] + 8) = result7;\n  return result & 7;\n}\n\n",
            "renaming": {
                "FUN_0800a5a0": "calculate_result_0800a5a0",
                "param_1": "input",
                "param_2": "output",
                "param_3": "size",
                "param_4": "dataOffset",
                "param_5": "calculationType",
                "param_6": "calculationData",
                "puVar1": "ptr1",
                "uVar2": "result",
                "uVar3": "value1",
                "uVar4": "value2",
                "extraout_r1": "temp",
                "iVar5": "index",
                "puVar6": "ptr2",
                "extraout_r1_00": "temp1",
                "extraout_r1_01": "temp2",
                "extraout_r1_02": "temp3",
                "uVar7": "temp4",
                "ppuVar8": "ptrArray",
                "iVar9": "calculationOffset",
                "iVar10": "innerIndex",
                "puVar11": "innerPtr",
                "uVar12": "innerValue1",
                "uVar13": "innerValue2",
                "puVar14": "innerPtr2",
                "iVar15": "innerIndex2",
                "iVar16": "init_jk_value",
                "iVar23": "outerIndex",
                "puVar17": "outerPtr",
                "puVar18": "outerPtr2",
                "puVar19": "tempPtr1",
                "puVar20": "tempPtr2",
                "puVar21": "tempPtr3",
                "uVar22": "tempValue1",
                "uStack_208": "tempValue3",
                "local_168": "tempResult1",
                "local_164": "tempResult2",
                "local_160": "tempResult3",
                "uStack_c8": "tempValue4"
            },
            "calling": [
                "__ieee754_rem_pio2"
            ],
            "called": [
                "__muldf3",
                "scalbn",
                "__aeabi_dcmpge",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800adf0": {
            "entrypoint": "0x0800adf0",
            "current_name": "calculate_0800adf0",
            "code": "\nundefined4\ncalculate_0800adf0(undefined4 input,uint multiplier,undefined4 constant1,undefined4 constant2,int flag)\n\n{\n  int convertedValue;\n  undefined4 result1_high;\n  undefined4 result1_low;\n  undefined4 result2_high;\n  undefined4 result2_low;\n  undefined4 temp_high;\n  undefined8 temp_low;\n  undefined8 temp2_high;\n  \n  if (((multiplier & 0x7fffffff) < 0x3e400000) && (convertedValue = __aeabi_d2iz(), convertedValue == 0)) {\n    return input;\n  }\n  temp_low = __muldf3(input,multiplier,input);\n  result2_high = (undefined4)((ulonglong)temp_low >> 0x20);\n  result1_low = (undefined4)temp_low;\n  temp_low = __muldf3(input,multiplier,result1_low,result2_high);\n  result2_low = (undefined4)((ulonglong)temp_low >> 0x20);\n  result1_high = (undefined4)temp_low;\n  temp_low = __muldf3(result1_low,result2_high,0x5acfd57c,0x3de5d93a);\n  temp_low = __subdf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),0x8a2b9ceb,0x3e5ae5e6);\n  temp_low = __muldf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),result1_low,result2_high);\n  temp_low = __aeabi_dadd((int)temp_low,(int)((ulonglong)temp_low >> 0x20),0x57b1fe7d,0x3ec71de3);\n  temp_low = __muldf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),result1_low,result2_high);\n  temp_low = __subdf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),0x19c161d5,0x3f2a01a0);\n  temp_low = __muldf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),result1_low,result2_high);\n  temp_low = __aeabi_dadd((int)temp_low,(int)((ulonglong)temp_low >> 0x20),0x1110f8a6,0x3f811111);\n  temp_high = (undefined4)((ulonglong)temp_low >> 0x20);\n  if (flag != 0) {\n    temp2_high = __muldf3(constant1,constant2,0,0x3fe00000);\n    temp_low = __muldf3(result1_high,result2_low,(int)temp_low,temp_high);\n    temp_low = __subdf3((int)temp2_high,(int)((ulonglong)temp2_high >> 0x20),(int)temp_low,\n                     (int)((ulonglong)temp_low >> 0x20));\n    temp_low = __muldf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),result1_low,result2_high);\n    temp_low = __subdf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),constant1,constant2);\n    temp2_high = __muldf3(result1_high,result2_low,0x55555549,0x3fc55555);\n    temp_low = __aeabi_dadd((int)temp_low,(int)((ulonglong)temp_low >> 0x20),(int)temp2_high,\n                         (int)((ulonglong)temp2_high >> 0x20));\n    result1_low = __subdf3(input,multiplier,(int)temp_low,(int)((ulonglong)temp_low >> 0x20));\n    return result1_low;\n  }\n  temp_low = __muldf3(result1_low,result2_high,(int)temp_low,temp_high);\n  temp_low = __subdf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),0x55555549,0x3fc55555);\n  temp_low = __muldf3((int)temp_low,(int)((ulonglong)temp_low >> 0x20),result1_high,result2_low);\n  result1_low = __aeabi_dadd((int)temp_low,(int)((ulonglong)temp_low >> 0x20),input,multiplier);\n  return result1_low;\n}\n\n",
            "renaming": {
                "FUN_0800adf0": "calculate_0800adf0",
                "param_1": "input",
                "param_2": "multiplier",
                "param_3": "constant1",
                "param_4": "constant2",
                "param_5": "flag",
                "iVar1": "convertedValue",
                "uVar2": "result1_high",
                "uVar3": "result1_low",
                "uVar4": "result2_high",
                "uVar5": "result2_low",
                "uVar6": "temp_high",
                "uVar7": "temp_low",
                "uVar8": "temp2_high"
            },
            "calling": [
                "sin",
                "cos"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800af78": {
            "entrypoint": "0x0800af78",
            "current_name": "calculate_polynomial_0800af78",
            "code": "\ndouble calculatePolynomial_0800af78(double input)\n\n{\n  int intValue;\n  undefined4 result1;\n  undefined4 result2;\n  uint absValue;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  uint absValueSigned;\n  int case;\n  double output;\n  double tempResult;\n  double extraout_d0;\n  undefined8 temp4;\n  undefined8 temp5;\n  undefined4 temp6;\n  uint temp7;\n  \n  absValueSigned = absValue & 0x7fffffff;\n  if (absValueSigned < 0x44100000) {\n    if (absValueSigned < 0x3fdc0000) {\n      temp7 = absValue;\n      if (absValueSigned < 0x3e200000) {\n        temp4 = __aeabi_dadd(intValue,absValue,0x8800759c,0x7e37e43c);\n        case = __aeabi_dcmpgt((int)temp4,(int)((ulonglong)temp4 >> 0x20),0,0x3ff00000);\n        if (case != 0) {\n          return extraout_d0;\n        }\n      }\n      case = -1;\n    }\n    else {\n      fabs((double)CONCAT44(absValue,temp6));\n      if (absValueSigned < 0x3ff30000) {\n        if (absValueSigned < 0x3fe60000) {\n          temp4 = __aeabi_dadd();\n          temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0,0x3ff00000);\n          temp5 = __aeabi_dadd(intValue,temp3,0,0x40000000);\n          temp4 = __divdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                           (int)((ulonglong)temp5 >> 0x20));\n          temp7 = (uint)((ulonglong)temp4 >> 0x20);\n          intValue = (int)temp4;\n          case = 0;\n        }\n        else {\n          temp4 = __subdf3();\n          temp5 = __aeabi_dadd(intValue,temp3,0,0x3ff00000);\n          temp4 = __divdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                           (int)((ulonglong)temp5 >> 0x20));\n          temp7 = (uint)((ulonglong)temp4 >> 0x20);\n          intValue = (int)temp4;\n          case = 1;\n        }\n      }\n      else if (absValueSigned < 0x40038000) {\n        temp4 = __subdf3();\n        temp5 = __muldf3(intValue,temp3,0,0x3ff80000);\n        temp5 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),0,0x3ff00000);\n        temp4 = __divdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                         (int)((ulonglong)temp5 >> 0x20));\n        temp7 = (uint)((ulonglong)temp4 >> 0x20);\n        intValue = (int)temp4;\n        case = 2;\n      }\n      else {\n        temp4 = __divdf3(0,0xbff00000,intValue,temp3);\n        temp7 = (uint)((ulonglong)temp4 >> 0x20);\n        intValue = (int)temp4;\n        case = 3;\n      }\n    }\n    temp4 = __muldf3(intValue,temp7,intValue);\n    temp1 = (undefined4)((ulonglong)temp4 >> 0x20);\n    result1 = (undefined4)temp4;\n    temp4 = __muldf3(result1,temp1,result1,temp1);\n    temp2 = (undefined4)((ulonglong)temp4 >> 0x20);\n    result2 = (undefined4)temp4;\n    temp4 = __muldf3(result2,temp2,0xe322da11,0x3f90ad3a);\n    temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),result2,temp2);\n    temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),result2,temp2);\n    temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),result2,temp2);\n    temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x920083ff,0x3fc24924);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),result2,temp2);\n    temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x5555550d,0x3fd55555);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),result1,temp1);\n    result1 = (undefined4)((ulonglong)temp4 >> 0x20);\n    temp5 = __muldf3(result2,temp2,0x2c6a6c2f,0xbfa2b444);\n    temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),result2,temp2);\n    temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),result2,temp2);\n    temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),result2,temp2);\n    temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),result2,temp2);\n    result2 = (undefined4)((ulonglong)temp5 >> 0x20);\n    if (case == -1) {\n      temp4 = __aeabi_dadd((int)temp4,result1,(int)temp5,result2);\n      temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),intValue,temp7);\n      tempResult = (double)__subdf3(intValue,temp7,(int)temp4,(int)((ulonglong)temp4 >> 0x20));\n      return tempResult;\n    }\n    temp4 = __aeabi_dadd((int)temp4,result1,(int)temp5,result2);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),intValue,temp7);\n    temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),*(undefined4 *)(&atanlo + case * 8)\n                     ,*(undefined4 *)(&UNK_0800c094 + case * 8));\n    temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),intValue,temp7);\n    output = (double)__subdf3(*(undefined4 *)(&atanhi + case * 8),\n                             *(undefined4 *)(&UNK_0800c074 + case * 8),(int)temp4,\n                             (int)((ulonglong)temp4 >> 0x20));\n    if ((int)absValue < 0) {\n      return output;\n    }\n  }\n  else if ((0x7ff00000 < absValueSigned) || ((absValueSigned == 0x7ff00000 && (intValue != 0)))) {\n    tempResult = (double)__aeabi_dadd();\n    return tempResult;\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_0800af78": "calculate_polynomial_0800af78",
                "__x": "input",
                "in_r0": "intValue",
                "uVar1": "result1",
                "uVar2": "result2",
                "in_r1": "absValue",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "extraout_r1": "temp3",
                "uVar5": "absValueSigned",
                "iVar6": "case",
                "in_d0": "output",
                "dVar7": "tempResult",
                "uVar8": "temp4",
                "uVar9": "temp5",
                "in_stack_ffffffd0": "temp6",
                "uVar10": "temp7"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__muldf3",
                "fabs",
                "__aeabi_dadd",
                "__divdf3",
                "__subdf3",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2cc": {
            "entrypoint": "0x0800b2cc",
            "current_name": "calculate_squared_value_0800b2cc",
            "code": "\ndouble calculate_squared_value_0800b2cc(double input_value)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800b2cc": "calculate_squared_value_0800b2cc",
                "__x": "input_value",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "__ieee754_atan2",
                "atan"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2d4": {
            "entrypoint": "0x0800b2d4",
            "current_name": "calculate_sign_bit_0800b2d4",
            "code": "\nint calculateSignBit_0800b2d4(double inputValue)\n\n{\n  uint upperBitMask;\n  \n  return (upperBitMask | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_0800b2d4": "calculate_sign_bit_0800b2d4",
                "__value": "inputValue",
                "in_r1": "upperBitMask"
            },
            "calling": [
                "hypot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2e0": {
            "entrypoint": "0x0800b2e0",
            "current_name": "handle_exception_0800b2e0",
            "code": "\nint handle_exception_0800b2e0(exception *exception_obj)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800b2e0": "handle_exception_0800b2e0",
                "__exc": "exception_obj"
            },
            "calling": [
                "sqrt",
                "hypot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2e8": {
            "entrypoint": "0x0800b2e8",
            "current_name": "calculate_exponential_0800b2e8",
            "code": "\ndouble calculateExponential_0800b2e8(double input,int power)\n\n{\n  uint temp1;\n  int temp2;\n  uint shifted_power;\n  int sum_power_temp;\n  uint shifted_input;\n  double result;\n  double temp_result;\n  double final_result;\n  undefined8 combined_inputs;\n  \n  combined_inputs = CONCAT44(temp1,power);\n  shifted_power = (temp1 << 1) >> 0x15;\n  if (shifted_power == 0) {\n    if ((power | temp1 & 0x7fffffff) == 0) {\n      return result;\n    }\n    combined_inputs = __muldf3(power,temp1,0,0x43500000);\n    if (temp2 < -50000) goto LAB_0800b34a;\n    shifted_power = ((uint)((int)((ulonglong)combined_inputs >> 0x20) << 1) >> 0x15) - 0x36;\n    result = temp_result;\n  }\n  else if (shifted_power == 0x7ff) {\n    final_result = (double)__aeabi_dadd(power,temp1,power);\n    return final_result;\n  }\n  shifted_input = (uint)((ulonglong)combined_inputs >> 0x20);\n  sum_power_temp = shifted_power + temp2;\n  if (sum_power_temp < 0x7ff) {\n    if (0 < sum_power_temp) {\n      return result;\n    }\n    if (sum_power_temp + 0x35 < 0 == SCARRY4(sum_power_temp,0x35)) {\n      final_result = (double)__muldf3((int)combined_inputs,shifted_input & 0x800fffff | (sum_power_temp + 0x36) * 0x100000,0,\n                               0x3c900000);\n      return final_result;\n    }\n    if (temp2 < 0xc351) {\n      combined_inputs = CONCAT44(shifted_input & 0x80000000 | 0x1a56e1f,0xc2f8f359);\nLAB_0800b34a:\n      final_result = (double)__muldf3((int)combined_inputs,(int)((ulonglong)combined_inputs >> 0x20),0xc2f8f359,0x1a56e1f);\n      return final_result;\n    }\n  }\n  final_result = (double)__muldf3(0x8800759c,shifted_input & 0x80000000 | 0x7e37e43c,0x8800759c,0x7e37e43c);\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_0800b2e8": "calculate_exponential_0800b2e8",
                "__x": "input",
                "__n": "power",
                "in_r1": "temp1",
                "in_r2": "temp2",
                "uVar1": "shifted_power",
                "iVar2": "sum_power_temp",
                "uVar3": "shifted_input",
                "in_d0": "result",
                "extraout_d0": "temp_result",
                "dVar4": "final_result",
                "uVar5": "combined_inputs"
            },
            "calling": [
                "__kernel_rem_pio2"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b3dc": {
            "entrypoint": "0x0800b3dc",
            "current_name": "get_impure_ptr_0800b3dc",
            "code": "\nimpure_ptr_type get_impure_ptr_0800b3dc(void)\n\n{\n  return impure_ptr_variable;\n}\n\n",
            "renaming": {
                "FUN_0800b3dc": "get_impure_ptr_0800b3dc",
                "undefined4": "impure_ptr_type",
                "_impure_ptr": "impure_ptr_variable"
            },
            "calling": [
                "sqrt",
                "hypot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b3e8": {
            "entrypoint": "0x0800b3e8",
            "current_name": "initialize_preinit_functions_0800b3e8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800b3f4) */\n/* WARNING: Removing unreachable block (ram,0x0800b3f6) */\n\nvoid initializePreinitFunctions_0800b3e8(EVP_PKEY_CTX *ctx)\n\n{\n  int counter;\n  code **functionArray;\n  \n  _init(ctx);\n  counter = 0;\n  functionArray = (code **)&__preinit_array_end;\n  do {\n    counter = counter + 1;\n    (**functionArray)();\n    functionArray = functionArray + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b3e8": "initialize_preinit_functions_0800b3e8",
                "param_1": "ctx",
                "iVar1": "counter",
                "ppcVar2": "functionArray"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy",
                "register_fini"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b430": {
            "entrypoint": "0x0800b430",
            "current_name": "memset_0800b430",
            "code": "\nvoid * memset_0800b430(void *ptr,int value,size_t num_bytes)\n\n{\n  uint loop_counter;\n  uint *dest_ptr;\n  uint *curr_dest_ptr;\n  uint *next_dest_ptr;\n  uint fill_value;\n  bool is_done;\n  \n  dest_ptr = (uint *)ptr;\n  if (((uint)ptr & 3) != 0) {\n    fill_value = num_bytes - 1;\n    curr_dest_ptr = (uint *)ptr;\n    if (num_bytes == 0) {\n      return ptr;\n    }\n    while( true ) {\n      dest_ptr = (uint *)((int)curr_dest_ptr + 1);\n      *(char *)curr_dest_ptr = (char)value;\n      num_bytes = fill_value;\n      if (((uint)dest_ptr & 3) == 0) break;\n      is_done = fill_value == 0;\n      fill_value = fill_value - 1;\n      curr_dest_ptr = dest_ptr;\n      if (is_done) {\n        return ptr;\n      }\n    }\n  }\n  if (3 < num_bytes) {\n    fill_value = value & 0xffU | (value & 0xffU) << 8;\n    fill_value = fill_value | fill_value << 0x10;\n    if (0xf < num_bytes) {\n      curr_dest_ptr = dest_ptr + 4;\n      do {\n        curr_dest_ptr[-4] = fill_value;\n        curr_dest_ptr[-3] = fill_value;\n        curr_dest_ptr[-2] = fill_value;\n        curr_dest_ptr[-1] = fill_value;\n        curr_dest_ptr = curr_dest_ptr + 4;\n      } while (curr_dest_ptr != (uint *)((int)dest_ptr + (num_bytes - 0x10 & 0xfffffff0) + 0x20));\n      loop_counter = num_bytes & 0xc;\n      dest_ptr = dest_ptr + ((num_bytes - 0x10 >> 4) + 1) * 4;\n      num_bytes = num_bytes & 0xf;\n      if (loop_counter == 0) goto joined_r0x0800b4a8;\n    }\n    curr_dest_ptr = (uint *)((num_bytes - 4 & 0xfffffffc) + 4 + (int)dest_ptr);\n    do {\n      next_dest_ptr = dest_ptr + 1;\n      *dest_ptr = fill_value;\n      dest_ptr = next_dest_ptr;\n    } while (curr_dest_ptr != next_dest_ptr);\n    num_bytes = num_bytes & 3;\n    dest_ptr = curr_dest_ptr;\n  }\njoined_r0x0800b4a8:\n  if (num_bytes != 0) {\n    curr_dest_ptr = dest_ptr;\n    do {\n      next_dest_ptr = (uint *)((int)curr_dest_ptr + 1);\n      *(char *)curr_dest_ptr = (char)value;\n      curr_dest_ptr = next_dest_ptr;\n    } while ((uint *)(num_bytes + (int)dest_ptr) != next_dest_ptr);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_0800b430": "memset_0800b430",
                "__s": "ptr",
                "__c": "value",
                "__n": "num_bytes",
                "uVar1": "loop_counter",
                "puVar2": "dest_ptr",
                "puVar3": "curr_dest_ptr",
                "puVar4": "next_dest_ptr",
                "uVar5": "fill_value",
                "bVar6": "is_done"
            },
            "calling": [
                "gc_execute_line",
                "mc_go_home",
                "eeprom_init",
                "grbl_main",
                "plan_init",
                "debounce_init",
                "gc_init",
                "settings_read_coord_data",
                "homing_cycle",
                "st_reset"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b4d0": {
            "entrypoint": "0x0800b4d0",
            "current_name": "FUNC_0800b4d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800b4d4) */\n\nvoid FUNC_0800b4d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b4d0": "FUNC_0800b4d0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800b4e4": {
            "entrypoint": "0x0800b4e4",
            "current_name": "register_exitproc_0800b4e4",
            "code": "\nint register_exitproc_0800b4e4(function_ptr *function_ptr)\n\n{\n  int result;\n  \n  result = __register_exitproc_0800b4e4(0,function_ptr,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800b4e4": "register_exitproc_0800b4e4",
                "__func": "function_ptr",
                "iVar1": "result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b4f0": {
            "entrypoint": "0x0800b4f0",
            "current_name": "execute_global_destructors_0800b4f0",
            "code": "\nvoid execute_global_destructors_0800b4f0(void)\n\n{\n  int iteration_count;\n  code **destructor_ptr;\n  \n  iteration_count = 1;\n  destructor_ptr = (code **)&global_destructors_array_entry;\n  do {\n    iteration_count = iteration_count + -1;\n    (**destructor_ptr)();\n    destructor_ptr = destructor_ptr + -1;\n  } while (iteration_count != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b4f0": "execute_global_destructors_0800b4f0",
                "iVar1": "iteration_count",
                "ppcVar2": "destructor_ptr",
                "__do_global_dtors_aux_fini_array_entry": "global_destructors_array_entry"
            },
            "calling": [],
            "called": [
                "_fini",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b51c": {
            "entrypoint": "0x0800b51c",
            "current_name": "FUNC_0800b51c",
            "code": "\nvoid FUNC_0800b51c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b51c": "FUNC_0800b51c"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800b520": {
            "entrypoint": "0x0800b520",
            "current_name": "FUNC_0800b520",
            "code": "\nvoid FUNC_0800b520(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b520": "FUNC_0800b520"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800b524": {
            "entrypoint": "0x0800b524",
            "current_name": "register_at_exit_function_0800b524",
            "code": "\nundefined4 registerAtExitFunction_0800b524(int options,undefined4 callback,undefined4 data,undefined4 userdata)\n\n{\n  undefined *exitHandlers;\n  undefined4 result;\n  uint bitMask;\n  uint handlerIndex;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  exitHandlers = DAT_20000168;\n  handlerIndex = *(uint *)(DAT_20000168 + 4);\n  if ((int)handlerIndex < 0x20) {\n    if (options != 0) {\n      *(undefined4 *)(DAT_20000168 + handlerIndex * 4 + 0x88) = data;\n      bitMask = 1 << (handlerIndex & 0xff);\n      *(uint *)(exitHandlers + 0x188) = *(uint *)(exitHandlers + 0x188) | bitMask;\n      *(undefined4 *)(exitHandlers + handlerIndex * 4 + 0x108) = userdata;\n      if (options == 2) {\n        *(uint *)(exitHandlers + 0x18c) = bitMask | *(uint *)(exitHandlers + 0x18c);\n      }\n    }\n    result = __atexit_recursive_mutex;\n    *(uint *)(exitHandlers + 4) = handlerIndex + 1;\n    *(undefined4 *)(exitHandlers + (handlerIndex + 2) * 4) = callback;\n    __retarget_lock_release_recursive(result);\n    result = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800b524": "register_at_exit_function_0800b524",
                "param_1": "options",
                "param_2": "callback",
                "param_3": "data",
                "param_4": "userdata",
                "puVar1": "exitHandlers",
                "uVar2": "result",
                "uVar3": "bitMask",
                "uVar4": "handlerIndex"
            },
            "calling": [
                "atexit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b5b0": {
            "entrypoint": "0x0800b5b0",
            "current_name": "extract_evp_key_context_0800b5b0",
            "code": "\nint extractEVPKeyContext_0800b5b0(EVP_PKEY_CTX *keyContext)\n\n{\n  return (int)keyContext;\n}\n\n",
            "renaming": {
                "FUN_0800b5b0": "extract_evp_key_context_0800b5b0",
                "ctx": "keyContext"
            },
            "calling": [
                "frame_dummy",
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b5bc": {
            "entrypoint": "0x0800b5bc",
            "current_name": "FUNC_0800b5bc",
            "code": "\nvoid FUNC_0800b5bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b5bc": "FUNC_0800b5bc"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 202419,
    "layers": [
        [
            "FUN_08000188",
            "FUN_080001ac",
            "FUN_080001f8",
            "FUN_08000210",
            "FUN_08000220",
            "FUN_08000268",
            "FUN_080002a0",
            "FUN_080002b6",
            "FUN_080002f0",
            "FUN_08000310",
            "FUN_08000340",
            "FUN_08000374",
            "FUN_080003ec",
            "FUN_08000478",
            "FUN_080004ac",
            "FUN_080004fc",
            "FUN_0800056c",
            "FUN_080005b4",
            "FUN_0800184c",
            "FUN_080018cc",
            "FUN_080018fc",
            "FUN_0800192c",
            "FUN_0800195c",
            "FUN_08001994",
            "FUN_08001d4c",
            "FUN_08001ddc",
            "FUN_08001e98",
            "FUN_08001f00",
            "FUN_08002408",
            "FUN_080024c4",
            "FUN_080025e8",
            "FUN_08002638",
            "FUN_08002814",
            "FUN_08002828",
            "FUN_0800283a",
            "FUN_08002870",
            "FUN_08002896",
            "FUN_080028bc",
            "FUN_08002908",
            "FUN_08002978",
            "FUN_080029d8",
            "FUN_08002a94",
            "FUN_08002afc",
            "FUN_08002ba8",
            "FUN_08002c18",
            "FUN_08002e08",
            "FUN_08002edc",
            "FUN_08002ef0",
            "FUN_08002f24",
            "FUN_08002f40",
            "FUN_08002f74",
            "FUN_08002fac",
            "FUN_08002fd4",
            "FUN_08003004",
            "FUN_080035ec",
            "FUN_08003618",
            "FUN_0800369c",
            "FUN_080036c6",
            "FUN_080036f0",
            "FUN_08003740",
            "FUN_0800375c",
            "FUN_08003778",
            "FUN_080037fc",
            "FUN_08003826",
            "FUN_08003980",
            "FUN_080039a0",
            "FUN_080039bc",
            "FUN_08003a18",
            "FUN_08003a74",
            "FUN_08003b98",
            "FUN_08003f34",
            "FUN_08004030",
            "FUN_08004148",
            "FUN_080041a0",
            "FUN_08004228",
            "FUN_0800423c",
            "FUN_08004250",
            "FUN_080044e8",
            "FUN_080046d0",
            "FUN_08004900",
            "FUN_08004940",
            "FUN_08004bc0",
            "FUN_08004bf4",
            "FUN_08004c2a",
            "FUN_08004c48",
            "FUN_08004d2c",
            "FUN_08004d7c",
            "FUN_08004dd2",
            "FUN_08004e30",
            "FUN_080051b4",
            "FUN_08005238",
            "FUN_08005250",
            "FUN_0800525c",
            "FUN_080052ac",
            "FUN_080052dc",
            "FUN_08005324",
            "FUN_08005360",
            "FUN_080053a0",
            "FUN_08005760",
            "FUN_08005778",
            "FUN_08005790",
            "FUN_080057e4",
            "FUN_08005814",
            "FUN_0800583c",
            "FUN_0800585c",
            "FUN_0800587c",
            "FUN_080058a0",
            "FUN_08005900",
            "FUN_0800597c",
            "FUN_08005984",
            "FUN_080059b4",
            "FUN_080059f8",
            "FUN_08005a68",
            "FUN_08005a84",
            "FUN_08005a98",
            "FUN_08005ac4",
            "FUN_08005ad4",
            "FUN_08005aec",
            "FUN_08005b04",
            "FUN_08005b20",
            "FUN_08005b3c",
            "FUN_08005b58",
            "FUN_08005b74",
            "FUN_08005b90",
            "FUN_08005bac",
            "FUN_08005bc4",
            "FUN_08005bdc",
            "FUN_08005c30",
            "FUN_08005c74",
            "FUN_08005cec",
            "FUN_0800618c",
            "FUN_0800640c",
            "FUN_080064bc",
            "FUN_080064d4",
            "FUN_080064ec",
            "FUN_08006628",
            "FUN_08006680",
            "FUN_080066cc",
            "FUN_08006718",
            "FUN_080068bc",
            "FUN_0800691c",
            "FUN_08006950",
            "FUN_08006998",
            "FUN_080069b4",
            "FUN_080069e4",
            "FUN_08006a18",
            "FUN_08006a58",
            "FUN_08006a8c",
            "FUN_08006ac0",
            "FUN_08006b00",
            "FUN_08006b54",
            "FUN_08006ba0",
            "FUN_08006c04",
            "FUN_08006c70",
            "FUN_08006c9c",
            "FUN_08006ce0",
            "FUN_08006cf6",
            "FUN_08006d2e",
            "FUN_08006d4a",
            "FUN_08006d66",
            "FUN_08006d72",
            "FUN_08006d8a",
            "FUN_08006d98",
            "FUN_08006dc4",
            "FUN_08006de0",
            "FUN_08006dfe",
            "FUN_08006e1a",
            "FUN_08006e38",
            "FUN_08006e70",
            "FUN_08006e88",
            "FUN_080071d0",
            "FUN_08007310",
            "FUN_0800733e",
            "FUN_0800736c",
            "FUN_0800738e",
            "FUN_080073c0",
            "FUN_080073d4",
            "FUN_08007402",
            "FUN_08007430",
            "FUN_08007436",
            "FUN_080074c8",
            "FUN_08007520",
            "FUN_08007540",
            "FUN_0800756c",
            "FUN_080075c8",
            "FUN_080076c8",
            "FUN_0800771a",
            "FUN_08007720",
            "FUN_08007726",
            "FUN_0800772c",
            "FUN_08007756",
            "FUN_0800778c",
            "FUN_08007854",
            "FUN_08007884",
            "FUN_080078d0",
            "FUN_080078e2",
            "FUN_080078f4",
            "FUN_08007930",
            "FUN_080079c0",
            "FUN_080079e0",
            "FUN_08007a10",
            "FUN_08007a70",
            "FUN_08007ad0",
            "FUN_08007b70",
            "FUN_08007bc2",
            "FUN_08007bf0",
            "FUN_08007c40",
            "FUN_08007c5e",
            "FUN_08007c7c",
            "FUN_08007d08",
            "FUN_08007da8",
            "FUN_08007dd8",
            "FUN_08007e08",
            "FUN_08007e1c",
            "FUN_08007e58",
            "FUN_08007e84",
            "FUN_08007ea4",
            "FUN_08007f54",
            "FUN_08008190",
            "FUN_08008250",
            "FUN_0800826a",
            "FUN_08008286",
            "FUN_080082c8",
            "FUN_080082d0",
            "FUN_080082d4",
            "FUN_0800854c",
            "FUN_0800856c",
            "FUN_08008590",
            "FUN_080085d4",
            "FUN_080085e4",
            "FUN_0800881c",
            "FUN_08008a02",
            "FUN_08008a64",
            "FUN_08008a6c",
            "FUN_08008a74",
            "FUN_08008af0",
            "FUN_08008b00",
            "FUN_08008b10",
            "FUN_08008b24",
            "FUN_08008b38",
            "FUN_08008b4c",
            "FUN_08008b60",
            "FUN_08008b74",
            "FUN_08008ba0",
            "FUN_08008bf0",
            "FUN_08008c30",
            "FUN_08008cd0",
            "FUN_08008cd8",
            "FUN_08008cdc",
            "FUN_08008e3c",
            "FUN_08008e44",
            "FUN_08008e60",
            "FUN_08008e70",
            "FUN_08008eec",
            "FUN_08009054",
            "FUN_0800918c",
            "FUN_08009194",
            "FUN_0800919c",
            "FUN_080091fc",
            "FUN_08009204",
            "FUN_08009214",
            "FUN_08009228",
            "FUN_0800923c",
            "FUN_08009250",
            "FUN_08009264",
            "FUN_08009278",
            "FUN_080092c4",
            "FUN_08009314",
            "FUN_08009318",
            "FUN_08009410",
            "FUN_080094c0",
            "FUN_080095b8",
            "FUN_08009654",
            "FUN_080096e8",
            "FUN_08009798",
            "FUN_0800981c",
            "FUN_080098d0",
            "FUN_08009990",
            "FUN_08009b24",
            "FUN_08009d78",
            "FUN_0800a1bc",
            "FUN_0800a348",
            "FUN_0800a5a0",
            "FUN_0800adf0",
            "FUN_0800af78",
            "FUN_0800b2cc",
            "FUN_0800b2d4",
            "FUN_0800b2e0",
            "FUN_0800b2e8",
            "FUN_0800b3dc",
            "FUN_0800b3e8",
            "FUN_0800b430",
            "FUN_0800b4e4",
            "FUN_0800b4f0",
            "FUN_0800b524",
            "FUN_0800b5b0"
        ],
        [
            "FUN_08008640",
            "FUN_08008894"
        ]
    ],
    "locked_functions": []
}