{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeCompletedFlag_08000110(undefined4 inputValue)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "inputValue",
                "completed_8672": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_parameters_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_parameters_08000134(undefined4 first_parameter,undefined4 second_parameter)\n\n{\n  return CONCAT44(second_parameter,first_parameter);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_parameters_08000134",
                "param_1": "first_parameter",
                "param_2": "second_parameter"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "calculate_string_length_08000150",
            "code": "\nsize_t calculateStringLength_08000150(char *str)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *strPtr;\n  \n  strPtr = str;\n  do {\n    nextCharPtr = strPtr + 1;\n    currentChar = *strPtr;\n    strPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_08000150": "calculate_string_length_08000150",
                "__s": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "strPtr"
            },
            "calling": [
                "serialPrint"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000160": {
            "entrypoint": "0x08000160",
            "current_name": "add_offset_08000160",
            "code": "\nvoid addOffset_08000160(undefined4 result,uint offset)\n\n{\n  __aeabi_dadd(result,offset ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000160": "add_offset_08000160",
                "param_1": "result",
                "param_2": "offset"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000168": {
            "entrypoint": "0x08000168",
            "current_name": "reverse_function_08000168",
            "code": "\nulonglong reverseFunction_08000168(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int result1;\n  byte flag1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int result2;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  bool flag2;\n  bool flag3;\n  bool flag4;\n  \n  temp4 = input4 ^ 0x80000000;\n  temp6 = input2 << 1;\n  input4 = input4 << 1;\n  flag2 = ((input2 ^ temp4) & 0x7fffffff) == 0;\n  flag3 = flag2 && input1 == input3;\n  if (!flag2 || input1 != input3) {\n    flag3 = (temp6 | input1) == 0;\n  }\n  if (!flag3) {\n    flag3 = (input4 | input3) == 0;\n  }\n  result2 = (int)temp6 >> 0x15;\n  if (!flag3) {\n    flag3 = result2 == -1;\n  }\n  result1 = (int)input4 >> 0x15;\n  if (!flag3) {\n    flag3 = result1 == -1;\n  }\n  if (flag3) {\n    if (result2 == -1 || result1 == -1) {\n      temp6 = temp4;\n      temp8 = input3;\n      if (result2 == -1) {\n        temp6 = input2;\n        temp8 = input1;\n      }\n      if (result2 != -1 || result1 != -1) {\n        input3 = temp8;\n        temp4 = temp6;\n      }\n      flag3 = (temp8 | temp6 << 0xc) == 0;\n      if (flag3) {\n        flag3 = (input3 | temp4 << 0xc) == 0;\n      }\n      if (flag3) {\n        flag3 = temp6 == temp4;\n      }\n      if (!flag3) {\n        temp6 = temp6 | 0x80000;\n      }\n      return CONCAT44(temp6,temp8);\n    }\n    if (((input2 ^ temp4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp6 | input1) == 0) {\n        input1 = input3;\n        input2 = temp4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp4) {\n      return 0;\n    }\n    if (temp6 >> 0x15 == 0) {\n      flag3 = (input1 & 0x80000000) != 0;\n      temp4 = input2 * 2 + (uint)flag3;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag3)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,input1 << 1);\n    }\n    if (temp6 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp6 = temp6 >> 0x15;\n  input4 = input4 >> 0x15;\n  temp8 = input4 - temp6;\n  flag3 = temp8 != 0;\n  if (input4 < temp6) {\n    temp8 = -temp8;\n  }\n  temp7 = input1;\n  temp5 = input2;\n  if (flag3 && temp6 <= input4) {\n    temp6 = temp6 + temp8;\n    temp7 = input3;\n    temp5 = temp4;\n    input3 = input1;\n    temp4 = input2;\n  }\n  if (0x36 < temp8) {\n    return CONCAT44(temp5,temp7);\n  }\n  temp2 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    flag3 = temp7 != 0;\n    temp7 = -temp7;\n    temp2 = -temp2 - (uint)flag3;\n  }\n  temp5 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    flag3 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)flag3;\n  }\n  if (temp6 == temp8) {\n    temp5 = temp5 ^ 0x100000;\n    if (temp6 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      temp6 = 1;\n    }\n    else {\n      temp8 = temp8 - 1;\n    }\n  }\n  temp4 = -temp8 + 0x20;\n  if ((int)temp8 < 0x21) {\n    temp9 = input3 << (temp4 & 0xff);\n    input3 = input3 >> (temp8 & 0xff);\n    temp1 = temp7 + input3;\n    temp3 = temp5 << (temp4 & 0xff);\n    temp4 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(temp7,input3) + ((int)temp5 >> (temp8 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    temp9 = temp5 << (-temp8 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp9 = temp9 | 2;\n    }\n    temp5 = (int)temp5 >> (temp8 - 0x20 & 0xff);\n    temp4 = temp7 + temp5;\n    temp2 = temp2 + ((int)temp5 >> 0x1f) + (uint)CARRY4(temp7,temp5);\n  }\n  input2 = temp2 & 0x80000000;\n  temp8 = temp2;\n  if ((int)temp2 < 0) {\n    flag3 = temp9 == 0;\n    temp9 = -temp9;\n    temp8 = -temp4;\n    temp4 = -(uint)!flag3 - temp4;\n    temp8 = -(uint)(flag3 <= temp8) - temp2;\n  }\n  if (0xfffff < temp8) {\n    temp7 = temp6 - 1;\n    if (0x1fffff < temp8) {\n      temp7 = temp8 & 1;\n      temp8 = temp8 >> 1;\n      flag1 = (byte)temp4;\n      temp4 = (uint)(temp7 != 0) << 0x1f | temp4 >> 1;\n      temp9 = (uint)(flag1 & 1) << 0x1f | temp9 >> 1;\n      temp7 = temp6;\n      if (0xffbfffff < temp6 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    flag3 = 0x7fffffff < temp9;\n    if (temp9 == 0x80000000) {\n      flag3 = (temp4 & 1) != 0;\n    }\n    return CONCAT44(temp8 + temp7 * 0x100000 + (uint)CARRY4(temp4,(uint)flag3) | input2,\n                    temp4 + flag3);\n  }\n  flag2 = (temp9 & 0x80000000) != 0;\n  temp9 = temp9 << 1;\n  temp7 = temp4 * 2;\n  flag3 = CARRY4(temp4,temp4);\n  temp4 = temp4 * 2 + (uint)flag2;\n  temp8 = temp8 * 2 + (uint)(flag3 || CARRY4(temp7,(uint)flag2));\n  temp7 = temp6 - 2;\n  if ((temp8 & 0x100000) != 0) goto LAB_08000278;\n  temp5 = temp4;\n  temp6 = temp8;\n  if (temp8 == 0) {\n    temp5 = 0;\n    temp6 = temp4;\n  }\n  result2 = LZCOUNT(temp6);\n  if (temp8 == 0) {\n    result2 = result2 + 0x20;\n  }\n  temp8 = result2 - 0xb;\n  flag4 = SBORROW4(temp8,0x20);\n  temp4 = result2 - 0x2b;\n  flag3 = (int)temp4 < 0;\n  flag2 = temp4 == 0;\n  if ((int)temp8 < 0x20) {\n    flag4 = SCARRY4(temp4,0xc);\n    result2 = result2 + -0x1f;\n    flag3 = result2 < 0;\n    flag2 = result2 == 0;\n    temp4 = temp8;\n    if (!flag2 && flag3 == flag4) {\n      temp5 = temp6 << (temp8 & 0xff);\n      temp6 = temp6 >> (0xcU - result2 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (flag2 || flag3 != flag4) {\n    temp9 = 0x20 - temp4;\n  }\n  temp6 = temp6 << (temp4 & 0xff);\n  if (flag2 || flag3 != flag4) {\n    temp6 = temp6 | temp5 >> (temp9 & 0xff);\n  }\n  if (flag2 || flag3 != flag4) {\n    temp5 = temp5 << (temp4 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp8 <= (int)temp7) {\n    return CONCAT44(temp6 + (temp7 - temp8) * 0x100000 | input2,temp5);\n  }\n  temp4 = ~(temp7 - temp8);\n  if ((int)temp4 < 0x1f) {\n    result2 = temp4 - 0x13;\n    if (result2 != 0 && result2 < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp5 >> (0x20 - (0xcU - result2) & 0xff) | temp6 << (0xcU - result2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(input2 | temp6 >> (temp4 & 0xff),\n                    temp5 >> (temp4 & 0xff) | temp6 << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp2,temp6 >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000168": "reverse_function_08000168",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "result1",
                "bVar2": "flag1",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "result2",
                "uVar9": "temp6",
                "uVar10": "temp7",
                "uVar11": "temp8",
                "uVar12": "temp9",
                "bVar13": "flag2",
                "bVar14": "flag3",
                "bVar15": "flag4"
            },
            "calling": [
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800016c": {
            "entrypoint": "0x0800016c",
            "current_name": "calculate_shifted_sum_0800016c",
            "code": "\nulonglong calculate_shifted_sum_0800016c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shifted_input1;\n  byte carry_bit;\n  uint shifted_sum1;\n  uint shifted_sum2;\n  uint shifted_input2;\n  int shift_count1;\n  uint shifted_input2_divided;\n  uint shifted_input4;\n  uint shifted_input4_divided;\n  uint shift_difference;\n  uint temp1;\n  uint temp2;\n  bool equality_check1;\n  bool equality_check2;\n  bool carry_check;\n  \n  shifted_input2_divided = input2 << 1;\n  shifted_input4_divided = input4 << 1;\n  equality_check1 = ((input2 ^ input4) & 0x7fffffff) == 0;\n  equality_check2 = equality_check1 && input1 == input3;\n  if (!equality_check1 || input1 != input3) {\n    equality_check2 = (shifted_input2_divided | input1) == 0;\n  }\n  if (!equality_check2) {\n    equality_check2 = (shifted_input4_divided | input3) == 0;\n  }\n  shift_count1 = (int)shifted_input2_divided >> 0x15;\n  if (!equality_check2) {\n    equality_check2 = shift_count1 == -1;\n  }\n  shifted_input1 = (int)shifted_input4_divided >> 0x15;\n  if (!equality_check2) {\n    equality_check2 = shifted_input1 == -1;\n  }\n  if (equality_check2) {\n    if (shift_count1 == -1 || shifted_input1 == -1) {\n      shifted_input4_divided = input4;\n      shifted_input2_divided = input3;\n      if (shift_count1 == -1) {\n        shifted_input4_divided = input2;\n        shifted_input2_divided = input1;\n      }\n      if (shift_count1 != -1 || shifted_input1 != -1) {\n        input3 = shifted_input2_divided;\n        input4 = shifted_input4_divided;\n      }\n      equality_check2 = (shifted_input2_divided | shifted_input4_divided << 0xc) == 0;\n      if (equality_check2) {\n        equality_check2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (equality_check2) {\n        equality_check2 = shifted_input4_divided == input4;\n      }\n      if (!equality_check2) {\n        shifted_input4_divided = shifted_input4_divided | 0x80000;\n      }\n      return CONCAT44(shifted_input4_divided,shifted_input2_divided);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((shifted_input2_divided | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (shifted_input2_divided >> 0x15 == 0) {\n      equality_check2 = (input1 & 0x80000000) != 0;\n      shifted_input4_divided = input2 * 2 + (uint)equality_check2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)equality_check2)) {\n        shifted_input4_divided = shifted_input4_divided | 0x80000000;\n      }\n      return CONCAT44(shifted_input4_divided,input1 << 1);\n    }\n    if (shifted_input2_divided < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  shifted_input2_divided = shifted_input2_divided >> 0x15;\n  shifted_input4_divided = shifted_input4_divided >> 0x15;\n  shift_difference = shifted_input4_divided - shifted_input2_divided;\n  equality_check2 = shift_difference != 0;\n  if (shifted_input4_divided < shifted_input2_divided) {\n    shift_difference = -shift_difference;\n  }\n  shifted_input4 = input1;\n  shifted_input2 = input2;\n  if (equality_check2 && shifted_input2_divided <= shifted_input4_divided) {\n    shifted_input2_divided = shifted_input2_divided + shift_difference;\n    shifted_input4 = input3;\n    shifted_input2 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < shift_difference) {\n    return CONCAT44(shifted_input2,shifted_input4);\n  }\n  shifted_input4_divided = shifted_input2 & 0xfffff | 0x100000;\n  if ((shifted_input2 & 0x80000000) != 0) {\n    equality_check2 = shifted_input4 != 0;\n    shifted_input4 = -shifted_input4;\n    shifted_input4_divided = -shifted_input4_divided - (uint)equality_check2;\n  }\n  shifted_input2 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    equality_check2 = input3 != 0;\n    input3 = -input3;\n    shifted_input2 = -shifted_input2 - (uint)equality_check2;\n  }\n  if (shifted_input2_divided == shift_difference) {\n    shifted_input2 = shifted_input2 ^ 0x100000;\n    if (shifted_input2_divided == 0) {\n      shifted_input4_divided = shifted_input4_divided ^ 0x100000;\n      shifted_input2_divided = 1;\n    }\n    else {\n      shift_difference = shift_difference - 1;\n    }\n  }\n  temp2 = -shift_difference + 0x20;\n  if ((int)shift_difference < 0x21) {\n    temp1 = input3 << (temp2 & 0xff);\n    input3 = input3 >> (shift_difference & 0xff);\n    shifted_sum1 = shifted_input4 + input3;\n    shifted_sum2 = shifted_input2 << (temp2 & 0xff);\n    temp2 = shifted_sum1 + shifted_sum2;\n    shifted_input4_divided = shifted_input4_divided + CARRY4(shifted_input4,input3) + ((int)shifted_input2 >> (shift_difference & 0xff)) +\n            (uint)CARRY4(shifted_sum1,shifted_sum2);\n  }\n  else {\n    temp1 = shifted_input2 << (-shift_difference + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp1 = temp1 | 2;\n    }\n    shifted_input2 = (int)shifted_input2 >> (shift_difference - 0x20 & 0xff);\n    temp2 = shifted_input4 + shifted_input2;\n    shifted_input4_divided = shifted_input4_divided + ((int)shifted_input2 >> 0x1f) + (uint)CARRY4(shifted_input4,shifted_input2);\n  }\n  input2 = shifted_input4_divided & 0x80000000;\n  shift_difference = shifted_input4_divided;\n  if ((int)shifted_input4_divided < 0) {\n    equality_check2 = temp1 == 0;\n    temp1 = -temp1;\n    shift_difference = -temp2;\n    temp2 = -(uint)!equality_check2 - temp2;\n    shift_difference = -(uint)(equality_check2 <= shift_difference) - shifted_input4_divided;\n  }\n  if (0xfffff < shift_difference) {\n    shifted_input4 = shifted_input2_divided - 1;\n    if (0x1fffff < shift_difference) {\n      shifted_input4_divided = shift_difference & 1;\n      shift_difference = shift_difference >> 1;\n      carry_bit = (byte)temp2;\n      temp2 = (uint)(shifted_input4_divided != 0) << 0x1f | temp2 >> 1;\n      temp1 = (uint)(carry_bit & 1) << 0x1f | temp1 >> 1;\n      shifted_input4 = shifted_input2_divided;\n      if (0xffbfffff < shifted_input2_divided * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    equality_check2 = 0x7fffffff < temp1;\n    if (temp1 == 0x80000000) {\n      equality_check2 = (temp2 & 1) != 0;\n    }\n    return CONCAT44(shift_difference + shifted_input4 * 0x100000 + (uint)CARRY4(temp2,(uint)equality_check2) | input2,\n                    temp2 + equality_check2);\n  }\n  equality_check1 = (temp1 & 0x80000000) != 0;\n  temp1 = temp1 << 1;\n  shifted_input4 = temp2 * 2;\n  equality_check2 = CARRY4(temp2,temp2);\n  temp2 = temp2 * 2 + (uint)equality_check1;\n  shift_difference = shift_difference * 2 + (uint)(equality_check2 || CARRY4(shifted_input4,(uint)equality_check1));\n  shifted_input4 = shifted_input2_divided - 2;\n  if ((shift_difference & 0x100000) != 0) goto LAB_08000278;\n  shifted_input2 = temp2;\n  shifted_input2_divided = shift_difference;\n  if (shift_difference == 0) {\n    shifted_input2 = 0;\n    shifted_input2_divided = temp2;\n  }\n  shift_count1 = LZCOUNT(shifted_input2_divided);\n  if (shift_difference == 0) {\n    shift_count1 = shift_count1 + 0x20;\n  }\n  temp2 = shift_count1 - 0xb;\n  carry_check = SBORROW4(temp2,0x20);\n  shift_difference = shift_count1 - 0x2b;\n  equality_check2 = (int)shift_difference < 0;\n  equality_check1 = shift_difference == 0;\n  if ((int)temp2 < 0x20) {\n    carry_check = SCARRY4(shift_difference,0xc);\n    shift_count1 = shift_count1 + -0x1f;\n    equality_check2 = shift_count1 < 0;\n    equality_check1 = shift_count1 == 0;\n    shift_difference = temp2;\n    if (!equality_check1 && equality_check2 == carry_check) {\n      shifted_input2 = shifted_input2_divided << (temp2 & 0xff);\n      shifted_input2_divided = shifted_input2_divided >> (0xcU - shift_count1 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (equality_check1 || equality_check2 != carry_check) {\n    temp1 = 0x20 - shift_difference;\n  }\n  shifted_input2_divided = shifted_input2_divided << (shift_difference & 0xff);\n  if (equality_check1 || equality_check2 != carry_check) {\n    shifted_input2_divided = shifted_input2_divided | shifted_input2 >> (temp1 & 0xff);\n  }\n  if (equality_check1 || equality_check2 != carry_check) {\n    shifted_input2 = shifted_input2 << (shift_difference & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp2 <= (int)shifted_input4) {\n    return CONCAT44(shifted_input2_divided + (shifted_input4 - temp2) * 0x100000 | input2,shifted_input2);\n  }\n  shift_difference = ~(shifted_input4 - temp2);\n  if ((int)shift_difference < 0x1f) {\n    shift_count1 = shift_difference - 0x13;\n    if (shift_count1 != 0 && shift_count1 < 0 == SCARRY4(shift_difference - 0x1f,0xc)) {\n      return CONCAT44(shifted_input4_divided,shifted_input2 >> (0x20 - (0xcU - shift_count1) & 0xff) | shifted_input2_divided << (0xcU - shift_count1 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shift_difference = shift_difference + 1;\n    return CONCAT44(input2 | shifted_input2_divided >> (shift_difference & 0xff),\n                    shifted_input2 >> (shift_difference & 0xff) | shifted_input2_divided << (0x20 - shift_difference & 0xff));\n  }\n  return CONCAT44(shifted_input4_divided,shifted_input2_divided >> (shift_difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800016c": "calculate_shifted_sum_0800016c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shifted_input1",
                "bVar2": "carry_bit",
                "uVar3": "shifted_sum1",
                "uVar4": "shifted_sum2",
                "uVar5": "shifted_input2",
                "iVar6": "shift_count1",
                "uVar7": "shifted_input2_divided",
                "uVar8": "shifted_input4",
                "uVar9": "shifted_input4_divided",
                "uVar10": "shift_difference",
                "uVar11": "temp1",
                "uVar12": "temp2",
                "bVar13": "equality_check1",
                "bVar14": "equality_check2",
                "bVar15": "carry_check"
            },
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "__aeabi_drsub",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003e4": {
            "entrypoint": "0x080003e4",
            "current_name": "FUNC_080003e4",
            "code": "\nulonglong FUNC_080003e4(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint in_r12;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  uVar1 = 0;\n  iVar3 = LZCOUNT(param_1);\n  uVar4 = iVar3 + 0x15;\n  bVar7 = SBORROW4(uVar4,0x20);\n  uVar2 = iVar3 - 0xb;\n  bVar5 = (int)uVar2 < 0;\n  bVar6 = uVar2 == 0;\n  if (uVar4 < 0x20) {\n    bVar7 = SCARRY4(uVar2,0xc);\n    bVar5 = false;\n    bVar6 = iVar3 + 1 == 0;\n    uVar2 = uVar4;\n    if (!bVar6 && bVar7 == false) {\n      uVar1 = param_1 << uVar4;\n      param_1 = param_1 >> (0xcU - (iVar3 + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bVar6 || bVar5 != bVar7) {\n    in_r12 = 0x20 - uVar2;\n  }\n  param_1 = param_1 << (uVar2 & 0xff);\n  if (bVar6 || bVar5 != bVar7) {\n    param_1 = param_1 | 0U >> (in_r12 & 0xff);\n  }\n  if (bVar6 || bVar5 != bVar7) {\n    uVar1 = 0 << (uVar2 & 0xff);\n  }\nLAB_080002f0:\n  if (uVar4 < 0x433) {\n    return CONCAT44(param_1 + (0x432 - uVar4) * 0x100000,uVar1);\n  }\n  uVar2 = ~(0x432 - uVar4);\n  if (0x1e < (int)uVar2) {\n    return (ulonglong)(param_1 >> (uVar2 - 0x1f & 0xff));\n  }\n  iVar3 = uVar2 - 0x13;\n  if (iVar3 == 0 || iVar3 < 0 != SCARRY4(uVar2 - 0x1f,0xc)) {\n    uVar2 = uVar2 + 1;\n    return CONCAT44(param_1 >> (uVar2 & 0xff),\n                    uVar1 >> (uVar2 & 0xff) | param_1 << (0x20 - uVar2 & 0xff));\n  }\n  return (ulonglong)(uVar1 >> (0x20 - (0xcU - iVar3) & 0xff) | param_1 << (0xcU - iVar3 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003e4": "FUNC_080003e4"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000404": {
            "entrypoint": "0x08000404",
            "current_name": "count_bits_and_shift_08000404",
            "code": "\nulonglong countBitsAndShift_08000404(uint input)\n\n{\n  uint count;\n  uint absInput;\n  uint shift;\n  int leadingZeros;\n  uint shiftAmount;\n  uint isNegative;\n  uint invertedShift;\n  bool isShiftNegative;\n  bool isShiftZero;\n  bool isShiftCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  isNegative = input & 0x80000000;\n  absInput = input;\n  if ((int)isNegative < 0) {\n    absInput = -input;\n  }\n  count = 0;\n  leadingZeros = LZCOUNT(absInput);\n  shiftAmount = leadingZeros + 0x15;\n  isShiftCarry = SBORROW4(shiftAmount,0x20);\n  shift = leadingZeros - 0xb;\n  isShiftNegative = (int)shift < 0;\n  isShiftZero = shift == 0;\n  if (shiftAmount < 0x20) {\n    isShiftCarry = SCARRY4(shift,0xc);\n    isShiftNegative = false;\n    isShiftZero = leadingZeros + 1 == 0;\n    shift = shiftAmount;\n    if (!isShiftZero && isShiftCarry == false) {\n      count = absInput << shiftAmount;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isShiftZero || isShiftNegative != isShiftCarry) {\n    invertedShift = 0x20 - shift;\n  }\n  absInput = absInput << (shift & 0xff);\n  if (isShiftZero || isShiftNegative != isShiftCarry) {\n    absInput = absInput | 0U >> (invertedShift & 0xff);\n  }\n  if (isShiftZero || isShiftNegative != isShiftCarry) {\n    count = 0 << (shift & 0xff);\n  }\nLAB_080002f0:\n  if (shiftAmount < 0x433) {\n    return CONCAT44(absInput + (0x432 - shiftAmount) * 0x100000 | isNegative,count);\n  }\n  shift = ~(0x432 - shiftAmount);\n  if (0x1e < (int)shift) {\n    return CONCAT44(input,absInput >> (shift - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shift - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shift - 0x1f,0xc)) {\n    shift = shift + 1;\n    return CONCAT44(isNegative | absInput >> (shift & 0xff),\n                    count >> (shift & 0xff) | absInput << (0x20 - shift & 0xff));\n  }\n  return CONCAT44(input,count >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000404": "count_bits_and_shift_08000404",
                "param_1": "input",
                "uVar1": "count",
                "uVar2": "absInput",
                "uVar3": "shift",
                "iVar4": "leadingZeros",
                "uVar5": "shiftAmount",
                "uVar6": "isNegative",
                "in_r12": "invertedShift",
                "bVar7": "isShiftNegative",
                "bVar8": "isShiftZero",
                "bVar9": "isShiftCarry"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000428": {
            "entrypoint": "0x08000428",
            "current_name": "decode_and_shift_bits_08000428",
            "code": "\nulonglong decodeAndShiftBits_08000428(uint inputValue,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint result;\n  uint tempValue1;\n  uint tempValue2;\n  uint tempValue3;\n  uint shiftedInput;\n  int bitCount;\n  uint tempValue4;\n  uint extraShift;\n  bool isNegative1;\n  bool isZero1;\n  bool isNegative2;\n  \n  shiftedInput = inputValue << 1;\n  isZero1 = shiftedInput == 0;\n  result = (uint)((inputValue & 0x80000000) != 0) << 0x1f;\n  tempValue3 = (uint)((int)shiftedInput >> 3) >> 1;\n  tempValue2 = result | tempValue3;\n  inputValue = inputValue << 0x1d;\n  if (!isZero1) {\n    param4 = shiftedInput & 0xff000000;\n    isZero1 = param4 == 0;\n  }\n  if (!isZero1) {\n    isZero1 = param4 == 0xff000000;\n  }\n  if (!isZero1) {\n    return CONCAT44(tempValue2,inputValue) ^ 0x3800000000000000;\n  }\n  if (shiftedInput == 0 || param4 == 0xff000000) {\n    return CONCAT44(tempValue2,inputValue);\n  }\n  tempValue1 = inputValue;\n  shiftedInput = tempValue3;\n  if (tempValue3 == 0) {\n    tempValue1 = 0;\n    shiftedInput = inputValue;\n  }\n  bitCount = LZCOUNT(shiftedInput);\n  if (tempValue3 == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  tempValue4 = bitCount - 0xb;\n  isNegative2 = SBORROW4(tempValue4,0x20);\n  tempValue3 = bitCount - 0x2b;\n  isZero1 = (int)tempValue3 < 0;\n  isNegative1 = tempValue3 == 0;\n  if ((int)tempValue4 < 0x20) {\n    isNegative2 = SCARRY4(tempValue3,0xc);\n    bitCount = bitCount + -0x1f;\n    isZero1 = bitCount < 0;\n    isNegative1 = bitCount == 0;\n    tempValue3 = tempValue4;\n    if (!isNegative1 && isZero1 == isNegative2) {\n      tempValue1 = shiftedInput << (tempValue4 & 0xff);\n      shiftedInput = shiftedInput >> (0xcU - bitCount & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isNegative1 || isZero1 != isNegative2) {\n    extraShift = 0x20 - tempValue3;\n  }\n  shiftedInput = shiftedInput << (tempValue3 & 0xff);\n  if (isNegative1 || isZero1 != isNegative2) {\n    shiftedInput = shiftedInput | tempValue1 >> (extraShift & 0xff);\n  }\n  if (isNegative1 || isZero1 != isNegative2) {\n    tempValue1 = tempValue1 << (tempValue3 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)tempValue4 < 0x381) {\n    return CONCAT44(shiftedInput + (0x380 - tempValue4) * 0x100000 | result,tempValue1);\n  }\n  tempValue3 = ~(0x380 - tempValue4);\n  if ((int)tempValue3 < 0x1f) {\n    bitCount = tempValue3 - 0x13;\n    if (bitCount != 0 && bitCount < 0 == SCARRY4(tempValue3 - 0x1f,0xc)) {\n      return CONCAT44(tempValue2,tempValue1 >> (0x20 - (0xcU - bitCount) & 0xff) | shiftedInput << (0xcU - bitCount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    tempValue3 = tempValue3 + 1;\n    return CONCAT44(result | shiftedInput >> (tempValue3 & 0xff),\n                    tempValue1 >> (tempValue3 & 0xff) | shiftedInput << (0x20 - tempValue3 & 0xff));\n  }\n  return CONCAT44(tempValue2,shiftedInput >> (tempValue3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000428": "decode_and_shift_bits_08000428",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result",
                "uVar2": "tempValue1",
                "uVar3": "tempValue2",
                "uVar4": "tempValue3",
                "uVar5": "shiftedInput",
                "iVar6": "bitCount",
                "uVar7": "tempValue4",
                "in_r12": "extraShift",
                "bVar8": "isNegative1",
                "bVar9": "isZero1",
                "bVar10": "isNegative2"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000464": {
            "entrypoint": "0x08000464",
            "current_name": "calculate_fused_value_08000464",
            "code": "\nulonglong calculateFusedValue_08000464(uint input1,uint input2)\n\n{\n  byte byteValue;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int temp4;\n  uint temp5;\n  int temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  temp6 = 0x432;\n  temp7 = input2 >> 0x16;\n  if (temp7 != 0) {\n    temp6 = 3;\n    if (input2 >> 0x19 != 0) {\n      temp6 = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      temp6 = temp6 + 3;\n    }\n    temp3 = temp6 - ((int)input2 >> 0x1f);\n    temp7 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    temp6 = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      byteValue = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      temp7 = (uint)(byteValue & 1) << 0x1f | temp7 >> 1;\n      temp6 = temp6 + 1;\n      if (0xffbfffff < (uint)(temp6 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000278:\n    flag2 = 0x7fffffff < temp7;\n    if (temp7 == 0x80000000) {\n      flag2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + temp6 * 0x100000 + (uint)CARRY4(input1,(uint)flag2),input1 + flag2\n                   );\n  }\n  flag1 = (temp7 & 0x80000000) != 0;\n  temp7 = temp7 << 1;\n  temp3 = input1 * 2;\n  flag2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)flag1;\n  input2 = input2 * 2 + (uint)(flag2 || CARRY4(temp3,(uint)flag1));\n  temp6 = temp6 + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000278;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  temp4 = LZCOUNT(temp3);\n  if (input2 == 0) {\n    temp4 = temp4 + 0x20;\n  }\n  temp5 = temp4 - 0xb;\n  flag3 = SBORROW4(temp5,0x20);\n  temp2 = temp4 - 0x2b;\n  flag2 = (int)temp2 < 0;\n  flag1 = temp2 == 0;\n  if ((int)temp5 < 0x20) {\n    flag3 = SCARRY4(temp2,0xc);\n    temp4 = temp4 + -0x1f;\n    flag2 = temp4 < 0;\n    flag1 = temp4 == 0;\n    temp2 = temp5;\n    if (!flag1 && flag2 == flag3) {\n      temp1 = temp3 << (temp5 & 0xff);\n      temp3 = temp3 >> (0xcU - temp4 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp7 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp3 = temp3 | temp1 >> (temp7 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp5 <= temp6) {\n    return CONCAT44(temp3 + (temp6 - temp5) * 0x100000,temp1);\n  }\n  temp7 = ~(temp6 - temp5);\n  if (0x1e < (int)temp7) {\n    return (ulonglong)(temp3 >> (temp7 - 0x1f & 0xff));\n  }\n  temp6 = temp7 - 0x13;\n  if (temp6 == 0 || temp6 < 0 != SCARRY4(temp7 - 0x1f,0xc)) {\n    temp7 = temp7 + 1;\n    return CONCAT44(temp3 >> (temp7 & 0xff),temp1 >> (temp7 & 0xff) | temp3 << (0x20 - temp7 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - temp6) & 0xff) | temp3 << (0xcU - temp6 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_08000464": "calculate_fused_value_08000464",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "byteValue",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "temp5",
                "iVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000474": {
            "entrypoint": "0x08000474",
            "current_name": "calculate_08000474",
            "code": "\nulonglong calculate_08000474(uint input1,uint input2)\n\n{\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint shift;\n  int bitCount;\n  uint shiftedBits;\n  int exponent;\n  uint signBit;\n  uint finalBits;\n  bool bitShifted;\n  bool carryShift;\n  bool carryShifted;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  signBit = input2 & 0x80000000;\n  temp2 = input2;\n  if ((int)signBit < 0) {\n    carryShift = input1 != 0;\n    input1 = -input1;\n    temp2 = -input2 - (uint)carryShift;\n  }\n  exponent = 0x432;\n  finalBits = temp2 >> 0x16;\n  if (finalBits != 0) {\n    exponent = 3;\n    if (temp2 >> 0x19 != 0) {\n      exponent = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      exponent = exponent + 3;\n    }\n    shift = exponent - ((int)temp2 >> 0x1f);\n    finalBits = input1 << (0x20 - shift & 0xff);\n    input1 = input1 >> (shift & 0xff) | temp2 << (0x20 - shift & 0xff);\n    temp2 = temp2 >> (shift & 0xff);\n    exponent = shift + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      shift = temp2 & 1;\n      temp2 = temp2 >> 1;\n      carry = (byte)input1;\n      input1 = (uint)(shift != 0) << 0x1f | input1 >> 1;\n      finalBits = (uint)(carry & 1) << 0x1f | finalBits >> 1;\n      exponent = exponent + 1;\n      if (0xffbfffff < (uint)(exponent * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000278:\n    carryShift = 0x7fffffff < finalBits;\n    if (finalBits == 0x80000000) {\n      carryShift = (input1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + exponent * 0x100000 + (uint)CARRY4(input1,(uint)carryShift) | signBit,\n                    input1 + carryShift);\n  }\n  bitShifted = (finalBits & 0x80000000) != 0;\n  finalBits = finalBits << 1;\n  shift = input1 * 2;\n  carryShift = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)bitShifted;\n  temp2 = temp2 * 2 + (uint)(carryShift || CARRY4(shift,(uint)bitShifted));\n  exponent = exponent + -1;\n  if ((temp2 & 0x100000) != 0) goto LAB_08000278;\n  temp1 = input1;\n  shift = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    shift = input1;\n  }\n  bitCount = LZCOUNT(shift);\n  if (temp2 == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  shiftedBits = bitCount - 0xb;\n  carryShifted = SBORROW4(shiftedBits,0x20);\n  temp2 = bitCount - 0x2b;\n  carryShift = (int)temp2 < 0;\n  bitShifted = temp2 == 0;\n  if ((int)shiftedBits < 0x20) {\n    carryShifted = SCARRY4(temp2,0xc);\n    bitCount = bitCount + -0x1f;\n    carryShift = bitCount < 0;\n    bitShifted = bitCount == 0;\n    temp2 = shiftedBits;\n    if (!bitShifted && carryShift == carryShifted) {\n      temp1 = shift << (shiftedBits & 0xff);\n      shift = shift >> (0xcU - bitCount & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bitShifted || carryShift != carryShifted) {\n    finalBits = 0x20 - temp2;\n  }\n  shift = shift << (temp2 & 0xff);\n  if (bitShifted || carryShift != carryShifted) {\n    shift = shift | temp1 >> (finalBits & 0xff);\n  }\n  if (bitShifted || carryShift != carryShifted) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)shiftedBits <= exponent) {\n    return CONCAT44(shift + (exponent - shiftedBits) * 0x100000 | signBit,temp1);\n  }\n  temp2 = ~(exponent - shiftedBits);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(input2,shift >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  exponent = temp2 - 0x13;\n  if (exponent == 0 || exponent < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(signBit | shift >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | shift << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(input2,temp1 >> (0x20 - (0xcU - exponent) & 0xff) | shift << (0xcU - exponent & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000474": "calculate_08000474",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "carry",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "shift",
                "iVar5": "bitCount",
                "uVar6": "shiftedBits",
                "iVar7": "exponent",
                "uVar8": "signBit",
                "uVar9": "finalBits",
                "bVar10": "bitShifted",
                "bVar11": "carryShift",
                "bVar12": "carryShifted"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d0": {
            "entrypoint": "0x080004d0",
            "current_name": "calculate_bitwise_product_080004d0",
            "code": "\nulonglong calculate_bitwise_product_080004d0(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong result_lower;\n  longlong temp;\n  uint temp2;\n  uint temp3;\n  int temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  ulonglong result;\n  \n  result = CONCAT44(input2,input1);\n  temp7 = 0x7ff;\n  temp3 = input2 >> 0x14 & 0x7ff;\n  condition1 = temp3 == 0;\n  if (!condition1) {\n    temp6 = input4 >> 0x14 & 0x7ff;\n    condition1 = temp6 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp3 == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = temp6 == 0x7ff;\n  }\n  if (condition1) {\n    result = calculate_bitwise_difference_080006ac();\n  }\n  temp2 = (uint)(result >> 0x20);\n  temp4 = temp3 + temp6;\n  temp3 = temp2 ^ input4;\n  temp2 = temp2 & ~(temp7 << 0x15);\n  input4 = input4 & ~(temp7 << 0x15);\n  condition1 = ((uint)result | temp2 << 0xc) == 0;\n  if (!condition1) {\n    condition1 = (input3 | input4 << 0xc) == 0;\n  }\n  temp2 = temp2 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (condition1) {\n    input3 = (uint)result | input3;\n    input4 = (temp3 & 0x80000000 | temp2) ^ input4;\n    temp3 = temp7 >> 1;\n    condition3 = SBORROW4(temp4,temp3);\n    temp5 = temp4 - temp3;\n    condition1 = temp5 == 0;\n    temp2 = temp5;\n    if (!condition1 && (int)temp3 <= temp4) {\n      condition3 = SBORROW4(temp7,temp5);\n      temp2 = temp7 - temp5;\n      condition1 = temp7 == temp5;\n    }\n    if (!condition1 && (int)temp2 < 0 == condition3) {\n      input4 = input4 | temp5 * 0x100000;\n    }\n    if (!condition1 && (int)temp2 < 0 == condition3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    temp7 = 0;\n    condition3 = SBORROW4(temp5,1);\n    temp5 = temp5 - 1;\n    condition1 = temp5 == 0;\n    temp3 = temp5;\n  }\n  else {\n    result_lower = (result & 0xffffffff) * (ulonglong)input3;\n    result = (result & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)temp2 * (ulonglong)input3 + (result_lower >> 0x20);\n    temp8 = (uint)result;\n    temp = (ulonglong)temp2 * (ulonglong)input4 + (result >> 0x20);\n    temp7 = (uint)temp;\n    temp2 = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result_lower != 0) {\n      temp8 = temp8 | 1;\n    }\n    temp5 = (temp4 + -0x3ff) - (uint)(temp2 < 0x200);\n    if (temp2 < 0x200) {\n      condition1 = (temp8 & 0x80000000) != 0;\n      temp8 = temp8 << 1;\n      temp = CONCAT44(temp2 * 2 + (uint)(CARRY4(temp7,temp7) || CARRY4(temp7 * 2,(uint)condition1)),\n                       temp7 * 2 + (uint)condition1);\n    }\n    input4 = temp3 & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    input3 = (uint)temp << 0xb | temp8 >> 0x15;\n    temp7 = temp8 * 0x800;\n    condition2 = 0xfc < temp5;\n    condition3 = SBORROW4(temp5,0xfd);\n    temp2 = temp5 - 0xfd;\n    condition1 = temp2 == 0;\n    temp3 = temp2;\n    if (condition2 && !condition1) {\n      condition2 = 0x6ff < temp2;\n      condition3 = SBORROW4(temp2,0x700);\n      temp3 = temp5 - 0x7fd;\n      condition1 = temp2 == 0x700;\n    }\n    if (!condition2 || condition1) {\n      condition1 = 0x7fffffff < temp7;\n      if (temp7 == 0x80000000) {\n        condition1 = (temp8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + temp5 * 0x100000 + (uint)CARRY4(input3,(uint)condition1),input3 + condition1\n                     );\n    }\n  }\n  if (!condition1 && (int)temp3 < 0 == condition3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition2 = SCARRY4(temp5,0x36);\n  condition1 = (int)(temp5 + 0x36) < 0;\n  condition3 = temp5 == 0xffffffca;\n  if (condition3 || condition1 != condition2) {\n    input3 = 0;\n  }\n  if (condition3 || condition1 != condition2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (condition3 || condition1 != condition2) {\n    return CONCAT44(input4,input3);\n  }\n  temp3 = -temp5;\n  temp2 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp5 = input3 >> (temp2 & 0xff) | input4 << (0x20 - temp2 & 0xff);\n    temp3 = (input4 >> (temp2 & 0xff) & ~((input4 & 0x80000000) >> (temp2 & 0xff))) -\n            ((int)temp5 >> 0x1f);\n    if ((temp7 | input3 << (0x20 - temp2 & 0xff) | temp5 << 1) == 0) {\n      temp3 = temp3 & ~(temp5 >> 0x1f);\n    }\n    return CONCAT44(input4,temp3) & 0x80000000ffffffff;\n  }\n  temp4 = temp3 - 0x14;\n  if (temp4 == 0 || temp4 < 0 != SCARRY4(temp2,0xc)) {\n    temp8 = input3 << (temp5 + 0x20 & 0xff);\n    temp2 = input3 >> (temp3 & 0xff) | input4 << (temp5 + 0x20 & 0xff);\n    temp5 = temp2 + -((int)temp8 >> 0x1f);\n    if ((temp7 | temp8 << 1) == 0) {\n      temp5 = temp5 & ~(temp8 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (temp3 & 0xff)) +\n                    (uint)CARRY4(temp2,-((int)temp8 >> 0x1f)),temp5);\n  }\n  temp3 = 0xc - temp4;\n  temp5 = input3 << (temp3 & 0xff);\n  temp3 = input3 >> (0x20 - temp3 & 0xff) | input4 << (temp3 & 0xff);\n  temp2 = temp3 + -((int)temp5 >> 0x1f);\n  if ((temp7 | temp5 << 1) == 0) {\n    temp2 = temp2 & ~(temp5 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(temp3,-((int)temp5 >> 0x1f)),temp2);\n}\n\n",
            "renaming": {
                "FUN_080004d0": "calculate_bitwise_product_080004d0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result_lower",
                "lVar2": "temp",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "temp5",
                "unaff_r5": "temp6",
                "uVar7": "temp7",
                "uVar8": "temp8",
                "bVar9": "condition1",
                "bVar10": "condition2",
                "bVar11": "condition3",
                "uVar12": "result"
            },
            "calling": [
                "pow",
                "scalbn",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_080006ac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006ac": {
            "entrypoint": "0x080006ac",
            "current_name": "calculate_bitwise_difference_080006ac",
            "code": "\nulonglong calculateBitwiseDifference_080006ac(uint num1,uint num2,uint num3,uint num4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint result;\n  uint temp;\n  uint mask;\n  bool isZero;\n  \n  result = mask & num4 >> 0x14;\n  if (bit2 != mask && result != mask) {\n    isZero = (num1 | num2 << 1) == 0;\n    if (!isZero) {\n      isZero = (num3 | num4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((num2 ^ num4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      temp = num2 & 0x80000000;\n      do {\n        bit1 = num1 & 0x80000000;\n        num1 = num1 << 1;\n        num2 = num2 * 2 + (uint)(bit1 != 0);\n      } while ((num2 & 0x100000) == 0);\n      num2 = num2 | temp;\n      if (result != 0) {\n        return CONCAT44(num2,num1);\n      }\n    }\n    do {\n      result = num3 & 0x80000000;\n      num3 = num3 << 1;\n      num4 = num4 * 2 + (uint)(result != 0);\n    } while ((num4 & 0x100000) == 0);\n    return CONCAT44(num2,num1);\n  }\n  isZero = (num1 | num2 << 1) == 0;\n  if (isZero) {\n    num2 = num4;\n    num1 = num3;\n  }\n  if (!isZero) {\n    isZero = (num3 | num4 << 1) == 0;\n  }\n  temp = num2;\n  if (((!isZero) && ((bit2 != mask || ((num1 | num2 << 0xc) == 0)))) &&\n     ((result != mask || (num1 = num3, temp = num4, (num3 | num4 << 0xc) == 0)))) {\n    return (ulonglong)((num2 ^ num4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp,num1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006ac": "calculate_bitwise_difference_080006ac",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "result",
                "uVar3": "temp",
                "in_r12": "mask",
                "bVar4": "isZero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000724": {
            "entrypoint": "0x08000724",
            "current_name": "decode_and_compute_08000724",
            "code": "\nulonglong decode_and_compute_08000724(undefined4 param1,uint param2,uint param3,uint param4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  undefined8 temp15;\n  \n  temp15 = CONCAT44(param2,param1);\n  temp14 = 0x7ff;\n  temp7 = param2 >> 0x14 & 0x7ff;\n  flag1 = temp7 == 0;\n  if (!flag1) {\n    temp10 = param4 >> 0x14 & 0x7ff;\n    flag1 = temp10 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp10 == 0x7ff;\n  }\n  if (flag1) {\n    temp15 = decode_and_compute_08000724_08000892();\n  }\n  temp9 = (uint)((ulonglong)temp15 >> 0x20);\n  temp12 = (uint)temp15;\n  temp8 = temp7 - temp10;\n  if ((param3 | param4 << 0xc) == 0) {\n    temp7 = (temp9 ^ param4) & 0x80000000 | temp9 & 0xfffff;\n    flag3 = SCARRY4(temp8,temp14 >> 1);\n    temp9 = temp8 + (temp14 >> 1);\n    flag1 = (int)temp9 < 0;\n    flag2 = temp9 == 0;\n    if (!flag2 && flag1 == flag3) {\n      flag3 = SBORROW4(temp14,temp9);\n      flag1 = (int)(temp14 - temp9) < 0;\n      flag2 = temp14 == temp9;\n    }\n    if (!flag2 && flag1 == flag3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!flag2 && flag1 == flag3) {\n      return CONCAT44(temp7,temp12);\n    }\n    temp7 = temp7 | 0x100000;\n    temp14 = 0;\n    flag2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    flag1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (param4 << 0xc) >> 4 | 0x10000000 | param3 >> 0x18;\n    temp14 = param3 << 8;\n    temp11 = (temp9 << 0xc) >> 4 | 0x10000000 | temp12 >> 0x18;\n    temp12 = temp12 * 0x100;\n    temp7 = (temp9 ^ param4) & 0x80000000;\n    flag1 = temp3 <= temp11;\n    if (temp11 == temp3) {\n      flag1 = temp14 <= temp12;\n    }\n    temp8 = temp8 + (uint)flag1;\n    temp9 = temp8 + 0x3fd;\n    if (flag1 == false) {\n      temp3 = temp3 >> 1;\n      temp14 = (uint)((param3 >> 0x18 & 1) != 0) << 0x1f | temp14 >> 1;\n    }\n    temp13 = temp12 - temp14;\n    temp11 = (temp11 - temp3) - (uint)(temp12 < temp14);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp14 >> 1;\n    temp12 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      flag1 = temp1 <= temp13;\n      if (temp4 < temp11 || temp11 - temp4 < (uint)flag1) {\n        temp13 = temp13 - temp1;\n        temp12 = temp12 | temp3;\n        temp11 = (temp11 - temp4) - (uint)!flag1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp11 - temp5 < (uint)flag2;\n      temp14 = temp11;\n      if (temp5 < temp11 || flag1) {\n        temp13 = temp13 - temp1;\n        temp14 = (temp11 - temp5) - (uint)!flag2;\n      }\n      if (temp5 < temp11 || flag1) {\n        temp12 = temp12 | temp3 >> 1;\n      }\n      temp11 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp2 <= temp13;\n      flag1 = temp14 - temp11 < (uint)flag2;\n      temp5 = temp14;\n      if (temp11 < temp14 || flag1) {\n        temp13 = temp13 - temp2;\n        temp5 = (temp14 - temp11) - (uint)!flag2;\n      }\n      if (temp11 < temp14 || flag1) {\n        temp12 = temp12 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp11 & 1) != 0) << 0x1f | temp2 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp5 - temp6 < (uint)flag2;\n      temp11 = temp5;\n      if (temp6 < temp5 || flag1) {\n        temp13 = temp13 - temp1;\n        temp11 = (temp5 - temp6) - (uint)!flag2;\n      }\n      if (temp6 < temp5 || flag1) {\n        temp12 = temp12 | temp3 >> 3;\n      }\n      temp14 = temp11 | temp13;\n      if (temp14 == 0) break;\n      temp11 = temp11 << 4 | temp13 >> 0x1c;\n      temp13 = temp13 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_08000842;\n        temp7 = temp7 | temp12;\n        temp12 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp12;\n      temp12 = 0;\n    }\nLAB_08000842:\n    flag3 = 0xfc < temp9;\n    flag2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    flag1 = temp4 == 0;\n    temp3 = temp4;\n    if (flag3 && !flag1) {\n      flag3 = 0x6ff < temp4;\n      flag2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      flag1 = temp4 == 0x700;\n    }\n    if (!flag3 || flag1) {\n      flag1 = temp6 <= temp11;\n      if (temp11 == temp6) {\n        flag1 = temp1 <= temp13;\n      }\n      if (temp11 == temp6 && temp13 == temp1) {\n        flag1 = (temp12 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp12,(uint)flag1),temp12 + flag1);\n    }\n  }\n  if (!flag1 && (int)temp3 < 0 == flag2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag3 = SCARRY4(temp9,0x36);\n  flag1 = (int)(temp9 + 0x36) < 0;\n  flag2 = temp9 == 0xffffffca;\n  if (flag2 || flag1 != flag3) {\n    temp12 = 0;\n  }\n  if (flag2 || flag1 != flag3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (flag2 || flag1 != flag3) {\n    return CONCAT44(temp7,temp12);\n  }\n  temp3 = -temp9;\n  temp11 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp12 >> (temp11 & 0xff) | temp7 << (0x20 - temp11 & 0xff);\n    temp9 = (temp7 >> (temp11 & 0xff) & ~((temp7 & 0x80000000) >> (temp11 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp14 | temp12 << (0x20 - temp11 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp11,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp12 << (temp9 & 0xff);\n    temp12 = temp12 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp12 + -((int)temp3 >> 0x1f);\n    if ((temp14 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp12,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp11 = temp12 << (temp9 + 0x20 & 0xff);\n  temp12 = temp12 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp12 + -((int)temp11 >> 0x1f);\n  if ((temp14 | temp11 << 1) == 0) {\n    temp9 = temp9 & ~(temp11 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp12,-((int)temp11 >> 0x1f)),temp9);\n}\n\n",
            "renaming": {
                "FUN_08000724": "decode_and_compute_08000724",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "unaff_r5": "temp10",
                "uVar10": "temp11",
                "uVar11": "temp12",
                "uVar12": "temp13",
                "uVar13": "temp14",
                "bVar14": "flag1",
                "bVar15": "flag2",
                "bVar16": "flag3",
                "uVar17": "temp15"
            },
            "calling": [
                "pow",
                "__ieee754_atan2",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_08000892"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000892": {
            "entrypoint": "0x08000892",
            "current_name": "decode_and_compute_08000892",
            "code": "\nulonglong decode_and_compute_08000892(uint input_val_1,uint input_val_2,uint input_val_3,uint input_val_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint bit_4;\n  uint mask;\n  bool is_zero;\n  \n  bit_3 = mask & input_val_4 >> 0x14;\n  bit_4 = input_val_2;\n  if (bit_2 != mask || bit_3 != mask) {\n    if (bit_2 == mask) {\n      if (((input_val_1 | input_val_2 << 0xc) == 0) && (input_val_1 = input_val_3, bit_4 = input_val_4, bit_3 != mask)\n         ) {\nreturn_value_1:\n        return (ulonglong)((input_val_2 ^ input_val_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit_3 == mask) {\n      input_val_1 = input_val_3;\n      bit_4 = input_val_4;\n      if ((input_val_3 | input_val_4 << 0xc) == 0) {\nreturn_value_2:\n        return (ulonglong)((input_val_2 ^ input_val_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (input_val_1 | input_val_2 << 1) == 0;\n      if (!is_zero) {\n        is_zero = (input_val_3 | input_val_4 << 1) == 0;\n      }\n      if (!is_zero) {\n        if (bit_2 == 0) {\n          bit_4 = input_val_2 & 0x80000000;\n          do {\n            bit_1 = input_val_1 & 0x80000000;\n            input_val_1 = input_val_1 << 1;\n            input_val_2 = input_val_2 * 2 + (uint)(bit_1 != 0);\n          } while ((input_val_2 & 0x100000) == 0);\n          input_val_2 = input_val_2 | bit_4;\n          if (bit_3 != 0) {\n            return CONCAT44(input_val_2,input_val_1);\n          }\n        }\n        do {\n          bit_4 = input_val_3 & 0x80000000;\n          input_val_3 = input_val_3 << 1;\n          input_val_4 = input_val_4 * 2 + (uint)(bit_4 != 0);\n        } while ((input_val_4 & 0x100000) == 0);\n        return CONCAT44(input_val_2,input_val_1);\n      }\n      if ((input_val_1 | input_val_2 << 1) != 0) goto return_value_1;\n      if ((input_val_3 | input_val_4 << 1) != 0) goto return_value_2;\n    }\n  }\n  return CONCAT44(bit_4,input_val_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08000892": "decode_and_compute_08000892",
                "param_1": "input_val_1",
                "param_2": "input_val_2",
                "param_3": "input_val_3",
                "param_4": "input_val_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "bit_4",
                "in_r12": "mask",
                "bVar4": "is_zero",
                "LAB_08000704": "return_value_1",
                "LAB_080006c8": "return_value_2"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_parameters_080008f4",
            "code": "\nuint check_parameters_080008f4(uint input_1,uint shifted_2,uint input_3,uint shifted_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLessOrEqual;\n  \n  if (((int)(shifted_2 << 1) >> 0x15 == -1 || (int)(shifted_4 << 1) >> 0x15 == -1) &&\n     ((((int)(shifted_2 << 1) >> 0x15 == -1 && ((input_1 | shifted_2 << 0xc) != 0)) ||\n      (((int)(shifted_4 << 1) >> 0x15 == -1 && ((input_3 | shifted_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (input_1 | shifted_2 << 1) == 0;\n  if (isZero) {\n    isZero = (input_3 | shifted_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = shifted_2 == shifted_4;\n  }\n  if (isZero) {\n    isZero = input_1 == input_3;\n  }\n  if (!isZero) {\n    result = shifted_2 ^ shifted_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = shifted_2 == shifted_4;\n    }\n    isLessOrEqual = -1 < (int)result && shifted_4 <= shifted_2;\n    if (isZero) {\n      isLessOrEqual = input_3 <= input_1;\n    }\n    shifted_4 = (int)shifted_4 >> 0x1f;\n    if (!isLessOrEqual) {\n      shifted_4 = ~shifted_4;\n    }\n    return shifted_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_parameters_080008f4",
                "param_1": "input_1",
                "param_2": "shifted_2",
                "param_3": "input_3",
                "param_4": "shifted_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLessOrEqual"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_equality_and_zero_080008fc",
            "code": "\nuint checkEqualityAndZero_080008fc(uint arg1,uint arg2,uint arg3,uint arg4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLessThanOrEqual;\n  \n  if (((int)(arg2 << 1) >> 0x15 == -1 || (int)(arg4 << 1) >> 0x15 == -1) &&\n     ((((int)(arg2 << 1) >> 0x15 == -1 && ((arg1 | arg2 << 0xc) != 0)) ||\n      (((int)(arg4 << 1) >> 0x15 == -1 && ((arg3 | arg4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (arg1 | arg2 << 1) == 0;\n  if (isZero) {\n    isZero = (arg3 | arg4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = arg2 == arg4;\n  }\n  if (isZero) {\n    isZero = arg1 == arg3;\n  }\n  if (!isZero) {\n    result = arg2 ^ arg4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = arg2 == arg4;\n    }\n    isLessThanOrEqual = -1 < (int)result && arg4 <= arg2;\n    if (isZero) {\n      isLessThanOrEqual = arg3 <= arg1;\n    }\n    arg4 = (int)arg4 >> 0x1f;\n    if (!isLessThanOrEqual) {\n      arg4 = ~arg4;\n    }\n    return arg4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_equality_and_zero_080008fc",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLessThanOrEqual"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000904": {
            "entrypoint": "0x08000904",
            "current_name": "compare_params_08000904",
            "code": "\nuint compareParams_08000904(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool areParamsZero;\n  bool isParam4Lower;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  areParamsZero = (value1 | value2 << 1) == 0;\n  if (areParamsZero) {\n    areParamsZero = (value3 | value4 << 1) == 0;\n  }\n  if (!areParamsZero) {\n    areParamsZero = value2 == value4;\n  }\n  if (areParamsZero) {\n    areParamsZero = value1 == value3;\n  }\n  if (!areParamsZero) {\n    result = value2 ^ value4;\n    areParamsZero = result == 0;\n    if (-1 < (int)result) {\n      areParamsZero = value2 == value4;\n    }\n    isParam4Lower = -1 < (int)result && value4 <= value2;\n    if (areParamsZero) {\n      isParam4Lower = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isParam4Lower) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000904": "compare_params_08000904",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "areParamsZero",
                "bVar3": "isParam4Lower"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000980": {
            "entrypoint": "0x08000980",
            "current_name": "compare_floating_point_numbers_08000980",
            "code": "\nvoid compareFloatingPointNumbers_08000980(undefined4 result,undefined4 status,undefined4 number1,undefined4 number2)\n\n{\n  __aeabi_cdcmpeq(number1,number2,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000980": "compare_floating_point_numbers_08000980",
                "param_1": "result",
                "param_2": "status",
                "param_3": "number1",
                "param_4": "number2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000990": {
            "entrypoint": "0x08000990",
            "current_name": "convert_float_to_undefined_08000990",
            "code": "\nundefined4 convertFloatToUndefined_08000990(undefined4 value)\n\n{\n  floatingPointConversionFunction();\n  return value;\n}\n\n",
            "renaming": {
                "FUN_08000990": "convert_float_to_undefined_08000990",
                "param_1": "value",
                "__nedf2": "floatingPointConversionFunction"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a0": {
            "entrypoint": "0x080009a0",
            "current_name": "check_cdcmp_result_080009a0",
            "code": "\nbool check_cdcmp_result_080009a0(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009a0": "check_cdcmp_result_080009a0",
                "in_ZR": "comparison_result"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b4": {
            "entrypoint": "0x080009b4",
            "current_name": "check_if_null_character_080009b4",
            "code": "\nbool checkIfNullCharacter_080009b4(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdcmpeq();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009b4": "check_if_null_character_080009b4",
                "in_CY": "inputChar"
            },
            "calling": [
                "pow",
                "sqrt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "check_zero_and_carry_080009c8",
            "code": "\nbool check_zero_and_carry_080009c8(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c8": "check_zero_and_carry_080009c8",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "is_comparison_result_valid_080009dc",
            "code": "\nbool isComparisonResultValid_080009dc(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_080009dc": "is_comparison_result_valid_080009dc",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "is_null_string_080009f0",
            "code": "\nbool is_null_string_080009f0(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009f0": "is_null_string_080009f0",
                "in_CY": "input_char"
            },
            "calling": [
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_conditions_08000a04",
            "code": "\nundefined4 check_conditions_08000a04(uint value_1,int shifted_value_2,uint value_3,int shifted_value_4)\n\n{\n  if ((((shifted_value_2 << 1) >> 0x15 != -1) || ((value_1 | shifted_value_2 << 0xc) == 0)) &&\n     (((shifted_value_4 << 1) >> 0x15 != -1 || ((value_3 | shifted_value_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_conditions_08000a04",
                "param_1": "value_1",
                "param_2": "shifted_value_2",
                "param_3": "value_3",
                "param_4": "shifted_value_4"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a30": {
            "entrypoint": "0x08000a30",
            "current_name": "calculate_float_08000a30",
            "code": "\nuint calculateFloat_08000a30(uint num1,uint num2)\n\n{\n  uint result;\n  uint temp;\n  uint newVal;\n  uint condition1;\n  bool isZero;\n  bool check1;\n  \n  temp = num2 * 2;\n  check1 = temp < 0x70000000;\n  newVal = temp + 0x90000000;\n  result = newVal;\n  if (!check1) {\n    condition1 = temp + 0x8fe00000;\n    result = condition1;\n  }\n  isZero = result == 0;\n  if (!check1 && newVal >= 0x200000) {\n    isZero = condition1 == 0x1fc00000;\n  }\n  if (((check1 || newVal < 0x200000) || 0x1fc00000 < condition1) || isZero) {\n    if ((num2 & 0x40000000) != 0) {\n      if (((int)temp >> 0x15 == -1) && ((num1 | num2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return num2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp + 0x92e00000) < 0 != SCARRY4(newVal,0x2e00000)) {\n      return num2 & 0x80000000;\n    }\n    temp = 0x18 - (temp + 0x92e00000 >> 0x15);\n    result = num1 >> (temp & 0xff);\n    if (num1 << (0x20 - temp & 0xff) != 0) {\n      result = result | 1;\n    }\n    newVal = num2 & 0x1fffff | 0x100000;\n    num1 = result | newVal << (0x20 - temp & 0xff);\n    newVal = (newVal >> (temp & 0xff)) << 1;\n  }\n  result = (num2 & 0x80000000 | num1 >> 0x1d) + newVal * 4 + (uint)(0x7fffffff < num1 * 8);\n  if (num1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000a30": "calculate_float_08000a30",
                "param_1": "num1",
                "param_2": "num2",
                "uVar1": "result",
                "uVar2": "temp",
                "uVar3": "newVal",
                "in_r12": "condition1",
                "bVar4": "isZero",
                "bVar5": "check1"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad0": {
            "entrypoint": "0x08000ad0",
            "current_name": "convert_and_add_float_08000ad0",
            "code": "\nvoid convertAndAddFloat_08000ad0(uint inputNumber)\n\n{\n  __addsf3(inputNumber ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ad0": "convert_and_add_float_08000ad0",
                "param_1": "inputNumber"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad8": {
            "entrypoint": "0x08000ad8",
            "current_name": "perform_arithmetic_operation_08000ad8",
            "code": "\nuint performArithmeticOperation_08000ad8(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftedInput1;\n  int shiftedInput2;\n  uint bitwiseXor;\n  uint bitwiseXorResult;\n  uint shiftedResult1;\n  uint shiftedResult2;\n  uint resultDifference;\n  bool isConditionSatisfied;\n  \n  bitwiseXor = input2 ^ 0x80000000;\n  shiftedResult1 = input1 << 1;\n  isConditionSatisfied = shiftedResult1 == 0;\n  if (!isConditionSatisfied) {\n    input4 = input2 << 1;\n    isConditionSatisfied = input4 == 0;\n  }\n  if (!isConditionSatisfied) {\n    isConditionSatisfied = shiftedResult1 == input4;\n  }\n  shiftedInput1 = (int)shiftedResult1 >> 0x18;\n  if (!isConditionSatisfied) {\n    isConditionSatisfied = shiftedInput1 == -1;\n  }\n  if (!isConditionSatisfied) {\n    isConditionSatisfied = (int)input4 >> 0x18 == -1;\n  }\n  if (isConditionSatisfied) {\n    shiftedInput2 = (int)(input2 << 1) >> 0x18;\n    if (shiftedInput1 == -1 || shiftedInput2 == -1) {\n      shiftedResult1 = bitwiseXor;\n      if (shiftedInput1 == -1) {\n        shiftedResult1 = input1;\n      }\n      if (shiftedInput1 != -1 || shiftedInput2 != -1) {\n        bitwiseXor = shiftedResult1;\n      }\n      isConditionSatisfied = (shiftedResult1 & 0x7fffff) == 0;\n      if (isConditionSatisfied) {\n        isConditionSatisfied = (bitwiseXor & 0x7fffff) == 0;\n      }\n      if (isConditionSatisfied) {\n        isConditionSatisfied = shiftedResult1 == bitwiseXor;\n      }\n      if (!isConditionSatisfied) {\n        shiftedResult1 = shiftedResult1 | 0x400000;\n      }\n      return shiftedResult1;\n    }\n    if (((input1 ^ bitwiseXor) & 0x7fffffff) != 0) {\n      if (shiftedResult1 == 0) {\n        input1 = bitwiseXor;\n      }\n      return input1;\n    }\n    if (input1 != bitwiseXor) {\n      return 0;\n    }\n    if ((shiftedResult1 & 0xff000000) == 0) {\n      bitwiseXor = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        bitwiseXor = bitwiseXor | 0x80000000;\n      }\n      return bitwiseXor;\n    }\n    if (shiftedResult1 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000c12:\n    return input1 | 0x7f800000;\n  }\n  shiftedResult1 = shiftedResult1 >> 0x18;\n  input4 = input4 >> 0x18;\n  resultDifference = input4 - shiftedResult1;\n  isConditionSatisfied = resultDifference != 0;\n  shiftedResult2 = shiftedResult1;\n  if (isConditionSatisfied && shiftedResult1 <= input4) {\n    shiftedResult2 = shiftedResult1 + resultDifference;\n  }\n  if (isConditionSatisfied && shiftedResult1 <= input4) {\n    bitwiseXor = bitwiseXor ^ input1;\n  }\n  if (isConditionSatisfied && shiftedResult1 <= input4) {\n    input1 = input1 ^ bitwiseXor;\n  }\n  if (isConditionSatisfied && shiftedResult1 <= input4) {\n    bitwiseXor = bitwiseXor ^ input1;\n  }\n  if (input4 < shiftedResult1) {\n    resultDifference = -resultDifference;\n  }\n  if (0x19 < resultDifference) {\n    return input1;\n  }\n  shiftedResult1 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    shiftedResult1 = -shiftedResult1;\n  }\n  bitwiseXorResult = bitwiseXor & 0xffffff | 0x800000;\n  if ((bitwiseXor & 0x80000000) != 0) {\n    bitwiseXorResult = -bitwiseXorResult;\n  }\n  if (shiftedResult2 == resultDifference) {\n    bitwiseXorResult = bitwiseXorResult ^ 0x800000;\n    if (shiftedResult2 == 0) {\n      shiftedResult1 = shiftedResult1 ^ 0x800000;\n      shiftedResult2 = 1;\n    }\n    else {\n      resultDifference = resultDifference - 1;\n    }\n  }\n  shiftedResult1 = shiftedResult1 + ((int)bitwiseXorResult >> (resultDifference & 0xff));\n  bitwiseXorResult = bitwiseXorResult << (0x20 - resultDifference & 0xff);\n  input1 = shiftedResult1 & 0x80000000;\n  if ((int)shiftedResult1 < 0) {\n    isConditionSatisfied = bitwiseXorResult != 0;\n    bitwiseXorResult = -bitwiseXorResult;\n    shiftedResult1 = -shiftedResult1 - (uint)isConditionSatisfied;\n  }\n  if (shiftedResult1 < 0x800000) {\n    bitwiseXor = bitwiseXorResult & 0x80000000;\n    bitwiseXorResult = bitwiseXorResult << 1;\n    shiftedResult1 = shiftedResult1 * 2 + (uint)(bitwiseXor != 0);\n    bitwiseXor = shiftedResult2 - 2;\n    if ((shiftedResult1 & 0x800000) == 0) {\n      resultDifference = LZCOUNT(shiftedResult1) - 8;\n      shiftedResult1 = shiftedResult1 << (resultDifference & 0xff);\n      if ((int)bitwiseXor < (int)resultDifference) {\n        shiftedResult1 = shiftedResult1 >> (-(bitwiseXor - resultDifference) & 0xff);\n      }\n      else {\n        shiftedResult1 = shiftedResult1 + (bitwiseXor - resultDifference) * 0x800000;\n      }\n      return shiftedResult1 | input1;\n    }\n  }\n  else {\n    bitwiseXor = shiftedResult2 - 1;\n    if (0xffffff < shiftedResult1) {\n      bitwiseXor = shiftedResult1 & 1;\n      shiftedResult1 = shiftedResult1 >> 1;\n      bitwiseXorResult = (uint)(bitwiseXor != 0) << 0x1f | bitwiseXorResult >> 1;\n      bitwiseXor = shiftedResult2;\n      if (0xfd < shiftedResult2) goto LAB_08000c12;\n    }\n  }\n  shiftedResult1 = shiftedResult1 + bitwiseXor * 0x800000 + (uint)(0x7fffffff < bitwiseXorResult);\n  if (bitwiseXorResult == 0x80000000) {\n    shiftedResult1 = shiftedResult1 & 0xfffffffe;\n  }\n  return shiftedResult1 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000ad8": "perform_arithmetic_operation_08000ad8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput1",
                "iVar2": "shiftedInput2",
                "uVar3": "bitwiseXor",
                "uVar4": "bitwiseXorResult",
                "uVar5": "shiftedResult1",
                "uVar6": "shiftedResult2",
                "uVar7": "resultDifference",
                "bVar8": "isConditionSatisfied"
            },
            "calling": [
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "AHRS_GetYaw"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000adc": {
            "entrypoint": "0x08000adc",
            "current_name": "calculate_floating_point_value_08000adc",
            "code": "\nuint calculateFloatingPointValue_08000adc(uint firstOperand,uint secondOperand,undefined4 undefined,uint result)\n\n{\n  int shiftedFirstOperand;\n  int shiftedSecondOperand;\n  uint shiftedValue;\n  uint tempValue;\n  uint tempValue2;\n  uint difference;\n  bool isZero;\n  \n  tempValue = firstOperand << 1;\n  isZero = tempValue == 0;\n  if (!isZero) {\n    result = secondOperand << 1;\n    isZero = result == 0;\n  }\n  if (!isZero) {\n    isZero = tempValue == result;\n  }\n  shiftedFirstOperand = (int)tempValue >> 0x18;\n  if (!isZero) {\n    isZero = shiftedFirstOperand == -1;\n  }\n  if (!isZero) {\n    isZero = (int)result >> 0x18 == -1;\n  }\n  if (isZero) {\n    shiftedSecondOperand = (int)(secondOperand << 1) >> 0x18;\n    if (shiftedFirstOperand == -1 || shiftedSecondOperand == -1) {\n      tempValue = secondOperand;\n      if (shiftedFirstOperand == -1) {\n        tempValue = firstOperand;\n      }\n      if (shiftedFirstOperand != -1 || shiftedSecondOperand != -1) {\n        secondOperand = tempValue;\n      }\n      isZero = (tempValue & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (secondOperand & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = tempValue == secondOperand;\n      }\n      if (!isZero) {\n        tempValue = tempValue | 0x400000;\n      }\n      return tempValue;\n    }\n    if (((firstOperand ^ secondOperand) & 0x7fffffff) != 0) {\n      if (tempValue == 0) {\n        firstOperand = secondOperand;\n      }\n      return firstOperand;\n    }\n    if (firstOperand != secondOperand) {\n      return 0;\n    }\n    if ((tempValue & 0xff000000) == 0) {\n      tempValue = firstOperand << 1;\n      if ((firstOperand & 0x80000000) != 0) {\n        tempValue = tempValue | 0x80000000;\n      }\n      return tempValue;\n    }\n    if (tempValue < 0xfe000000) {\n      return firstOperand + 0x800000;\n    }\n    firstOperand = firstOperand & 0x80000000;\nLAB_08000c12:\n    return firstOperand | 0x7f800000;\n  }\n  tempValue = tempValue >> 0x18;\n  result = result >> 0x18;\n  difference = result - tempValue;\n  isZero = difference != 0;\n  tempValue2 = tempValue;\n  if (isZero && tempValue <= result) {\n    tempValue2 = tempValue + difference;\n  }\n  if (isZero && tempValue <= result) {\n    secondOperand = secondOperand ^ firstOperand;\n  }\n  if (isZero && tempValue <= result) {\n    firstOperand = firstOperand ^ secondOperand;\n  }\n  if (isZero && tempValue <= result) {\n    secondOperand = secondOperand ^ firstOperand;\n  }\n  if (result < tempValue) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return firstOperand;\n  }\n  tempValue = firstOperand & 0xffffff | 0x800000;\n  if ((firstOperand & 0x80000000) != 0) {\n    tempValue = -tempValue;\n  }\n  shiftedValue = secondOperand & 0xffffff | 0x800000;\n  if ((secondOperand & 0x80000000) != 0) {\n    shiftedValue = -shiftedValue;\n  }\n  if (tempValue2 == difference) {\n    shiftedValue = shiftedValue ^ 0x800000;\n    if (tempValue2 == 0) {\n      tempValue = tempValue ^ 0x800000;\n      tempValue2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  tempValue = tempValue + ((int)shiftedValue >> (difference & 0xff));\n  shiftedValue = shiftedValue << (0x20 - difference & 0xff);\n  firstOperand = tempValue & 0x80000000;\n  if ((int)tempValue < 0) {\n    isZero = shiftedValue != 0;\n    shiftedValue = -shiftedValue;\n    tempValue = -tempValue - (uint)isZero;\n  }\n  if (tempValue < 0x800000) {\n    difference = shiftedValue & 0x80000000;\n    shiftedValue = shiftedValue << 1;\n    tempValue = tempValue * 2 + (uint)(difference != 0);\n    difference = tempValue2 - 2;\n    if ((tempValue & 0x800000) == 0) {\n      tempValue2 = LZCOUNT(tempValue) - 8;\n      tempValue = tempValue << (tempValue2 & 0xff);\n      if ((int)difference < (int)tempValue2) {\n        tempValue = tempValue >> (-(difference - tempValue2) & 0xff);\n      }\n      else {\n        tempValue = tempValue + (difference - tempValue2) * 0x800000;\n      }\n      return tempValue | firstOperand;\n    }\n  }\n  else {\n    difference = tempValue2 - 1;\n    if (0xffffff < tempValue) {\n      difference = tempValue & 1;\n      tempValue = tempValue >> 1;\n      shiftedValue = (uint)(difference != 0) << 0x1f | shiftedValue >> 1;\n      difference = tempValue2;\n      if (0xfd < tempValue2) goto LAB_08000c12;\n    }\n  }\n  tempValue = tempValue + difference * 0x800000 + (uint)(0x7fffffff < shiftedValue);\n  if (shiftedValue == 0x80000000) {\n    tempValue = tempValue & 0xfffffffe;\n  }\n  return tempValue | firstOperand;\n}\n\n",
            "renaming": {
                "FUN_08000adc": "calculate_floating_point_value_08000adc",
                "param_1": "firstOperand",
                "param_2": "secondOperand",
                "param_3": "undefined",
                "param_4": "result",
                "iVar1": "shiftedFirstOperand",
                "iVar2": "shiftedSecondOperand",
                "uVar3": "shiftedValue",
                "uVar4": "tempValue",
                "uVar5": "tempValue2",
                "uVar6": "difference",
                "bVar7": "isZero"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_Init",
                "MadgwickQuaternionUpdate",
                "__aeabi_frsub",
                "AHRS_GetYaw",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_value_08000c3c",
            "code": "\nuint calculateValue_08000c3c(uint input)\n\n{\n  uint count;\n  uint shift;\n  int constant;\n  uint mask;\n  \n  if (input == 0) {\n    return 0;\n  }\n  count = LZCOUNT(input);\n  shift = count - 8;\n  constant = shift * -0x800000 + 0x4a800000;\n  if (7 < count) {\n    mask = 0 << (shift & 0xff);\n    count = constant + (input << (shift & 0xff)) +\n            (0U >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      count = count & 0xfffffffe;\n    }\n    return count;\n  }\n  shift = input << count + 0x18;\n  count = constant + ((input >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n  if ((shift & 0x7fffffff) == 0) {\n    count = count & ~(shift >> 0x1f);\n  }\n  return count;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_value_08000c3c",
                "param_1": "input",
                "uVar1": "count",
                "uVar2": "shift",
                "iVar3": "constant",
                "uVar4": "mask"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c44": {
            "entrypoint": "0x08000c44",
            "current_name": "extracted_bits_from_param_08000c44",
            "code": "\nuint extractedBitsFromParam_08000c44(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  uint isNegative;\n  int result;\n  \n  isNegative = inputValue & 0x80000000;\n  if ((int)isNegative < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftAmount = leadingZeros - 8;\n  result = ((isNegative | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n    isNegative = result + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      isNegative = isNegative & 0xfffffffe;\n    }\n    return isNegative;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  isNegative = result + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    isNegative = isNegative & ~(shiftAmount >> 0x1f);\n  }\n  return isNegative;\n}\n\n",
            "renaming": {
                "FUN_08000c44": "extracted_bits_from_param_08000c44",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "uVar3": "isNegative",
                "iVar4": "result"
            },
            "calling": [
                "PID_Compute",
                "AK8963_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c60": {
            "entrypoint": "0x08000c60",
            "current_name": "calculate_shifted_sum_08000c60",
            "code": "\nuint calculate_shifted_sum_08000c60(uint input_1,uint input_2)\n\n{\n  uint shifted_input_1;\n  uint shifted_input_2;\n  uint leading_zeros;\n  uint shift_amount;\n  int constant_offset;\n  \n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  shifted_input_1 = input_1;\n  shifted_input_2 = input_2;\n  if (input_2 == 0) {\n    shifted_input_1 = 0;\n    shifted_input_2 = input_1;\n  }\n  constant_offset = 0x5b000000;\n  if (input_2 == 0) {\n    constant_offset = 0x4b000000;\n  }\n  leading_zeros = LZCOUNT(shifted_input_2);\n  shift_amount = leading_zeros - 8;\n  constant_offset = constant_offset + -0x800000 + shift_amount * -0x800000;\n  if (leading_zeros < 8) {\n    shift_amount = shifted_input_2 << leading_zeros + 0x18;\n    shifted_input_2 = constant_offset + ((shifted_input_2 >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((shifted_input_1 | shift_amount << 1) == 0) {\n      shifted_input_2 = shifted_input_2 & ~(shift_amount >> 0x1f);\n    }\n    return shifted_input_2;\n  }\n  leading_zeros = shifted_input_1 << (shift_amount & 0xff);\n  shifted_input_2 = constant_offset + (shifted_input_2 << (shift_amount & 0xff)) +\n          (shifted_input_1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n  if (leading_zeros == 0x80000000) {\n    shifted_input_2 = shifted_input_2 & 0xfffffffe;\n  }\n  return shifted_input_2;\n}\n\n",
            "renaming": {
                "FUN_08000c60": "calculate_shifted_sum_08000c60",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "shifted_input_1",
                "uVar2": "shifted_input_2",
                "uVar3": "leading_zeros",
                "uVar4": "shift_amount",
                "iVar5": "constant_offset"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c70": {
            "entrypoint": "0x08000c70",
            "current_name": "perform_bitwise_operation_08000c70",
            "code": "\nuint performBitwiseOperation_08000c70(uint inputValue1,uint inputValue2)\n\n{\n  uint tempValue1;\n  uint tempValue2;\n  uint count;\n  uint shiftCount;\n  uint mask;\n  int result;\n  bool isParam1NonZero;\n  \n  if ((inputValue1 | inputValue2) == 0) {\n    return inputValue1;\n  }\n  mask = inputValue2 & 0x80000000;\n  if ((int)mask < 0) {\n    isParam1NonZero = inputValue1 != 0;\n    inputValue1 = -inputValue1;\n    inputValue2 = -inputValue2 - (uint)isParam1NonZero;\n  }\n  tempValue2 = inputValue1;\n  tempValue1 = inputValue2;\n  if (inputValue2 == 0) {\n    tempValue2 = 0;\n    tempValue1 = inputValue1;\n  }\n  mask = mask | 0x5b000000;\n  if (inputValue2 == 0) {\n    mask = mask + 0xf0000000;\n  }\n  count = LZCOUNT(tempValue1);\n  shiftCount = count - 8;\n  result = (mask - 0x800000) + shiftCount * -0x800000;\n  if (count < 8) {\n    shiftCount = tempValue1 << count + 0x18;\n    mask = result + ((tempValue1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shiftCount >> 0x1f));\n    if ((tempValue2 | shiftCount << 1) == 0) {\n      mask = mask & ~(shiftCount >> 0x1f);\n    }\n    return mask;\n  }\n  count = tempValue2 << (shiftCount & 0xff);\n  mask = result + (tempValue1 << (shiftCount & 0xff)) +\n          (tempValue2 >> (0x20 - shiftCount & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    mask = mask & 0xfffffffe;\n  }\n  return mask;\n}\n\n",
            "renaming": {
                "FUN_08000c70": "perform_bitwise_operation_08000c70",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "uVar1": "tempValue1",
                "uVar2": "tempValue2",
                "uVar3": "count",
                "uVar4": "shiftCount",
                "uVar5": "mask",
                "iVar6": "result",
                "bVar7": "isParam1NonZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cec": {
            "entrypoint": "0x08000cec",
            "current_name": "perform_arithmetic_operation_08000cec",
            "code": "\nuint perform_arithmetic_operation_08000cec(uint input_1,uint input_2,undefined4 constant_param_1,uint constant_param_2)\n\n{\n  longlong result;\n  uint output;\n  uint temp_1;\n  int temp_2;\n  int temp_3;\n  uint temp_4;\n  int temp_5;\n  uint temp_6;\n  bool condition_1;\n  bool condition_2;\n  \n  temp_1 = input_1 >> 0x17 & 0xff;\n  condition_1 = temp_1 == 0;\n  if (!condition_1) {\n    constant_param_2 = input_2 >> 0x17 & 0xff;\n    condition_1 = constant_param_2 == 0;\n  }\n  if (!condition_1) {\n    condition_1 = temp_1 == 0xff;\n  }\n  if (!condition_1) {\n    condition_1 = constant_param_2 == 0xff;\n  }\n  if (condition_1) {\n    constant_param_2 = input_2 >> 0x17 & 0xff;\n    if (temp_1 == 0xff || constant_param_2 == 0xff) {\n      condition_1 = input_1 == 0 || input_1 == 0x80000000;\n      output = input_2;\n      if (input_1 != 0 && input_1 != 0x80000000) {\n        condition_1 = input_2 == 0;\n        output = input_1;\n      }\n      if (!condition_1) {\n        condition_1 = input_2 == 0x80000000;\n      }\n      temp_6 = output;\n      if (((condition_1) || ((temp_1 == 0xff && ((output & 0x7fffff) != 0)))) ||\n         ((constant_param_2 == 0xff && (temp_6 = input_2, (input_2 & 0x7fffff) != 0)))) {\n        return temp_6 | 0x7fc00000;\n      }\n      output = output ^ input_2;\n      goto LAB_08000e3c;\n    }\n    condition_1 = (input_1 & 0x7fffffff) == 0;\n    if (!condition_1) {\n      condition_1 = (input_2 & 0x7fffffff) == 0;\n    }\n    if (condition_1) {\n      return (input_1 ^ input_2) & 0x80000000;\n    }\n    condition_1 = temp_1 == 0;\n    output = input_1 & 0x80000000;\n    while( true ) {\n      if (condition_1) {\n        input_1 = input_1 << 1;\n        condition_1 = (input_1 & 0x800000) == 0;\n      }\n      if (!condition_1) break;\n      temp_1 = temp_1 - 1;\n    }\n    input_1 = input_1 | output;\n    condition_1 = constant_param_2 == 0;\n    output = input_2 & 0x80000000;\n    while( true ) {\n      if (condition_1) {\n        input_2 = input_2 << 1;\n        condition_1 = (input_2 & 0x800000) == 0;\n      }\n      if (!condition_1) break;\n      constant_param_2 = constant_param_2 - 1;\n    }\n    input_2 = input_2 | output;\n  }\n  temp_2 = temp_1 + constant_param_2;\n  temp_6 = input_1 ^ input_2;\n  temp_1 = input_1 << 9;\n  condition_1 = temp_1 == 0;\n  if (!condition_1) {\n    input_2 = input_2 << 9;\n    condition_1 = input_2 == 0;\n  }\n  if (condition_1) {\n    if (temp_1 == 0) {\n      input_2 = input_2 << 9;\n    }\n    output = temp_6 & 0x80000000 | input_1 & 0x7fffff | input_2 >> 9;\n    condition_2 = SBORROW4(temp_2,0x7f);\n    temp_3 = temp_2 + -0x7f;\n    condition_1 = temp_3 == 0;\n    temp_5 = temp_3;\n    if (!condition_1 && 0x7e < temp_2) {\n      condition_2 = SBORROW4(0xff,temp_3);\n      temp_5 = 0xff - temp_3;\n      condition_1 = temp_3 == 0xff;\n    }\n    if (!condition_1 && temp_5 < 0 == condition_2) {\n      output = output | temp_3 * 0x800000;\n    }\n    if (!condition_1 && temp_5 < 0 == condition_2) {\n      return output;\n    }\n    output = output | 0x800000;\n    temp_4 = 0;\n    condition_2 = SBORROW4(temp_3,1);\n    temp_6 = temp_2 - 0x80;\n    condition_1 = temp_6 == 0;\n    temp_1 = temp_6;\n  }\n  else {\n    result = (ulonglong)(temp_1 >> 5 | 0x8000000) * (ulonglong)(input_2 >> 5 | 0x8000000);\n    temp_4 = (uint)result;\n    output = (uint)((ulonglong)result >> 0x20);\n    condition_1 = output < 0x800000;\n    if (condition_1) {\n      output = output << 1;\n    }\n    if (condition_1) {\n      output = output | temp_4 >> 0x1f;\n      temp_4 = temp_4 << 1;\n    }\n    output = temp_6 & 0x80000000 | output;\n    temp_6 = (temp_2 + -0x7f) - (uint)condition_1;\n    condition_2 = SBORROW4(temp_6,0xfd);\n    condition_1 = temp_6 == 0xfd;\n    temp_1 = temp_6 - 0xfd;\n    if (temp_6 < 0xfe) {\n      output = output + temp_6 * 0x800000 + (uint)(0x7fffffff < temp_4);\n      if (temp_4 == 0x80000000) {\n        output = output & 0xfffffffe;\n      }\n      return output;\n    }\n  }\n  if (condition_1 || (int)temp_1 < 0 != condition_2) {\n    condition_1 = (int)(temp_6 + 0x19) < 0;\n    if (temp_6 == 0xffffffe7 || condition_1 != SCARRY4(temp_6,0x19)) {\n      output = output & 0x80000000;\n    }\n    if (temp_6 != 0xffffffe7 && condition_1 == SCARRY4(temp_6,0x19)) {\n      temp_1 = (output << 1) >> (-temp_6 & 0xff);\n      temp_6 = output << (temp_6 + 0x20 & 0xff);\n      temp_1 = ((uint)((output & 0x80000000) != 0) << 0x1f | temp_1 >> 1) + (uint)((byte)temp_1 & 1);\n      if ((temp_4 | temp_6 << 1) == 0) {\n        temp_1 = temp_1 & ~(temp_6 >> 0x1f);\n      }\n      return temp_1;\n    }\n    return output;\n  }\nLAB_08000e3c:\n  return output & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cec": "perform_arithmetic_operation_08000cec",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "constant_param_1",
                "param_4": "constant_param_2",
                "lVar1": "result",
                "uVar2": "output",
                "uVar3": "temp_1",
                "iVar4": "temp_2",
                "iVar5": "temp_3",
                "uVar6": "temp_4",
                "iVar7": "temp_5",
                "uVar8": "temp_6",
                "bVar9": "condition_1",
                "bVar10": "condition_2"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "AK8963_Init",
                "AHRS_ComputeAngles",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e54": {
            "entrypoint": "0x08000e54",
            "current_name": "binary_floating_point_conversion_08000e54",
            "code": "\nuint binaryFloatingPointConversion_08000e54(uint inputFloat,uint valueToConvert,undefined4 roundingMode,uint exponentBits)\n\n{\n  uint fractionMantissaTemp;\n  uint fractionMantissaBits;\n  int exponentBitsTemp;\n  uint exponentBitsShifted;\n  int exponentBitsShiftedTemp;\n  uint outputFloat;\n  bool isZero;\n  bool isNegative;\n  bool condition;\n  \n  fractionMantissaBits = inputFloat >> 0x17 & 0xff;\n  isZero = fractionMantissaBits == 0;\n  if (!isZero) {\n    exponentBits = valueToConvert >> 0x17 & 0xff;\n    isZero = exponentBits == 0;\n  }\n  if (!isZero) {\n    isZero = fractionMantissaBits == 0xff;\n  }\n  if (!isZero) {\n    isZero = exponentBits == 0xff;\n  }\n  if (isZero) {\n    exponentBits = valueToConvert >> 0x17 & 0xff;\n    outputFloat = inputFloat;\n    if (fractionMantissaBits == 0xff) {\n      if (((inputFloat & 0x7fffff) != 0) || (outputFloat = valueToConvert, exponentBits == 0xff)) {\nLAB_08000e4a:\n        return outputFloat | 0x7fc00000;\n      }\n    }\n    else {\n      if (exponentBits == 0xff) {\n        outputFloat = valueToConvert;\n        if ((valueToConvert & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (inputFloat ^ valueToConvert) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      isZero = (inputFloat & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (valueToConvert & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = fractionMantissaBits == 0;\n        outputFloat = inputFloat & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            inputFloat = inputFloat << 1;\n            isZero = (inputFloat & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          fractionMantissaBits = fractionMantissaBits - 1;\n        }\n        inputFloat = inputFloat | outputFloat;\n        isZero = exponentBits == 0;\n        outputFloat = valueToConvert & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            valueToConvert = valueToConvert << 1;\n            isZero = (valueToConvert & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          exponentBits = exponentBits - 1;\n        }\n        valueToConvert = valueToConvert | outputFloat;\n        goto LAB_08000e6c;\n      }\n      if ((inputFloat & 0x7fffffff) == 0) {\n        if ((valueToConvert & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    inputFloat = inputFloat ^ valueToConvert;\n  }\n  else {\nLAB_08000e6c:\n    exponentBitsTemp = fractionMantissaBits - exponentBits;\n    if (valueToConvert << 9 == 0) {\n      inputFloat = (inputFloat ^ valueToConvert) & 0x80000000 | inputFloat & 0x7fffff;\n      condition = SCARRY4(exponentBitsTemp,0x7f);\n      exponentBitsShiftedTemp = exponentBitsTemp + 0x7f;\n      isZero = exponentBitsShiftedTemp < 0;\n      isNegative = exponentBitsShiftedTemp == 0;\n      if (!isNegative && isZero == condition) {\n        condition = SBORROW4(0xff,exponentBitsShiftedTemp);\n        isZero = 0xff - exponentBitsShiftedTemp < 0;\n        isNegative = exponentBitsShiftedTemp == 0xff;\n      }\n      if (!isNegative && isZero == condition) {\n        inputFloat = inputFloat | exponentBitsShiftedTemp * 0x800000;\n      }\n      if (!isNegative && isZero == condition) {\n        return inputFloat;\n      }\n      inputFloat = inputFloat | 0x800000;\n      fractionMantissaBits = 0;\n      isNegative = SBORROW4(exponentBitsShiftedTemp,1);\n      exponentBitsShifted = exponentBitsTemp + 0x7e;\n      isZero = exponentBitsShifted == 0;\n      outputFloat = exponentBitsShifted;\n    }\n    else {\n      fractionMantissaTemp = (valueToConvert << 9) >> 4 | 0x10000000;\n      fractionMantissaBits = (inputFloat << 9) >> 4 | 0x10000000;\n      inputFloat = (inputFloat ^ valueToConvert) & 0x80000000;\n      isZero = fractionMantissaTemp <= fractionMantissaBits;\n      if (!isZero) {\n        fractionMantissaBits = fractionMantissaBits << 1;\n      }\n      exponentBitsShifted = exponentBitsTemp + 0x7d + (uint)isZero;\n      outputFloat = 0x800000;\n      do {\n        if (fractionMantissaTemp <= fractionMantissaBits) {\n          fractionMantissaBits = fractionMantissaBits - fractionMantissaTemp;\n          inputFloat = inputFloat | outputFloat;\n        }\n        isZero = fractionMantissaTemp >> 1 <= fractionMantissaBits;\n        if (isZero) {\n          fractionMantissaBits = fractionMantissaBits - (fractionMantissaTemp >> 1);\n        }\n        if (isZero) {\n          inputFloat = inputFloat | outputFloat >> 1;\n        }\n        isZero = fractionMantissaTemp >> 2 <= fractionMantissaBits;\n        if (isZero) {\n          fractionMantissaBits = fractionMantissaBits - (fractionMantissaTemp >> 2);\n        }\n        if (isZero) {\n          inputFloat = inputFloat | outputFloat >> 2;\n        }\n        isZero = fractionMantissaTemp >> 3 <= fractionMantissaBits;\n        if (isZero) {\n          fractionMantissaBits = fractionMantissaBits - (fractionMantissaTemp >> 3);\n        }\n        if (isZero) {\n          inputFloat = inputFloat | outputFloat >> 3;\n        }\n        fractionMantissaBits = fractionMantissaBits * 0x10;\n        isZero = fractionMantissaBits == 0;\n        if (!isZero) {\n          outputFloat = outputFloat >> 4;\n          isZero = outputFloat == 0;\n        }\n      } while (!isZero);\n      isNegative = SBORROW4(exponentBitsShifted,0xfd);\n      isZero = exponentBitsShifted == 0xfd;\n      outputFloat = exponentBitsShifted - 0xfd;\n      if (exponentBitsShifted < 0xfe) {\n        inputFloat = inputFloat + exponentBitsShifted * 0x800000 + (uint)(fractionMantissaTemp <= fractionMantissaBits);\n        if (fractionMantissaBits - fractionMantissaTemp == 0) {\n          inputFloat = inputFloat & 0xfffffffe;\n        }\n        return inputFloat;\n      }\n    }\n    if (isZero || (int)outputFloat < 0 != isNegative) {\n      isZero = (int)(exponentBitsShifted + 0x19) < 0;\n      if (exponentBitsShifted == 0xffffffe7 || isZero != SCARRY4(exponentBitsShifted,0x19)) {\n        inputFloat = inputFloat & 0x80000000;\n      }\n      if (exponentBitsShifted == 0xffffffe7 || isZero != SCARRY4(exponentBitsShifted,0x19)) {\n        return inputFloat;\n      }\n      outputFloat = (inputFloat << 1) >> (-exponentBitsShifted & 0xff);\n      exponentBitsShifted = inputFloat << (exponentBitsShifted + 0x20 & 0xff);\n      outputFloat = ((uint)((inputFloat & 0x80000000) != 0) << 0x1f | outputFloat >> 1) + (uint)((byte)outputFloat & 1);\n      if ((fractionMantissaBits | exponentBitsShifted << 1) == 0) {\n        outputFloat = outputFloat & ~(exponentBitsShifted >> 0x1f);\n      }\n      return outputFloat;\n    }\n  }\n  return inputFloat & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e54": "binary_floating_point_conversion_08000e54",
                "param_1": "inputFloat",
                "param_2": "valueToConvert",
                "param_3": "roundingMode",
                "param_4": "exponentBits",
                "uVar1": "fractionMantissaTemp",
                "uVar2": "fractionMantissaBits",
                "iVar3": "exponentBitsTemp",
                "uVar4": "exponentBitsShifted",
                "iVar5": "exponentBitsShiftedTemp",
                "uVar6": "outputFloat",
                "bVar7": "isZero",
                "bVar8": "isNegative",
                "bVar9": "condition"
            },
            "calling": [
                "PID_Compute",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "calculate_unsigned_difference_08000f8c",
            "code": "\nuint calculate_unsigned_difference_08000f8c(uint input_value_1,uint input_value_2)\n\n{\n  bool is_negative_difference;\n  uint doubled_input_value_1;\n  uint doubled_input_value_2;\n  uint combined_input_values;\n  bool is_combined_zero;\n  \n  doubled_input_value_1 = input_value_1 * 2;\n  doubled_input_value_2 = input_value_2 * 2;\n  if (((int)doubled_input_value_1 >> 0x18 == -1 || (int)doubled_input_value_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_value_1 >> 0x18 == -1 && ((input_value_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_value_2 >> 0x18 == -1 && ((input_value_2 & 0x7fffff) != 0)))))) {\n    result 0xffffffff;\n  }\n  combined_input_values = doubled_input_value_1 | input_value_2 & 0x7fffffff;\n  is_combined_zero = combined_input_values == 0;\n  if (!is_combined_zero) {\n    combined_input_values = input_value_1 ^ input_value_2;\n    is_combined_zero = combined_input_values == 0;\n  }\n  is_negative_difference = -1 < (int)combined_input_values;\n  if (is_negative_difference) {\n    input_value_1 = doubled_input_value_1 + input_value_2 * -2;\n    is_combined_zero = input_value_1 == 0;\n  }\n  if ((is_negative_difference && doubled_input_value_2 <= doubled_input_value_1) && !is_combined_zero) {\n    input_value_1 = (int)input_value_2 >> 0x1f;\n  }\n  if (!is_negative_difference || doubled_input_value_2 > doubled_input_value_1) {\n    input_value_1 = ~((int)input_value_2 >> 0x1f);\n  }\n  if (!is_combined_zero) {\n    input_value_1 = input_value_1 | 1;\n  }\n  result input_value_1;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "calculate_unsigned_difference_08000f8c",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "bVar1": "is_negative_difference",
                "uVar2": "doubled_input_value_1",
                "uVar3": "doubled_input_value_2",
                "uVar4": "combined_input_values",
                "bVar5": "is_combined_zero",
                "return": "result"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f94": {
            "entrypoint": "0x08000f94",
            "current_name": "check_overflow_08000f94",
            "code": "\nuint check_overflow_08000f94(uint input1,uint input2)\n\n{\n  bool has_overflow;\n  uint input1_times_2;\n  uint input2_times_2;\n  uint combined_input;\n  bool is_combined_input_zero;\n  \n  input1_times_2 = input1 * 2;\n  input2_times_2 = input2 * 2;\n  if (((int)input1_times_2 >> 0x18 == -1 || (int)input2_times_2 >> 0x18 == -1) &&\n     ((((int)input1_times_2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2_times_2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_input = input1_times_2 | input2 & 0x7fffffff;\n  is_combined_input_zero = combined_input == 0;\n  if (!is_combined_input_zero) {\n    combined_input = input1 ^ input2;\n    is_combined_input_zero = combined_input == 0;\n  }\n  has_overflow = -1 < (int)combined_input;\n  if (has_overflow) {\n    input1 = input1_times_2 + input2 * -2;\n    is_combined_input_zero = input1 == 0;\n  }\n  if ((has_overflow && input2_times_2 <= input1_times_2) && !is_combined_input_zero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!has_overflow || input2_times_2 > input1_times_2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!is_combined_input_zero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_08000f94": "check_overflow_08000f94",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "has_overflow",
                "uVar2": "input1_times_2",
                "uVar3": "input2_times_2",
                "uVar4": "combined_input",
                "bVar5": "is_combined_input_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f9c": {
            "entrypoint": "0x08000f9c",
            "current_name": "check_multiplication_overflow_08000f9c",
            "code": "\nuint check_multiplication_overflow_08000f9c(uint number_1,uint number_2)\n\n{\n  bool multiplication_overflow;\n  uint number_1_times_2;\n  uint number_2_times_2;\n  uint merged_numbers;\n  bool result_zero;\n  \n  number_1_times_2 = number_1 * 2;\n  number_2_times_2 = number_2 * 2;\n  if (((int)number_1_times_2 >> 0x18 == -1 || (int)number_2_times_2 >> 0x18 == -1) &&\n     ((((int)number_1_times_2 >> 0x18 == -1 && ((number_1 & 0x7fffff) != 0)) ||\n      (((int)number_2_times_2 >> 0x18 == -1 && ((number_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  merged_numbers = number_1_times_2 | number_2 & 0x7fffffff;\n  result_zero = merged_numbers == 0;\n  if (!result_zero) {\n    merged_numbers = number_1 ^ number_2;\n    result_zero = merged_numbers == 0;\n  }\n  multiplication_overflow = -1 < (int)merged_numbers;\n  if (multiplication_overflow) {\n    number_1 = number_1_times_2 + number_2 * -2;\n    result_zero = number_1 == 0;\n  }\n  if ((multiplication_overflow && number_2_times_2 <= number_1_times_2) && !result_zero) {\n    number_1 = (int)number_2 >> 0x1f;\n  }\n  if (!multiplication_overflow || number_2_times_2 > number_1_times_2) {\n    number_1 = ~((int)number_2 >> 0x1f);\n  }\n  if (!result_zero) {\n    number_1 = number_1 | 1;\n  }\n  return number_1;\n}\n\n",
            "renaming": {
                "FUN_08000f9c": "check_multiplication_overflow_08000f9c",
                "param_1": "number_1",
                "param_2": "number_2",
                "bVar1": "multiplication_overflow",
                "uVar2": "number_1_times_2",
                "uVar3": "number_2_times_2",
                "uVar4": "merged_numbers",
                "bVar5": "result_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ffc": {
            "entrypoint": "0x08000ffc",
            "current_name": "compare_floats_08000ffc",
            "code": "\nvoid compareFloats_08000ffc(undefined4 firstFloat,undefined4 secondFloat)\n\n{\n  __aeabi_cfcmpeq(secondFloat,firstFloat);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ffc": "compare_floats_08000ffc",
                "param_1": "firstFloat",
                "param_2": "secondFloat"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001004": {
            "entrypoint": "0x08001004",
            "current_name": "concatenate_params_08001004",
            "code": "\nundefined8 concatenateParams_08001004(undefined4 firstParam,undefined4 secondParam)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParam,firstParam);\n}\n\n",
            "renaming": {
                "FUN_08001004": "concatenate_params_08001004",
                "param_1": "firstParam",
                "param_2": "secondParam"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001014": {
            "entrypoint": "0x08001014",
            "current_name": "check_equality_08001014",
            "code": "\nbool check_equality_08001014(void)\n\n{\n  char result;\n  \n  __aeabi_cfcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001014": "check_equality_08001014",
                "in_ZR": "result"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001028": {
            "entrypoint": "0x08001028",
            "current_name": "check_null_terminator_08001028",
            "code": "\nbool check_null_terminator_08001028(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001028": "check_null_terminator_08001028",
                "in_CY": "input_character"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800103c": {
            "entrypoint": "0x0800103c",
            "current_name": "is_carry_flag_set_0800103c",
            "code": "\nbool is_carry_flag_set_0800103c(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_result;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)is_carry_result || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_0800103c": "is_carry_flag_set_0800103c",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_result"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001050": {
            "entrypoint": "0x08001050",
            "current_name": "check_if_comparable_08001050",
            "code": "\nbool check_if_comparable_08001050(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cfrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_08001050": "check_if_comparable_08001050",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001064": {
            "entrypoint": "0x08001064",
            "current_name": "is_null_terminator_08001064",
            "code": "\nbool is_null_terminator_08001064(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001064": "is_null_terminator_08001064",
                "in_CY": "input_char"
            },
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001078": {
            "entrypoint": "0x08001078",
            "current_name": "decode_value_08001078",
            "code": "\nuint decode_value_08001078(uint value)\n\n{\n  uint shifted_value;\n  uint diff;\n  \n  if (value << 1 < 0x7f000000) {\n    return 0;\n  }\n  shifted_value = (value << 1) >> 0x18;\n  diff = 0x9e - shifted_value;\n  if (shifted_value < 0x9f && diff != 0) {\n    shifted_value = (value << 8 | 0x80000000) >> (diff & 0xff);\n    if ((value & 0x80000000) != 0) {\n      shifted_value = -shifted_value;\n    }\n    return shifted_value;\n  }\n  if ((diff == 0xffffff9f) && ((value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  value = value & 0x80000000;\n  if (value == 0) {\n    value = 0x7fffffff;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_08001078": "decode_value_08001078",
                "param_1": "value",
                "uVar1": "shifted_value",
                "uVar2": "diff"
            },
            "calling": [
                "Motor_DistributeSpeed",
                "AHRS_ComputeAngles",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080010c4": {
            "entrypoint": "0x080010c4",
            "current_name": "calculate_shifted_value_080010c4",
            "code": "\nuint calculate_shifted_value_080010c4(uint input_value)\n\n{\n  uint shift_amount;\n  \n  if (((input_value & 0x80000000) != 0) || (input_value << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((input_value << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (input_value << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080010c4": "calculate_shifted_value_080010c4",
                "param_1": "input_value",
                "uVar1": "shift_amount"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001104": {
            "entrypoint": "0x08001104",
            "current_name": "configure_sys_tick_08001104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSysTick_08001104(uint32_t priority)\n\n{\n  uint32_t HCLKFreq;\n  \n  HCLKFreq = getHCLKFrequency();\n  configureSysTick_08001104Timer(HCLKFreq / 1000);\n  setSysTickPriority(SysTickInterrupt,priority,0);\n  return HAL_STATUS_OK;\n}\n\n",
            "renaming": {
                "FUN_08001104": "configure_sys_tick_08001104",
                "TickPriority": "priority",
                "uVar1": "HCLKFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFrequency",
                "HAL_SYSTICK_Config": "configureSysTickTimer",
                "HAL_NVIC_SetPriority": "setSysTickPriority",
                "SysTick_IRQn": "SysTickInterrupt",
                "HAL_OK": "HAL_STATUS_OK"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001128": {
            "entrypoint": "0x08001128",
            "current_name": "initialize_hardware_08001128",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHardwareStatus initializeHardware_08001128(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initializeTick(0);\n  initializeMSP();\n  return Hardware_OK;\n}\n\n",
            "renaming": {
                "FUN_08001128": "initialize_hardware_08001128",
                "HAL_StatusTypeDef": "HardwareStatus",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMSP",
                "HAL_OK": "Hardware_OK"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800114c": {
            "entrypoint": "0x0800114c",
            "current_name": "increment_uw_tick_0800114c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementUwTick_0800114c(void)\n\n{\n  tickCounter = tickCounter + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800114c": "increment_uw_tick_0800114c",
                "uwTick": "tickCounter"
            },
            "calling": [
                "SysTick_Handler",
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800115c": {
            "entrypoint": "0x0800115c",
            "current_name": "get_system_tick_0800115c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_0800115c(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_0800115c": "get_system_tick_0800115c",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Read",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "millis",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001168": {
            "entrypoint": "0x08001168",
            "current_name": "FUNC_08001168",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001168": "FUNC_08001168"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "configure_priority_group_08001170",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08001170(uint32_t priorityGroup)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | 0x5fa0000 | (priorityGroup & 7) << 8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001170": "configure_priority_group_08001170",
                "PriorityGroup": "priorityGroup"
            },
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001194": {
            "entrypoint": "0x08001194",
            "current_name": "configure_interrupt_priority_08001194",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterruptPriority_08001194(interruptNumber_Type interruptNumber,uint32_t preemptPriorityLevel,uint32_t subPriorityLevel)\n\n{\n  uint interruptNumber32;\n  undefined priorityValue;\n  uint32_t preemptPriorityBits;\n  uint tempValue;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint tempValue3;\n  \n  interruptNumber32 = (uint)interruptNumber;\n  subPriorityBits = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - subPriorityBits;\n  tempValue3 = subPriorityBits + 4;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (tempValue3 < 7) {\n    subPriorityBits = 0;\n  }\n  tempValue = (1 << (preemptPriorityBits & 0xff)) - 1;\n  if (6 < tempValue3) {\n    subPriorityBits = subPriorityBits - 3;\n  }\n  priorityValue = (undefined)\n          ((subPriorityLevel & (1 << (subPriorityBits & 0xff)) - 1U |\n           (preemptPriorityLevel & tempValue) << (subPriorityBits & 0xff)) << 4);\n  if (-1 < (int)interruptNumber32) {\n    tempValue3 = interruptNumber32 + 0xe000e100;\n  }\n  else {\n    tempValue = 0xe000ed14;\n    tempValue3 = interruptNumber32 & 0xf;\n  }\n  if (-1 < (int)interruptNumber32) {\n    *(undefined *)(tempValue3 + 0x300) = priorityValue;\n  }\n  else {\n    *(undefined *)(tempValue + tempValue3) = priorityValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001194": "configure_interrupt_priority_08001194",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriorityLevel",
                "SubPriority": "subPriorityLevel",
                "uVar1": "interruptNumber32",
                "PreemptPriorityBits": "preemptPriorityBits",
                "uVar3": "tempValue",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "uVar4": "tempValue3",
                "uVar2": "priorityValue"
            },
            "calling": [
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011fc": {
            "entrypoint": "0x080011fc",
            "current_name": "set_interrupt_bit_080011fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_interrupt_bit_080011fc(interrupt_number_Type interrupt_number)\n\n{\n  *(int *)(((uint)(int)interrupt_number >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interrupt_number & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011fc": "set_interrupt_bit_080011fc",
                "IRQn": "interrupt_number"
            },
            "calling": [
                "HAL_UART_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001214": {
            "entrypoint": "0x08001214",
            "current_name": "set_timer_values_08001214",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t setTimerValues_08001214(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001214": "set_timer_values_08001214",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001240": {
            "entrypoint": "0x08001240",
            "current_name": "set_clock_source_08001240",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08001240(uint32_t source)\n\n{\n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001240": "set_clock_source_08001240",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001258": {
            "entrypoint": "0x08001258",
            "current_name": "FUNC_08001258",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001258(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001258": "FUNC_08001258"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800125a": {
            "entrypoint": "0x0800125a",
            "current_name": "handle_sys_tick_callback_0800125a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickCallback_0800125a(void)\n\n{\n  systickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800125a": "handle_sys_tick_callback_0800125a",
                "HAL_SYSTICK_Callback": "systickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001264": {
            "entrypoint": "0x08001264",
            "current_name": "configure_gpio_08001264",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08001264(GPIO *GPIOx,GPIO_Configuration *GPIO_Init)\n\n{\n  uint32_t *config_register;\n  uint32_t selected_speed;\n  uint selected_pin;\n  uint selected_mode;\n  int port_index;\n  uint pin_index;\n  uint pin_mask;\n  uint uVar7;\n  GPIO *current_GPIOx;\n  int shift_value;\n  uint32_t tmp_register;\n  \n  selected_speed = 0;\n  pin_index = 0;\n  do {\n    pin_mask = 1 << (pin_index & 0xff);\n    selected_pin = pin_mask & GPIO_Init->Pin;\n    if (pin_mask == selected_pin) {\n      selected_mode = GPIO_Init->Mode;\n      if (selected_mode == 0x12) {\n        selected_speed = GPIO_Init->Speed + 0xc;\n      }\n      else if (selected_mode < 0x13) {\n        if (selected_mode == 2) {\n          selected_speed = GPIO_Init->Speed + 8;\n        }\n        else if (selected_mode < 3) {\n          if (selected_mode == 0) goto LAB_080013be;\n          if (selected_mode == 1) {\n            selected_speed = GPIO_Init->Speed;\n          }\n        }\n        else if (selected_mode == 3) {\n          selected_speed = 0;\n        }\n        else if (selected_mode == 0x11) {\n          selected_speed = GPIO_Init->Speed + 4;\n        }\n      }\n      else {\n        if (selected_mode != 0x10210000) {\n          if (selected_mode < 0x10210001) {\n            if (selected_mode != 0x10110000) {\n              uVar7 = 0x10120000;\nLAB_080013b8:\n              if (selected_mode != uVar7) goto LAB_080012a8;\n            }\n          }\n          else if ((selected_mode != 0x10310000) && (selected_mode != 0x10320000)) {\n            uVar7 = 0x10220000;\n            goto LAB_080013b8;\n          }\n        }\nLAB_080013be:\n        selected_speed = GPIO_Init->Pull;\n        if (selected_speed == 0) {\n          selected_speed = 4;\n        }\n        else {\n          if (selected_speed == 1) {\n            GPIOx->BSRR = pin_mask;\n          }\n          if (selected_speed != 1) {\n            GPIOx->BRR = pin_mask;\n          }\n          selected_speed = 8;\n        }\n      }\nLAB_080012a8:\n      if (selected_pin < 0x100) {\n        pin_mask = GPIOx->CRL;\n        selected_mode = pin_index << 2;\n        current_GPIOx = GPIOx;\n      }\n      else {\n        pin_mask = GPIOx->CRH;\n        selected_mode = (pin_index + 0x3ffffff8) * 4;\n      }\n      if (0xff < selected_pin) {\n        current_GPIOx = (GPIO *)&GPIOx->CRH;\n      }\n      current_GPIOx->CRL = pin_mask & ~(0xf << (selected_mode & 0xff)) | selected_speed << (selected_mode & 0xff);\n      current_GPIOx = (GPIO *)GPIO_Init->Mode;\n      if (((uint)current_GPIOx & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shift_value = (pin_index & 3) << 2;\n        if (GPIOx == (GPIO *)0x40010800) {\n          port_index = 0;\n        }\n        else if (GPIOx == (GPIO *)0x40010c00) {\n          port_index = 1;\n        }\n        else if (GPIOx == (GPIO *)0x40011000) {\n          port_index = 2;\n        }\n        else if (GPIOx == (GPIO *)0x40011400) {\n          port_index = 3;\n        }\n        else {\n          port_index = 4;\n        }\n        *(uint *)((pin_index & 0xfffffffc) + 0x40010008) =\n             port_index << shift_value | *(uint *)((pin_index & 0xfffffffc) + 0x40010008) & ~(0xf << shift_value);\n        if (((uint)current_GPIOx & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~selected_pin;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | selected_pin;\n        }\n        if (((uint)current_GPIOx & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~selected_pin;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | selected_pin;\n        }\n        if (((uint)current_GPIOx & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~selected_pin;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | selected_pin;\n        }\n        if (((uint)current_GPIOx & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~selected_pin;\n        }\n        else {\n          _DAT_4001040c = selected_pin | _DAT_4001040c;\n        }\n      }\n    }\n    pin_index = pin_index + 1;\n    if (pin_index == 0x10) {\n      return;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001264": "configure_gpio_08001264",
                "GPIO_TypeDef": "GPIO",
                "GPIO_InitTypeDef": "GPIO_Configuration",
                "configregister": "config_register",
                "uVar1": "selected_speed",
                "uVar2": "selected_pin",
                "uVar3": "selected_mode",
                "iVar4": "port_index",
                "uVar5": "pin_index",
                "uVar6": "pin_mask",
                "unaff_r10": "current_GPIOx",
                "iVar8": "shift_value",
                "tmpreg": "tmp_register"
            },
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_I2C_MspInit",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001424": {
            "entrypoint": "0x08001424",
            "current_name": "set_pin_state_08001424",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001424(GPIO_TypeDef *gpio,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  uint32_t bitmask;\n  \n  bitmask = (uint32_t)pinNumber;\n  if (pinState == GPIO_PIN_RESET) {\n    bitmask = bitmask << 0x10;\n  }\n  gpio->BSRR = bitmask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001424": "set_pin_state_08001424",
                "GPIOx": "gpio",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState",
                "uVar1": "bitmask"
            },
            "calling": [
                "Peripherals_Init",
                "toggleLED",
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800142e": {
            "entrypoint": "0x0800142e",
            "current_name": "toggle_gpio_0800142e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid toggleGPIO_0800142e(GPIO_TypeDef *gpioPort,uint16_t pinNumber)\n\n{\n  gpioPort->ODR = (uint)pinNumber ^ gpioPort->ODR;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800142e": "toggle_gpio_0800142e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001436": {
            "entrypoint": "0x08001436",
            "current_name": "check_i2_c_status_08001436",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CStatus_08001436(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->statusReg1 & 0x400) != 0) {\n    i2cInstance->statusReg1 = i2cInstance->statusReg1 & 0xfffffbff;\n    i2cHandle->errorCode = 4;\n    i2cHandle->state = HAL_I2C_STATE_READY;\n    i2cHandle->lock = HAL_UNLOCKED;\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001436": "check_i2_c_status_08001436",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "SR1": "statusReg1",
                "ErrorCode": "errorCode",
                "State": "state",
                "Lock": "lock"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "check_i2_c_status_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nI2C_Status checkI2CStatus_08001460(I2C_HandleTypeDef *i2cHandle,uint32_t flag,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint status;\n  I2C_TypeDef *i2c;\n  \n  startTime = getTime();\n  do {\n    i2c = i2cHandle->Instance;\n    if ((flag << 8) >> 0x18 == 1) {\n      status = i2c->statusReg1;\n    }\n    else {\n      status = i2c->statusReg2;\n    }\n    if ((flag & 0xffff & ~status) == 0) {\n      return HAL_SUCCESS;\n    }\n    if ((int)(i2c->statusReg1 << 0x15) < 0) {\n      i2c->controlReg1 = i2c->controlReg1 | 0x200;\n      i2c->statusReg1 = i2c->statusReg1 & 0xfffffbff;\n      i2cHandle->error = 4;\n      i2cHandle->currentState = I2C_READY;\n      i2cHandle->lock = UNLOCKED;\n      return HAL_FAILURE;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTime = getTime(), currentTime - startTime <= timeout))));\n  i2cHandle->currentState = I2C_READY;\n  i2cHandle->lock = UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001460": "check_i2_c_status_08001460",
                "hi2c": "i2cHandle",
                "Flag": "flag",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "uVar3": "status",
                "pIVar4": "i2c",
                "HAL_StatusTypeDef": "I2C_Status",
                "HAL_GetTick": "getTime",
                "SR1": "statusReg1",
                "SR2": "statusReg2",
                "CR1": "controlReg1",
                "ErrorCode": "error",
                "State": "currentState",
                "Lock": "lock",
                "HAL_OK": "HAL_SUCCESS",
                "HAL_ERROR": "HAL_FAILURE",
                "HAL_I2C_STATE_READY": "I2C_READY",
                "HAL_UNLOCKED": "UNLOCKED"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014e2": {
            "entrypoint": "0x080014e2",
            "current_name": "wait_for_i2_c_status_080014e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CStatus_080014e2(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  uint32_t tickStart;\n  \n  startTick = HAL_GetTick();\n  while( true ) {\n    if ((int)(i2cHandle->Instance->SR1 << 0x18) < 0) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - startTick)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080014e2": "wait_for_i2_c_status_080014e2",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "tickstart": "tickStart"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001530": {
            "entrypoint": "0x08001530",
            "current_name": "send_data_08001530",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsendData_08001530(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  startTime = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n        i2cHandle->Instance->DR = deviceAddress & 0xfe;\n        status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n        if (status == HAL_OK) {\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n          if (status == HAL_OK) {\n            i2cInstance = i2cHandle->Instance;\n            if (memoryAddressSize == 1) {\nLAB_080015ca:\n              i2cInstance->DR = (uint)(byte)memoryAddress;\n              return HAL_OK;\n            }\n            i2cInstance->DR = (uint)(memoryAddress >> 8);\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n            if (status == HAL_OK) {\n              i2cInstance = i2cHandle->Instance;\n              goto LAB_080015ca;\n            }\n          }\n          if (i2cHandle->ErrorCode != 4) {\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        return HAL_ERROR;\n      }\n    } while (timeout == 0xffffffff);\n    if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001530": "send_data_08001530",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015e8": {
            "entrypoint": "0x080015e8",
            "current_name": "initialize_i2_c_comms_080015e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ninitializeI2CComms_080015e8(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  i2cInstance = i2cHandle->Instance;\n  i2cInstance->CR1 = i2cInstance->CR1 | 0x400;\n  i2cInstance->CR1 = i2cInstance->CR1 | 0x100;\n  startTime = HAL_GetTick();\nLAB_0800160e:\n  while (-1 < (int)(i2cHandle->Instance->SR1 << 0x1f)) {\n    if (timeout != 0xffffffff) goto code_r0x08001658;\n  }\n  i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n  status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n  if (status != HAL_OK) goto LAB_080016ba;\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cInstance = i2cHandle->Instance;\n    if (memoryAddressSize != 1) {\n      i2cInstance->DR = (uint)(memoryAddress >> 8);\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001642;\n      i2cInstance = i2cHandle->Instance;\n    }\n    i2cInstance->DR = (uint)(byte)memoryAddress;\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      startTime = HAL_GetTick();\n      do {\n        do {\n          if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n            i2cHandle->Instance->DR = (byte)deviceAddress | 1;\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n            if (status == HAL_OK) {\n              return HAL_OK;\n            }\nLAB_080016ba:\n            if (i2cHandle->ErrorCode != 4) {\n              return HAL_TIMEOUT;\n            }\n            return HAL_ERROR;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout));\nLAB_0800165a:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001642:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\ncode_r0x08001658:\n  if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) goto LAB_0800165a;\n  goto LAB_0800160e;\n}\n\n",
            "renaming": {
                "FUN_080015e8": "initialize_i2_c_comms_080015e8",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016f4": {
            "entrypoint": "0x080016f4",
            "current_name": "wait_for_i2_c_flag_080016f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CFlag_080016f4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  \n  startTime = HAL_GetTick();\n  while( true ) {\n    i2cInstance = i2cHandle->Instance;\n    if ((i2cInstance->statusRegister1 & 0x40) != 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->statusRegister1 << 0x1b) < 0) break;\n    if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cInstance->statusRegister1 = i2cInstance->statusRegister1 & 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080016f4": "wait_for_i2_c_flag_080016f4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "pIVar3": "i2cInstance",
                "SR1": "statusRegister1"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001754": {
            "entrypoint": "0x08001754",
            "current_name": "configure_i2_c_08001754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status configureI2C_08001754(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t pclkFreq;\n  uint timeoutPeriod;\n  uint standardMode;\n  I2C_TypeDef *i2cInstance;\n  uint clockSpeed;\n  uint pclkMhz;\n  \n  if (i2cHandle != (I2C_HandleTypeDef *)0x0) {\n    if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandle);\n    }\n    i2cHandle->State = HAL_I2C_STATE_BUSY;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    clockSpeed = (i2cHandle->Init).ClockSpeed;\n    pclkMhz = pclkFreq / 1000000;\n    standardMode = timeoutPeriod;\n    if (100000 < clockSpeed) {\n      standardMode = 300;\n    }\n    i2cInstance = i2cHandle->Instance;\n    if (100000 < clockSpeed) {\n      standardMode = pclkMhz * standardMode;\n    }\n    i2cInstance->CR2 = pclkMhz;\n    if (100000 < clockSpeed) {\n      pclkMhz = standardMode / 1000;\n    }\n    i2cInstance->TRISE = pclkMhz + 1;\n    if (clockSpeed < 0x186a1) {\n      pclkFreq = pclkFreq / (clockSpeed << 1);\n      if ((pclkFreq & 0xfff) < 4) {\n        pclkFreq = 4;\n      }\n    }\n    else {\n      if ((i2cHandle->Init).DutyCycle == 0) {\n        pclkFreq = pclkFreq / (clockSpeed * 3) | 0x8000;\n      }\n      else {\n        pclkFreq = pclkFreq / (clockSpeed * 0x19) | 0xc000;\n      }\n      if ((pclkFreq & 0xfff) == 0) {\n        pclkFreq = 1;\n      }\n    }\n    pclkMhz = (i2cHandle->Init).NoStretchMode;\n    standardMode = (i2cHandle->Init).GeneralCallMode;\n    i2cInstance->CCR = pclkFreq;\n    i2cInstance->CR1 = standardMode | pclkMhz;\n    i2cInstance->OAR1 = (i2cHandle->Init).AddressingMode | (i2cHandle->Init).OwnAddress1;\n    i2cInstance->OAR2 = (i2cHandle->Init).DualAddressMode | (i2cHandle->Init).OwnAddress2;\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n    i2cHandle->ErrorCode = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001754": "configure_i2_c_08001754",
                "hi2c": "i2cHandle",
                "uVar1": "pclkFreq",
                "extraout_r1": "timeoutPeriod",
                "uVar2": "standardMode",
                "pIVar3": "i2cInstance",
                "uVar4": "clockSpeed",
                "uVar5": "pclkMhz",
                "HAL_StatusTypeDef": "HAL_Status"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001828": {
            "entrypoint": "0x08001828",
            "current_name": "write_i2_c_memory_08001828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nwriteI2CMemory_08001828(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t newTick;\n  I2C_TypeDef *i2cInstance;\n  uint tempVar;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      return HAL_ERROR;\n    }\n    if (dataSize == 0) {\n      return HAL_ERROR;\n    }\n    currentTick = HAL_GetTick();\n    do {\n      i2cInstance = i2cHandle->Instance;\n      if ((~i2cInstance->SR2 & 2) != 0) {\n        if (i2cHandle->Lock == HAL_LOCKED) {\n          return HAL_BUSY;\n        }\n        tempVar = i2cInstance->CR1;\n        i2cHandle->Lock = HAL_LOCKED;\n        i2cInstance->CR1 = tempVar & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n        if (status != HAL_OK) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          if (i2cHandle->ErrorCode == 4) {\n            return HAL_ERROR;\n          }\n          return HAL_TIMEOUT;\n        }\n        goto LAB_080018e2;\n      }\n      newTick = HAL_GetTick();\n    } while (newTick - currentTick < 0x2711);\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n  }\n  return HAL_BUSY;\n  while (dataSize != 0) {\nLAB_080018e2:\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status != HAL_OK) goto LAB_080018ee;\n    i2cInstance = i2cHandle->Instance;\n    i2cInstance->DR = (uint)*data;\n    if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n      if ((uint16_t)(dataSize - 1) == 0) break;\n      dataSize = dataSize - 2;\n      i2cInstance->DR = (uint)data[1];\n      data = data + 2;\n    }\n    else {\n      data = data + 1;\n      dataSize = dataSize - 1;\n    }\n  }\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\nLAB_080018ee:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001828": "write_i2_c_memory_08001828",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "currentTick",
                "uVar3": "newTick",
                "pIVar4": "i2cInstance",
                "uVar5": "tempVar"
            },
            "calling": [
                "I2C_WriteByte"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryWrite",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001938": {
            "entrypoint": "0x08001938",
            "current_name": "read_memory_08001938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nreadMemory_08001938(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint8_t *ptrVar1;\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint32_t tickCurrent;\n  I2C_TypeDef *I2C;\n  uint ctrlReg;\n  uint8_t *ptrVar7;\n  bool flag;\n  uint32_t tempReg;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  \n  if (i2cHandle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  tickStart = HAL_GetTick();\n  while (I2C = i2cHandle->Instance, (~I2C->SR2 & 2) == 0) {\n    tickCurrent = HAL_GetTick();\n    if (10000 < tickCurrent - tickStart) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (i2cHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  ctrlReg = I2C->CR1;\n  i2cHandle->Lock = HAL_LOCKED;\n  I2C->CR1 = ctrlReg & 0xfffff7ff;\n  i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n  i2cHandle->Mode = HAL_I2C_MODE_MEM;\n  i2cHandle->ErrorCode = 0;\n  status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n  if (status != HAL_OK) {\n    i2cHandle->Lock = HAL_UNLOCKED;\n    if (i2cHandle->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  I2C = i2cHandle->Instance;\n  ctrlReg = I2C->CR1;\n  if (size == 1) {\n    I2C->CR1 = ctrlReg & 0xfffffbff;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      *data = (uint8_t)i2cHandle->Instance->DR;\nLAB_08001ab8:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (i2cHandle->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (size == 2) {\n    I2C->CR1 = ctrlReg | 0x800;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    I2C->CR1 = ctrlReg | 0x400;\n    while (3 < size) {\n      status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001a18;\n      *data = (uint8_t)i2cHandle->Instance->DR;\n      I2C = i2cHandle->Instance;\n      flag = (int)(I2C->SR1 << 0x1d) < 0;\n      if (flag) {\n        I2C = (I2C_TypeDef *)I2C->DR;\n        ptrVar7 = data + 2;\n        size = size - 2;\n      }\n      else {\n        ptrVar7 = data + 1;\n        size = size - 1;\n      }\n      ptrVar1 = data + 1;\n      data = ptrVar7;\n      if (flag) {\n        *ptrVar1 = (uint8_t)I2C;\n      }\n    }\n    if (size != 2) {\n      tickStart = HAL_GetTick();\n      do {\n        I2C = i2cHandle->Instance;\n        do {\n          if ((int)(I2C->SR1 << 0x1d) < 0) {\n            I2C->CR1 = I2C->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *data = (uint8_t)i2cHandle->Instance->DR;\n            tickStart = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (tickCurrent = HAL_GetTick(), tickCurrent - tickStart <= timeout));\n      goto LAB_08001afa;\n    }\n  }\n  tickStart = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        I2C = i2cHandle->Instance;\n        I2C->CR1 = I2C->CR1 | 0x200;\n        *data = (uint8_t)I2C->DR;\n        enableIRQinterrupts();\n        data[1] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (tickCurrent = HAL_GetTick(), tickCurrent - tickStart <= timeout));\nLAB_08001afa:\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    I2C = i2cHandle->Instance;\n    do {\n      if ((int)(I2C->SR1 << 0x1d) < 0) {\n        I2C->CR1 = I2C->CR1 | 0x200;\n        data[1] = (uint8_t)I2C->DR;\n        enableIRQinterrupts();\n        data[2] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (tickCurrent = HAL_GetTick(), tickCurrent - tickStart <= timeout));\n  goto LAB_08001afa;\n}\n\n",
            "renaming": {
                "FUN_08001938": "read_memory_08001938",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "puVar1": "ptrVar1",
                "HVar2": "status",
                "uVar3": "tickStart",
                "uVar4": "tickCurrent",
                "pIVar5": "I2C",
                "uVar6": "ctrlReg",
                "puVar7": "ptrVar7",
                "bVar8": "flag",
                "tmpreg": "tempReg",
                "tmpreg_1": "tempReg1",
                "tmpreg_2": "tempReg2"
            },
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b58": {
            "entrypoint": "0x08001b58",
            "current_name": "configure_oscillators_08001b58",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) configureOscillators_08001b58\n/* WARNING: Removing unreachable block (ram,0x08001ee8) configureOscillators_08001b58\n\n/* WARNING: Unknown calling convention configureOscillators_08001b58\n\nHAL_StatusTypeDef configureOscillators_08001b58(RCC_OscInitTypeDef *oscillatorConfig)\n\n{\n  uint32_t tickStart;\n  uint32_t tickCurrent;\n  uint pllSource;\n  uint32_t tmpRegister;\n  \n  if ((int)(oscillatorConfig->OscillatorType << 0x1f) < 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((int)(_DAT_40021004 << 0xf) < 0)))) {\n      if (((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) && (oscillatorConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      tickStart = oscillatorConfig->HSEState;\n      if (tickStart == 0x10000) {\nLAB_08001c1e:\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else {\n        if (tickStart == 0) {\n          _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n          tickStart = HAL_GetTick();\n          while ((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) {\n            tickCurrent = HAL_GetTick();\n            if (100 < tickCurrent - tickStart) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (tickStart == 0x50000) {\n          _DAT_40021000 = _DAT_40021000 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      tickStart = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 0x11) << 0x1f)) {\n        tickCurrent = HAL_GetTick();\n        if (100 < tickCurrent - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  if ((int)(oscillatorConfig->OscillatorType << 0x1e) < 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && (-1 < (int)(_DAT_40021004 << 0xf))))) {\n      if (((int)((_DAT_40021000 >> 1) << 0x1f) < 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uRam42420000 = oscillatorConfig->HSIState;\n      if (uRam42420000 == 0) {\n        tickStart = HAL_GetTick();\n        while ((int)((_DAT_40021000 >> 1) << 0x1f) < 0) {\n          tickCurrent = HAL_GetTick();\n          if (2 < tickCurrent - tickStart) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      uRam42420000 = 1;\n      tickStart = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 1) << 0x1f)) {\n        tickCurrent = HAL_GetTick();\n        if (2 < tickCurrent - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    _DAT_40021000 = oscillatorConfig->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n  }\nLAB_08001b6c:\n  if ((int)(oscillatorConfig->OscillatorType << 0x1c) < 0) {\n    uRam42420480 = oscillatorConfig->LSIState;\n    if (uRam42420480 == 0) {\n      tickStart = HAL_GetTick();\n      while ((int)((_DAT_40021024 >> 1) << 0x1f) < 0) {\n        tickCurrent = HAL_GetTick();\n        if (2 < tickCurrent - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uRam42420480 = 1;\n      tickStart = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021024 >> 1) << 0x1f)) {\n        tickCurrent = HAL_GetTick();\n        if (2 < tickCurrent - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n      HAL_Delay(1);\n    }\n  }\n  if (-1 < (int)(oscillatorConfig->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  _DAT_4002101c = _DAT_4002101c | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0x100;\n  tickStart = HAL_GetTick();\n  while (-1 < (int)(_DAT_40007000 << 0x17)) {\n    tickCurrent = HAL_GetTick();\n    if (100 < tickCurrent - tickStart) {\n      return HAL_TIMEOUT;\n    }\n  }\n  tickStart = oscillatorConfig->LSEState;\n  if (tickStart == 1) {\nLAB_08001e1a:\n    _DAT_40021020 = _DAT_40021020 | 1;\n  }\n  else {\n    if (tickStart == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n      tickStart = HAL_GetTick();\n      while ((int)((_DAT_40021020 >> 1) << 0x1f) < 0) {\n        tickCurrent = HAL_GetTick();\n        if (5000 < tickCurrent - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (tickStart == 5) {\n      _DAT_40021020 = _DAT_40021020 | 4;\n      goto LAB_08001e1a;\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n  }\n  tickStart = HAL_GetTick();\n  while (-1 < (int)((_DAT_40021020 >> 1) << 0x1f)) {\n    tickCurrent = HAL_GetTick();\n    if (5000 < tickCurrent - tickStart) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  tickStart = (oscillatorConfig->PLL).PLLState;\n  if (tickStart == 0) {\n    return HAL_OK;\n  }\n  if ((_DAT_40021004 & 0xc) != 8) {\n    if (tickStart != 2) {\n      uRam42420060 = 0;\n      tickStart = HAL_GetTick();\n      do {\n        if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n          return HAL_OK;\n        }\n        tickCurrent = HAL_GetTick();\n      } while (tickCurrent - tickStart < 3);\n      return HAL_TIMEOUT;\n    }\n    uRam42420060 = 0;\n    tickStart = HAL_GetTick();\n    do {\n      if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n        pllSource = (oscillatorConfig->PLL).PLLSource;\n        if (pllSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillatorConfig->HSEPredivValue;\n        }\n        _DAT_40021004 = pllSource | (oscillatorConfig->PLL).PLLMUL | _DAT_40021004 & 0xffc2ffff;\n        uRam42420060 = 1;\n        tickStart = HAL_GetTick();\n        do {\n          if ((int)((_DAT_40021000 >> 0x19) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          tickCurrent = HAL_GetTick();\n        } while (tickCurrent - tickStart < 3);\n        return HAL_TIMEOUT;\n      }\n      tickCurrent = HAL_GetTick();\n    } while (tickCurrent - tickStart < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001b58": "configure_oscillators_08001b58",
                "RCC_OscInitStruct": "oscillatorConfig",
                "uVar1": "tickStart",
                "uVar2": "tickCurrent",
                "uVar3": "pllSource",
                "tmpreg": "tmpRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002008": {
            "entrypoint": "0x08002008",
            "current_name": "calculate_system_clock_08002008",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSystemClock_08002008(void)\n\n{\n  undefined4 temp1;\n  uint32_t systemClock;\n  undefined4 temp2;\n  undefined4 *PLLMULTablePointer;\n  uint predivFactor;\n  undefined4 *PLLMULFactorTablePointer;\n  uint8_t predivFactorTable [2];\n  uint8_t PLLMULFactorTable [16];\n  \n  PLLMULTablePointer = &DAT_080072f0;\n  PLLMULFactorTablePointer = (undefined4 *)PLLMULFactorTable;\n  do {\n    temp1 = *PLLMULTablePointer;\n    temp2 = PLLMULTablePointer[1];\n    PLLMULTablePointer = PLLMULTablePointer + 2;\n    *PLLMULFactorTablePointer = temp1;\n    PLLMULFactorTablePointer[1] = temp2;\n    PLLMULFactorTablePointer = PLLMULFactorTablePointer + 2;\n  } while (PLLMULTablePointer != (undefined4 *)\"../Src/MPU9250.c\");\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((int)(_DAT_40021004 << 0xf) < 0) {\n      predivFactor = 8000000 / predivFactorTable[(_DAT_40021004 & 0x20000) >> 0x11];\n    }\n    else {\n      predivFactor = 4000000;\n    }\n    systemClock = predivFactor * PLLMULFactorTable[(_DAT_40021004 & 0x3c0000) >> 0x12];\n  }\n  else {\n    systemClock = 8000000;\n  }\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08002008": "calculate_system_clock_08002008",
                "uVar1": "temp1",
                "uVar2": "systemClock",
                "uVar3": "temp2",
                "puVar4": "PLLMULTablePointer",
                "uVar5": "predivFactor",
                "puVar6": "PLLMULFactorTablePointer",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "PLLMULFactorTable"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800209c": {
            "entrypoint": "0x0800209c",
            "current_name": "configure_clock_system_0800209c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureClockSystem_0800209c(clockConfig *RCC_ClkInitStruct,uint32_t desiredLatency)\n\n{\n  char isPositive;\n  char isZero;\n  uint32_t sysClockFreq;\n  uint32_t currentTick;\n  uint sysclkSource;\n  \n  if ((desiredLatency <= (_DAT_40022000 & 7)) ||\n     (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | desiredLatency, desiredLatency == (desiredLatency & 7))) {\n    if ((int)(RCC_ClkInitStruct->ClockType << 0x1e) < 0) {\n      _DAT_40021004 = _DAT_40021004 & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n    }\n    if (-1 < (int)(RCC_ClkInitStruct->ClockType << 0x1f)) {\nLAB_080020ba:\n      if ((desiredLatency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | desiredLatency, desiredLatency != (desiredLatency & 7))) {\n        return HAL_ERROR;\n      }\n      if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider;\n      }\n      if ((int)(RCC_ClkInitStruct->ClockType << 0x1c) < 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n      }\n      sysClockFreq = HAL_RCC_GetSysClockFreq();\n      SystemCoreClock = sysClockFreq >> \"\"[(_DAT_40021004 & 0xf0) >> 4];\n      HAL_InitTick(0);\n      return HAL_OK;\n    }\n    sysclkSource = RCC_ClkInitStruct->SYSCLKSource;\n    if (sysclkSource == 1) {\n      isZero = '\\x01';\n      isPositive = '\\0';\n    }\n    else {\n      if (sysclkSource == 2) goto LAB_08002176;\n      isZero = '\\0';\n      isPositive = '\\x01';\n    }\n    if ((int)((_DAT_40021000 >>\n              (LZCOUNT((uint)(byte)(isPositive << 6) << 0x18 | (uint)(byte)(isZero << 6) << 8) & 0x1fU))\n             << 0x1f) < 0) {\nLAB_08002176:\n      _DAT_40021004 = _DAT_40021004 & 0xfffffffc | sysclkSource;\n      sysClockFreq = HAL_GetTick();\n      if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_080020ba;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n      }\n      else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_080020ba;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_080020ba;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n      }\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800209c": "configure_clock_system_0800209c",
                "RCC_ClkInitTypeDef": "clockConfig",
                "FLatency": "desiredLatency",
                "cVar1": "isPositive",
                "cVar2": "isZero",
                "uVar3": "sysClockFreq",
                "uVar4": "currentTick",
                "uVar5": "sysclkSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002214": {
            "entrypoint": "0x08002214",
            "current_name": "get_system_core_clock_08002214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08002214(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08002214": "get_system_core_clock_08002214",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002220": {
            "entrypoint": "0x08002220",
            "current_name": "get_adjusted_system_clock_08002220",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedSystemClock_08002220(void)\n\n{\n  return currentClockSpeed >> \"\"[(_DAT_40021004 & 0x700) >> 8];\n}\n\n",
            "renaming": {
                "FUN_08002220": "get_adjusted_system_clock_08002220",
                "SystemCoreClock": "currentClockSpeed"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002250": {
            "entrypoint": "0x08002250",
            "current_name": "get_adjusted_clock_speed_08002250",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedClockSpeed_08002250(void)\n\n{\n  return SystemCoreClock >> \"\"[(_DAT_40021004 & 0x3800) >> 0xb];\n}\n\n",
            "renaming": {
                "FUN_08002250": "get_adjusted_clock_speed_08002250"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002280": {
            "entrypoint": "0x08002280",
            "current_name": "initialize_timer_08002280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08002280(TimerType *TIMx,TIM_OC_InitTypeDef *PWMConfig)\n\n{\n  uint32_t configValue1;\n  uint32_t configValue2;\n  uint modeValue;\n  \n  TIMx->CCER = TIMx->CCER & 0xfffffffe;\n  configValue2 = TIMx->CR2;\n  modeValue = PWMConfig->OCMode;\n  configValue1 = TIMx->CCER & 0xfffffffd | PWMConfig->OCPolarity;\n  if (TIMx == (TimerType *)0x40012c00) {\n    configValue1 = (configValue1 & 0xfffffff7 | PWMConfig->OCNPolarity) & 0xfffffffb;\n    configValue2 = configValue2 & 0xfffffcff | PWMConfig->OCIdleState | PWMConfig->OCNIdleState;\n  }\n  TIMx->CR2 = configValue2;\n  TIMx->CCMR1 = TIMx->CCMR1 & 0xffffff8c | modeValue;\n  TIMx->CCR1 = PWMConfig->Pulse;\n  TIMx->CCER = configValue1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002280": "initialize_timer_08002280",
                "TIM_TypeDef": "TimerType",
                "OC_Config": "PWMConfig",
                "uVar1": "configValue1",
                "uVar2": "configValue2",
                "uVar3": "modeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022d0": {
            "entrypoint": "0x080022d0",
            "current_name": "configure_tim_output_compare_080022d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimOutputCompare_080022d0(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t modifiedCCER;\n  uint32_t modifiedCR2;\n  uint outputMode;\n  \n  timer->captureCompareEnableRegister = timer->captureCompareEnableRegister & 0xfffffeff;\n  modifiedCR2 = timer->controlRegister2;\n  outputMode = outputCompareConfig->outputCompareMode;\n  modifiedCCER = timer->captureCompareEnableRegister & 0xfffffdff | outputCompareConfig->outputPolarity << 8;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    modifiedCCER = (modifiedCCER & 0xfffff7ff | outputCompareConfig->outputNpolarity << 8) & 0xfffffbff;\n    modifiedCR2 = modifiedCR2 & 0xffffcfff | (outputCompareConfig->outputIdleState | outputCompareConfig->outputNidleState) << 4;\n  }\n  timer->controlRegister2 = modifiedCR2;\n  timer->captureCompareModeRegister2 = timer->captureCompareModeRegister2 & 0xffffff8c | outputMode;\n  timer->captureCompareRegister3 = outputCompareConfig->pulseWidth;\n  timer->captureCompareEnableRegister = modifiedCCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022d0": "configure_tim_output_compare_080022d0",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "modifiedCCER",
                "uVar2": "modifiedCR2",
                "uVar3": "outputMode",
                "CCER": "captureCompareEnableRegister",
                "CR2": "controlRegister2",
                "OCMode": "outputCompareMode",
                "OCPolarity": "outputPolarity",
                "OCNPolarity": "outputNpolarity",
                "OCIdleState": "outputIdleState",
                "OCNIdleState": "outputNidleState",
                "CCMR2": "captureCompareModeRegister2",
                "CCR3": "captureCompareRegister3",
                "Pulse": "pulseWidth"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002324": {
            "entrypoint": "0x08002324",
            "current_name": "configure_timer_output_08002324",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_08002324(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t controlRegisterValue;\n  uint32_t outputMode;\n  uint32_t outputPolarity;\n  uint32_t idleState;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  controlRegisterValue = timer->CR2;\n  outputMode = outputConfig->OCMode;\n  outputPolarity = outputConfig->OCPolarity;\n  idleState = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    idleState = outputConfig->OCIdleState;\n    controlRegisterValue = controlRegisterValue & 0xffffbfff;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    controlRegisterValue = controlRegisterValue | idleState << 6;\n  }\n  timer->CR2 = controlRegisterValue;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | outputMode << 8;\n  timer->CCR4 = outputConfig->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | outputPolarity << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002324": "configure_timer_output_08002324",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "controlRegisterValue",
                "uVar2": "outputMode",
                "uVar3": "outputPolarity",
                "uVar4": "idleState"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002368": {
            "entrypoint": "0x08002368",
            "current_name": "configure_timer_08002368",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_08002368(TIM_TypeDef *timer,TIM_Base_InitTypeDef *timerConfig)\n\n{\n  uint32_t cr1Value;\n  \n  cr1Value = timer->CR1;\n  if (((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n       (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) &&\n     (((cr1Value = cr1Value & 0xffffff8f | timerConfig->CounterMode, timer == (TIM_TypeDef *)0x40012c00 ||\n       (timer == (TIM_TypeDef *)0x40000000)) ||\n      ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))))) {\n    cr1Value = cr1Value & 0xfffffcff | timerConfig->ClockDivision;\n  }\n  timer->CR1 = cr1Value;\n  timer->ARR = timerConfig->Period;\n  timer->PSC = timerConfig->Prescaler;\n  cr1Value = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    cr1Value = timerConfig->RepetitionCounter;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    timer->RCR = cr1Value;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002368": "configure_timer_08002368",
                "TIMx": "timer",
                "Structure": "timerConfig",
                "uVar1": "cr1Value"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023d0": {
            "entrypoint": "0x080023d0",
            "current_name": "initialize_timer_080023d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeTimer_080023d0(TIM_HandleTypeDef *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef *)0x0) {\n    if (timer->currentState == TIM_RESET) {\n      timer->Lock = TIM_UNLOCKED;\n      initializePWM(timer);\n    }\n    timer->currentState = TIM_BUSY;\n    setTimerConfig(timer->timerInstance,&timer->timerInitialization);\n    timer->currentState = TIM_READY;\n    return SUCCESS;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_080023d0": "initialize_timer_080023d0",
                "htim": "timer",
                "State": "currentState",
                "HAL_TIM_STATE_RESET": "TIM_RESET",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "HAL_TIM_STATE_BUSY": "TIM_BUSY",
                "HAL_TIM_STATE_READY": "TIM_READY",
                "HAL_OK": "SUCCESS",
                "HAL_ERROR": "ERROR",
                "HAL_TIM_PWM_MspInit": "initializePWM",
                "TIM_Base_SetConfig": "setTimerConfig",
                "Instance": "timerInstance",
                "Init": "timerInitialization"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002404": {
            "entrypoint": "0x08002404",
            "current_name": "set_output_compare_config_08002404",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setOutputCompareConfig_08002404(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint32_t ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2Value = timer->CR2;\n  ocModeValue = outputCompareConfig->OCMode;\n  ccerValue = timer->CCER & 0xffffffdf | outputCompareConfig->OCPolarity << 4;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xffffff7f | outputCompareConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2Value = cr2Value & 0xfffff3ff | (outputCompareConfig->OCIdleState | outputCompareConfig->OCNIdleState) << 2;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocModeValue << 8;\n  timer->CCR2 = outputCompareConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002404": "set_output_compare_config_08002404",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800245c": {
            "entrypoint": "0x0800245c",
            "current_name": "configure_timer_channel_0800245c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_0800245c(TIM_HandleTypeDef *timerHandle,TIM_OC_InitTypeDef *config,uint32_t channel)\n\n{\n  int var1;\n  int var2;\n  int var3;\n  uint value1;\n  int var4;\n  int value2;\n  uint32_t result;\n  TIM_TypeDef *timer;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  timerHandle->State = HAL_TIM_STATE_BUSY;\n  timerHandle->Lock = HAL_LOCKED;\n  switch(channel) {\n  case 0:\n    TIM_OC1_SetConfig(timerHandle->Instance,config);\n    timer = timerHandle->Instance;\n    value1 = *(uint *)(var1 + 0x10);\n    timer->CCMR1 = timer->CCMR1 | 8;\n    timer->CCMR1 = timer->CCMR1 & 0xfffffffb;\n    result = timer->CCMR1 | value1;\n    break;\n  default:\n    goto switchD_0800247a_caseD_1;\n  case 4:\n    TIM_OC2_SetConfig(timerHandle->Instance,config);\n    timer = timerHandle->Instance;\n    value2 = *(int *)(var2 + 0x10);\n    timer->CCMR1 = timer->CCMR1 | 0x800;\n    timer->CCMR1 = timer->CCMR1 & 0xfffffbff;\n    result = timer->CCMR1 | value2 << 8;\n    break;\n  case 8:\n    TIM_OC3_SetConfig(timerHandle->Instance,config);\n    timer = timerHandle->Instance;\n    value1 = *(uint *)(var3 + 0x10);\n    timer->CCMR2 = timer->CCMR2 | 8;\n    timer->CCMR2 = timer->CCMR2 & 0xfffffffb;\n    result = timer->CCMR2 | value1;\n    goto LAB_080024fa;\n  case 0xc:\n    TIM_OC4_SetConfig(timerHandle->Instance,config);\n    timer = timerHandle->Instance;\n    value2 = *(int *)(var4 + 0x10);\n    timer->CCMR2 = timer->CCMR2 | 0x800;\n    timer->CCMR2 = timer->CCMR2 & 0xfffffbff;\n    result = timer->CCMR2 | value2 << 8;\nLAB_080024fa:\n    timer->CCMR2 = result;\n    goto switchD_0800247a_caseD_1;\n  }\n  timer->CCMR1 = result;\nswitchD_0800247a_caseD_1:\n  timerHandle->State = HAL_TIM_STATE_READY;\n  timerHandle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800245c": "configure_timer_channel_0800245c",
                "htim": "timerHandle",
                "sConfig": "config",
                "Channel": "channel",
                "extraout_r1": "var1",
                "extraout_r1_00": "var2",
                "extraout_r1_01": "var3",
                "extraout_r1_02": "var4",
                "uVar1": "value1",
                "iVar2": "value2",
                "uVar3": "result",
                "pTVar4": "timer"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002520": {
            "entrypoint": "0x08002520",
            "current_name": "update_channel_state_08002520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08002520(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = state << (channel & 0xff) | timer->CCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002520": "update_channel_state_08002520",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002538": {
            "entrypoint": "0x08002538",
            "current_name": "configure_timer_channel_08002538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_08002538(TIM_HandleTypeDef *timerHandler,uint32_t channel)\n\n{\n  uint32_t controlValue;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandler->Instance,channel,1);\n  timerInstance = timerHandler->Instance;\n  controlValue = 0x40012c00;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    controlValue = uRam40012c44 | 0x8000;\n  }\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    timerInstance->BDTR = controlValue;\n  }\n  timerInstance->CR1 = timerInstance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002538": "configure_timer_channel_08002538",
                "htim": "timerHandler",
                "Channel": "channel",
                "uVar1": "controlValue",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "PWM_Init"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002564": {
            "entrypoint": "0x08002564",
            "current_name": "configure_break_dead_time_08002564",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureBreakDeadTime_08002564(TIM_HandleTypeDef *timerHandle,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n\n{\n  HAL_StatusTypeDef status;\n  \n  status = HAL_BUSY;\n  if (timerHandle->Lock != HAL_LOCKED) {\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->BDTR =\n         breakDeadTimeConfig->OffStateRunMode | breakDeadTimeConfig->OffStateIDLEMode |\n         breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime |\n         breakDeadTimeConfig->BreakState | breakDeadTimeConfig->BreakPolarity |\n         breakDeadTimeConfig->AutomaticOutput;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timerHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002564": "configure_break_dead_time_08002564",
                "htim": "timerHandle",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025a4": {
            "entrypoint": "0x080025a4",
            "current_name": "configure_master_timer_080025a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureMasterTimer_080025a4(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  uint masterSlaveMode;\n  HAL_StatusTypeDef status;\n  TIM_TypeDef *timerInstance;\n  uint masterOutputTrigger;\n  \n  status = HAL_BUSY;\n  if (timerHandle->Lock != HAL_LOCKED) {\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerInstance = timerHandle->Instance;\n    masterOutputTrigger = masterConfig->MasterOutputTrigger;\n    masterSlaveMode = masterConfig->MasterSlaveMode;\n    timerInstance->CR2 = timerInstance->CR2 & 0xffffff8f;\n    timerInstance->CR2 = timerInstance->CR2 | masterOutputTrigger;\n    timerInstance->SMCR = timerInstance->SMCR & 0xffffff7f;\n    timerInstance->SMCR = timerInstance->SMCR | masterSlaveMode;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timerHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080025a4": "configure_master_timer_080025a4",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "uVar1": "masterSlaveMode",
                "HVar2": "status",
                "pTVar3": "timerInstance",
                "uVar4": "masterOutputTrigger"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "configure_uart_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configure_uart_080025e8(uart_handle *uart_handle)\n\n{\n  uint32_t pclk_freq;\n  uint32_t pclk_freq2;\n  uint parity;\n  int baud_rate_division;\n  uint32_t baud_rate;\n  int baud_rate_correction;\n  USART_TypeDef *usart_instance;\n  \n  usart_instance = uart_handle->Instance;\n  parity = (uart_handle->Init).Parity;\n  usart_instance->CR2 = usart_instance->CR2 & 0xffffcfff | (uart_handle->Init).StopBits;\n  usart_instance->CR1 = (uart_handle->Init).WordLength | parity | (uart_handle->Init).Mode | usart_instance->CR1 & 0xffffe9f3;\n  usart_instance->CR3 = usart_instance->CR3 & 0xfffffcff | (uart_handle->Init).HwFlowCtl;\n  if (usart_instance == (USART_TypeDef *)0x40013800) {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate_division = (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100);\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq2 = HAL_RCC_GetPCLK2Freq();\n    baud_rate_correction = (pclk_freq * 0x19) / (baud_rate << 2) +\n            (int)(((ulonglong)(pclk_freq2 * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    parity = (pclk_freq * 0x19) / ((uart_handle->Init).BaudRate << 2);\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n  }\n  else {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate_division = (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100);\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq2 = HAL_RCC_GetPCLK1Freq();\n    baud_rate_correction = (pclk_freq * 0x19) / (baud_rate << 2) +\n            (int)(((ulonglong)(pclk_freq2 * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    parity = (pclk_freq * 0x19) / ((uart_handle->Init).BaudRate << 2);\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n  }\n  usart_instance->BRR = (((parity + (int)(((ulonglong)(pclk_freq * 0x19) /\n                                 (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) * -100) * 0x10 +\n                 0x32) / 100 & 0xf | (baud_rate_correction * 0x10 + 0x32U) / 100 & 0xf0) + baud_rate_division * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "configure_uart_080025e8",
                "UART_HandleTypeDef": "uart_handle",
                "huart": "uart_handle",
                "uVar1": "pclk_freq",
                "uVar2": "pclk_freq2",
                "uVar3": "parity",
                "iVar4": "baud_rate_division",
                "uVar5": "baud_rate",
                "iVar6": "baud_rate_correction",
                "pUVar7": "usart_instance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002724": {
            "entrypoint": "0x08002724",
            "current_name": "initialize_uart_08002724",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initialize_UART_08002724(UART_HandleTypeDef *UART_handle)\n\n{\n  USART_TypeDef *UART_instance;\n  \n  if (UART_handle != (UART_HandleTypeDef *)0x0) {\n    if (UART_handle->State == UART_STATE_RESET) {\n      UART_handle->Lock = UART_UNLOCKED;\n      initialize_UART_08002724_Msp(UART_handle);\n    }\n    UART_handle->State = HAL_UART_STATE_BUSY;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 & 0xffffdfff;\n    set_UART_Config(UART_handle);\n    UART_instance = UART_handle->Instance;\n    UART_instance->CR2 = UART_instance->CR2 & 0xffffb7ff;\n    UART_instance->CR3 = UART_instance->CR3 & 0xffffffd5;\n    UART_instance->CR1 = UART_instance->CR1 | 0x2000;\n    UART_handle->ErrorCode = 0;\n    UART_handle->State = HAL_UART_STATE_READY;\n    return UART_SUCCESS;\n  }\n  return UART_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002724": "initialize_uart_08002724",
                "huart": "UART_handle",
                "pUVar1": "UART_instance",
                "HAL_UART_STATE_RESET": "UART_STATE_RESET",
                "HAL_UNLOCKED": "UART_UNLOCKED",
                "HAL_UART_MspInit": "initialize_UART_Msp",
                "UART_SetConfig": "set_UART_Config",
                "HAL_OK": "UART_SUCCESS",
                "HAL_ERROR": "UART_ERROR"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800277c": {
            "entrypoint": "0x0800277c",
            "current_name": "uart_transmit_data_0800277c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nuart_TransmitData_0800277c(UART_HandleTypeDef *uart_handle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  HAL_UART_StateTypeDef uart_state;\n  USART_TypeDef *uart_instance;\n  uint16_t *tmp;\n  \n  if ((uart_handle->State == HAL_UART_STATE_READY) || (uart_handle->State == HAL_UART_STATE_BUSY_RX)) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      return HAL_ERROR;\n    }\n    if (uart_handle->Lock != HAL_LOCKED) {\n      uart_handle->Lock = HAL_LOCKED;\n      uart_handle->ErrorCode = 0;\n      uart_handle->TxXfersize = size;\n      if (uart_handle->State == HAL_UART_STATE_BUSY_RX) {\n        uart_state = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uart_state = HAL_UART_STATE_BUSY_TX;\n      }\n      uart_handle->TxXferCount = size;\n      uart_handle->State = uart_state;\nLAB_080027c4:\n      if (uart_handle->TxXferCount == 0) {\n        uVar1 = HAL_GetTick();\n        do {\n          do {\n            if ((int)(uart_handle->Instance->SR << 0x19) < 0) {\n              if (uart_handle->State == HAL_UART_STATE_BUSY_TX_RX) {\n                uart_state = HAL_UART_STATE_BUSY_RX;\n              }\n              else {\n                uart_state = HAL_UART_STATE_READY;\n              }\n              uart_handle->State = uart_state;\n              uart_handle->Lock = HAL_UNLOCKED;\n              return HAL_OK;\n            }\n          } while (timeout == 0xffffffff);\n        } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n      }\n      else {\n        uart_handle->TxXferCount = uart_handle->TxXferCount - 1;\n        if ((uart_handle->Init).WordLength == 0x1000) {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uart_handle->Instance->SR << 0x18) < 0) {\n                uart_handle->Instance->DR = *(ushort *)data & 0x1ff;\n                if ((uart_handle->Init).Parity == 0) {\n                  data = (uint8_t *)((int)data + 2);\n                }\n                else {\nLAB_08002812:\n                  data = (uint8_t *)((int)data + 1);\n                }\n                goto LAB_080027c4;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n        else {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uart_handle->Instance->SR << 0x18) < 0) {\n                uart_handle->Instance->DR = (uint)*data;\n                goto LAB_08002812;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n      }\n      uart_instance = uart_handle->Instance;\n      uart_instance->CR1 = uart_instance->CR1 & 0xffffff7f;\n      uart_instance->CR1 = uart_instance->CR1 & 0xffffffdf;\n      uart_instance->CR1 = uart_instance->CR1 & 0xfffffeff;\n      uart_instance->CR3 = uart_instance->CR3 & 0xfffffffe;\n      uart_handle->State = HAL_UART_STATE_READY;\n      uart_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800277c": "uart_transmit_data_0800277c",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar3": "uart_state",
                "pUVar4": "uart_instance"
            },
            "calling": [
                "serialWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028a6": {
            "entrypoint": "0x080028a6",
            "current_name": "initialize_uart_080028a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUART_080028a6(UART_HandleTypeDef *UARTHandle,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  HAL_UART_StateTypeDef uartState;\n  uint controlReg;\n  USART_TypeDef *uartInstance;\n  \n  if ((UARTHandle->State == HAL_UART_STATE_READY) || (UARTHandle->State == HAL_UART_STATE_BUSY_TX)) {\n    if ((dataBuffer == (uint8_t *)0x0) || (dataSize == 0)) {\n      return HAL_ERROR;\n    }\n    if (UARTHandle->Lock != HAL_LOCKED) {\n      UARTHandle->Lock = HAL_LOCKED;\n      UARTHandle->ErrorCode = 0;\n      UARTHandle->RxXferdataSize = dataSize;\n      UARTHandle->RxXferCount = dataSize;\n      UARTHandle->Lock = HAL_UNLOCKED;\n      if (UARTHandle->State == HAL_UART_STATE_BUSY_TX) {\n        uartState = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = HAL_UART_STATE_BUSY_RX;\n      }\n      uartInstance = UARTHandle->Instance;\n      UARTHandle->State = uartState;\n      controlReg = uartInstance->CR1;\n      UARTHandle->pRxBuffPtr = dataBuffer;\n      uartInstance->CR1 = controlReg | 0x100;\n      uartInstance->CR3 = uartInstance->CR3 | 1;\n      uartInstance->CR1 = uartInstance->CR1 | 0x20;\n      return HAL_OK;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080028a6": "initialize_uart_080028a6",
                "huart": "UARTHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "HVar1": "uartState",
                "uVar2": "controlReg",
                "pUVar3": "uartInstance"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800290a": {
            "entrypoint": "0x0800290a",
            "current_name": "FUNC_0800290a",
            "code": "\nvoid FUNC_0800290a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800290a": "FUNC_0800290a"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800290c": {
            "entrypoint": "0x0800290c",
            "current_name": "receive_uart_data_0800290c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef receive_UART_data_0800290c(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t parity;\n  byte byte_value;\n  USART_TypeDef *uart_instance;\n  uint16_t rx_transfer_count;\n  ushort *rx_buffer;\n  uint16_t *temp;\n  ushort *updated_rx_buffer;\n  bool is_busy;\n  \n  if ((uart_handle->State & 0xef) != 0x22) {\n    return HAL_UART_BUSY;\n  }\n  parity = (uart_handle->Init).Parity;\n  uart_instance = uart_handle->Instance;\n  rx_buffer = (ushort *)uart_handle->pRxBuffPtr;\n  if ((uart_handle->Init).WordLength == 0x1000) {\n    if (parity == 0) {\n      updated_rx_buffer = rx_buffer + 1;\n      *rx_buffer = (ushort)((uart_instance->DR << 0x17) >> 0x17);\n    }\n    else {\n      updated_rx_buffer = (ushort *)((int)rx_buffer + 1);\n      *rx_buffer = (ushort)uart_instance->DR & 0xff;\n    }\n    uart_handle->pRxBuffPtr = (uint8_t *)updated_rx_buffer;\n  }\n  else {\n    if (parity == 0) {\n      byte_value = (byte)uart_instance->DR;\n      uart_handle->pRxBuffPtr = (uint8_t *)((int)rx_buffer + 1);\n    }\n    else {\n      parity = uart_instance->DR;\n      uart_handle->pRxBuffPtr = (uint8_t *)((int)rx_buffer + 1);\n      byte_value = (byte)parity & 0x7f;\n    }\n    *(byte *)rx_buffer = byte_value;\n  }\n  rx_transfer_count = uart_handle->RxXferCount - 1;\n  uart_handle->RxXferCount = rx_transfer_count;\n  if (rx_transfer_count == 0) {\n    uart_instance = uart_handle->Instance;\n    uart_instance->CR1 = uart_instance->CR1 & 0xffffffdf;\n    is_busy = uart_handle->State != HAL_UART_STATE_BUSY_TX_RX;\n    if (is_busy) {\n      parity = uart_instance->CR1 & 0xfffffeff;\n    }\n    else {\n      uart_instance = (USART_TypeDef *)0x12;\n      parity = 0x32;\n    }\n    if (is_busy) {\n      uart_instance->CR1 = parity;\n      parity = uart_instance->CR3 & 0xfffffffe;\n    }\n    if (is_busy) {\n      uart_instance->CR3 = parity;\n      uart_instance = (USART_TypeDef *)0x1;\n    }\n    uart_handle->State = (UART_state)uart_instance;\n    handle_received_data_callback(uart_handle);\n  }\n  return HAL_UART_OK;\n}\n\n",
            "renaming": {
                "FUN_0800290c": "receive_uart_data_0800290c",
                "huart": "uart_handle",
                "uVar1": "parity",
                "bVar2": "byte_value",
                "pUVar3": "uart_instance",
                "uVar4": "rx_transfer_count",
                "puVar5": "rx_buffer",
                "tmp": "temp",
                "puVar6": "updated_rx_buffer",
                "bVar7": "is_busy",
                "HAL_BUSY": "HAL_UART_BUSY",
                "HAL_OK": "HAL_UART_OK",
                "HAL_UART_StateTypeDef": "UART_state",
                "HAL_UART_RxCpltCallback": "handle_received_data_callback"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002998": {
            "entrypoint": "0x08002998",
            "current_name": "FUNC_08002998",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002998": "FUNC_08002998"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800299a": {
            "entrypoint": "0x0800299a",
            "current_name": "handle_uart_interrupt_0800299a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_0800299a(UART_HandleTypeDef *uart_handle)\n\n{\n  uint status_reg;\n  uint32_t status_reg2;\n  uint16_t temp_reg;\n  uint status_reg3;\n  uint32_t status_flags;\n  ushort *pointer_var;\n  uint16_t *temp_pointer;\n  HAL_UART_StateTypeDef state_var;\n  USART_TypeDef *uart_instance;\n  uint32_t error_code;\n  uint32_t status_reg4;\n  uint flag;\n  bool bool_var;\n  \n  uart_instance = uart_handle->Instance;\n  status_reg3 = uart_instance->SR;\n  status_reg = uart_instance->CR1;\n  if ((status_reg3 & 0xf) == 0) {\n    if (((int)(status_reg3 << 0x1a) < 0) && ((int)(status_reg << 0x1a) < 0)) {\n      UART_Receive_IT(uart_handle);\n      return;\n    }\n  }\n  else {\n    flag = uart_instance->CR3 & 1;\n    if ((flag != 0) || ((status_reg & 0x120) != 0)) {\n      error_code = status_reg3 << 0x1f;\n      if ((int)error_code < 0) {\n        bool_var = (int)(status_reg << 0x17) < 0;\n        if (bool_var) {\n          error_code = uart_handle->ErrorCode | 1;\n        }\n        if (bool_var) {\n          uart_handle->ErrorCode = error_code;\n        }\n      }\n      if (((int)(status_reg3 << 0x1d) < 0) && (flag != 0)) {\n        uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n      }\n      if (((int)(status_reg3 << 0x1e) < 0) && (flag != 0)) {\n        uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n      }\n      if (((int)(status_reg3 << 0x1c) < 0) && (flag != 0)) {\n        uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n      }\n      if (uart_handle->ErrorCode == 0) {\n        return;\n      }\n      if (((int)(status_reg3 << 0x1a) < 0) && ((int)(status_reg << 0x1a) < 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      uart_instance = uart_handle->Instance;\n      if ((-1 < (int)(uart_handle->ErrorCode << 0x1c)) && ((uart_instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      uart_instance->CR1 = uart_instance->CR1 & 0xfffffedf;\n      uart_instance->CR3 = uart_instance->CR3 & 0xfffffffe;\n      uart_handle->State = HAL_UART_STATE_READY;\n      HAL_UART_ErrorCallback(uart_handle);\n      return;\n    }\n  }\n  if (((int)(status_reg3 << 0x18) < 0) && ((int)(status_reg << 0x18) < 0)) {\n    if ((uart_handle->State & 0xdf) == 0x12) {\n      pointer_var = (ushort *)uart_handle->pTxBuffPtr;\n      if ((uart_handle->Init).WordLength == 0x1000) {\n        uart_instance->DR = *pointer_var & 0x1ff;\n        if ((uart_handle->Init).Parity == 0) {\n          pointer_var = pointer_var + 1;\n        }\n        else {\n          pointer_var = (ushort *)((int)pointer_var + 1);\n        }\n        uart_handle->pTxBuffPtr = (uint8_t *)pointer_var;\n      }\n      else {\n        uart_handle->pTxBuffPtr = (byte *)((int)pointer_var + 1);\n        uart_instance->DR = (uint)*(byte *)pointer_var;\n      }\n      temp_reg = uart_handle->TxXferCount - 1;\n      uart_handle->TxXferCount = temp_reg;\n      if (temp_reg == 0) {\n        uart_instance->CR1 = uart_instance->CR1 & 0xffffff7f;\n        uart_instance->CR1 = uart_instance->CR1 | 0x40;\n        return;\n      }\n    }\n  }\n  else if (((int)(status_reg3 << 0x19) < 0) && ((int)(status_reg << 0x19) < 0)) {\n    uart_instance->CR1 = uart_instance->CR1 & 0xffffffbf;\n    if (uart_handle->State == HAL_UART_STATE_BUSY_TX_RX) {\n      state_var = HAL_UART_STATE_BUSY_RX;\n    }\n    else {\n      state_var = HAL_UART_STATE_READY;\n    }\n    uart_handle->State = state_var;\n    HAL_UART_TxCpltCallback(uart_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800299a": "handle_uart_interrupt_0800299a",
                "huart": "uart_handle",
                "uVar1": "status_reg",
                "cr1its": "status_reg2",
                "uVar2": "temp_reg",
                "uVar3": "status_reg3",
                "isrflags": "status_flags",
                "puVar4": "pointer_var",
                "tmp": "temp_pointer",
                "HVar5": "state_var",
                "pUVar6": "uart_instance",
                "uVar7": "error_code",
                "cr3its": "status_reg4",
                "uVar8": "flag",
                "bVar9": "bool_var"
            },
            "calling": [
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad0": {
            "entrypoint": "0x08002ad0",
            "current_name": "configure_mpu9250_08002ad0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureMPU9250_08002ad0(void)\n\n{\n  readByteFromI2C(0xd0,0x75,\"../Src/MPU9250.c\",0x3b);\n  writeByteToI2C(0xd0,0x6b,0x80,'\\x01');\n  writeByteToI2C(0xd0,0x6b,'\\x01','\\x01');\n  writeByteToI2C(0xd0,0x6c,'\\0','\\x01');\n  writeByteToI2C(0xd0,0x19,'\\0','\\x01');\n  writeByteToI2C(0xd0,0x1d,'\\x03','\\x01');\n  writeByteToI2C(0xd0,0x1a,'\\x03','\\x01');\n  writeByteToI2C(0xd0,0x1b,'\\x10','\\x01');\n  writeByteToI2C(0xd0,0x1c,'\\b','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ad0": "configure_mpu9250_08002ad0",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_WriteByte": "writeByteToI2C"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "I2C_WriteByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b48": {
            "entrypoint": "0x08002b48",
            "current_name": "read_and_process_accel_data_08002b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndProcessAccelData_08002b48(void)\n\n{\n  undefined4 convertedValue;\n  uint inputData;\n  int convertedAccelZ;\n  int convertedAccelY;\n  uint8_t accelRawData [6];\n  \n  accelRawData[0] = '\\0';\n  accelRawData[1] = '\\0';\n  accelRawData[2] = '\\0';\n  accelRawData[3] = '\\0';\n  stackVar = inputData & 0xffff0000;\n  I2C_ReadByteArray(0xd0,0x3b,accelRawData,6,\"../Src/MPU9250.c\",0x58);\n  rawAccelY = CONCAT11(accelRawData[2],accelRawData[3]);\n  rawAccelX = CONCAT11(accelRawData[0],accelRawData[1]);\n  rawAccelZ = CONCAT11(accelRawData[4],accelRawData[5]);\n  convertedAccelY = (int)rawAccelY;\n  convertedAccelZ = (int)rawAccelZ;\n  convertedValue = __floatsisf();\n  convertedValue = __aeabi_fmul(convertedValue,0x40800000);\n  processedAccelX = (float)__aeabi_fmul(convertedValue,0x38000000);\n  convertedValue = __floatsisf(convertedAccelY);\n  convertedValue = __aeabi_fmul(convertedValue,0x40800000);\n  processedAccelY = (float)__aeabi_fmul(convertedValue,0x38000000);\n  convertedValue = __floatsisf(convertedAccelZ);\n  convertedValue = __aeabi_fmul(convertedValue,0x40800000);\n  processedAccelZ = (float)__aeabi_fmul(convertedValue,0x38000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b48": "read_and_process_accel_data_08002b48",
                "in_r3": "inputData",
                "raw_data": "accelRawData",
                "stack0xffffffec": "stackVar",
                "accelRaw.y": "rawAccelY",
                "accelRaw.x": "rawAccelX",
                "accelRaw.z": "rawAccelZ",
                "iVar3": "convertedAccelY",
                "iVar2": "convertedAccelZ",
                "uVar1": "convertedValue",
                "accelData.x": "processedAccelX",
                "accelData.y": "processedAccelY",
                "accelData.z": "processedAccelZ"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bf0": {
            "entrypoint": "0x08002bf0",
            "current_name": "read_and_process_gyro_data_08002bf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndProcessGyroData_08002bf0(void)\n\n{\n  undefined4 gyroConversionFactor;\n  int gyroRawDataZ;\n  int gyroRawDataY;\n  uint8_t gyroRawData [6];\n  \n  gyroRawData[0] = '\\0';\n  gyroRawData[1] = '\\0';\n  gyroRawData[2] = '\\0';\n  gyroRawData[3] = '\\0';\n  gyroRawData[4] = '\\0';\n  gyroRawData[5] = '\\0';\n  I2C_ReadByteArray(0xd0,0x43,gyroRawData,6,\"../Src/MPU9250.c\",0x7b);\n  gyroRaw.y = CONCAT11(gyroRawData[2],gyroRawData[3]);\n  gyroRaw.x = CONCAT11(gyroRawData[0],gyroRawData[1]);\n  gyroRaw.z = CONCAT11(gyroRawData[4],gyroRawData[5]);\n  gyroRawDataY = (int)gyroRaw.y;\n  gyroRawDataZ = (int)gyroRaw.z;\n  gyroConversionFactor = __floatsisf();\n  gyroConversionFactor = __aeabi_fmul(gyroConversionFactor,0x447a0000);\n  gyroConversionFactor = __aeabi_fmul(gyroConversionFactor,0x38000000);\n  gyroProcessedData.x = (float)__aeabi_fsub(gyroConversionFactor,gyroBiasData.x);\n  gyroConversionFactor = __floatsisf(gyroRawDataY);\n  gyroConversionFactor = __aeabi_fmul(gyroConversionFactor,0x447a0000);\n  gyroConversionFactor = __aeabi_fmul(gyroConversionFactor,0x38000000);\n  gyroProcessedData.y = (float)__aeabi_fsub(gyroConversionFactor,gyroBiasData.y);\n  gyroConversionFactor = __floatsisf(gyroRawDataZ);\n  gyroConversionFactor = __aeabi_fmul(gyroConversionFactor,0x447a0000);\n  gyroConversionFactor = __aeabi_fmul(gyroConversionFactor,0x38000000);\n  gyroProcessedData.z = (float)__aeabi_fsub(gyroConversionFactor,gyroBiasData.z);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002bf0": "read_and_process_gyro_data_08002bf0",
                "raw_data": "gyroRawData",
                "iVar2": "gyroRawDataZ",
                "iVar3": "gyroRawDataY",
                "uVar1": "gyroConversionFactor",
                "gyroData": "gyroProcessedData",
                "gyroBias": "gyroBiasData"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb0": {
            "entrypoint": "0x08002cb0",
            "current_name": "calibrate_magnetometer_08002cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calibrateMagnetometer_08002cb0(void)\n\n{\n  undefined4 scaledValue;\n  uint rawData;\n  uint8_t rawData [3];\n  \n  _rawData = rawData;\n  writeI2CByte(0xd0,0x37,'\\\"','\\x01');\n  writeI2CByte(0xd0,0x6a,'\\x01','\\x01');\n  readI2CByte(0x18,0,\"../Src/MPU9250.c\",0xad);\n  writeI2CByte(0x18,0xb,'\\x01','\\x01');\n  writeI2CByte(0x18,10,'\\0','\\x01');\n  writeI2CByte(0x18,10,'\\x0f','\\x01');\n  readI2CByteArray(0x18,0x10,rawData,3,\"../Src/MPU9250.c\",0xb6);\n  scaledValue = __floatsisf((_rawData & 0xff) - 0x80);\n  scaledValue = __aeabi_fmul(scaledValue,0x3b800000);\n  calibratedMagX = (float)__addsf3(scaledValue,0x3f800000);\n  scaledValue = __floatsisf((_rawData >> 8 & 0xff) - 0x80);\n  scaledValue = __aeabi_fmul(scaledValue,0x3b800000);\n  calibratedMagY = (float)__addsf3(scaledValue,0x3f800000);\n  scaledValue = __floatsisf(rawData[2] - 0x80);\n  scaledValue = __aeabi_fmul(scaledValue,0x3b800000);\n  calibratedMagZ = (float)__addsf3(scaledValue,0x3f800000);\n  writeI2CByte(0x18,10,'\\0','\\x01');\n  writeI2CByte(0x18,10,'\\x16','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cb0": "calibrate_magnetometer_08002cb0",
                "in_r3": "rawData",
                "uVar1": "scaledValue",
                "I2C_WriteByte": "writeI2CByte",
                "I2C_ReadByte": "readI2CByte",
                "I2C_ReadByteArray": "readI2CByteArray",
                "magCalib.x": "calibratedMagX",
                "magCalib.y": "calibratedMagY",
                "magCalib.z": "calibratedMagZ"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "__addsf3",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d88": {
            "entrypoint": "0x08002d88",
            "current_name": "process_mag_data_08002d88",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processMagData_08002d88(void)\n\n{\n  float mRes;\n  byte byteVal;\n  undefined4 floatingVar;\n  undefined4 inputParameter;\n  int magnitudeZ;\n  int magnitudeY;\n  int16_t magnitudeX;\n  undefined stackVar1;\n  undefined stackVar2;\n  undefined temp1;\n  undefined temp2;\n  uint8_t overflowFlag;\n  undefined stackFlag;\n  \n  stackFlag = (undefined)((uint)inputParameter >> 0x18);\n  magnitudeX = 0;\n  stackVar1 = 0;\n  stackVar2 = 0;\n  temp1 = 0;\n  temp2 = 0;\n  overflowFlag = '\\0';\n  byteVal = I2C_ReadByte(0x18,2,\"../Src/MPU9250.c\",0xd7);\n  if ((int)((uint)byteVal << 0x1f) < 0) {\n    I2C_ReadByteArray(0x18,3,(uint8_t *)&magnitudeX,7,\"../Src/MPU9250.c\",0xda);\n    mRes = mRes;\n    if ((int)((uint)overflowFlag << 0x1c) < 0) {\n      statusStruct.i2c_errors_count = statusStruct.i2c_errors_count + 1;\n    }\n    else {\n      rawMagnetometerData.y = CONCAT11(stackVar2,stackVar1);\n      rawMagnetometerData.z = CONCAT11(temp2,temp1);\n      magnitudeY = (int)rawMagnetometerData.y;\n      magnitudeZ = (int)rawMagnetometerData.z;\n      rawMagnetometerData.x = magnitudeX;\n      floatingVar = __floatsisf();\n      floatingVar = __aeabi_fmul(floatingVar,mRes);\n      floatingVar = __aeabi_fmul(floatingVar,magnetometerCalibration.x);\n      floatingVar = __aeabi_fsub(floatingVar,magnetometerBias.x);\n      processedMagnetometerData.x = (float)__aeabi_fmul(floatingVar,magnetometerScale.x);\n      floatingVar = __floatsisf(magnitudeY);\n      floatingVar = __aeabi_fmul(floatingVar,mRes);\n      floatingVar = __aeabi_fmul(floatingVar,magnetometerCalibration.y);\n      floatingVar = __aeabi_fsub(floatingVar,magnetometerBias.y);\n      processedMagnetometerData.y = (float)__aeabi_fmul(floatingVar,magnetometerScale.y);\n      floatingVar = __floatsisf(magnitudeZ);\n      floatingVar = __aeabi_fmul(floatingVar,mRes);\n      floatingVar = __aeabi_fmul(floatingVar,magnetometerCalibration.z);\n      floatingVar = __aeabi_fsub(floatingVar,magnetometerBias.z);\n      processedMagnetometerData.z = (float)__aeabi_fmul(floatingVar,magnetometerScale.z);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d88": "process_mag_data_08002d88",
                "in_r3": "inputParameter",
                "iVar4": "magnitudeZ",
                "iVar5": "magnitudeY",
                "local_24": "temp1",
                "local_23": "temp2",
                "local_28": "magnitudeX",
                "OVF": "overflowFlag",
                "uStack_26": "stackVar1",
                "uStack_25": "stackVar2",
                "uStack_21": "stackFlag",
                "fVar1": "mRes",
                "bVar2": "byteVal",
                "uVar3": "floatingVar",
                "magRaw": "rawMagnetometerData",
                "magData": "processedMagnetometerData",
                "magCalib": "magnetometerCalibration",
                "magBias": "magnetometerBias",
                "magScale": "magnetometerScale",
                "msp_txf_status": "statusStruct"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "I2C_ReadByte",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ea0": {
            "entrypoint": "0x08002ea0",
            "current_name": "initialize_sensor_system_08002ea0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSensorSystem_08002ea0(void)\n\n{\n  initializeMPU9250();\n  initializeAK8963();\n  setMadgwickBeta(0.6);\n  setMadgwickDelta(0.0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ea0": "initialize_sensor_system_08002ea0",
                "MPU9250_Init": "initializeMPU9250",
                "AK8963_Init": "initializeAK8963",
                "MadgwickSetBeta": "setMadgwickBeta",
                "MadgwickSetDelta": "setMadgwickDelta"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "MPU9250_Init",
                "AK8963_Init",
                "MadgwickSetDelta",
                "MadgwickSetBeta"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec0": {
            "entrypoint": "0x08002ec0",
            "current_name": "get_filtered_pitch_angle_08002ec0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat getFilteredPitchAngle_08002ec0(void)\n\n{\n  float fVar1;\n  \n  fVar1 = lowPassFilter(&filter,angleData[1]);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ec0": "get_filtered_pitch_angle_08002ec0",
                "lpf_pitch": "filter",
                "AHRS_Angle": "angleData"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed4": {
            "entrypoint": "0x08002ed4",
            "current_name": "apply_low_pass_filter_08002ed4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat applyLowPassFilter_08002ed4(void)\n\n{\n  float fVar1;\n  \n  fVar1 = calculateFilteredValue(&lowPassFilterRoll,sensorAngles[0]);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ed4": "apply_low_pass_filter_08002ed4",
                "lowPassFilter": "calculateFilteredValue",
                "lpf_roll": "lowPassFilterRoll",
                "AHRS_Angle": "sensorAngles"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ee8": {
            "entrypoint": "0x08002ee8",
            "current_name": "calculate_angle_offset_08002ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateAngleOffset_08002ee8(void)\n\n{\n  int isAngleGreaterThanOrLessThan;\n  float currentAngle;\n  float offset;\n  \n  offset = AHRS_Angle[2];\n  isAngleGreaterThanOrLessThan = isGreaterThanOrEqualTo(AHRS_Angle[2],0xc3340000);\n  if ((isAngleGreaterThanOrLessThan != 0) && (isAngleGreaterThanOrLessThan = isLessThan(offset,0x42b40000), isAngleGreaterThanOrLessThan != 0)) {\n    offset = (float)floatAddition(offset,0x42b40000);\n    return offset;\n  }\n  offset = (float)floatSubtraction(offset,0x43870000);\n  return offset;\n}\n\n",
            "renaming": {
                "FUN_08002ee8": "calculate_angle_offset_08002ee8",
                "angle": "currentAngle",
                "fVar2": "offset",
                "iVar1": "isAngleGreaterThanOrLessThan",
                "__addsf3": "floatAddition",
                "__aeabi_fcmpge": "isGreaterThanOrEqualTo",
                "__aeabi_fcmplt": "isLessThan",
                "__aeabi_fsub": "floatSubtraction"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fcmpge",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f28": {
            "entrypoint": "0x08002f28",
            "current_name": "update_ahrs_data_08002f28",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAHRSData_08002f28(void)\n\n{\n  undefined4 timeElapsed;\n  float timeDelta;\n  \n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n  AHRS_timeNow = micros();\n  timeElapsed = __floatunsisf(AHRS_timeNow - AHRS_lastUpdate);\n  timeDelta = (float)__aeabi_fdiv(timeElapsed,0x447a0000);\n  MadgwickSetDelta(timeDelta);\n  AHRS_lastUpdate = AHRS_timeNow;\n  MadgwickQuaternionUpdate\n            ((float)((int)accelerationData.y + -0x80000000),(float)((int)accelerationData.x + -0x80000000),\n             accelerationData.z,gyroData.y,gyroData.x,(float)((int)gyroData.z + -0x80000000),magnetometerData.x,\n             magnetometerData.y,magnetometerData.z,angleAHRS);\n  transmitRawIMU.accx = (int16_t)((uint)(int)rawAcceleration.x / 100);\n  transmitRawIMU.accz = (int16_t)((uint)(int)rawAcceleration.z / 100);\n  transmitRawIMU.accy = (int16_t)((uint)(int)rawAcceleration.y / 100);\n  transmitRawIMU.gyrx = rawGyro.x;\n  transmitRawIMU.gyry = rawGyro.y;\n  transmitRawIMU.gyrz = rawGyro.z;\n  transmitRawIMU.magx = rawMagnetometer.x;\n  transmitRawIMU.magy = rawMagnetometer.y;\n  transmitRawIMU.magz = rawMagnetometer.z;\n  AHRS_GetRoll();\n  __aeabi_fmul();\n  transmitAttitude.angx = __aeabi_f2iz();\n  AHRS_GetPitch();\n  __aeabi_fmul();\n  transmitAttitude.angy = __aeabi_f2iz();\n  AHRS_GetYaw();\n  transmitAttitude.heading = __aeabi_f2iz();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f28": "update_ahrs_data_08002f28",
                "_deltat": "timeDelta",
                "uVar1": "timeElapsed",
                "accelData": "accelerationData",
                "magData": "magnetometerData",
                "AHRS_Angle": "angleAHRS",
                "msp_txf_raw_imu": "transmitRawIMU",
                "accelRaw": "rawAcceleration",
                "gyroRaw": "rawGyro",
                "magRaw": "rawMagnetometer",
                "msp_txf_attitude": "transmitAttitude"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__aeabi_fmul",
                "MPU9250_ReadAccelData",
                "micros",
                "MPU9250_ReadGyroData",
                "AHRS_GetRoll",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AK8963_ReadData",
                "AHRS_GetYaw",
                "MadgwickSetDelta",
                "__floatunsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003034": {
            "entrypoint": "0x08003034",
            "current_name": "read_and_concatenate_bytes_08003034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readAndConcatenateBytes_08003034(void)\n\n{\n  undefined4 input_register;\n  uint8_t received_bytes [3];\n  \n  _received_bytes = input_register;\n  I2C_ReadBytes(0xee,0,received_bytes,3,\"../Src/MS5611.c\",0x8c);\n  return (uint)CONCAT12(received_bytes[0],CONCAT11(received_bytes[1],received_bytes[2]));\n}\n\n",
            "renaming": {
                "FUN_08003034": "read_and_concatenate_bytes_08003034",
                "in_r3": "input_register",
                "rxbuf": "received_bytes"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "I2C_ReadBytes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003068": {
            "entrypoint": "0x08003068",
            "current_name": "get_input_float_08003068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat get_input_float_08003068(void)\n\n{\n  float input_value;\n  \n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08003068": "get_input_float_08003068",
                "in_s0": "input_value"
            },
            "calling": [
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003078": {
            "entrypoint": "0x08003078",
            "current_name": "FUNC_08003078",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003078(void)\n\n{\n  float *pfVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined4 uVar6;\n  float fVar7;\n  uint32_t uVar8;\n  undefined4 extraout_r1;\n  uint uVar9;\n  undefined4 unaff_r4;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  float *pfVar13;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  int iVar14;\n  int32_t TEMP;\n  int iVar15;\n  int iVar16;\n  int32_t dT;\n  bool bVar17;\n  undefined8 uVar18;\n  \n  if ((TEMP_READY != '\\0') && (PRESSURE_READY != '\\0')) {\n    iVar16 = MS5611_RawTemperature + (uint)MS5611_Coefficients[5] * -0x100;\n    uVar9 = (uint)((longlong)(int)(uint)MS5611_Coefficients[6] * (longlong)iVar16) >> 0x17 |\n            (int)((ulonglong)((longlong)(int)(uint)MS5611_Coefficients[6] * (longlong)iVar16) >>\n                 0x20) << 9;\n    uVar10 = (uint)((longlong)(int)(uint)MS5611_Coefficients[4] * (longlong)iVar16 >> 7);\n    uVar11 = uVar10 + (uint)MS5611_Coefficients[2] * 0x10000;\n    uVar4 = (uint)((ulonglong)((longlong)(int)(uint)MS5611_Coefficients[3] * (longlong)iVar16) >> 8)\n    ;\n    iVar14 = uVar9 + 2000;\n    uVar5 = uVar4 + (uint)MS5611_Coefficients[1] * 0x8000;\n    bVar17 = (int)uVar9 < 0;\n    if (1999 < iVar14) {\n      uVar9 = 0;\n    }\n    uVar3 = uVar9;\n    if (bVar17 != SBORROW4(iVar14,2000)) {\n      iVar15 = uVar9 * uVar9 * 5;\n      uVar9 = iVar15 >> 2;\n      uVar3 = iVar15 >> 1;\n    }\n    uVar12 = uVar11 - uVar3;\n    lVar2 = (ulonglong)(uVar5 - uVar9) * (ulonglong)MS5611_RawPressure;\n    iVar15 = MS5611_RawPressure *\n             ((((int)((longlong)(int)(uint)MS5611_Coefficients[3] * (longlong)iVar16 >> 0x28) +\n               (uint)CARRY4(uVar4,(uint)MS5611_Coefficients[1] * 0x8000)) - ((int)uVar9 >> 0x1f)) -\n             (uint)(uVar5 < uVar9)) + (int)((ulonglong)lVar2 >> 0x20);\n    uVar4 = (uint)lVar2 >> 0x15 | iVar15 * 0x800;\n    uVar6 = __floatsisf(uVar4 - uVar12 >> 0xf |\n                        (((iVar15 >> 0x15) -\n                         ((((int)((longlong)(int)(uint)MS5611_Coefficients[4] * (longlong)iVar16 >>\n                                 0x27) + (uint)CARRY4(uVar10,(uint)MS5611_Coefficients[2] * 0x10000)\n                           ) - ((int)uVar3 >> 0x1f)) - (uint)(uVar11 < uVar3))) -\n                        (uint)(uVar4 < uVar12)) * 0x20000);\n    fVar7 = (float)__aeabi_fdiv(uVar6,0x42c80000);\n    MS5611_CompensatedPressure = fVar7;\n    uVar6 = __floatsisf(iVar14);\n    MS5611_CompensatedTemperature = (float)__aeabi_fdiv(uVar6,0x42c80000);\n    __aeabi_fdiv(fVar7,0x447d5000);\n    uVar6 = __aeabi_f2d();\n    pow((double)CONCAT44(unaff_r5,unaff_r4),(double)CONCAT44(unaff_r7,unaff_r6));\n    uVar18 = __subdf3(0,0x3ff00000,uVar6,extraout_r1);\n    __muldf3((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),0,0x40e5a540);\n    fVar7 = (float)__truncdfsf2();\n    uVar6 = 0;\n    pfVar13 = alt_filter;\n    MS5611_Altitude = fVar7;\n    do {\n      pfVar1 = pfVar13 + 1;\n      *pfVar13 = *pfVar1;\n      uVar6 = __addsf3(uVar6);\n      pfVar13 = pfVar1;\n    } while (pfVar1 != alt_filter + 0x13);\n    alt_filter[19] = fVar7;\n    uVar6 = __addsf3(uVar6,fVar7);\n    MS5611_FilteredAltitude = (float)__aeabi_fdiv(uVar6,0x41a00000);\n    iVar14 = __aeabi_f2iz();\n    msp_txf_altitude.est_alt = iVar14 * 100;\n    TEMP_READY = '\\0';\n    PRESSURE_READY = '\\0';\n    I2C_WriteByte(0xee,MS5611_OSR + 0x50,'\\x01','\\0');\n    temp_time = millis();\n  }\n  uVar8 = millis();\n  if (((10 < uVar8 - temp_time) && (TEMP_READY == '\\0')) && (PRESSURE_READY == '\\0')) {\n    MS5611_RawTemperature = MS5611_ReadADC();\n    TEMP_READY = '\\x01';\n    I2C_WriteByte(0xee,MS5611_OSR + 0x40,'\\x01','\\0');\n    pressure_time = millis();\n  }\n  uVar8 = millis();\n  if (((10 < uVar8 - pressure_time) && (TEMP_READY != '\\0')) && (PRESSURE_READY == '\\0')) {\n    MS5611_RawPressure = MS5611_ReadADC();\n    PRESSURE_READY = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003078": "FUNC_08003078"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2d",
                "pow",
                "__truncdfsf2",
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__addsf3",
                "__floatsisf",
                "__muldf3",
                "millis",
                "MS5611_ReadADC",
                "I2C_WriteByte",
                "__subdf3"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003298": {
            "entrypoint": "0x08003298",
            "current_name": "initialize_ms5611_sensor_08003298",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMS5611Sensor_08003298(void)\n\n{\n  int i;\n  int index;\n  uint8_t receiveBuffer [2];\n  \n  index = 0;\n  I2C_WriteByte(0xee,0x1e,'\\x01','\\x01');\n  delay_ms(10);\n  oversampleRate = '\\b';\n  do {\n    receiveBuffer[0] = '\\0';\n    receiveBuffer[1] = '\\0';\n    I2C_ReadByteArray(0xee,(short)index + 0xa0,receiveBuffer,2,\"../Src/MS5611.c\",0x7c);\n    *(ushort *)((int)coefficients + index) = CONCAT11(receiveBuffer[0],receiveBuffer[1]);\n    index = index + 2;\n  } while (index != 0x10);\n  index = 0;\n  do {\n    altitudeFilter[index] = 0.0;\n    index = index + 1;\n  } while (index != 0x14);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003298": "initialize_ms5611_sensor_08003298",
                "rxbuf": "receiveBuffer",
                "iVar1": "index",
                "MS5611_OSR": "oversampleRate",
                "MS5611_Coefficients": "coefficients",
                "alt_filter": "altitudeFilter"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "delay_ms",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003314": {
            "entrypoint": "0x08003314",
            "current_name": "set_beta_08003314",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setBeta_08003314(float newBeta)\n\n{\n  beta = newBeta;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "newBeta"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003320": {
            "entrypoint": "0x08003320",
            "current_name": "update_delta_time_08003320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDeltaTime_08003320(float newDeltaTime)\n\n{\n  deltaTime = newDeltaTime;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003320": "update_delta_time_08003320",
                "_deltat": "newDeltaTime",
                "deltat": "deltaTime"
            },
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003330": {
            "entrypoint": "0x08003330",
            "current_name": "calculate_quaternion_angles_08003330",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateQuaternionAngles_08003330(float accelerationX,float accelerationY,float accelerationZ,float gyroscopeX,float gyroscopeY,float gyroscopeZ,float magneticFieldX,float magneticFieldY,float magneticFieldZ,\n                 float *quaternionAngles)\n\n{\n  float temp1;\n  float temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  float norm;\n  undefined4 temp5;\n  int temp6;\n  undefined4 temp7;\n  undefined4 temp8;\n  undefined4 temp9;\n  int temp10;\n  undefined4 temp11;\n  undefined4 temp12;\n  undefined4 temp13;\n  undefined4 temp14;\n  undefined4 temp15;\n  undefined4 temp16;\n  undefined4 temp17;\n  undefined4 temp18;\n  undefined4 temp19;\n  undefined4 temp20;\n  int temp21;\n  float temp22;\n  undefined4 temp23;\n  float temp24;\n  undefined4 temp25;\n  float temp26;\n  undefined4 temp27;\n  float temp28;\n  undefined4 temp29;\n  undefined4 temp30;\n  undefined4 temp31;\n  int temp32;\n  float temp33;\n  float temp34;\n  float temp35;\n  float s1;\n  float s2;\n  float s3;\n  float s4;\n  float temp36;\n  float temp37;\n  float temp38;\n  float quaternion1;\n  float quaternion2;\n  float quaternion4;\n  float quaternion3;\n  undefined8 temp39;\n  undefined8 temp40;\n  undefined4 temp41;\n  float temp42;\n  float hy;\n  float hx;\n  \n  temp38 = q[3];\n  temp37 = q[2];\n  temp36 = q[0];\n  temp42 = q[1];\n  temp3 = __aeabi_fmul(accelerationX,accelerationX);\n  temp4 = __aeabi_fmul(accelerationY);\n  temp3 = __addsf3(temp3,temp4);\n  temp4 = __aeabi_fmul(accelerationZ);\n  __addsf3(temp3,temp4);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(temp42,temp41));\n  temp3 = __truncdfsf2();\n  norm = (float)__aeabi_fcmpeq(temp3,0);\n  if (norm == 0.0) {\n    temp4 = __aeabi_fmul(magneticFieldX);\n    temp5 = __aeabi_fmul(magneticFieldY);\n    temp4 = __addsf3(temp4,temp5);\n    temp5 = __aeabi_fmul(magneticFieldZ);\n    __addsf3(temp4,temp5);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(temp42,temp41));\n    temp4 = __truncdfsf2();\n    temp6 = __aeabi_fcmpeq(temp4,0);\n    if (temp6 == 0) {\n      temp39 = __aeabi_f2d(gyroscopeX);\n      __muldf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0xa2529d39,0x3f91df46);\n      temp5 = __truncdfsf2();\n      temp39 = __aeabi_f2d(gyroscopeY);\n      __muldf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0xa2529d39,0x3f91df46);\n      temp7 = __truncdfsf2();\n      temp39 = __aeabi_f2d(gyroscopeZ);\n      __muldf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0xa2529d39,0x3f91df46);\n      temp8 = __truncdfsf2();\n      temp6 = __addsf3(temp36);\n      temp9 = __addsf3(temp42);\n      temp10 = __addsf3(temp37,temp37);\n      temp11 = __addsf3(temp38,temp38);\n      temp12 = __aeabi_fmul(temp36);\n      temp13 = __aeabi_fmul(temp36,temp42);\n      temp14 = __aeabi_fmul(temp36,temp37);\n      temp15 = __aeabi_fmul(temp42);\n      temp16 = __aeabi_fmul(temp42,temp38);\n      temp17 = __aeabi_fmul(temp37,temp37);\n      temp18 = __aeabi_fmul(temp38,temp38);\n      temp3 = __aeabi_fdiv(0x3f800000,temp3);\n      temp4 = __aeabi_fdiv(0x3f800000,temp4);\n      temp19 = __aeabi_fmul(magneticFieldX,temp4);\n      temp20 = __aeabi_fmul(magneticFieldY,temp4);\n      temp4 = __aeabi_fmul(magneticFieldZ,temp4);\n      temp21 = __aeabi_fmul(temp6,temp19);\n      temp23 = __aeabi_fmul(temp6,temp20);\n      temp25 = __aeabi_fmul(temp6,temp4);\n      temp27 = __aeabi_fmul(temp9,temp19);\n      temp29 = __aeabi_fmul(temp12,temp19);\n      temp30 = __aeabi_fmul(temp38,temp23);\n      temp29 = __aeabi_fsub(temp29,temp30);\n      temp30 = __aeabi_fmul(temp37,temp25);\n      temp29 = __addsf3(temp29,temp30);\n      temp30 = __aeabi_fmul(temp15,temp19);\n      temp29 = __addsf3(temp29,temp30);\n      temp30 = __aeabi_fmul(temp9,temp20);\n      temp30 = __aeabi_fmul(temp30,temp37);\n      temp29 = __addsf3(temp29,temp30);\n      temp30 = __aeabi_fmul(temp9,temp4);\n      temp30 = __aeabi_fmul(temp30,temp38);\n      temp29 = __addsf3(temp29,temp30);\n      temp30 = __aeabi_fmul(temp17,temp19);\n      temp29 = __aeabi_fsub(temp29,temp30);\n      temp30 = __aeabi_fmul(temp18,temp19);\n      temp29 = __aeabi_fsub(temp29,temp30);\n      temp30 = __aeabi_fmul(temp38,temp21);\n      temp31 = __aeabi_fmul(temp12,temp20);\n      temp30 = __addsf3(temp30,temp31);\n      temp25 = __aeabi_fmul(temp42,temp25);\n      temp25 = __aeabi_fsub(temp30,temp25);\n      temp30 = __aeabi_fmul(temp37,temp27);\n      temp25 = __addsf3(temp25,temp30);\n      temp30 = __aeabi_fmul(temp15,temp20);\n      temp25 = __aeabi_fsub(temp25,temp30);\n      temp30 = __aeabi_fmul(temp17,temp20);\n      temp25 = __addsf3(temp25,temp30);\n      temp30 = __aeabi_fmul(temp10,temp4);\n      temp30 = __aeabi_fmul(temp30,temp38);\n      temp25 = __addsf3(temp25,temp30);\n      temp30 = __aeabi_fmul(temp18,temp20);\n      temp25 = __aeabi_fsub(temp25,temp30);\n      temp29 = __aeabi_fmul(temp29,temp29);\n      temp25 = __aeabi_fmul(temp25,temp25);\n      __addsf3(temp29,temp25);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(temp42,temp41));\n      temp32 = __truncdfsf2();\n      temp25 = __aeabi_fmul(temp21 + -0x80000000,temp37);\n      temp23 = __aeabi_fmul(temp42,temp23);\n      temp23 = __addsf3(temp25,temp23);\n      temp12 = __aeabi_fmul(temp12,temp4);\n      temp12 = __addsf3(temp23,temp12);\n      temp23 = __aeabi_fmul(temp38,temp27);\n      temp12 = __addsf3(temp12,temp23);\n      temp23 = __aeabi_fmul(temp15,temp4);\n      temp12 = __aeabi_fsub(temp12,temp23);\n      temp23 = __aeabi_fmul(temp10,temp20);\n      temp23 = __aeabi_fmul(temp23,temp38);\n      temp12 = __addsf3(temp12,temp23);\n      temp23 = __aeabi_fmul(temp17,temp4);\n      temp12 = __aeabi_fsub(temp12,temp23);\n      temp23 = __aeabi_fmul(temp18,temp4);\n      temp12 = __addsf3(temp12,temp23);\n      temp34 = (float)__addsf3(temp12,temp12);\n      temp23 = __addsf3(temp16);\n      temp25 = __aeabi_fmul(temp37,temp6);\n      temp23 = __aeabi_fsub(temp23,temp25);\n      temp25 = __aeabi_fmul(accelerationX,temp3);\n      temp23 = __aeabi_fsub(temp23,temp25);\n      temp25 = __aeabi_fmul(temp38,temp10);\n      temp27 = __addsf3(temp13);\n      temp25 = __addsf3(temp25,temp27);\n      temp27 = __aeabi_fmul(accelerationY,temp3);\n      temp25 = __aeabi_fsub(temp25,temp27);\n      temp27 = __aeabi_fmul(temp37,temp12);\n      temp29 = __aeabi_fsub(0x3f000000,temp17);\n      temp18 = __aeabi_fsub(temp29,temp18);\n      temp18 = __aeabi_fmul(temp18,temp32);\n      temp29 = __aeabi_fsub(temp16,temp14);\n      temp29 = __aeabi_fmul(temp29,temp12);\n      temp18 = __addsf3(temp18,temp29);\n      temp18 = __aeabi_fsub(temp18,temp19);\n      temp19 = __aeabi_fmul(temp42,temp12);\n      temp29 = __aeabi_fmul(temp42,temp37);\n      temp30 = __aeabi_fmul(temp36,temp38);\n      temp29 = __aeabi_fsub(temp29,temp30);\n      temp29 = __aeabi_fmul(temp29,temp32);\n      temp30 = __aeabi_fmul(temp37,temp38);\n      temp13 = __addsf3(temp30,temp13);\n      temp13 = __aeabi_fmul(temp13,temp12);\n      temp13 = __addsf3(temp29,temp13);\n      temp13 = __aeabi_fsub(temp13,temp20);\n      temp20 = __aeabi_fmul(temp37,temp32);\n      temp29 = __aeabi_fsub(0x3f000000,temp15);\n      temp29 = __aeabi_fsub(temp29,temp17);\n      temp29 = __aeabi_fmul(temp29,temp12);\n      temp14 = __addsf3(temp14,temp16);\n      temp14 = __aeabi_fmul(temp14,temp32);\n      temp14 = __addsf3(temp29,temp14);\n      temp4 = __aeabi_fsub(temp14,temp4);\n      temp14 = __aeabi_fmul(temp10 + -0x80000000,temp23);\n      temp16 = __aeabi_fmul(temp9,temp25);\n      temp14 = __addsf3(temp14,temp16);\n      temp16 = __aeabi_fmul(temp27,temp18);\n      temp14 = __aeabi_fsub(temp14,temp16);\n      temp16 = __aeabi_fmul(temp38,temp32 + -0x80000000);\n      temp16 = __addsf3(temp16,temp19);\n      temp16 = __aeabi_fmul(temp16,temp13);\n      temp14 = __addsf3(temp14,temp16);\n      temp16 = __aeabi_fmul(temp20,temp4);\n      temp14 = __addsf3(temp14,temp16);\n      temp15 = __addsf3(temp15);\n      temp15 = __aeabi_fsub(0x3f800000,temp15);\n      temp16 = __addsf3(temp17);\n      temp15 = __aeabi_fsub(temp15,temp16);\n      temp3 = __aeabi_fmul(accelerationZ,temp3);\n      temp3 = __aeabi_fsub(temp15,temp3);\n      temp15 = __aeabi_fmul(temp38,temp12);\n      temp12 = __aeabi_fmul(temp36,temp12);\n      temp16 = __aeabi_fmul(temp11,temp23);\n      temp17 = __aeabi_fmul(temp6,temp25);\n      temp16 = __addsf3(temp16,temp17);\n      temp17 = __aeabi_fmul(temp42,0x40800000);\n      temp17 = __aeabi_fmul(temp17,temp3);\n      temp16 = __aeabi_fsub(temp16,temp17);\n      temp17 = __aeabi_fmul(temp18,temp15);\n      temp16 = __addsf3(temp16,temp17);\n      temp17 = __addsf3(temp20,temp12);\n      temp17 = __aeabi_fmul(temp17,temp13);\n      temp16 = __addsf3(temp16,temp17);\n      temp17 = __aeabi_fmul(temp38,temp32);\n      temp20 = __aeabi_fmul(temp42,temp34);\n      temp17 = __aeabi_fsub(temp17,temp20);\n      temp17 = __aeabi_fmul(temp17,temp4);\n      temp16 = __addsf3(temp16,temp17);\n      temp21 = __addsf3(temp32,temp32);\n      temp17 = __aeabi_fmul(temp42,temp32);\n      temp20 = __aeabi_fmul(temp6 + -0x80000000,temp23);\n      temp11 = __aeabi_fmul(temp11,temp25);\n      temp11 = __addsf3(temp20,temp11);\n      temp20 = __aeabi_fmul(temp37,0x40800000);\n      temp3 = __aeabi_fmul(temp20,temp3);\n      temp3 = __aeabi_fsub(temp11,temp3);\n      temp11 = __aeabi_fmul(temp37,temp21 + -0x80000000);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp11 = __aeabi_fmul(temp11,temp18);\n      temp3 = __addsf3(temp3,temp11);\n      temp11 = __addsf3(temp15,temp17);\n      temp11 = __aeabi_fmul(temp11,temp13);\n      temp3 = __addsf3(temp3,temp11);\n      temp11 = __aeabi_fmul(temp36,temp32);\n      temp12 = __aeabi_fmul(temp37,temp34);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp11 = __aeabi_fmul(temp11,temp4);\n      temp3 = __addsf3(temp3,temp11);\n      temp9 = __aeabi_fmul(temp9,temp23);\n      temp11 = __aeabi_fmul(temp10,temp25);\n      temp9 = __addsf3(temp9,temp11);\n      temp11 = __aeabi_fmul(temp38,temp21 + -0x80000000);\n      temp11 = __addsf3(temp11,temp19);\n      temp11 = __aeabi_fmul(temp11,temp18);\n      temp9 = __addsf3(temp9,temp11);\n      temp11 = __aeabi_fmul(temp36,temp32 + -0x80000000);\n      temp11 = __addsf3(temp11,temp27);\n      temp11 = __aeabi_fmul(temp11,temp13);\n      temp9 = __addsf3(temp9,temp11);\n      temp4 = __aeabi_fmul(temp4,temp17);\n      temp4 = __addsf3(temp9,temp4);\n      temp9 = __aeabi_fmul(temp14);\n      temp11 = __aeabi_fmul(temp16);\n      temp9 = __addsf3(temp9,temp11);\n      temp11 = __aeabi_fmul(temp3,temp3);\n      temp9 = __addsf3(temp9,temp11);\n      temp11 = __aeabi_fmul(temp4,temp4);\n      __addsf3(temp9,temp11);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(temp42,temp41));\n      temp9 = __truncdfsf2();\n      temp9 = __aeabi_fdiv(0x3f800000,temp9);\n      temp1 = beta;\n      temp11 = __aeabi_fmul((int)temp42 + -0x80000000,temp5);\n      temp12 = __aeabi_fmul(temp37,temp7);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp12 = __aeabi_fmul(temp38,temp8);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp11 = __aeabi_fmul(temp11,0x3f000000);\n      temp12 = __aeabi_fmul(temp14,temp9);\n      temp2 = deltat;\n      temp12 = __aeabi_fmul(temp12,temp1);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp11 = __aeabi_fmul(temp11,temp2);\n      temp11 = __addsf3(temp11,temp36);\n      temp12 = __aeabi_fmul(temp36,temp5);\n      temp13 = __aeabi_fmul(temp37,temp8);\n      temp2 = deltat;\n      temp12 = __addsf3(temp12,temp13);\n      temp13 = __aeabi_fmul(temp38,temp7);\n      temp12 = __aeabi_fsub(temp12,temp13);\n      temp12 = __aeabi_fmul(temp12,0x3f000000);\n      temp13 = __aeabi_fmul(temp16,temp9);\n      temp13 = __aeabi_fmul(temp13,temp1);\n      temp12 = __aeabi_fsub(temp12,temp13);\n      temp12 = __aeabi_fmul(temp12,temp2);\n      temp12 = __addsf3(temp12,temp42);\n      temp2 = deltat;\n      temp13 = __aeabi_fmul(temp36,temp7);\n      temp14 = __aeabi_fmul(temp42,temp8);\n      temp13 = __aeabi_fsub(temp13,temp14);\n      temp14 = __aeabi_fmul(temp38,temp5);\n      temp13 = __addsf3(temp13,temp14);\n      temp13 = __aeabi_fmul(temp13,0x3f000000);\n      temp3 = __aeabi_fmul(temp3,temp9);\n      temp3 = __aeabi_fmul(temp3,temp1);\n      temp3 = __aeabi_fsub(temp13,temp3);\n      temp3 = __aeabi_fmul(temp3,temp2);\n      temp3 = __addsf3(temp3,temp37);\n      temp8 = __aeabi_fmul(temp36,temp8);\n      temp7 = __aeabi_fmul(temp42,temp7);\n      temp7 = __addsf3(temp8,temp7);\n      temp5 = __aeabi_fmul(temp37,temp5);\n      temp5 = __aeabi_fsub(temp7,temp5);\n      temp5 = __aeabi_fmul(temp5,0x3f000000);\n      temp4 = __aeabi_fmul(temp4,temp9);\n      temp4 = __aeabi_fmul(temp4,temp1);\n      temp36 = deltat;\n      temp4 = __aeabi_fsub(temp5,temp4);\n      temp4 = __aeabi_fmul(temp4,temp36);\n      temp4 = __addsf3(temp4,temp38);\n      temp5 = __aeabi_fmul(temp11,temp11);\n      temp8 = __aeabi_fmul(temp12,temp12);\n      temp5 = __addsf3(temp5,temp8);\n      temp8 = __aeabi_fmul(temp3,temp3);\n      temp5 = __addsf3(temp5,temp8);\n      temp8 = __aeabi_fmul(temp4,temp4);\n      __addsf3(temp5,temp8);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(temp7,temp41));\n      temp5 = __truncdfsf2();\n      temp5 = __aeabi_fdiv(0x3f800000,temp5);\n      temp36 = (float)__aeabi_fmul(temp11,temp5);\n      q[0] = temp36;\n      temp37 = (float)__aeabi_fmul(temp12,temp5);\n      q[1] = temp37;\n      temp38 = (float)__aeabi_fmul(temp3,temp5);\n      q[2] = temp38;\n      q[3] = (float)__aeabi_fmul(temp4,temp5);\n      temp3 = __aeabi_fmul(temp37,q[3]);\n      temp4 = __aeabi_fmul(temp36,temp38);\n      temp3 = __aeabi_fsub(temp3,temp4);\n      __addsf3(temp3,temp3);\n      __aeabi_f2d();\n      asin((double)CONCAT44(temp7,temp41));\n      temp39 = __muldf3();\n      __divdf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0x54442d18,0x400921fb);\n      temp36 = (float)__truncdfsf2();\n      *quaternionAngles = temp36;\n      temp37 = q[1];\n      temp36 = q[0];\n      temp3 = __aeabi_fmul(q[0],q[0]);\n      temp4 = __aeabi_fmul(temp37,temp37);\n      temp3 = __aeabi_fsub(temp3,temp4);\n      temp38 = q[2];\n      temp4 = __aeabi_fmul(q[2],q[2]);\n      temp3 = __aeabi_fsub(temp3,temp4);\n      temp42 = q[3];\n      temp4 = __aeabi_fmul(q[3],q[3]);\n      __addsf3(temp3,temp4);\n      temp39 = __aeabi_f2d();\n      temp3 = __aeabi_fmul(temp36,temp37);\n      temp4 = __aeabi_fmul(temp38,temp42);\n      temp3 = __addsf3(temp3,temp4);\n      __addsf3(temp3,temp3);\n      temp40 = __aeabi_f2d();\n      temp39 = atan2((int)temp40,(int)((ulonglong)temp40 >> 0x20),(int)temp39,\n                     (int)((ulonglong)temp39 >> 0x20));\n      temp39 = __muldf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0,0x40668000);\n      __divdf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0x54442d18,0x400921fb);\n      temp36 = (float)__truncdfsf2();\n      quaternionAngles[1] = temp36;\n      temp37 = q[1];\n      temp36 = q[0];\n      temp3 = __aeabi_fmul(q[0],q[0]);\n      temp4 = __aeabi_fmul(temp37,temp37);\n      temp3 = __addsf3(temp3,temp4);\n      temp38 = q[2];\n      temp4 = __aeabi_fmul(q[2],q[2]);\n      temp3 = __aeabi_fsub(temp3,temp4);\n      temp42 = q[3];\n      temp4 = __aeabi_fmul(q[3],q[3]);\n      __aeabi_fsub(temp3,temp4);\n      temp39 = __aeabi_f2d();\n      temp3 = __aeabi_fmul(temp37,temp38);\n      temp4 = __aeabi_fmul(temp36,temp42);\n      temp3 = __addsf3(temp3,temp4);\n      __addsf3(temp3,temp3);\n      temp40 = __aeabi_f2d();\n      temp39 = atan2((int)temp40,(int)((ulonglong)temp40 >> 0x20),(int)temp39,\n                     (int)((ulonglong)temp39 >> 0x20));\n      temp39 = __muldf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0,0x40668000);\n      __divdf3((int)temp39,(int)((ulonglong)temp39 >> 0x20),0x54442d18,0x400921fb);\n      temp36 = (float)__truncdfsf2();\n      quaternionAngles[2] = temp36;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003330": "calculate_quaternion_angles_08003330",
                "ax": "accelerationX",
                "ay": "accelerationY",
                "az": "accelerationZ",
                "gx": "gyroscopeX",
                "gy": "gyroscopeY",
                "gz": "gyroscopeZ",
                "mx": "magneticFieldX",
                "my": "magneticFieldY",
                "mz": "magneticFieldZ",
                "angle": "quaternionAngles",
                "fVar1": "temp1",
                "fVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "iVar6": "temp6",
                "uVar7": "temp7",
                "uVar8": "temp8",
                "uVar9": "temp9",
                "iVar10": "temp10",
                "uVar11": "temp11",
                "uVar12": "temp12",
                "uVar13": "temp13",
                "uVar14": "temp14",
                "uVar15": "temp15",
                "uVar16": "temp16",
                "uVar17": "temp17",
                "uVar18": "temp18",
                "uVar19": "temp19",
                "uVar20": "temp20",
                "iVar21": "temp21",
                "_2q1mx": "temp22",
                "uVar22": "temp23",
                "_2q1my": "temp24",
                "uVar23": "temp25",
                "_2q1mz": "temp26",
                "uVar24": "temp27",
                "_2q2mx": "temp28",
                "uVar25": "temp29",
                "uVar26": "temp30",
                "uVar27": "temp31",
                "iVar28": "temp32",
                "_2bx": "temp33",
                "_2bz": "temp34",
                "_4bz": "temp35",
                "fVar29": "temp36",
                "fVar30": "temp37",
                "fVar31": "temp38",
                "q1": "quaternion1",
                "q2": "quaternion2",
                "q4": "quaternion4",
                "q3": "quaternion3",
                "uVar32": "temp39",
                "uVar33": "temp40",
                "in_stack_ffffff78": "temp41",
                "fVar34": "temp42"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fdiv",
                "__aeabi_fcmpeq",
                "__addsf3",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_fmul",
                "atan2",
                "sqrt",
                "__divdf3",
                "asin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "execute_software_interrupt_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_08003eac(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "execute_software_interrupt_08003eac"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eb0": {
            "entrypoint": "0x08003eb0",
            "current_name": "afl_call_if_no_hyper_call_08003eb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint aflCallIfNoHyperCall_08003eb0(int ticks)\n\n{\n  uint32_t result;\n  \n  if (noHyperCall == 0) {\n    result = aflCall(1,ticks,0);\n    return result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003eb0": "afl_call_if_no_hyper_call_08003eb0",
                "uVar1": "result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ec8": {
            "entrypoint": "0x08003ec8",
            "current_name": "append_to_circular_buffer_08003ec8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint appendToCircularBuffer_08003ec8(CircularBuffer *cb,uint8_t newData)\n\n{\n  cb->bufferSize = cb->bufferSize + 1;\n  cb->buffer[cb->tailIndex] = newData;\n  cb->tailIndex = cb->tailIndex + 1 & 0x7ff;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003ec8": "append_to_circular_buffer_08003ec8",
                "data": "newData",
                "size": "bufferSize",
                "tail": "tailIndex"
            },
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ef2": {
            "entrypoint": "0x08003ef2",
            "current_name": "initialize_circular_buffer_08003ef2",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeCircularBuffer_08003ef2(CindexrcularBuffer *cb)\n\n{\n  indexnt index;\n  \n  index = 0;\n  cb->head = 0;\n  cb->taindexl = 0;\n  cb->sindexze = 0;\n  do {\n    cb->buffer[index] = '\\0';\n    index = index + 1;\n  } whindexle (index != 0x800);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ef2": "initialize_circular_buffer_08003ef2",
                "i": "index"
            },
            "calling": [
                "serialFlush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0e": {
            "entrypoint": "0x08003f0e",
            "current_name": "calculate_weighted_average_08003f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateWeightedAverage_08003f0e(LPF *inputData,float currentValue)\n\n{\n  undefined4 difference;\n  undefined4 product;\n  float betaValue;\n  float result;\n  \n  betaValue = inputData->beta;\n  difference = __aeabi_fsub(0x3f800000,betaValue);\n  difference = __aeabi_fmul(difference,currentValue);\n  product = __aeabi_fmul(betaValue,inputData->last);\n  betaValue = (float)__addsf3(product,difference);\n  inputData->last = betaValue;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003f0e": "calculate_weighted_average_08003f0e",
                "var": "inputData",
                "current": "currentValue",
                "uVar1": "difference",
                "uVar2": "product",
                "fVar3": "betaValue",
                "extraout_s0": "result"
            },
            "calling": [
                "AHRS_GetRoll",
                "AHRS_GetPitch"
            ],
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f3c": {
            "entrypoint": "0x08003f3c",
            "current_name": "set_led_state_08003f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_LED_state_08003f3c(int is_white_LED_on,int is_red_LED_on,int is_blue_LED_on)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,is_white_LED_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,is_red_LED_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,is_blue_LED_on == 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f3c": "set_led_state_08003f3c",
                "led_white": "is_white_LED_on",
                "led_red": "is_red_LED_on",
                "led_blue": "is_blue_LED_on"
            },
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f7c": {
            "entrypoint": "0x08003f7c",
            "current_name": "blink_led_08003f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid blinkLED_08003f7c(void)\n\n{\n  int loopCount;\n  \n  loopCount = 3;\n  do {\n    toggleLED(1,0,0);\n    delay_ms(100);\n    toggleLED(0,1,0);\n    delay_ms(100);\n    toggleLED(0,0,1);\n    delay_ms(100);\n    loopCount = loopCount + -1;\n  } while (loopCount != 0);\n  toggleLED(1,1,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f7c": "blink_led_08003f7c",
                "iVar1": "loopCount"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fc4": {
            "entrypoint": "0x08003fc4",
            "current_name": "update_pwm_08003fc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePWM_08003fc4(int newPwmValue)\n\n{\n  (timer4.Instance)->CCR4 = newPwmValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fc4": "update_pwm_08003fc4",
                "pwm": "newPwmValue",
                "htim4": "timer4"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd0": {
            "entrypoint": "0x08003fd0",
            "current_name": "set_pwm_value_08003fd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_PWM_value_08003fd0(int new_PWM_value)\n\n{\n  (htim4.Instance)->CCR3 = new_PWM_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd0": "set_pwm_value_08003fd0",
                "pwm": "new_PWM_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fdc": {
            "entrypoint": "0x08003fdc",
            "current_name": "set_pwm_value_08003fdc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_value_08003fdc(int pwm_value)\n\n{\n  (timer_instance.Instance)->CCR2 = pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fdc": "set_pwm_value_08003fdc",
                "pwm": "pwm_value",
                "htim2": "timer_instance"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fe8": {
            "entrypoint": "0x08003fe8",
            "current_name": "set_pwm_08003fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_08003fe8(int new_pwm_value)\n\n{\n  (htim3.Instance)->CCR3 = new_pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fe8": "set_pwm_08003fe8",
                "pwm": "new_pwm_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff4": {
            "entrypoint": "0x08003ff4",
            "current_name": "start_pwm_08003ff4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid start_pwm_08003ff4(void)\n\n{\n  HAL_TIM_PWM_Start(timer2,4);\n  HAL_TIM_PWM_Start(timer3,8);\n  HAL_TIM_PWM_Start(timer4,8);\n  HAL_TIM_PWM_Start(timer4,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff4": "start_pwm_08003ff4",
                "&htim2": "timer2",
                "&htim3": "timer3",
                "&htim4": "timer4"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004028": {
            "entrypoint": "0x08004028",
            "current_name": "initialize_peripherals_and_pwm_08004028",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripheralsAndPWM_08004028(void)\n\n{\n  initializePeripherals();\n  initializePWM();\n  performLEDStartupSequence();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004028": "initialize_peripherals_and_pwm_08004028",
                "Peripherals_Init": "initializePeripherals",
                "PWM_Init": "initializePWM",
                "LED_StartupSequence": "performLEDStartupSequence"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "Peripherals_Init",
                "LED_StartupSequence",
                "PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800403c": {
            "entrypoint": "0x0800403c",
            "current_name": "write_i2_c_register_0800403c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeI2CRegister_0800403c(uint16_t deviceAddress,uint16_t registerAddress,uint8_t registerValue,uint8_t useDelay)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  uint8_t byteData [1];\n  \n  byteData[0] = registerValue;\n  status = HAL_I2C_Mem_Write(&hi2c1,deviceAddress,registerAddress,1,byteData,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../Src/i2c.c\",0x1b);\n  }\n  if (useDelay != '\\0') {\n    delay_ms(0x32);\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_0800403c": "write_i2_c_register_0800403c",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "register_val": "registerValue",
                "delay_mode": "useDelay",
                "HVar1": "status",
                "ret": "returnValue",
                "byte": "byteData"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "MS5611_Init",
                "MS5611_Update"
            ],
            "called": [
                "delay_ms",
                "HAL_I2C_Mem_Write",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "read_i2_c_register_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t read_I2C_register_0800407c(uint16_t device_address,uint16_t register_address,char *source_file,int source_line)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t result;\n  uint8_t data [1];\n  \n  data[0] = '\\0';\n  status = HAL_I2C_Mem_Read(&hi2c1,device_address,register_address,1,data,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(source_file,source_line);\n  }\n  resulturn data[0];\n}\n\n",
            "renaming": {
                "FUN_0800407c": "read_i2_c_register_0800407c",
                "device_add": "device_address",
                "register_add": "register_address",
                "file": "source_file",
                "line": "source_line",
                "HVar1": "status",
                "ret": "result",
                "byte": "data"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b8": {
            "entrypoint": "0x080040b8",
            "current_name": "read_i2_c_memory_080040b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readI2CMemory_080040b8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *data,uint16_t dataSize,char *fileName,\n                 int lineNumber)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  \n  status = HAL_I2C_Mem_Read(&hi2c1,deviceAddress,registerAddress,1,data,dataSize,200);\n  if (status != HAL_OK) {\n    _Error_Handler(fileName,lineNumber);\n    returnValueurn;\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_080040b8": "read_i2_c_memory_080040b8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "bytes": "data",
                "size": "dataSize",
                "file": "fileName",
                "line": "lineNumber",
                "HVar1": "status",
                "ret": "returnValue"
            },
            "calling": [
                "MS5611_ReadADC"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "read_and_save_i2_c_data_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndSaveI2CData_080040e8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *dataArray,uint16_t dataSize,\n                 char *sourceFile,int sourceLine)\n\n{\n  uint8_t readByte;\n  int index;\n  uint8_t *pArray;\n  \n  pArray = dataArray + -1;\n  for (index = 0; index < (int)(uint)dataSize; index = index + 1) {\n    readByte = I2C_ReadByte(deviceAddress,registerAddress + (short)index,\"../Src/i2c.c\",0x4c);\n    pArray = pArray + 1;\n    *pArray = readByte;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "read_and_save_i2_c_data_080040e8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "byte_array": "dataArray",
                "size": "dataSize",
                "file": "sourceFile",
                "line": "sourceLine",
                "uVar1": "readByte",
                "iVar2": "index",
                "puVar3": "pArray"
            },
            "calling": [
                "AK8963_Init",
                "MS5611_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData"
            ],
            "called": [
                "I2C_ReadByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800411c": {
            "entrypoint": "0x0800411c",
            "current_name": "update_sensors_0800411c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateSensors_0800411c(void)\n\n{\n  uint32_t currentMillis;\n  \n  currentMillis = millis();\n  if (1 < currentMillis - previousTick1) {\n    previousTick1 = millis();\n    AHRS_ComputeAngles();\n  }\n  currentMillis = millis();\n  if (2 < currentMillis - previousTick3) {\n    previousTick3 = millis();\n    PID_Update();\n  }\n  currentMillis = millis();\n  if (3 < currentMillis - previousTick2) {\n    previousTick2 = millis();\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800411c": "update_sensors_0800411c",
                "uVar1": "currentMillis",
                "last_tick1": "previousTick1",
                "last_tick2": "previousTick2",
                "last_tick3": "previousTick3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "MSP_SendMotor",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendAltitude",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendPID",
                "millis",
                "MSP_SendIdent",
                "MS5611_Update",
                "MSP_SendRawIMU"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004194": {
            "entrypoint": "0x08004194",
            "current_name": "initialize_devices_08004194",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDevices_08004194(void)\n\n{\n  initializeDevices_08004194();\n  initializeSerialConnection();\n  initializeIMU();\n  initializeMS5611();\n  initializePID();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004194": "initialize_devices_08004194",
                "Devices_Init": "initializeDevices",
                "serialBegin": "initializeSerialConnection",
                "IMU_Init": "initializeIMU",
                "MS5611_Init": "initializeMS5611",
                "PID_Init": "initializePID"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PID_Init",
                "Devices_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ae": {
            "entrypoint": "0x080041ae",
            "current_name": "start_and_schedule_tasks_080041ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint start_and_schedule_tasks_080041ae(void)\n\n{\n  start_fork_server(0);\n  initialize_system();\n  do {\n    increment_tick();\n    run_task_scheduler();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080041ae": "start_and_schedule_tasks_080041ae",
                "startForkserver": "start_fork_server",
                "setup": "initialize_system",
                "HAL_IncTick": "increment_tick",
                "taskScheduler": "run_task_scheduler"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "taskScheduler",
                "HAL_IncTick",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041c4": {
            "entrypoint": "0x080041c4",
            "current_name": "stop_motors_080041c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopMotors_080041c4(void)\n\n{\n  setMotor1PWM(0);\n  setMotor2PWM(0);\n  setMotor3PWM(0);\n  setMotor4PWM(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041c4": "stop_motors_080041c4",
                "Motor1_SetPWM": "setMotor1PWM",
                "Motor2_SetPWM": "setMotor2PWM",
                "Motor3_SetPWM": "setMotor3PWM",
                "Motor4_SetPWM": "setMotor4PWM"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041e4": {
            "entrypoint": "0x080041e4",
            "current_name": "set_motor_pwm_080041e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_motor_pwm_080041e4(int motor_1_input,int motor_2_input,int motor_3_input,int motor_4_input)\n\n{\n  if (999 < motor_1_input) {\n    motor_1_input = 1000;\n  }\n  if (999 < motor_2_input) {\n    motor_2_input = 1000;\n  }\n  if (999 < motor_3_input) {\n    motor_3_input = 1000;\n  }\n  if (999 < motor_4_input) {\n    motor_4_input = 1000;\n  }\n  motor_pulse_width_modulation[2] = motor_3_input & ~(motor_3_input >> 0x1f);\n  motor_pulse_width_modulation[3] = motor_4_input & ~(motor_4_input >> 0x1f);\n  motor_pulse_width_modulation[1] = motor_2_input & ~(motor_2_input >> 0x1f);\n  motor_pulse_width_modulation[0] = motor_1_input & ~(motor_1_input >> 0x1f);\n  set_motor1_pwm(motor_pulse_width_modulation[0]);\n  set_motor2_pwm(motor_pulse_width_modulation[1]);\n  set_motor3_pwm(motor_pulse_width_modulation[2]);\n  set_motor4_pwm(motor_pulse_width_modulation[3]);\n  msp_transmit_motor_values.motor[0] = (short)motor_pulse_width_modulation[0] + 1000;\n  msp_transmit_motor_values.motor[1] = (short)motor_pulse_width_modulation[1] + 1000;\n  msp_transmit_motor_values.motor[2] = (short)motor_pulse_width_modulation[2] + 1000;\n  msp_transmit_motor_values.motor[3] = (short)motor_pulse_width_modulation[3] + 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041e4": "set_motor_pwm_080041e4",
                "m1": "motor_1_input",
                "m2": "motor_2_input",
                "m3": "motor_3_input",
                "m4": "motor_4_input",
                "motor_pwm": "motor_pulse_width_modulation",
                "Motor1_SetPWM": "set_motor1_pwm",
                "Motor2_SetPWM": "set_motor2_pwm",
                "Motor3_SetPWM": "set_motor3_pwm",
                "Motor4_SetPWM": "set_motor4_pwm",
                "msp_txf_motor": "msp_transmit_motor_values"
            },
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800426c": {
            "entrypoint": "0x0800426c",
            "current_name": "calculate_motor_speeds_0800426c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateMotorSpeeds_0800426c(float throttleInput,float pitchInput,float rollInput,float yawInput)\n\n{\n  undefined4 throttlePitchDiff;\n  undefined4 throttlePitchSum;\n  undefined4 throttlePitchRollDiff;\n  int motor4Speed;\n  int motor3Speed;\n  int motor2Speed;\n  int motor1Speed;\n  \n  throttlePitchDiff = __aeabi_fsub();\n  throttlePitchSum = __addsf3(throttleInput,pitchInput);\n  throttlePitchRollDiff = __aeabi_fsub(throttlePitchDiff,rollInput);\n  throttlePitchRollDiff = __addsf3(throttlePitchRollDiff,yawInput);\n  __aeabi_fsub(throttlePitchRollDiff,0x447a0000);\n  motor4Speed = __aeabi_f2iz();\n  throttlePitchRollDiff = __aeabi_fsub(throttlePitchSum,rollInput);\n  throttlePitchRollDiff = __aeabi_fsub(throttlePitchRollDiff,yawInput);\n  __aeabi_fsub(throttlePitchRollDiff,0x447a0000);\n  motor3Speed = __aeabi_f2iz();\n  throttlePitchDiff = __addsf3(throttlePitchDiff,rollInput);\n  throttlePitchDiff = __aeabi_fsub(throttlePitchDiff,yawInput);\n  __aeabi_fsub(throttlePitchDiff,0x447a0000);\n  motor2Speed = __aeabi_f2iz();\n  throttlePitchDiff = __addsf3(rollInput,throttlePitchSum);\n  throttlePitchDiff = __addsf3(throttlePitchDiff,yawInput);\n  __aeabi_fsub(throttlePitchDiff,0x447a0000);\n  motor1Speed = __aeabi_f2iz();\n  Motor_SetSpeed(motor1Speed,motor2Speed,motor3Speed,motor4Speed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800426c": "calculate_motor_speeds_0800426c",
                "throttle": "throttleInput",
                "pitch": "pitchInput",
                "roll": "rollInput",
                "yaw": "yawInput",
                "uVar1": "throttlePitchDiff",
                "uVar2": "throttlePitchSum",
                "uVar3": "throttlePitchRollDiff",
                "m4": "motor4Speed",
                "m3": "motor3Speed",
                "m2": "motor2Speed",
                "m1": "motor1Speed"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_f2iz",
                "__addsf3",
                "__aeabi_fsub",
                "Motor_SetSpeed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004300": {
            "entrypoint": "0x08004300",
            "current_name": "send_data_with_checksum_08004300",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendDataWithChecksum_08004300(uint8_t checksum,uint8_t *payload,uint16_t payload_length)\n\n{\n  byte checksum_byte;\n  byte *data_ptr;\n  \n  serialPrint(\"$M>\");\n  serialWrite((byte)payload_length);\n  checksum_byte = (byte)payload_length ^ checksum;\n  serialWrite(checksum);\n  for (data_ptr = payload; (int)data_ptr - (int)payload < (int)(uint)payload_length; data_ptr = data_ptr + 1) {\n    serialWrite(*data_ptr);\n    checksum_byte = checksum_byte ^ *data_ptr;\n  }\n  serialWrite(checksum_byte);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004300": "send_data_with_checksum_08004300",
                "code": "checksum",
                "data": "payload",
                "data_length": "payload_length",
                "ch": "checksum_byte",
                "pbVar1": "data_ptr"
            },
            "calling": [
                "MSP_SendMotor",
                "MSP_SendAttitude",
                "MSP_SendStatus",
                "MSP_SendAltitude",
                "MSP_SendPID",
                "MSP_SendIdent",
                "MSP_SendRawIMU"
            ],
            "called": [
                "serialWrite",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004348": {
            "entrypoint": "0x08004348",
            "current_name": "transmit_data_08004348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08004348(void)\n\n{\n  uint inputValue;\n  uint8_t buffer [7];\n  undefined4 frameIdentifier;\n  uint maskedInputValue;\n  \n  msp_txf_ident._0_4_ = 0x40003e9;\n  msp_txf_ident.capability._1_2_ = 0;\n  msp_txf_ident.capability._3_1_ = 0;\n  frameIdentifier = 0x40003e9;\n  maskedInputValue = inputValue & 0xff000000;\n  MSP_SendFrame('d',(uint8_t *)&frameIdentifier,7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004348": "transmit_data_08004348",
                "in_r1": "inputValue",
                "buff": "buffer",
                "local_10": "frameIdentifier",
                "local_c": "maskedInputValue"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004384": {
            "entrypoint": "0x08004384",
            "current_name": "send_frame_to_msp_08004384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameToMSP_08004384(void)\n\n{\n  uint inputValue;\n  undefined4 localStatus;\n  undefined4 stackStatus;\n  uint maskedValue;\n  \n  msp_txf_status._4_4_ = 0x2a0007;\n  localStatus = msp_txf_status._0_4_;\n  stackStatus = 0x2a0007;\n  msp_txf_status.flag._2_2_ = 0;\n  msp_txf_status.current_set = '\\0';\n  maskedValue = inputValue & 0xff000000;\n  MSP_SendFrame('e',(uint8_t *)&localStatus,0xb);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004384": "send_frame_to_msp_08004384",
                "in_r3": "inputValue",
                "local_14": "localStatus",
                "uStack_10": "stackStatus",
                "local_c": "maskedValue"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043bc": {
            "entrypoint": "0x080043bc",
            "current_name": "copy_raw_imu_data_080043bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid copyRawImuData_080043bc(void)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 *destBuffer;\n  RawImuData *srcData;\n  uint8_t buffer [18];\n  \n  srcData = &msp_txf_raw_imu;\n  destBuffer = (undefined4 *)buffer;\n  do {\n    temp1 = *(undefined4 *)srcData;\n    temp2 = *(undefined4 *)&srcData->accz;\n    srcData = (RawImuData *)&srcData->gyry;\n    *destBuffer = temp1;\n    destBuffer[1] = temp2;\n    destBuffer = destBuffer + 2;\n  } while (srcData != (RawImuData *)&msp_txf_raw_imu.magz);\n  *(int16_t *)destBuffer = msp_txf_raw_imu.magz;\n  MSP_SendFrame('f',buffer,0x12);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043bc": "copy_raw_imu_data_080043bc",
                "msp_raw_imu": "RawImuData",
                "puVar3": "destBuffer",
                "pmVar4": "srcData",
                "buff": "buffer",
                "uVar1": "temp1",
                "uVar2": "temp2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043f0": {
            "entrypoint": "0x080043f0",
            "current_name": "send_motor_data_080043f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendMotorData_080043f0(void)\n\n{\n  uint8_t buffer [8];\n  undefined4 motorSpeed;\n  undefined4 motorPosition;\n  \n  motorSpeed = msp_txf_motor.motor._0_4_;\n  motorPosition = msp_txf_motor.motor._4_4_;\n  MSP_SendFrame('h',(uint8_t *)&motorSpeed,8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "buff": "buffer",
                "local_10": "motorSpeed",
                "uStack_c": "motorPosition"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004410": {
            "entrypoint": "0x08004410",
            "current_name": "send_attitude_frame_08004410",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAttitudeFrame_08004410(void)\n\n{\n  undefined4 input_parameter;\n  uint8_t attitudeBuffer [6];\n  undefined4 attitudeField1;\n  undefined4 attitudeField2;\n  \n  attitudeField1 = msp_txf_attitude._0_4_;\n  attitudeField2 = CONCAT22((short)((uint)input_parameter >> 0x10),msp_txf_attitude.heading);\n  MSP_SendFrame('l',(uint8_t *)&attitudeField1,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004410": "send_attitude_frame_08004410",
                "in_r1": "input_parameter",
                "buff": "attitudeBuffer",
                "local_10": "attitudeField1",
                "local_c": "attitudeField2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004434": {
            "entrypoint": "0x08004434",
            "current_name": "send_altitude_data_08004434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAltitudeData_08004434(void)\n\n{\n  undefined4 arg1;\n  uint8_t buffer [6];\n  int32_t altitude;\n  undefined4 vario;\n  \n  altitude = msp_txf_altitude.est_alt;\n  vario = CONCAT22((short)((uint)arg1 >> 0x10),msp_txf_altitude.vario);\n  MSP_SendFrame('m',(uint8_t *)&altitude,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004434": "send_altitude_data_08004434",
                "in_r1": "arg1",
                "buff": "buffer",
                "local_10": "altitude",
                "local_c": "vario"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004458": {
            "entrypoint": "0x08004458",
            "current_name": "send_pitch_data_08004458",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendPitchData_08004458(void)\n\n{\n  undefined4 *localDataPtr;\n  undefined4 yawData;\n  undefined4 *dataPtr;\n  msp_pid *currentPid;\n  msp_pid *nextPid;\n  uint8_t buffer [30];\n  undefined4 dataArray [3];\n  undefined2 yawArray [10];\n  \n  localDataPtr = dataArray;\n  nextPid = &msp_txf_pid;\n  do {\n    currentPid = nextPid;\n    dataPtr = localDataPtr;\n    yawData = *(undefined4 *)&(currentPid->pitch).i;\n    nextPid = (msp_pid *)&(currentPid->yaw).d;\n    *dataPtr = *(undefined4 *)currentPid;\n    dataPtr[1] = yawData;\n    localDataPtr = dataPtr + 2;\n  } while (nextPid != (msp_pid *)&msp_txf_pid.mag);\n  dataPtr[2] = msp_txf_pid._24_4_;\n  *(undefined2 *)(dataPtr + 3) = *(undefined2 *)&currentPid->pos;\n  MSP_SendFrame('p',(uint8_t *)dataArray,0x1e);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004458": "send_pitch_data_08004458",
                "puVar1": "localDataPtr",
                "uVar2": "yawData",
                "puVar3": "dataPtr",
                "pmVar4": "currentPid",
                "pmVar5": "nextPid",
                "buff": "buffer",
                "local_30": "dataArray",
                "local_24": "yawArray"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004490": {
            "entrypoint": "0x08004490",
            "current_name": "error_handler_08004490",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid errorHandler_08004490(char *fileName,int lineNumber)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,GPIO_PIN_SET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,GPIO_PIN_RESET);\n  do {\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x4000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x8000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x2000);\n    serialPrint(\"Error with \");\n    serialPrint(fileName);\n    serialPrint(\" at lineNumber: \");\n    serialInt(lineNumber);\n    serialWrite('\\n');\n    delay_ms(500);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004490": "error_handler_08004490",
                "file": "fileName",
                "line": "lineNumber"
            },
            "calling": [
                "Peripherals_Init",
                "I2C_ReadByte",
                "I2C_ReadBytes",
                "I2C_WriteByte",
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "serialWrite",
                "delay_ms",
                "serialInt",
                "serialPrint",
                "HAL_GPIO_TogglePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004514": {
            "entrypoint": "0x08004514",
            "current_name": "initialize_system_08004514",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08004514(void)\n\n{\n  HAL_StatusTypeDef status;\n  char *errorFilePath;\n  uint32_t hclkFreq;\n  int lineNumber;\n  uint flashLatency;\n  RCC_ClkInitTypeDef rccClkInitStruct;\n  RCC_OscInitTypeDef rccOscInitStruct;\n  \n  rccOscInitStruct.HSIState = 1;\n  rccOscInitStruct.HSICalibrationValue = 0x10;\n  flashLatency = 2;\n  rccOscInitStruct.PLL.PLLSource = 0;\n  rccOscInitStruct.OscillatorType = 2;\n  rccOscInitStruct.PLL.PLLState = 2;\n  rccOscInitStruct.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig(&rccOscInitStruct);\n  errorFilePath = (char *)(uint)status;\n  if (errorFilePath == (char *)0x0) goto LAB_08004540;\n  lineNumber = 0x3c;\n  while( true ) {\n    errorFilePath = \"../Src/peripherals.c\";\n    _Error_Handler(\"../Src/peripherals.c\",lineNumber);\nLAB_08004540:\n    rccClkInitStruct.ClockType = 0xf;\n    rccClkInitStruct.APB1CLKDivider = 0x400;\n    rccClkInitStruct.SYSCLKSource = flashLatency;\n    rccClkInitStruct.AHBCLKDivider = (uint32_t)errorFilePath;\n    rccClkInitStruct.APB2CLKDivider = (uint32_t)errorFilePath;\n    status = HAL_RCC_ClockConfig(&rccClkInitStruct,flashLatency);\n    flashLatency = (uint)status;\n    if (flashLatency == 0) break;\n    lineNumber = 0x49;\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004514": "initialize_system_08004514",
                "RCC_OscInitStruct": "rccOscInitStruct",
                "RCC_ClkInitStruct": "rccClkInitStruct",
                "HVar1": "status",
                "pcVar2": "errorFilePath",
                "uVar3": "hclkFreq",
                "FLatency": "flashLatency",
                "line": "lineNumber"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_peripherals_0800458c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_0800458c(void)\n\n{\n  Status HVar1;\n  char *errorHandler;\n  uint status;\n  int currentLine;\n  uint prescaler;\n  uint32_t tmpRegister;\n  uint32_t tmpRegister1;\n  uint32_t tmpRegister2;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_OC_InitTypeDef ocConfig;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  initializeHardware();\n  configureSystemClock();\n  prescaler = 2;\n  _DAT_40021018 = _DAT_40021018 | 0x1c;\n  setGPIOPinState((GPIO *)0x40011000,0xe000,GPIO_PIN_RESET);\n  setGPIOPinState((GPIO *)0x40010800,0x20,GPIO_PIN_RESET);\n  gpioPin = 0xe000;\n  gpioMode = 1;\n  gpioSpeed = 2;\n  HAL_GPIO_Init((GPIO *)0x40011000,&gpioInitStruct);\n  gpioPin = 0x20;\n  gpioMode = 1;\n  gpioSpeed = 2;\n  HAL_GPIO_Init((GPIO *)0x40010800,&gpioInitStruct);\n  i2c1.Instance = (I2C *)0x40005400;\n  i2c1.Init.ClockSpeed = 400000;\n  i2c1.Init.AddressingMode = 0x4000;\n  i2c1.Init.DutyCycle = 0;\n  i2c1.Init.OwnAddress1 = 0;\n  i2c1.Init.DualAddressMode = 0;\n  i2c1.Init.OwnAddress2 = 0;\n  i2c1.Init.GeneralCallMode = 0;\n  i2c1.Init.NoStretchMode = 0;\n  HVar1 = initializeI2C(&i2c1);\n  errorHandler = (char *)(uint)HVar1;\n  if (errorHandler == (char *)0x0) goto LAB_0800463a;\n  currentLine = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  errorHandler = \"../Src/peripherals.c\";\n                                  _Error_Handler(\"../Src/peripherals.c\",currentLine);\nLAB_0800463a:\n                                  usart1.Instance = (USART *)0x40013800;\n                                  usart1.Init.BaudRate = 0x1c200;\n                                  usart1.Init.Mode = 0xc;\n                                  usart1.Init.WordLength = (uint32_t)errorHandler;\n                                  usart1.Init.StopBits = (uint32_t)errorHandler;\n                                  usart1.Init.Parity = (uint32_t)errorHandler;\n                                  usart1.Init.HwFlowCtl = (uint32_t)errorHandler;\n                                  usart1.Init.OverSampling = (uint32_t)errorHandler;\n                                  HVar1 = initializeUART(&usart1);\n                                  status = (uint)HVar1;\n                                  if (status == 0) break;\n                                  currentLine = 0x151;\n                                }\n                                timer1.Instance = (TIM *)0x40012c00;\n                                timer1.Init.Period = 1000;\n                                timer1.Init.Prescaler = prescaler;\n                                timer1.Init.CounterMode = status;\n                                timer1.Init.ClockDivision = status;\n                                timer1.Init.RepetitionCounter = status;\n                                HVar1 = initializePWMTimer(&timer1);\n                                status = (uint)HVar1;\n                                if (status == 0) break;\n                                currentLine = 0x88;\n                              }\n                              masterConfig.MasterOutputTrigger = status;\n                              masterConfig.MasterSlaveMode = status;\n                              HVar1 = configureMasterSlaveMode(&timer1,&masterConfig);\n                              status = (uint)HVar1;\n                              if (status == 0) break;\n                              currentLine = 0x8f;\n                            }\n                            ocConfig.OCMode = 0x60;\n                            ocConfig.Pulse = status;\n                            ocConfig.OCPolarity = status;\n                            ocConfig.OCFastMode = status;\n                            ocConfig.OCIdleState = status;\n                            ocConfig.OCNIdleState = status;\n                            HVar1 = configurePWMChannel(&timer1,&ocConfig,0xc);\n                            status = (uint)HVar1;\n                            if (status == 0) break;\n                            currentLine = 0x9a;\n                          }\n                          gpioPin = status;\n                          gpioMode = status;\n                          gpioInitStruct.Pull = status;\n                          gpioSpeed = status;\n                          HVar1 = configureBreakDeadTime\n                                            (&timer1,(TIM_BreakDeadTimeConfig *)\n                                                    &gpioInitStruct);\n                          status = (uint)HVar1;\n                          if (status == 0) break;\n                          currentLine = 0xa6;\n                        }\n                        postInitializeTIM(&timer1);\n                        timer2.Instance = (TIM *)0x40000000;\n                        timer2.Init.Period = 1000;\n                        timer2.Init.Prescaler = prescaler;\n                        timer2.Init.CounterMode = status;\n                        timer2.Init.ClockDivision = status;\n                        HVar1 = initializePWMTimer(&timer2);\n                        status = (uint)HVar1;\n                        if (status == 0) break;\n                        currentLine = 0xc3;\n                      }\n                      ocConfig.OCMode = status;\n                      ocConfig.Pulse = status;\n                      HVar1 = configureMasterSlaveMode\n                                        (&timer2,(TIM_MasterConfigTypeDef *)&ocConfig);\n                      status = (uint)HVar1;\n                      if (status == 0) break;\n                      currentLine = 0xca;\n                    }\n                    gpioPin = 0x60;\n                    gpioMode = status;\n                    gpioInitStruct.Pull = status;\n                    HVar1 = configurePWMChannel\n                                      (&timer2,(TIM_OC_InitTypeDef *)&gpioInitStruct,4);\n                    status = (uint)HVar1;\n                    if (status == 0) break;\n                    currentLine = 0xd3;\n                  }\n                  postInitializeTIM(&timer2);\n                  timer3.Init.Period = 1000;\n                  timer3.Instance = (TIM *)0x40000400;\n                  timer3.Init.Prescaler = prescaler;\n                  timer3.Init.CounterMode = status;\n                  timer3.Init.ClockDivision = status;\n                  HVar1 = initializePWMTimer(&timer3);\n                  if (HVar1 == HAL_OK) break;\n                  currentLine = 0xf0;\n                }\n                ocConfig.OCMode = 0;\n                ocConfig.Pulse = 0;\n                HVar1 = configureMasterSlaveMode\n                                  (&timer3,(TIM_MasterConfigTypeDef *)&ocConfig);\n                status = (uint)HVar1;\n                if (status == 0) break;\n                currentLine = 0xf7;\n              }\n              gpioPin = 0x60;\n              gpioMode = status;\n              gpioInitStruct.Pull = status;\n              HVar1 = configurePWMChannel(&timer3,(TIM_OC_InitTypeDef *)&gpioInitStruct,8);\n              if (HVar1 == HAL_OK) break;\n              currentLine = 0x100;\n            }\n            HVar1 = configurePWMChannel(&timer3,(TIM_OC_InitTypeDef *)&gpioInitStruct,0xc);\n            prescaler = (uint)HVar1;\n            if (prescaler == 0) break;\n            currentLine = 0x105;\n          }\n          postInitializeTIM(&timer3);\n          timer4.Instance = (TIM *)0x40000800;\n          timer4.Init.Prescaler = 2;\n          timer4.Init.Period = 1000;\n          timer4.Init.CounterMode = prescaler;\n          timer4.Init.ClockDivision = prescaler;\n          HVar1 = initializePWMTimer(&timer4);\n          status = (uint)HVar1;\n          if (status == 0) break;\n          currentLine = 0x122;\n        }\n        ocConfig.OCMode = status;\n        ocConfig.Pulse = status;\n        HVar1 = configureMasterSlaveMode(&timer4,(TIM_MasterConfigTypeDef *)&ocConfig);\n        status = (uint)HVar1;\n        if (status == 0) break;\n        currentLine = 0x129;\n      }\n      gpioPin = 0x60;\n      gpioMode = status;\n      gpioInitStruct.Pull = status;\n      HVar1 = configurePWMChannel(&timer4,(TIM_OC_InitTypeDef *)&gpioInitStruct,8);\n      if (HVar1 == HAL_OK) break;\n      currentLine = 0x132;\n    }\n    HVar1 = configurePWMChannel(&timer4,(TIM_OC_InitTypeDef *)&gpioInitStruct,0xc);\n    if (HVar1 == HAL_OK) break;\n    currentLine = 0x137;\n  }\n  postInitializeTIM(&timer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_peripherals_0800458c",
                "HAL_StatusTypeDef": "Status",
                "pcVar2": "errorHandler",
                "uVar3": "status",
                "line": "currentLine",
                "uVar4": "prescaler",
                "tmpreg": "tmpRegister",
                "tmpreg_1": "tmpRegister1",
                "tmpreg_2": "tmpRegister2",
                "sMasterConfig": "masterConfig",
                "sConfigOC": "ocConfig",
                "GPIO_InitStruct": "gpioInitStruct",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock",
                "HAL_GPIO_WritePin": "setGPIOPinState",
                "hi2c1": "i2c1",
                "I2C_TypeDef": "I2C",
                "GPIO_TypeDef": "GPIO",
                "HAL_I2C_Init": "initializeI2C",
                "huart1": "usart1",
                "USART_TypeDef": "USART",
                "HAL_UART_Init": "initializeUART",
                "htim1": "timer1",
                "TIM_TypeDef": "TIM",
                "HAL_TIM_PWM_Init": "initializePWMTimer",
                "HAL_TIMEx_MasterConfigSynchronization": "configureMasterSlaveMode",
                "HAL_TIM_PWM_ConfigChannel": "configurePWMChannel",
                "GPIO_InitStruct.Pin": "gpioPin",
                "GPIO_InitStruct.Mode": "gpioMode",
                "GPIO_InitStruct.Speed": "gpioSpeed",
                "TIM_BreakDeadTimeConfigTypeDef": "TIM_BreakDeadTimeConfig",
                "HAL_TIMEx_ConfigBreakDeadTime": "configureBreakDeadTime",
                "HAL_TIM_MspPostInit": "postInitializeTIM",
                "htim2": "timer2",
                "htim3": "timer3",
                "htim4": "timer4"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_UART_Init",
                "HAL_Init",
                "HAL_GPIO_Init",
                "HAL_I2C_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_ConfigChannel",
                "_Error_Handler",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_MspPostInit",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800483c": {
            "entrypoint": "0x0800483c",
            "current_name": "calculate_pid_output_0800483c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculatePIDOutput_0800483c(PIDData *pid)\n\n{\n  undefined4 setPointOffset;\n  int comparisonResult;\n  undefined4 uVar3;\n  float inputError;\n  float proportionalTerm;\n  float integralGain;\n  \n  inputError = pid->input;\n  setPointOffset = __addsf3(pid->set_point,pid->offset);\n  inputError = (float)__aeabi_fsub(setPointOffset,inputError);\n  pid->error = inputError;\n  if (pid->instance == 3) {\n    comparisonResult = __aeabi_fcmpgt(pid->error,0);\n    if (comparisonResult == 0) {\n      comparisonResult = __aeabi_fcmplt(pid->error,0xc3340000);\n    }\n    else {\n      comparisonResult = __aeabi_fcmpgt(pid->error,0x43340000);\n    }\n    if (comparisonResult != 0) {\n      proportionalTerm = pid->error;\n      setPointOffset = __aeabi_fmul(pid->error,0x43b40000);\n      comparisonResult = __aeabi_fcmpgt(pid->error,0);\n      inputError = pid->error;\n      if (comparisonResult == 0) {\n        inputError = (float)((int)inputError + -0x80000000);\n      }\n      setPointOffset = __aeabi_fdiv(setPointOffset,inputError);\n      inputError = (float)__aeabi_fsub(proportionalTerm,setPointOffset);\n      pid->error = inputError;\n    }\n  }\n  integralGain = pid->con_KI;\n  proportionalTerm = pid->con_KD;\n  inputError = (float)__aeabi_fmul(pid->con_KP,pid->error);\n  pid->proportional = inputError;\n  inputError = (float)__addsf3(pid->error,pid->integral);\n  pid->integral = inputError;\n  comparisonResult = __aeabi_fcmplt(pid->integral,0xc3fa0000);\n  if (comparisonResult == 0) {\n    comparisonResult = __aeabi_fcmpgt(pid->integral,0x43fa0000);\n    if (comparisonResult == 0) {\n      inputError = pid->integral;\n    }\n    else {\n      inputError = 500.0;\n    }\n  }\n  else {\n    inputError = -500.0;\n  }\n  pid->integral = inputError;\n  inputError = (float)__aeabi_fsub(pid->input,pid->last_input);\n  pid->derivative = inputError;\n  inputError = pid->proportional;\n  setPointOffset = __aeabi_fmul(integralGain,pid->integral);\n  setPointOffset = __addsf3(setPointOffset,inputError);\n  uVar3 = __aeabi_fmul(proportionalTerm,pid->derivative);\n  inputError = (float)__aeabi_fsub(setPointOffset,uVar3);\n  pid->output = inputError;\n  setPointOffset = __floatsisf(pid->direction);\n  comparisonResult = __aeabi_fcmplt(pid->output,0xc3fa0000);\n  if (comparisonResult == 0) {\n    comparisonResult = __aeabi_fcmpgt(pid->output,0x43fa0000);\n    if (comparisonResult == 0) {\n      inputError = pid->output;\n    }\n    else {\n      inputError = 500.0;\n    }\n  }\n  else {\n    inputError = -500.0;\n  }\n  inputError = (float)__aeabi_fmul(inputError,setPointOffset);\n  pid->output = inputError;\n  pid->last_input = pid->input;\n  pid->last_error = pid->error;\n  pid->last_time = pid->time;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800483c": "calculate_pid_output_0800483c",
                "PID_TypeDef": "PIDData",
                "fVar4": "inputError",
                "uVar1": "setPointOffset",
                "fVar5": "proportionalTerm",
                "fVar6": "integralGain",
                "iVar2": "comparisonResult"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "initialize_pid_controllers_08004978",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePIDControllers_08004978(void)\n\n{\n  pid_pitch.direction = 1;\n  pid_roll.direction = 1;\n  pid_yaw.direction = -1;\n  pid_altitude.direction = 1;\n  pid_pitch.breakpoint = 1500.0;\n  pid_roll.breakpoint = 1450.0;\n  pid_yaw.breakpoint = 2000.0;\n  pid_altitude.breakpoint = 0.0;\n  pid_pitch.con_KP = 4.4;\n  pid_pitch.con_KI = 0.02;\n  pid_pitch.con_KD = 280.0;\n  pid_pitch.agr_KP = 4.5;\n  pid_pitch.agr_KI = 0.02;\n  pid_pitch.agr_KD = 360.0;\n  pid_roll.con_KP = 3.8;\n  pid_roll.con_KI = 0.02;\n  pid_roll.con_KD = 260.0;\n  pid_roll.agr_KP = 3.8;\n  pid_roll.agr_KI = 0.02;\n  pid_roll.agr_KD = 320.0;\n  pid_yaw.con_KP = 3.0;\n  pid_yaw.con_KI = 0.01;\n  pid_yaw.con_KD = 280.0;\n  pid_yaw.agr_KP = 0.0;\n  pid_yaw.agr_KI = 0.0;\n  pid_yaw.agr_KD = 0.0;\n  pid_altitude.con_KP = 10.0;\n  pid_altitude.con_KI = 0.0;\n  pid_altitude.con_KD = 0.0;\n  pid_altitude.agr_KP = 0.0;\n  pid_altitude.agr_KI = 0.0;\n  pid_altitude.agr_KD = 0.0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004978": "initialize_pid_controllers_08004978"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a30": {
            "entrypoint": "0x08004a30",
            "current_name": "update_altitude_08004a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAltitude_08004a30(void)\n\n{\n  if (isAltitudeHoldEnabled != '\\0') {\n    if (hasAltitudeChanged == '\\0') {\n      getFilteredAltitude();\n      altitudeSetPoint = (float)multiplyFloat();\n      hasAltitudeChanged = '\\x01';\n    }\n    else {\n      getFilteredAltitude();\n      altitudeInput = (float)multiplyFloat();\n    }\n  }\n  if (isAltitudeHoldEnabled == '\\0') {\n    if (hasAltitudeChanged != '\\0') {\n      hasAltitudeChanged = isAltitudeHoldEnabled;\n    }\n    altitudeOutput = throttleValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a30": "update_altitude_08004a30",
                "joystick.ALT_HOLD": "isAltitudeHoldEnabled",
                "ALT_FLAG": "hasAltitudeChanged",
                "MS5611_GetFilteredAltitude": "getFilteredAltitude",
                "pid_altitude.set_point": "altitudeSetPoint",
                "__aeabi_fmul": "multiplyFloat",
                "pid_altitude.input": "altitudeInput",
                "joystick.throttle": "throttleValue",
                "pid_altitude.output": "altitudeOutput"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "MS5611_GetFilteredAltitude",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "update_flight_controller_08004a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateFlightController_08004a84(void)\n\n{\n  float input;\n  int comparison_result;\n  \n  AHRS_GetPitch();\n  pitch_input = input;\n  AHRS_GetRoll();\n  roll_input = input;\n  AHRS_GetYaw();\n  yaw_input = input;\n  updateAltitudeController();\n  comparison_result = __aeabi_fcmpgt(pitch_input,0);\n  if (comparison_result == 0) {\n    comparison_result = __aeabi_fcmplt(pitch_input,0xc2a00000);\n  }\n  else {\n    comparison_result = __aeabi_fcmpgt(pitch_input,0x42a00000);\n  }\n  if (comparison_result == 0) {\n    comparison_result = __aeabi_fcmpgt(roll_input,0);\n    if (comparison_result == 0) {\n      comparison_result = __aeabi_fcmplt(roll_input,0xc2a00000);\n    }\n    else {\n      comparison_result = __aeabi_fcmpgt(roll_input,0x42a00000);\n    }\n    if (comparison_result == 0) {\n      toggleLED(1,1,1);\n      computePID(&pitch_pid);\n      computePID(&roll_pid);\n      computePID(&yaw_pid);\n      if (ALT_HOLD_flag != '\\0') {\n        computePID(&pid_altitude);\n        __addsf3(pid_altitude.output,0x44bb8000);\n      }\n      pid_altitude.output = throttle;\n      if (MOTOR_ARM_flag == '\\0') {\n        stopAllMotors();\n      }\n      else {\n        distributeMotorSpeed(throttle,pitch_pid.output,roll_pid.output,yaw_pid.output);\n      }\n      __aeabi_fmul(pitch_KP,0x437f0000);\n      msp_txf_pid_pitch_P = __fixunssfsi();\n      __aeabi_fmul(pitch_KI,0x437f0000);\n      msp_txf_pid_pitch_I = __fixunssfsi();\n      __aeabi_fmul(roll_KP,0x437f0000);\n      msp_txf_pid_roll_P = __fixunssfsi();\n      __aeabi_fmul(roll_KI,0x437f0000);\n      msp_txf_pid_roll_I = __fixunssfsi();\n      __aeabi_fmul(roll_KD,0x437f0000);\n      msp_txf_pid_roll_D = __fixunssfsi();\n      __aeabi_fmul(yaw_KP,0x437f0000);\n      msp_txf_pid_yaw_P = __fixunssfsi();\n      __aeabi_fmul(yaw_KI,0x437f0000);\n      msp_txf_pid_yaw_I = __fixunssfsi();\n      __aeabi_fmul(yaw_KD,0x437f0000);\n      msp_txf_pid_yaw_D = __fixunssfsi();\n      __aeabi_fmul(altitude_KP,0x437f0000);\n      msp_txf_pid_alt_P = __fixunssfsi();\n      __aeabi_fmul(altitude_KI,0x437f0000);\n      msp_txf_pid_alt_I = __fixunssfsi();\n      __aeabi_fmul(altitude_KD,0x437f0000);\n      msp_txf_pid_alt_D = __fixunssfsi();\n      return;\n    }\n  }\n  stopAllMotors();\n  toggleLED(0,1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "update_flight_controller_08004a84",
                "in_r0": "input",
                "iVar1": "comparison_result",
                "pid_pitch.input": "pitch_input",
                "pid_roll.input": "roll_input",
                "pid_yaw.input": "yaw_input",
                "pid_pitch": "pitch_pid",
                "pid_roll": "roll_pid",
                "pid_yaw": "yaw_pid",
                "PID_UpdateAltitude": "updateAltitudeController",
                "joystick.ALT_HOLD": "ALT_HOLD_flag",
                "PID_Compute": "computePID",
                "joystick.throttle": "throttle",
                "joystick.MOTOR_ARM": "MOTOR_ARM_flag",
                "Motor_StopAll": "stopAllMotors",
                "Motor_DistributeSpeed": "distributeMotorSpeed",
                "pid_pitch.con_KP": "pitch_KP",
                "pid_pitch.con_KI": "pitch_KI",
                "pid_roll.con_KP": "roll_KP",
                "pid_roll.con_KI": "roll_KI",
                "pid_roll.con_KD": "roll_KD",
                "pid_yaw.con_KP": "yaw_KP",
                "pid_yaw.con_KI": "yaw_KI",
                "pid_yaw.con_KD": "yaw_KD",
                "pid_altitude.con_KP": "altitude_KP",
                "pid_altitude.con_KI": "altitude_KI",
                "pid_altitude.con_KD": "altitude_KD",
                "msp_txf_pid.pitch.p": "msp_txf_pid_pitch_P",
                "msp_txf_pid.pitch.i": "msp_txf_pid_pitch_I",
                "msp_txf_pid.roll.p": "msp_txf_pid_roll_P",
                "msp_txf_pid.roll.i": "msp_txf_pid_roll_I",
                "msp_txf_pid.roll.d": "msp_txf_pid_roll_D",
                "msp_txf_pid.yaw.p": "msp_txf_pid_yaw_P",
                "msp_txf_pid.yaw.i": "msp_txf_pid_yaw_I",
                "msp_txf_pid.yaw.d": "msp_txf_pid_yaw_D",
                "msp_txf_pid.alt.p": "msp_txf_pid_alt_P",
                "msp_txf_pid.alt.i": "msp_txf_pid_alt_I",
                "msp_txf_pid.alt.d": "msp_txf_pid_alt_D"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "Motor_StopAll",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "AHRS_GetRoll",
                "PID_Compute",
                "__addsf3",
                "toggleLED",
                "Motor_DistributeSpeed",
                "AHRS_GetPitch",
                "__fixunssfsi",
                "AHRS_GetYaw",
                "PID_UpdateAltitude"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c18": {
            "entrypoint": "0x08004c18",
            "current_name": "transmit_buffered_char_08004c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitBufferedChar_08004c18(ucharacterar character)\n\n{\n  transmitBuffer[0] = character;\n  transmitUARTData(&huart1,(uint8_t *)transmitBuffer,1,5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c18": "transmit_buffered_char_08004c18",
                "ch": "character",
                "tx_buffer": "transmitBuffer",
                "HAL_UART_Transmit": "transmitUARTData"
            },
            "calling": [
                "MSP_SendFrame",
                "serialPrint",
                "_Error_Handler"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "handle_uart_instance_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_instance_08004c30(UART_HandleTypeDef *uart_instance)\n\n{\n  if (uart_instance->Instance == (uart_typedef *)0x40013800) {\n    write_to_circular_buffer(&receive_character,receive_buffer[0]);\n    receive_uart_data_with_interrupt(&uart1_instance,receive_buffer,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "handle_uart_instance_08004c30",
                "huart": "uart_instance",
                "USART_TypeDef": "uart_typedef",
                "CB_Write": "write_to_circular_buffer",
                "rxc": "receive_character",
                "rx_buffer": "receive_buffer",
                "HAL_UART_Receive_IT": "receive_uart_data_with_interrupt",
                "huart1": "uart1_instance"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "CB_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c64": {
            "entrypoint": "0x08004c64",
            "current_name": "initialize_receiver_08004c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeReceiver_08004c64(void)\n\n{\n  CB_Init(&receiver);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c64": "initialize_receiver_08004c64",
                "rxc": "receiver"
            },
            "calling": [
                "serialBegin"
            ],
            "called": [
                "CB_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c70": {
            "entrypoint": "0x08004c70",
            "current_name": "initialize_serial_communication_08004c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08004c70(void)\n\n{\n  flushSerialBuffer();\n  receiveDataWithInterrupt(&huart1,receivedDataBuffer,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c70": "initialize_serial_communication_08004c70",
                "rx_buffer": "receivedDataBuffer",
                "serialFlush": "flushSerialBuffer",
                "HAL_UART_Receive_IT": "receiveDataWithInterrupt"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8c": {
            "entrypoint": "0x08004c8c",
            "current_name": "serialize_data_08004c8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serializeData_08004c8c(char *inputData)\n\n{\n  size_t dataLength;\n  uchar *currentCharacter;\n  \n  for (currentCharacter = (uchar *)inputData; dataLength = strlen(inputData), (uint)((int)currentCharacter - (int)inputData) < dataLength;\n      currentCharacter = currentCharacter + 1) {\n    serialWrite(*currentCharacter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c8c": "serialize_data_08004c8c",
                "data": "inputData",
                "sVar1": "dataLength",
                "puVar2": "currentCharacter"
            },
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "called": [
                "strlen",
                "serialWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cac": {
            "entrypoint": "0x08004cac",
            "current_name": "print_integer_value_08004cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printIntegerValue_08004cac(int inputNumber)\n\n{\n  siprintf(outputBuffer,\"%i\",inputNumber);\n  serialPrint(outputBuffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004cac": "print_integer_value_08004cac",
                "val": "inputNumber",
                "tx_buffer": "outputBuffer"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "initialize_interrupts_08004ccc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterrupts_08004ccc(void)\n\n{\n  uint32_t temporaryRegister;\n  \n  _DAT_40021018 = _DAT_40021018 | 1;\n  setPriorityGrouping(3);\n  HAL_NVIC_SetPriority(memoryManagementInterrupt,0,0);\n  HAL_NVIC_SetPriority(busFaultInterrupt,0,0);\n  HAL_NVIC_SetPriority(usageFaultInterrupt,0,0);\n  HAL_NVIC_SetPriority(serviceCallInterrupt,0,0);\n  HAL_NVIC_SetPriority(debugMonitorInterrupt,0,0);\n  HAL_NVIC_SetPriority(pendSVInterrupt,0,0);\n  HAL_NVIC_SetPriority(sysTickInterrupt,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "initialize_interrupts_08004ccc",
                "tmpreg": "temporaryRegister",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "MemoryManagement_IRQn": "memoryManagementInterrupt",
                "BusFault_IRQn": "busFaultInterrupt",
                "UsageFault_IRQn": "usageFaultInterrupt",
                "SVCall_IRQn": "serviceCallInterrupt",
                "DebugMonitor_IRQn": "debugMonitorInterrupt",
                "PendSV_IRQn": "pendSVInterrupt",
                "SysTick_IRQn": "sysTickInterrupt"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d48": {
            "entrypoint": "0x08004d48",
            "current_name": "initialize_i2_c_08004d48",
            "code": "\n/* WARNING: Variable defined which should be unmapped: gpioInitStruct */\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_08004d48(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t temporaryRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (i2cHandle->Instance == (I2C_TypeDef *)0x40005400) {\n    gpioInitStruct.Pin = 0xc0;\n    gpioInitStruct.Mode = 0x12;\n    gpioInitStruct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010c00,&gpioInitStruct);\n    _DAT_4002101c = _DAT_4002101c | 0x200000;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d48": "initialize_i2_c_08004d48",
                "hi2c": "i2cHandle",
                "tmpreg": "temporaryRegister",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d8c": {
            "entrypoint": "0x08004d8c",
            "current_name": "setup_timer_08004d8c",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid setupTimer_08004d8c(TIM_HandleTypeDef *timer)\n\n{\n  TIM_TypeDef *timerInstance;\n  uint32_t tempRegister;\n  uint32_t tempRegister_1;\n  uint32_t tempRegister_2;\n  uint32_t tempRegister_3;\n  \n  timerInstance = timer->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d8c": "setup_timer_08004d8c",
                "htim_pwm": "timer",
                "pTVar1": "timerInstance",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister_1",
                "tmpreg_2": "tempRegister_2",
                "tmpreg_3": "tempRegister_3"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e14": {
            "entrypoint": "0x08004e14",
            "current_name": "configure_gpio_08004e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08004e14(TIM_HandleTypeDef *timer)\n\n{\n  GPIO_TypeDef *gpio;\n  TIM_TypeDef *timerInstance;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  timerInstance = timer->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    gpioInitStruct.Pin = 0x800;\n  }\n  else {\n    if (timerInstance != (TIM_TypeDef *)0x40000000) {\n      if (timerInstance == (TIM_TypeDef *)0x40000400) {\n        gpioInitStruct.Pin = 3;\n      }\n      else {\n        if (timerInstance != (TIM_TypeDef *)0x40000800) {\n          return;\n        }\n        gpioInitStruct.Pin = 0x300;\n      }\n      gpio = (GPIO_TypeDef *)0x40010c00;\n      goto LAB_08004e2e;\n    }\n    gpioInitStruct.Pin = 2;\n  }\n  gpio = (GPIO_TypeDef *)0x40010800;\nLAB_08004e2e:\n  gpioInitStruct.Speed = 2;\n  gpioInitStruct.Mode = 2;\n  HAL_GPIO_Init(gpio,&gpioInitStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e14": "configure_gpio_08004e14",
                "htim": "timer",
                "GPIOx": "gpio",
                "pTVar1": "timerInstance",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e7c": {
            "entrypoint": "0x08004e7c",
            "current_name": "initialize_uart_peripheral_08004e7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_peripheral_08004e7c(UART_HandleTypeDef *uart_handler)\n\n{\n  uint32_t temporary_register;\n  GPIO_InitTypeDef gpio_config;\n  \n  if (uart_handler->usart_instance == (USART_type_definition *)0x40013800) {\n    _DAT_40021018 = _DAT_40021018 | 0x4000;\n    gpio_config.gpio_pin = 0x200;\n    gpio_config.gpio_mode = 2;\n    gpio_config.gpio_speed = 3;\n    initialize_GPIO((GPIO_TypeDef *)0x40010800,&gpio_config);\n    gpio_config.gpio_pin = 0x400;\n    gpio_config.gpio_mode = 0;\n    gpio_config.gpio_pull = 0;\n    initialize_GPIO((GPIO_TypeDef *)0x40010800,&gpio_config);\n    set_NVIC_priority(usart_interrupt_number,0,0);\n    enable_NVIC_IRQ(usart_interrupt_number);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e7c": "initialize_uart_peripheral_08004e7c",
                "huart": "uart_handler",
                "tmpreg": "temporary_register",
                "GPIO_InitStruct": "gpio_config",
                "Instance": "usart_instance",
                "USART_TypeDef": "USART_type_definition",
                "Pin": "gpio_pin",
                "Mode": "gpio_mode",
                "Speed": "gpio_speed",
                "HAL_GPIO_Init": "initialize_GPIO",
                "Pull": "gpio_pull",
                "HAL_NVIC_SetPriority": "set_NVIC_priority",
                "USART1_IRQn": "usart_interrupt_number",
                "HAL_NVIC_EnableIRQ": "enable_NVIC_IRQ"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_GPIO_Init",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee4": {
            "entrypoint": "0x08004ee4",
            "current_name": "FUNC_08004ee4",
            "code": "\nvoid FUNC_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee4": "FUNC_08004ee4"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee6": {
            "entrypoint": "0x08004ee6",
            "current_name": "infinite_loop_08004ee6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004ee6(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee6": "infinite_loop_08004ee6"
            },
            "calling": [
                "HardFault_Handler"
            ],
            "called": [
                "HardFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "run_infinite_loop_08004ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid run_infinite_loop_08004ee8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "run_infinite_loop_08004ee8"
            },
            "calling": [
                "MemManage_Handler"
            ],
            "called": [
                "MemManage_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eea": {
            "entrypoint": "0x08004eea",
            "current_name": "do_nothing_loop_08004eea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid doNothingLoop_08004eea(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eea": "do_nothing_loop_08004eea"
            },
            "calling": [
                "BusFault_Handler"
            ],
            "called": [
                "BusFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eec": {
            "entrypoint": "0x08004eec",
            "current_name": "infinite_loop_08004eec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eec(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eec": "infinite_loop_08004eec"
            },
            "calling": [
                "UsageFault_Handler"
            ],
            "called": [
                "UsageFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eee": {
            "entrypoint": "0x08004eee",
            "current_name": "FUNC_08004eee",
            "code": "\nvoid FUNC_08004eee(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004eee": "FUNC_08004eee"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef0": {
            "entrypoint": "0x08004ef0",
            "current_name": "FUNC_08004ef0",
            "code": "\nvoid FUNC_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef0": "FUNC_08004ef0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef2": {
            "entrypoint": "0x08004ef2",
            "current_name": "FUNC_08004ef2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef2": "FUNC_08004ef2"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "increment_tick_and_handle_sys_tick_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTickAndHandleSysTickInterrupt_08004ef4(void)\n\n{\n  incrementTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "increment_tick_and_handle_sys_tick_interrupt_08004ef4",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f04": {
            "entrypoint": "0x08004f04",
            "current_name": "handle_uart_interrupt_08004f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08004f04(void)\n\n{\n  HAL_UART_IRQHandler(UART_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f04": "handle_uart_interrupt_08004f04",
                "&huart1": "UART_handle"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f10": {
            "entrypoint": "0x08004f10",
            "current_name": "initialize_memory_08004f10",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08004f10(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f10": "initialize_memory_08004f10"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f5c": {
            "entrypoint": "0x08004f5c",
            "current_name": "FUN_08004f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
            "renaming": {},
            "calling": [
                "taskScheduler",
                "MS5611_Update"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "get_system_tick_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08004f60(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "get_system_tick_08004f60",
                "uwTick": "systemTick"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f64": {
            "entrypoint": "0x08004f64",
            "current_name": "FUNC_08004f64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f64": "FUNC_08004f64"
            },
            "calling": [
                "LED_StartupSequence",
                "MS5611_Init",
                "I2C_WriteByte",
                "_Error_Handler"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f68": {
            "entrypoint": "0x08004f68",
            "current_name": "initialize_system_08004f68",
            "code": "\nvoid initializeSystem_08004f68(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8672; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (pointer = &completed_8672; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8004f9a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08004f9a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f68": "initialize_system_08004f68",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb0": {
            "entrypoint": "0x08004fb0",
            "current_name": "infinite_loop_08004fb0",
            "code": "\nvoid infiniteLoop_08004fb0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004fb0": "infinite_loop_08004fb0"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb4": {
            "entrypoint": "0x08004fb4",
            "current_name": "initialize_pkey_context_08004fb4",
            "code": "\nvoid initializePKEYContext_08004fb4(EVP_PKEY_CTX *context)\n\n{\n  int iterator;\n  \n  for (iterator = 0; iterator != 0; iterator = iterator + 1) {\n    context = (EVP_PKEY_CTX *)(*(code *)(&__frame_dummy_init_array_entry)[iterator])();\n  }\n  _init(context);\n  for (iterator = 0; iterator != 1; iterator = iterator + 1) {\n    (*(code *)(&__frame_dummy_init_array_entry)[iterator])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fb4": "initialize_pkey_context_08004fb4",
                "param_1": "context",
                "iVar1": "iterator"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ffc": {
            "entrypoint": "0x08004ffc",
            "current_name": "print_formatted_string_08004ffc",
            "code": "\nint printFormattedString_08004ffc(char *outputString,char *formatString,...)\n\n{\n  int returnValue;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *outputStringBuf [2];\n  undefined4 maxOutputLength;\n  undefined2 outputBufSize;\n  undefined2 maxFormatLength;\n  char *outputStringPtr;\n  undefined4 maxOutputLengthCopy;\n  char *formatStringPtr;\n  undefined4 unimportantStackValue1;\n  undefined4 unimportantStackValue2;\n  \n  outputBufSize = 0x208;\n  maxOutputLength = 0x7fffffff;\n  maxOutputLengthCopy = 0x7fffffff;\n  maxFormatLength = 0xffff;\n  outputStringBuf[0] = outputString;\n  outputStringPtr = outputString;\n  formatStringPtr = formatString;\n  unimportantStackValue1 = in_r2;\n  unimportantStackValue2 = in_r3;\n  returnValue = _svfiprintf_r(_impure_ptr,outputStringBuf,formatString);\n  *outputStringBuf[0] = '\\0';\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004ffc": "print_formatted_string_08004ffc",
                "__s": "outputString",
                "__format": "formatString",
                "local_78": "outputStringBuf",
                "local_70": "maxOutputLength",
                "local_6c": "outputBufSize",
                "local_6a": "maxFormatLength",
                "local_68": "outputStringPtr",
                "local_64": "maxOutputLengthCopy",
                "pcStack_c": "formatStringPtr",
                "uStack_8": "unimportantStackValue1",
                "uStack_4": "unimportantStackValue2",
                "iVar1": "returnValue"
            },
            "calling": [
                "serialInt"
            ],
            "called": [
                "_svfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005044": {
            "entrypoint": "0x08005044",
            "current_name": "copy_and_resize_buffer_08005044",
            "code": "\nundefined4 copy_and_resize_buffer_08005044(undefined4 *error_code,void **buffer,void *source_data,void *source_data_length)\n\n{\n  void *new_buffer;\n  void *existing_buffer;\n  size_t buffer_difference;\n  \n  existing_buffer = buffer[2];\n  if ((existing_buffer <= source_data_length) && ((*(ushort *)(buffer + 3) & 0x480) != 0)) {\n    buffer_difference = (int)*buffer - (int)buffer[4];\n    existing_buffer = (void *)((uint)((int)buffer[5] * 3) / 2);\n    new_buffer = (void *)((int)source_data_length + buffer_difference + 1);\n    if (existing_buffer < new_buffer) {\n      existing_buffer = new_buffer;\n    }\n    if ((int)((uint)*(ushort *)(buffer + 3) << 0x15) < 0) {\n      new_buffer = (void *)_malloc_r(error_code,existing_buffer);\n      if (new_buffer == (void *)0x0) {\nLAB_0800508a:\n        *error_code = 0xc;\n        *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x40;\n        return 0xffffffff;\n      }\n      memcpy(new_buffer,buffer[4],buffer_difference);\n      *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfb7f | 0x80;\n    }\n    else {\n      new_buffer = (void *)_realloc_r(error_code,buffer[4],existing_buffer);\n      if (new_buffer == (void *)0x0) {\n        _free_r(error_code,buffer[4]);\n        goto LAB_0800508a;\n      }\n    }\n    buffer[4] = new_buffer;\n    *buffer = (void *)((int)new_buffer + buffer_difference);\n    buffer[5] = existing_buffer;\n    buffer[2] = (void *)((int)existing_buffer - buffer_difference);\n    existing_buffer = source_data_length;\n  }\n  if (source_data_length <= existing_buffer) {\n    existing_buffer = source_data_length;\n  }\n  memmove(*buffer,source_data,(size_t)existing_buffer);\n  buffer[2] = (void *)((int)buffer[2] - (int)existing_buffer);\n  *buffer = (void *)((int)existing_buffer + (int)*buffer);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005044": "copy_and_resize_buffer_08005044",
                "param_1": "error_code",
                "param_2": "buffer",
                "param_3": "source_data",
                "param_4": "source_data_length",
                "pvVar1": "new_buffer",
                "pvVar2": "existing_buffer",
                "__n": "buffer_difference"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050fc": {
            "entrypoint": "0x080050fc",
            "current_name": "format_string_080050fc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005294) */\n\nint formatString_080050fc(undefined4 *paramList,int *flags,byte *format,int *argList)\n\n{\n  bool isNumber;\n  int numValue;\n  int result;\n  void *ptrValue;\n  int *argCount;\n  byte *currentChar;\n  byte *nextChar;\n  int unaff_r9;\n  int *argPtr;\n  uint flagBits;\n  int width;\n  undefined4 length;\n  int precision;\n  int totalChars;\n  byte formatChar;\n  undefined flag1;\n  undefined flag2;\n  undefined signFlag;\n  undefined4 padding;\n  \n  argPtr = argList;\n  if (((int)((uint)*(ushort *)(flags + 3) << 0x18) < 0) && (flags[4] == 0)) {\n    numValue = _malloc_r(paramList,0x40);\n    *flags = numValue;\n    flags[4] = numValue;\n    if (numValue == 0) {\n      *paramList = 0xc;\n      return -1;\n    }\n    flags[5] = 0x40;\n  }\n  totalChars = 0;\n  flag1 = 0x20;\n  flag2 = 0x30;\n  currentChar = format;\nLAB_08005146:\n  nextChar = currentChar;\n  if (*nextChar != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  currentChar = nextChar + 1;\n  if (*nextChar != 0x25) goto LAB_08005146;\nLAB_08005150:\n  numValue = (int)nextChar - (int)format;\n  if (numValue != 0) {\n    result = __ssputs_r(paramList,flags,format,numValue);\n    if (result == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(flags + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalChars;\n    }\n    totalChars = totalChars + numValue;\n  }\n  if (*nextChar == 0) goto LAB_080052ac;\n  flagBits = 0;\n  precision = 0;\n  width = -1;\n  length = 0;\n  signFlag = 0;\n  padding = 0;\n  currentChar = nextChar + 1;\n  while( true ) {\n    ptrValue = memchr(&DAT_08007379,(uint)*currentChar,5);\n    format = currentChar + 1;\n    if (ptrValue == (void *)0x0) break;\n    flagBits = 1 << ((int)ptrValue + 0xf7ff8c87U & 0xff) | flagBits;\n    currentChar = format;\n  }\n  if ((int)(flagBits << 0x1b) < 0) {\n    signFlag = 0x20;\n  }\n  if ((int)(flagBits << 0x1c) < 0) {\n    signFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    argCount = argPtr + 1;\n    numValue = *argPtr;\n    argPtr = argCount;\n    if (numValue < 0) {\n      precision = -numValue;\n      flagBits = flagBits | 2;\n      goto LAB_080051fc;\n    }\n  }\n  else {\n    isNumber = false;\n    numValue = precision;\n    format = currentChar;\n    while( true ) {\n      if (9 < *format - 0x30) break;\n      numValue = numValue * 10 + (*format - 0x30);\n      isNumber = true;\n      format = format + 1;\n    }\n    if (!isNumber) goto LAB_080051fc;\n  }\n  precision = numValue;\nLAB_080051fc:\n  if (*format == 0x2e) {\n    if (format[1] == 0x2a) {\n      format = format + 2;\n      argCount = argPtr + 1;\n      width = *argPtr;\n      argPtr = argCount;\n      if (width < 0) {\n        width = -1;\n      }\n    }\n    else {\n      isNumber = false;\n      numValue = 0;\n      width = 0;\n      while( true ) {\n        format = format + 1;\n        if (9 < *format - 0x30) break;\n        numValue = numValue * 10 + (*format - 0x30);\n        isNumber = true;\n      }\n      if (isNumber) {\n        width = numValue;\n      }\n    }\n  }\n  ptrValue = memchr(&DAT_0800737f,(uint)*format,3);\n  if (ptrValue != (void *)0x0) {\n    format = format + 1;\n    flagBits = flagBits | 0x40 << ((int)ptrValue + 0xf7ff8c81U & 0xff);\n  }\n  formatChar = *format;\n  format = format + 1;\n  ptrValue = memchr(\"efgEFG\",(uint)formatChar,6);\n  if (ptrValue == (void *)0x0) {\n    unaff_r9 = _printf_i(paramList,&flagBits,flags,0x8005045,&argPtr);\n    if (unaff_r9 == -1) goto LAB_080052ac;\n  }\n  else {\n    argPtr = (int *)(((int)argPtr + 7U & 0xfffffff8) + 8);\n  }\n  totalChars = totalChars + unaff_r9;\n  currentChar = format;\n  goto LAB_08005146;\n}\n\n",
            "renaming": {
                "FUN_080050fc": "format_string_080050fc",
                "param_1": "paramList",
                "param_2": "flags",
                "param_3": "format",
                "param_4": "argList",
                "bVar1": "isNumber",
                "iVar2": "numValue",
                "iVar3": "result",
                "pvVar4": "ptrValue",
                "piVar5": "argCount",
                "pbVar6": "currentChar",
                "pbVar7": "nextChar",
                "local_8c": "argPtr",
                "local_88": "flagBits",
                "local_84": "width",
                "local_80": "length",
                "local_7c": "precision",
                "local_74": "totalChars",
                "local_70": "formatChar",
                "local_6f": "flag1",
                "local_6e": "flag2",
                "local_45": "signFlag",
                "local_30": "padding"
            },
            "calling": [
                "siprintf"
            ],
            "called": [
                "__ssputs_r",
                "memchr",
                "_malloc_r",
                "_printf_i"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052e4": {
            "entrypoint": "0x080052e4",
            "current_name": "validate_and_process_data_080052e4",
            "code": "\nundefined4\nvalidate_and_process_data_080052e4(undefined4 input_value,uint *data_array,uint *output_size,undefined4 config_value,code *callback_function)\n\n{\n  int counter;\n  int callback_result;\n  uint max_size;\n  uint offset;\n  bool is_condition_met;\n  \n  max_size = data_array[4];\n  if ((int)data_array[4] < (int)data_array[2]) {\n    max_size = data_array[2];\n  }\n  *output_size = max_size;\n  if (*(char *)((int)data_array + 0x43) != '\\0') {\n    *output_size = max_size + 1;\n  }\n  if ((int)(*data_array << 0x1a) < 0) {\n    *output_size = *output_size + 2;\n  }\n  if ((*data_array & 6) == 0) {\n    for (counter = 0; counter < (int)(data_array[3] - *output_size); counter = counter + 1) {\n      callback_result = (*callback_function)(input_value,config_value,(int)data_array + 0x19,1);\n      if (callback_result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  max_size = (uint)*(byte *)((int)data_array + 0x43);\n  if (max_size != 0) {\n    max_size = 1;\n  }\n  offset = max_size;\n  if ((int)(*data_array << 0x1a) < 0) {\n    *(undefined *)((int)data_array + max_size + 0x43) = 0x30;\n    offset = max_size + 2;\n    *(undefined *)((int)data_array + max_size + 0x44) = *(undefined *)((int)data_array + 0x45);\n  }\n  counter = (*callback_function)(input_value,config_value,(int)data_array + 0x43,offset);\n  if (counter != -1) {\n    max_size = data_array[3];\n    is_condition_met = (*data_array & 6) != 4;\n    if (is_condition_met) {\n      max_size = 0;\n    }\n    offset = 0;\n    if (!is_condition_met) {\n      max_size = max_size - *output_size;\n    }\n    if (!is_condition_met) {\n      max_size = max_size & ~((int)max_size >> 0x1f);\n    }\n    if ((int)data_array[4] < (int)data_array[2]) {\n      max_size = max_size + (data_array[2] - data_array[4]);\n    }\n    while( true ) {\n      if (max_size == offset) {\n        return 0;\n      }\n      counter = (*callback_function)(input_value,config_value,(int)data_array + 0x1a,1);\n      if (counter == -1) break;\n      offset = offset + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080052e4": "validate_and_process_data_080052e4",
                "param_1": "input_value",
                "param_2": "data_array",
                "param_3": "output_size",
                "param_4": "config_value",
                "param_5": "callback_function",
                "iVar1": "counter",
                "iVar2": "callback_result",
                "uVar3": "max_size",
                "uVar4": "offset",
                "bVar5": "is_condition_met"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "print_formatted_string_080053d4",
            "code": "\nuint print_formatted_string_080053d4(undefined4 format_string,uint *arg_list,undefined4 width,code *print_func,uint **arg_ptr)\n\n{\n  byte byte_value;\n  int result;\n  uint *ptr;\n  void *ptr_found;\n  int index;\n  char *hex_chars;\n  uint value;\n  uint **ptr_ptr;\n  char **str_ptr;\n  uint count;\n  uint temp;\n  char *char_ptr;\n  char *string;\n  uint result_array [2];\n  \n  byte_value = *(byte *)(arg_list + 6);\n  string = (char *)((int)arg_list + 0x43);\n  if (byte_value != 0x6e) {\n    if (byte_value < 0x6f) {\n      if (byte_value != 99) {\n        if (byte_value < 100) {\n          if (byte_value == 0) goto LAB_0800558e;\n          if (byte_value != 0x58) goto LAB_08005404;\n          *(undefined *)((int)arg_list + 0x45) = 0x58;\n          hex_chars = \"0123456789ABCDEF\";\nLAB_0800551e:\n          value = *arg_list;\n          ptr = *arg_ptr;\n          *arg_ptr = ptr + 1;\n          if (((value & 0x80) == 0) && ((int)(value << 0x19) < 0)) {\n            count = (uint)*(ushort *)ptr;\n          }\n          else {\n            count = *ptr;\n          }\n          if ((int)(value << 0x1f) < 0) {\n            *arg_list = value | 0x20;\n          }\n          if (count == 0) {\n            *arg_list = *arg_list & 0xffffffdf;\n          }\n          value = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)arg_list + 0x43) = 0;\n        }\n        else {\n          if ((byte_value != 100) && (byte_value != 0x69)) goto LAB_08005404;\n          count = *arg_list;\n          ptr = *arg_ptr;\n          if ((count & 0x80) == 0) {\n            *arg_ptr = ptr + 1;\n            if ((count & 0x40) == 0) goto LAB_08005424;\n            count = (uint)(short)*(ushort *)ptr;\n          }\n          else {\n            *arg_ptr = ptr + 1;\nLAB_08005424:\n            count = *ptr;\n          }\n          if ((int)count < 0) {\n            count = -count;\n            *(undefined *)((int)arg_list + 0x43) = 0x2d;\n          }\n          hex_chars = \"0123456789ABCDEF\";\n          value = 10;\n        }\n        temp = arg_list[1];\n        arg_list[2] = temp;\n        char_ptr = string;\n        if ((int)temp < 0) {\n          if (count != 0) goto LAB_08005552;\nLAB_08005600:\n          *(char *)((int)arg_list + 0x42) = *hex_chars;\n          char_ptr = (char *)((int)arg_list + 0x42);\n        }\n        else {\n          *arg_list = *arg_list & 0xfffffffb;\n          if (count == 0) {\n            if (temp != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              temp = count / value;\n              char_ptr = char_ptr + -1;\n              *char_ptr = hex_chars[count - value * temp];\n              count = temp;\n            } while (temp != 0);\n          }\n        }\n        if (((value == 8) && ((int)(*arg_list << 0x1f) < 0)) && ((int)arg_list[1] <= (int)arg_list[4]))\n        {\n          char_ptr[-1] = '0';\n          char_ptr = char_ptr + -1;\n        }\n        arg_list[4] = (int)string - (int)char_ptr;\n        string = char_ptr;\n        goto LAB_080054fa;\n      }\n      ptr = *arg_ptr;\n      *arg_ptr = ptr + 1;\n      *(char *)((int)arg_list + 0x42) = (char)*ptr;\nLAB_08005464:\n      string = (char *)((int)arg_list + 0x42);\n      count = 1;\n    }\n    else {\n      if (byte_value != 0x73) {\n        if (byte_value < 0x74) {\n          if (byte_value == 0x6f) {\nLAB_0800548a:\n            count = *arg_list;\n            ptr = *arg_ptr;\n            if ((count & 0x80) == 0) {\n              *arg_ptr = ptr + 1;\n              if ((count & 0x40) == 0) goto LAB_08005498;\n              count = (uint)*(ushort *)ptr;\n            }\n            else {\n              *arg_ptr = ptr + 1;\nLAB_08005498:\n              count = *ptr;\n            }\n            if (byte_value == 0x6f) {\n              value = 8;\n            }\n            else {\n              value = 10;\n            }\n            hex_chars = \"0123456789ABCDEF\";\n            goto LAB_080054b4;\n          }\n          if (byte_value == 0x70) {\n            *arg_list = *arg_list | 0x20;\nLAB_0800544a:\n            hex_chars = \"0123456789abcdef\";\n            *(undefined *)((int)arg_list + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (byte_value == 0x75) goto LAB_0800548a;\n          if (byte_value == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)arg_list + 0x42) = byte_value;\n        goto LAB_08005464;\n      }\n      str_ptr = (char **)*arg_ptr;\n      *arg_ptr = (uint *)(str_ptr + 1);\n      string = *str_ptr;\n      ptr_found = memchr(string,0,arg_list[1]);\n      if (ptr_found != (void *)0x0) {\n        arg_list[1] = (int)ptr_found - (int)string;\n      }\n      count = arg_list[1];\n    }\n    arg_list[4] = count;\n    *(undefined *)((int)arg_list + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  count = *arg_list;\n  ptr_ptr = (uint **)*arg_ptr;\n  value = arg_list[5];\n  if ((count & 0x80) == 0) {\n    *arg_ptr = (uint *)(ptr_ptr + 1);\n    ptr = *ptr_ptr;\n    if ((count & 0x40) == 0) goto LAB_0800557a;\n    *(short *)ptr = (short)value;\n  }\n  else {\n    *arg_ptr = (uint *)(ptr_ptr + 1);\n    ptr = *ptr_ptr;\nLAB_0800557a:\n    *ptr = value;\n  }\nLAB_0800558e:\n  arg_list[4] = 0;\nLAB_080054fa:\n  result = _printf_common(format_string,arg_list,result_array,width,print_func);\n  if ((result == -1) || (result = (*print_func)(format_string,width,string,arg_list[4]), result == -1)) {\nLAB_0800550e:\n    count = 0xffffffff;\n  }\n  else {\n    if ((int)(*arg_list << 0x1e) < 0) {\n      for (result = 0; result < (int)(arg_list[3] - result_array[0]); result = result + 1) {\n        index = (*print_func)(format_string,width,(int)arg_list + 0x19,1);\n        if (index == -1) goto LAB_0800550e;\n      }\n    }\n    count = arg_list[3];\n    if ((int)arg_list[3] < (int)result_array[0]) {\n      count = result_array[0];\n    }\n  }\n  return count;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "print_formatted_string_080053d4",
                "param_1": "format_string",
                "param_2": "arg_list",
                "param_3": "width",
                "param_4": "print_func",
                "param_5": "arg_ptr",
                "bVar1": "byte_value",
                "iVar2": "result",
                "puVar3": "ptr",
                "pvVar4": "ptr_found",
                "iVar5": "index",
                "pcVar6": "hex_chars",
                "uVar7": "value",
                "ppuVar8": "ptr_ptr",
                "ppcVar9": "str_ptr",
                "uVar10": "count",
                "uVar11": "temp",
                "pcVar12": "char_ptr",
                "__s": "string",
                "local_24": "result_array"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005614": {
            "entrypoint": "0x08005614",
            "current_name": "find_byte_in_memory_08005614",
            "code": "\nvoid * find_byte_in_memory_08005614(void *memory_block,int target_byte,size_t block_size)\n\n{\n  byte *current_byte;\n  byte *found_byte;\n  \n  current_byte = (byte *)memory_block;\n  do {\n    found_byte = current_byte;\n    if (found_byte == (byte *)(block_size + (int)memory_block)) {\n      return (void *)0x0;\n    }\n    current_byte = found_byte + 1;\n  } while ((uint)*found_byte != (target_byte & 0xffU));\n  return found_byte;\n}\n\n",
            "renaming": {
                "FUN_08005614": "find_byte_in_memory_08005614",
                "__s": "memory_block",
                "__c": "target_byte",
                "__n": "block_size",
                "pbVar1": "current_byte",
                "pbVar2": "found_byte"
            },
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005630": {
            "entrypoint": "0x08005630",
            "current_name": "copy_memory_08005630",
            "code": "\nvoid * copy_memory_08005630(void *destination,void *source,size_t length)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(length + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005630": "copy_memory_08005630",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005646": {
            "entrypoint": "0x08005646",
            "current_name": "copy_memory_backward_08005646",
            "code": "\nvoid * copy_memory_backward_08005646(void *destination,void *source,size_t length)\n\n{\n  undefined *dest_ptr;\n  int remaining_length;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)source + length);\n  if ((source < destination) && (destination < src_ptr)) {\n    dest_ptr = (undefined *)((int)destination + length);\n    remaining_length = length - (int)src_ptr;\n    while (src_ptr + remaining_length != (undefined *)0x0) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n    return destination;\n  }\n  dest_ptr = (undefined *)((int)destination + -1);\n  for (; (undefined *)source != src_ptr; source = (void *)((int)source + 1)) {\n    dest_ptr = dest_ptr + 1;\n    *dest_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005646": "copy_memory_backward_08005646",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_ptr",
                "iVar2": "remaining_length",
                "puVar3": "src_ptr"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800567c": {
            "entrypoint": "0x0800567c",
            "current_name": "allocate_memory_0800567c",
            "code": "\nvoid allocateMemory_0800567c(undefined4 *errorFlag,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int **temp1;\n  int **temp2;\n  int **temp3;\n  int *temp4;\n  int **temp5;\n  int **temp6;\n  \n  if (size == 0) {\n    return;\n  }\n  temp6 = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    temp6 = (int **)((int)temp6 + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  temp3 = (int **)&freeListHead;\n  if (freeListHead == (int **)0x0) {\n    temp6[1] = (int *)0x0;\n    temp2 = temp1;\n    freeListHead = temp6;\n  }\n  else {\n    temp3 = freeListHead;\n    if (temp6 < freeListHead) {\n      temp2 = (int **)*temp6;\n      temp3 = (int **)((int)temp6 + (int)temp2);\n      if (freeListHead == temp3) {\n        temp4 = *freeListHead;\n        freeListHead = (int **)freeListHead[1];\n        temp3 = (int **)((int)temp4 + (int)temp2);\n        *temp6 = (int *)temp3;\n      }\n      temp6[1] = (int *)freeListHead;\n      freeListHead = temp6;\n    }\n    else {\n      do {\n        temp5 = temp3;\n        temp3 = (int **)temp5[1];\n        if (temp3 == (int **)0x0) break;\n      } while (temp3 <= temp6);\n      temp2 = (int **)*temp5;\n      if ((int **)((int)temp5 + (int)temp2) == temp6) {\n        temp2 = (int **)((int)temp2 + (int)*temp6);\n        *temp5 = (int *)temp2;\n        if (temp3 == (int **)((int)temp5 + (int)temp2)) {\n          temp4 = *temp3;\n          temp3 = (int **)temp3[1];\n          temp2 = (int **)((int)temp2 + (int)temp4);\n          *temp5 = (int *)temp2;\n          temp5[1] = (int *)temp3;\n        }\n      }\n      else if (temp6 < (int **)((int)temp5 + (int)temp2)) {\n        *errorFlag = 0xc;\n      }\n      else {\n        temp2 = (int **)((int)temp6 + (int)*temp6);\n        if (temp3 == temp2) {\n          temp4 = *temp3;\n          temp3 = (int **)temp3[1];\n          temp2 = (int **)((int)temp4 + (int)*temp6);\n          *temp6 = (int *)temp2;\n        }\n        temp6[1] = (int *)temp3;\n        temp5[1] = (int *)temp6;\n      }\n    }\n  }\n  __malloc_unlock(errorFlag,temp2,temp3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800567c": "allocate_memory_0800567c",
                "param_1": "errorFlag",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "extraout_r1": "temp1",
                "ppiVar1": "temp2",
                "ppiVar2": "temp3",
                "piVar3": "temp4",
                "ppiVar4": "temp5",
                "ppiVar5": "temp6",
                "__malloc_free_list": "freeListHead"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "allocate_memory_block_08005714",
            "code": "\nuint allocateMemoryBlock_08005714(undefined4 *size,uint alignment)\n\n{\n  uint *currentBlock;\n  int remainingSize;\n  uint *previousBlock;\n  uint sizeDifference;\n  uint *newBlock;\n  uint allocatedSize;\n  \n  allocatedSize = (alignment + 3 & 0xfffffffc) + 8;\n  if (allocatedSize < 0xc) {\n    allocatedSize = 0xc;\n  }\n  if (((int)allocatedSize < 0) || (allocatedSize < alignment)) {\n    *size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    currentBlock = __malloc_free_list;\n    newBlock = __malloc_free_list;\n    while (previousBlock = currentBlock, previousBlock != (uint *)0x0) {\n      sizeDifference = *previousBlock - allocatedSize;\n      if (-1 < (int)sizeDifference) {\n        if (sizeDifference < 0xc) {\n          if (newBlock == previousBlock) {\n            currentBlock = (uint *)newBlock[1];\n            __malloc_free_list = currentBlock;\n          }\n          else {\n            currentBlock = (uint *)previousBlock[1];\n          }\n          if (newBlock != previousBlock) {\n            newBlock[1] = (uint)currentBlock;\n            newBlock = previousBlock;\n          }\n        }\n        else {\n          *previousBlock = sizeDifference;\n          *(uint *)((int)previousBlock + sizeDifference) = allocatedSize;\n          newBlock = (uint *)((int)previousBlock + sizeDifference);\n        }\n        goto LAB_08005778;\n      }\n      newBlock = previousBlock;\n      currentBlock = (uint *)previousBlock[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(size);\n    }\n    currentBlock = (uint *)_sbrk_r(size,allocatedSize);\n    if ((currentBlock != (uint *)0xffffffff) &&\n       ((newBlock = (uint *)((int)currentBlock + 3U & 0xfffffffc), currentBlock == newBlock ||\n        (remainingSize = _sbrk_r(size,(int)newBlock - (int)currentBlock), remainingSize != -1)))) {\n      *newBlock = allocatedSize;\nLAB_08005778:\n      __malloc_unlock(size);\n      allocatedSize = (int)newBlock + 0xbU & 0xfffffff8;\n      remainingSize = allocatedSize - (int)(newBlock + 1);\n      if (remainingSize != 0) {\n        *(int *)((int)newBlock + remainingSize) = -remainingSize;\n        return allocatedSize;\n      }\n      return allocatedSize;\n    }\n    *size = 0xc;\n    __malloc_unlock(size);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005714": "allocate_memory_block_08005714",
                "param_1": "size",
                "param_2": "alignment",
                "puVar1": "currentBlock",
                "iVar2": "remainingSize",
                "puVar3": "previousBlock",
                "uVar4": "sizeDifference",
                "puVar5": "newBlock",
                "uVar6": "allocatedSize"
            },
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057d0": {
            "entrypoint": "0x080057d0",
            "current_name": "copy_or_allocate_memory_080057d0",
            "code": "\nvoid * copyOrAllocateMemory_080057d0(undefined4 param,void *source,uint size,undefined4 param_4)\n\n{\n  void *destination;\n  uint usableSize;\n  \n  if (source != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      destination = (void *)0x0;\n    }\n    else {\n      usableSize = _malloc_usable_size_r();\n      destination = source;\n      if ((usableSize < size) && (destination = (void *)_malloc_r(param,size), destination != (void *)0x0))\n      {\n        memcpy(destination,source,size);\n        _free_r(param,source);\n      }\n    }\n    return destination;\n  }\n  destination = (void *)_malloc_r(param,size,size,param_4);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080057d0": "copy_or_allocate_memory_080057d0",
                "param_1": "param",
                "param_2": "source",
                "param_3": "size",
                "pvVar1": "destination",
                "uVar2": "usableSize"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800581c": {
            "entrypoint": "0x0800581c",
            "current_name": "allocate_memory_0800581c",
            "code": "\nvoid allocateMemory_0800581c(int *errorFlag,intptr_t memorySize)\n\n{\n  void *memoryBlock;\n  \n  errno = 0;\n  memoryBlock = _sbrk(memorySize);\n  if ((memoryBlock == (void *)0xffffffff) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "errorFlag",
                "param_2": "memorySize",
                "pvVar1": "memoryBlock"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "FUNC_0800583c",
            "code": "\nvoid FUNC_0800583c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "FUNC_0800583c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800583e": {
            "entrypoint": "0x0800583e",
            "current_name": "FUNC_0800583e",
            "code": "\nvoid FUNC_0800583e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583e": "FUNC_0800583e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_result_08005840",
            "code": "\nint calculateResult_08005840(undefined4 result,int inputOffset)\n\n{\n  int updatedOffset;\n  \n  updatedOffset = *(int *)(inputOffset + -4) + -4;\n  if (*(int *)(inputOffset + -4) < 0) {\n    updatedOffset = updatedOffset + *(int *)(inputOffset + updatedOffset);\n  }\n  return updatedOffset;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "param_1": "result",
                "param_2": "inputOffset",
                "iVar1": "updatedOffset"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005854": {
            "entrypoint": "0x08005854",
            "current_name": "calculate_asin_08005854",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080058d4) */\n\ndouble calculate_asin_08005854(double input_value)\n\n{\n  int comparison_result;\n  undefined4 *errno_ptr;\n  double result;\n  double temp1;\n  double temp2;\n  double temp3;\n  double temp4;\n  int stack_value1;\n  char *stack_value2;\n  \n  result = (double)__ieee754_asin();\n  if ((__fdlib_version != -1) && (comparison_result = __unorddf2(), result = temp1, comparison_result == 0)) {\n    fabs((double)CONCAT44(stack_value2,stack_value1));\n    comparison_result = __aeabi_dcmpgt();\n    result = temp2;\n    if ((comparison_result != 0) &&\n       ((nan(\"\"), __fdlib_version == '\\x02' ||\n        (comparison_result = matherr((exception *)&stack0xffffffb8), result = temp4, comparison_result == 0)))) {\n      errno_ptr = (undefined4 *)__errno();\n      *errno_ptr = 0x21;\n      result = temp3;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005854": "calculate_asin_08005854",
                "__x": "input_value",
                "iVar1": "comparison_result",
                "puVar2": "errno_ptr",
                "dVar3": "result",
                "extraout_d0": "temp1",
                "extraout_d0_00": "temp2",
                "extraout_d0_01": "temp3",
                "extraout_d0_02": "temp4",
                "in_stack_ffffffb8": "stack_value1",
                "in_stack_ffffffbc": "stack_value2"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__errno",
                "fabs",
                "matherr",
                "__aeabi_dcmpgt",
                "nan",
                "__ieee754_asin",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058fc": {
            "entrypoint": "0x080058fc",
            "current_name": "FUN_080058fc",
            "code": "\nundefined8 __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  undefined4 uVar1;\n  undefined4 extraout_r1;\n  int extraout_r1_00;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  uVar5 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar5 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar3 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar3 | (-param_1 | param_1) >> 0x1f))) {\n    uVar6 = __aeabi_dadd(param_1,param_2);\n    return uVar6;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    atan(param_5);\n    return CONCAT44(extraout_r1,param_1);\n  }\n  uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((param_1 | uVar3) == 0) {\n    if (uVar2 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (uVar2 != 3) {\n      return CONCAT44(param_2,param_1);\n    }\nLAB_0800613e:\n    uVar6 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((param_3 | uVar5) != 0) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 0x7ff00000) {\n          if (uVar2 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (uVar2 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (uVar2 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (uVar2 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (uVar2 != 3) {\n          if (uVar2 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (uVar3 != 0x7ff00000) {\n        iVar4 = (int)(uVar3 - uVar5) >> 0x14;\n        if (iVar4 < 0x3d) {\n          if (((int)param_4 < 0) && (iVar4 + 0x3c < 0 != SCARRY4(iVar4,0x3c))) {\n            uVar1 = 0;\n            iVar4 = 0;\n          }\n          else {\n            uVar1 = __divdf3(param_1,param_2);\n            fabs((double)CONCAT44(unaff_r4,param_4));\n            atan((double)CONCAT44(unaff_r4,param_4));\n            iVar4 = extraout_r1_00;\n          }\n        }\n        else {\n          uVar1 = 0x54442d18;\n          iVar4 = 0x3ff921fb;\n        }\n        if (uVar2 == 1) {\n          return CONCAT44(iVar4 + -0x80000000,uVar1);\n        }\n        if (uVar2 == 2) {\n          uVar7 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar6 = 0x400921fb54442d18;\n        }\n        else {\n          if (uVar2 == 0) {\n            return CONCAT44(iVar4,uVar1);\n          }\n          uVar6 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar7 = 0x400921fb54442d18;\n        }\n        uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                         (int)((ulonglong)uVar7 >> 0x20));\n        return uVar6;\n      }\n    }\n    if ((int)param_2 < 0) {\n      uVar6 = 0xbff921fb54442d18;\n    }\n    else {\n      uVar6 = 0x3ff921fb54442d18;\n    }\n  }\n  return uVar6;\n}\n\n",
            "renaming": {},
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "calculate_pow_08005900",
            "code": "\ndouble calculate_pow_08005900(double base,double exponent)\n\n{\n  char version;\n  int comparison;\n  int *errno_ptr;\n  undefined4 *extraout_ptr;\n  int finite_check;\n  undefined4 extra_result_1;\n  undefined4 extra_result_2;\n  undefined4 extraout;\n  double default_result_1;\n  double default_result_2;\n  double default_result_3;\n  double default_result_4;\n  double default_result_5;\n  double default_result_6;\n  double default_result_7;\n  double default_result_8;\n  double default_result_9;\n  double default_result_10;\n  double default_result_11;\n  double default_result_12;\n  double default_result_13;\n  double default_result_14;\n  double result;\n  undefined8 mul_result;\n  undefined exception_info [24];\n  undefined8 default_result;\n  int error_code;\n  \n  result = (double)__ieee754_pow();\n  version = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return default_result_1;\n  }\n  comparison = __unorddf2();\n  if (comparison != 0) {\n    return default_result_2;\n  }\n  comparison = __unorddf2();\n  if (comparison != 0) {\n    comparison = __aeabi_dcmpeq();\n    if (comparison == 0) {\n      return default_result_3;\n    }\n    exception_info._0_4_ = 1;\n    exception_info._4_4_ = \"pow\";\n    default_result = 1.0;\n    error_code = 0;\n    if (version == '\\x02') {\n      return default_result_3;\n    }\n    goto LAB_08005978;\n  }\n  comparison = __aeabi_dcmpeq();\n  if (comparison == 0) {\n    comparison = finite(result);\n    if ((comparison == 0) && (finite_check = finite(result), finite_check != 0)) {\n      finite_check = finite(result);\n      if (finite_check == 0) goto LAB_08005b4c;\n      error_code = __unorddf2(SUB84(result,0),(int)((ulonglong)result >> 0x20));\n      version = __fdlib_version;\n      if (error_code != 0) {\n        exception_info._4_4_ = \"pow\";\n        exception_info._0_4_ = 1;\n        error_code = comparison;\n        if (__fdlib_version == '\\0') goto LAB_08005a22;\n        default_result = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      exception_info._4_4_ = \"pow\";\n      exception_info._0_4_ = 3;\n      if (__fdlib_version != '\\0') {\n        default_result._0_4_ = 0;\n        default_result._4_4_ = 0x7ff00000;\n        comparison = __aeabi_dcmplt();\n        if (comparison != 0) {\n          mul_result = __muldf3();\n          extraout = (int)mul_result;\n          rint(result);\n          comparison = __aeabi_dcmpeq((int)mul_result,(int)((ulonglong)mul_result >> 0x20),extraout,extra_result_2);\n          if (comparison == 0) {\n            default_result._0_4_ = 0;\n            default_result._4_4_ = 0xfff00000;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      default_result._0_4_ = 0xe0000000;\n      default_result._4_4_ = 0x47efffff;\n      comparison = __aeabi_dcmplt();\n      if (comparison != 0) {\n        mul_result = __muldf3();\n        extraout = (int)mul_result;\n        rint(result);\n        comparison = __aeabi_dcmpeq((int)mul_result,(int)((ulonglong)mul_result >> 0x20),extraout,extra_result_1);\n        if (comparison == 0) {\n          default_result._0_4_ = 0xe0000000;\n          default_result._4_4_ = 0xc7efffff;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      comparison = matherr((exception *)exception_info);\n      result = default_result_14;\n      if (comparison != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      comparison = __aeabi_dcmpeq(SUB84(result,0),(int)((ulonglong)result >> 0x20),0,0);\n      if (comparison == 0) {\n        return default_result_11;\n      }\n      comparison = finite(result);\n      if (comparison == 0) {\n        return default_result_12;\n      }\n      comparison = finite(result);\n      if (comparison == 0) {\n        return default_result_13;\n      }\n      exception_info._0_4_ = 4;\n      exception_info._4_4_ = \"pow\";\n      error_code = 0;\n      default_result._0_4_ = 0;\n      default_result._4_4_ = 0;\nLAB_08005afa:\n      if (__fdlib_version != '\\x02') goto LAB_08005b98;\n    }\n    extraout_ptr = (undefined4 *)__errno();\n    extraout = 0x22;\n    result = default_result_10;\n  }\n  else {\n    comparison = __aeabi_dcmpeq();\n    if (comparison == 0) {\n      comparison = finite(result);\n      if (comparison == 0) {\n        return default_result_7;\n      }\n      comparison = __aeabi_dcmplt();\n      if (comparison == 0) {\n        return default_result_8;\n      }\n      exception_info._0_4_ = 1;\n      exception_info._4_4_ = \"pow\";\n      error_code = 0;\n      if (__fdlib_version == '\\0') {\nLAB_08005a22:\n        exception_info._4_4_ = \"pow\";\n        exception_info._0_4_ = 1;\n        default_result = 0.0;\n        goto LAB_08005978;\n      }\n      default_result = -INFINITY;\n      error_code = 0;\n      version = __fdlib_version;\nLAB_08005a32:\n      if (version != '\\x02') goto LAB_08005978;\n    }\n    else {\n      exception_info._0_4_ = 1;\n      exception_info._4_4_ = \"pow\";\n      default_result = 0.0;\n      error_code = 0;\n      if (version != '\\0') {\n        default_result = 1.0;\n        result = default_result_5;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      comparison = matherr((exception *)exception_info);\n      result = default_result_4;\n      if (comparison != 0) goto LAB_080059d0;\n    }\n    extraout_ptr = (undefined4 *)__errno();\n    extraout = 0x21;\n    result = default_result_9;\n  }\n  *extraout_ptr = extraout;\nLAB_080059d0:\n  if (error_code != 0) {\n    errno_ptr = (int *)__errno();\n    *errno_ptr = error_code;\n    result = default_result_6;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005900": "calculate_pow_08005900",
                "__x": "base",
                "__y": "exponent",
                "cVar1": "version",
                "iVar2": "comparison",
                "piVar3": "errno_ptr",
                "puVar4": "extraout_ptr",
                "iVar5": "finite_check",
                "uVar6": "extraout",
                "dVar7": "result",
                "uVar8": "mul_result",
                "local_50": "exception_info",
                "local_38": "default_result",
                "local_30": "error_code",
                "extraout_r1": "extra_result_1",
                "extraout_r1_00": "extra_result_2",
                "extraout_d0": "default_result_1",
                "extraout_d0_00": "default_result_2",
                "extraout_d0_01": "default_result_3",
                "extraout_d0_02": "default_result_4",
                "extraout_d0_03": "default_result_5",
                "extraout_d0_04": "default_result_6",
                "extraout_d0_05": "default_result_7",
                "extraout_d0_06": "default_result_8",
                "extraout_d0_07": "default_result_9",
                "extraout_d0_08": "default_result_10",
                "extraout_d0_09": "default_result_11",
                "extraout_d0_10": "default_result_12",
                "extraout_d0_11": "default_result_13",
                "extraout_d0_12": "default_result_14"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__errno",
                "rint",
                "matherr",
                "__muldf3",
                "finite",
                "__ieee754_pow",
                "__unorddf2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc8": {
            "entrypoint": "0x08005bc8",
            "current_name": "calculate_root_08005bc8",
            "code": "\ndouble calculateRoot_08005bc8(double inputValue)\n\n{\n  char fdlibVersion;\n  int comparisonResult;\n  int *errnoPtr;\n  undefined4 *fdlibVersionPtr;\n  double result;\n  double errorCase1;\n  double errorCase2;\n  double tempResult1;\n  double errorCase3;\n  double errorCase4;\n  undefined exceptionDetails [24];\n  undefined8 exceptionValue;\n  int comparisonResult2;\n  \n  result = (double)__ieee754_sqrt();\n  fdlibVersion = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return result;\n  }\n  comparisonResult2 = __unorddf2();\n  if (comparisonResult2 != 0) {\n    return errorCase1;\n  }\n  comparisonResult = __aeabi_dcmplt();\n  if (comparisonResult == 0) {\n    return errorCase2;\n  }\n  exceptionDetails._0_4_ = 1;\n  exceptionDetails._4_4_ = \"sqrt\";\n  if (fdlibVersion == '\\0') {\n    exceptionValue = 0.0;\nLAB_08005c26:\n    comparisonResult = matherr((exception *)exceptionDetails);\n    result = tempResult1;\n    if (comparisonResult != 0) goto LAB_08005c2e;\n  }\n  else {\n    exceptionValue = (double)__divdf3(0,0,0,0);\n    if (fdlibVersion != '\\x02') goto LAB_08005c26;\n  }\n  fdlibVersionPtr = (undefined4 *)__errno();\n  *fdlibVersionPtr = 0x21;\n  result = errorCase4;\nLAB_08005c2e:\n  if (comparisonResult2 != 0) {\n    errnoPtr = (int *)__errno();\n    *errnoPtr = comparisonResult2;\n    result = errorCase3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005bc8": "calculate_root_08005bc8",
                "__x": "inputValue",
                "cVar1": "fdlibVersion",
                "iVar2": "comparisonResult",
                "piVar3": "errnoPtr",
                "puVar4": "fdlibVersionPtr",
                "dVar5": "result",
                "extraout_d0": "errorCase1",
                "extraout_d0_00": "errorCase2",
                "extraout_d0_01": "tempResult1",
                "extraout_d0_02": "errorCase3",
                "extraout_d0_03": "errorCase4",
                "local_50": "exceptionDetails",
                "local_38": "exceptionValue",
                "local_30": "comparisonResult2"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__ieee754_sqrt",
                "__divdf3",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c70": {
            "entrypoint": "0x08005c70",
            "current_name": "calculate_square_root_08005c70",
            "code": "\nundefined8 calculateSquareRoot_08005c70(uint input1,uint input2)\n\n{\n  int comparisonResult;\n  undefined4 extraOutput1;\n  undefined4 tempVar2;\n  undefined4 tempVar3;\n  undefined4 tempVar4;\n  undefined4 tempVar5;\n  undefined4 tempVar6;\n  undefined4 tempVar7;\n  uint unsignedInput2;\n  undefined8 result;\n  undefined8 tempVar10;\n  undefined8 tempVar11;\n  undefined4 stackParameter;\n  \n  result = CONCAT44(input2,input1);\n  unsignedInput2 = input2 & 0x7fffffff;\n  if (unsignedInput2 < 0x3ff00000) {\n    if (unsignedInput2 < 0x3fe00000) {\n      if (0x3e3fffff < unsignedInput2) {\n        tempVar10 = __muldf3(input1,input2,input1,input2);\n        tempVar7 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n        tempVar6 = (undefined4)tempVar10;\n        tempVar10 = __muldf3(tempVar6,tempVar7,0xdfdf709,0x3f023de1);\n        tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x7501b288,0x3f49efe0);\n        tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n        tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0xb5688f3b,0x3fa48228);\n        tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n        tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0xe884455,0x3fc9c155);\n        tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n        tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x3eb6f7d,0x3fd4d612);\n        tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n        tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x55555555,0x3fc55555);\n        tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n        tempVar11 = __muldf3(tempVar6,tempVar7,0xb12e9282,0x3fb3b8c5);\n        tempVar11 = __subdf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0x1b8d0159,0x3fe6066c);\n        tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar6,tempVar7);\n        tempVar11 = __aeabi_dadd((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0x9c598ac8,0x40002ae5);\n        tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar6,tempVar7);\n        tempVar11 = __subdf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0x1c8a2d4b,0x40033a27);\n        tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar6,tempVar7);\n        tempVar11 = __aeabi_dadd((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0,0x3ff00000);\n        tempVar10 = __divdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),(int)tempVar11,\n                          (int)((ulonglong)tempVar11 >> 0x20));\n        tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),input1,input2);\n        goto LAB_08005cba;\n      }\n      tempVar10 = __aeabi_dadd(input1,input2,0x8800759c,0x7e37e43c);\n      comparisonResult = __aeabi_dcmpgt((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0,0x3ff00000);\n      if (comparisonResult != 0) {\n        return result;\n      }\n    }\n    fabs((double)CONCAT44(input2,stackParameter));\n    result = __subdf3(0,0x3ff00000,input1,extraOutput1);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x3fe00000);\n    tempVar2 = (undefined4)((ulonglong)result >> 0x20);\n    tempVar6 = (undefined4)result;\n    result = __muldf3(tempVar6,tempVar2,0xdfdf709,0x3f023de1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x7501b288,0x3f49efe0);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tempVar6,tempVar2);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0xb5688f3b,0x3fa48228);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tempVar6,tempVar2);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0xe884455,0x3fc9c155);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tempVar6,tempVar2);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x3eb6f7d,0x3fd4d612);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tempVar6,tempVar2);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x55555555,0x3fc55555);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tempVar6,tempVar2);\n    tempVar3 = (undefined4)((ulonglong)result >> 0x20);\n    tempVar10 = __muldf3(tempVar6,tempVar2,0xb12e9282,0x3fb3b8c5);\n    tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x1b8d0159,0x3fe6066c);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar2);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x9c598ac8,0x40002ae5);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar2);\n    tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x1c8a2d4b,0x40033a27);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar2);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0,0x3ff00000);\n    tempVar4 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n    tempVar11 = __ieee754_sqrt(tempVar6,tempVar2);\n    tempVar5 = (undefined4)((ulonglong)tempVar11 >> 0x20);\n    tempVar7 = (undefined4)tempVar11;\n    if (unsignedInput2 < 0x3fef3333) {\n      result = __divdf3((int)result,tempVar3,(int)tempVar10,tempVar4);\n      tempVar10 = __aeabi_dadd(tempVar7,tempVar5,tempVar7,tempVar5);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar10,\n                       (int)((ulonglong)tempVar10 >> 0x20));\n      tempVar10 = __muldf3(0,tempVar5,0,tempVar5);\n      tempVar10 = __subdf3(tempVar6,tempVar2,(int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20));\n      tempVar11 = __aeabi_dadd(tempVar7,tempVar5,0,tempVar5);\n      tempVar10 = __divdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),(int)tempVar11,\n                        (int)((ulonglong)tempVar11 >> 0x20));\n      tempVar6 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n      tempVar10 = __aeabi_dadd((int)tempVar10,tempVar6,(int)tempVar10,tempVar6);\n      tempVar10 = __subdf3(0x33145c07,0x3c91a626,(int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar10,\n                       (int)((ulonglong)tempVar10 >> 0x20));\n      tempVar10 = __aeabi_dadd(0,tempVar5,0,tempVar5);\n      tempVar10 = __subdf3(0x54442d18,0x3fe921fb,(int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar10,\n                       (int)((ulonglong)tempVar10 >> 0x20));\n      tempVar6 = 0x3fe921fb;\n    }\n    else {\n      result = __divdf3((int)result,tempVar3,(int)tempVar10,tempVar4);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tempVar7,tempVar5);\n      result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),tempVar7,tempVar5);\n      tempVar6 = (undefined4)((ulonglong)result >> 0x20);\n      result = __aeabi_dadd((int)result,tempVar6,(int)result,tempVar6);\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x33145c07,0x3c91a626);\n      tempVar6 = 0x3ff921fb;\n    }\n    result = __subdf3(0x54442d18,tempVar6,(int)result,(int)((ulonglong)result >> 0x20));\n    if ((int)input2 < 1) {\n      result = CONCAT44((int)((ulonglong)result >> 0x20) + -0x80000000,(int)result);\n    }\n  }\n  else {\n    if ((unsignedInput2 + 0xc0100000 | input1) != 0) {\n      result = __subdf3(input1,input2,input1,input2);\n      tempVar6 = (undefined4)((ulonglong)result >> 0x20);\n      result = __divdf3((int)result,tempVar6,(int)result,tempVar6);\n      return result;\n    }\n    result = __muldf3(input1,input2,0x54442d18,0x3ff921fb);\n    tempVar10 = __muldf3(input1,input2,0x33145c07,0x3c91a626);\nLAB_08005cba:\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar10,\n                         (int)((ulonglong)tempVar10 >> 0x20));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005c70": "calculate_square_root_08005c70",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "comparisonResult",
                "extraout_r1": "extraOutput1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6",
                "uVar7": "tempVar7",
                "uVar8": "unsignedInput2",
                "uVar9": "result",
                "uVar10": "tempVar10",
                "uVar11": "tempVar11",
                "in_stack_ffffffc8": "stackParameter"
            },
            "calling": [
                "asin"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006070": {
            "entrypoint": "0x08006070",
            "current_name": "calculate_result_08006070",
            "code": "\nundefined8 calculate_result_08006070(uint input_1,uint input_2,uint input_3,uint input_4,double input_5)\n\n{\n  undefined4 value1;\n  undefined4 value2;\n  int value3;\n  undefined4 value4;\n  uint flag;\n  uint temp1;\n  int temp2;\n  uint temp3;\n  undefined8 result1;\n  undefined8 result2;\n  \n  temp3 = input_4 & 0x7fffffff;\n  if ((0x7ff00000 < (temp3 | (-input_3 | input_3) >> 0x1f)) ||\n     (temp1 = input_2 & 0x7fffffff, 0x7ff00000 < (temp1 | (-input_1 | input_1) >> 0x1f))) {\n    result1 = __aeabi_dadd(input_1,input_2);\n    return result1;\n  }\n  if ((input_4 + 0xc0100000 | input_3) == 0) {\n    atan(input_5);\n    return CONCAT44(value2,input_1);\n  }\n  flag = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n  if ((input_1 | temp1) == 0) {\n    if (flag == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (flag != 3) {\n      return CONCAT44(input_2,input_1);\n    }\nLAB_0800613e:\n    result1 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((input_3 | temp3) != 0) {\n      if (temp3 == 0x7ff00000) {\n        if (temp1 == 0x7ff00000) {\n          if (flag == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (flag == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (flag != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (flag == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (flag != 3) {\n          if (flag != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (temp1 != 0x7ff00000) {\n        temp2 = (int)(temp1 - temp3) >> 0x14;\n        if (temp2 < 0x3d) {\n          if (((int)input_4 < 0) && (temp2 + 0x3c < 0 != SCARRY4(temp2,0x3c))) {\n            value1 = 0;\n            temp2 = 0;\n          }\n          else {\n            value1 = __divdf3(input_1,input_2);\n            fabs((double)CONCAT44(value4,input_4));\n            atan((double)CONCAT44(value4,input_4));\n            temp2 = value3;\n          }\n        }\n        else {\n          value1 = 0x54442d18;\n          temp2 = 0x3ff921fb;\n        }\n        if (flag == 1) {\n          return CONCAT44(temp2 + -0x80000000,value1);\n        }\n        if (flag == 2) {\n          result2 = __subdf3(value1,temp2,0x33145c07,0x3ca1a626);\n          result1 = 0x400921fb54442d18;\n        }\n        else {\n          if (flag == 0) {\n            return CONCAT44(temp2,value1);\n          }\n          result1 = __subdf3(value1,temp2,0x33145c07,0x3ca1a626);\n          result2 = 0x400921fb54442d18;\n        }\n        result1 = __subdf3((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                         (int)((ulonglong)result2 >> 0x20));\n        return result1;\n      }\n    }\n    if ((int)input_2 < 0) {\n      result1 = 0xbff921fb54442d18;\n    }\n    else {\n      result1 = 0x3ff921fb54442d18;\n    }\n  }\n  return result1;\n}\n\n",
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "uVar1": "value1",
                "extraout_r1": "value2",
                "extraout_r1_00": "value3",
                "unaff_r4": "value4",
                "uVar2": "flag",
                "uVar3": "temp1",
                "iVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "result1",
                "uVar7": "result2"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006228": {
            "entrypoint": "0x08006228",
            "current_name": "calculate_floating_point_08006228",
            "code": "\nvoid calculateFloatingPoint_08006228(uint signBit,uint exponent,uint mantissa1,uint mantissa2)\n\n{\n  uint isZero;\n  undefined4 exponent1;\n  uint exponent2;\n  undefined4 extra1;\n  undefined4 extra2;\n  undefined4 extra3;\n  uint extra4;\n  undefined4 extra5;\n  undefined4 temp1;\n  int temp2;\n  uint temp3;\n  int temp4;\n  undefined4 temp5;\n  uint temp6;\n  undefined4 temp7;\n  uint absMantissa2;\n  undefined4 isZero1;\n  undefined4 isZero2;\n  undefined8 isZero3;\n  undefined8 isZero4;\n  undefined8 isZero5;\n  undefined8 isZero6;\n  longlong calculationResult;\n  ulonglong absMantissa1;\n  undefined8 subResult1;\n  undefined4 subResult2;\n  undefined4 extra6;\n  undefined4 remainder1;\n  undefined4 remainder2;\n  int shiftAmount;\n  \n  absMantissa2 = mantissa2 & 0x7fffffff;\n  if ((absMantissa2 | mantissa1) == 0) {\n    return;\n  }\n  temp6 = exponent & 0x7fffffff;\n  if (temp6 < 0x7ff00001) {\n    if (temp6 == 0x7ff00000) {\n      if (signBit == 0) {\n        if (0x7ff00000 < absMantissa2) goto LAB_08006278;\nLAB_08006262:\n        if ((absMantissa2 != 0x7ff00000) || (mantissa1 == 0)) {\n          if (-1 < (int)exponent) goto LAB_0800632a;\n          if (absMantissa2 < 0x43400000) {\n            if (absMantissa2 < 0x3ff00000) {\nLAB_0800632a:\n              isZero = 0;\n              goto LAB_080062ba;\n            }\n            temp2 = ((int)absMantissa2 >> 0x14) + -0x3ff;\n            if (0x14 < temp2) {\n              isZero = mantissa1 >> (0x34U - temp2 & 0xff);\n              if (mantissa1 == isZero << (0x34U - temp2 & 0xff)) {\n                isZero = 2 - (isZero & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (mantissa1 == 0) {\n              isZero = (int)absMantissa2 >> (0x14U - temp2 & 0xff);\n              if (absMantissa2 == isZero << (0x14U - temp2 & 0xff)) {\n                isZero = 2 - (isZero & 1);\n              }\n              else {\n                isZero = 0;\n              }\n              goto LAB_0800630c;\n            }\n            isZero = 0;\n          }\n          else {\n            isZero = 2;\nLAB_080062ba:\n            if (mantissa1 == 0) {\n              if (absMantissa2 == 0x7ff00000) {\n                return;\n              }\nLAB_0800630c:\n              if (absMantissa2 == 0x3ff00000) {\n                if (-1 < (int)mantissa2) {\n                  return;\n                }\n                isZero3 = 0x3ff0000000000000;\n                isZero4 = CONCAT44(exponent,signBit);\n                goto LAB_08006320;\n              }\n              if (mantissa2 == 0x40000000) goto LAB_0800634a;\n              if ((mantissa2 == 0x3fe00000) && (-1 < (int)exponent)) {\n                __ieee754_sqrt(signBit,exponent);\n                return;\n              }\n            }\n          }\n          temp3 = signBit;\n          fabs((double)CONCAT44(extra6,isZero));\n          absMantissa1 = CONCAT44(exponent,temp3) & 0x7fffffffffffffff;\n          if ((signBit == 0) && ((temp6 == 0 || ((exponent & 0x3fffffff) == 0x3ff00000)))) {\n            if ((int)mantissa2 < 0) {\n              __divdf3(0,0x3ff00000,temp3,exponent1);\n            }\n            if (-1 < (int)exponent) {\n              return;\n            }\n            if ((isZero | temp6 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            temp3 = 0xffffffff - ((int)exponent >> 0x1f);\n            if ((isZero | temp3) != 0) {\n              if (absMantissa2 < 0x41e00001) {\n                shiftAmount = 0;\n                if (temp6 < 0x100000) {\n                  absMantissa1 = __muldf3();\n                  shiftAmount = -0x35;\n                }\n                absMantissa2 = (uint)(absMantissa1 >> 0x20);\n                shiftAmount = ((int)absMantissa2 >> 0x14) + -0x3ff + shiftAmount;\n                absMantissa2 = absMantissa2 & 0xfffff;\n                temp6 = absMantissa2 | 0x3ff00000;\n                if (absMantissa2 < 0x3988f) {\nLAB_08006628:\n                  temp2 = 0;\n                }\n                else {\n                  if (0xbb679 < absMantissa2) {\n                    temp6 = temp6 - 0x100000;\n                    shiftAmount = shiftAmount + 1;\n                    goto LAB_08006628;\n                  }\n                  temp2 = 1;\n                }\n                temp4 = temp2 * 8;\n                temp5 = (&bp)[temp2 * 2];\n                subResult2 = (&DAT_080073c4)[temp2 * 2];\n                isZero3 = __subdf3();\n                isZero1 = (undefined4)((ulonglong)isZero3 >> 0x20);\n                isZero4 = __aeabi_dadd((int)absMantissa1,temp6,temp5,subResult2);\n                isZero4 = __divdf3(0,0x3ff00000,(int)isZero4,(int)((ulonglong)isZero4 >> 0x20));\n                isZero2 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                isZero5 = __muldf3((int)isZero3,isZero1,(int)isZero4,isZero2);\n                extra1 = (undefined4)((ulonglong)isZero5 >> 0x20);\n                temp7 = (undefined4)isZero5;\n                isZero5 = __muldf3(0,extra1);\n                isZero3 = __subdf3((int)isZero3,isZero1,(int)isZero5,(int)((ulonglong)isZero5 >> 0x20));\n                isZero5 = __subdf3(0,((int)temp6 >> 1 | 0x20000000U) + 0x80000 + temp2 * 0x40000,\n                                  temp5,subResult2);\n                isZero5 = __subdf3((int)absMantissa1,temp6,(int)isZero5,(int)((ulonglong)isZero5 >> 0x20));\n                isZero5 = __muldf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),0,extra1);\n                isZero3 = __subdf3((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),(int)isZero5,\n                                  (int)((ulonglong)isZero5 >> 0x20));\n                isZero3 = __muldf3((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),(int)isZero4,isZero2);\n                isZero2 = (undefined4)((ulonglong)isZero3 >> 0x20);\n                isZero4 = __muldf3(temp7,extra1);\n                temp5 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                isZero1 = (undefined4)isZero4;\n                isZero4 = __muldf3(isZero1,temp5,0x4a454eef,0x3fca7e28);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0x93c9db65,\n                                      0x3fcd864a);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero1,temp5);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0xa91d4101,\n                                      0x3fd17460);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero1,temp5);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0x518f264d,\n                                      0x3fd55555);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero1,temp5);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0xdb6fabff,\n                                      0x3fdb6db6);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero1,temp5);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0x33333303,\n                                      0x3fe33333);\n                isZero5 = __muldf3(isZero1,temp5,isZero1,temp5);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero5,\n                                  (int)((ulonglong)isZero5 >> 0x20));\n                isZero5 = __aeabi_dadd(temp7,extra1,0,extra1);\n                isZero5 = __muldf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),(int)isZero3,isZero2);\n                isZero4 = __aeabi_dadd((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),(int)isZero4,\n                                      (int)((ulonglong)isZero4 >> 0x20));\n                isZero1 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                isZero5 = __muldf3(0,extra1,0,extra1);\n                temp5 = (undefined4)((ulonglong)isZero5 >> 0x20);\n                isZero6 = __aeabi_dadd((int)isZero5,temp5,0,0x40080000);\n                __aeabi_dadd((int)isZero6,(int)((ulonglong)isZero6 >> 0x20),(int)isZero4,isZero1);\n                isZero6 = __muldf3(0,extra1,0,extra2);\n                subResult2 = (undefined4)((ulonglong)isZero6 >> 0x20);\n                subResult1 = __subdf3(0,extra2,0,0x40080000);\n                isZero5 = __subdf3((int)subResult1,(int)((ulonglong)subResult1 >> 0x20),(int)isZero5,temp5);\n                isZero4 = __subdf3((int)isZero4,isZero1,(int)isZero5,(int)((ulonglong)isZero5 >> 0x20));\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),temp7,extra1);\n                isZero3 = __muldf3((int)isZero3,isZero2,0,extra2);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero3,\n                                      (int)((ulonglong)isZero3 >> 0x20));\n                temp7 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                __aeabi_dadd((int)isZero6,subResult2,(int)isZero4,temp7);\n                isZero3 = __muldf3(0,extra3,0xe0000000,0x3feec709);\n                isZero5 = __subdf3(0,extra3,(int)isZero6,subResult2);\n                isZero4 = __subdf3((int)isZero4,temp7,(int)isZero5,(int)((ulonglong)isZero5 >> 0x20));\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0xdc3a03fd,0x3feec709\n                                 );\n                isZero5 = __muldf3(0,extra3,0x145b01f5,0xbe3e2fe0);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero5,\n                                      (int)((ulonglong)isZero5 >> 0x20));\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),\n                                      *(undefined4 *)(&dp_l + temp4),\n                                      *(undefined4 *)(&DAT_080073e4 + temp4));\n                isZero5 = __aeabi_i2d(shiftAmount);\n                temp7 = (undefined4)((ulonglong)isZero5 >> 0x20);\n                isZero1 = *(undefined4 *)(&dp_h + temp4);\n                isZero2 = *(undefined4 *)(&DAT_080073d4 + temp4);\n                isZero6 = __aeabi_dadd((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),(int)isZero4,\n                                      (int)((ulonglong)isZero4 >> 0x20));\n                isZero6 = __aeabi_dadd((int)isZero6,(int)((ulonglong)isZero6 >> 0x20),isZero1,isZero2);\n                __aeabi_dadd((int)isZero6,(int)((ulonglong)isZero6 >> 0x20),(int)isZero5,temp7);\n                isZero5 = __subdf3(0,extra4,(int)isZero5,temp7);\n                calculationResult = __subdf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),isZero1,isZero2);\n                absMantissa2 = extra4;\n              }\n              else {\n                if (0x43f00000 < absMantissa2) {\n                  if (0x3fefffff < temp6) {\nLAB_08006418:\n                    if ((int)mantissa2 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)mantissa2) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if (temp6 < 0x3fefffff) goto LAB_080063fa;\n                if (0x3ff00000 < temp6) goto LAB_08006418;\n                isZero3 = __subdf3();\n                isZero1 = (undefined4)((ulonglong)isZero3 >> 0x20);\n                temp7 = (undefined4)isZero3;\n                isZero3 = __muldf3(temp7,isZero1,0x60000000,0x3ff71547);\n                isZero4 = __muldf3(temp7,isZero1,0xf85ddf44,0x3e54ae0b);\n                isZero5 = __muldf3(temp7,isZero1,0,0x3fd00000);\n                isZero5 = __subdf3(0x55555555,0x3fd55555,(int)isZero5,(int)((ulonglong)isZero5 >> 0x20)\n                                 );\n                isZero5 = __muldf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),temp7,isZero1);\n                isZero5 = __subdf3(0,0x3fe00000,(int)isZero5,(int)((ulonglong)isZero5 >> 0x20));\n                isZero6 = __muldf3(temp7,isZero1,temp7,isZero1);\n                isZero5 = __muldf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),(int)isZero6,\n                                  (int)((ulonglong)isZero6 >> 0x20));\n                isZero5 = __muldf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),0x652b82fe,0x3ff71547\n                                 );\n                isZero4 = __subdf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero5,\n                                  (int)((ulonglong)isZero5 >> 0x20));\n                __aeabi_dadd((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),(int)isZero4,\n                             (int)((ulonglong)isZero4 >> 0x20));\n                calculationResult = (ulonglong)exponent2 << 0x20;\n                absMantissa2 = exponent2;\n              }\n              isZero3 = __subdf3((int)calculationResult,(int)((ulonglong)calculationResult >> 0x20),(int)isZero3,\n                                (int)((ulonglong)isZero3 >> 0x20));\n              isZero3 = __subdf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero3,\n                                (int)((ulonglong)isZero3 >> 0x20));\n              if ((isZero - 1 | temp3) == 0) {\n                temp7 = 0xbff00000;\n              }\n              else {\n                temp7 = 0x3ff00000;\n              }\n              subResult2 = 0;\n              isZero4 = __subdf3(mantissa1,mantissa2,0,mantissa2);\n              isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0,absMantissa2);\n              isZero3 = __muldf3((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),mantissa1,mantissa2);\n              isZero3 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero3,\n                                    (int)((ulonglong)isZero3 >> 0x20));\n              extra1 = (undefined4)((ulonglong)isZero3 >> 0x20);\n              isZero1 = (undefined4)isZero3;\n              isZero3 = __muldf3(0,absMantissa2,0,mantissa2);\n              temp5 = (undefined4)((ulonglong)isZero3 >> 0x20);\n              isZero2 = (undefined4)isZero3;\n              calculationResult = __aeabi_dadd(isZero1,extra1,isZero2,temp5);\n              temp6 = (uint)((ulonglong)calculationResult >> 0x20);\n              absMantissa2 = (uint)calculationResult;\n              if (0x408fffffffffffff < calculationResult) {\n                if ((temp6 + 0xbf700000 | absMantissa2) == 0) {\n                  isZero4 = __aeabi_dadd(isZero1,extra1,0x652b82fe,0x3c971547);\n                  isZero5 = __subdf3(absMantissa2,temp6,isZero2,temp5);\n                  temp2 = __aeabi_dcmpgt((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero5,\n                                         (int)((ulonglong)isZero5 >> 0x20));\n                  if (temp2 == 0) goto LAB_08006968;\n                }\n                __muldf3(subResult2,temp7,0x8800759c,0x7e37e43c);\n                goto LAB_0800634a;\n              }\n              if ((temp6 & 0x7fffffff) < 0x4090cc00) {\nLAB_08006968:\n                if ((temp6 & 0x7fffffff) < 0x3fe00001) {\n                  temp2 = 0;\n                }\n                else {\n                  temp6 = (0x100000 >> (((int)(temp6 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          temp6;\n                  absMantissa2 = (temp6 * 2 >> 0x15) - 0x3ff;\n                  temp2 = (int)(temp6 & 0xfffff | 0x100000) >> (0x14 - absMantissa2 & 0xff);\n                  if (calculationResult < 0) {\n                    temp2 = -temp2;\n                  }\n                  isZero3 = __subdf3(isZero2,temp5,0,temp6 & ~(0xfffff >> (absMantissa2 & 0xff)));\n                }\n                remainder2 = (undefined4)((ulonglong)isZero3 >> 0x20);\n                remainder1 = (undefined4)isZero3;\n                __aeabi_dadd(remainder1,remainder2,isZero1,extra1);\n                isZero3 = __muldf3(0,extra5,0,0x3fe62e43);\n                isZero2 = (undefined4)((ulonglong)isZero3 >> 0x20);\n                isZero4 = __subdf3(0,extra5,remainder1,remainder2);\n                isZero4 = __subdf3(isZero1,extra1,(int)isZero4,(int)((ulonglong)isZero4 >> 0x20));\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0xfefa39ef,0x3fe62e42\n                                 );\n                isZero5 = __muldf3(0,extra5,0xca86c39,0xbe205c61);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero5,\n                                      (int)((ulonglong)isZero5 >> 0x20));\n                extra1 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                isZero5 = __aeabi_dadd((int)isZero3,isZero2,(int)isZero4,extra1);\n                temp5 = (undefined4)((ulonglong)isZero5 >> 0x20);\n                isZero1 = (undefined4)isZero5;\n                isZero3 = __subdf3(isZero1,temp5,(int)isZero3,isZero2);\n                isZero3 = __subdf3((int)isZero4,extra1,(int)isZero3,(int)((ulonglong)isZero3 >> 0x20));\n                extra1 = (undefined4)((ulonglong)isZero3 >> 0x20);\n                isZero4 = __muldf3(isZero1,temp5,isZero1,temp5);\n                temp1 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                isZero2 = (undefined4)isZero4;\n                isZero4 = __muldf3(isZero2,temp1,0x72bea4d0,0x3e663769);\n                isZero4 = __subdf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0xc5d26bf1,0x3ebbbd41\n                                 );\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero2,temp1);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0xaf25de2c,\n                                      0x3f11566a);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero2,temp1);\n                isZero4 = __subdf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0x16bebd93,0x3f66c16c\n                                 );\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero2,temp1);\n                isZero4 = __aeabi_dadd((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),0x5555553e,\n                                      0x3fc55555);\n                isZero4 = __muldf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),isZero2,temp1);\n                isZero4 = __subdf3(isZero1,temp5,(int)isZero4,(int)((ulonglong)isZero4 >> 0x20));\n                isZero2 = (undefined4)((ulonglong)isZero4 >> 0x20);\n                isZero5 = __muldf3(isZero1,temp5,(int)isZero4,isZero2);\n                isZero4 = __subdf3((int)isZero4,isZero2,0,0x40000000);\n                isZero4 = __divdf3((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),(int)isZero4,\n                                  (int)((ulonglong)isZero4 >> 0x20));\n                isZero5 = __muldf3(isZero1,temp5,(int)isZero3,extra1);\n                isZero3 = __aeabi_dadd((int)isZero5,(int)((ulonglong)isZero5 >> 0x20),(int)isZero3,extra1\n                                     );\n                isZero3 = __subdf3((int)isZero4,(int)((ulonglong)isZero4 >> 0x20),(int)isZero3,\n                                  (int)((ulonglong)isZero3 >> 0x20));\n                isZero3 = __subdf3((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),isZero1,temp5);\n                isZero3 = __subdf3(0,0x3ff00000,(int)isZero3,(int)((ulonglong)isZero3 >> 0x20));\n                if ((int)((ulonglong)isZero3 >> 0x20) + temp2 * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(temp7,subResult2),(int)isZero3);\n                }\n              }\n              else {\n                if ((temp6 + 0x3f6f3400 | absMantissa2) == 0) {\n                  isZero4 = __subdf3(absMantissa2,temp6,isZero2,temp5);\n                  temp2 = __aeabi_dcmple(isZero1,extra1,(int)isZero4,(int)((ulonglong)isZero4 >> 0x20));\n                  if (temp2 == 0) goto LAB_08006968;\n                }\n                __muldf3(subResult2,temp7,0xc2f8f359,0x1a56e1f);\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          isZero3 = __subdf3();\n          isZero4 = isZero3;\nLAB_08006320:\n          __divdf3((int)isZero3,(int)((ulonglong)isZero3 >> 0x20),(int)isZero4,\n                   (int)((ulonglong)isZero4 >> 0x20));\n          return;\n        }\n      }\n    }\n    else if (absMantissa2 < 0x7ff00001) goto LAB_08006262;\n  }\n  if ((temp6 + 0xc0100000 | signBit) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(\"\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006228": "calculate_floating_point_08006228",
                "param_1": "signBit",
                "param_2": "exponent",
                "param_3": "mantissa1",
                "param_4": "mantissa2",
                "uVar1": "isZero",
                "extraout_r1": "exponent1",
                "extraout_r1_00": "exponent2",
                "uVar2": "extra1",
                "extraout_r1_01": "extra2",
                "extraout_r1_02": "extra3",
                "extraout_r1_03": "extra4",
                "extraout_r1_04": "extra5",
                "uVar3": "temp1",
                "iVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "temp4",
                "uVar7": "temp5",
                "uVar8": "temp6",
                "uVar9": "temp7",
                "uVar10": "absMantissa2",
                "lVar17": "calculationResult",
                "uVar18": "absMantissa1",
                "uVar19": "subResult1",
                "uVar20": "subResult2",
                "in_stack_ffffff94": "extra6",
                "local_68": "remainder1",
                "local_64": "remainder2",
                "local_54": "shiftAmount"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_i2d",
                "scalbn",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__aeabi_dcmple",
                "nan",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c0c": {
            "entrypoint": "0x08006c0c",
            "current_name": "calculate_product_sum_08006c0c",
            "code": "\nundefined8 calculateProductSum_08006c0c(uint input1,uint input2)\n\n{\n  undefined4 temp1;\n  uint temp2;\n  int shiftCount;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  int sum;\n  uint temp6;\n  uint temp7;\n  int loopCount;\n  uint temp8;\n  undefined8 result;\n  \n  if ((~input2 & 0x7ff00000) == 0) {\n    result = __muldf3(input1,input2,input1,input2);\n    result = __aeabi_dadd(input1,input2,(int)result,(int)((ulonglong)result >> 0x20));\n    return result;\n  }\n  if ((int)input2 < 1) {\n    if ((input2 & 0x7fffffff | input1) == 0) {\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != 0) {\n      result = __subdf3(input1,input2,input1,input2);\n      temp1 = (undefined4)((ulonglong)result >> 0x20);\n      result = __divdf3((int)result,temp1,(int)result,temp1);\n      return result;\n    }\n  }\n  shiftCount = (int)input2 >> 0x14;\n  if (shiftCount == 0) {\n    while (input2 == 0) {\n      shiftCount = shiftCount + -0x15;\n      input2 = input1 >> 0xb;\n      input1 = input1 << 0x15;\n    }\n    temp2 = 0;\n    for (; -1 < (int)(input2 << 0xb); input2 = input2 << 1) {\n      temp2 = temp2 + 1;\n    }\n    shiftCount = shiftCount - (temp2 - 1);\n    input2 = input2 | input1 >> (0x20 - temp2 & 0xff);\n    input1 = input1 << (temp2 & 0xff);\n  }\n  sum = 0;\n  temp2 = input2 & 0xfffff | 0x100000;\n  if ((shiftCount + -0x3ff) * -0x80000000 < 0) {\n    temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n    input1 = input1 << 1;\n  }\n  temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n  temp3 = 0x16;\n  temp4 = 0;\n  temp6 = 0x200000;\n  input1 = input1 << 1;\n  do {\n    loopCount = temp4 + temp6;\n    if (loopCount <= (int)temp2) {\n      temp2 = temp2 - loopCount;\n      temp4 = loopCount + temp6;\n      sum = sum + temp6;\n    }\n    temp3 = temp3 + -1;\n    temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n    temp6 = temp6 >> 1;\n    input1 = input1 << 1;\n  } while (temp3 != 0);\n  loopCount = 0x20;\n  temp7 = 0x80000000;\n  temp6 = 0;\n  temp3 = 0;\n  do {\n    temp8 = temp7 + temp3;\n    temp5 = temp4;\n    if (((int)temp4 < (int)temp2) || ((temp2 == temp4 && (temp8 <= input1)))) {\n      temp3 = temp8 + temp7;\n      if (((int)temp8 < 0) && (-1 < temp3)) {\n        temp5 = temp4 + 1;\n      }\n      temp2 = temp2 - temp4;\n      if (input1 < temp8) {\n        temp2 = temp2 - 1;\n      }\n      input1 = input1 - temp8;\n      temp6 = temp6 + temp7;\n    }\n    temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n    loopCount = loopCount + -1;\n    input1 = input1 << 1;\n    temp7 = temp7 >> 1;\n    temp4 = temp5;\n  } while (loopCount != 0);\n  if ((input1 | temp2) != 0) {\n    if (temp6 == 0xffffffff) {\n      sum = sum + 1;\n      temp6 = 0;\n    }\n    else {\n      temp6 = temp6 + 1 & 0xfffffffe;\n    }\n  }\n  temp6 = temp6 >> 1;\n  if (sum << 0x1f < 0) {\n    temp6 = temp6 | 0x80000000;\n  }\n  return CONCAT44((sum >> 1) + 0x3fe00000 + (shiftCount + -0x3ff >> 1) * 0x100000,temp6);\n}\n\n",
            "renaming": {
                "FUN_08006c0c": "calculate_product_sum_08006c0c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "shiftCount",
                "iVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5",
                "iVar7": "sum",
                "uVar8": "temp6",
                "uVar9": "temp7",
                "iVar10": "loopCount",
                "uVar11": "temp8",
                "uVar12": "result"
            },
            "calling": [
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d68": {
            "entrypoint": "0x08006d68",
            "current_name": "calculate_approximate_tangent_08006d68",
            "code": "\ndouble calculate_approximate_tangent_08006d68(double input_value)\n\n{\n  int integer_part;\n  int comparison_result;\n  undefined4 temp_var_1;\n  undefined4 temp_var_2;\n  uint fractional_part;\n  undefined4 temp_var_3;\n  undefined4 temp_var_4;\n  undefined4 temp_var_5;\n  undefined4 unaff_r3;\n  undefined4 unaff_r4;\n  undefined4 temp_var_6;\n  undefined4 temp_var_7;\n  uint normalized_input_value;\n  double result;\n  double extraout_result;\n  undefined8 temp_var_8;\n  undefined8 temp_var_9;\n  \n  temp_var_9 = CONCAT44(fractional_part,integer_part);\n  normalized_input_value = fractional_part & 0x7fffffff;\n  if (normalized_input_value < 0x44100000) {\n    if (normalized_input_value < 0x3fdc0000) {\n      if (normalized_input_value < 0x3e200000) {\n        temp_var_8 = __aeabi_dadd(integer_part,fractional_part,0x8800759c,0x7e37e43c);\n        comparison_result = __aeabi_dcmpgt((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),0,0x3ff00000);\n        if (comparison_result != 0) {\n          return extraout_result;\n        }\n      }\n      comparison_result = -1;\n    }\n    else {\n      fabs((double)CONCAT44(unaff_r4,unaff_r3));\n      if (normalized_input_value < 0x3ff30000) {\n        if (normalized_input_value < 0x3fe60000) {\n          temp_var_9 = __aeabi_dadd();\n          temp_var_9 = __subdf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),0,0x3ff00000);\n          temp_var_8 = __aeabi_dadd(integer_part,temp_var_3,0,0x40000000);\n          temp_var_9 = __divdf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),(int)temp_var_8,\n                            (int)((ulonglong)temp_var_8 >> 0x20));\n          comparison_result = 0;\n        }\n        else {\n          temp_var_9 = __subdf3();\n          temp_var_8 = __aeabi_dadd(integer_part,temp_var_3,0,0x3ff00000);\n          temp_var_9 = __divdf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),(int)temp_var_8,\n                            (int)((ulonglong)temp_var_8 >> 0x20));\n          comparison_result = 1;\n        }\n      }\n      else if (normalized_input_value < 0x40038000) {\n        temp_var_9 = __subdf3();\n        temp_var_8 = __muldf3(integer_part,temp_var_3,0,0x3ff80000);\n        temp_var_8 = __aeabi_dadd((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),0,0x3ff00000);\n        temp_var_9 = __divdf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),(int)temp_var_8,\n                          (int)((ulonglong)temp_var_8 >> 0x20));\n        comparison_result = 2;\n      }\n      else {\n        temp_var_9 = __divdf3(0,0xbff00000,integer_part,temp_var_3);\n        comparison_result = 3;\n      }\n    }\n    temp_var_7 = (undefined4)((ulonglong)temp_var_9 >> 0x20);\n    temp_var_6 = (undefined4)temp_var_9;\n    temp_var_9 = __muldf3(temp_var_6,temp_var_7,temp_var_6,temp_var_7);\n    temp_var_4 = (undefined4)((ulonglong)temp_var_9 >> 0x20);\n    temp_var_1 = (undefined4)temp_var_9;\n    temp_var_9 = __muldf3(temp_var_1,temp_var_4,temp_var_1,temp_var_4);\n    temp_var_5 = (undefined4)((ulonglong)temp_var_9 >> 0x20);\n    temp_var_2 = (undefined4)temp_var_9;\n    temp_var_9 = __muldf3(temp_var_2,temp_var_5,0xe322da11,0x3f90ad3a);\n    temp_var_9 = __aeabi_dadd((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_9 = __aeabi_dadd((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_9 = __aeabi_dadd((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_9 = __aeabi_dadd((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),0x920083ff,0x3fc24924);\n    temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_9 = __aeabi_dadd((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),0x5555550d,0x3fd55555);\n    temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_1,temp_var_4);\n    temp_var_1 = (undefined4)((ulonglong)temp_var_9 >> 0x20);\n    temp_var_8 = __muldf3(temp_var_2,temp_var_5,0x2c6a6c2f,0xbfa2b444);\n    temp_var_8 = __subdf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp_var_8 = __muldf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_8 = __subdf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp_var_8 = __muldf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_8 = __subdf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp_var_8 = __muldf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_8 = __subdf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp_var_8 = __muldf3((int)temp_var_8,(int)((ulonglong)temp_var_8 >> 0x20),temp_var_2,temp_var_5);\n    temp_var_2 = (undefined4)((ulonglong)temp_var_8 >> 0x20);\n    if (comparison_result == -1) {\n      temp_var_9 = __aeabi_dadd((int)temp_var_9,temp_var_1,(int)temp_var_8,temp_var_2);\n      temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_6,temp_var_7);\n      result = (double)__subdf3(temp_var_6,temp_var_7,(int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20));\n    }\n    else {\n      temp_var_9 = __aeabi_dadd((int)temp_var_9,temp_var_1,(int)temp_var_8,temp_var_2);\n      temp_var_9 = __muldf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_6,temp_var_7);\n      comparison_result = comparison_result * 8;\n      temp_var_9 = __subdf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),\n                        *(undefined4 *)(&atanlo + comparison_result),*(undefined4 *)(&UNK_08007414 + comparison_result));\n      temp_var_9 = __subdf3((int)temp_var_9,(int)((ulonglong)temp_var_9 >> 0x20),temp_var_6,temp_var_7);\n      result = (double)__subdf3(*(undefined4 *)(&atanhi + comparison_result),\n                               *(undefined4 *)(&UNK_080073f4 + comparison_result),(int)temp_var_9,\n                               (int)((ulonglong)temp_var_9 >> 0x20));\n    }\n  }\n  else if ((0x7ff00000 < normalized_input_value) || ((normalized_input_value == 0x7ff00000 && (integer_part != 0)))) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d68": "calculate_approximate_tangent_08006d68",
                "__x": "input_value",
                "in_r0": "integer_part",
                "iVar1": "comparison_result",
                "uVar2": "temp_var_1",
                "uVar3": "temp_var_2",
                "in_r1": "fractional_part",
                "extraout_r1": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "in_r3": "unaff_r3",
                "uVar6": "temp_var_6",
                "uVar7": "temp_var_7",
                "uVar8": "normalized_input_value",
                "in_d0": "result",
                "extraout_d0": "extraout_result",
                "uVar9": "temp_var_8",
                "uVar10": "temp_var_9"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800708c": {
            "entrypoint": "0x0800708c",
            "current_name": "calculate_square_root_0800708c",
            "code": "\ndouble calculate_square_root_0800708c(double input)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800708c": "calculate_square_root_0800708c",
                "__x": "input",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007092": {
            "entrypoint": "0x08007092",
            "current_name": "compute_sign_bit_08007092",
            "code": "\nint computeSignBit_08007092(double input)\n\n{\n  uint signBit;\n  \n  return (signBit | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_08007092": "compute_sign_bit_08007092",
                "__value": "input",
                "in_r1": "signBit"
            },
            "calling": [
                "pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800709e": {
            "entrypoint": "0x0800709e",
            "current_name": "handle_exception_0800709e",
            "code": "\nint handle_exception_0800709e(exception *exception_object)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800709e": "handle_exception_0800709e",
                "__exc": "exception_object"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070a4": {
            "entrypoint": "0x080070a4",
            "current_name": "calculate_tagb_value_080070a4",
            "code": "\ndouble calculateTagbValue_080070a4(char *tagb)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_080070a4": "calculate_tagb_value_080070a4",
                "__tagb": "tagb",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070b0": {
            "entrypoint": "0x080070b0",
            "current_name": "calculate_exponential_080070b0",
            "code": "\ndouble calculateExponential_080070b0(double input)\n\n{\n  int integerPart;\n  uint lowerBits;\n  uint higherBits;\n  undefined4 twopower_iVar1;\n  undefined4 TWO52_plus_iVar1;\n  uint exponentDiff;\n  uint shiftedExponent;\n  double result;\n  double finalResult;\n  undefined8 tempResult;\n  \n  shiftedExponent = (higherBits << 1) >> 0x15;\n  exponentDiff = shiftedExponent - 0x3ff;\n  integerPart = (int)higherBits >> 0x1f;\n  if ((int)exponentDiff < 0x14) {\n    if ((int)exponentDiff < 0) {\n      if ((higherBits & 0x7fffffff | lowerBits) == 0) {\n        return result;\n      }\n      exponentDiff = higherBits & 0xfffff | lowerBits;\n      integerPart = integerPart * -8;\n      twopower_iVar1 = *(undefined4 *)(&TWO52 + integerPart);\n      TWO52_plus_iVar1 = *(undefined4 *)(&DAT_08007434 + integerPart);\n      tempResult = __aeabi_dadd(lowerBits,(-exponentDiff | exponentDiff) >> 0xc & 0x80000 | higherBits & 0xfffe0000,twopower_iVar1,TWO52_plus_iVar1)\n      ;\n      finalResult = (double)__subdf3((int)tempResult,(int)((ulonglong)tempResult >> 0x20),twopower_iVar1,TWO52_plus_iVar1);\n      return finalResult;\n    }\n    shiftedExponent = 0xfffff >> (exponentDiff & 0xff);\n    if ((higherBits & shiftedExponent | lowerBits) == 0) {\n      return result;\n    }\n    shiftedExponent = shiftedExponent >> 1;\n    lowerBits = higherBits & shiftedExponent | lowerBits;\n    if (lowerBits != 0) {\n      if (exponentDiff == 0x13) {\n        lowerBits = 0x80000000;\n      }\n      else {\n        lowerBits = 0;\n      }\n      higherBits = 0x40000 >> (exponentDiff & 0xff) | higherBits & ~shiftedExponent;\n    }\n  }\n  else {\n    if (0x33 < (int)exponentDiff) {\n      if (exponentDiff != 0x400) {\n        return result;\n      }\n      finalResult = (double)__aeabi_dadd();\n      return finalResult;\n    }\n    shiftedExponent = shiftedExponent - 0x413;\n    exponentDiff = 0xffffffff >> (shiftedExponent & 0xff);\n    if ((lowerBits & exponentDiff) == 0) {\n      return result;\n    }\n    exponentDiff = exponentDiff >> 1;\n    if ((lowerBits & exponentDiff) != 0) {\n      lowerBits = 0x40000000 >> (shiftedExponent & 0xff) | lowerBits & ~exponentDiff;\n    }\n  }\n  integerPart = integerPart * -8;\n  twopower_iVar1 = *(undefined4 *)(&TWO52 + integerPart);\n  TWO52_plus_iVar1 = *(undefined4 *)(&DAT_08007434 + integerPart);\n  tempResult = __aeabi_dadd(lowerBits,higherBits,twopower_iVar1,TWO52_plus_iVar1);\n  finalResult = (double)__subdf3((int)tempResult,(int)((ulonglong)tempResult >> 0x20),twopower_iVar1,TWO52_plus_iVar1);\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080070b0": "calculate_exponential_080070b0",
                "__x": "input",
                "iVar1": "integerPart",
                "in_r0": "lowerBits",
                "in_r1": "higherBits",
                "uVar2": "twopower_iVar1",
                "uVar3": "TWO52_plus_iVar1",
                "uVar4": "exponentDiff",
                "uVar5": "shiftedExponent",
                "in_d0": "result",
                "dVar6": "finalResult",
                "uVar7": "tempResult"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071c0": {
            "entrypoint": "0x080071c0",
            "current_name": "calculate_exponential_080071c0",
            "code": "\ndouble calculateExponential_080071c0(double base,int exponent)\n\n{\n  uint temp1;\n  int temp2;\n  int temp3;\n  uint shiftedExponent;\n  int totalExponent;\n  undefined4 part2;\n  undefined4 part1;\n  undefined4 part4;\n  undefined4 part3;\n  double result;\n  double finalResult;\n  \n  shiftedExponent = (temp1 << 1) >> 0x15;\n  if (shiftedExponent == 0) {\n    if ((temp1 & 0x7fffffff | exponent) == 0) {\n      return result;\n    }\n    result = (double)multiply(exponent,temp1,0,0x43500000);\n    if (temp3 < -50000) goto LAB_0800722e;\n    shiftedExponent = ((uint)(temp2 << 1) >> 0x15) - 0x36;\n  }\n  else if (shiftedExponent == 0x7ff) {\n    finalResult = (double)__aeabi_dadd(exponent,temp1,exponent);\n    return finalResult;\n  }\n  totalExponent = shiftedExponent + temp3;\n  if (totalExponent < 0x7ff) {\n    if (0 < totalExponent) {\n      return result;\n    }\n    if (totalExponent + 0x35 < 0 == SCARRY4(totalExponent,0x35)) goto LAB_0800722e;\n    if (temp3 < 0xc351) {\n      copySign((double)concatenate(part1,part2),(double)concatenate(part3,part4));\n      goto LAB_0800722e;\n    }\n  }\n  copySign((double)concatenate(part1,part2),(double)concatenate(part3,part4));\nLAB_0800722e:\n  finalResult = (double)multiply();\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080071c0": "calculate_exponential_080071c0",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "temp1",
                "extraout_r1": "temp2",
                "in_r2": "temp3",
                "uVar1": "shiftedExponent",
                "iVar2": "totalExponent",
                "in_d0": "result",
                "dVar3": "finalResult",
                "__muldf3": "multiply",
                "copysign": "copySign",
                "CONCAT44": "concatenate",
                "unaff_r4": "part1",
                "in_r3": "part2",
                "unaff_r6": "part3",
                "unaff_r5": "part4"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "copysign"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800729c": {
            "entrypoint": "0x0800729c",
            "current_name": "calculate_distance_0800729c",
            "code": "\ndouble calculate_distance_0800729c(double x_coordinate,double y_coordinate)\n\n{\n  double distance;\n  \n  return distance;\n}\n\n",
            "renaming": {
                "FUN_0800729c": "calculate_distance_0800729c",
                "__x": "x_coordinate",
                "__y": "y_coordinate",
                "in_d0": "distance"
            },
            "calling": [
                "scalbn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072ac": {
            "entrypoint": "0x080072ac",
            "current_name": "get_impure_pointer_080072ac",
            "code": "\nundefined4 get_impure_pointer_080072ac(void)\n\n{\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_080072ac": "get_impure_pointer_080072ac",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072b8": {
            "entrypoint": "0x080072b8",
            "current_name": "expand_heap_080072b8",
            "code": "\nvoid * expandHeap_080072b8(intptr_t heapSize)\n\n{\n  undefined *currentHeapEnd;\n  \n  if (heap_end_4116 == (undefined *)0x0) {\n    heap_end_4116 = &_ebss;\n  }\n  currentHeapEnd = heap_end_4116;\n  heap_end_4116 = heap_end_4116 + heapSize;\n  return currentHeapEnd;\n}\n\n",
            "renaming": {
                "FUN_080072b8": "expand_heap_080072b8",
                "__delta": "heapSize",
                "puVar1": "currentHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d4": {
            "entrypoint": "0x080072d4",
            "current_name": "get_evp_context_080072d4",
            "code": "\nint getEVPContext_080072d4(EVP_PKEY_CTX *context)\n\n{\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_080072d4": "get_evp_context_080072d4",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072e0": {
            "entrypoint": "0x080072e0",
            "current_name": "FUNC_080072e0",
            "code": "\nvoid FUNC_080072e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072e0": "FUNC_080072e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 162844,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000160",
            "FUN_08000168",
            "FUN_0800016c",
            "FUN_080003e4",
            "FUN_08000404",
            "FUN_08000428",
            "FUN_08000464",
            "FUN_08000474",
            "FUN_080006ac",
            "FUN_08000892",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000904",
            "FUN_08000980",
            "FUN_08000990",
            "FUN_080009a0",
            "FUN_080009b4",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a30",
            "FUN_08000ad0",
            "FUN_08000ad8",
            "FUN_08000adc",
            "FUN_08000c3c",
            "FUN_08000c44",
            "FUN_08000c60",
            "FUN_08000c70",
            "FUN_08000cec",
            "FUN_08000e54",
            "FUN_08000f8c",
            "FUN_08000f94",
            "FUN_08000f9c",
            "FUN_08000ffc",
            "FUN_08001004",
            "FUN_08001014",
            "FUN_08001028",
            "FUN_0800103c",
            "FUN_08001050",
            "FUN_08001064",
            "FUN_08001078",
            "FUN_080010c4",
            "FUN_08001104",
            "FUN_08001128",
            "FUN_0800114c",
            "FUN_0800115c",
            "FUN_08001170",
            "FUN_08001194",
            "FUN_080011fc",
            "FUN_08001214",
            "FUN_08001240",
            "FUN_0800125a",
            "FUN_08001264",
            "FUN_08001424",
            "FUN_0800142e",
            "FUN_08001436",
            "FUN_08001460",
            "FUN_080014e2",
            "FUN_08001530",
            "FUN_080015e8",
            "FUN_080016f4",
            "FUN_08001754",
            "FUN_08001828",
            "FUN_08001938",
            "FUN_08001b58",
            "FUN_08002008",
            "FUN_0800209c",
            "FUN_08002214",
            "FUN_08002220",
            "FUN_08002250",
            "FUN_08002280",
            "FUN_080022d0",
            "FUN_08002324",
            "FUN_08002368",
            "FUN_080023d0",
            "FUN_08002404",
            "FUN_0800245c",
            "FUN_08002520",
            "FUN_08002538",
            "FUN_08002564",
            "FUN_080025a4",
            "FUN_080025e8",
            "FUN_08002724",
            "FUN_0800277c",
            "FUN_080028a6",
            "FUN_0800290c",
            "FUN_0800299a",
            "FUN_08002ad0",
            "FUN_08002b48",
            "FUN_08002bf0",
            "FUN_08002cb0",
            "FUN_08002d88",
            "FUN_08002ea0",
            "FUN_08002ec0",
            "FUN_08002ed4",
            "FUN_08002ee8",
            "FUN_08002f28",
            "FUN_08003034",
            "FUN_08003068",
            "FUN_08003078",
            "FUN_08003298",
            "FUN_08003314",
            "FUN_08003320",
            "FUN_08003330",
            "FUN_08003eac",
            "FUN_08003eb0",
            "FUN_08003ec8",
            "FUN_08003ef2",
            "FUN_08003f0e",
            "FUN_08003f3c",
            "FUN_08003f7c",
            "FUN_08003fc4",
            "FUN_08003fd0",
            "FUN_08003fdc",
            "FUN_08003fe8",
            "FUN_08003ff4",
            "FUN_08004028",
            "FUN_0800403c",
            "FUN_0800407c",
            "FUN_080040b8",
            "FUN_080040e8",
            "FUN_0800411c",
            "FUN_08004194",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_080041e4",
            "FUN_0800426c",
            "FUN_08004300",
            "FUN_08004348",
            "FUN_08004384",
            "FUN_080043bc",
            "FUN_080043f0",
            "FUN_08004410",
            "FUN_08004434",
            "FUN_08004458",
            "FUN_08004490",
            "FUN_08004514",
            "FUN_0800458c",
            "FUN_0800483c",
            "FUN_08004978",
            "FUN_08004a30",
            "FUN_08004a84",
            "FUN_08004c18",
            "FUN_08004c30",
            "FUN_08004c64",
            "FUN_08004c70",
            "FUN_08004c8c",
            "FUN_08004cac",
            "FUN_08004ccc",
            "FUN_08004d48",
            "FUN_08004d8c",
            "FUN_08004e14",
            "FUN_08004e7c",
            "FUN_08004ee6",
            "FUN_08004ee8",
            "FUN_08004eea",
            "FUN_08004eec",
            "FUN_08004ef4",
            "FUN_08004f04",
            "FUN_08004f10",
            "FUN_08004f60",
            "FUN_08004f68",
            "FUN_08004fb0",
            "FUN_08004fb4",
            "FUN_08004ffc",
            "FUN_08005044",
            "FUN_080050fc",
            "FUN_080052e4",
            "FUN_080053d4",
            "FUN_08005614",
            "FUN_08005630",
            "FUN_08005646",
            "FUN_0800567c",
            "FUN_08005714",
            "FUN_080057d0",
            "FUN_0800581c",
            "FUN_08005840",
            "FUN_08005854",
            "FUN_08005900",
            "FUN_08005bc8",
            "FUN_08005c70",
            "FUN_08006070",
            "FUN_08006228",
            "FUN_08006c0c",
            "FUN_08006d68",
            "FUN_0800708c",
            "FUN_08007092",
            "FUN_0800709e",
            "FUN_080070a4",
            "FUN_080070b0",
            "FUN_080071c0",
            "FUN_0800729c",
            "FUN_080072ac",
            "FUN_080072b8",
            "FUN_080072d4"
        ],
        [
            "FUN_080004d0",
            "FUN_08000724"
        ]
    ],
    "locked_functions": []
}