{
    "functions": {
        "FUN_00000410": {
            "entrypoint": "0x00000410",
            "current_name": "initialize_uart_stdio_00000410",
            "code": "\nint initialize_uart_stdio_00000410(EVP_PKEY_CTX *context)\n\n{\n  uart_stdio_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_00000410": "initialize_uart_stdio_00000410",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "uart_stdio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000041c": {
            "entrypoint": "0x0000041c",
            "current_name": "FUNC_0000041c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0000041c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000041c": "FUNC_0000041c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000428": {
            "entrypoint": "0x00000428",
            "current_name": "expand_heap_00000428",
            "code": "\nvoid * expandHeap_00000428(_reentranteent *reentrant,ptreentrantdiff_t increaseSize)\n\n{\n  uint irqState;\n  ptreentrantdiff_t increaseSizeLocal;\n  _reentranteent *reentrantLocal;\n  uint irqState2;\n  void *result;\n  \n  irqState = ireentrantq_disable();\n  result = heap_top;\n  if ((&_ereentrantam < heap_top + increaseSize) || (heap_top + increaseSize < &_sheap)) {\n    reentrant->_ereentrantreentrantno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    heap_top = heap_top + increaseSize;\n  }\n  ireentrantq_resulttoreentrante(irqState);\n  reentrantetureentrantn result;\n}\n\n",
            "renaming": {
                "FUN_00000428": "expand_heap_00000428",
                "r": "reentrant",
                "incr": "increaseSize",
                "state_00": "irqState",
                "incr_local": "increaseSizeLocal",
                "r_local": "reentrantLocal",
                "state": "irqState2",
                "res": "result"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "irq_restore",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000490": {
            "entrypoint": "0x00000490",
            "current_name": "read_uart_data_00000490",
            "code": "\n_ssize_t read_uart_data_00000490(reent_struct *reent,int fd,void *data_buffer,size_t buffer_length)\n\n{\n  int iVareent1;\n  size_t local_buffer_length;\n  void *local_data_buffer;\n  int local_file_descriptor;\n  reent_struct *local_reent;\n  \n  iVareent1 = uareentt_stdio_reentead((chareent *)data_buffer,buffer_length);\n  reentetureentn iVareent1;\n}\n\n",
            "renaming": {
                "_reent": "reent_struct",
                "FUN_00000490": "read_uart_data_00000490",
                "r": "reent",
                "buffer": "data_buffer",
                "count": "buffer_length",
                "count_local": "local_buffer_length",
                "buffer_local": "local_data_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "uart_stdio_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004b2": {
            "entrypoint": "0x000004b2",
            "current_name": "write_data_000004b2",
            "code": "\n_ssize_t write_data_000004b2(reent *r,int fd,void *buffer,size_t buffer_size)\n\n{\n  int write_result;\n  size_t local_buffer_size;\n  void *local_buffer;\n  int local_file_descriptor;\n  reent *local_reent;\n  \n  write_result = uart_stdio_write((char *)buffer,buffer_size);\n  return write_result;\n}\n\n",
            "renaming": {
                "_reent": "reent",
                "FUN_000004b2": "write_data_000004b2",
                "data": "buffer",
                "count": "buffer_size",
                "count_local": "local_buffer_size",
                "data_local": "local_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent",
                "iVar1": "write_result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_stdio_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004d4": {
            "entrypoint": "0x000004d4",
            "current_name": "set_error_code_000004d4",
            "code": "\nint setErrorCode_000004d4(_reentPtreent *reentPtr,int fd)\n\n{\n  int localFileDescriptor;\n  _reentPtreent *localReentPtr;\n  \n  reentPtr->_ereentPtrreentPtrno = 0x13;\n  reentPtretureentPtrn -1;\n}\n\n",
            "renaming": {
                "FUN_000004d4": "set_error_code_000004d4",
                "r": "reentPtr",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentPtr"
            },
            "calling": [
                "__sclose"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004f2": {
            "entrypoint": "0x000004f2",
            "current_name": "file_seek_000004f2",
            "code": "\n_off_t file_seek_000004f2(reentrant_structure *reentrant_structure_ptr,int fd,_off_t position,int direction)\n\n{\n  int local_direction;\n  _off_t local_position;\n  int local_file_descriptor;\n  reentrant_structure *local_reentrant_structure;\n  \n  reentrant_structure_ptr->_ereentrant_structure_ptrreentrant_structure_ptrno = 0x13;\n  reentrant_structure_ptretureentrant_structure_ptrn -1;\n}\n\n",
            "renaming": {
                "_reent": "reentrant_structure",
                "FUN_000004f2": "file_seek_000004f2",
                "r": "reentrant_structure_ptr",
                "pos": "position",
                "dir": "direction",
                "dir_local": "local_direction",
                "pos_local": "local_position",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reentrant_structure"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000514": {
            "entrypoint": "0x00000514",
            "current_name": "set_errno_and_return_00000514",
            "code": "\nint setErrnoAndReturn_00000514(_reentStructeent *reentStruct,int fd,fileStatat *fileStat)\n\n{\n  fileStatat *localFileStat;\n  int localFileDescriptor;\n  _reentStructeent *localReentStruct;\n  \n  reentStruct->_ereentStructreentStructno = 0x13;\n  reentStructetureentStructn -1;\n}\n\n",
            "renaming": {
                "FUN_00000514": "set_errno_and_return_00000514",
                "r": "reentStruct",
                "st": "fileStat",
                "st_local": "localFileStat",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentStruct"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000534": {
            "entrypoint": "0x00000534",
            "current_name": "check_standard_file_descriptor_00000534",
            "code": "\nint checkStandardFileDescriptor_00000534(_reentPtreent *reentPtr,int fd)\n\n{\n  int result;\n  int localFileDescriptor;\n  _reentPtreent *localReentPtr;\n  \n  reentPtr->_ereentPtrreentPtrno = 0;\n  if (((fd == 0) || (fd == 1)) || (fd == 2)) {\n    result = 1;\n  }\n  else {\n    result = 0;\n  }\n  reentPtretureentPtrn result;\n}\n\n",
            "renaming": {
                "FUN_00000534": "check_standard_file_descriptor_00000534",
                "r": "reentPtr",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentPtr",
                "iVar1": "result"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000566": {
            "entrypoint": "0x00000566",
            "current_name": "reverse_byte_order_00000566",
            "code": "\nuint reverseByteOrder_00000566(uint inputValue)\n\n{\n  byte firstByte;\n  byte secondByte;\n  byte thirdByte;\n  byte fourthByte;\n  uint reversedValue;\n  uint tempValue;\n  \n  secondByte = (byte)inputValue;\n  thirdByte = (byte)(inputValue >> 8);\n  fourthByte = (byte)(inputValue >> 0x10);\n  firstByte = (byte)(inputValue >> 0x18);\n  reversedValue = LZCOUNT((uint)(byte)((((((((secondByte & 1) << 1 | secondByte >> 1 & 1) << 1 | secondByte >> 2 & 1) << 1\n                                  | secondByte >> 3 & 1) << 1 | secondByte >> 4 & 1) << 1 | secondByte >> 5 & 1) <<\n                                1 | secondByte >> 6 & 1) << 1 | secondByte >> 7) << 0x18 |\n                  (uint)(byte)((((((((thirdByte & 1) << 1 | thirdByte >> 1 & 1) << 1 | thirdByte >> 2 & 1) << 1\n                                  | thirdByte >> 3 & 1) << 1 | thirdByte >> 4 & 1) << 1 | thirdByte >> 5 & 1) <<\n                                1 | thirdByte >> 6 & 1) << 1 | thirdByte >> 7) << 0x10 |\n                  (uint)(byte)((((((((fourthByte & 1) << 1 | fourthByte >> 1 & 1) << 1 | fourthByte >> 2 & 1) << 1\n                                  | fourthByte >> 3 & 1) << 1 | fourthByte >> 4 & 1) << 1 | fourthByte >> 5 & 1) <<\n                                1 | fourthByte >> 6 & 1) << 1 | fourthByte >> 7) << 8 |\n                  (uint)(byte)((((((((firstByte & 1) << 1 | firstByte >> 1 & 1) << 1 | firstByte >> 2 & 1) << 1\n                                  | firstByte >> 3 & 1) << 1 | firstByte >> 4 & 1) << 1 | firstByte >> 5 & 1) <<\n                                1 | firstByte >> 6 & 1) << 1 | firstByte >> 7));\n  if (inputValue == 0) {\n    reversedValue = 0xffffffff;\n  }\n  return reversedValue;\n}\n\n",
            "renaming": {
                "FUN_00000566": "reverse_byte_order_00000566",
                "v": "inputValue",
                "bVar1": "firstByte",
                "bVar2": "secondByte",
                "bVar3": "thirdByte",
                "bVar4": "fourthByte",
                "uVar5": "reversedValue",
                "v_local": "tempValue"
            },
            "calling": [
                "sched_run"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000058e": {
            "entrypoint": "0x0000058e",
            "current_name": "insert_node_at_end_0000058e",
            "code": "\nvoid insertNodeAtEnd_0000058e(chead_node_t *head,chead_node_t *nodeToInsert)\n\n{\n  chead_node_t *currentNode;\n  chead_node_t *currentHead;\n  \n  if (head->next == (head_node *)0x0) {\n    nodeToInsert->next = nodeToInsert;\n  }\n  else {\n    nodeToInsert->next = head->next->next;\n    head->next->next = nodeToInsert;\n  }\n  head->next = nodeToInsert;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000058e": "insert_node_at_end_0000058e",
                "list": "head",
                "new_node": "nodeToInsert",
                "new_node_local": "currentNode",
                "list_local": "currentHead"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000005ca": {
            "entrypoint": "0x000005ca",
            "current_name": "remove_list_node_000005ca",
            "code": "\nchead_node_t * removeListNode_000005ca(chead_node_t *head)\n\n{\n  head_node *removedNode;\n  chead_node_t *currentNode;\n  chead_node_t *firstNode;\n  \n  if (head->next == (head_node *)0x0) {\n    removedNode = (head_node *)0x0;\n  }\n  else {\n    removedNode = head->next->next;\n    if (removedNode == head->next) {\n      head->next = (head_node *)0x0;\n    }\n    else {\n      head->next->next = removedNode->next;\n    }\n  }\n  return removedNode;\n}\n\n",
            "renaming": {
                "FUN_000005ca": "remove_list_node_000005ca",
                "list": "head",
                "plVar1": "removedNode",
                "list_local": "currentNode",
                "first": "firstNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000610": {
            "entrypoint": "0x00000610",
            "current_name": "context_switch_00000610",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint contextSwitch_00000610(void)\n\n{\n  thread_t *activeThread;\n  uint bitIndex;\n  list_node *nextRunqueueNode;\n  int result;\n  thread_t *activeThread;\n  int nextRunqueue;\n  clist_node_t *nodePointer;\n  thread_t *nextThread;\n  \n  activeThread = sched_activeThread;\n  sched_context_switch_request = 0;\n  bitIndex = bitarithm_lsb(runqueue_bitcache);\n  nextRunqueueNode = (sched_runqueues[bitIndex].next)->next;\n  if (activeThread == (thread_t *)(nextRunqueueNode + -2)) {\n    result = 0;\n  }\n  else {\n    if ((activeThread != (thread_t *)0x0) && (activeThread->status == '\\t')) {\n      activeThread->status = '\\n';\n    }\n    *(undefined *)&nextRunqueueNode[-1].next = 9;\n    sched_active_pid = *(kernel_pid_t *)((int)&nextRunqueueNode[-1].next + 2);\n    result = 1;\n    sched_activeThread = (thread_t *)(nextRunqueueNode + -2);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000610": "context_switch_00000610",
                "ptVar1": "activeThread",
                "uVar2": "bitIndex",
                "plVar3": "nextRunqueueNode",
                "iVar4": "result",
                "active_thread": "activeThread",
                "nextrq": "nextRunqueue",
                "__m____": "nodePointer",
                "next_thread": "nextThread"
            },
            "calling": [
                "isr_svc"
            ],
            "called": [
                "bitarithm_lsb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000698": {
            "entrypoint": "0x00000698",
            "current_name": "update_process_status_00000698",
            "code": "\nvoid updateProcessStatus_00000698(thread_t *currentProcess,uint newStatus)\n\n{\n  uint localStatus;\n  thread_t *localProcess;\n  \n  if (newStatus < 9) {\n    if ((8 < currentProcess->newStatus) &&\n       (clist_lpop(runqueues + currentProcess->priority),\n       runqueues[currentProcess->priority].next == (ListNode *)0x0)) {\n      bitCache = bitCache & ~(1 << currentProcess->priority);\n    }\n  }\n  else if (currentProcess->newStatus < 9) {\n    clist_rpush(runqueues + currentProcess->priority,&currentProcess->rq_entry);\n    bitCache = bitCache | 1 << currentProcess->priority;\n  }\n  currentProcess->newStatus = (uint8_t)newStatus;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "currentProcess",
                "status": "newStatus",
                "status_local": "localStatus",
                "process_local": "localProcess",
                "sched_runqueues": "runqueues",
                "list_node": "ListNode",
                "runqueue_bitcache": "bitCache"
            },
            "calling": [
                "mutex_unlock",
                "thread_create",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [
                "clist_rpush",
                "clist_lpop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000738": {
            "entrypoint": "0x00000738",
            "current_name": "check_thread_priority_00000738",
            "code": "\nvoid checkThreadPriority_00000738(uint16_t targetPriority)\n\n{\n  int iVar1;\n  uint16_t localPriority;\n  uint16_t currentPriority;\n  thread_t *currentThread;\n  int isOnRunqueue;\n  \n  if ((sched_currentThread->status < 9) || (targetPriority < sched_currentThread->priority)) {\n    iVar1 = irq_is_in();\n    if (iVar1 == 0) {\n      thread_yield_higher();\n    }\n    else {\n      sched_context_switch_request = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000738": "check_thread_priority_00000738",
                "other_prio": "targetPriority",
                "other_prio_local": "localPriority",
                "current_prio": "currentPriority",
                "active_thread": "currentThread",
                "on_runqueue": "isOnRunqueue"
            },
            "calling": [
                "mutex_unlock",
                "thread_create"
            ],
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000794": {
            "entrypoint": "0x00000794",
            "current_name": "disable_interrupts_and_switch_context_exit_00000794",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_interrupts_and_switch_context_exit_00000794(void)\n\n{\n  irq_disable();\n  thread_pool[active_thread_index] = (thread_t *)0x0;\n  num_threads = num_threads + -1;\n  set_thread_status(active_thread,0);\n  active_thread = (thread_t *)0x0;\n                    \n  switch_context_exit();\n}\n\n",
            "renaming": {
                "FUN_00000794": "disable_interrupts_and_switch_context_exit_00000794",
                "sched_threads": "thread_pool",
                "sched_active_pid": "active_thread_index",
                "sched_num_threads": "num_threads",
                "sched_set_status": "set_thread_status",
                "sched_active_thread": "active_thread",
                "cpu_switch_context_exit": "switch_context_exit"
            },
            "calling": [],
            "called": [
                "sched_set_status",
                "cpu_switch_context_exit",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000007dc": {
            "entrypoint": "0x000007dc",
            "current_name": "create_thread_with_stack_000007dc",
            "code": "\nchar * createThreadWithStack_000007dc(thread_taskFunction_t taskFunction,vocounter2d *argument,vocounter2d *stackStart,counter2nt stackSize)\n\n{\n  ucounter2nt adjustedStackSize;\n  counter2nt localStackSize;\n  vocounter2d *localStackStart;\n  vocounter2d *localArgument;\n  thread_taskFunction_t localTaskFunction;\n  counter2nt counter1;\n  counter2nt counter2;\n  ucounter2nt32_t *stackPointer;\n  \n  adjustedStackSize = stackSize + (counter2nt)stackStart & 0xfffffffc;\n  stackPointer = (ucounter2nt32_t *)(adjustedStackSize - 4);\n  *stackPointer = 0x77777777;\n  counter2f (((ucounter2nt)stackPointer & 7) != 0) {\n    stackPointer = (ucounter2nt32_t *)(adjustedStackSize - 8);\n    *stackPointer = 0x88888888;\n  }\n  stackPointer[-1] = 0x1000000;\n  stackPointer[-2] = (ucounter2nt32_t)taskFunction;\n  stackPointer[-3] = 0x795;\n  stackPointer = stackPointer + -4;\n  *stackPointer = 0;\n  for (counter2 = 3; 0 < counter2; counter2 = counter2 + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = counter2;\n  }\n  stackPointer = stackPointer + -1;\n  *stackPointer = (ucounter2nt32_t)argument;\n  for (counter1 = 0xb; 3 < counter1; counter1 = counter1 + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = counter1;\n  }\n  stackPointer[-1] = 0xfffffffd;\n  return (char *)(stackPointer + -1);\n}\n\n",
            "renaming": {
                "FUN_000007dc": "create_thread_with_stack_000007dc",
                "task_func": "taskFunction",
                "arg": "argument",
                "stack_start": "stackStart",
                "stack_size": "stackSize",
                "uVar1": "adjustedStackSize",
                "stack_size_local": "localStackSize",
                "stack_start_local": "localStackStart",
                "arg_local": "localArgument",
                "task_func_local": "localTaskFunction",
                "i_1": "counter1",
                "i": "counter2",
                "stk": "stackPointer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000008b8": {
            "entrypoint": "0x000008b8",
            "current_name": "count_used_words_000008b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint countUsedWords_000008b8(void)\n\n{\n  currentPtrdiff_t usedWords;\n  uint32_t *currentPtr;\n  \n  for (currentPtr = (uint32_t *)isr_stack; (*currentPtr == 0xe7fee7fe && (currentPtr < &heap_top)); currentPtr = currentPtr + 1) {\n  }\n  return ((int)&heap_top - (int)currentPtr >> 2) << 2;\n}\n\n",
            "renaming": {
                "FUN_000008b8": "count_used_words_000008b8",
                "num_used_words": "usedWords",
                "ptr": "currentPtr"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000900": {
            "entrypoint": "0x00000900",
            "current_name": "get_main_stack_pointer_00000900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * getMainStackPointer_00000900(void)\n\n{\n  void *mainStackPointer;\n  uint32_t returnValue;\n  void *mainStackPointer;\n  \n  mainStackPointer = (void *)getMainStackPointer_00000900();\n  return mainStackPointer;\n}\n\n",
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "mainStackPointer",
                "result": "returnValue",
                "msp": "mainStackPointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000091c": {
            "entrypoint": "0x0000091c",
            "current_name": "get_isr_stack_0000091c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_isr_stack_0000091c(void)\n\n{\n  return interrupt_service_routine_stack;\n}\n\n",
            "renaming": {
                "FUN_0000091c": "get_isr_stack_0000091c",
                "isr_stack": "interrupt_service_routine_stack"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000930": {
            "entrypoint": "0x00000930",
            "current_name": "enable_interrupt_and_wait_00000930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableInterruptAndWait_00000930(void)\n\n{\n  enableInterrupt();\n  triggerSoftwareInterrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000930": "enable_interrupt_and_wait_00000930",
                "irq_enable": "enableInterrupt",
                "software_interrupt": "triggerSoftwareInterrupt"
            },
            "calling": [
                "kernel_init",
                "sched_task_exit"
            ],
            "called": [
                "irq_enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000093c": {
            "entrypoint": "0x0000093c",
            "current_name": "set_flag_in_register_0000093c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setFlagInRegister_0000093c(void)\n\n{\n  _DAT_e000ed04 = _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000093c": "set_flag_in_register_0000093c"
            },
            "calling": [
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end",
                "_mutex_lock",
                "cortexm_isr_end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000958": {
            "entrypoint": "0x00000958",
            "current_name": "execute_recoverable_function_00000958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRecoverableFunction_00000958(void)\n\n{\n  bool isPrivileged;\n  int iVar2;\n  code *jumpTable;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  undefined4 param4;\n  undefined4 param5;\n  undefined4 param6;\n  undefined4 param7;\n  undefined4 param8;\n  undefined4 param9;\n  code **stackPointer;\n  \n  iVar2 = getStackPointer();\n  *(undefined4 *)(iVar2 + -4) = param8;\n  *(undefined4 *)(iVar2 + -8) = param7;\n  *(undefined4 *)(iVar2 + -0xc) = param6;\n  *(undefined4 *)(iVar2 + -0x10) = param5;\n  *(undefined4 *)(iVar2 + -0x14) = param4;\n  *(undefined4 *)(iVar2 + -0x18) = param3;\n  *(undefined4 *)(iVar2 + -0x1c) = param2;\n  *(undefined4 *)(iVar2 + -0x20) = param1;\n  *(undefined4 *)(iVar2 + -0x24) = param9;\n  activeThread->sp = (char *)(undefined4 *)(iVar2 + -0x24);\n  handleSvcInterrupt();\n  runScheduler();\n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivileged = (bool)isPrivilegedMode();\n  if (isPrivileged) {\n    setStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000958": "execute_recoverable_function_00000958",
                "unaff_r4": "param1",
                "unaff_r5": "param2",
                "unaff_r6": "param3",
                "unaff_r7": "param4",
                "unaff_r8": "param5",
                "unaff_r9": "param6",
                "unaff_r10": "param7",
                "unaff_r11": "param8",
                "in_lr": "param9",
                "getProcessStackPointer": "getStackPointer",
                "sched_active_thread": "activeThread",
                "isr_svc": "handleSvcInterrupt",
                "sched_run": "runScheduler",
                "isCurrentModePrivileged": "isPrivilegedMode",
                "setProcessStackPointer": "setStackPointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar3": "stackPointer",
                "bVar1": "isPrivileged"
            },
            "calling": [],
            "called": [
                "isr_svc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000974": {
            "entrypoint": "0x00000974",
            "current_name": "run_scheduler_and_jump_00000974",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runSchedulerAndJump_00000974(void)\n\n{\n  bool isPrivilegedMode;\n  code *jumpTable;\n  code **stackPointer;\n  \n  sched_run();\n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    setStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000974": "run_scheduler_and_jump_00000974",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer",
                "bVar1": "isPrivilegedMode",
                "sched_active_thread": "activeThread",
                "setProcessStackPointer": "setStackPointer",
                "isCurrentModePrivileged": "checkPrivilegedMode"
            },
            "calling": [
                "isr_pendsv"
            ],
            "called": [
                "sched_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000978": {
            "entrypoint": "0x00000978",
            "current_name": "execute_function_00000978",
            "code": "\nvoid executeFunction_00000978(void)\n\n{\n  bool isPrivileged;\n  code *jumpTable;\n  code **stackPointer;\n  \n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    setProcessStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000978": "execute_function_00000978",
                "sched_active_thread": "activeThread",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer",
                "bVar1": "isPrivileged"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000990": {
            "entrypoint": "0x00000990",
            "current_name": "FUNC_00000990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000990(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000990": "FUNC_00000990"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000099c": {
            "entrypoint": "0x0000099c",
            "current_name": "initialize_system_0000099c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_0000099c(void)\n\n{\n  uint32_t topPointer;\n  uint32_t *top;\n  uint32_t *source;\n  uint32_t *destination;\n  \n  top = &topPointer;\n  source = (uint32_t *)&_etext;\n  pre_startup();\n  destination = (uint32_t *)isr_stack;\n  while (destination < &topPointer) {\n    *destination = 0xe7fee7fe;\n    destination = destination + 1;\n  }\n  destination = (uint32_t *)&heap_top;\n  while (destination < &sched_num_threads) {\n    *destination = *source;\n    source = source + 1;\n    destination = destination + 1;\n  }\n  destination = (uint32_t *)&sched_num_threads;\n  while (destination < &_sheap) {\n    *destination = 0;\n    destination = destination + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "topPointer",
                "src": "source",
                "dst": "destination"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "post_startup",
                "pre_startup",
                "kernel_init",
                "board_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a30": {
            "entrypoint": "0x00000a30",
            "current_name": "handle_nmi_00000a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_nmi_00000a30(void)\n\n{\n                    \n  trigger_panic(panic_message,\"NMI HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000a30": "handle_nmi_00000a30",
                "PANIC_NMI_HANDLER": "panic_message",
                "core_panic": "trigger_panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a40": {
            "entrypoint": "0x00000a40",
            "current_name": "calculate_offset_00000a40",
            "code": "\nint calculateOffset_00000a40(uint32_t requiredOffset)\n\n{\n  uint32_t localOffset;\n  uint32_t *stackPointer;\n  \n  return (int)(&stack0xe000ffe8 + -requiredOffset);\n}\n\n",
            "renaming": {
                "FUN_00000a40": "calculate_offset_00000a40",
                "required": "requiredOffset",
                "required_local": "localOffset",
                "sp": "stackPointer"
            },
            "calling": [
                "hard_fault_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a64": {
            "entrypoint": "0x00000a64",
            "current_name": "handle_memory_access_00000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryAccess_00000a64(void)\n\n{\n  uint32_t *stackPointer;\n  uint32_t isCorrupted;\n  uint32_t register4;\n  undefined4 register5;\n  undefined4 register6;\n  undefined4 register7;\n  undefined4 register8;\n  undefined4 register9;\n  undefined4 register10;\n  undefined4 register11;\n  uint linkRegister;\n  \n  if ((&_eram < &stack0x00000000) || (&stack0x00000000 < isr_stack + 0x159)) {\n    isCorrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)&heap_top;\n  }\n  else {\n    isCorrupted = 0;\n  }\n  if ((linkRegister & 4) == 0) {\n    stackPointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stackPointer = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = register11;\n  *(undefined4 *)((int)register0x00000054 + -8) = register10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = register9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = register8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = register7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = register6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = register5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = register4;\n                    \n  hard_fault_handler(stackPointer,isCorrupted,linkRegister,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n",
            "renaming": {
                "FUN_00000a64": "handle_memory_access_00000a64",
                "unaff_r4": "register4",
                "unaff_r5": "register5",
                "unaff_r6": "register6",
                "unaff_r7": "register7",
                "unaff_r8": "register8",
                "unaff_r9": "register9",
                "unaff_r10": "register10",
                "unaff_r11": "register11",
                "in_lr": "linkRegister",
                "corrupted": "isCorrupted",
                "sp": "stackPointer"
            },
            "calling": [],
            "called": [
                "hard_fault_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000aa8": {
            "entrypoint": "0x00000aa8",
            "current_name": "handle_hard_fault_00000aa8",
            "code": "\n\n\nvoid handleHardFault_00000aa8(uint32_t *stackPointer,uint32_t isCorrupted,uint32_t exceptionReturn,uint32_t *r4ToR11Stack)\n\n{\n  uint cfsr;\n  undefined4 hfsr;\n  undefined4 dfsr;\n  undefined4 afsr;\n  undefined4 bfar;\n  undefined4 mmfar;\n  int stackSizeLeft;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t r12;\n  uint32_t *r4ToR11StackLocal;\n  uint32_t exceptionReturnLocal;\n  uint32_t isCorruptedLocal;\n  uint32_t *stackPointerLocal;\n  int stackSize;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *originalStackPointer;\n  uint32_t programCounter;\n  \n  mmfar = _DAT_e000ed3c;\n  bfar = _DAT_e000ed38;\n  afsr = _DAT_e000ed34;\n  dfsr = _DAT_e000ed30;\n  hfsr = _DAT_e000ed2c;\n  cfsr = _DAT_e000ed28;\n  programCounter = 0;\n  if (isr_stack._0_4_ != -0x18011802) {\n    puts(\"\\nISR stack overflowed\");\n  }\n  if (isCorrupted == 0) {\n    r0 = *stackPointer;\n    r1 = stackPointer[1];\n    r2 = stackPointer[2];\n    r3 = stackPointer[4];\n    r12 = stackPointer[5];\n    programCounter = stackPointer[6];\n    puts(\"\\nContext before hardfault:\");\n    iprintf(\"   r0: 0x%08lx\\n   r1: 0x%08lx\\n   r2: 0x%08lx\\n   r3: 0x%08lx\\n\",r0,r1,r2);\n    iprintf(\"  r12: 0x%08lx\\n   lr: 0x%08lx\\n   programCounter: 0x%08lx\\n  psr: 0x%08lx\\n\\n\",r3,r12,programCounter);\n  }\n  else {\n    puts(\"Stack pointer isCorrupted, reset to top of stack\");\n  }\n  puts(\"FSR/FAR:\");\n  iprintf(\" CFSR: 0x%08lx\\n\",cfsr);\n  iprintf(\" HFSR: 0x%08lx\\n\",hfsr);\n  iprintf(\" DFSR: 0x%08lx\\n\",dfsr);\n  iprintf(\" AFSR: 0x%08lx\\n\",mmfar);\n  if ((cfsr & 0x8000) != 0) {\n    iprintf(\" BFAR: 0x%08lx\\n\",bfar);\n  }\n  if ((cfsr & 0x80) != 0) {\n    iprintf(\"MMFAR: 0x%08lx\\n\",afsr);\n  }\n  puts(\"Misc\");\n  iprintf(\"EXC_RET: 0x%08lx\\n\",exceptionReturn);\n  if (isCorrupted == 0) {\n    puts(\"Attempting to reconstruct state for debugging...\");\n    iprintf(\"In GDB:\\n  set $programCounter=0x%lx\\n  frame 0\\n  bt\\n\",programCounter);\n    stackSizeLeft = _stack_size_left(0x158);\n    if (stackSizeLeft < 0) {\n      iprintf(\"\\nISR stack overflowed by at least %d bytes.\\n\",-stackSizeLeft);\n    }\n  }\n  software_bkpt(1);\n                    \n  core_panic(PANIC_HARD_FAULT,\"HARD FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stackPointer",
                "corrupted": "isCorrupted",
                "exc_return": "exceptionReturn",
                "r4_to_r11_stack": "r4ToR11Stack",
                "uVar1": "cfsr",
                "uVar2": "hfsr",
                "uVar3": "dfsr",
                "uVar4": "afsr",
                "uVar5": "bfar",
                "uVar6": "mmfar",
                "iVar7": "stackSizeLeft",
                "uVar8": "r0",
                "uVar9": "r1",
                "uVar10": "r2",
                "uVar11": "r3",
                "uVar12": "r12",
                "r4_to_r11_stack_local": "r4ToR11StackLocal",
                "exc_return_local": "exceptionReturnLocal",
                "corrupted_local": "isCorruptedLocal",
                "sp_local": "stackPointerLocal",
                "stack_left": "stackSize",
                "orig_sp": "originalStackPointer",
                "pc": "programCounter"
            },
            "calling": [
                "hard_fault_default"
            ],
            "called": [
                "core_panic",
                "iprintf",
                "puts",
                "_stack_size_left"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c80": {
            "entrypoint": "0x00000c80",
            "current_name": "handle_memory_management_exception_00000c80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryManagementException_00000c80(void)\n\n{\n                    \n  panic(memoryManagementError,\"MEM MANAGE HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c80": "handle_memory_management_exception_00000c80",
                "PANIC_MEM_MANAGE": "memoryManagementError",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c90": {
            "entrypoint": "0x00000c90",
            "current_name": "handle_bus_fault_00000c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleBusFault_00000c90(void)\n\n{\n                    \n  core_panic(busFaultPanic,\"BUS FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PANIC_BUS_FAULT": "busFaultPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ca0": {
            "entrypoint": "0x00000ca0",
            "current_name": "handle_usage_fault_00000ca0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUsageFault_00000ca0(void)\n\n{\n                    \n  triggerPanic(usageFaultPanic,\"USAGE FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PANIC_USAGE_FAULT": "usageFaultPanic",
                "core_panic": "triggerPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cb0": {
            "entrypoint": "0x00000cb0",
            "current_name": "handle_debug_mon_00000cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDebugMon_00000cb0(void)\n\n{\n                    \n  triggerPanic(debugMonMessage,\"DEBUG MON HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cb0": "handle_debug_mon_00000cb0",
                "PANIC_DEBUG_MON": "debugMonMessage",
                "core_panic": "triggerPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cc0": {
            "entrypoint": "0x00000cc0",
            "current_name": "handle_dummy_function_00000cc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDummyFunction_00000cc0(void)\n\n{\n                    \n  panic(panicMessage,\"DUMMY HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cc0": "handle_dummy_function_00000cc0",
                "PANIC_DUMMY_HANDLER": "panicMessage",
                "core_panic": "panic"
            },
            "calling": [
                "dummy_handler"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cd0": {
            "entrypoint": "0x00000cd0",
            "current_name": "check_interrupt_status_00000cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkInterruptStatus_00000cd0(void)\n\n{\n  bool isPrivilegedMode;\n  uint interruptsEnabled;\n  uint32_t interruptsStatus;\n  uint32_t interruptsMask;\n  \n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cd0": "check_interrupt_status_00000cd0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled",
                "result": "interruptsStatus",
                "mask": "interruptsMask"
            },
            "calling": [
                "pm_off",
                "core_panic",
                "mutex_unlock",
                "kernel_init",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cf0": {
            "entrypoint": "0x00000cf0",
            "current_name": "check_ir_qinterrupts_enabled_00000cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkIRQinterruptsEnabled_00000cf0(void)\n\n{\n  bool isPrivilegedMode;\n  uint interruptsEnabled;\n  uint32_t interrupts;\n  \n  enableIRQinterrupts();\n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cf0": "check_ir_qinterrupts_enabled_00000cf0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled",
                "result": "interrupts"
            },
            "calling": [
                "cpu_switch_context_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d0c": {
            "entrypoint": "0x00000d0c",
            "current_name": "enable_ir_qinterrupts_if_privileged_00000d0c",
            "code": "\nvoid enableIRQinterruptsIfPrivileged_00000d0c(uint inputState)\n\n{\n  bool isPrivilegedMode;\n  uint localState;\n  \n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    enableIRQinterrupts((inputState & 1) == 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d0c": "enable_ir_qinterrupts_if_privileged_00000d0c",
                "state": "inputState",
                "bVar1": "isPrivilegedMode",
                "state_local": "localState"
            },
            "calling": [
                "mutex_unlock",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d2a": {
            "entrypoint": "0x00000d2a",
            "current_name": "get_exception_number_00000d2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint getExceptionNumber_00000d2a(void)\n\n{\n  bool isPrivilegedMode;\n  uint exceptionNumber;\n  uint32_t improvedResult;\n  \n  exceptionNumber = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    exceptionNumber = getCurrentExceptionNumber();\n    exceptionNumber = exceptionNumber & 0x1f;\n  }\n  return exceptionNumber;\n}\n\n",
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "bVar1": "isPrivilegedMode",
                "uVar2": "exceptionNumber",
                "result": "improvedResult"
            },
            "calling": [
                "sched_switch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d44": {
            "entrypoint": "0x00000d44",
            "current_name": "calculate_offset_00000d44",
            "code": "\nvoid * calculateOffset_00000d44(void *inputPointer,uintinputPointer_t bitValue)\n\n{\n  uintinputPointer_t localBitValue;\n  void *localPointer;\n  \n  return (void *)(bitValue * 4 + ((uint)inputPointer & 0xf0000000 | ((uint)inputPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "ptr": "inputPointer",
                "bit": "bitValue",
                "bit_local": "localBitValue",
                "ptr_local": "localPointer"
            },
            "calling": [
                "bit_clear32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d76": {
            "entrypoint": "0x00000d76",
            "current_name": "clear_bit_in_ptr_00000d76",
            "code": "\nvoid clearBitInPtr_00000d76(uint32_t *ptr_local,uint8_t bit_index)\n\n{\n  undefined4 *bitAddr;\n  uint8_t bit_value;\n  uint32_t *ptr;\n  \n  bitAddr = (undefined4 *)bit_indexband_addr(ptr_local,(uint)bit_index);\n  *bitAddr = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d76": "clear_bit_in_ptr_00000d76",
                "ptr": "ptr_local",
                "bit": "bit_index",
                "bit_local": "bit_value",
                "ptr_local": "ptr",
                "puVar1": "bitAddr"
            },
            "calling": [
                "cpu_errata_fixes"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d9c": {
            "entrypoint": "0x00000d9c",
            "current_name": "clear_peripheral_bit_00000d9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPeripheralBit_00000d9c(void)\n\n{\n  bit_clear32((uint32_t *)0x40048040,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d9c": "clear_peripheral_bit_00000d9c"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [
                "bit_clear32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000db0": {
            "entrypoint": "0x00000db0",
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_watchdog_and_fix_cpu_errata_00000db0(void)\n\n{\n  wdog_disable();\n  cpu_errata_fixes();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dc0": {
            "entrypoint": "0x00000dc0",
            "current_name": "handle_default_case_00000dc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_default_case_00000dc0(void)\n\n{\n  dummy_handler_default();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dc0": "handle_default_case_00000dc0"
            },
            "calling": [],
            "called": [
                "dummy_handler_default"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dcc": {
            "entrypoint": "0x00000dcc",
            "current_name": "initialize_data_00000dcc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_00000dcc(void)\n\n{\n  _DAT_4005200e = 0xd928;\n  _DAT_40052000 = 0xd2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dcc": "initialize_data_00000dcc"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000df4": {
            "entrypoint": "0x00000df4",
            "current_name": "initialize_uart_00000df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_00000df4(void)\n\n{\n  uart_initialize(0,0x1c200,write_one_isrpipe + 1,&stdio_isrpipe_uart);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "uart_init": "uart_initialize",
                "isrpipe_write_one": "write_one_isrpipe",
                "uart_stdio_isrpipe": "stdio_isrpipe_uart"
            },
            "calling": [
                "_init"
            ],
            "called": [
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e14": {
            "entrypoint": "0x00000e14",
            "current_name": "read_uart_data_00000e14",
            "code": "\nint read_uart_data_00000e14(char *input_buffer,int byte_count)\n\n{\n  int read_result;\n  int local_byte_count;\n  char *local_buffer;\n  \n  read_result = isrpipe_read(&uart_stdio_isrpipe,input_buffer,byte_count);\n  return read_result;\n}\n\n",
            "renaming": {
                "FUN_00000e14": "read_uart_data_00000e14",
                "buffer": "input_buffer",
                "count": "byte_count",
                "iVar1": "read_result",
                "count_local": "local_byte_count",
                "buffer_local": "local_buffer"
            },
            "calling": [
                "_read_r"
            ],
            "called": [
                "isrpipe_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e38": {
            "entrypoint": "0x00000e38",
            "current_name": "write_buffer_to_uart_00000e38",
            "code": "\nint write_buffer_to_uart_00000e38(char *input_buffer,int buffer_length)\n\n{\n  int local_length;\n  char *local_buffer;\n  \n  uart_write(0,(uint8_t *)input_buffer,buffer_length);\n  return buffer_length;\n}\n\n",
            "renaming": {
                "FUN_00000e38": "write_buffer_to_uart_00000e38",
                "buffer": "input_buffer",
                "len": "buffer_length",
                "len_local": "local_length",
                "buffer_local": "local_buffer"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e58": {
            "entrypoint": "0x00000e58",
            "current_name": "disable_interrupts_00000e58",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_interrupts_00000e58(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000e58": "disable_interrupts_00000e58"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e64": {
            "entrypoint": "0x00000e64",
            "current_name": "initialize_00000e64",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_00000e64(void)\n\n{\n  _DAT_40048038 = _DAT_40048038 | 0x200;\n  _DAT_40049048 = _DAT_40049048 & 0xfefff8ff;\n  initialize_00000e64_cpu();\n  initialize_00000e64_gpio(0x2056,GPIO_OUT);\n  initialize_00000e64_gpio(0x511a,GPIO_OUT);\n  initialize_00000e64_gpio(0x2055,GPIO_OUT);\n  set_gpio(0x2056);\n  set_gpio(0x511a);\n  set_gpio(0x2055);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000e64": "initialize_00000e64",
                "cpu_init": "initialize_cpu",
                "gpio_init": "initialize_gpio",
                "gpio_set": "set_gpio"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "gpio_set",
                "cpu_init",
                "gpio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ed8": {
            "entrypoint": "0x00000ed8",
            "current_name": "print_return_address_00000ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printReturnAddress_00000ed8(void)\n\n{\n  undefined4 returnAddress;\n  uint32_t *lrPointer;\n  \n  iprintf(\"%p\\n\",returnAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ed8": "print_return_address_00000ed8",
                "in_lr": "returnAddress",
                "lr_ptr": "lrPointer"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ef8": {
            "entrypoint": "0x00000ef8",
            "current_name": "FUNC_00000ef8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ef8": "FUNC_00000ef8"
            },
            "calling": [
                "core_panic"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000f04": {
            "entrypoint": "0x00000f04",
            "current_name": "handle_panic_00000f04",
            "code": "\nvoid handle_panic_00000f04(core_panic_t error_code,char *error_message)\n\n{\n  undefined4 stack_var_1;\n  undefined4 stack_var_2;\n  char *localized_message;\n  core_panic_t localized_error_code;\n  \n  localized_message = error_message;\n  localized_error_code = error_code;\n  if (crashed == 0) {\n    crashed = 1;\n    if (error_code == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(\"*** RIOT kernel panic:\\n%s\\n\\n\",localized_message);\n    ps();\n    iprintf(\"\\n\");\n    iprintf(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  panic_arch();\n  stack_var_2 = 0xf4d;\n  pm_off();\n  stack_var_1 = (int)&stack_var_1 + 1;\n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f04": "handle_panic_00000f04",
                "crash_code": "error_code",
                "message": "error_message",
                "uStack_18": "stack_var_1",
                "uStack_14": "stack_var_2",
                "message_local": "localized_message",
                "crash_code_local": "localized_error_code"
            },
            "calling": [
                "debug_mon_default",
                "uart_init",
                "hard_fault_handler",
                "thread_add_to_list",
                "usage_fault_default",
                "bus_fault_default",
                "fmt_s32_dfp",
                "nmi_default",
                "mem_manage_default",
                "cib_init",
                "dummy_handler_default"
            ],
            "called": [
                "pm_off",
                "ps",
                "panic_arch",
                "cpu_print_last_instruction",
                "iprintf",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f5c": {
            "entrypoint": "0x00000f5c",
            "current_name": "initialize_print_function_00000f5c",
            "code": "\nvoid * initializePrintFunction_00000f5c(void *argument)\n\n{\n  void *localArgument;\n  \n  initializeAutomatically();\n  printInformation(\"executeMain(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  executeMain();\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_00000f5c": "initialize_print_function_00000f5c",
                "arg": "argument",
                "arg_local": "localArgument",
                "auto_init": "initializeAutomatically",
                "iprintf": "printInformation",
                "main": "executeMain"
            },
            "calling": [],
            "called": [
                "auto_init",
                "iprintf",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f80": {
            "entrypoint": "0x00000f80",
            "current_name": "infinite_loop_00000f80",
            "code": "\nvoid * infiniteLoop_00000f80(void *arg_local)\n\n{\n  void *arg_local_local;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg_local"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f8c": {
            "entrypoint": "0x00000f8c",
            "current_name": "initialize_system_00000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00000f8c(void)\n\n{\n  irq_disable();\n  thread_create(idle_stack_pointer,0x100,'\\x0f',0xc,idle_thread_function + 1,(void *)0x0,idle_thread_name);\n  thread_create(main_stack_pointer,0x600,'\\a',0xc,main_function + 1,(void *)0x0,main_thread_name);\n                    \n  cpu_switch_context_exit();\n}\n\n",
            "renaming": {
                "FUN_00000f8c": "initialize_system_00000f8c",
                "idle_stack": "idle_stack_pointer",
                "main_stack": "main_stack_pointer",
                "idle_thread": "idle_thread_function",
                "main_trampoline": "main_function",
                "idle_name": "idle_thread_name",
                "main_name": "main_thread_name"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "cpu_switch_context_exit",
                "thread_create",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000fec": {
            "entrypoint": "0x00000fec",
            "current_name": "initialize_circular_buffer_00000fec",
            "code": "\nvoid initializeCircularBuffer_00000fec(CircularBuffer *cib,uint bufferSize)\n\n{\n  uint localBufferSize;\n  CircularBuffer *localCircularBuffer;\n  CircularBuffer c;\n  \n  if ((bufferSize & bufferSize - 1) != 0) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  cib->read_count = 0;\n  cib->write_count = 0;\n  cib->mask = bufferSize - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "CircularBuffer",
                "size": "bufferSize",
                "size_local": "localBufferSize",
                "cib_local": "localCircularBuffer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001034": {
            "entrypoint": "0x00001034",
            "current_name": "insert_thread_into_list_00001034",
            "code": "\nvoid insertThreadIntoList_00001034(threadList_node_t *threadList,currentThread_t *currentThread)\n\n{\n  currentThread_t *tempThread;\n  threadList_node_t *tempList;\n  currentThread_t *listNode;\n  cthreadList_node_t *clistNode;\n  threadList_node_t *newListNode;\n  uint16_t currentPriority;\n  \n  if (currentThread->status < 9) {\n    tempList = threadList;\n    while ((tempList->next != (threadList_node *)0x0 &&\n           (*(byte *)((int)&tempList->next[-1].next + 1) <= currentThread->priority))) {\n      tempList = tempList->next;\n    }\n    (currentThread->rq_entry).next = tempList->next;\n    tempList->next = &currentThread->rq_entry;\n    return;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list": "threadList",
                "thread": "currentThread",
                "thread_local": "tempThread",
                "list_local": "tempList",
                "list_entry": "listNode",
                "__m____": "clistNode",
                "new_node": "newListNode",
                "my_prio": "currentPriority"
            },
            "calling": [
                "_mutex_lock"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010a0": {
            "entrypoint": "0x000010a0",
            "current_name": "calculate_stack_space_000010a0",
            "code": "\nuintptr_t calculateStackSpace_000010a0(char *stackPointer)\n\n{\n  char *localStackPointer;\n  uintptr_t freeSpace;\n  uintptr_t *currentStackPointer;\n  \n  for (currentStackPointer = (uintptr_t *)stackPointer; (uintptr_t *)*currentStackPointer == currentStackPointer; currentStackPointer = currentStackPointer + 1) {\n  }\n  return (int)currentStackPointer - (int)stackPointer;\n}\n\n",
            "renaming": {
                "FUN_000010a0": "calculate_stack_space_000010a0",
                "stack": "stackPointer",
                "stack_local": "localStackPointer",
                "space_free": "freeSpace",
                "stackp": "currentStackPointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010d4": {
            "entrypoint": "0x000010d4",
            "current_name": "create_thread_000010d4",
            "code": "\nkernel_result_pid_t\ncreateThread_000010d4(char *stack_ptr,pidnt stack_size,char thread_priority,pidnt thread_flags,thread_task_func_t thread_function,vopidd *thread_arg\n            ,char *thread_name)\n\n{\n  upidnt irq_state;\n  char *stack_init_ptr;\n  pidnt stack_alignment;\n  upidnt adjusted_stacksize;\n  thread_t *new_thread;\n  pidnt local_flags;\n  char local_priority;\n  pidnt local_stacksize;\n  char *adjusted_stack_ptr;\n  upidnt thread_state;\n  upidntptr_t *stack_ending;\n  thread_t *cb;\n  upidntptr_t stack_misalignment;\n  pidnt thread_stacksize;\n  upidntptr_t *stack_pointer;\n  kernel_result_pid_t pid;\n  kernel_result_pid_t result_pid;\n  \n  pidf ((byte)thread_priority < 0x10) {\n    local_stacksize = stack_size;\n    adjusted_stack_ptr = stack_ptr;\n    pidf (((upidnt)stack_ptr & 3) != 0) {\n      stack_alignment = 4 - ((upidnt)stack_ptr & 3);\n      adjusted_stack_ptr = stack_ptr + stack_alignment;\n      local_stacksize = stack_size - stack_alignment;\n    }\n    adjusted_stacksize = local_stacksize - 0x30U & 0xfffffffc;\n    new_thread = (thread_t *)(adjusted_stack_ptr + adjusted_stacksize);\n    pidf ((thread_flags & 8U) == 0) {\n      *(char **)adjusted_stack_ptr = adjusted_stack_ptr;\n    }\n    else {\n      for (stack_pointer = (upidntptr_t *)adjusted_stack_ptr; stack_pointer < adjusted_stack_ptr + adjusted_stacksize; stack_pointer = stack_pointer + 1\n          ) {\n        *stack_pointer = (upidntptr_t)stack_pointer;\n      }\n    }\n    irq_state = disable_interrupt();\n    result_pid = 0;\n    for (pid = 1; pid < 0x21; pid = pid + 1) {\n      pidf (thread_list[pid] == (thread_t *)0x0) {\n        result_pid = pid;\n        break;\n      }\n    }\n    pidf (result_pid == 0) {\n      pidrq_restore(irq_state);\n      result_pid = -0x8b;\n    }\n    else {\n      thread_list[result_pid] = new_thread;\n      new_thread->result_pid = result_pid;\n      stack_init_ptr = thread_stack_ptr_pidnpidt(thread_function,thread_arg,adjusted_stack_ptr,adjusted_stacksize);\n      new_thread->sp = stack_init_ptr;\n      new_thread->stack_ptr_start = adjusted_stack_ptr;\n      new_thread->adjusted_stacksize = stack_size;\n      new_thread->thread_name = thread_name;\n      new_thread->thread_priority = thread_priority;\n      new_thread->status = '\\0';\n      (new_thread->rq_entry).next = (node *)0x0;\n      new_thread->wapidt_data = (vopidd *)0x0;\n      (new_thread->msg_wapidters).next = (node *)0x0;\n      cpidb_pidnpidt(&new_thread->msg_queue,0);\n      new_thread->msg_array = (msg_t *)0x0;\n      num_threads = num_threads + 1;\n      pidf ((thread_flags & 1U) == 0) {\n        sched_set_status(new_thread,10);\n        pidf ((thread_flags & 4U) == 0) {\n          pidrq_restore(irq_state);\n          sched_swpidtch((ushort)(byte)thread_priority);\n          return result_pid;\n        }\n      }\n      else {\n        sched_set_status(new_thread,1);\n      }\n      pidrq_restore(irq_state);\n    }\n  }\n  else {\n    result_pid = -0x16;\n  }\n  return result_pid;\n}\n\n",
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stack_ptr",
                "stacksize": "stack_size",
                "priority": "thread_priority",
                "flags": "thread_flags",
                "function": "thread_function",
                "arg": "thread_arg",
                "name": "thread_name",
                "state_00": "irq_state",
                "pcVar1": "stack_init_ptr",
                "iVar2": "stack_alignment",
                "stack_size": "adjusted_stacksize",
                "process": "new_thread",
                "flags_local": "local_flags",
                "priority_local": "local_priority",
                "stacksize_local": "local_stacksize",
                "stack_local": "adjusted_stack_ptr",
                "state": "thread_state",
                "stackmax": "stack_ending",
                "misalignment": "stack_misalignment",
                "total_stacksize": "thread_stacksize",
                "stackp": "stack_pointer",
                "i": "pid",
                "pid": "result_pid",
                "sched_threads": "thread_list",
                "irq_disable": "disable_interrupt",
                "sched_num_threads": "num_threads",
                "list_node": "node"
            },
            "calling": [
                "kernel_init"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "cib_init",
                "irq_disable",
                "thread_stack_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001274": {
            "entrypoint": "0x00001274",
            "current_name": "initialize_system_00001274",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00001274(void)\n\n{\n  initialize_cortexm();\n  DAT_4007e000 = DAT_4007e000 | 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "kinetis_mcg_init",
                "periph_init",
                "cortexm_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000129c": {
            "entrypoint": "0x0000129c",
            "current_name": "lock_mutex_0000129c",
            "code": "\nvoid lockMutex_0000129c(mutexPtr_t *mutexPtr)\n\n{\n  mutexPtr_t *localMutex;\n  \n  _mutexPtr_lock(mutexPtr,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex": "mutexPtr",
                "mutex_local": "localMutex"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "_mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012b4": {
            "entrypoint": "0x000012b4",
            "current_name": "add_character_to_isr_pipe_000012b4",
            "code": "\nint addCharacterToISRPipe_000012b4(pipe_t *pipe,char c)\n\n{\n  int addResult;\n  char localCharacter;\n  pipe_t *localPipe;\n  int result;\n  \n  addResult = tsrb_add_one(&pipe->tsrb,c);\n  mutex_unlock(&pipe->mutex);\n  return addResult;\n}\n\n",
            "renaming": {
                "FUN_000012b4": "add_character_to_isr_pipe_000012b4",
                "isrpipe": "pipe",
                "iVar1": "addResult",
                "c_local": "localCharacter",
                "isrpipe_local": "localPipe",
                "res": "result"
            },
            "calling": [],
            "called": [
                "mutex_unlock",
                "tsrb_add_one"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012e2": {
            "entrypoint": "0x000012e2",
            "current_name": "read_from_isr_pipe_000012e2",
            "code": "\nint readFromISRPipe_000012e2(inputPipe_t *inputPipe,char *outputBuffer,size_t bufferSize)\n\n{\n  int iVar1;\n  size_t localBufferSize;\n  char *localOutputBuffer;\n  inputPipe_t *localInputPipe;\n  int result;\n  \n  while( true ) {\n    iVar1 = tsrb_get(&inputPipe->tsrb,outputBuffer,bufferSize);\n    if (iVar1 != 0) break;\n    mutex_lock(&inputPipe->mutex);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_000012e2": "read_from_isr_pipe_000012e2",
                "isrpipe": "inputPipe",
                "buffer": "outputBuffer",
                "count": "bufferSize",
                "count_local": "localBufferSize",
                "buffer_local": "localOutputBuffer",
                "isrpipe_local": "localInputPipe",
                "res": "result"
            },
            "calling": [
                "uart_stdio_read"
            ],
            "called": [
                "tsrb_get",
                "mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001318": {
            "entrypoint": "0x00001318",
            "current_name": "set_irq_enabled_bit_00001318",
            "code": "\nvoid setIRQEnabledBit_00001318(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001318": "set_irq_enabled_bit_00001318",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "uart_init_uart"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001348": {
            "entrypoint": "0x00001348",
            "current_name": "check_for_context_switch_request_00001348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_for_context_switch_request_00001348(void)\n\n{\n  if (is_context_switch_requested != 0) {\n    yield_to_higher_thread();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001348": "check_for_context_switch_request_00001348",
                "sched_context_switch_request": "is_context_switch_requested",
                "thread_yield_higher": "yield_to_higher_thread"
            },
            "calling": [
                "irq_handler_uart"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001360": {
            "entrypoint": "0x00001360",
            "current_name": "calculate_new_pointer_00001360",
            "code": "\nvoid * calculateNewPointer_00001360(void *originalPointer,uintoriginalPointer_t bitMask)\n\n{\n  uintoriginalPointer_t localBitMask;\n  void *localOriginalPointer;\n  \n  return (void *)(bitMask * 4 + ((uint)originalPointer & 0xf0000000 | ((uint)originalPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001360": "calculate_new_pointer_00001360",
                "ptr": "originalPointer",
                "bit": "bitMask",
                "bit_local": "localBitMask",
                "ptr_local": "localOriginalPointer"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001392": {
            "entrypoint": "0x00001392",
            "current_name": "set_bit_value_00001392",
            "code": "\nvoid setBitValue_00001392(uint32_t *ptrAddress,uint8_t bitIndex)\n\n{\n  undefined4 *bitAddress;\n  uint8_t localBit;\n  uint32_t *localPtr;\n  \n  bitAddress = (undefined4 *)bitIndexband_addr(ptrAddress,(uint)bitIndex);\n  *bitAddress = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001392": "set_bit_value_00001392",
                "ptr": "ptrAddress",
                "bit": "bitIndex",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitAddress"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000013b8": {
            "entrypoint": "0x000013b8",
            "current_name": "initialize_uart_000013b8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000142e) */\n\nint initialize_uart_000013b8(uart_instance_t uart_instance,uint32_t baudrate,uart_instance_receive_callback_t receive_callback,void *callback_arg)\n\n{\n  void *local_callback_arg;\n  uart_instance_receive_callback_t local_receive_callback;\n  uint32_t local_baudrate;\n  uart_instance_t local_uart;\n  \n  if (uart_instance == 0) {\n    uart_config[0].receive_callback = receive_callback;\n    uart_config[0].callback_arg = callback_arg;\n    uart_instance_init_pins(0);\n    bit_set32((uint32_t *)&DAT_40048034,'\\n');\n    uart_instance_init_uart_instance(0,baudrate);\n    return 0;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_instance",
                "rx_cb": "receive_callback",
                "arg": "callback_arg",
                "arg_local": "local_callback_arg",
                "rx_cb_local": "local_receive_callback",
                "baudrate_local": "local_baudrate",
                "uart_local": "local_uart",
                "config": "uart_config"
            },
            "calling": [
                "uart_stdio_init"
            ],
            "called": [
                "uart_init_uart",
                "core_panic",
                "uart_init_pins",
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001448": {
            "entrypoint": "0x00001448",
            "current_name": "initialize_uart_00001448",
            "code": "\nvoid initializeUART_00001448(uartDevice_t uartDevice)\n\n{\n  uartDevice_t localUart;\n  \n  if (uartConfiguration[uartDevice].receivePin != 0xffff) {\n    gpio_init_port(uartConfiguration[uartDevice].receivePin,uartConfiguration[uartDevice].receivePcr);\n  }\n  if (uartConfiguration[uartDevice].transmitPin != 0xffff) {\n    gpio_init_port(uartConfiguration[uartDevice].transmitPin,uartConfiguration[uartDevice].transmitPcr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001448": "initialize_uart_00001448",
                "uart": "uartDevice",
                "uart_local": "localUart",
                "uart_config": "uartConfiguration",
                "pin_rx": "receivePin",
                "pin_tx": "transmitPin",
                "pcr_rx": "receivePcr",
                "pcr_tx": "transmitPcr"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "gpio_init_port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000014c4": {
            "entrypoint": "0x000014c4",
            "current_name": "initialize_uart_000014c4",
            "code": "\nvoid initializeUART_000014c4(uartType_t uartType,uint32_t baudrateValue)\n\n{\n  byte *uartDevice;\n  uint uartFrequency;\n  uint baudrateDivisor;\n  uint32_t localBaudrate;\n  uartType_t localUart;\n  uint8_t txFifoSize;\n  uint8_t baudrateFraction;\n  uint16_t uartBaudrateDivisor;\n  uint32_t clockFrequency;\n  UART_Type *uartDevicePointer;\n  \n  uartDevice = (byte *)uartType_config[uartType].uartDevicePointer;\n  uartFrequency = uartType_config[uartType].freq;\n  uartDevice[3] = uartDevice[3] & 0xf3;\n  uartDevice[2] = uartType_config[uartType].mode;\n  baudrateDivisor = uartFrequency / (baudrateValue << 4);\n  *uartDevice = (byte)(baudrateDivisor >> 8) & 0x1f;\n  uartDevice[1] = (byte)baudrateDivisor;\n  uartDevice[10] = (byte)((uartFrequency << 2) / baudrateValue + 1 >> 1) & 0x1f;\n  uartDevice[0x10] = uartDevice[0x10] | 0x88;\n  if ((uartDevice[0x10] & 0x70) == 0) {\n    uartDevice[0x13] = 0;\n  }\n  else {\n    uartDevice[0x13] = (char)(2 << (uartDevice[0x10] >> 4 & 7)) - 1;\n  }\n  uartDevice[0x15] = 1;\n  uartDevice[0x11] = 0xc0;\n  uartDevice[3] = uartDevice[3] | 0x2c;\n  NVIC_EnableIRQ(uartType_config[uartType].irqn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000014c4": "initialize_uart_000014c4",
                "uart": "uartType",
                "baudrate": "baudrateValue",
                "pbVar1": "uartDevice",
                "uVar2": "uartFrequency",
                "uVar3": "baudrateDivisor",
                "baudrate_local": "localBaudrate",
                "uart_local": "localUart",
                "txfifo_size": "txFifoSize",
                "brfa": "baudrateFraction",
                "ubd": "uartBaudrateDivisor",
                "clk": "clockFrequency",
                "dev": "uartDevicePointer"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000015d0": {
            "entrypoint": "0x000015d0",
            "current_name": "copy_data_to_uart_000015d0",
            "code": "\nvoindexd copyDataToUART_000015d0(uartPort_t uartPort,uindexnt8_t *inputData,sindexze_t dataLength)\n\n{\n  voindexd *uartDevice;\n  sindexze_t localDataLength;\n  uindexnt8_t *localData;\n  uartPort_t localUARTPort;\n  UART_Type *device;\n  sindexze_t index;\n  \n  uartDevice = uartPort_confindexg[uartPort].device;\n  for (index = 0; index < dataLength; index = index + 1) {\n    do {\n    } whindexle (-1 < *(char *)((indexnt)uartDevice + 4));\n    *(uindexnt8_t *)((indexnt)uartDevice + 7) = inputData[index];\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000015d0": "copy_data_to_uart_000015d0",
                "uart": "uartPort",
                "data": "inputData",
                "len": "dataLength",
                "len_local": "localDataLength",
                "data_local": "localData",
                "uart_local": "localUARTPort",
                "dev": "device",
                "i": "index",
                "pvVar1": "uartDevice"
            },
            "calling": [
                "uart_stdio_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001628": {
            "entrypoint": "0x00001628",
            "current_name": "handle_uart_interrupt_00001628",
            "code": "\nvoid handle_uart_interrupt_00001628(uart_instance_t uart_instance)\n\n{\n  uart_instance_t local_uart;\n  uint8_t received_data;\n  UART_Type *uart_device;\n  \n  if (((*(byte *)((int)device_config[uart_instance].uart_device + 4) & 0x20) != 0) &&\n     (uart_configuration[uart_instance].receiver_callback != (uart_instance_receiver_callback_t)0x0)) {\n    (*uart_configuration[uart_instance].receiver_callback)(uart_configuration[uart_instance].arg,*(uint8_t *)((int)device_config[uart_instance].uart_device + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001628": "handle_uart_interrupt_00001628",
                "uart": "uart_instance",
                "uart_local": "local_uart",
                "data": "received_data",
                "dev": "uart_device",
                "uart_config": "device_config",
                "config": "uart_configuration",
                "rx_cb": "receiver_callback"
            },
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001688": {
            "entrypoint": "0x00001688",
            "current_name": "initialize_uart_irq_handler_00001688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_irq_handler_00001688(void)\n\n{\n  handle_uart_interrupt(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001688": "initialize_uart_irq_handler_00001688",
                "irq_handler_uart": "handle_uart_interrupt"
            },
            "calling": [],
            "called": [
                "irq_handler_uart"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001696": {
            "entrypoint": "0x00001696",
            "current_name": "calculate_memory_address_00001696",
            "code": "\nvoid * calculateMemoryAddress_00001696(void *inputPointer,uintinputPointer_t bitOffset)\n\n{\n  uintinputPointer_t localBit;\n  void *localPointer;\n  \n  return (void *)(bitOffset * 4 + ((uint)inputPointer & 0xf0000000 | ((uint)inputPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001696": "calculate_memory_address_00001696",
                "ptr": "inputPointer",
                "bit": "bitOffset",
                "bit_local": "localBit",
                "ptr_local": "localPointer"
            },
            "calling": [
                "bit_clear8",
                "bit_set8",
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016c8": {
            "entrypoint": "0x000016c8",
            "current_name": "set_bit_000016c8",
            "code": "\nvoid setBit_000016c8(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016c8": "set_bit_000016c8"
            },
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016ec": {
            "entrypoint": "0x000016ec",
            "current_name": "set_bit_000016ec",
            "code": "\nvoid setBit_000016ec(uint8_t *data,uint8_t position)\n\n{\n  undefined *puVar1;\n  uint8_t localBit;\n  uint8_t *localData;\n  \n  puVar1 = (undefined *)positionband_addr(data,(uint)position);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016ec": "set_bit_000016ec",
                "ptr": "data",
                "bit": "position",
                "bit_local": "localBit",
                "ptr_local": "localData"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001710": {
            "entrypoint": "0x00001710",
            "current_name": "clear_bit_in_byte_00001710",
            "code": "\nvoid clearBitInByte_00001710(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  uint8_t bit_local;\n  uint8_t *ptr_local;\n  \n  puVar1 = (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001710": "clear_bit_in_byte_00001710"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001734": {
            "entrypoint": "0x00001734",
            "current_name": "clear_bit_in_register_00001734",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearBitInRegister_00001734(void)\n\n{\n  bit_clear8(&DAT_40064005,'\\x06');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001734": "clear_bit_in_register_00001734"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bit_clear8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001748": {
            "entrypoint": "0x00001748",
            "current_name": "update_fll_factor_00001748",
            "code": "\nvoid updateFLLFactor_00001748(kinetis_mcg_fll_t newFactor)\n\n{\n  kinetis_mcg_fll_t localFactor;\n  \n  DAT_40064003 = newFactor | DAT_40064003 & ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001748": "update_fll_factor_00001748",
                "factor": "newFactor",
                "factor_local": "localFactor"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001778": {
            "entrypoint": "0x00001778",
            "current_name": "clear_bit_and_set_flag_00001778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n/* WARNING: Unknown calling convention */\n\nvoid clear_bit_and_set_flag_00001778(void)\n\n{\n  DAT_40064001 = DAT_40064001 & 0xcf | 0x20;\n  bit_clear8(&DAT_40064001,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001778": "clear_bit_and_set_flag_00001778"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fee"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000017dc": {
            "entrypoint": "0x000017dc",
            "current_name": "initialize_flags_000017dc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeFlags_000017dc(void)\n\n{\n  bit_set32((uint32_t *)&DAT_4004803c,'\\x1d');\n  if ((_DAT_4003d010 & 0x100) == 0) {\n    _DAT_4003d010 = 0x104;\n  }\n  _DAT_40047000 = _DAT_40047000 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000017dc": "initialize_flags_000017dc"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000182c": {
            "entrypoint": "0x0000182c",
            "current_name": "clear_bits_and_set_flags_0000182c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n/* WARNING: Unknown calling convention */\n\nvoid clearBitsAndSetFlags_0000182c(void)\n\n{\n  uint8_t temporary;\n  \n  DAT_40064008 = DAT_40064008 & 0xd0;\n  setBit8(&DAT_40064001,'\\0');\n  clearBit8(&DAT_40064000,'\\x01');\n  clearBit8(&DAT_40064000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000182c": "clear_bits_and_set_flags_0000182c",
                "tmp": "temporary",
                "bit_set8": "setBit8",
                "bit_clear8": "clearBit8"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000018bc": {
            "entrypoint": "0x000018bc",
            "current_name": "initialize_clock_system_000018bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockSystem_000018bc(void)\n\n{\n  kinetis_mcg_set_fll_factor(FLL_FACTOR_1464);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  bit_clear8(&DAT_40064001,'\\x01');\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  mode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000018bc": "initialize_clock_system_000018bc",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "current_mode": "mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000191c": {
            "entrypoint": "0x0000191c",
            "current_name": "initialize_mcg_0000191c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCG_0000191c(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(fllFactor1920);\n  DAT_40064000 = DAT_40064000 & 0x3b;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  mcgMode = KINETIS_MCG_MODE_FEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000191c": "initialize_mcg_0000191c",
                "KINETIS_MCG_FLL_FACTOR_1920": "fllFactor1920",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001960": {
            "entrypoint": "0x00001960",
            "current_name": "initialize_system_00001960",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00001960(void)\n\n{\n  kinetis_mcg_set_fll_factor(FLL_FACTOR_1464);\n  clear_bit8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 & 0xc) != 4);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  system_mode = KINETIS_MCG_MODE_FBI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001960": "initialize_system_00001960",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "bit_clear8": "clear_bit8",
                "current_mode": "system_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000019c0": {
            "entrypoint": "0x000019c0",
            "current_name": "initialize_clock_000019c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_clock_000019c0(void)\n\n{\n  enable_oscillator();\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  clear_bit(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  disable_pll();\n  mcg_mode = KINETIS_MCG_MODE_FBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000019c0": "initialize_clock_000019c0",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "bit_clear8": "clear_bit",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "mcg_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a18": {
            "entrypoint": "0x00001a18",
            "current_name": "initialize_kinetis_mcg_00001a18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_kinetis_mcg_00001a18(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disable_pll();\n  mcg_mode = KINETIS_MCG_MODE_BLPI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a18": "initialize_kinetis_mcg_00001a18",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "mcg_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a3c": {
            "entrypoint": "0x00001a3c",
            "current_name": "initialize_mcg_mode_00001a3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_mcg_mode_00001a3c(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  kinetis_mcg_disable_pll();\n  mcg_current_mode = KINETIS_MCG_MODE_BLPE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a3c": "initialize_mcg_mode_00001a3c",
                "current_mode": "mcg_current_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a60": {
            "entrypoint": "0x00001a60",
            "current_name": "initialize_kinetis_mcg_mode_00001a60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_Kinetis_MCG_mode_00001a60(void)\n\n{\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  bit_set8(&DAT_40064005,'\\x06');\n  do {\n  } while ((DAT_40064006 & 0x20) == 0);\n  do {\n  } while ((DAT_40064006 & 0x40) == 0);\n  kinetis_MCG_current_mode = KINETIS_MCG_MODE_PBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a60": "initialize_kinetis_mcg_mode_00001a60",
                "current_mode": "kinetis_MCG_current_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ad4": {
            "entrypoint": "0x00001ad4",
            "current_name": "set_mcg_mode_to_pee_00001ad4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setMCGModeToPEE_00001ad4(void)\n\n{\n  DAT_40064000 = DAT_40064000 & 0x3f;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0xc);\n  mcgMode = KINETIS_MCG_MODE_PEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ad4": "set_mcg_mode_to_pee_00001ad4",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001b10": {
            "entrypoint": "0x00001b10",
            "current_name": "set_mcg_mode_00001b10",
            "code": "\nint setMCGMode_00001b10(MCGMode requestedMode)\n\n{\n  int result;\n  MCGMode currentMode;\n  \n  if (requestedMode < NUM_MCG_MODES) {\n    do {\n      switch(modeRouting[currentMode][requestedMode]) {\n      case '\\0':\n        setFEI();\n        break;\n      case '\\x01':\n        setFEE();\n        break;\n      case '\\x02':\n        setFBI();\n        break;\n      case '\\x03':\n        setFBE();\n        break;\n      case '\\x04':\n        setBLPI();\n        break;\n      case '\\x05':\n        setBLPE();\n        break;\n      case '\\x06':\n        setPBE();\n        break;\n      case '\\a':\n        setPEE();\n        break;\n      default:\n        return -1;\n      }\n    } while (requestedMode != currentMode);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00001b10": "set_mcg_mode_00001b10",
                "mode": "requestedMode",
                "mode_local": "currentMode",
                "kinetis_mcg_mode_t": "MCGMode",
                "KINETIS_MCG_MODE_NUMOF": "NUM_MCG_MODES",
                "mcg_mode_routing": "modeRouting",
                "current_mode": "currentMode",
                "kinetis_mcg_set_fei": "setFEI",
                "kinetis_mcg_set_fee": "setFEE",
                "kinetis_mcg_set_fbi": "setFBI",
                "kinetis_mcg_set_fbe": "setFBE",
                "kinetis_mcg_set_blpi": "setBLPI",
                "kinetis_mcg_set_blpe": "setBLPE",
                "kinetis_mcg_set_pbe": "setPBE",
                "kinetis_mcg_set_pee": "setPEE",
                "iVar1": "result"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001bb8": {
            "entrypoint": "0x00001bb8",
            "current_name": "initialize_system_00001bb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001bb8(void)\n\n{\n  if ((DAT_40064001 & 2) != 0) {\n    bit_clear8(&DAT_40064001,'\\x01');\n  }\n  if ((DAT_40064005 & 0x40) != 0) {\n    if ((DAT_40064000 & 0xc0) == 0) {\n      DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 & 0xc) != 8);\n    }\n    bit_clear8(&DAT_40064005,'\\x06');\n    do {\n    } while ((DAT_40064006 & 0x20) != 0);\n  }\n  kinetis_mcg_set_fll_factor(mcgFllFactor640);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  currentMode = mcgModeFEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001bb8": "initialize_system_00001bb8",
                "KINETIS_MCG_FLL_FACTOR_640": "mcgFllFactor640",
                "current_mode": "currentMode",
                "KINETIS_MCG_MODE_FEI": "mcgModeFEI"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001c84": {
            "entrypoint": "0x00001c84",
            "current_name": "initialize_system_clock_00001c84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemClock_00001c84(void)\n\n{\n  uint interruptState;\n  uint interruptMask;\n  \n  interruptState = irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 = 0x220000;\n  DAT_4006400c = 0;\n  DAT_40064000 = DAT_40064000 & 199 | 0x38;\n  DAT_40064004 = 0x13;\n  DAT_40064005 = 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(interruptState);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001c84": "initialize_system_clock_00001c84",
                "state": "interruptState",
                "mask": "interruptMask"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_init_erclk32k",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_mode",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001cf0": {
            "entrypoint": "0x00001cf0",
            "current_name": "check_and_yield_higher_00001cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_higher_00001cf0(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    yield_current_thread();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001cf0": "check_and_yield_higher_00001cf0",
                "thread_yield_higher": "yield_current_thread"
            },
            "calling": [
                "irq_handler"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d08": {
            "entrypoint": "0x00001d08",
            "current_name": "calculate_ptr_offset_00001d08",
            "code": "\nvoid * calculatePtrOffset_00001d08(void *inputPointer,uintinputPointer_t bitMask)\n\n{\n  uintinputPointer_t localBitMask;\n  void *localInputPointer;\n  \n  return (void *)(bitMask * 4 + ((uint)inputPointer & 0xf0000000 | ((uint)inputPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001d08": "calculate_ptr_offset_00001d08",
                "ptr": "inputPointer",
                "bit": "bitMask",
                "bit_local": "localBitMask",
                "ptr_local": "localInputPointer"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d3a": {
            "entrypoint": "0x00001d3a",
            "current_name": "set_bit_00001d3a",
            "code": "\nvoid setBit_00001d3a(uint32_t *dataPointer,uint8_t bitPosition)\n\n{\n  undefined4 *bitbandAddress;\n  uint8_t localBit;\n  uint32_t *localDataPointer;\n  \n  bitbandAddress = (undefined4 *)bitPositionband_addr(dataPointer,(uint)bitPosition);\n  *bitbandAddress = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a",
                "ptr": "dataPointer",
                "bit": "bitPosition",
                "bit_local": "localBit",
                "ptr_local": "localDataPointer",
                "puVar1": "bitbandAddress"
            },
            "calling": [
                "clk_en"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d5e": {
            "entrypoint": "0x00001d5e",
            "current_name": "get_port_type_from_gpio_00001d5e",
            "code": "\nPortType * getPortTypeFromGPIO_00001d5e(gpio_t gpioPin)\n\n{\n  gpio_t localPin;\n  \n  return (PortType *)(gpioPin & 0x7000 | 0x40048000);\n}\n\n",
            "renaming": {
                "FUN_00001d5e": "get_port_type_from_gpio_00001d5e",
                "pin": "gpioPin",
                "pin_local": "localPin",
                "PORT_Type": "PortType"
            },
            "calling": [
                "gpio_init_port",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d80": {
            "entrypoint": "0x00001d80",
            "current_name": "map_gpio_pin_to_address_00001d80",
            "code": "\nGPIO_Type * mapGpioPinToAddress_00001d80(gpio_t gpioPin)\n\n{\n  gpio_t localGpioPin;\n  \n  return (GPIO_Type *)(gpioPin & 0x1c0 | 0x400ff000);\n}\n\n",
            "renaming": {
                "FUN_00001d80": "map_gpio_pin_to_address_00001d80",
                "pin": "gpioPin",
                "pin_local": "localGpioPin"
            },
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001da2": {
            "entrypoint": "0x00001da2",
            "current_name": "extract_bits_from_pin_00001da2",
            "code": "\nint extractBitsFromPin_00001da2(gpio_t pinValue)\n\n{\n  gpio_t localPin;\n  \n  return pinValue >> 6 & 7;\n}\n\n",
            "renaming": {
                "FUN_00001da2": "extract_bits_from_pin_00001da2",
                "pin": "pinValue",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port",
                "clk_en"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001dc0": {
            "entrypoint": "0x00001dc0",
            "current_name": "extract_gpio_pin_00001dc0",
            "code": "\nint extract_gpio_pin_00001dc0(gpio_t gpio_pin)\n\n{\n  gpio_t local_gpio_pin;\n  \n  return gpio_pin & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_00001dc0": "extract_gpio_pin_00001dc0",
                "pin": "gpio_pin",
                "pin_local": "local_gpio_pin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ddc": {
            "entrypoint": "0x00001ddc",
            "current_name": "set_pin_state_00001ddc",
            "code": "\nvoid setPinState_00001ddc(gpio_t pin)\n\n{\n  int portNumber;\n  gpio_t localPin;\n  \n  portNumber = port_num(pin);\n  bit_set32((uint32_t *)&DAT_40048038,(char)portNumber + '\\t');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ddc": "set_pin_state_00001ddc",
                "iVar1": "portNumber",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "bit_set32",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e0c": {
            "entrypoint": "0x00001e0c",
            "current_name": "get_pin_value_00001e0c",
            "code": "\nint getPinValue_00001e0c(int portNumber,int pinNumber)\n\n{\n  int localPinNumber;\n  int localPortNumber;\n  \n  return isr_map[(pinNumber >> 3) + portNumber * 4] >> ((pinNumber & 7U) << 2) & 0xf;\n}\n\n",
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "portNumber",
                "pin": "pinNumber",
                "pin_local": "localPinNumber",
                "port_local": "localPortNumber"
            },
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e44": {
            "entrypoint": "0x00001e44",
            "current_name": "update_isr_map_00001e44",
            "code": "\nvoid update_isr_map_00001e44(int port_num,int pin_num,int context)\n\n{\n  int divided_pin;\n  int local_context;\n  int local_pin;\n  int local_port;\n  \n  divided_pin = pin_num >> 3;\n  isr_map[divided_pin + port_num * 4] = isr_map[divided_pin + port_num * 4] & ~(0xf << ((pin_num & 7U) << 2));\n  isr_map[divided_pin + port_num * 4] = isr_map[divided_pin + port_num * 4] | context << ((pin_num & 7U) << 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001e44": "update_isr_map_00001e44",
                "port": "port_num",
                "pin": "pin_num",
                "ctx": "context",
                "iVar1": "divided_pin",
                "ctx_local": "local_context",
                "pin_local": "local_pin",
                "port_local": "local_port"
            },
            "calling": [
                "ctx_clear"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ec4": {
            "entrypoint": "0x00001ec4",
            "current_name": "write_ctx_to_map_00001ec4",
            "code": "\nvoid write_ctx_to_map_00001ec4(int inputPort,int inputPin)\n\n{\n  int context;\n  int localPin;\n  int localPort;\n  int context;\n  \n  context = get_context(inputPort,inputPin);\n  write_map(inputPort,inputPin,context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ec4": "write_ctx_to_map_00001ec4",
                "port": "inputPort",
                "pin": "inputPin",
                "ctx_00": "context",
                "pin_local": "localPin",
                "port_local": "localPort",
                "ctx": "context"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "get_ctx",
                "write_map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001eea": {
            "entrypoint": "0x00001eea",
            "current_name": "configure_gpio_00001eea",
            "code": "\nint configureGPIO_00001eea(gpio_t GPIO_Pin,gpio_GPIO_Mode_t GPIO_Mode)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPointer;\n  PORT_Type *portPointer;\n  int pinNum;\n  gpio_GPIO_Mode_t localMode;\n  gpio_t localPin;\n  \n  gpio_init_port(GPIO_Pin,0);\n  if ((char)GPIO_Mode < '\\0') {\n    pinNumber = GPIO_Pin_num(GPIO_Pin);\n    gpioPointer = gpio(GPIO_Pin);\n    gpioPointer->PDDR = gpioPointer->PDDR | 1 << (pinNumber & 0xff);\n  }\n  else {\n    pinNumber = GPIO_Pin_num(GPIO_Pin);\n    gpioPointer = gpio(GPIO_Pin);\n    gpioPointer->PDDR = gpioPointer->PDDR & ~(1 << (pinNumber & 0xff));\n  }\n  portPointer = port(GPIO_Pin);\n  pinNum = GPIO_Pin_num(GPIO_Pin);\n  portPointer->PCR[pinNum] = GPIO_Mode & 0x23 | 0x100;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00001eea": "configure_gpio_00001eea",
                "pin": "GPIO_Pin",
                "mode": "GPIO_Mode",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPointer",
                "pPVar3": "portPointer",
                "iVar4": "pinNum",
                "mode_local": "localMode",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio_init_port",
                "gpio",
                "port",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001f80": {
            "entrypoint": "0x00001f80",
            "current_name": "configure_pin_00001f80",
            "code": "\nvoid configurePin_00001f80(gpio_t gpioPin,uint32_t pinConfig)\n\n{\n  PORT_Type *portPtr;\n  int pinIndex;\n  int pinNumber;\n  uint oldPcrValue;\n  uint32_t newPinConfig;\n  gpio_t localGpioPin;\n  uint32_t interruptState;\n  \n  clk_en(gpioPin);\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  oldPcrValue = portPtr->PCR[pinIndex];\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  portPtr->PCR[pinIndex] = pinConfig;\n  if ((oldPcrValue & 0xf0000) != 0) {\n    pinIndex = port_num(gpioPin);\n    pinNumber = gpioPin_num(gpioPin);\n    ctx_clear(pinIndex,pinNumber);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001f80": "configure_pin_00001f80",
                "pin": "gpioPin",
                "pcr": "pinConfig",
                "pPVar1": "portPtr",
                "iVar2": "pinIndex",
                "pin_00": "pinNumber",
                "uVar3": "oldPcrValue",
                "pcr_local": "newPinConfig",
                "pin_local": "localGpioPin",
                "isr_state": "interruptState"
            },
            "calling": [
                "uart_init_pins",
                "gpio_init"
            ],
            "called": [
                "port",
                "pin_num",
                "ctx_clear",
                "clk_en",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ff6": {
            "entrypoint": "0x00001ff6",
            "current_name": "set_pin_high_00001ff6",
            "code": "\nvoid setPinHigh_00001ff6(gpio_t pin)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPort;\n  gpio_t localPin;\n  \n  pinNumber = pin_num(pin);\n  gpioPort = gpio(pin);\n  gpioPort->PSOR = 1 << (pinNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ff6": "set_pin_high_00001ff6",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPort",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002028": {
            "entrypoint": "0x00002028",
            "current_name": "process_interrupts_00002028",
            "code": "\nvoindexd processInterrupts_00002028(PORT_Type *portPtr,indexnt portNum)\n\n{\n  indexnt ctxIndex;\n  uindexnt interruptFlags;\n  indexnt localPortNum;\n  PORT_Type *localPortPtr;\n  indexnt context;\n  uindexnt32_t portStatus;\n  indexnt index;\n  \n  interruptFlags = portPtr->ISFR;\n  for (index = 0; index < 0x20; index = index + 1) {\n    indexf (((interruptFlags & 1 << (index & 0xffU)) != 0) && ((portPtr->PCR[index] & 0xf0000) != 0)) {\n      portPtr->ISFR = 1 << (index & 0xffU);\n      ctxIndex = get_context(portNum,index);\n      (*indexsr_context[ctxIndex].cb)(indexsr_context[ctxIndex].arg);\n    }\n  }\n  cortexm_indexsr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002028": "process_interrupts_00002028",
                "port": "portPtr",
                "port_num": "portNum",
                "iVar1": "ctxIndex",
                "uVar2": "interruptFlags",
                "port_num_local": "localPortNum",
                "port_local": "localPortPtr",
                "ctx": "context",
                "status": "portStatus",
                "i": "index"
            },
            "calling": [
                "isr_portc",
                "isr_portd",
                "isr_porte",
                "isr_portb",
                "isr_porta"
            ],
            "called": [
                "get_ctx",
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020b8": {
            "entrypoint": "0x000020b8",
            "current_name": "initialize_port_interrupts_000020b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePortInterrupts_000020b8(void)\n\n{\n  irq_handler((PORT_Type *)0x40049000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020b8": "initialize_port_interrupts_000020b8"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020cc": {
            "entrypoint": "0x000020cc",
            "current_name": "initialize_irq_handler_000020cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_irq_handler_000020cc(void)\n\n{\n  irq_handler((PORT_Type *)0x4004a000,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020cc": "initialize_irq_handler_000020cc"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020e0": {
            "entrypoint": "0x000020e0",
            "current_name": "initialize_irq_handler_000020e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_000020e0(void)\n\n{\n  irq_handler((port *)0x4004b000,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020e0": "initialize_irq_handler_000020e0",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020f4": {
            "entrypoint": "0x000020f4",
            "current_name": "initialize_irq_000020f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQ_000020f4(void)\n\n{\n  irq_handler((PORT_Type *)0x4004c000,3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020f4": "initialize_irq_000020f4"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002108": {
            "entrypoint": "0x00002108",
            "current_name": "initialize_irq_handler_00002108",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_00002108(void)\n\n{\n  handleIRQ((port *)0x4004d000,4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002108": "initialize_irq_handler_00002108",
                "PORT_Type": "port",
                "irq_handler": "handleIRQ"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000211c": {
            "entrypoint": "0x0000211c",
            "current_name": "print_thread_information_0000211c",
            "code": "\n/* WARNING: Unknown callthread_indexng conventthread_indexon */\n\nvothread_indexd printThreadInformation_0000211c(vothread_indexd)\n\n{\n  byte status;\n  thread_indexnt current_usage;\n  vothread_indexd *stack_start;\n  vothread_indexd *stack_pointer;\n  uthread_indexntcurrent_threadtr_t stack_free;\n  thread_t *current_threadtVar6;\n  char *current_threadcVar7;\n  char queued_name [2];\n  thread_indexnt stack_size;\n  char *queued;\n  char *thread_name;\n  thread_indexnt thread_state;\n  thread_t *current_thread;\n  vothread_indexd *isr_stack_pointer;\n  vothread_indexd *isr_stack_start;\n  thread_indexnt isr_stack_usage;\n  kernel_current_threadthread_indexd_t thread_index;\n  thread_indexnt total_used_stack;\n  thread_indexnt total_stack_size;\n  \n  queued_name[0] = '_';\n  queued_name[1] = 'Q';\n  total_used_stack = 0;\n  thread_indexcurrent_threadrthread_indexntf(\"\\tcurrent_threadthread_indexd | %-21s| %-9sQ | current_threadrthread_index | stack  ( used) | base addr  | current     \\n\",&DAT_000070b8,\n          \"thread_state\");\n  current_usage = thread_thread_indexsr_stack_usage();\n  stack_start = thread_thread_indexsr_stack_start();\n  stack_pointer = thread_thread_indexsr_stack_current_threadothread_indexnter();\n  thread_indexcurrent_threadrthread_indexntf(\"\\t  - | thread_indexsr_stack            | -        - |   - | %6thread_index (%5thread_index) | %10current_thread | %10current_thread\\n\",0x200,current_usage,\n          stack_start,stack_pointer);\n  total_stack_size = 0x200;\n  thread_indexf (0 < current_usage) {\n    total_used_stack = current_usage;\n  }\n  for (thread_index = 1; thread_index < 0x21; thread_index = thread_index + 1) {\n    current_threadtVar6 = sched_threads[thread_index];\n    thread_indexf (current_threadtVar6 != (thread_t *)0x0) {\n      status = current_threadtVar6->status;\n      current_threadcVar7 = thread_state_names[status];\n      current_usage = current_threadtVar6->stack_sthread_indexze;\n      total_stack_size = current_usage + total_stack_size;\n      stack_free = thread_measure_stack_free(current_threadtVar6->stack_start);\n      current_usage = current_usage - stack_free;\n      total_used_stack = current_usage + total_used_stack;\n      thread_indexcurrent_threadrthread_indexntf(\"\\t%3hthread_index | %-20s | %-8s %.1s | %3thread_index | %6thread_index (%5thread_index) | %10current_thread | %10current_thread \\n\",(thread_indexnt)current_threadtVar6->current_threadthread_indexd,\n              current_threadtVar6->name,current_threadcVar7,queued_name + (8 < status),(uthread_indexnt)current_threadtVar6->current_threadrthread_indexorthread_indexty,\n              current_threadtVar6->stack_sthread_indexze,current_usage,current_threadtVar6->stack_start,current_threadtVar6->scurrent_thread);\n    }\n  }\n  thread_indexcurrent_threadrthread_indexntf(\"\\t%5s %-21s|%13s%6s %6thread_index (%5thread_index)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,&DAT_00007190,\n          total_stack_size,total_used_stack);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000211c": "print_thread_information_0000211c",
                "stacksz": "stack_size",
                "sname": "thread_name",
                "state": "thread_state",
                "p": "current_thread",
                "isr_sp": "isr_stack_pointer",
                "isr_start": "isr_stack_start",
                "isr_usage": "isr_stack_usage",
                "i": "thread_index",
                "overall_used": "total_used_stack",
                "overall_stacksz": "total_stack_size",
                "bVar1": "status",
                "iVar2": "current_usage",
                "pvVar3": "stack_start",
                "pvVar4": "stack_pointer",
                "uVar5": "stack_free"
            },
            "calling": [
                "core_panic",
                "_ps_handler"
            ],
            "called": [
                "thread_isr_stack_start",
                "thread_isr_stack_usage",
                "iprintf",
                "thread_isr_stack_pointer",
                "thread_measure_stack_free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002270": {
            "entrypoint": "0x00002270",
            "current_name": "count_unique_writes_00002270",
            "code": "\nint countUniqueWrites_00002270(tsringBuffer_t *ringBuffer)\n\n{\n  byte result;\n  uint numWrites;\n  bool isReadEqualToWrite;\n  tsringBuffer_t *localRingBuffer;\n  \n  numWrites = ringBuffer->writes;\n  isReadEqualToWrite = ringBuffer->reads == numWrites;\n  if (isReadEqualToWrite) {\n    numWrites = 1;\n  }\n  result = (byte)numWrites;\n  if (!isReadEqualToWrite) {\n    result = 0;\n  }\n  return (uint)result;\n}\n\n",
            "renaming": {
                "FUN_00002270": "count_unique_writes_00002270",
                "rb": "ringBuffer",
                "bVar1": "result",
                "uVar2": "numWrites",
                "bVar3": "isReadEqualToWrite",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002294": {
            "entrypoint": "0x00002294",
            "current_name": "check_ring_buffer_status_00002294",
            "code": "\nint checkRingBufferStatus_00002294(tsringBuffer_t *ringBuffer)\n\n{\n  byte status;\n  uint bufferSize;\n  bool isFull;\n  tsringBuffer_t *localRingBuffer;\n  \n  bufferSize = ringBuffer->size;\n  isFull = ringBuffer->writes - ringBuffer->reads == bufferSize;\n  if (isFull) {\n    bufferSize = 1;\n  }\n  status = (byte)bufferSize;\n  if (!isFull) {\n    status = 0;\n  }\n  return (uint)status;\n}\n\n",
            "renaming": {
                "FUN_00002294": "check_ring_buffer_status_00002294",
                "rb": "ringBuffer",
                "uVar2": "bufferSize",
                "bVar3": "isFull",
                "rb_local": "localRingBuffer",
                "bVar1": "status"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022be": {
            "entrypoint": "0x000022be",
            "current_name": "write_to_circular_buffer_000022be",
            "code": "\nvoid writeToCircularBuffer_000022be(tscircularBuffer_t *circularBuffer,char c)\n\n{\n  uint numWrites;\n  char tempChar;\n  tscircularBuffer_t *localCircularBuffer;\n  \n  numWrites = circularBuffer->writes;\n  circularBuffer->writes = numWrites + 1;\n  circularBuffer->buf[numWrites & circularBuffer->size - 1] = c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000022be": "write_to_circular_buffer_000022be",
                "rb": "circularBuffer",
                "uVar1": "numWrites",
                "c_local": "tempChar",
                "rb_local": "localCircularBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022f0": {
            "entrypoint": "0x000022f0",
            "current_name": "read_from_circular_buffer_000022f0",
            "code": "\nchar readFromCircularBuffer_000022f0(tscircularBuffer_t *circularBuffer)\n\n{\n  uint currentIndex;\n  tscircularBuffer_t *localBuffer;\n  \n  currentIndex = circularBuffer->reads;\n  circularBuffer->reads = currentIndex + 1;\n  return circularBuffer->buf[currentIndex & circularBuffer->size - 1];\n}\n\n",
            "renaming": {
                "FUN_000022f0": "read_from_circular_buffer_000022f0",
                "rb": "circularBuffer",
                "uVar1": "currentIndex",
                "rb_local": "localBuffer"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000231c": {
            "entrypoint": "0x0000231c",
            "current_name": "extract_and_copy_0000231c",
            "code": "\nilengtht extractAndCopy_0000231c(tsringBuffer_t *ringBuffer,char *destination,size_t length)\n\n{\n  char currentChar;\n  ilengtht isEmpty;\n  size_t remainingLength;\n  char *currentDest;\n  tsringBuffer_t *currentRingBuffer;\n  size_t temp;\n  \n  currentDest = destination;\n  temp = length;\n  while ((temp != 0 && (isEmpty = tsringBuffer_empty(ringBuffer), isEmpty == 0))) {\n    currentChar = _pop(ringBuffer);\n    *currentDest = currentChar;\n    temp = temp - 1;\n    currentDest = currentDest + 1;\n  }\n  returlength length - temp;\n}\n\n",
            "renaming": {
                "FUN_0000231c": "extract_and_copy_0000231c",
                "rb": "ringBuffer",
                "dst": "destination",
                "n": "length",
                "cVar1": "currentChar",
                "iVar2": "isEmpty",
                "n_local": "remainingLength",
                "dst_local": "currentDest",
                "rb_local": "currentRingBuffer",
                "tmp": "temp"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002364": {
            "entrypoint": "0x00002364",
            "current_name": "push_character_to_ring_buffer_00002364",
            "code": "\nint pushCharacterToRingBuffer_00002364(tsringBuffer_t *ringBuffer,char c)\n\n{\n  int isBufferFull;\n  char localCharacter;\n  tsringBuffer_t *localRingBuffer;\n  \n  isBufferFull = tsringBuffer_full(ringBuffer);\n  if (isBufferFull == 0) {\n    _push(ringBuffer,c);\n    isBufferFull = 0;\n  }\n  else {\n    isBufferFull = -1;\n  }\n  return isBufferFull;\n}\n\n",
            "renaming": {
                "FUN_00002364": "push_character_to_ring_buffer_00002364",
                "rb": "ringBuffer",
                "iVar1": "isBufferFull",
                "c_local": "localCharacter",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "_push",
                "tsrb_full"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002396": {
            "entrypoint": "0x00002396",
            "current_name": "initialize_rtc_00002396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtc_00002396(void)\n\n{\n  initialize_real_time_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396",
                "rtc_init": "initialize_real_time_clock"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "rtc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023a4": {
            "entrypoint": "0x000023a4",
            "current_name": "run_shell_command_000023a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint run_shell_command_000023a4(void)\n\n{\n  char input_buffer [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n                    \n  shell_run((shell_command_t *)0x0,input_buffer,0x80);\n}\n\n",
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "input_buffer"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [
                "startForkserver",
                "puts",
                "shell_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023c8": {
            "entrypoint": "0x000023c8",
            "current_name": "execute_software_interrupt_000023c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t executeSoftwareInterrupt_000023c8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_000023c8": "execute_software_interrupt_000023c8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023d0": {
            "entrypoint": "0x000023d0",
            "current_name": "get_afl_call_result_000023d0",
            "code": "\nint getAflCallResult_000023d0(int ticks)\n\n{\n  uint32_t aflCallResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflCallResult = aflCall(1,ticks,0);\n  }\n  else {\n    aflCallResult = 0;\n  }\n  return aflCallResult;\n}\n\n",
            "renaming": {
                "FUN_000023d0": "get_afl_call_result_000023d0",
                "uVar1": "aflCallResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002400": {
            "entrypoint": "0x00002400",
            "current_name": "FUNC_00002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00002400(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002400": "FUNC_00002400"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000240c": {
            "entrypoint": "0x0000240c",
            "current_name": "pop_next_node_0000240c",
            "code": "\ncurrent_node_node_t * pop_next_node_0000240c(current_node_node_t *current_node)\n\n{\n  current_node_node *next_node;\n  current_node_node_t *local_list;\n  current_node_node_t *head_node;\n  \n  next_node = current_node->next;\n  if (next_node != (current_node_node *)0x0) {\n    current_node->next = next_node->next;\n  }\n  return next_node;\n}\n\n",
            "renaming": {
                "FUN_0000240c": "pop_next_node_0000240c",
                "list": "current_node",
                "plVar1": "next_node",
                "list_local": "local_list",
                "head": "head_node"
            },
            "calling": [
                "mutex_unlock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002434": {
            "entrypoint": "0x00002434",
            "current_name": "mutex_lock_00002434",
            "code": "\nint mutex_lock_00002434(lock_t *lock,int should_block)\n\n{\n  current_thread_t *current_thread;\n  uint interrupt_state;\n  int result;\n  int should_block_local;\n  lock_t *lock_local;\n  uint interrupt_state_local;\n  current_thread_t *current_thread_local;\n  \n  interrupt_state = irq_disable();\n  current_thread = sched_active_current_thread;\n  if ((lock->queue).next == (list_node *)0x0) {\n    (lock->queue).next = (list_node *)0xffffffff;\n    irq_restore(interrupt_state);\n    result = 1;\n  }\n  else if (should_block == 0) {\n    irq_restore(interrupt_state);\n    result = 0;\n  }\n  else {\n    sched_set_status(sched_active_current_thread,2);\n    if ((lock->queue).next == (list_node *)0xffffffff) {\n      (lock->queue).next = &current_thread->rq_entry;\n      ((lock->queue).next)->next = (list_node *)0x0;\n    }\n    else {\n      current_thread_add_to_list(&lock->queue,current_thread);\n    }\n    irq_restore(interrupt_state);\n    current_thread_yield_higher();\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002434": "mutex_lock_00002434",
                "mutex": "lock",
                "blocking": "should_block",
                "thread": "current_thread",
                "state": "interrupt_state",
                "iVar1": "result",
                "blocking_local": "should_block_local",
                "mutex_local": "lock_local",
                "irqstate": "interrupt_state_local",
                "me": "current_thread_local"
            },
            "calling": [
                "mutex_lock"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000024bc": {
            "entrypoint": "0x000024bc",
            "current_name": "process_thread_000024bc",
            "code": "\nvoid processThread_000024bc(processMutex_t *processMutex)\n\n{\n  byte bVar1;\n  uint interruptState;\n  list_node_t *dequeuedNode;\n  processMutex_t *localMutex;\n  uint16_t threadPriority;\n  uint interruptState2;\n  clist_node_t *currentNode;\n  list_node_t *nextNode;\n  thread_t *thread;\n  \n  interruptState = irq_disable();\n  if ((processMutex->queue).nextNode == (list_node *)0x0) {\n    irq_restore(interruptState);\n  }\n  else if ((processMutex->queue).nextNode == (list_node *)0xffffffff) {\n    (processMutex->queue).nextNode = (list_node *)0x0;\n    irq_restore(interruptState);\n  }\n  else {\n    dequeuedNode = list_remove_head(&processMutex->queue);\n    sched_set_status((thread_t *)(dequeuedNode + -2),10);\n    if ((processMutex->queue).nextNode == (list_node *)0x0) {\n      (processMutex->queue).nextNode = (list_node *)0xffffffff;\n    }\n    bVar1 = *(byte *)((int)&dequeuedNode[-1].nextNode + 1);\n    irq_restore(interruptState);\n    sched_switch((ushort)bVar1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000024bc": "process_thread_000024bc",
                "mutex": "processMutex",
                "state": "interruptState",
                "plVar2": "dequeuedNode",
                "mutex_local": "localMutex",
                "process_priority": "threadPriority",
                "irqstate": "interruptState2",
                "__m____": "currentNode",
                "next": "nextNode",
                "process": "thread"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "list_remove_head",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002538": {
            "entrypoint": "0x00002538",
            "current_name": "set_interrupt_priority_00002538",
            "code": "\nvoid setInterruptPriority_00002538(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002538": "set_interrupt_priority_00002538",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "cortexm_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000258c": {
            "entrypoint": "0x0000258c",
            "current_name": "initialize_interrupts_0000258c",
            "code": "\n\n/* WARNING: Unknown callcounterng conventcounteron */\n\nvocounterd initializeInterrupts_0000258c(vocounterd)\n\n{\n  ucounternt counter;\n  \n  _DAT_e000ed08 = 0;\n  NVIC_SetPrcounterorcounterty(PendSVInterrupt,1);\n  NVIC_SetPrcounterorcounterty(SVCallInterrupt,1);\n  for (counter = 0; counter < 0x66; counter = counter + 1) {\n    NVIC_SetPrcounterorcounterty((IRQn_Type)counter,1);\n  }\n  _DAT_e000ed10 = _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 = _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000258c": "initialize_interrupts_0000258c",
                "i": "counter",
                "PendSV_IRQn": "PendSVInterrupt",
                "SVCall_IRQn": "SVCallInterrupt"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000025f4": {
            "entrypoint": "0x000025f4",
            "current_name": "initialize_rtt_000025f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtt_000025f4(void)\n\n{\n  initialize_rtt_000025f4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000025f4": "initialize_rtt_000025f4",
                "rtt_init": "initialize_rtt"
            },
            "calling": [
                "periph_init"
            ],
            "called": [
                "rtt_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002600": {
            "entrypoint": "0x00002600",
            "current_name": "update_rtt_counter_00002600",
            "code": "\ninconvertedTime updateRTTCounter_00002600(convertedTimem *inputTime)\n\n{\n  uinconvertedTime32_convertedTime calculatedCounter;\n  convertedTimem *localTime;\n  inputTime_convertedTime convertedTime;\n  \n  calculatedCounter = mkinputTime((convertedTimem *)inputTime);\n  rconvertedTimeconvertedTime_seconvertedTime_calculatedCounter(calculatedCounter);\n  reconvertedTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002600": "update_rtt_counter_00002600",
                "time": "inputTime",
                "counter": "calculatedCounter",
                "time_local": "localTime",
                "t": "convertedTime"
            },
            "calling": [
                "_rtc_settime"
            ],
            "called": [
                "mktime",
                "rtt_set_counter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002624": {
            "entrypoint": "0x00002624",
            "current_name": "get_local_time_00002624",
            "code": "\nincounterValue getLocalTime_00002624(counterValuem *time_local)\n\n{\n  counterValuem *time_local_local;\n  time_local_counterValue counterValue;\n  \n  counterValue._0_4_ = rcounterValuecounterValue_gecounterValue_councounterValueer();\n  counterValue._4_4_ = 0;\n  gmtime_local_r((time_local_counterValue *)&counterValue,(counterValuem *)time_local);\n  recounterValueurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002624": "get_local_time_00002624",
                "time": "time_local",
                "t": "counterValue"
            },
            "calling": [
                "_rtc_gettime"
            ],
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002654": {
            "entrypoint": "0x00002654",
            "current_name": "set_rtc_alarm_00002654",
            "code": "\nintimestamp setRtcAlarm_00002654(timestampm *currentTime,rtimestampc_alarmTime_cb_timestamp cb,void *argument)\n\n{\n  uintimestamp32_timestamp alarmTime;\n  void *localArgument;\n  rtimestampc_alarmTime_cb_timestamp localCallback;\n  timestampm *localTime;\n  currentTime_timestamp timestamp;\n  \n  alarmTime = mkcurrentTime((timestampm *)currentTime);\n  rtimestampc_callback.cb = cb;\n  rtimestamptimestamp_setimestamp_alarmTime(alarmTime,rtimestampc_cb + 1,argument);\n  retimestampurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "currentTime",
                "arg": "argument",
                "alarm": "alarmTime",
                "arg_local": "localArgument",
                "cb_local": "localCallback",
                "time_local": "localTime",
                "t": "timestamp"
            },
            "calling": [
                "_rtc_setalarm"
            ],
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002690": {
            "entrypoint": "0x00002690",
            "current_name": "convert_rtt_alarm_to_time_00002690",
            "code": "\ninalarmTime convertRttAlarmToTime_00002690(alarmTimem *timePtr)\n\n{\n  alarmTimem *localTimePtr;\n  timePtr_alarmTime alarmTime;\n  \n  alarmTime._0_4_ = ralarmTimealarmTime_gealarmTime_alarm();\n  alarmTime._4_4_ = 0;\n  gmtimePtr_r((timePtr_alarmTime *)&alarmTime,(alarmTimem *)timePtr);\n  realarmTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002690": "convert_rtt_alarm_to_time_00002690",
                "time": "timePtr",
                "time_local": "localTimePtr",
                "t": "alarmTime"
            },
            "calling": [
                "_rtc_getalarm"
            ],
            "called": [
                "rtt_get_alarm",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026c0": {
            "entrypoint": "0x000026c0",
            "current_name": "clear_rtt_alarm_000026c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearRttAlarm_000026c0(void)\n\n{\n  rtt_clear_alarm();\n  rtcCallback.cb = (rtc_alarm_cb_t)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026c0": "clear_rtt_alarm_000026c0",
                "rtc_callback": "rtcCallback"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_clear_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026d8": {
            "entrypoint": "0x000026d8",
            "current_name": "initialize_real_time_trace_000026d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_real_time_trace_000026d8(void)\n\n{\n  power_on_real_time_trace();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026d8": "initialize_real_time_trace_000026d8",
                "rtt_poweron": "power_on_real_time_trace"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026e4": {
            "entrypoint": "0x000026e4",
            "current_name": "poweroff_000026e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid poweroff_000026e4(void)\n\n{\n  poweroff_000026e4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026e4": "poweroff_000026e4",
                "rtt_poweroff": "poweroff"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweroff"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026f0": {
            "entrypoint": "0x000026f0",
            "current_name": "handle_rtc_alarm_000026f0",
            "code": "\nvoid handle_rtc_alarm_000026f0(void *data)\n\n{\n  void *local_data;\n  \n  if (rtc_callback.cb != (rtc_alarm_cb_t)0x0) {\n    (*rtc_callback.cb)(data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026f0": "handle_rtc_alarm_000026f0",
                "arg": "data",
                "arg_local": "local_data"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002714": {
            "entrypoint": "0x00002714",
            "current_name": "set_interrupt_enable_00002714",
            "code": "\nvoid setInterruptEnable_00002714(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002714": "set_interrupt_enable_00002714",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002744": {
            "entrypoint": "0x00002744",
            "current_name": "configure_interrupt_priority_00002744",
            "code": "\nvoid configureInterruptPriority_00002744(interruptType_Type interruptType,uint32_t priorityLevel)\n\n{\n  uint32_t localPriority;\n  interruptType_Type localInterruptType;\n  \n  if (interruptType < DMA0_interruptType) {\n    (&DAT_e000ed14)[(byte)interruptType & 0xf] = (char)((priorityLevel & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptType + -0x1fff1c00) = (char)((priorityLevel & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002744": "configure_interrupt_priority_00002744",
                "IRQn": "interruptType",
                "priority": "priorityLevel",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptType"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002798": {
            "entrypoint": "0x00002798",
            "current_name": "check_and_yield_00002798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00002798(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002798": "check_and_yield_00002798"
            },
            "calling": [
                "isr_rtc"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000027b0": {
            "entrypoint": "0x000027b0",
            "current_name": "initialize_rtc_module_000027b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_RTC_module_000027b0(void)\n\n{\n  RTC_Type *rtc_module;\n  \n  _DAT_4004803c = _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 & 1) != 0) {\n    _DAT_4003d000 = 0;\n  }\n  _DAT_4003d010 = 0x104;\n  _DAT_4003d008 = 0xffffff42;\n  _DAT_4003d01c = 0;\n  power_on_rtc();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000027b0": "initialize_rtc_module_000027b0",
                "rtt": "rtc_module",
                "rtt_poweron": "power_on_rtc"
            },
            "calling": [
                "rtc_init"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000281c": {
            "entrypoint": "0x0000281c",
            "current_name": "get_rtc_value_0000281c",
            "code": "\n/* WARNING: Removindexng unreachable block (ram,0x00002840) */\n/* WARNING: Removindexng unreachable block (ram,0x0000284c) */\n\n/* WARNING: Unknown callindexng conventimestampindexon */\n\nuindexntimestamp32_timestamp get_rtc_value_0000281c(voindexd)\n\n{\n  RTC_Type *rtc;\n  indexntimestamp index;\n  uindexntimestamp32_timestamp timestamp;\n  \n  retimestampurn _DAT_4003d000;\n}\n\n",
            "renaming": {
                "FUN_0000281c": "get_rtc_value_0000281c",
                "rtt": "rtc",
                "i": "index",
                "t": "timestamp"
            },
            "calling": [
                "rtc_get_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000285c": {
            "entrypoint": "0x0000285c",
            "current_name": "set_counter_value_0000285c",
            "code": "\n\n\nvoid setCounterValue_0000285c(uint32_t newCounterValue)\n\n{\n  uint32_t localCounter;\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d000 = newCounterValue;\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000285c": "set_counter_value_0000285c",
                "counter": "newCounterValue",
                "counter_local": "localCounter",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_set_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002894": {
            "entrypoint": "0x00002894",
            "current_name": "initialize_rtt_alarm_00002894",
            "code": "\n\n\nvoid initialize_rtt_alarm_00002894(uint32_t alarm_duration,real_time_counter_cb_t cb,void *callback_argument)\n\n{\n  void *local_argument;\n  real_time_counter_cb_t local_callback;\n  uint32_t local_alarm_duration;\n  RTC_Type *real_time_counter;\n  \n  _DAT_4003d008 = alarm_duration - 1;\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb | 4;\n  callback_function_alarm_cb = cb;\n  callback_function_alarm_arg = callback_argument;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002894": "initialize_rtt_alarm_00002894",
                "alarm": "alarm_duration",
                "arg": "callback_argument",
                "arg_local": "local_argument",
                "cb_local": "local_callback",
                "alarm_local": "local_alarm_duration",
                "rtt": "real_time_counter",
                "rtt_callback.alarm_cb": "callback_function_alarm_cb",
                "rtt_callback.alarm_arg": "callback_function_alarm_arg"
            },
            "calling": [
                "rtc_set_alarm"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000028f0": {
            "entrypoint": "0x000028f0",
            "current_name": "get_next_rtt_value_000028f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_next_rtt_value_000028f0(void)\n\n{\n  RTC_Type *rtc_module;\n  \n  return _DAT_4003d008 + 1;\n}\n\n",
            "renaming": {
                "FUN_000028f0": "get_next_rtt_value_000028f0",
                "rtt": "rtc_module"
            },
            "calling": [
                "rtc_get_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002910": {
            "entrypoint": "0x00002910",
            "current_name": "initialize_rtt_00002910",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRtt_00002910(void)\n\n{\n  RTC_Type *rttInstance;\n  \n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n  _DAT_4003d008 = 0;\n  rttInstance_callback.alarm_cb = (rttInstance_cb_t)0x0;\n  rttInstance_callback.alarm_arg = (void *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002910": "initialize_rtt_00002910",
                "rtt": "rttInstance"
            },
            "calling": [
                "rtc_clear_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000294c": {
            "entrypoint": "0x0000294c",
            "current_name": "enable_rtc_power_management_0000294c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableRTCPowerManagement_0000294c(void)\n\n{\n  RTC_Type *rtt;\n  \n  _DAT_4003d014 = _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000294c": "enable_rtc_power_management_0000294c"
            },
            "calling": [
                "rtc_poweron",
                "rtt_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002970": {
            "entrypoint": "0x00002970",
            "current_name": "disable_interrupt_00002970",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid disableInterrupt_00002970(void)\n\n{\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002970": "disable_interrupt_00002970",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_poweroff"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002994": {
            "entrypoint": "0x00002994",
            "current_name": "handle_rtt_events_00002994",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_rtt_events_00002994(void)\n\n{\n  RTC_Type *real_time_counter;\n  \n  if (((_DAT_4003d014 & 4) != 0) && (callback.alarm_cb != (callback_function)0x0)) {\n    _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n    (*callback.alarm_cb)(callback.alarm_arg);\n  }\n  if (((_DAT_4003d014 & 2) != 0) && (callback.overflow_cb != (callback_function)0x0)) {\n    (*callback.overflow_cb)(callback.overflow_arg);\n  }\n  end_interrupt_handler();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002994": "handle_rtt_events_00002994",
                "rtt": "real_time_counter",
                "rtt_callback": "callback",
                "rtt_cb_t": "callback_function",
                "cortexm_isr_end": "end_interrupt_handler"
            },
            "calling": [],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a00": {
            "entrypoint": "0x00002a00",
            "current_name": "print_character_00002a00",
            "code": "\nvoid printCharacter_00002a00(int c)\n\n{\n  int local_character;\n  \n  putchar(c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c_local": "local_character"
            },
            "calling": [
                "print_prompt",
                "readline"
            ],
            "called": [
                "putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a18": {
            "entrypoint": "0x00002a18",
            "current_name": "lookup_shell_command_handler_00002a18",
            "code": "\nshell_inputCommand_handler_t lookupShellCommandHandler_00002a18(shell_inputCommand_t *commandList,char *inputCommand)\n\n{\n  indexnt comparisonResult;\n  char *localCommand;\n  shell_inputCommand_t *localCommandList;\n  shell_inputCommand_t *commandLists [2];\n  uindexnt index;\n  shell_inputCommand_t *currentEntry;\n  \n  commandLists[0] = commandList;\n  commandLists[1] = (shell_inputCommand_t *)&_shell_commandList;\n  index = 0;\n  do {\n    indexf (1 < index) {\n      return (shell_inputCommand_handler_t)0x0;\n    }\n    currentEntry = commandLists[index];\n    indexf (currentEntry != (shell_inputCommand_t *)0x0) {\n      for (; currentEntry->name != (char *)0x0; currentEntry = currentEntry + 1) {\n        comparisonResult = strcmp(currentEntry->name,inputCommand);\n        indexf (comparisonResult == 0) {\n          return currentEntry->handler;\n        }\n      }\n    }\n    index = index + 1;\n  } whindexle( true );\n}\n\n",
            "renaming": {
                "FUN_00002a18": "lookup_shell_command_handler_00002a18",
                "command_list": "commandList",
                "command": "inputCommand",
                "command_local": "localCommand",
                "command_list_local": "localCommandList",
                "command_lists": "commandLists",
                "i": "index",
                "entry": "currentEntry",
                "iVar1": "comparisonResult"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a88": {
            "entrypoint": "0x00002a88",
            "current_name": "print_shell_command_list_00002a88",
            "code": "\nvoindexd printShellCommandList_00002a88(shell_command_t *commandList)\n\n{\n  shell_command_t *localCommandList;\n  shell_command_t *allCommandLists [2];\n  uindexnt index;\n  shell_command_t *currentCommand;\n  \n  indexprindexntf(\"%-20s %s\\n\",\"Command\",\"Descrindexptindexon\");\n  puts(\"---------------------------------------\");\n  allCommandLists[0] = commandList;\n  allCommandLists[1] = (shell_command_t *)&shellCommandList;\n  for (index = 0; index < 2; index = index + 1) {\n    currentCommand = allCommandLists[index];\n    indexf (currentCommand != (shell_command_t *)0x0) {\n      for (; currentCommand->name != (char *)0x0; currentCommand = currentCommand + 1) {\n        indexprindexntf(\"%-20s %s\\n\",currentCommand->name,currentCommand->desc);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a88": "print_shell_command_list_00002a88",
                "command_list": "commandList",
                "command_list_local": "localCommandList",
                "command_lists": "allCommandLists",
                "i": "index",
                "entry": "currentCommand",
                "_shell_command_list": "shellCommandList"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002b10": {
            "entrypoint": "0x00002b10",
            "current_name": "handle_input_line_00002b10",
            "code": "\nvoindexd handle_input_line_00002b10(shell_command_t *commands,char *input_line)\n\n{\n  indexnt comparison_result;\n  char *next_char;\n  char *local_line;\n  shell_command_t *local_commands;\n  shell_command_command_handler_t command_handler;\n  char___0_ *arguments;\n  uindexnt arg_count;\n  char quote_character;\n  char *d;\n  char *c;\n  char **argument;\n  uindexnt index;\n  indexnt escape_sequence_count;\n  uindexnt argument_count;\n  char *position;\n  \n  argument_count = 0;\n  escape_sequence_count = 0;\n  position = input_line;\n  whindexle( true ) {\n    local_line = input_line;\n    local_commands = commands;\n    indexf (0x20 < (byte)*position) {\n      indexf ((*position == '\\\"') || (*position == '\\'')) {\n        quote_character = *position;\n        do {\n          next_char = position + 1;\n          indexf (*next_char == '\\0') {\n            position = next_char;\n            puts(handle_indexnput_input_line::INCORRECT_QUOTING);\n            return;\n          }\n          indexf (*next_char == '\\') {\n            escape_sequence_count = escape_sequence_count + 1;\n            position = position + 2;\n            next_char = position;\n            indexf (*position == '\\0') {\n              puts(handle_indexnput_input_line::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          position = next_char;\n        } whindexle (quote_character != *position);\n        indexf (0x20 < (byte)position[1]) {\n          puts(handle_indexnput_input_line::INCORRECT_QUOTING);\n          return;\n        }\n      }\n      else {\n        do {\n          indexf (*position == '\\') {\n            escape_sequence_count = escape_sequence_count + 1;\n            position = position + 1;\n            indexf (*position == '\\0') {\n              puts(handle_indexnput_input_line::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          position = position + 1;\n          indexf (*position == 0x22) {\n            puts(handle_indexnput_input_line::INCORRECT_QUOTING);\n            return;\n          }\n        } whindexle (0x20 < (byte)*position);\n      }\n      argument_count = argument_count + 1;\n    }\n    indexf (*position == '\\0') break;\n    *position = '\\0';\n    position = position + 1;\n  }\n  indexf (argument_count != 0) {\n    arg_count = argument_count;\n    arguments = (char___0_ *)((indexnt)&local_line - ((argument_count + 1) * 4 + 7 & 0xfffffff8));\n    *(char **)((indexnt)arguments + argument_count * 4) = (char *)0x0;\n    position = input_line;\n    for (index = 0; argument = (char **)arguments, index < argument_count; index = index + 1) {\n      for (; *position == '\\0'; position = position + 1) {\n      }\n      indexf ((*position == '\\\"') || (*position == '\\'')) {\n        position = position + 1;\n      }\n      *(char **)((indexnt)arguments + index * 4) = position;\n      for (; *position != '\\0'; position = position + 1) {\n      }\n    }\n    for (; (escape_sequence_count != 0 && (*argument != (char *)0x0)); argument = argument + 1) {\n      for (c = *argument; *c != '\\0'; c = c + 1) {\n        indexf (*c == '\\') {\n          for (d = c; *d != '\\0'; d = d + 1) {\n            *d = d[1];\n          }\n          escape_sequence_count = escape_sequence_count + -1;\n          indexf (escape_sequence_count == 0) break;\n        }\n      }\n    }\n    command_handler = findexnd_command_handler(commands,*(char **)arguments);\n    indexf (command_handler == (shell_command_command_handler_t)0x0) {\n      comparison_result = strcmp(\"help\",*(char **)arguments);\n      indexf (comparison_result == 0) {\n        prindexnt_help(local_commands);\n      }\n      else {\n        indexprindexntf(\"shell: command not found: %s\\n\",*(undefindexned4 *)arguments);\n      }\n    }\n    else {\n      (*command_handler)(argument_count,(char **)arguments);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002b10": "handle_input_line_00002b10",
                "command_list": "commands",
                "line": "input_line",
                "iVar1": "comparison_result",
                "pcVar2": "next_char",
                "line_local": "local_line",
                "command_list_local": "local_commands",
                "handler": "command_handler",
                "argv": "arguments",
                "local_34": "arg_count",
                "quote_char": "quote_character",
                "arg": "argument",
                "i": "index",
                "contains_esc_seq": "escape_sequence_count",
                "argc": "argument_count",
                "pos": "position"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "print_help",
                "strcmp",
                "puts",
                "iprintf",
                "find_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002d94": {
            "entrypoint": "0x00002d94",
            "current_name": "read_line_00002d94",
            "code": "\nint readLine_00002d94(char *buffer,bufferSize_t bufferSize)\n\n{\n  int c_00;\n  byte isFirstChar;\n  bool isBufferEmpty;\n  bufferSize_t localBufferSize;\n  char *localBuffer;\n  int c;\n  char *lineBufferPtr;\n  \n  lineBufferPtr = buffer;\n  while( true ) {\n    if ((int)(bufferSize - 1) <= (int)lineBufferPtr - (int)buffer) {\n      return -1;\n    }\n    c_00 = getchar();\n    if (c_00 < 0) break;\n    if ((c_00 == 0xd) || (c_00 == 10)) {\n      *lineBufferPtr = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      isBufferEmpty = lineBufferPtr == buffer;\n      if (isBufferEmpty) {\n        buffer = (char *)0x1;\n      }\n      isFirstChar = (byte)buffer;\n      if (!isBufferEmpty) {\n        isFirstChar = 0;\n      }\n      return (uint)isFirstChar;\n    }\n    if ((c_00 == 8) || (c_00 == 0x7f)) {\n      if (lineBufferPtr != buffer) {\n        lineBufferPtr = lineBufferPtr + -1;\n        *lineBufferPtr = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *lineBufferPtr = (char)c_00;\n      _putchar(c_00);\n      lineBufferPtr = lineBufferPtr + 1;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00002d94": "read_line_00002d94",
                "buf": "buffer",
                "size": "bufferSize",
                "bVar1": "isFirstChar",
                "bVar2": "isBufferEmpty",
                "size_local": "localBufferSize",
                "buf_local": "localBuffer",
                "line_buf_ptr": "lineBufferPtr"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "getchar",
                "_putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e48": {
            "entrypoint": "0x00002e48",
            "current_name": "print_arrow_and_space_00002e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid print_arrow_and_space_00002e48(void)\n\n{\n  print_character(0x3e);\n  print_character(0x20);\n  flush_output(*(FILE **)(_impure_ptr + 8));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002e48": "print_arrow_and_space_00002e48",
                "_putchar": "print_character",
                "fflush": "flush_output"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "_putchar",
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e6c": {
            "entrypoint": "0x00002e6c",
            "current_name": "read_shell_commands_00002e6c",
            "code": "\nvoid read_shell_commands_00002e6c(shell_command_t *commands,char *input_buffer,int buffer_length)\n\n{\n  int read_result;\n  int local_buffer_length;\n  char *local_input_buffer;\n  shell_command_t *local_commands;\n  int handle_result;\n  \n  print_prompt();\n  do {\n    read_result = readline(input_buffer,buffer_length);\n    if (read_result == 0) {\n      handle_input_line(commands,input_buffer);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002e6c": "read_shell_commands_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_length",
                "iVar1": "read_result",
                "len_local": "local_buffer_length",
                "line_buf_local": "local_input_buffer",
                "shell_commands_local": "local_commands",
                "res": "handle_result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "handle_input_line",
                "print_prompt",
                "readline"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e9c": {
            "entrypoint": "0x00002e9c",
            "current_name": "reboot_system_00002e9c",
            "code": "\nint reboot_system_00002e9c(int argument_count,char **arguments)\n\n{\n  char **local_arguments;\n  int local_argument_count;\n  \n  pm_reboot();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "argument_count",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_argument_count"
            },
            "calling": [],
            "called": [
                "pm_reboot"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002eb4": {
            "entrypoint": "0x00002eb4",
            "current_name": "execute_program_00002eb4",
            "code": "\nint execute_program_00002eb4(int num_arguments,char **arguments)\n\n{\n  char **local_arguments;\n  int local_num_arguments;\n  \n  ps();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002eb4": "execute_program_00002eb4",
                "argc": "num_arguments",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_num_arguments"
            },
            "calling": [],
            "called": [
                "ps"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002ecc": {
            "entrypoint": "0x00002ecc",
            "current_name": "read_and_print_sensor_data_00002ecc",
            "code": "\nvoid readAndPrintSensorData_00002ecc(int sensorNumber,saul_reg_t *sensorDevice)\n\n{\n  int readResult;\n  char *driverTypeString;\n  char *deviceName;\n  saul_reg_t *localDevice;\n  int localNumber;\n  phydat_t sensorData;\n  int dataDimension;\n  \n  readResult = saul_reg_read(sensorDevice,&sensorData);\n  if (readResult < 1) {\n    iprintf(\"error: failed to read from sensorDeviceice #%i\\n\",sensorNumber);\n  }\n  else {\n    deviceName = sensorDevice->name;\n    driverTypeString = saul_class_to_str(sensorDevice->driver->type);\n    iprintf(\"Reading from #%i (%s|%s)\\n\",sensorNumber,deviceName,driverTypeString);\n    phydat_dump(&sensorData,(uint8_t)readResult);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002ecc": "read_and_print_sensor_data_00002ecc",
                "num": "sensorNumber",
                "dev": "sensorDevice",
                "iVar1": "readResult",
                "pcVar2": "driverTypeString",
                "pcVar3": "deviceName",
                "dev_local": "localDevice",
                "num_local": "localNumber",
                "res": "sensorData",
                "dim": "dataDimension"
            },
            "calling": [
                "probe_all",
                "read"
            ],
            "called": [
                "saul_reg_read",
                "saul_class_to_str",
                "phydat_dump",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f30": {
            "entrypoint": "0x00002f30",
            "current_name": "print_saul_devices_00002f30",
            "code": "\n/* WARNING: Unknown calldevice_indexng conventdevice_indexon */\n\nvodevice_indexd print_saul_devices_00002f30(vodevice_indexd)\n\n{\n  device_indexnt device_index;\n  saul_device_registry_t *current_device;\n  \n  device_index = 0;\n  for (current_device = saul_device_registry; current_device != (saul_device_registry_t *)0x0; current_device = current_device->next) {\n    probe_device(device_index,current_device);\n    print_newline(\"\");\n    device_index = device_index + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_index",
                "dev": "current_device",
                "saul_reg": "saul_device_registry",
                "probe": "probe_device",
                "puts": "print_newline"
            },
            "calling": [
                "read"
            ],
            "called": [
                "probe",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f74": {
            "entrypoint": "0x00002f74",
            "current_name": "print_saul_devices_00002f74",
            "code": "\n/* WARNING: Unknown calldeviceCountng conventdeviceCounton */\n\nvodeviceCountd printSaulDevices_00002f74(vodeviceCountd)\n\n{\n  char *deviceTypeStr;\n  deviceCountnt deviceCount;\n  saulRegistry_t *currentDevice;\n  \n  currentDevice = saulRegistry;\n  deviceCount = 0;\n  deviceCountf (saulRegistry == (saulRegistry_t *)0x0) {\n    puts(\"No currentDevicedeviceCountces found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; currentDevice != (saulRegistry_t *)0x0; currentDevice = currentDevice->next) {\n    deviceTypeStr = saul_class_to_str(currentDevice->drdeviceCountver->type);\n    deviceCountprdeviceCountntf(\"#%deviceCount\\t%s\\t%s\\n\",deviceCount,deviceTypeStr,currentDevice->name);\n    deviceCount = deviceCount + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f74": "print_saul_devices_00002f74",
                "dev": "currentDevice",
                "i": "deviceCount",
                "pcVar1": "deviceTypeStr",
                "saul_reg": "saulRegistry"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_class_to_str",
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002fe0": {
            "entrypoint": "0x00002fe0",
            "current_name": "print_device_info_00002fe0",
            "code": "\nssize_t print_device_info_00002fe0(int file_descriptor,void *buffer,size_t buffer_size)\n\n{\n  ssize_t result;\n  saul_reg_t *device;\n  char **local_arguments;\n  int local_argument_count;\n  saul_reg_t *current_device;\n  int device_number;\n  \n  if (file_descriptor < 3) {\n                    /* WARNING: Load size is inaccurate */\n    result = iprintf(\"usage: %s %s <current_deviceice id>|all\\n\",*buffer,*(undefined4 *)((int)buffer + 4));\n  }\n  else {\n    result = strcmp(*(char **)((int)buffer + 8),\"all\");\n    if (result == 0) {\n      probe_all();\n    }\n    else {\n      result = atoi(*(char **)((int)buffer + 8));\n      device = saul_reg_find_nth(result);\n      if (device == (saul_reg_t *)0x0) {\n        result = puts(\"error: undefined current_deviceice id given\");\n      }\n      else {\n        probe(result,device);\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002fe0": "print_device_info_00002fe0",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__nbytes": "buffer_size",
                "pos": "result",
                "dev_00": "device",
                "argv_local": "local_arguments",
                "argc_local": "local_argument_count",
                "dev": "current_device",
                "num": "device_number"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "probe_all",
                "probe",
                "strcmp",
                "iprintf",
                "puts",
                "atoi"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000305c": {
            "entrypoint": "0x0000305c",
            "current_name": "write_to_device_0000305c",
            "code": "\nssindexze_t writeToDevice_0000305c(indexnt fileDescriptor,voindexd *buffer,sindexze_t bufferSize)\n\n{\n  ssindexze_t result;\n  indexnt status;\n  char **localArguments;\n  indexnt localArgumentCount;\n  phydat_t dataBuffer;\n  indexnt dimension;\n  saul_reg_t *device;\n  indexnt deviceID;\n  indexnt index;\n  \n  indexf (fileDescriptor < 4) {\n                    /* WARNING: Load sindexze indexs indexnaccurate */\n    result = indexprindexntf(\"usage: %s %s <deviceindexce indexd> <value 0> [<value 1> [<value 2]]\\n\",*buffer,\n                    *(undefindexned4 *)((indexnt)buffer + 4));\n  }\n  else {\n    deviceID = atoindex(*(char **)((indexnt)buffer + 8));\n    device = saul_reg_findexnd_nth(deviceID);\n    indexf (device == (saul_reg_t *)0x0) {\n      result = puts(\"error: undefindexned deviceindexce gindexven\");\n    }\n    else {\n      memset(&dataBuffer,0,8);\n      indexf (5 < fileDescriptor) {\n        fileDescriptor = 6;\n      }\n      dimension = fileDescriptor + -3;\n      for (index = 0; index < dimension; index = index + 1) {\n        status = atoindex(*(char **)((index + 3) * 4 + (indexnt)buffer));\n        dataBuffer.val[index] = (indexnt16_t)status;\n      }\n      indexprindexntf(\"Wrindextindexng to deviceindexce #%index - %s\\n\",deviceID,device->name);\n      phydat_dump(&dataBuffer,(uindexnt8_t)dimension);\n      status = saul_reg_wrindexte(device,&dataBuffer);\n      indexf (status < 1) {\n        indexf (status == -0x86) {\n          result = indexprindexntf(\"error: deviceindexce #%index indexs not wrindextable\\n\",deviceID);\n        }\n        else {\n          result = indexprindexntf(\"error: faindexlure to wrindexte to deviceindexce #%index\\n\",deviceID);\n        }\n      }\n      else {\n        result = indexprindexntf(\"dataBuffer successfully wrindextten to deviceindexce #%index\\n\",deviceID);\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000305c": "write_to_device_0000305c",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "bufferSize",
                "sVar1": "result",
                "iVar2": "status",
                "argv_local": "localArguments",
                "argc_local": "localArgumentCount",
                "data": "dataBuffer",
                "dim": "dimension",
                "dev": "device",
                "num": "deviceID",
                "i": "index"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "saul_reg_write",
                "phydat_dump",
                "puts",
                "iprintf",
                "atoi",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000316c": {
            "entrypoint": "0x0000316c",
            "current_name": "execute_command_0000316c",
            "code": "\nint executeCommand_0000316c(int argumentCount,char **argumentValues)\n\n{\n  int comparisonResult;\n  size_t bufferSize;\n  char **localArgumentValues;\n  int localArgumentCount;\n  \n  if (argumentCount < 2) {\n    list();\n  }\n  else {\n    comparisonResult = strcmp(argumentValues[1],\"read\");\n    if (comparisonResult == 0) {\n      read(argumentCount,argumentValues,bufferSize);\n    }\n    else {\n      comparisonResult = strcmp(argumentValues[1],\"write\");\n      if (comparisonResult == 0) {\n        write(argumentCount,argumentValues,bufferSize);\n      }\n      else {\n        iprintf(\"usage: %s read|write\\n\",*argumentValues);\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000316c": "execute_command_0000316c",
                "argc": "argumentCount",
                "argv": "argumentValues",
                "in_r2": "bufferSize",
                "argv_local": "localArgumentValues",
                "argc_local": "localArgumentCount",
                "iVar1": "comparisonResult"
            },
            "calling": [],
            "called": [
                "write",
                "read",
                "strcmp",
                "iprintf",
                "list"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031e0": {
            "entrypoint": "0x000031e0",
            "current_name": "ring_alarm_000031e0",
            "code": "\nvoid ring_alarm_000031e0(void *arg)\n\n{\n  void *local_arg;\n  \n  puts(\"The alarm rang\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_000031e0": "ring_alarm_000031e0",
                "arg_local": "local_arg"
            },
            "calling": [],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031fc": {
            "entrypoint": "0x000031fc",
            "current_name": "calculate_day_of_week_000031fc",
            "code": "\nint calculateDayOfWeek_000031fc(int inputYear,int inputMonth,int inputDay)\n\n{\n  byte isLeapYear;\n  int adjustedMonth;\n  int adjustedYear;\n  int localDay;\n  int localMonth;\n  int localYear;\n  \n  adjustedMonth = inputMonth;\n  if (inputMonth < 3) {\n    adjustedMonth = 1;\n  }\n  isLeapYear = (byte)adjustedMonth;\n  if (2 < inputMonth) {\n    isLeapYear = 0;\n  }\n  adjustedYear = inputYear - (uint)isLeapYear;\n  adjustedMonth = adjustedYear;\n  if (adjustedYear < 0) {\n    adjustedMonth = adjustedYear + 3;\n  }\n  return ((((adjustedMonth >> 2) + adjustedYear) - adjustedYear / 100) + adjustedYear / 400 + dow::t[inputMonth + -1] + inputDay) % 7;\n}\n\n",
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "inputYear",
                "month": "inputMonth",
                "day": "inputDay",
                "iVar2": "adjustedMonth",
                "bVar1": "isLeapYear",
                "iVar3": "adjustedYear",
                "day_local": "localDay",
                "month_local": "localMonth",
                "year_local": "localYear"
            },
            "calling": [
                "_parse_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000328c": {
            "entrypoint": "0x0000328c",
            "current_name": "parse_date_time_0000328c",
            "code": "\ntempValuent parseDateTime_0000328c(char **arguments,tm *parsedTime)\n\n{\n  long convertedValue;\n  tempValuent dayOfWeek;\n  tm *localTime;\n  char **localArguments;\n  char *endPtr;\n  short tempValue;\n  \n  convertedValue = strtol(*arguments,&endPtr,10);\n  tempValue = (short)convertedValue;\n  parsedTime->tm_year = tempValue + -0x76c;\n  convertedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)convertedValue;\n  parsedTime->tm_mon = tempValue + -1;\n  convertedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)convertedValue;\n  parsedTime->tm_mday = (tempValuent)tempValue;\n  convertedValue = strtol(arguments[1],&endPtr,10);\n  tempValue = (short)convertedValue;\n  parsedTime->tm_hour = (tempValuent)tempValue;\n  convertedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)convertedValue;\n  parsedTime->tm_mtempValuen = (tempValuent)tempValue;\n  convertedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)convertedValue;\n  parsedTime->tm_sec = (tempValuent)tempValue;\n  dayOfWeek = dow(parsedTime->tm_year + 0x76c,parsedTime->tm_mon + 1,parsedTime->tm_mday);\n  parsedTime->tm_wday = dayOfWeek;\n  parsedTime->tm_tempValuesdst = -1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000328c": "parse_date_time_0000328c",
                "argv": "arguments",
                "time": "parsedTime",
                "time_local": "localTime",
                "argv_local": "localArguments",
                "end": "endPtr",
                "i": "tempValue",
                "lVar1": "convertedValue",
                "iVar2": "dayOfWeek"
            },
            "calling": [
                "_rtc_settime",
                "_rtc_setalarm"
            ],
            "called": [
                "strtol",
                "dow"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003378": {
            "entrypoint": "0x00003378",
            "current_name": "print_formatted_date_time_00003378",
            "code": "\nint printFormattedDateTime_00003378(tm *dateTime)\n\n{\n  tm *localDateTime;\n  \n  iprintf(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",dateTime->tm_year + 0x76c,dateTime->tm_mon + 1,dateTime->tm_mday,\n          dateTime->tm_hour,dateTime->tm_min,dateTime->tm_sec);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00003378": "print_formatted_date_time_00003378",
                "time": "dateTime",
                "time_local": "localDateTime"
            },
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033c0": {
            "entrypoint": "0x000033c0",
            "current_name": "print_rtc_alarm_000033c0",
            "code": "\n/* WARNING: Unknown calling convenalarm_timeion */\n\ninalarm_time print_rtc_alarm_000033c0(void)\n\n{\n  inalarm_time result;\n  alarm_timem alarm_time;\n  \n  result = ralarm_timec_gealarm_time_alarm(&alarm_time);\n  if (result != 0) {\n    pualarm_times(\"ralarm_timec: error gealarm_timealarm_timeing alarm\");\n  }\n  else {\n    _prinalarm_time_alarm_timeime(&alarm_time);\n  }\n  realarm_timeurn (uinalarm_time)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_000033c0": "print_rtc_alarm_000033c0",
                "iVar1": "result",
                "t": "alarm_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033f4": {
            "entrypoint": "0x000033f4",
            "current_name": "set_alarm_000033f4",
            "code": "\nint set_alarm_000033f4(char **arguments)\n\n{\n  int status;\n  char **local_arguments;\n  tm current_time;\n  \n  status = _parse_time(arguments,&current_time);\n  if (status == 0) {\n    status = rtc_set_alarm_000033f4(&current_time,_alarm_handler + 1,(void *)0x0);\n    if (status == -1) {\n      puts(\"rtc: error setting alarm\");\n      status = 1;\n    }\n    else {\n      status = 0;\n    }\n  }\n  else {\n    status = 1;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_000033f4": "set_alarm_000033f4",
                "argv": "arguments",
                "iVar1": "status",
                "argv_local": "local_arguments",
                "now": "current_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "rtc_set_alarm",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003444": {
            "entrypoint": "0x00003444",
            "current_name": "get_and_print_rtc_time_00003444",
            "code": "\n/* WARNING: Unknown calling convencurrent_timeion */\n\nincurrent_time get_and_print_rtc_time_00003444(void)\n\n{\n  incurrent_time status;\n  current_timem current_time;\n  \n  status = rcurrent_timec_gecurrent_time_current_timeime(&current_time);\n  if (status != 0) {\n    pucurrent_times(\"rcurrent_timec: error gecurrent_timecurrent_timeing current_timeime\");\n  }\n  else {\n    _princurrent_time_current_timeime(&current_time);\n  }\n  recurrent_timeurn (uincurrent_time)(status != 0);\n}\n\n",
            "renaming": {
                "FUN_00003444": "get_and_print_rtc_time_00003444",
                "iVar1": "status",
                "t": "current_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003478": {
            "entrypoint": "0x00003478",
            "current_name": "set_system_time_00003478",
            "code": "\nint setSystemTime_00003478(char **commandLineArguments)\n\n{\n  int returnValue;\n  char **localArguments;\n  tm currentTime;\n  \n  returnValue = _parse_time(commandLineArguments,&currentTime);\n  if (returnValue == 0) {\n    returnValue = rtc_set_time(&currentTime);\n    if (returnValue == -1) {\n      puts(\"rtc: error setting time\");\n      returnValue = 1;\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00003478": "set_system_time_00003478",
                "argv": "commandLineArguments",
                "iVar1": "returnValue",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000034c0": {
            "entrypoint": "0x000034c0",
            "current_name": "print_usage_info_000034c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint printUsageInfo_000034c0(void)\n\n{\n  puts(\"usage: rtc <command> [arguments]\");\n  puts(\"commands:\");\n  puts(\"\\tpoweron\\t\\tpower the interface on\");\n  puts(\"\\tpoweroff\\tpower the interface off\");\n  puts(\"\\tclearalarm\\tdeactivate the current alarm\");\n  puts(\"\\tgetalarm\\tprint the currently alarm time\");\n  puts(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  puts(\"\\tgettime\\t\\tprint the current time\");\n  puts(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000034c0": "print_usage_info_000034c0"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003524": {
            "entrypoint": "0x00003524",
            "current_name": "handle_rtc_command_00003524",
            "code": "\nint handle_rtc_command_00003524(int num_args,char **args)\n\n{\n  int result;\n  char **local_args;\n  int local_num_args;\n  \n  if (num_args < 2) {\n    print_rtc_usage();\n    result = 1;\n  }\n  else {\n    result = compare_strings(args[1],\"poweron\",7);\n    if (result == 0) {\n      power_on_rtc();\n    }\n    else {\n      result = compare_strings(args[1],\"poweroff\",8);\n      if (result == 0) {\n        power_off_rtc();\n      }\n      else {\n        result = compare_strings(args[1],\"clearalarm\",8);\n        if (result == 0) {\n          clear_rtc_alarm();\n        }\n        else {\n          result = compare_strings(args[1],\"getalarm\",8);\n          if (result == 0) {\n            get_rtc_alarm();\n          }\n          else {\n            result = compare_strings(args[1],\"setalarm\",8);\n            if ((result == 0) && (num_args == 4)) {\n              set_rtc_alarm(args + 2);\n            }\n            else {\n              result = compare_strings(args[1],\"gettime\",7);\n              if (result == 0) {\n                get_rtc_time();\n              }\n              else {\n                result = compare_strings(args[1],\"settime\",7);\n                if ((result != 0) || (num_args != 4)) {\n                  print_message(\"unknown command or missing parameters: %s\\n\\n\",args[1]);\n                  print_rtc_usage();\n                  return 1;\n                }\n                set_rtc_time(args + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003524": "handle_rtc_command_00003524",
                "argc": "num_args",
                "argv": "args",
                "argv_local": "local_args",
                "argc_local": "local_num_args",
                "_rtc_usage": "print_rtc_usage",
                "iVar1": "result",
                "strncmp": "compare_strings",
                "rtc_poweron": "power_on_rtc",
                "rtc_poweroff": "power_off_rtc",
                "rtc_clear_alarm": "clear_rtc_alarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "_rtc_gettime": "get_rtc_time",
                "_rtc_settime": "set_rtc_time",
                "iprintf": "print_message"
            },
            "calling": [],
            "called": [
                "_rtc_getalarm",
                "rtc_poweron",
                "_rtc_settime",
                "_rtc_usage",
                "_rtc_gettime",
                "rtc_clear_alarm",
                "rtc_poweroff",
                "_rtc_setalarm",
                "iprintf",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003658": {
            "entrypoint": "0x00003658",
            "current_name": "infinite_loop_00003658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00003658(void)\n\n{\n  syncBarrier(0xf);\n  syncBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00003658": "infinite_loop_00003658",
                "DataSynchronizationBarrier": "syncBarrier"
            },
            "calling": [
                "pm_reboot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003688": {
            "entrypoint": "0x00003688",
            "current_name": "reset_system_00003688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetSystem_00003688(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "calling": [
                "_reboot_handler"
            ],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003694": {
            "entrypoint": "0x00003694",
            "current_name": "display_data_00003694",
            "code": "\nvoindexd displayData_00003694(phydat_t *dataObject,uindexnt8_t dimension)\n\n{\n  sindexze_t stringLength;\n  char *stringPointer;\n  char charVar;\n  uindexnt uintVar;\n  bool boolVar;\n  uindexnt8_t localDimension;\n  phydat_t *localDataObject;\n  char numberString [8];\n  sindexze_t length;\n  char prefix;\n  uindexnt8_t index;\n  \n  indexf ((dataObject == (phydat_t *)0x0) || (3 < dimension)) {\n    puts(\"Unable to dindexsplay dataObject object\");\n  }\n  else {\n    indexprindexntf(\"Data:\");\n    for (index = '\\0'; index < dimension; index = index + '\\x01') {\n      indexf (dataObject->unindext < 0x14) {\n        uintVar = 1 << (uindexnt)dataObject->unindext & 0x8018f;\n        boolVar = uintVar != 0;\n        indexf (boolVar) {\n          uintVar = 1;\n        }\n        charVar = (char)uintVar;\n        indexf (!boolVar) {\n          charVar = '\\0';\n        }\n        indexf (charVar == '\\0') goto LAB_000036ee;\n        prefix = '\\0';\n      }\n      else {\nLAB_000036ee:\n        prefix = phydat_prefindexx_from_scale(dataObject->scale);\n      }\n      indexprindexntf(\"\\t\");\n      indexf (dimension < 2) {\n        indexprindexntf(\"     \");\n      }\n      else {\n        indexprindexntf(\"[%u] \",(uindexnt)index);\n      }\n      indexf (prefix == '\\0') {\n        indexf (dataObject->scale == '\\0') {\n          indexprindexntf(\"%6d\",(indexnt)dataObject->val[index]);\n        }\n        else indexf ((dataObject->scale + 4 < 0 == SCARRY4((indexnt)dataObject->scale,4)) && (dataObject->scale < '\\0')) {\n          stringLength = fmt_s16_dfp(numberString,dataObject->val[index],(indexnt)dataObject->scale);\n          numberString[stringLength] = '\\0';\n          indexprindexntf(\"%s\",numberString);\n        }\n        else {\n          indexprindexntf(\"%indexE%index\",(indexnt)dataObject->val[index],(indexnt)dataObject->scale);\n        }\n      }\n      else {\n        indexprindexntf(\"%6d %c\",(indexnt)dataObject->val[index],(uindexnt)(byte)prefix);\n      }\n      stringPointer = phydat_unindext_to_str(dataObject->unindext);\n      indexprindexntf(\"%s\\n\",stringPointer);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003694": "display_data_00003694",
                "data": "dataObject",
                "dim": "dimension",
                "sVar1": "stringLength",
                "pcVar2": "stringPointer",
                "cVar3": "charVar",
                "uVar4": "uintVar",
                "bVar5": "boolVar",
                "dim_local": "localDimension",
                "data_local": "localDataObject",
                "num": "numberString",
                "len": "length",
                "scale_prefix": "prefix",
                "i": "index"
            },
            "calling": [
                "write",
                "probe"
            ],
            "called": [
                "phydat_unit_to_str",
                "iprintf",
                "puts",
                "fmt_s16_dfp",
                "phydat_prefix_from_scale"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003810": {
            "entrypoint": "0x00003810",
            "current_name": "get_unit_string_00003810",
            "code": "\nchar * getUnitString_00003810(uint8_t unitCode)\n\n{\n  char *unitString;\n  uint8_t localUnitCode;\n  \n  switch(unitCode) {\n  case '\\x02':\n    unitString = &DAT_000077ec;\n    break;\n  case '\\x03':\n    unitString = &DAT_000077f0;\n    break;\n  case '\\x04':\n    unitString = \"K\";\n    break;\n  case '\\x05':\n    unitString = \"lx\";\n    break;\n  case '\\x06':\n    unitString = \"m\";\n    break;\n  case '\\a':\n    unitString = \"m^2\";\n    break;\n  case '\\b':\n    unitString = \"m^3\";\n    break;\n  case '\\t':\n    unitString = \"g\";\n    break;\n  case '\\n':\n    unitString = \"dps\";\n    break;\n  case '\\v':\n    unitString = \"G\";\n    break;\n  case '\\f':\n    unitString = \"A\";\n    break;\n  case '\\r':\n    unitString = \"V\";\n    break;\n  case '\\x0e':\n    unitString = \"Gs\";\n    break;\n  case '\\x0f':\n    unitString = \"Bar\";\n    break;\n  case '\\x10':\n    unitString = \"Pa\";\n    break;\n  case '\\x11':\n    unitString = \"cd\";\n    break;\n  default:\n    unitString = \"\";\n    break;\n  case '\\x13':\n    unitString = \"%\";\n    break;\n  case '\\x15':\n    unitString = \"ppm\";\n  }\n  return unitString;\n}\n\n",
            "renaming": {
                "FUN_00003810": "get_unit_string_00003810",
                "unit": "unitCode",
                "unit_local": "localUnitCode",
                "pcVar1": "unitString"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003918": {
            "entrypoint": "0x00003918",
            "current_name": "get_scale_character_00003918",
            "code": "\nchar getScaleCharacter_00003918(int8_t scale)\n\n{\n  char character;\n  int8_t localScale;\n  \n  switch(scale) {\n  case '\\x02':\n    character = 'h';\n    break;\n  case '\\x03':\n    character = 'k';\n    break;\n  case '\\x06':\n    character = 'M';\n    break;\n  case '\\t':\n    character = 'G';\n    break;\n  case '\\f':\n    character = 'T';\n    break;\n  case '\\x0f':\n    character = 'P';\n    break;\n  case -0xf:\n    character = 'f';\n    break;\n  default:\n    character = '\\0';\n    break;\n  case -0xc:\n    character = 'p';\n    break;\n  case -9:\n    character = 'n';\n    break;\n  case -6:\n    character = 'u';\n    break;\n  case -3:\n    character = 'm';\n  }\n  return character;\n}\n\n",
            "renaming": {
                "FUN_00003918": "get_scale_character_00003918",
                "cVar1": "character",
                "scale_local": "localScale"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000039e8": {
            "entrypoint": "0x000039e8",
            "current_name": "get_class_string_000039e8",
            "code": "\nchar * getClassString_000039e8(uint8_t classId)\n\n{\n  char *className;\n  uint8_t localClassId;\n  \n  switch(classId) {\n  case '\\0':\n    className = \"CLASS_UNDEF\";\n    break;\n  case '@':\n    className = \"ACT_ANY\";\n    break;\n  case 'B':\n    className = \"ACT_LED_RGB\";\n    break;\n  case 'C':\n    className = \"ACT_SERVO\";\n    break;\n  case 'D':\n    className = \"ACT_MOTOR\";\n    break;\n  case 'E':\n    className = \"ACT_SWITCH\";\n    break;\n  case 'F':\n    className = \"ACT_DIMMER\";\n    break;\n  case 0x80:\n    className = \"SENSE_ANY\";\n    break;\n  case 0x81:\n    className = \"SENSE_BTN\";\n    break;\n  case 0x82:\n    className = \"SENSE_TEMP\";\n    break;\n  case 0x83:\n    className = \"SENSE_HUM\";\n    break;\n  case 0x84:\n    className = \"SENSE_LIGHT\";\n    break;\n  case 0x85:\n    className = \"SENSE_ACCEL\";\n    break;\n  case 0x86:\n    className = \"SENSE_MAG\";\n    break;\n  case 0x87:\n    className = \"SENSE_GYRO\";\n    break;\n  case 0x88:\n    className = \"SENSE_COLOR\";\n    break;\n  case 0x89:\n    className = \"SENSE_PRESS\";\n    break;\n  case 0x8a:\n    className = \"SENSE_ANALOG\";\n    break;\n  case 0x8b:\n    className = \"SENSE_UV\";\n    break;\n  case 0x8c:\n    className = \"SENSE_OBJTEMP\";\n    break;\n  case 0x8d:\n    className = \"SENSE_PULSE_COUNT\";\n    break;\n  case 0x8e:\n    className = \"SENSE_DISTANCE\";\n    break;\n  case 0x8f:\n    className = \"SENSE_CO2\";\n    break;\n  default:\n    if (classId == 0xff) {\n      return \"CLASS_ANY\";\n    }\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    className = \"CLASS_UNKNOWN\";\n  }\n  return className;\n}\n\n",
            "renaming": {
                "FUN_000039e8": "get_class_string_000039e8",
                "class_id": "classId",
                "pcVar1": "className",
                "class_id_local": "localClassId"
            },
            "calling": [
                "probe",
                "list"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d24": {
            "entrypoint": "0x00003d24",
            "current_name": "get_saul_registry_by_position_00003d24",
            "code": "\nsaulRegistry_t * getSaulRegistryByPosition_00003d24(counternt position)\n\n{\n  counternt localPosition;\n  counternt counter;\n  saulRegistry_t *currentRegistry;\n  \n  counter = 0;\n  for (currentRegistry = saulRegistry; (counter < position && (currentRegistry != (saulRegistry_t *)0x0)); currentRegistry = currentRegistry->next) {\n    counter = counter + 1;\n  }\n  return currentRegistry;\n}\n\n",
            "renaming": {
                "FUN_00003d24": "get_saul_registry_by_position_00003d24",
                "pos": "position",
                "pos_local": "localPosition",
                "i": "counter",
                "tmp": "currentRegistry",
                "saul_reg": "saulRegistry"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d64": {
            "entrypoint": "0x00003d64",
            "current_name": "read_sensor_data_00003d64",
            "code": "\nint read_sensor_data_00003d64(saul_reg_t *sensor,phydat_t *sensor_data)\n\n{\n  int result;\n  phydat_t *local_sensor_data;\n  saul_reg_t *local_sensor;\n  \n  if (sensor == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->sensor,sensor_data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "sensor_data",
                "iVar1": "result",
                "res_local": "local_sensor_data",
                "dev_local": "local_sensor"
            },
            "calling": [
                "probe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d94": {
            "entrypoint": "0x00003d94",
            "current_name": "write_phydat_to_device_00003d94",
            "code": "\nint write_phydat_to_device_00003d94(saul_reg_t *device,phydat_t *input_data)\n\n{\n  int result;\n  phydat_t *local_data;\n  saul_reg_t *local_device;\n  \n  if (device == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*device->driver->write)(device->device,input_data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d94": "write_phydat_to_device_00003d94",
                "dev": "device",
                "data": "input_data",
                "iVar1": "result",
                "data_local": "local_data",
                "dev_local": "local_device"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003dc4": {
            "entrypoint": "0x00003dc4",
            "current_name": "count_digits_00003dc4",
            "code": "\nsize_t countDigits_00003dc4(char *outputString,uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  char *localString;\n  char *pointer;\n  uint32_t temporary;\n  size_t length;\n  \n  length = 1;\n  if (inputValue < 1000000000) {\n    for (temporary = 10; temporary <= inputValue; temporary = temporary * 10) {\n      length = length + 1;\n    }\n  }\n  else {\n    length = 10;\n  }\n  if (outputString != (char *)0x0) {\n    pointer = outputString + length;\n    localValue = inputValue;\n    do {\n      pointer = pointer + -1;\n      *pointer = (char)(localValue % 10) + '0';\n      localValue = localValue / 10;\n    } while (localValue != 0);\n  }\n  return length;\n}\n\n",
            "renaming": {
                "FUN_00003dc4": "count_digits_00003dc4",
                "out": "outputString",
                "val": "inputValue",
                "val_local": "localValue",
                "out_local": "localString",
                "ptr": "pointer",
                "tmp": "temporary",
                "len": "length"
            },
            "calling": [
                "fmt_s32_dec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e58": {
            "entrypoint": "0x00003e58",
            "current_name": "convert_int_to_string_00003e58",
            "code": "\nsize_t convertIntToString_00003e58(char *outputString,int32_t inputValue)\n\n{\n  size_t stringLength;\n  int32_t localValue;\n  char *localOutputString;\n  uint isNegative;\n  \n  localValue = inputValue;\n  localOutputString = outputString;\n  if (-(inputValue >> 0x1f) != 0) {\n    if (outputString != (char *)0x0) {\n      localOutputString = outputString + 1;\n      *outputString = '-';\n    }\n    localValue = -inputValue;\n  }\n  stringLength = fmt_u32_dec(localOutputString,localValue);\n  return -(inputValue >> 0x1f) + stringLength;\n}\n\n",
            "renaming": {
                "FUN_00003e58": "convert_int_to_string_00003e58",
                "out": "outputString",
                "val": "inputValue",
                "sVar1": "stringLength",
                "val_local": "localValue",
                "out_local": "localOutputString",
                "negative": "isNegative"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "fmt_u32_dec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e9e": {
            "entrypoint": "0x00003e9e",
            "current_name": "format_integer_with_decimal_00003e9e",
            "code": "\nsize_t formatIntegerWithDecimal_00003e9e(char *outputBuffer,int16_t inputValue,int decimalPlaces)\n\n{\n  size_t formattedSize;\n  int decimalPlaces;\n  int16_t inputValue;\n  char *outputBuffer;\n  \n  formattedSize = fmt_s32_dfp(outputBuffer,(int)inputValue,decimalPlaces);\n  return formattedSize;\n}\n\n",
            "renaming": {
                "FUN_00003e9e": "format_integer_with_decimal_00003e9e",
                "out": "outputBuffer",
                "val": "inputValue",
                "fp_digits": "decimalPlaces",
                "fp_digits_local": "decimalPlaces",
                "val_local": "inputValue",
                "out_local": "outputBuffer",
                "sVar1": "formattedSize"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [
                "fmt_s32_dfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ec4": {
            "entrypoint": "0x00003ec4",
            "current_name": "format_float_00003ec4",
            "code": "\nsize_t formatFloat_00003ec4(char *outputString,int32_t value,int fractionalDigits)\n\n{\n  size_t formattedStringSize;\n  uint divResult;\n  int currentPosition;\n  int fractionalDigits_local;\n  int32_t value_local;\n  char *outputString_local;\n  uint divisionLength;\n  int32_t absolute;\n  uint32_t e;\n  int32_t remainder;\n  uint position;\n  \n  if (fractionalDigits + 7 < 0 != SCARRY4(fractionalDigits,7)) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  position = 0;\n  if (fractionalDigits == 0) {\n    position = fmt_s32_dec(outputString,value);\n  }\n  else if (fractionalDigits < 1) {\n    divResult = (uint)value / _tenmap[-fractionalDigits];\n    remainder = value - _tenmap[-fractionalDigits] * divResult;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((divResult == 0) && (value < 0)) {\n      if (outputString != (char *)0x0) {\n        *outputString = '-';\n      }\n      position = 1;\n    }\n    if (outputString == (char *)0x0) {\n      formattedStringSize = fmt_s32_dec((char *)0x0,divResult);\n      position = formattedStringSize + 1 + position;\n    }\n    else {\n      formattedStringSize = fmt_s32_dec(outputString + position,divResult);\n      currentPosition = position + formattedStringSize;\n      position = currentPosition + 1;\n      outputString[currentPosition] = '.';\n      formattedStringSize = fmt_s32_dec(outputString + position,remainder);\n      fmt_lpad(outputString + position,formattedStringSize,-fractionalDigits,'0');\n    }\n    position = -fractionalDigits + position;\n  }\n  else {\n    formattedStringSize = fmt_s32_dec(outputString,value);\n    if (outputString != (char *)0x0) {\n      memset(outputString + formattedStringSize,0x30,fractionalDigits);\n    }\n    position = fractionalDigits + formattedStringSize;\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00003ec4": "format_float_00003ec4",
                "out": "outputString",
                "val": "value",
                "fp_digits": "fractionalDigits",
                "sVar1": "formattedStringSize",
                "val_00": "divResult",
                "iVar2": "currentPosition",
                "fp_digits_local": "fractionalDigits_local",
                "val_local": "value_local",
                "out_local": "outputString_local",
                "div_len": "divisionLength",
                "abs": "absolute",
                "div": "remainder",
                "pos": "position"
            },
            "calling": [
                "fmt_s16_dfp"
            ],
            "called": [
                "core_panic",
                "fmt_s32_dec",
                "fmt_lpad",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ff4": {
            "entrypoint": "0x00003ff4",
            "current_name": "pad_string_00003ff4",
            "code": "\nsize_t padString_00003ff4(char *output,size_t input_length,size_t padding_length,char padding_character)\n\n{\n  size_t sVar1;\n  char local_padding_character;\n  size_t local_padding_length;\n  size_t local_input_length;\n  char *local_output;\n  size_t counter;\n  \n  sVar1 = input_length;\n  if ((input_length < padding_length) && (sVar1 = padding_length, output != (char *)0x0)) {\n    memmove(output + (padding_length - input_length),output,input_length);\n    memset(output,(uicountert)(byte)padding_character,padding_length - input_length);\n  }\n  returcounter sVar1;\n}\n\n",
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padding_length",
                "pad_char": "padding_character",
                "pad_char_local": "local_padding_character",
                "pad_len_local": "local_padding_length",
                "in_len_local": "local_input_length",
                "out_local": "local_output",
                "n": "counter"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "memmove",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004042": {
            "entrypoint": "0x00004042",
            "current_name": "convert_string_to_long_00004042",
            "code": "\nint convertStringToLong_00004042(char *inputString)\n\n{\n  long convertedValue;\n  \n  convertedValue = strtol(inputString,(char **)0x0,10);\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "inputString",
                "lVar1": "convertedValue"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000404c": {
            "entrypoint": "0x0000404c",
            "current_name": "reverse_and_improve_0000404c",
            "code": "\nundefined4 reverse_and_improve_0000404c(uint *input_array,int *output_array)\n\n{\n  int offset;\n  int *temp_ptr;\n  uint temp_var;\n  ushort flags;\n  int increment;\n  code *callback_func;\n  int count;\n  uint temp_var2;\n  bool is_zero;\n  \n  flags = *(ushort *)(output_array + 3);\n  temp_var = (uint)flags;\n  if ((int)(temp_var << 0x1c) < 0) {\n    offset = output_array[4];\n    if (offset != 0) {\n      increment = temp_var << 0x1e;\n      is_zero = increment == 0;\n      count = *output_array;\n      if (is_zero) {\n        increment = output_array[5];\n      }\n      *output_array = offset;\n      if (!is_zero) {\n        increment = 0;\n      }\n      output_array[2] = increment;\n      for (count = count - offset; 0 < count; count = count - increment) {\n        increment = (*(code *)output_array[10])(input_array,output_array[8],offset,count);\n        if (increment < 1) {\n          *(ushort *)(output_array + 3) = *(ushort *)(output_array + 3) | 0x40;\n          return 0xffffffff;\n        }\n        offset = offset + increment;\n      }\n    }\n  }\n  else {\n    if ((output_array[1] < 1) && (output_array[0x10] < 1)) {\n      return 0;\n    }\n    callback_func = (code *)output_array[0xb];\n    if (callback_func == (code *)0x0) {\n      return 0;\n    }\n    temp_var2 = *input_array;\n    *input_array = 0;\n    if ((flags & 0x1000) == 0) {\n      offset = (*callback_func)(input_array,output_array[8],temp_var & 0x1000,1);\n      if ((offset == -1) && (temp_var = *input_array, temp_var != 0)) {\n        if ((temp_var == 0x1d) || (temp_var == 0x16)) {\n          *input_array = temp_var2;\n          return 0;\n        }\n        flags = *(ushort *)(output_array + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      offset = output_array[0x15];\n    }\n    if (((int)((uint)*(ushort *)(output_array + 3) << 0x1d) < 0) &&\n       (offset = offset - output_array[1], output_array[0xd] != 0)) {\n      offset = offset - output_array[0x10];\n    }\n    offset = (*(code *)output_array[0xb])(input_array,output_array[8],offset,0);\n    flags = *(ushort *)(output_array + 3);\n    if ((offset == -1) &&\n       ((0x1d < *input_array || (-1 < (int)((0x20400001U >> (*input_array & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(output_array + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    output_array[1] = 0;\n    *output_array = output_array[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((offset != -1 || (*input_array == 0)))) {\n      output_array[0x15] = offset;\n    }\n    temp_ptr = (int *)output_array[0xd];\n    *input_array = temp_var2;\n    if (temp_ptr != (int *)0x0) {\n      if (temp_ptr != output_array + 0x11) {\n        _free_r(input_array);\n      }\n      output_array[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000404c": "reverse_and_improve_0000404c",
                "param_1": "input_array",
                "param_2": "output_array",
                "iVar1": "offset",
                "piVar2": "temp_ptr",
                "uVar3": "temp_var",
                "uVar4": "flags",
                "iVar5": "increment",
                "pcVar6": "callback_func",
                "iVar7": "count",
                "uVar8": "temp_var2",
                "bVar9": "is_zero"
            },
            "calling": [
                "_fflush_r",
                "__srefill_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004158": {
            "entrypoint": "0x00004158",
            "current_name": "flush_stream_00004158",
            "code": "\nundefined4 flushStream_00004158(int streamPtr,undefined4 *filePtr)\n\n{\n  undefined4 result;\n  \n  if (filePtr[4] != 0) {\n    if ((streamPtr != 0) && (*(int *)(streamPtr + 0x18) == 0)) {\n      initializeStream();\n    }\n    if (filePtr == &fakeStdinPtr) {\n      filePtr = *(undefined4 **)(streamPtr + 4);\n    }\n    else if (filePtr == (undefined4 *)&fakeStdoutPtr) {\n      filePtr = *(undefined4 **)(streamPtr + 8);\n    }\n    else if (filePtr == (undefined4 *)&fakeStderrPtr) {\n      filePtr = *(undefined4 **)(streamPtr + 0xc);\n    }\n    if (*(short *)(filePtr + 3) != 0) {\n      if ((-1 < (int)(filePtr[0x19] << 0x1f)) && (-1 < (int)*(short *)(filePtr + 3) << 0x16)) {\n        acquireRecursiveLock(filePtr[0x16]);\n      }\n      result = flushStream_00004158R(streamPtr,filePtr);\n      if ((int)(filePtr[0x19] << 0x1f) < 0) {\n        return result;\n      }\n      if ((int)((uint)*(ushort *)(filePtr + 3) << 0x16) < 0) {\n        return result;\n      }\n      releaseRecursiveLock(filePtr[0x16]);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004158": "flush_stream_00004158",
                "param_1": "streamPtr",
                "param_2": "filePtr",
                "uVar1": "result",
                "__sf_fake_stdin": "fakeStdinPtr",
                "__sf_fake_stdout": "fakeStdoutPtr",
                "__sf_fake_stderr": "fakeStderrPtr",
                "__sinit": "initializeStream",
                "__retarget_lock_acquire_recursive": "acquireRecursiveLock",
                "__sflush_r": "flushStreamR",
                "__retarget_lock_release_recursive": "releaseRecursiveLock"
            },
            "calling": [
                "__swbuf_r",
                "fflush",
                "__srefill_r"
            ],
            "called": [
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041d0": {
            "entrypoint": "0x000041d0",
            "current_name": "flush_file_000041d0",
            "code": "\nint flushFile_000041d0(FILE *file)\n\n{\n  int result;\n  \n  if (file == (FILE *)0x0) {\n    result = _fwalk_reent(&impure_data,0x4159);\n    return result;\n  }\n  result = _fflush_r(_impure_ptr,file);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000041d0": "flush_file_000041d0",
                "__stream": "file",
                "iVar1": "result"
            },
            "calling": [
                "lflush",
                "print_prompt"
            ],
            "called": [
                "_fwalk_reent",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041f4": {
            "entrypoint": "0x000041f4",
            "current_name": "initialize_data_struct_000041f4",
            "code": "\nvoid initializeDataStruct_000041f4(undefined4 *dataStructPtr,undefined2 value1,undefined2 value2)\n\n{\n  *dataStructPtr = 0;\n  dataStructPtr[1] = 0;\n  dataStructPtr[4] = 0;\n  dataStructPtr[5] = 0;\n  dataStructPtr[2] = 0;\n  *(undefined2 *)(dataStructPtr + 3) = value1;\n  dataStructPtr[25] = 0;\n  *(undefined2 *)((int)dataStructPtr + 0xe) = value2;\n  dataStructPtr[6] = 0;\n  memset(dataStructPtr + 0x17,0,8);\n  dataStructPtr[9] = 0x4dc9;\n  dataStructPtr[10] = 0x4def;\n  dataStructPtr[11] = 0x4e27;\n  dataStructPtr[8] = dataStructPtr;\n  dataStructPtr[12] = 0x4e4b;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000041f4": "initialize_data_struct_000041f4",
                "param_1": "dataStructPtr",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "dataStructPtr[1]",
                "param_1[4]": "dataStructPtr[4]",
                "param_1[5]": "dataStructPtr[5]",
                "param_1[2]": "dataStructPtr[2]",
                "param_1[0x19]": "dataStructPtr[25]",
                "param_1[6]": "dataStructPtr[6]",
                "param_1[9]": "dataStructPtr[9]",
                "param_1[10]": "dataStructPtr[10]",
                "param_1[0xb]": "dataStructPtr[11]",
                "param_1[8]": "dataStructPtr[8]",
                "param_1[0xc]": "dataStructPtr[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000423c": {
            "entrypoint": "0x0000423c",
            "current_name": "initialize_file_walk_0000423c",
            "code": "\nvoid initializeFileWalk_0000423c(undefined4 reent)\n\n{\n  fileWalkReent(reent,0x4159);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000423c": "initialize_file_walk_0000423c",
                "param_1": "reent",
                "_fwalk_reent": "fileWalkReent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004248": {
            "entrypoint": "0x00004248",
            "current_name": "create_dynamic_array_00004248",
            "code": "\nundefined4 * createDynamicArray_00004248(undefined4 elementSize,int numElements)\n\n{\n  undefined4 *arrayPtr;\n  int totalSize;\n  \n  totalSize = (numElements + -1) * 0x68;\n  arrayPtr = (undefined4 *)_malloc_r(elementSize,totalSize + 0x74);\n  if (arrayPtr != (undefined4 *)0x0) {\n    *arrayPtr = 0;\n    arrayPtr[1] = numElements;\n    arrayPtr[2] = arrayPtr + 3;\n    memset(arrayPtr + 3,0,totalSize + 0x68);\n  }\n  return arrayPtr;\n}\n\n",
            "renaming": {
                "FUN_00004248": "create_dynamic_array_00004248",
                "param_1": "elementSize",
                "param_2": "numElements",
                "puVar1": "arrayPtr",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004274": {
            "entrypoint": "0x00004274",
            "current_name": "acquire_lock_00004274",
            "code": "\nvoid acquireLock_00004274(void)\n\n{\n  __retarget_lock_acquire_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004274": "acquire_lock_00004274",
                "__lock___sfp_recursive_mutex": "lock"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004280": {
            "entrypoint": "0x00004280",
            "current_name": "release_sfp_recursive_mutex_00004280",
            "code": "\nvoid release_sfp_recursive_mutex_00004280(void)\n\n{\n  release_recursive_lock(&sfp_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004280": "release_sfp_recursive_mutex_00004280",
                "__retarget_lock_release_recursive": "release_recursive_lock",
                "&__lock___sfp_recursive_mutex": "&sfp_recursive_mutex"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000428c": {
            "entrypoint": "0x0000428c",
            "current_name": "acquire_recursive_lock_0000428c",
            "code": "\nvoid acquire_recursive_lock_0000428c(void)\n\n{\n  acquire_recursive_lock_0000428c(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "__lock___sinit_recursive_mutex": "lock",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004298": {
            "entrypoint": "0x00004298",
            "current_name": "release_recursive_lock_00004298",
            "code": "\nvoid releaseRecursiveLock_00004298(void)\n\n{\n  __retarget_lock_release_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004298": "release_recursive_lock_00004298",
                "__lock___sinit_recursive_mutex": "lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000042a4": {
            "entrypoint": "0x000042a4",
            "current_name": "initialize_data_structures_000042a4",
            "code": "\nvoid initializeDataStructures_000042a4(undefined1 *dataStruct)\n\n{\n  undefined4 returnValue;\n  undefined1 *impureData;\n  \n  acquireLock();\n  if (*(int *)(dataStruct + 0x18) == 0) {\n    *(undefined4 *)(dataStruct + 0x48) = 0;\n    *(undefined4 *)(dataStruct + 0x4c) = 0;\n    *(undefined4 *)(dataStruct + 0x50) = 0;\n    impureData = &impureData;\n    *(undefined4 *)(dataStruct + 0x28) = 0x423d;\n    if (dataStruct == &impureData) {\n      impureData = (undefined1 *)0x1;\n    }\n    if (dataStruct == &impureData) {\n      *(undefined1 **)(dataStruct + 0x18) = impureData;\n    }\n    returnValue = getFloatFromParam(dataStruct);\n    *(undefined4 *)(dataStruct + 4) = returnValue;\n    returnValue = getFloatFromParam(dataStruct);\n    *(undefined4 *)(dataStruct + 8) = returnValue;\n    returnValue = getFloatFromParam(dataStruct);\n    *(undefined4 *)(dataStruct + 0xc) = returnValue;\n    storeData(*(undefined4 *)(dataStruct + 4),4,0);\n    storeData(*(undefined4 *)(dataStruct + 8),9,1);\n    storeData(*(undefined4 *)(dataStruct + 0xc),0x12,2);\n    *(undefined4 *)(dataStruct + 0x18) = 1;\n  }\n  releaseLock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000042a4": "initialize_data_structures_000042a4",
                "param_1": "dataStruct",
                "uVar1": "returnValue",
                "puVar2": "impureData",
                "__sinit_lock_acquire": "acquireLock",
                "__sinit_lock_release": "releaseLock",
                "impure_data": "impureData",
                "__sfp": "getFloatFromParam",
                "std": "storeData"
            },
            "calling": [
                "__sfp",
                "_fflush_r",
                "_puts_r",
                "iprintf",
                "_putc_r",
                "_getc_r",
                "__srefill_r",
                "putchar",
                "__swbuf_r",
                "getchar",
                "__srget_r",
                "_vfprintf_r",
                "__swsetup_r"
            ],
            "called": [
                "__sfp",
                "std",
                "__sinit_lock_acquire",
                "__sinit_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004314": {
            "entrypoint": "0x00004314",
            "current_name": "initialize_and_acquire_lock_00004314",
            "code": "\nint * initializeAndAcquireLock_00004314(undefined4 *lockPointer)\n\n{\n  int *currentPointer;\n  int *nextPointer;\n  int **pointerArray;\n  \n  acquireLock();\n  if (DAT_1fff029c == 0) {\n    initialize(&data);\n  }\n  pointerArray = (int **)&DAT_1fff02cc;\n  do {\n    currentPointer = pointerArray[1];\n    nextPointer = pointerArray[2];\n    while (currentPointer = (int *)((int)currentPointer + -1), -1 < (int)currentPointer) {\n      if (*(shortInt *)(nextPointer + 3) == 0) {\n        nextPointer[3] = -0xffff;\n        nextPointer[0x19] = 0;\n        initializeRecursiveLock(nextPointer + 0x16);\n        releaseLock();\n        nextPointer[1] = 0;\n        nextPointer[2] = 0;\n        nextPointer[4] = 0;\n        nextPointer[5] = 0;\n        *nextPointer = 0;\n        nextPointer[6] = 0;\n        clearMemory(nextPointer + 0x17,0,8);\n        nextPointer[0xd] = 0;\n        nextPointer[0xe] = 0;\n        nextPointer[0x12] = 0;\n        nextPointer[0x13] = 0;\n        return nextPointer;\n      }\n      nextPointer = nextPointer + 0x1a;\n    }\n    if (*pointerArray == (int *)0x0) {\n      currentPointer = (int *)allocateMemory(lockPointer,4);\n      *pointerArray = currentPointer;\n      if (currentPointer == (int *)0x0) {\n        releaseLock();\n        *lockPointer = 0xc;\n        return (int *)0x0;\n      }\n    }\n    pointerArray = (int **)*pointerArray;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00004314": "initialize_and_acquire_lock_00004314",
                "param_1": "lockPointer",
                "piVar1": "currentPointer",
                "piVar2": "nextPointer",
                "ppiVar3": "pointerArray",
                "__sfp_lock_acquire": "acquireLock",
                "__sinit": "initialize",
                "impure_data": "data",
                "memset": "clearMemory",
                "__retarget_lock_init_recursive": "initializeRecursiveLock",
                "__sfp_lock_release": "releaseLock",
                "short": "shortInt",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043a0": {
            "entrypoint": "0x000043a0",
            "current_name": "process_data_000043a0",
            "code": "\nuint processData_000043a0(int offset,code *callback)\n\n{\n  uint result;\n  int *dataPointer;\n  int currentOffset;\n  uint finalResult;\n  int iterations;\n  \n  dataPointer = (int *)(offset + 0x48);\n  finalResult = 0;\n  do {\n    iterations = dataPointer[1];\n    currentOffset = dataPointer[2];\n    while (iterations = iterations + -1, -1 < iterations) {\n      if ((1 < *(ushort *)(currentOffset + 0xc)) && (*(short *)(currentOffset + 0xe) != -1)) {\n        result = (*callback)(currentOffset);\n        finalResult = finalResult | result;\n      }\n      currentOffset = currentOffset + 0x68;\n    }\n    dataPointer = (int *)*dataPointer;\n  } while (dataPointer != (int *)0x0);\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_000043a0": "process_data_000043a0",
                "param_1": "offset",
                "param_2": "callback",
                "piVar2": "dataPointer",
                "iVar3": "currentOffset",
                "uVar1": "result",
                "uVar4": "finalResult",
                "iVar5": "iterations"
            },
            "calling": [
                "__srefill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043da": {
            "entrypoint": "0x000043da",
            "current_name": "process_data_000043da",
            "code": "\nuint processData_000043da(int input,code *callback,undefined4 param1,undefined4 param2)\n\n{\n  uint result;\n  int count;\n  int *ptr;\n  int dataPtr;\n  uint resultFlags;\n  int loopCount;\n  \n  ptr = (int *)(input + 0x48);\n  resultFlags = 0;\n  do {\n    loopCount = ptr[1];\n    dataPtr = ptr[2];\n    while (loopCount = loopCount + -1, -1 < loopCount) {\n      if ((1 < *(ushort *)(dataPtr + 0xc)) && (count = *(short *)(dataPtr + 0xe) + 1, count != 0)) {\n        result = (*callback)(input,dataPtr,param1,count,param2);\n        resultFlags = resultFlags | result;\n      }\n      dataPtr = dataPtr + 0x68;\n    }\n    ptr = (int *)*ptr;\n  } while (ptr != (int *)0x0);\n  return resultFlags;\n}\n\n",
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "input",
                "param_2": "callback",
                "param_3": "param1",
                "param_4": "param2",
                "uVar1": "result",
                "iVar2": "count",
                "piVar3": "ptr",
                "iVar4": "dataPtr",
                "uVar5": "resultFlags",
                "iVar6": "loopCount"
            },
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004418": {
            "entrypoint": "0x00004418",
            "current_name": "read_character_00004418",
            "code": "\n\n\nint readCharacter_00004418(void)\n\n{\n  int tempVar;\n  \n  tempVar = file_pointer;\n  if ((file_pointer != 0) && (*(int *)(file_pointer + 0x18) == 0)) {\n    initializeFileStream(file_pointer);\n  }\n  tempVar = getCharacterFromStream(tempVar,*(undefined4 *)(tempVar + 4));\n  return tempVar;\n}\n\n",
            "renaming": {
                "FUN_00004418": "read_character_00004418",
                "_impure_ptr": "file_pointer",
                "iVar1": "tempVar",
                "__sinit": "initializeFileStream",
                "_getc_r": "getCharacterFromStream"
            },
            "calling": [
                "readline"
            ],
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000443c": {
            "entrypoint": "0x0000443c",
            "current_name": "calculate_date_time_from_seconds_0000443c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * calculateDateTimeFromSeconds_0000443c(time_t *inputTime,tm *outputDateTime)\n\n{\n  int quotient;\n  uint daysElapsed;\n  uint remainingSeconds;\n  uint totalDays;\n  int currentDayOfYear;\n  uint leapYearCount;\n  time_t inputTimeSeconds;\n  time_t inputTimeSecondsCopy;\n  uint year;\n  bool isNegative;\n  \n  inputTimeSeconds = *inputTime;\n  inputTimeSecondsCopy = inputTime[1];\n  quotient = __aeabi_ldivmod(inputTimeSeconds,inputTimeSecondsCopy,0x15180,0);\n  remainingSeconds = 0x15180;\n  __aeabi_ldivmod(inputTimeSeconds,inputTimeSecondsCopy,0x15180,0);\n  isNegative = (int)remainingSeconds < 0;\n  if (isNegative) {\n    remainingSeconds = remainingSeconds + 0x15180;\n  }\n  if (isNegative) {\n    daysElapsed = quotient + 0xafa6b;\n  }\n  else {\n    daysElapsed = quotient + 0xafa6c;\n  }\n  outputDateTime->tm_hour = remainingSeconds / 0xe10;\n  outputDateTime->tm_min = (remainingSeconds % 0xe10) / 0x3c;\n  outputDateTime->tm_sec = (remainingSeconds % 0xe10) % 0x3c;\n  outputDateTime->tm_wday = (daysElapsed + 3) % 7;\n  remainingSeconds = daysElapsed;\n  if ((int)daysElapsed < 0) {\n    remainingSeconds = daysElapsed - 0x23ab0;\n  }\n  daysElapsed = (remainingSeconds / 0x23ab1) * -0x23ab1 + daysElapsed;\n  totalDays = ((daysElapsed / 0x8eac + daysElapsed) - daysElapsed / 0x5b4) - daysElapsed / 0x23ab0;\n  leapYearCount = totalDays / 0x16d;\n  daysElapsed = (leapYearCount / 100 - totalDays / 0x5b4) + daysElapsed + leapYearCount * -0x16d;\n  year = daysElapsed * 5 + 2;\n  totalDays = year / 0x99;\n  if (year < 0x5fa) {\n    quotient = 2;\n  }\n  else {\n    quotient = -10;\n  }\n  year = totalDays + quotient;\n  quotient = (remainingSeconds / 0x23ab1) * 400 + leapYearCount;\n  if (year < 2) {\n    quotient = quotient + 1;\n  }\n  if (daysElapsed < 0x132) {\n    if (((leapYearCount & 3) == 0) && (leapYearCount != (leapYearCount / 100) * 100)) {\n      remainingSeconds = 1;\n    }\n    else {\n      remainingSeconds = (uint)(leapYearCount % 400 == 0);\n    }\n    currentDayOfYear = daysElapsed + 0x3b + remainingSeconds;\n  }\n  else {\n    currentDayOfYear = daysElapsed - 0x132;\n  }\n  outputDateTime->tm_yday = currentDayOfYear;\n  outputDateTime->tm_mday = (daysElapsed + 1) - (totalDays * 0x99 + 2) / 5;\n  outputDateTime->tm_mon = year;\n  outputDateTime->tm_year = quotient + -0x76c;\n  outputDateTime->tm_isdst = 0;\n  return outputDateTime;\n}\n\n",
            "renaming": {
                "FUN_0000443c": "calculate_date_time_from_seconds_0000443c",
                "__timer": "inputTime",
                "__tp": "outputDateTime",
                "iVar1": "quotient",
                "uVar2": "daysElapsed",
                "uVar3": "remainingSeconds",
                "uVar4": "totalDays",
                "iVar5": "currentDayOfYear",
                "uVar6": "leapYearCount",
                "tVar7": "inputTimeSeconds",
                "tVar8": "inputTimeSecondsCopy",
                "uVar9": "year",
                "bVar10": "isNegative"
            },
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "called": [
                "__aeabi_ldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000459c": {
            "entrypoint": "0x0000459c",
            "current_name": "execute_cleanup_functions_0000459c",
            "code": "\nvoid execute_cleanup_functions_0000459c(EVP_PKEY_CTX *ctx)\n\n{\n  code **function_array;\n  int index;\n  \n  function_array = (code **)&__fini_array_end;\n  for (index = 0; index != 0; index = index + 1) {\n    ctx = (EVP_PKEY_CTX *)(**function_array)();\n    function_array = function_array + 1;\n  }\n  _init(ctx);\n  function_array = (code **)&__fini_array_end;\n  for (index = 0; index != 0; index = index + 1) {\n    (**function_array)();\n    function_array = function_array + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000459c": "execute_cleanup_functions_0000459c",
                "param_1": "ctx",
                "ppcVar1": "function_array",
                "iVar2": "index"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000045e4": {
            "entrypoint": "0x000045e4",
            "current_name": "FUNC_000045e4",
            "code": "\nvoid FUNC_000045e4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e4": "FUNC_000045e4"
            },
            "calling": [
                "__sfp"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e6": {
            "entrypoint": "0x000045e6",
            "current_name": "FUNC_000045e6",
            "code": "\nvoid FUNC_000045e6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e6": "FUNC_000045e6"
            },
            "calling": [
                "__tz_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e8": {
            "entrypoint": "0x000045e8",
            "current_name": "FUNC_000045e8",
            "code": "\nvoid FUNC_000045e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e8": "FUNC_000045e8"
            },
            "calling": [
                "__env_lock",
                "_fflush_r",
                "__sfp_lock_acquire",
                "__malloc_lock",
                "_puts_r",
                "_vfprintf_r",
                "__sinit_lock_acquire",
                "_putc_r",
                "_getc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ea": {
            "entrypoint": "0x000045ea",
            "current_name": "FUNC_000045ea",
            "code": "\nvoid FUNC_000045ea(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ea": "FUNC_000045ea"
            },
            "calling": [
                "__tz_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ec": {
            "entrypoint": "0x000045ec",
            "current_name": "FUNC_000045ec",
            "code": "\nvoid FUNC_000045ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ec": "FUNC_000045ec"
            },
            "calling": [
                "_fflush_r",
                "_puts_r",
                "__sfp_lock_release",
                "__malloc_unlock",
                "_vfprintf_r",
                "_putc_r",
                "__env_unlock",
                "_getc_r",
                "__sinit_lock_release"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ee": {
            "entrypoint": "0x000045ee",
            "current_name": "copy_backward_000045ee",
            "code": "\nvoid * copy_backward_000045ee(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_iterator;\n  undefined *src_iterator;\n  \n  src_iterator = (undefined *)((int)source + size);\n  if ((source < destination) && (destination < src_iterator)) {\n    dest_iterator = (undefined *)(size + (int)destination);\n    while (dest_iterator != (undefined *)destination) {\n      src_iterator = src_iterator + -1;\n      dest_iterator = dest_iterator + -1;\n      *dest_iterator = *src_iterator;\n    }\n  }\n  else {\n    dest_iterator = (undefined *)((int)destination + -1);\n    for (; (undefined *)source != src_iterator; source = (void *)((int)source + 1)) {\n      dest_iterator = dest_iterator + 1;\n      *dest_iterator = *source;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000045ee": "copy_backward_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_iterator",
                "puVar2": "src_iterator"
            },
            "calling": [
                "fmt_lpad"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004622": {
            "entrypoint": "0x00004622",
            "current_name": "fill_memory_with_character_00004622",
            "code": "\nvoid * fillMemoryWithCharacter_00004622(void *ptr,int character,size_t size)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)ptr; puVar1 != (undefined *)(size + (int)ptr); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)character;\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_00004622": "fill_memory_with_character_00004622",
                "__s": "ptr",
                "__c": "character",
                "__n": "size"
            },
            "calling": [
                "__sfmoreglue",
                "__sfp",
                "std",
                "fmt_lpad",
                "write",
                "fmt_s32_dfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004634": {
            "entrypoint": "0x00004634",
            "current_name": "adjust_date_00004634",
            "code": "\nvoid adjustDate_00004634(uint *dateArray,uint numDays,undefined4 extraParam)\n\n{\n  int daysInMonth;\n  uint day;\n  uint year;\n  int month;\n  bool isNegative;\n  uint *quotient;\n  uint remainder;\n  undefined4 unused;\n  \n  quotient = dateArray;\n  remainder = numDays;\n  unused = extraParam;\n  if (0x3b < *dateArray) {\n    div((int)&quotient,*dateArray);\n    day = dateArray[1] + (int)quotient;\n    dateArray[1] = day;\n    if ((int)remainder < 0) {\n      day = day - 1;\n      *dateArray = remainder + 0x3c;\n    }\n    else {\n      *dateArray = remainder;\n    }\n    if ((int)remainder < 0) {\n      dateArray[1] = day;\n    }\n  }\n  if (0x3b < dateArray[1]) {\n    div((int)&quotient,dateArray[1]);\n    isNegative = (int)remainder < 0;\n    year = dateArray[2] + (int)quotient;\n    dateArray[2] = year;\n    day = remainder;\n    if (isNegative) {\n      day = remainder + 0x3c;\n      year = year - 1;\n    }\n    if (!isNegative) {\n      dateArray[1] = day;\n    }\n    if (isNegative) {\n      dateArray[1] = day;\n    }\n    if (isNegative) {\n      dateArray[2] = year;\n    }\n  }\n  if (0x17 < dateArray[2]) {\n    div((int)&quotient,dateArray[2]);\n    isNegative = (int)remainder < 0;\n    year = dateArray[3] + (int)quotient;\n    dateArray[3] = year;\n    day = remainder;\n    if (isNegative) {\n      day = remainder + 0x18;\n      year = year - 1;\n    }\n    if (!isNegative) {\n      dateArray[2] = day;\n    }\n    if (isNegative) {\n      dateArray[2] = day;\n    }\n    if (isNegative) {\n      dateArray[3] = year;\n    }\n  }\n  if (0xb < dateArray[4]) {\n    div((int)&quotient,dateArray[4]);\n    isNegative = (int)remainder < 0;\n    day = dateArray[5] + (int)quotient;\n    dateArray[5] = day;\n    if (isNegative) {\n      remainder = remainder + 0xc;\n      day = day - 1;\n    }\n    if (!isNegative) {\n      dateArray[4] = remainder;\n    }\n    if (isNegative) {\n      dateArray[4] = remainder;\n    }\n    if (isNegative) {\n      dateArray[5] = day;\n    }\n  }\n  day = dateArray[5];\n  if ((day & 3) == 0) {\n    if (day == (day / 100) * 100) {\n      if ((day + 0x76c) % 400 == 0) {\n        month = 0x1d;\n      }\n      else {\n        month = 0x1c;\n      }\n    }\n    else {\n      month = 0x1d;\n    }\n  }\n  else {\n    month = 0x1c;\n  }\n  if ((int)dateArray[3] < 1) {\n    while ((int)dateArray[3] < 1) {\n      day = dateArray[4];\n      dateArray[4] = day - 1;\n      if (day - 1 == 0xffffffff) {\n        year = dateArray[5];\n        day = year - 1;\n        dateArray[4] = 0xb;\n        dateArray[5] = day;\n        if ((day & 3) == 0) {\n          if (day == (day / 100) * 100) {\n            if ((year + 0x76b) % 400 == 0) {\n              month = 0x1d;\n            }\n            else {\n              month = 0x1c;\n            }\n          }\n          else {\n            month = 0x1d;\n          }\n        }\n        else {\n          month = 0x1c;\n        }\n      }\n      daysInMonth = month;\n      if (dateArray[4] != 1) {\n        daysInMonth = *(int *)(&DAYS_IN_MONTH + dateArray[4] * 4);\n      }\n      dateArray[3] = daysInMonth + dateArray[3];\n    }\n  }\n  else {\n    while( true ) {\n      day = dateArray[4];\n      daysInMonth = month;\n      if (day != 1) {\n        daysInMonth = *(int *)(&DAYS_IN_MONTH + day * 4);\n      }\n      if ((int)dateArray[3] <= daysInMonth) break;\n      dateArray[3] = dateArray[3] - daysInMonth;\n      dateArray[4] = day + 1;\n      if (day + 1 == 0xc) {\n        year = dateArray[5];\n        day = year + 1;\n        dateArray[4] = 0;\n        dateArray[5] = day;\n        if ((day & 3) == 0) {\n          if (day % 100 == 0) {\n            if ((year + 0x76d) % 400 == 0) {\n              month = 0x1d;\n            }\n            else {\n              month = 0x1c;\n            }\n          }\n          else {\n            month = 0x1d;\n          }\n        }\n        else {\n          month = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004634": "adjust_date_00004634",
                "param_1": "dateArray",
                "param_2": "numDays",
                "param_3": "extraParam",
                "iVar1": "daysInMonth",
                "uVar2": "day",
                "uVar3": "year",
                "iVar4": "month",
                "bVar5": "isNegative",
                "local_20": "quotient",
                "local_1c": "remainder",
                "uStack_18": "unused"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "div"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000047e4": {
            "entrypoint": "0x000047e4",
            "current_name": "convert_date_time_to_timestamp_000047e4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t convertDateTimeToTimestamp_000047e4(tm *dateTime)\n\n{\n  longlong totalSeconds;\n  int *dateTimeInfo;\n  uint daysBeforeMonth;\n  int leapYearDays;\n  int leapYearDaysCorrection;\n  int daysInYear;\n  uint secondsBefore;\n  uint currentYear;\n  uint currentLeapYear;\n  int daysSinceEpoch;\n  uint year;\n  uint isDst;\n  uint isDstCorrection;\n  uint finalSeconds;\n  time_t finalTimestamp;\n  bool isDstNegative;\n  \n  dateTimeInfo = (int *)__gettzinfo();\n  validate_structure(dateTime);\n  year = dateTime->tm_year;\n  daysSinceEpoch = dateTime->tm_mday + -1 + *(int *)(&_DAYS_BEFORE_MONTH + dateTime->tm_mon * 4);\n  if (((1 < dateTime->tm_mon) && ((year & 3) == 0)) &&\n     ((year != (year / 100) * 100 || (year + 0x76c == ((year + 0x76c) / 400) * 400)))) {\n    daysSinceEpoch = daysSinceEpoch + 1;\n  }\n  dateTime->tm_yday = daysSinceEpoch;\n  if (20000 < (int)&DAT_00002710 + year) {\n    return -1;\n  }\n  if ((int)year < 0x47) {\n    if (year != 0x46) {\n      for (currentYear = 0x45; (int)year < (int)currentYear; currentYear = currentYear - 1) {\n        if ((currentYear & 3) == 0) {\n          if (currentYear == (currentYear / 100) * 100) {\n            if ((currentYear + 0x76c) % 400 == 0) {\n              daysInYear = 0x16e;\n            }\n            else {\n              daysInYear = 0x16d;\n            }\n          }\n          else {\n            daysInYear = 0x16e;\n          }\n        }\n        else {\n          daysInYear = 0x16d;\n        }\n        daysSinceEpoch = daysSinceEpoch - daysInYear;\n      }\n      if ((currentYear & 3) == 0) {\n        if (year == (year / 100) * 100) {\n          daysInYear = 0x16d;\n          if ((year + 0x76c) % 400 == 0) {\n            daysInYear = 0x16e;\n          }\n        }\n        else {\n          daysInYear = 0x16e;\n        }\n      }\n      else {\n        daysInYear = 0x16d;\n      }\n      daysSinceEpoch = daysSinceEpoch - daysInYear;\n    }\n  }\n  else {\n    currentYear = 0x46;\n    do {\n      if ((currentYear & 3) == 0) {\n        if (currentYear % 100 == 0) {\n          if ((currentYear + 0x76c) % 400 == 0) {\n            daysInYear = 0x16e;\n          }\n          else {\n            daysInYear = 0x16d;\n          }\n        }\n        else {\n          daysInYear = 0x16e;\n        }\n      }\n      else {\n        daysInYear = 0x16d;\n      }\n      currentYear = currentYear + 1;\n      daysSinceEpoch = daysSinceEpoch + daysInYear;\n    } while (year != currentYear);\n  }\n  totalSeconds = (longlong)daysSinceEpoch * 0x15180 +\n          (longlong)(dateTime->tm_hour * 0xe10 + dateTime->tm_min * 0x3c + dateTime->tm_sec);\n  finalSeconds = (uint)totalSeconds;\n  daysInYear = (int)((ulonglong)totalSeconds >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  currentYear = _daylight;\n  if (_daylight == 0) {\nLAB_00004934:\n    finalTimestamp = finalSeconds + dateTimeInfo[10];\n  }\n  else {\n    isDstCorrection = dateTime->tm_isdst;\n    isDst = isDstCorrection;\n    if (0 < (int)isDstCorrection) {\n      isDst = 1;\n    }\n    if ((dateTimeInfo[1] == dateTime->tm_year + 0x76c) || (leapYearDays = __tzcalc_limits(), leapYearDays != 0)) {\n      currentLeapYear = dateTimeInfo[0x14];\n      daysBeforeMonth = dateTimeInfo[0x12];\n      secondsBefore = dateTimeInfo[10];\n      currentYear = daysBeforeMonth - secondsBefore;\n      leapYearDays = (dateTimeInfo[0x13] - ((int)secondsBefore >> 0x1f)) - (uint)(daysBeforeMonth < secondsBefore);\n      if (((int)((daysInYear - leapYearDays) - (uint)(finalSeconds < currentYear)) < 0 ==\n           (SBORROW4(daysInYear,leapYearDays) != SBORROW4(daysInYear - leapYearDays,(uint)(finalSeconds < currentYear)))) &&\n         (leapYearDaysCorrection = (dateTimeInfo[0x13] - ((int)currentLeapYear >> 0x1f)) - (uint)(daysBeforeMonth < currentLeapYear),\n         isDstNegative = finalSeconds < daysBeforeMonth - currentLeapYear,\n         (int)((daysInYear - leapYearDaysCorrection) - (uint)isDstNegative) < 0 !=\n         (SBORROW4(daysInYear,leapYearDaysCorrection) != SBORROW4(daysInYear - leapYearDaysCorrection,(uint)isDstNegative)))) goto LAB_00004a88;\n      daysBeforeMonth = dateTimeInfo[8] - currentLeapYear;\n      leapYearDaysCorrection = (dateTimeInfo[9] - ((int)currentLeapYear >> 0x1f)) - (uint)((uint)dateTimeInfo[8] < currentLeapYear);\n      if (*dateTimeInfo != 0) {\n        if ((int)((daysInYear - leapYearDaysCorrection) - (uint)(finalSeconds < daysBeforeMonth)) < 0 ==\n            (SBORROW4(daysInYear,leapYearDaysCorrection) != SBORROW4(daysInYear - leapYearDaysCorrection,(uint)(finalSeconds < daysBeforeMonth))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        currentYear = 0;\n        if ((int)isDstCorrection < 0) goto LAB_00004934;\nLAB_00004a14:\n        isDstCorrection = isDst ^ currentYear;\n        isDst = currentYear;\n        if (isDstCorrection == 1) {\n          if (currentYear == 0) {\n            daysInYear = currentLeapYear - secondsBefore;\n          }\n          else {\n            daysInYear = secondsBefore - currentLeapYear;\n          }\n          leapYearDays = dateTime->tm_mday;\n          finalSeconds = finalSeconds + daysInYear;\n          dateTime->tm_sec = dateTime->tm_sec + daysInYear;\n          validate_structure(dateTime);\n          leapYearDays = dateTime->tm_mday - leapYearDays;\n          if (leapYearDays != 0) {\n            if (leapYearDays < 2) {\n              if (leapYearDays == -2 || leapYearDays + 2 < 0 != SCARRY4(leapYearDays,2)) {\n                leapYearDays = 1;\n              }\n            }\n            else {\n              leapYearDays = -1;\n            }\n            daysInYear = leapYearDays + dateTime->tm_yday;\n            daysSinceEpoch = daysSinceEpoch + leapYearDays;\n            if (daysInYear < 0) {\n              currentYear = year - 1;\n              if ((currentYear & 3) == 0) {\n                if (currentYear == (currentYear / 100) * 100) {\n                  daysInYear = 0x16d;\n                  if ((year + 0x76b) % 400 != 0) {\n                    daysInYear = 0x16c;\n                  }\n                }\n                else {\n                  daysInYear = 0x16d;\n                }\n              }\n              else {\n                daysInYear = 0x16c;\n              }\n            }\n            else {\n              if ((year & 3) == 0) {\n                if (year == (year / 100) * 100) {\n                  leapYearDays = 0x16d;\n                  if ((year + 0x76c) % 400 == 0) {\n                    leapYearDays = 0x16e;\n                  }\n                }\n                else {\n                  leapYearDays = 0x16e;\n                }\n              }\n              else {\n                leapYearDays = 0x16d;\n              }\n              if (leapYearDays <= daysInYear) {\n                daysInYear = daysInYear - leapYearDays;\n              }\n            }\n            dateTime->tm_yday = daysInYear;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((daysInYear - leapYearDaysCorrection) - (uint)(finalSeconds < daysBeforeMonth)) < 0 !=\n          (SBORROW4(daysInYear,leapYearDaysCorrection) != SBORROW4(daysInYear - leapYearDaysCorrection,(uint)(finalSeconds < daysBeforeMonth)))) {\nLAB_0000491e:\n        if ((int)((daysInYear - leapYearDays) - (uint)(finalSeconds < currentYear)) < 0 ==\n            (SBORROW4(daysInYear,leapYearDays) != SBORROW4(daysInYear - leapYearDays,(uint)(finalSeconds < currentYear))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)isDstCorrection) {\n        currentYear = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      currentYear = isDst;\n      if (isDst != 1) goto LAB_00004934;\n    }\n    finalTimestamp = finalSeconds + dateTimeInfo[0x14];\n    currentYear = 1;\n  }\n  __tz_unlock();\n  dateTime->tm_isdst = currentYear;\n  dateTime->tm_wday = (daysSinceEpoch + 4U) % 7;\n  return finalTimestamp;\n}\n\n",
            "renaming": {
                "FUN_000047e4": "convert_date_time_to_timestamp_000047e4",
                "__tp": "dateTime",
                "lVar1": "totalSeconds",
                "piVar2": "dateTimeInfo",
                "uVar3": "daysBeforeMonth",
                "iVar4": "leapYearDays",
                "iVar5": "leapYearDaysCorrection",
                "iVar6": "daysInYear",
                "uVar7": "secondsBefore",
                "uVar8": "currentYear",
                "uVar9": "currentLeapYear",
                "iVar10": "daysSinceEpoch",
                "uVar11": "year",
                "uVar12": "isDst",
                "uVar13": "isDstCorrection",
                "uVar14": "finalSeconds",
                "tVar15": "finalTimestamp",
                "bVar16": "isDstNegative"
            },
            "calling": [
                "rtc_set_alarm",
                "rtc_set_time"
            ],
            "called": [
                "_tzset_unlocked",
                "validate_structure",
                "__tz_lock",
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004b34": {
            "entrypoint": "0x00004b34",
            "current_name": "allocate_memory_00004b34",
            "code": "\nvoid allocateMemory_00004b34(undefined4 *error_code,int size,undefined4 arg1,undefined4 arg2)\n\n{\n  int *temp_ptr;\n  int **extraout_ptr;\n  int **previous_ptr;\n  int **current_ptr;\n  int **next_ptr;\n  int **allocated_ptr;\n  bool is_same_block;\n  \n  if (size == 0) {\n    return;\n  }\n  allocated_ptr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    allocated_ptr = (int **)((int)allocated_ptr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  current_ptr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    allocated_ptr[1] = (int *)0x0;\n    previous_ptr = extraout_ptr;\n    __malloc_free_list = allocated_ptr;\n  }\n  else {\n    next_ptr = __malloc_free_list;\n    if (allocated_ptr < __malloc_free_list) {\n      previous_ptr = (int **)*allocated_ptr;\n      current_ptr = (int **)((int)allocated_ptr + (int)previous_ptr);\n      is_same_block = __malloc_free_list == current_ptr;\n      if (is_same_block) {\n        current_ptr = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      allocated_ptr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = allocated_ptr;\n      if (is_same_block) {\n        current_ptr = (int **)((int)current_ptr + (int)previous_ptr);\n        *allocated_ptr = (int *)current_ptr;\n      }\n    }\n    else {\n      do {\n        current_ptr = next_ptr;\n        next_ptr = (int **)current_ptr[1];\n        if (next_ptr == (int **)0x0) break;\n      } while (next_ptr <= allocated_ptr);\n      previous_ptr = (int **)*current_ptr;\n      if ((int **)((int)current_ptr + (int)previous_ptr) == allocated_ptr) {\n        previous_ptr = (int **)((int)previous_ptr + (int)*allocated_ptr);\n        *current_ptr = (int *)previous_ptr;\n        if (next_ptr == (int **)((int)current_ptr + (int)previous_ptr)) {\n          temp_ptr = *next_ptr;\n          current_ptr[1] = next_ptr[1];\n          previous_ptr = (int **)((int)previous_ptr + (int)temp_ptr);\n          *current_ptr = (int *)previous_ptr;\n        }\n      }\n      else if (allocated_ptr < (int **)((int)current_ptr + (int)previous_ptr)) {\n        *error_code = 0xc;\n      }\n      else {\n        previous_ptr = (int **)((int)allocated_ptr + (int)*allocated_ptr);\n        is_same_block = next_ptr == previous_ptr;\n        if (is_same_block) {\n          previous_ptr = (int **)*next_ptr;\n          next_ptr = (int **)next_ptr[1];\n        }\n        allocated_ptr[1] = (int *)next_ptr;\n        if (is_same_block) {\n          previous_ptr = (int **)((int)previous_ptr + (int)*allocated_ptr);\n          *allocated_ptr = (int *)previous_ptr;\n        }\n        current_ptr[1] = (int *)allocated_ptr;\n      }\n    }\n  }\n  __malloc_unlock(error_code,previous_ptr,current_ptr,arg2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004b34": "allocate_memory_00004b34",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "arg1",
                "param_4": "arg2",
                "piVar1": "temp_ptr",
                "extraout_r1": "extraout_ptr",
                "ppiVar2": "previous_ptr",
                "ppiVar3": "current_ptr",
                "ppiVar4": "next_ptr",
                "ppiVar5": "allocated_ptr",
                "bVar6": "is_same_block"
            },
            "calling": [
                "_realloc_r",
                "__ssrefill_r",
                "free",
                "__sflush_r",
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004bd0": {
            "entrypoint": "0x00004bd0",
            "current_name": "FUNC_00004bd0",
            "code": "\nuint FUNC_00004bd0(_reent *param_1,uint param_2)\n\n{\n  uint *puVar1;\n  void *pvVar2;\n  int iVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  \n  uVar6 = (param_2 + 3 & 0xfffffffc) + 8;\n  if (uVar6 < 0xc) {\n    uVar6 = 0xc;\n  }\n  if (((int)uVar6 < 0) || (uVar6 < param_2)) {\n    param_1->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 = __malloc_free_list;\n    for (puVar5 = __malloc_free_list; puVar5 != (uint *)0x0; puVar5 = (uint *)puVar5[1]) {\n      uVar4 = *puVar5 - uVar6;\n      if (-1 < (int)uVar4) {\n        if (0xb < uVar4) {\n          *puVar5 = uVar4;\n          puVar5 = (uint *)((int)puVar5 + uVar4);\n          goto LAB_00004c34;\n        }\n        if (puVar1 == puVar5) {\n          __malloc_free_list = (uint *)puVar5[1];\n        }\n        if (puVar1 != puVar5) {\n          puVar1[1] = (uint)(uint *)puVar5[1];\n        }\n        goto LAB_00004c42;\n      }\n      puVar1 = puVar5;\n    }\n    if (__malloc_sbrk_start == (void *)0x0) {\n      __malloc_sbrk_start = _sbrk_r(param_1,0);\n    }\n    puVar1 = (uint *)_sbrk_r(param_1,uVar6);\n    if ((puVar1 != (uint *)0xffffffff) &&\n       ((puVar5 = (uint *)((int)puVar1 + 3U & 0xfffffffc), puVar1 == puVar5 ||\n        (pvVar2 = _sbrk_r(param_1,(int)puVar5 - (int)puVar1), pvVar2 != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *puVar5 = uVar6;\nLAB_00004c42:\n      __malloc_unlock(param_1);\n      uVar6 = (int)puVar5 + 0xbU & 0xfffffff8;\n      iVar3 = uVar6 - (int)(puVar5 + 1);\n      if (iVar3 == 0) {\n        return uVar6;\n      }\n      *(uint *)((int)puVar5 + iVar3) = (int)(puVar5 + 1) - uVar6;\n      return uVar6;\n    }\n    param_1->_errno = 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004bd0": "FUNC_00004bd0"
            },
            "calling": [
                "__sfmoreglue",
                "__submore",
                "__smakebuf_r",
                "_realloc_r",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00004c84": {
            "entrypoint": "0x00004c84",
            "current_name": "print_formatted_output_00004c84",
            "code": "\nint printFormattedOutput_00004c84(char *formatString,...)\n\n{\n  int impurePointer;\n  undefined4 tempReg1;\n  undefined4 tempReg2;\n  undefined4 tempReg3;\n  char *formatPointer;\n  undefined4 tempStackC;\n  undefined4 tempStack8;\n  undefined4 tempStack4;\n  \n  impurePointer = _impure_ptr;\n  formatPointer = formatString;\n  tempStackC = tempReg1;\n  tempStack8 = tempReg2;\n  tempStack4 = tempReg3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePointer = _vfprintf_r(impurePointer,*(undefined4 *)(impurePointer + 8),formatString,&tempStackC,formatPointer,&tempStackC);\n  return impurePointer;\n}\n\n",
            "renaming": {
                "FUN_00004c84": "print_formatted_output_00004c84",
                "__format": "formatString",
                "iVar1": "impurePointer",
                "in_r1": "tempReg1",
                "in_r2": "tempReg2",
                "in_r3": "tempReg3",
                "pcVar2": "formatPointer",
                "uStack_c": "tempStackC",
                "uStack_8": "tempStack8",
                "uStack_4": "tempStack4"
            },
            "calling": [
                "main_trampoline",
                "read",
                "hard_fault_handler",
                "_rtc_handler",
                "handle_input_line",
                "cpu_print_last_instruction",
                "probe",
                "phydat_dump",
                "core_panic",
                "_saul",
                "write",
                "print_help",
                "ps",
                "_print_time",
                "list"
            ],
            "called": [
                "__sinit",
                "_vfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cb4": {
            "entrypoint": "0x00004cb4",
            "current_name": "put_character_00004cb4",
            "code": "\nint putCharacter_00004cb4(int character)\n\n{\n  int impurePtr;\n  undefined4 unused;\n  \n  impurePtr = impurePtr;\n  if ((impurePtr != 0) && (*(int *)(impurePtr + 0x18) == 0)) {\n    __sinit(impurePtr);\n  }\n  impurePtr = _putc_r(impurePtr,character,*(undefined4 *)(impurePtr + 8),unused);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_00004cb4": "put_character_00004cb4",
                "__c": "character",
                "iVar1": "impurePtr",
                "in_r3": "unused",
                "_impure_ptr": "impurePtr"
            },
            "calling": [
                "_putchar"
            ],
            "called": [
                "__sinit",
                "_putc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cdc": {
            "entrypoint": "0x00004cdc",
            "current_name": "process_input_00004cdc",
            "code": "\nundefined4 processInput_00004cdc(int inputBuffer,int bufferSize)\n\n{\n  char currentChar;\n  int result;\n  char *bufferPointer;\n  char **ioStreams;\n  undefined4 returnValue;\n  char *currentByte;\n  \n  if ((inputBuffer != 0) && (*(int *)(inputBuffer + 0x18) == 0)) {\n    __sinit();\n  }\n  ioStreams = *(char ***)(inputBuffer + 8);\n  if (*(int *)(inputBuffer + 0x18) == 0) {\n    __sinit(inputBuffer);\n  }\n  if (ioStreams == (char **)&__sf_fake_stdin) {\n    ioStreams = *(char ***)(inputBuffer + 4);\n  }\n  else if (ioStreams == (char **)&__sf_fake_stdout) {\n    ioStreams = *(char ***)(inputBuffer + 8);\n  }\n  else if (ioStreams == (char **)&__sf_fake_stderr) {\n    ioStreams = *(char ***)(inputBuffer + 0xc);\n  }\n  if ((-1 < (int)ioStreams[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ioStreams + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(ioStreams[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ioStreams + 3) << 0x1c) < 0) && (ioStreams[4] != (char *)0x0)) ||\n     (result = __swsetup_r(inputBuffer,ioStreams), result == 0)) {\n    currentByte = (char *)(bufferSize + -1);\n    do {\n      while( true ) {\n        currentByte = currentByte + 1;\n        currentChar = *currentByte;\n        bufferPointer = ioStreams[2] + -1;\n        ioStreams[2] = bufferPointer;\n        if (currentChar == '\\0') {\n          if (-1 < (int)bufferPointer) {\n            currentByte = *ioStreams;\n            returnValue = 10;\n            *ioStreams = currentByte + 1;\n            *currentByte = '\\n';\n            goto LAB_00004d64;\n          }\n          result = __swbuf_r(inputBuffer,10,ioStreams);\n          if (result != -1) {\n            returnValue = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)bufferPointer < 0) && (((int)bufferPointer < (int)ioStreams[6] || (currentChar == '\\n')))) break;\n        bufferPointer = *ioStreams;\n        *ioStreams = bufferPointer + 1;\n        *bufferPointer = currentChar;\n      }\n      result = __swbuf_r(inputBuffer,currentChar,ioStreams);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  returnValue = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)ioStreams[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ioStreams + 3) << 0x16))) {\n    __retarget_lock_release_recursive(ioStreams[0x16]);\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00004cdc": "process_input_00004cdc",
                "param_1": "inputBuffer",
                "param_2": "bufferSize",
                "cVar1": "currentChar",
                "iVar2": "result",
                "pcVar3": "bufferPointer",
                "ppcVar4": "ioStreams",
                "uVar5": "returnValue",
                "pcVar6": "currentByte"
            },
            "calling": [
                "puts"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004db8": {
            "entrypoint": "0x00004db8",
            "current_name": "print_string_00004db8",
            "code": "\nint print_string_00004db8(char *string)\n\n{\n  int result;\n  \n  result = _puts_r(_impure_ptr,string);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004db8": "print_string_00004db8",
                "__s": "string",
                "iVar1": "result"
            },
            "calling": [
                "_rtc_usage",
                "_rtc_gettime",
                "read",
                "hard_fault_handler",
                "handle_input_line",
                "_alarm_handler",
                "phydat_dump",
                "_rtc_setalarm",
                "main",
                "_rtc_getalarm",
                "probe_all",
                "_rtc_settime",
                "write",
                "print_help",
                "list"
            ],
            "called": [
                "_puts_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dc8": {
            "entrypoint": "0x00004dc8",
            "current_name": "read_and_update_data_00004dc8",
            "code": "\nvoid read_and_update_data_00004dc8(_reent *reent_struct,int data_ptr,void *buffer,size_t buffer_size)\n\n{\n  _ssize_t bytes_read;\n  uint updated_value;\n  bool is_read_successful;\n  \n  bytes_read = _read_r(reent_struct,(int)*(short *)(data_ptr + 0xe),buffer,buffer_size);\n  is_read_successful = -1 < bytes_read;\n  if (is_read_successful) {\n    updated_value = *(int *)(data_ptr + 0x54) + bytes_read;\n  }\n  else {\n    updated_value = *(ushort *)(data_ptr + 0xc) & 0xffffefff;\n  }\n  if (is_read_successful) {\n    *(uint *)(data_ptr + 0x54) = updated_value;\n  }\n  if (!is_read_successful) {\n    *(short *)(data_ptr + 0xc) = (short)updated_value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dc8": "read_and_update_data_00004dc8",
                "param_1": "reent_struct",
                "param_2": "data_ptr",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "_Var1": "bytes_read",
                "uVar2": "updated_value",
                "bVar3": "is_read_successful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dea": {
            "entrypoint": "0x00004dea",
            "current_name": "initialize_00004dea",
            "code": "\nundefined4 initialize_00004dea(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004dea": "initialize_00004dea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dee": {
            "entrypoint": "0x00004dee",
            "current_name": "write_data_to_file_00004dee",
            "code": "\nvoid writeDataToFile_00004dee(_reent *fileDescriptor,int bufferPointer,void *data,size_t size)\n\n{\n  if ((int)((uint)*(unsigned_short *)(bufferPointer + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(bufferPointer + 0xe),0,2);\n  }\n  *(unsigned_short *)(bufferPointer + 0xc) = *(unsigned_short *)(bufferPointer + 0xc) & 0xefff;\n  _write_r(fileDescriptor,(int)*(short *)(bufferPointer + 0xe),data,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dee": "write_data_to_file_00004dee",
                "param_1": "fileDescriptor",
                "param_2": "bufferPointer",
                "param_3": "data",
                "param_4": "size",
                "ushort": "unsigned_short"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e26": {
            "entrypoint": "0x00004e26",
            "current_name": "handle_file_seek_error_00004e26",
            "code": "\nvoid handleFileSeekError_00004e26(_reent *reentPtr,int dataPtr,_off_t offset,int whence)\n\n{\n  _off_t seekResult;\n  ushort flags;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(reentPtr,(int)*(short *)(dataPtr + 0xe),offset,whence);\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    flags = *(ushort *)(dataPtr + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(dataPtr + 0x54) = seekResult;\n    flags = *(ushort *)(dataPtr + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(dataPtr + 0xc) = flags;\n  }\n  if (!isSeekError) {\n    *(ushort *)(dataPtr + 0xc) = flags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e26": "handle_file_seek_error_00004e26",
                "param_1": "reentPtr",
                "param_2": "dataPtr",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seekResult",
                "uVar2": "flags",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e4a": {
            "entrypoint": "0x00004e4a",
            "current_name": "close_file_00004e4a",
            "code": "\nvoid closeFile_00004e4a(_reent *reentStruct,int filePointer)\n\n{\n  _close_r(reentStruct,(int)*(short *)(filePointer + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reentStruct",
                "param_2": "filePointer"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e52": {
            "entrypoint": "0x00004e52",
            "current_name": "compare_strings_00004e52",
            "code": "\nint compareStrings_00004e52(char *string1,char *string2)\n\n{\n  byte byte1;\n  uint char1;\n  bool isEqual;\n  \n  do {\n    char1 = (uint)(byte)*string1;\n    byte1 = *string2;\n    isEqual = char1 == 1;\n    if (char1 != 0) {\n      isEqual = char1 == byte1;\n    }\n    string1 = (char *)((byte *)string1 + 1);\n    string2 = (char *)((byte *)string2 + 1);\n  } while (isEqual);\n  return char1 - byte1;\n}\n\n",
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string1",
                "__s2": "string2",
                "bVar1": "byte1",
                "uVar2": "char1",
                "bVar3": "isEqual"
            },
            "calling": [
                "_saul",
                "read",
                "handle_input_line",
                "strcmp",
                "find_handler",
                "_tzset_unlocked_r"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e66": {
            "entrypoint": "0x00004e66",
            "current_name": "compare_strings_00004e66",
            "code": "\nint compare_strings_00004e66(char *string1,char *string2,size_t length)\n\n{\n  byte *ptr1;\n  int result;\n  byte *ptr2;\n  uint char1;\n  \n  if (length == 0) {\n    result = 0;\n  }\n  else {\n    ptr2 = (byte *)(string2 + -1);\n    ptr1 = (byte *)string1;\n    do {\n      char1 = (uint)*ptr1;\n      ptr2 = ptr2 + 1;\n      if ((char1 != *ptr2) || (ptr1 + 1 == (byte *)(string1 + length))) break;\n      ptr1 = ptr1 + 1;\n    } while (char1 != 0);\n    result = char1 - *ptr2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "ptr1",
                "iVar2": "result",
                "pbVar3": "ptr2",
                "uVar4": "char1"
            },
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e8c": {
            "entrypoint": "0x00004e8c",
            "current_name": "parse_integer_00004e8c",
            "code": "\nuint parse_integer_00004e8c(undefined4 *result_ptr,byte *input_string,byte **remaining_string_ptr,uint base)\n\n{\n  uint result;\n  uint current_char;\n  uint is_negative;\n  uint converted_digit;\n  int parse_flag;\n  uint max_value;\n  uint quotient;\n  byte *current_byte;\n  byte *next_byte;\n  \n  next_byte = input_string;\n  do {\n    current_byte = next_byte;\n    next_byte = current_byte + 1;\n    current_char = (uint)*current_byte;\n    is_negative = (byte)(&DAT_00007a99)[current_char] & 8;\n  } while (((&DAT_00007a99)[current_char] & 8) != 0);\n  if (current_char == 0x2d) {\n    current_char = (uint)*next_byte;\n    is_negative = 1;\n    next_byte = current_byte + 2;\n  }\n  else if (current_char == 0x2b) {\n    current_char = (uint)*next_byte;\n    next_byte = current_byte + 2;\n  }\n  if (base == 0) {\n    if (current_char != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (current_char != 0x30)) goto LAB_00004ed6;\n  if ((*next_byte & 0xdf) == 0x58) {\n    current_char = (uint)next_byte[1];\n    base = 0x10;\n    next_byte = next_byte + 2;\n  }\n  else {\n    current_char = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  max_value = is_negative + 0x7fffffff;\n  parse_flag = 0;\n  quotient = max_value / base;\n  result = 0;\n  do {\n    converted_digit = current_char - 0x30;\n    if (9 < converted_digit) {\n      if (current_char - 0x41 < 0x1a) {\n        converted_digit = current_char - 0x37;\n      }\n      else {\n        if (0x19 < current_char - 0x61) break;\n        converted_digit = current_char - 0x57;\n      }\n    }\n    if ((int)base <= (int)converted_digit) break;\n    if (parse_flag != -1) {\n      if ((quotient < result) || ((quotient == result && ((int)(max_value - base * quotient) < (int)converted_digit)))) {\n        parse_flag = -1;\n      }\n      else {\n        result = result * base + converted_digit;\n        parse_flag = 1;\n      }\n    }\n    current_char = (uint)*next_byte;\n    next_byte = next_byte + 1;\n  } while( true );\n  if (parse_flag == -1) {\n    *result_ptr = 0x22;\n    result = max_value;\n    if (remaining_string_ptr == (byte **)0x0) {\n      return max_value;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      result = -result;\n    }\n    if (remaining_string_ptr == (byte **)0x0) {\n      return result;\n    }\n    if (parse_flag == 0) goto LAB_00004f64;\n  }\n  input_string = next_byte + -1;\nLAB_00004f64:\n  *remaining_string_ptr = input_string;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004e8c": "parse_integer_00004e8c",
                "param_1": "result_ptr",
                "param_2": "input_string",
                "param_3": "remaining_string_ptr",
                "param_4": "base",
                "uVar1": "result",
                "uVar2": "current_char",
                "uVar3": "is_negative",
                "uVar4": "converted_digit",
                "iVar5": "parse_flag",
                "uVar6": "max_value",
                "uVar7": "quotient",
                "pbVar8": "current_byte",
                "pbVar9": "next_byte"
            },
            "calling": [
                "strtol",
                "_strtol_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f80": {
            "entrypoint": "0x00004f80",
            "current_name": "FUN_00004f80",
            "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)(&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f84": {
            "entrypoint": "0x00004f84",
            "current_name": "convert_string_to_number_00004f84",
            "code": "\nlong convertStringToNumber_00004f84(char *numberString,char **endPtr,int base)\n\n{\n  long convertedNumber;\n  \n  convertedNumber = _strtol_l_isra_0(_impure_ptr,numberString,endPtr,base);\n  return convertedNumber;\n}\n\n",
            "renaming": {
                "FUN_00004f84": "convert_string_to_number_00004f84",
                "__nptr": "numberString",
                "__endptr": "endPtr",
                "__base": "base",
                "lVar1": "convertedNumber"
            },
            "calling": [
                "_parse_time",
                "atoi"
            ],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f98": {
            "entrypoint": "0x00004f98",
            "current_name": "calculate_weekday_00004f98",
            "code": "\nundefined4 calculateWeekday_00004f98(uint year)\n\n{\n  uint *timeZoneInfo;\n  undefined4 isLeapYear;\n  uint dayOfWeekOffset;\n  int daysOffset;\n  uint *currentYearDays;\n  int totalDaysOffset;\n  uint isLeapYear2;\n  int monthIndex;\n  int weekdayOffset;\n  uint isLeapYear3;\n  \n  timeZoneInfo = (uint *)__gettzinfo();\n  if ((int)year < 0x7b2) {\n    isLeapYear = 0;\n  }\n  else {\n    totalDaysOffset = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) +\n            (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    timeZoneInfo[1] = year;\n    isLeapYear3 = (uint)(year % 400 == 0);\n    currentYearDays = timeZoneInfo;\n    do {\n      dayOfWeekOffset = currentYearDays[5];\n      if (*(char *)(currentYearDays + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)dayOfWeekOffset < 0x3c) {\n            daysOffset = 0;\n          }\n          else {\n            daysOffset = 1;\n          }\n        }\n        else {\n          daysOffset = 0;\n        }\n        daysOffset = daysOffset + totalDaysOffset + dayOfWeekOffset + -1;\n      }\n      else if (*(char *)(currentYearDays + 2) == 'D') {\n        daysOffset = totalDaysOffset + dayOfWeekOffset;\n      }\n      else {\n        isLeapYear2 = isLeapYear3;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          isLeapYear2 = 1;\n        }\n        monthIndex = 0;\n        daysOffset = totalDaysOffset;\n        while( true ) {\n          monthIndex = monthIndex + 1;\n          if ((int)currentYearDays[3] <= monthIndex) break;\n          daysOffset = daysOffset + *(int *)(&UNK_00007b98 + monthIndex * 4 + isLeapYear2 * 0x30);\n        }\n        weekdayOffset = dayOfWeekOffset - (daysOffset + 4U) % 7;\n        if (weekdayOffset < 0) {\n          weekdayOffset = weekdayOffset + 7;\n        }\n        for (weekdayOffset = (currentYearDays[4] - 1) * 7 + weekdayOffset;\n            *(int *)(&UNK_00007b98 + monthIndex * 4 + isLeapYear2 * 0x30) <= weekdayOffset; weekdayOffset = weekdayOffset + -7) {\n        }\n        daysOffset = daysOffset + weekdayOffset;\n      }\n      dayOfWeekOffset = currentYearDays[10] + daysOffset * 0x15180 + currentYearDays[6];\n      currentYearDays[8] = dayOfWeekOffset;\n      currentYearDays[9] = (int)dayOfWeekOffset >> 0x1f;\n      currentYearDays = currentYearDays + 10;\n    } while (timeZoneInfo + 0x14 != currentYearDays);\n    dayOfWeekOffset = timeZoneInfo[9];\n    isLeapYear3 = timeZoneInfo[0x13];\n    *timeZoneInfo = (uint)((int)((dayOfWeekOffset - isLeapYear3) - (uint)(timeZoneInfo[8] < timeZoneInfo[0x12])) < 0 !=\n                    (SBORROW4(dayOfWeekOffset,isLeapYear3) !=\n                    SBORROW4(dayOfWeekOffset - isLeapYear3,(uint)(timeZoneInfo[8] < timeZoneInfo[0x12]))));\n    isLeapYear = 1;\n  }\n  return isLeapYear;\n}\n\n",
            "renaming": {
                "FUN_00004f98": "calculate_weekday_00004f98",
                "param_1": "year",
                "puVar1": "timeZoneInfo",
                "uVar2": "isLeapYear",
                "uVar3": "dayOfWeekOffset",
                "iVar4": "daysOffset",
                "puVar5": "currentYearDays",
                "iVar6": "totalDaysOffset",
                "uVar7": "isLeapYear2",
                "iVar8": "monthIndex",
                "iVar9": "weekdayOffset",
                "uVar10": "isLeapYear3"
            },
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__gettzinfo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050e8": {
            "entrypoint": "0x000050e8",
            "current_name": "acquire_tz_mutex_000050e8",
            "code": "\nvoid acquire_tz_mutex_000050e8(void)\n\n{\n  lock_acquire(&tz_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050e8": "acquire_tz_mutex_000050e8",
                "__retarget_lock_acquire": "lock_acquire",
                "__lock___tz_mutex": "tz_mutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_acquire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050f4": {
            "entrypoint": "0x000050f4",
            "current_name": "release_mutex_000050f4",
            "code": "\nvoid releaseMutex_000050f4(void)\n\n{\n  __retarget_lock_release(&ptr_tzMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050f4": "release_mutex_000050f4",
                "__lock___tz_mutex": "ptr_tzMutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005100": {
            "entrypoint": "0x00005100",
            "current_name": "initialize_timezone_00005100",
            "code": "\nvoid initializeTimezone_00005100(void)\n\n{\n  updateTimezone(timezoneData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005100": "initialize_timezone_00005100",
                "_tzset_unlocked_r": "updateTimezone",
                "_impure_ptr": "timezoneData"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "_tzset_unlocked_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000510c": {
            "entrypoint": "0x0000510c",
            "current_name": "configure_timezone_0000510c",
            "code": "\nvoid configureTimezone_0000510c(undefined4 param)\n\n{\n  int tzinfo;\n  char *tzenv;\n  size_t tzenvLength;\n  int comparisonResult;\n  int scanResult;\n  ulong parsedValue;\n  undefined timeType;\n  char *scanPtr;\n  bool isFirstTime;\n  ushort *scanResult1;\n  int *index1;\n  ushort *scanResult2;\n  int *index2;\n  ushort hours;\n  ushort minutes;\n  ushort seconds;\n  ushort months;\n  ushort days;\n  ushort years;\n  int scanResultPtr;\n  char *prevTzenv [2];\n  \n  tzinfo = __gettzinfo();\n  tzenv = (char *)_getenv_r(param,&DAT_00007a5c);\n  if (tzenv == (char *)0x0) {\n    _tzname = &DAT_00007a5f;\n    DAT_1fff02e8 = &DAT_00007a5f;\n    _daylight = tzenv;\n    _timezone = tzenv;\n    free(prev_tzenv);\n    prev_tzenv = (char *)0x0;\n  }\n  else if ((prev_tzenv == (char *)0x0) || (comparisonResult = strcmp(tzenv,prev_tzenv), comparisonResult != 0)) {\n    free(prev_tzenv);\n    tzenvLength = strlen(tzenv);\n    prev_tzenv = (char *)_malloc_r(param,tzenvLength + 1);\n    if (prev_tzenv != (char *)0x0) {\n      strcpy(prev_tzenv,tzenv);\n    }\n    if (*tzenv == ':') {\n      tzenv = tzenv + 1;\n    }\n    comparisonResult = siscanf(tzenv,\"%10[^0-9,+-]%n\",&__tzname_std,&scanResultPtr);\n    if (0 < comparisonResult) {\n      scanPtr = tzenv + scanResultPtr;\n      if (tzenv[scanResultPtr] == '-') {\n        scanPtr = scanPtr + 1;\n        comparisonResult = -1;\n      }\n      else {\n        if (tzenv[scanResultPtr] == '+') {\n          scanPtr = scanPtr + 1;\n        }\n        comparisonResult = 1;\n      }\n      minutes = 0;\n      seconds = 0;\n      scanResult1 = &minutes;\n      index1 = &scanResultPtr;\n      scanResult2 = &seconds;\n      index2 = &scanResultPtr;\n      scanResult = siscanf(scanPtr,\"%hu%n:%hu%n:%hu%n\",&hours,&scanResultPtr,&minutes,&scanResultPtr,&seconds,\n                      &scanResultPtr);\n      if (0 < scanResult) {\n        *(uint *)(tzinfo + 0x28) =\n             ((uint)hours * 0xe10 + (uint)minutes * 0x3c + (uint)seconds) * comparisonResult;\n        _tzname = &__tzname_std;\n        scanPtr = scanPtr + scanResultPtr;\n        comparisonResult = siscanf(scanPtr,\"%10[^0-9,+-]%n\",&__tzname_dst,&scanResultPtr,scanResult1,index1,scanResult2,\n                        index2);\n        if (comparisonResult < 1) {\n          DAT_1fff02e8 = _tzname;\n          _timezone = *(char **)(tzinfo + 0x28);\n          _daylight = (char *)0x0;\n        }\n        else {\n          DAT_1fff02e8 = &__tzname_dst;\n          tzenv = scanPtr + scanResultPtr;\n          if (scanPtr[scanResultPtr] == '-') {\n            tzenv = tzenv + 1;\n            comparisonResult = -1;\n          }\n          else {\n            if (scanPtr[scanResultPtr] == '+') {\n              tzenv = tzenv + 1;\n            }\n            comparisonResult = 1;\n          }\n          hours = 0;\n          minutes = 0;\n          seconds = 0;\n          scanResultPtr = 0;\n          scanResult = siscanf(tzenv,\"%hu%n:%hu%n:%hu%n\",&hours,&scanResultPtr,&minutes,&scanResultPtr,\n                          &seconds,&scanResultPtr);\n          if (scanResult < 1) {\n            comparisonResult = *(int *)(tzinfo + 0x28) + -0xe10;\n          }\n          else {\n            comparisonResult = ((uint)hours * 0xe10 + (uint)minutes * 0x3c + (uint)seconds) * comparisonResult;\n          }\n          *(int *)(tzinfo + 0x50) = comparisonResult;\n          tzenv = tzenv + scanResultPtr;\n          isFirstTime = false;\n          comparisonResult = tzinfo;\n          while( true ) {\n            if (*tzenv == ',') {\n              tzenv = tzenv + 1;\n            }\n            if (*tzenv == 'M') {\n              scanResult = siscanf(tzenv,\"M%hu%n.%hu%n.%hu%n\",&months,&scanResultPtr,&days,&scanResultPtr,\n                              &years,&scanResultPtr);\n              if (scanResult != 3) {\n                return;\n              }\n              if (0xb < months - 1) {\n                return;\n              }\n              if (4 < days - 1) {\n                return;\n              }\n              if (6 < years) {\n                return;\n              }\n              *(uint *)(comparisonResult + 0xc) = (uint)months;\n              *(uint *)(comparisonResult + 0x10) = (uint)days;\n              *(undefined *)(comparisonResult + 8) = 0x4d;\n              *(uint *)(comparisonResult + 0x14) = (uint)years;\n              scanPtr = tzenv + scanResultPtr;\n            }\n            else {\n              if (*tzenv == 'J') {\n                tzenv = tzenv + 1;\n                timeType = 0x4a;\n              }\n              else {\n                timeType = 0x44;\n              }\n              parsedValue = strtoul(tzenv,prevTzenv,10);\n              years = (ushort)parsedValue;\n              scanPtr = prevTzenv[0];\n              if (prevTzenv[0] == tzenv) {\n                if (isFirstTime) {\n                  *(undefined *)(tzinfo + 0x30) = 0x4d;\n                  *(undefined4 *)(tzinfo + 0x34) = 0xb;\n                  *(undefined4 *)(tzinfo + 0x38) = 1;\n                  *(undefined4 *)(tzinfo + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(tzinfo + 8) = 0x4d;\n                  *(undefined4 *)(tzinfo + 0xc) = 3;\n                  *(undefined4 *)(tzinfo + 0x10) = 2;\n                  *(undefined4 *)(tzinfo + 0x14) = 0;\n                }\n              }\n              else {\n                *(undefined *)(comparisonResult + 8) = timeType;\n                *(ulong *)(comparisonResult + 0x14) = parsedValue & 0xffff;\n              }\n            }\n            hours = 2;\n            minutes = 0;\n            seconds = 0;\n            scanResultPtr = 0;\n            if (*scanPtr == '/') {\n              siscanf(scanPtr,\"/%hu%n:%hu%n:%hu%n\",&hours,&scanResultPtr,&minutes,&scanResultPtr,&seconds,\n                      &scanResultPtr);\n            }\n            *(uint *)(comparisonResult + 0x18) =\n                 (uint)hours * 0xe10 + (uint)minutes * 0x3c + (uint)seconds;\n            comparisonResult = comparisonResult + 0x28;\n            tzenv = scanPtr + scanResultPtr;\n            if (isFirstTime) break;\n            isFirstTime = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(tzinfo + 4));\n          _timezone = *(char **)(tzinfo + 0x28);\n          _daylight = (char *)(*(int *)(tzinfo + 0x50) - (int)_timezone);\n          if (_daylight != (char *)0x0) {\n            _daylight = (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000510c": "configure_timezone_0000510c",
                "param_1": "param",
                "iVar1": "tzinfo",
                "pcVar2": "tzenv",
                "sVar3": "tzenvLength",
                "iVar4": "comparisonResult",
                "iVar5": "scanResult",
                "uVar6": "parsedValue",
                "uVar7": "timeType",
                "pcVar8": "scanPtr",
                "bVar9": "isFirstTime",
                "puVar10": "scanResult1",
                "piVar11": "index1",
                "puVar12": "scanResult2",
                "piVar13": "index2",
                "local_3c": "hours",
                "local_3a": "minutes",
                "local_38": "seconds",
                "local_36": "months",
                "local_34": "days",
                "local_32": "years",
                "local_30": "scanResultPtr",
                "local_2c": "prevTzenv"
            },
            "calling": [
                "_tzset_unlocked"
            ],
            "called": [
                "_malloc_r",
                "_getenv_r",
                "__gettzinfo",
                "siscanf",
                "free",
                "strlen",
                "strtoul",
                "strcmp",
                "__tzcalc_limits",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005404": {
            "entrypoint": "0x00005404",
            "current_name": "write_to_stream_00005404",
            "code": "\nuint writeToStream_00005404(int streamHandle,uint data,int *stream,undefined4 streamingMode)\n\n{\n  int numBytesWritten;\n  uint numElements;\n  undefined *streamData;\n  \n  if ((streamHandle != 0) && (*(int *)(streamHandle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(streamHandle + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(streamHandle + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(streamHandle + 0xc);\n  }\n  stream[2] = stream[6];\n  numElements = (uint)*(ushort *)(stream + 3);\n  numBytesWritten = numElements << 0x1c;\n  if (((numBytesWritten < 0) && (numElements = stream[4], numElements != 0)) ||\n     (numBytesWritten = __swsetup_r(streamHandle,stream,numBytesWritten,numElements,streamingMode), numBytesWritten == 0)) {\n    numBytesWritten = *stream - stream[4];\n    data = data & 0xff;\n    if ((numBytesWritten < stream[5]) || (numBytesWritten = _fflush_r(streamHandle,stream), numBytesWritten == 0)) {\n      stream[2] = stream[2] + -1;\n      streamData = (undefined *)*stream;\n      *stream = (int)(streamData + 1);\n      *streamData = (char)data;\n      if (stream[5] != numBytesWritten + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return data;\n        }\n        if (data != 10) {\n          return data;\n        }\n      }\n      numBytesWritten = _fflush_r(streamHandle,stream);\n      if (numBytesWritten == 0) {\n        return data;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00005404": "write_to_stream_00005404",
                "param_1": "streamHandle",
                "param_2": "data",
                "param_3": "stream",
                "param_4": "streamingMode",
                "iVar1": "numBytesWritten",
                "uVar2": "numElements",
                "puVar3": "streamData"
            },
            "calling": [
                "__sfputc_r",
                "_puts_r",
                "_putc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000054a8": {
            "entrypoint": "0x000054a8",
            "current_name": "process_file_io_000054a8",
            "code": "\nuint processFileIO_000054a8(undefined4 *inputBufferPtr,undefined4 *streamPtr)\n\n{\n  ushort flag;\n  int impurePtr;\n  ushort originalFlag;\n  uint flagValue;\n  uint tempFlagValue;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (streamPtr == &__sf_fake_stdin) {\n    streamPtr = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (streamPtr == (undefined4 *)&__sf_fake_stdout) {\n    streamPtr = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (streamPtr == (undefined4 *)&__sf_fake_stderr) {\n    streamPtr = *(undefined4 **)(impurePtr + 0xc);\n  }\n  flagValue = (uint)*(ushort *)(streamPtr + 3);\n  originalFlag = *(ushort *)(streamPtr + 3);\n  if (-1 < (int)(flagValue << 0x1c)) {\n    if (-1 < (int)(flagValue << 0x1b)) {\n      *inputBufferPtr = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(flagValue << 0x1d) < 0) {\n      if ((undefined4 *)streamPtr[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)streamPtr[0xd] != streamPtr + 0x11) {\n          _free_r(inputBufferPtr);\n        }\n        streamPtr[0xd] = 0;\n      }\n      *(ushort *)(streamPtr + 3) = *(ushort *)(streamPtr + 3) & 0xffdb;\n      streamPtr[1] = 0;\n      *streamPtr = streamPtr[4];\n    }\n    *(ushort *)(streamPtr + 3) = *(ushort *)(streamPtr + 3) | 8;\n  }\n  if ((streamPtr[4] == 0) && ((*(ushort *)(streamPtr + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(inputBufferPtr,streamPtr);\n  }\n  flag = *(ushort *)(streamPtr + 3);\n  flagValue = (uint)flag;\n  originalFlag = *(ushort *)(streamPtr + 3);\n  tempFlagValue = flagValue & 1;\n  if ((flag & 1) == 0) {\n    if (-1 < (int)(flagValue << 0x1e)) {\n      tempFlagValue = streamPtr[5];\n    }\n    streamPtr[2] = tempFlagValue;\n  }\n  else {\n    streamPtr[2] = 0;\n    streamPtr[6] = -streamPtr[5];\n  }\n  if (streamPtr[4] != 0) {\n    return 0;\n  }\n  if ((flag & 0x80) == 0) {\n    return flagValue & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(streamPtr + 3) = originalFlag | 0x40;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000054a8": "process_file_io_000054a8",
                "param_1": "inputBufferPtr",
                "param_2": "streamPtr",
                "uVar1": "flag",
                "iVar2": "impurePtr",
                "uVar3": "originalFlag",
                "uVar4": "flagValue",
                "uVar5": "tempFlagValue"
            },
            "calling": [
                "__swbuf_r",
                "_puts_r",
                "_vfprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005584": {
            "entrypoint": "0x00005584",
            "current_name": "divide_with_remainder_00005584",
            "code": "\ndiv_t divide_with_remainder_00005584(int dividend,int divisor)\n\n{\n  uint remainder;\n  int temp;\n  uint quotient;\n  div_t result;\n  \n  quotient = (uint)divisor / remainder;\n  temp = divisor - remainder * quotient;\n  if (divisor < 0) {\n    if (0 < temp) {\n      quotient = quotient - 1;\n      temp = temp + remainder;\n    }\n  }\n  else if (temp < 0) {\n    quotient = quotient + 1;\n    temp = temp - remainder;\n  }\n  *(uint *)dividend = quotient;\n  *(int *)(dividend + 4) = temp;\n  result.rem = divisor;\n  result.quot = dividend;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005584": "divide_with_remainder_00005584",
                "__numer": "dividend",
                "__denom": "divisor",
                "in_r2": "remainder",
                "iVar1": "temp",
                "uVar2": "quotient",
                "dVar3": "result"
            },
            "calling": [
                "validate_structure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000055ac": {
            "entrypoint": "0x000055ac",
            "current_name": "read_from_stream_000055ac",
            "code": "\nuint readFromStream_000055ac(int streamPointer,byte **stream)\n\n{\n  uint returnValue;\n  byte *streamBuffer;\n  \n  if ((streamPointer != 0) && (*(int *)(streamPointer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (byte **)&__sf_fake_stdin) {\n    stream = *(byte ***)(streamPointer + 4);\n  }\n  else if (stream == (byte **)&__sf_fake_stdout) {\n    stream = *(byte ***)(streamPointer + 8);\n  }\n  else if (stream == (byte **)&__sf_fake_stderr) {\n    stream = *(byte ***)(streamPointer + 0xc);\n  }\n  if ((-1 < (int)stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  streamBuffer = stream[1];\n  stream[1] = streamBuffer + -1;\n  if ((int)(streamBuffer + -1) < 0) {\n    returnValue = __srget_r(streamPointer,stream);\n  }\n  else {\n    streamBuffer = *stream;\n    *stream = streamBuffer + 1;\n    returnValue = (uint)*streamBuffer;\n  }\n  if ((-1 < (int)stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream[0x16]);\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000055ac": "read_from_stream_000055ac",
                "param_1": "streamPointer",
                "param_2": "stream",
                "uVar1": "returnValue",
                "pbVar2": "streamBuffer"
            },
            "calling": [
                "getchar"
            ],
            "called": [
                "__sinit",
                "__srget_r",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000562c": {
            "entrypoint": "0x0000562c",
            "current_name": "find_environment_variable_0000562c",
            "code": "\nchar * findEnvironmentVariable_0000562c(undefined4 lock,char *variableName,int *result)\n\n{\n  char currentChar;\n  char **envArray;\n  int comparisonResult;\n  char *currentEnv;\n  char **currentEnvPtr;\n  size_t variableLength;\n  \n  __env_lock();\n  currentEnv = variableName;\n  if (environ != (char **)0x0) {\n    do {\n      currentChar = *currentEnv;\n      if (currentChar == '\\0') {\n        variableLength = (int)currentEnv - (int)variableName;\n        envArray = environ;\n        while( true ) {\n          currentEnvPtr = envArray;\n          if (*currentEnvPtr == (char *)0x0) break;\n          comparisonResult = strncmp(*currentEnvPtr,variableName,variableLength);\n          envArray = currentEnvPtr + 1;\n          if ((comparisonResult == 0) && (currentEnv = *currentEnvPtr, currentEnv[variableLength] == '=')) {\n            *result = (int)currentEnvPtr - (int)environ >> 2;\n            __env_unlock(lock);\n            return currentEnv + variableLength + 1;\n          }\n        }\n        break;\n      }\n      currentEnv = currentEnv + 1;\n    } while (currentChar != '=');\n  }\n  __env_unlock(lock);\n  return (char *)0x0;\n}\n\n",
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "lock",
                "param_2": "variableName",
                "param_3": "result",
                "cVar1": "currentChar",
                "ppcVar2": "envArray",
                "iVar3": "comparisonResult",
                "pcVar4": "currentEnv",
                "ppcVar5": "currentEnvPtr",
                "__n": "variableLength"
            },
            "calling": [
                "_getenv_r"
            ],
            "called": [
                "__env_lock",
                "__env_unlock",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056a0": {
            "entrypoint": "0x000056a0",
            "current_name": "find_environment_000056a0",
            "code": "\nvoid find_environment_000056a0(undefined4 env_value,undefined4 env_start,undefined4 locale,undefined4 env_buffer)\n\n{\n  undefined4 new_env_start;\n  undefined4 new_locale;\n  \n  new_env_start = env_start;\n  new_locale = locale;\n  _findenv_r(env_value,env_start,&new_env_start,env_buffer,env_value);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000056a0": "find_environment_000056a0",
                "param_1": "env_value",
                "param_2": "env_start",
                "param_3": "locale",
                "param_4": "env_buffer",
                "uStack_c": "new_env_start",
                "uStack_8": "new_locale"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_findenv_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b0": {
            "entrypoint": "0x000056b0",
            "current_name": "get_timezone_info_000056b0",
            "code": "\nundefined1 * get_timezone_info_000056b0(void)\n\n{\n  return timezone_info;\n}\n\n",
            "renaming": {
                "FUN_000056b0": "get_timezone_info_000056b0",
                "&tzinfo": "timezone_info"
            },
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b8": {
            "entrypoint": "0x000056b8",
            "current_name": "get_file_permission_000056b8",
            "code": "\nundefined4 getFilePermission_000056b8(_reent *reentPtr,int filePathPtr,undefined4 *permissionPtr,uint *isExecutablePtr)\n\n{\n  int status;\n  undefined4 permission;\n  stat fileStats;\n  \n  if ((*(short *)(filePathPtr + 0xe) < 0) ||\n     (status = _fstat_r(reentPtr,(int)*(short *)(filePathPtr + 0xe),&fileStats), status < 0)) {\n    *isExecutablePtr = 0;\n    if ((int)((uint)*(ushort *)(filePathPtr + 0xc) << 0x18) < 0) {\n      permission = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *isExecutablePtr = (uint)((fileStats.st_mode & 0xf000) == 0x2000);\n  }\n  permission = 0x400;\nLAB_000056f8:\n  *permissionPtr = permission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000056b8": "get_file_permission_000056b8",
                "param_1": "reentPtr",
                "param_2": "filePathPtr",
                "param_3": "permissionPtr",
                "param_4": "isExecutablePtr",
                "iVar1": "status",
                "uVar2": "permission",
                "sStack_68": "fileStats"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005700": {
            "entrypoint": "0x00005700",
            "current_name": "initialize_file_00005700",
            "code": "\nvoid initializeFile_00005700(_reent *reentrantStruct,int *fileDescriptor)\n\n{\n  ushort bufferStatus;\n  int allocatedMemory;\n  _reent *localReentrantStruct;\n  int *localFileDescriptor;\n  \n  if (-1 < (int)((uint)*(ushort *)(fileDescriptor + 3) << 0x1e)) {\n    localReentrantStruct = reentrantStruct;\n    localFileDescriptor = fileDescriptor;\n    bufferStatus = __swhatbuf_r(reentrantStruct,fileDescriptor,&localReentrantStruct,&localFileDescriptor);\n    allocatedMemory = _malloc_r(reentrantStruct,localReentrantStruct);\n    if (allocatedMemory != 0) {\n      reentrantStruct->__cleanup = _cleanup_r + 1;\n      *fileDescriptor = allocatedMemory;\n      *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) | 0x80;\n      fileDescriptor[5] = (int)localReentrantStruct;\n      fileDescriptor[4] = allocatedMemory;\n      if ((localFileDescriptor != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(reentrantStruct,(int)*(short *)((int)fileDescriptor + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(fileDescriptor + 3) = bufferStatus | *(ushort *)(fileDescriptor + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(fileDescriptor + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xfffc | 2;\n  }\n  *fileDescriptor = (int)fileDescriptor + 0x47;\n  fileDescriptor[4] = (int)fileDescriptor + 0x47;\n  fileDescriptor[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005700": "initialize_file_00005700",
                "param_1": "reentrantStruct",
                "param_2": "fileDescriptor",
                "uVar1": "bufferStatus",
                "iVar2": "allocatedMemory",
                "local_18": "localReentrantStruct",
                "local_14": "localFileDescriptor"
            },
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005780": {
            "entrypoint": "0x00005780",
            "current_name": "free_memory_00005780",
            "code": "\nvoid freeMemory_00005780(void *memoryPointer)\n\n{\n  _free_r(_impure_ptr,memoryPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005780": "free_memory_00005780",
                "__ptr": "memoryPointer"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005790": {
            "entrypoint": "0x00005790",
            "current_name": "acquire_malloc_recursive_mutex_00005790",
            "code": "\nvoid acquireMallocRecursiveMutex_00005790(void)\n\n{\n  __retarget_lock_acquire_recursive(&mallocRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005790": "acquire_malloc_recursive_mutex_00005790",
                "__lock___malloc_recursive_mutex": "mallocRecursiveMutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000579c": {
            "entrypoint": "0x0000579c",
            "current_name": "release_malloc_recursive_lock_0000579c",
            "code": "\nvoid releaseMallocRecursiveLock_0000579c(void)\n\n{\n  retargetLockReleaseRecursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000579c": "release_malloc_recursive_lock_0000579c",
                "__lock___malloc_recursive_mutex": "lock",
                "__retarget_lock_release_recursive": "retargetLockReleaseRecursive"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057a8": {
            "entrypoint": "0x000057a8",
            "current_name": "write_character_000057a8",
            "code": "\nint write_character_000057a8(undefined4 param1,int character,undefined4 *buffer)\n\n{\n  int remaining_chars;\n  undefined *next_position;\n  \n  remaining_chars = buffer[2] + -1;\n  buffer[2] = remaining_chars;\n  if ((remaining_chars < 0) && ((remaining_chars < (int)buffer[6] || (character == 10)))) {\n    remaining_chars = __swbuf_r();\n    return remaining_chars;\n  }\n  next_position = (undefined *)*buffer;\n  *buffer = next_position + 1;\n  *next_position = (char)character;\n  return character;\n}\n\n",
            "renaming": {
                "FUN_000057a8": "write_character_000057a8",
                "param_1": "param1",
                "param_2": "character",
                "param_3": "buffer",
                "iVar1": "remaining_chars",
                "puVar2": "next_position"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057d2": {
            "entrypoint": "0x000057d2",
            "current_name": "write_to_file_000057d2",
            "code": "\nint writeToFile_000057d2(undefined4 file,undefined4 stream,undefined *data,int length)\n\n{\n  int result;\n  undefined *endPtr;\n  int remainingLength;\n  \n  endPtr = data + length;\n  remainingLength = length;\n  do {\n    if (data == endPtr) {\n      return 0;\n    }\n    result = __sfputc_r(file,*data,stream,length,remainingLength);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000057d2": "write_to_file_000057d2",
                "param_1": "file",
                "param_2": "stream",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "endPtr",
                "iVar3": "remainingLength"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057f8": {
            "entrypoint": "0x000057f8",
            "current_name": "print_formatted_string_000057f8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint printFormattedString_000057f8(int stream,undefined4 *format,byte *str,int *args)\n\n{\n  bool bVar1;\n  int totalBytesWritten;\n  int bytesWritten;\n  void *formatSpecifier;\n  int *argPointer;\n  byte *currentChar;\n  int retargetLock;\n  byte *strPointer;\n  int *argPointerArr;\n  uint flags;\n  int precision;\n  undefined4 paddingChar;\n  int numberOfArguments;\n  int bytesWrittenTotal;\n  byte specifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined zeroFlag;\n  undefined4 prefixLength;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __initialize();\n  }\n  if (format == &__stdin) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&__stdout) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&__stderr) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if ((-1 < (int)(format[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(format + 3) << 0x16))) {\n    __acquireRecursiveLock(format[0x16]);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (totalBytesWritten = __setupStream(stream,format), totalBytesWritten != 0)) {\n    if ((-1 < (int)(format[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(format + 3) << 0x16)))\n    {\n      __retarget_lock_release_recursive(format[0x16]);\n    }\n    return -1;\n  }\n  bytesWrittenTotal = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  strPointer = str;\n  argPointerArr = args;\nLAB_0000588e:\n  currentChar = strPointer;\n  if (*currentChar != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  strPointer = currentChar + 1;\n  if (*currentChar == 0x25) {\nLAB_0000589a:\n    totalBytesWritten = (int)currentChar - (int)str;\n    if (totalBytesWritten != 0) {\n      bytesWritten = __writeString(stream,format,str,totalBytesWritten);\n      if (bytesWritten == -1) {\nLAB_00005a06:\n        if ((-1 < (int)(format[0x19] << 0x1f)) &&\n           (-1 < (int)((uint)*(ushort *)(format + 3) << 0x16))) {\n          __retarget_lock_release_recursive(format[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n          return -1;\n        }\n        return bytesWrittenTotal;\n      }\n      bytesWrittenTotal = bytesWrittenTotal + totalBytesWritten;\n    }\n    if (*currentChar == 0) goto LAB_00005a06;\n    precision = -1;\n    paddingChar = 0;\n    flags = 0;\n    numberOfArguments = 0;\n    zeroFlag = 0;\n    prefixLength = 0;\n    strPointer = currentChar + 1;\n    while( true ) {\n      currentChar = strPointer + 1;\n      formatSpecifier = findChar(\"flagsChars \",(uint)*strPointer,5);\n      if (formatSpecifier == (void *)0x0) break;\n      flags = 1 << ((int)formatSpecifier - flagsCharsOffset1 & 0xff) | flags;\n      strPointer = currentChar;\n    }\n    if ((int)(flags << 0x1b) < 0) {\n      zeroFlag = 0x20;\n    }\n    if ((int)(flags << 0x1c) < 0) {\n      zeroFlag = 0x2b;\n    }\n    if (*strPointer == 0x2a) {\n      argPointer = argPointerArr + 1;\n      numberOfArguments = *argPointerArr;\n      argPointerArr = argPointer;\n      if (numberOfArguments < 0) {\n        numberOfArguments = -numberOfArguments;\n        flags = flags | 2;\n      }\n    }\n    else {\n      bVar1 = false;\n      totalBytesWritten = numberOfArguments;\n      currentChar = strPointer;\n      while( true ) {\n        if (9 < *currentChar - 0x30) break;\n        totalBytesWritten = totalBytesWritten * 10 + (*currentChar - 0x30);\n        bVar1 = true;\n        currentChar = currentChar + 1;\n      }\n      if (bVar1) {\n        numberOfArguments = totalBytesWritten;\n      }\n    }\n    if (*currentChar == 0x2e) {\n      if (currentChar[1] == 0x2a) {\n        precision = *argPointerArr;\n        if (precision < 0) {\n          precision = -1;\n        }\n        currentChar = currentChar + 2;\n        argPointerArr = argPointerArr + 1;\n      }\n      else {\n        bVar1 = false;\n        precision = 0;\n        totalBytesWritten = 0;\n        while( true ) {\n          currentChar = currentChar + 1;\n          if (9 < *currentChar - 0x30) break;\n          totalBytesWritten = totalBytesWritten * 10 + (*currentChar - 0x30);\n          bVar1 = true;\n        }\n        if (bVar1) {\n          precision = totalBytesWritten;\n        }\n      }\n    }\n    formatSpecifier = findChar(&DAT_00007c02,(uint)*currentChar,3);\n    if (formatSpecifier != (void *)0x0) {\n      flags = flags | 0x40 << ((int)formatSpecifier - specifierCharsOffset1 & 0xff);\n      currentChar = currentChar + 1;\n    }\n    str = currentChar + 1;\n    specifier = *currentChar;\n    formatSpecifier = findChar(\"efgEFG\",(uint)specifier,6);\n    if (formatSpecifier == (void *)0x0) {\n      retargetLock = _printInteger(stream,&flags,format,0x57d3,&argPointerArr);\n      if (retargetLock == -1) goto LAB_00005a06;\n    }\n    else {\n      argPointerArr = (int *)(((int)argPointerArr + 7U & 0xfffffff8) + 8);\n    }\n    bytesWrittenTotal = bytesWrittenTotal + retargetLock;\n    strPointer = str;\n  }\n  goto LAB_0000588e;\n}\n\n",
            "renaming": {
                "FUN_000057f8": "print_formatted_string_000057f8",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "str",
                "param_4": "args",
                "iVar2": "totalBytesWritten",
                "iVar3": "bytesWritten",
                "pvVar4": "formatSpecifier",
                "piVar5": "argPointer",
                "pbVar6": "currentChar",
                "unaff_r7": "retargetLock",
                "pbVar7": "strPointer",
                "local_8c": "argPointerArr",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "paddingChar",
                "local_7c": "numberOfArguments",
                "local_74": "bytesWrittenTotal",
                "local_70": "specifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "zeroFlag",
                "local_30": "prefixLength",
                "__sf_fake_stdin": "__stdin",
                "__sf_fake_stdout": "__stdout",
                "__sf_fake_stderr": "__stderr",
                "__sinit": "__initialize",
                "__retarget_lock_acquire_recursive": "__acquireRecursiveLock",
                "__swsetup_r": "__setupStream",
                "__sfputs_r": "__writeString",
                "_printf_i": "_printInteger",
                "#-0+": "flagsChars",
                "memchr": "findChar",
                "0x7bfcU": "flagsCharsOffset1",
                "0x7c02U": "specifierCharsOffset1"
            },
            "calling": [
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sfputs_r",
                "__retarget_lock_release_recursive",
                "memchr",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005a58": {
            "entrypoint": "0x00005a58",
            "current_name": "calculate_output_length_00005a58",
            "code": "\nundefined4\ncalculateOutputLength_00005a58(undefined4 input,uint *data,uint *outputSize,undefined4 param4,code *callback)\n\n{\n  int index;\n  undefined4 result;\n  int returnValue;\n  uint maxSize;\n  uint counter;\n  bool isConditionTrue;\n  \n  maxSize = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxSize = data[2];\n  }\n  *outputSize = maxSize;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *outputSize = maxSize + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index = 0; index < (int)(data[3] - *outputSize); index = index + 1) {\n      returnValue = (*callback)(input,param4,(int)data + 0x19,1);\n      if (returnValue == -1) goto LAB_00005afc;\n    }\n  }\n  maxSize = (uint)*(byte *)((int)data + 0x43);\n  if (maxSize != 0) {\n    maxSize = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxSize + 0x43) = 0x30;\n    *(undefined *)((int)data + maxSize + 0x44) = *(undefined *)((int)data + 0x45);\n    maxSize = maxSize + 2;\n  }\n  index = (*callback)(input,param4,(int)data + 0x43,maxSize);\n  if (index == -1) {\nLAB_00005afc:\n    result = 0xffffffff;\n  }\n  else {\n    maxSize = data[3];\n    isConditionTrue = (*data & 6) == 4;\n    if (isConditionTrue) {\n      maxSize = maxSize - *outputSize;\n    }\n    if (isConditionTrue) {\n      maxSize = maxSize & ~((int)maxSize >> 0x1f);\n    }\n    else {\n      maxSize = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxSize = maxSize + (data[2] - data[4]);\n    }\n    for (counter = 0; maxSize != counter; counter = counter + 1) {\n      index = (*callback)(input,param4,(int)data + 0x1a,1);\n      if (index == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005a58": "calculate_output_length_00005a58",
                "param_1": "input",
                "param_2": "data",
                "param_3": "outputSize",
                "param_4": "param4",
                "param_5": "callback",
                "iVar1": "index",
                "uVar2": "result",
                "iVar3": "returnValue",
                "uVar4": "maxSize",
                "uVar5": "counter",
                "bVar6": "isConditionTrue"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005b34": {
            "entrypoint": "0x00005b34",
            "current_name": "print_formatted_output_00005b34",
            "code": "\ncode * printFormattedOutput_00005b34(undefined4 formatSpec,uint *argList,undefined4 outputFunc,code *argListCopy,uint **argPtr\n                   )\n\n{\n  bool isBaseGreater;\n  byte base;\n  int result;\n  code *output;\n  char *digitSet;\n  void *foundNull;\n  int charCount;\n  char *outputString;\n  uint value;\n  uint *bufPtr;\n  uint numBase;\n  uint **ppArgPtr;\n  char **ppcStrPtr;\n  uint strLength;\n  char *strPtr;\n  uint *puVar15;\n  undefined4 argIndex;\n  code *defaultOutputFunc;\n  \n  base = *(byte *)(argList + 6);\n  outputString = (char *)((int)argList + 0x43);\n  puVar15 = argList;\n  argIndex = outputFunc;\n  defaultOutputFunc = argListCopy;\n  if (0x78 < base) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)argList + 0x42) = base;\nLAB_00005bdc:\n    outputString = (char *)((int)argList + 0x42);\n    value = 1;\nLAB_00005d28:\n    argList[4] = value;\n    *(undefined *)((int)argList + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (base < 99) {\n    if (base == 0) goto LAB_00005d06;\n    if (base == 0x58) {\n      digitSet = \"0123456789ABCDEF\";\n      *(undefined *)((int)argList + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(base) {\n  case 99:\n    value = **argPtr;\n    *argPtr = *argPtr + 1;\n    *(char *)((int)argList + 0x42) = (char)value;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    numBase = *argList;\n    bufPtr = *argPtr;\n    if ((int)(numBase << 0x18) < 0) {\n      value = *bufPtr;\n      *argPtr = bufPtr + 1;\n    }\n    else {\n      value = *bufPtr;\n      *argPtr = bufPtr + 1;\n      if ((numBase & 0x40) != 0) {\n        value = (uint)(short)value;\n      }\n    }\n    if ((int)value < 0) {\n      value = -value;\n      *(undefined *)((int)argList + 0x43) = 0x2d;\n    }\n    digitSet = \"0123456789ABCDEF\";\n    numBase = 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppArgPtr = (uint **)*argPtr;\n    numBase = *argList;\n    value = argList[5];\n    *argPtr = (uint *)(ppArgPtr + 1);\n    bufPtr = *ppArgPtr;\n    if (((int)(numBase << 0x18) < 0) || (-1 < (int)(numBase << 0x19))) {\n      *bufPtr = value;\n    }\n    else {\n      *(short *)bufPtr = (short)value;\n    }\nLAB_00005d06:\n    argList[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    bufPtr = *argPtr;\n    value = *argList;\n    *argPtr = bufPtr + 1;\n    if (((int)(value << 0x18) < 0) || (-1 < (int)(value << 0x19))) {\n      value = *bufPtr;\n    }\n    else {\n      value = (uint)*(ushort *)bufPtr;\n    }\n    digitSet = \"0123456789ABCDEF\";\n    if (base == 0x6f) {\n      numBase = 8;\n    }\n    else {\n      numBase = 10;\n    }\n    break;\n  case 0x70:\n    *argList = *argList | 0x20;\n  case 0x78:\n    digitSet = \"0123456789abcdef\";\n    *(undefined *)((int)argList + 0x45) = 0x78;\nLAB_00005ca8:\n    numBase = *argList;\n    value = **argPtr;\n    *argPtr = *argPtr + 1;\n    if ((-1 < (int)(numBase << 0x18)) && ((int)(numBase << 0x19) < 0)) {\n      value = value & 0xffff;\n    }\n    if ((int)(numBase << 0x1f) < 0) {\n      *argList = numBase | 0x20;\n    }\n    if (value == 0) {\n      *argList = *argList & 0xffffffdf;\n    }\n    numBase = 0x10;\n    break;\n  case 0x73:\n    ppcStrPtr = (char **)*argPtr;\n    *argPtr = (uint *)(ppcStrPtr + 1);\n    outputString = *ppcStrPtr;\n    foundNull = memchr(outputString,0,argList[1]);\n    if (foundNull != (void *)0x0) {\n      argList[1] = (int)foundNull - (int)outputString;\n    }\n    value = argList[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)argList + 0x43) = 0;\nLAB_00005c36:\n  strLength = argList[1];\n  argList[2] = strLength;\n  if (-1 < (int)strLength) {\n    *argList = *argList & 0xfffffffb;\n  }\n  strPtr = outputString;\n  if ((value != 0) || (strLength != 0)) {\n    do {\n      strPtr = strPtr + -1;\n      *strPtr = digitSet[value - numBase * (value / numBase)];\n      isBaseGreater = numBase <= value;\n      value = value / numBase;\n    } while (isBaseGreater);\n  }\n  if (((numBase == 8) && ((int)(*argList << 0x1f) < 0)) && ((int)argList[1] <= (int)argList[4])) {\n    strPtr[-1] = '0';\n    strPtr = strPtr + -1;\n  }\n  argList[4] = (int)outputString - (int)strPtr;\n  outputString = strPtr;\nLAB_00005c84:\n  result = _printf_common(formatSpec,argList,&defaultOutputFunc,outputFunc,argListCopy,puVar15,argIndex);\n  if ((result == -1) || (result = (*argListCopy)(formatSpec,outputFunc,outputString,argList[4]), result == -1)) {\nLAB_00005c98:\n    output = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*argList << 0x1e) < 0) {\n      for (result = 0; result < (int)(argList[3] - (int)defaultOutputFunc); result = result + 1) {\n        charCount = (*argListCopy)(formatSpec,outputFunc,(int)argList + 0x19,1);\n        if (charCount == -1) goto LAB_00005c98;\n      }\n    }\n    output = (code *)argList[3];\n    if ((int)(code *)argList[3] < (int)defaultOutputFunc) {\n      output = defaultOutputFunc;\n    }\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_00005b34": "print_formatted_output_00005b34",
                "param_1": "formatSpec",
                "param_2": "argList",
                "param_3": "outputFunc",
                "param_4": "argListCopy",
                "param_5": "argPtr",
                "bVar1": "isBaseGreater",
                "bVar2": "base",
                "iVar3": "result",
                "pcVar4": "output",
                "pcVar5": "digitSet",
                "pcVar14": "strPtr",
                "pvVar6": "foundNull",
                "iVar7": "charCount",
                "__s": "outputString",
                "uVar8": "value",
                "puVar9": "bufPtr",
                "uVar10": "numBase",
                "uVar13": "strLength",
                "ppuVar11": "ppArgPtr",
                "ppcVar12": "ppcStrPtr",
                "uVar16": "argIndex",
                "local_24": "defaultOutputFunc"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005d80": {
            "entrypoint": "0x00005d80",
            "current_name": "write_to_stream_00005d80",
            "code": "\nuint write_to_stream_00005d80(int stream,uint data,undefined4 *stream_data)\n\n{\n  int remaining;\n  undefined *stream_ptr;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_data == &__sf_fake_stdin) {\n    stream_data = *(undefined4 **)(stream + 4);\n  }\n  else if (stream_data == (undefined4 *)&__sf_fake_stdout) {\n    stream_data = *(undefined4 **)(stream + 8);\n  }\n  else if (stream_data == (undefined4 *)&__sf_fake_stderr) {\n    stream_data = *(undefined4 **)(stream + 0xc);\n  }\n  if ((-1 < (int)(stream_data[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream_data + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream_data[0x16]);\n  }\n  remaining = stream_data[2] + -1;\n  stream_data[2] = remaining;\n  if ((remaining < 0) && ((remaining < (int)stream_data[6] || ((data & 0xff) == 10)))) {\n    data = __swbuf_r(stream,data,stream_data);\n  }\n  else {\n    stream_ptr = (undefined *)*stream_data;\n    *stream_data = stream_ptr + 1;\n    *stream_ptr = (char)data;\n    data = data & 0xff;\n  }\n  if ((-1 < (int)(stream_data[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream_data + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream_data[0x16]);\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_00005d80": "write_to_stream_00005d80",
                "param_1": "stream",
                "param_2": "data",
                "param_3": "stream_data",
                "iVar1": "remaining",
                "puVar2": "stream_ptr"
            },
            "calling": [
                "putchar"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e10": {
            "entrypoint": "0x00005e10",
            "current_name": "read_byte_00005e10",
            "code": "\nuint readByte_00005e10(int ptr_1,byte **ptr_2)\n\n{\n  int result;\n  uint byteValue;\n  byte *bytePtr;\n  \n  if ((ptr_1 != 0) && (*(int *)(ptr_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (ptr_2 == (byte **)&__sf_fake_stdin) {\n    ptr_2 = *(byte ***)(ptr_1 + 4);\n  }\n  else if (ptr_2 == (byte **)&__sf_fake_stdout) {\n    ptr_2 = *(byte ***)(ptr_1 + 8);\n  }\n  else if (ptr_2 == (byte **)&__sf_fake_stderr) {\n    ptr_2 = *(byte ***)(ptr_1 + 0xc);\n  }\n  result = __srefill_r(ptr_1,ptr_2);\n  if (result == 0) {\n    ptr_2[1] = ptr_2[1] + -1;\n    bytePtr = *ptr_2;\n    *ptr_2 = bytePtr + 1;\n    byteValue = (uint)*bytePtr;\n  }\n  else {\n    byteValue = 0xffffffff;\n  }\n  return byteValue;\n}\n\n",
            "renaming": {
                "FUN_00005e10": "read_byte_00005e10",
                "param_1": "ptr_1",
                "param_2": "ptr_2",
                "iVar1": "result",
                "uVar2": "byteValue",
                "pbVar3": "bytePtr"
            },
            "calling": [
                "_getc_r"
            ],
            "called": [
                "__sinit",
                "__srefill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e68": {
            "entrypoint": "0x00005e68",
            "current_name": "scan_format_string_00005e68",
            "code": "\nint scanFormatString_00005e68(char *buffer,char *formatString,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *bufferCopy;\n  size_t bufferLength;\n  undefined2 bufferCapacity;\n  undefined2 initialValue;\n  char *formattedBuffer;\n  size_t formattedBufferLength;\n  undefined4 randomValue1;\n  undefined4 randomValue2;\n  undefined4 randomValue3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  bufferCapacity = 0x204;\n  bufferCopy = buffer;\n  formattedBuffer = buffer;\n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  bufferLength = strlen(buffer);\n  randomValue1 = 0x4deb;\n  randomValue2 = 0;\n  randomValue3 = 0;\n  initialValue = 0xffff;\n  formattedBufferLength = bufferLength;\n  iVar1 = buffersvfiscanf_r(_impure_ptr,&bufferCopy,formatString,&uStack_8);\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00005e68": "scan_format_string_00005e68",
                "__s": "buffer",
                "__format": "formatString",
                "local_80": "bufferCopy",
                "local_7c": "bufferLength",
                "local_74": "bufferCapacity",
                "local_72": "initialValue",
                "local_70": "formattedBuffer",
                "local_6c": "formattedBufferLength",
                "local_5c": "randomValue1",
                "local_4c": "randomValue2",
                "local_38": "randomValue3"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ebc": {
            "entrypoint": "0x00005ebc",
            "current_name": "copy_string_00005ebc",
            "code": "\nchar * copyString_00005ebc(char *destination,char *source)\n\n{\n  char currentChar;\n  char *destinationPointer;\n  \n  destinationPointer = destination;\n  do {\n    currentChar = *source;\n    *destinationPointer = currentChar;\n    source = source + 1;\n    destinationPointer = destinationPointer + 1;\n  } while (currentChar != '\\0');\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentChar",
                "pcVar2": "destinationPointer"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ecc": {
            "entrypoint": "0x00005ecc",
            "current_name": "calculate_string_length_00005ecc",
            "code": "\nsize_t calculateStringLength_00005ecc(char *str)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = str;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_00005ecc": "calculate_string_length_00005ecc",
                "__s": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPointer",
                "pcVar3": "currentCharPointer"
            },
            "calling": [
                "siscanf",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005edc": {
            "entrypoint": "0x00005edc",
            "current_name": "parse_number_00005edc",
            "code": "\nuint parseNumber_00005edc(undefined4 *result,byte *input,byte **remaining,uint base)\n\n{\n  uint parsedNumber;\n  uint currentChar;\n  byte isNegative;\n  int status;\n  uint digitValue;\n  uint maxValue;\n  byte *currentByte;\n  byte *nextByte;\n  \n  nextByte = input;\n  do {\n    currentByte = nextByte;\n    nextByte = currentByte + 1;\n    currentChar = (uint)*currentByte;\n    isNegative = (&DAT_00007a99)[currentChar] & 8;\n  } while (((&DAT_00007a99)[currentChar] & 8) != 0);\n  if (currentChar == 0x2d) {\n    currentChar = (uint)*nextByte;\n    isNegative = 1;\n    nextByte = currentByte + 2;\n  }\n  else if (currentChar == 0x2b) {\n    currentChar = (uint)*nextByte;\n    nextByte = currentByte + 2;\n  }\n  if (base == 0) {\n    if (currentChar != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((base != 0x10) || (currentChar != 0x30)) goto LAB_00005f26;\n  if ((*nextByte & 0xdf) == 0x58) {\n    currentChar = (uint)nextByte[1];\n    base = 0x10;\n    nextByte = nextByte + 2;\n  }\n  else {\n    currentChar = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  status = 0;\n  maxValue = 0xffffffff / base;\n  parsedNumber = 0;\n  do {\n    digitValue = currentChar - 0x30;\n    if (9 < digitValue) {\n      if (currentChar - 0x41 < 0x1a) {\n        digitValue = currentChar - 0x37;\n      }\n      else {\n        if (0x19 < currentChar - 0x61) break;\n        digitValue = currentChar - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (((status < 0) || (maxValue < parsedNumber)) ||\n       ((maxValue == parsedNumber && ((int)~(base * maxValue) < (int)digitValue)))) {\n      status = -1;\n    }\n    else {\n      parsedNumber = parsedNumber * base + digitValue;\n      status = 1;\n    }\n    currentChar = (uint)*nextByte;\n    nextByte = nextByte + 1;\n  } while( true );\n  if (status < 0) {\n    *result = 0x22;\n    parsedNumber = 0xffffffff;\n    if (remaining == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      parsedNumber = -parsedNumber;\n    }\n    if (remaining == (byte **)0x0) {\n      return parsedNumber;\n    }\n    if (status == 0) goto LAB_00005fb8;\n  }\n  input = nextByte + -1;\nLAB_00005fb8:\n  *remaining = input;\n  return parsedNumber;\n}\n\n",
            "renaming": {
                "FUN_00005edc": "parse_number_00005edc",
                "param_1": "result",
                "param_2": "input",
                "param_3": "remaining",
                "param_4": "base",
                "uVar1": "parsedNumber",
                "uVar2": "currentChar",
                "bVar3": "isNegative",
                "iVar4": "status",
                "uVar5": "digitValue",
                "uVar6": "maxValue",
                "pbVar7": "currentByte",
                "pbVar8": "nextByte"
            },
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd4": {
            "entrypoint": "0x00005fd4",
            "current_name": "FUN_00005fd4",
            "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = (&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd8": {
            "entrypoint": "0x00005fd8",
            "current_name": "convert_string_to_unsigned_long_00005fd8",
            "code": "\nulong convertStringToUnsignedLong_00005fd8(char *inputString,char **endOfParsing,int numberBase)\n\n{\n  ulong result;\n  \n  result = _strtoul_l_isra_0(_impure_ptr,inputString,endOfParsing,numberBase);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005fd8": "convert_string_to_unsigned_long_00005fd8",
                "__nptr": "inputString",
                "__endptr": "endOfParsing",
                "__base": "numberBase",
                "uVar1": "result"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fec": {
            "entrypoint": "0x00005fec",
            "current_name": "acquire_recursive_lock_00005fec",
            "code": "\nvoid acquireRecursiveLock_00005fec(void)\n\n{\n  acquireRecursiveLock_00005fec(&envRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "__retarget_lock_acquire_recursive": "acquireRecursiveLock",
                "__lock___env_recursive_mutex": "envRecursiveMutex"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ff8": {
            "entrypoint": "0x00005ff8",
            "current_name": "release_recursive_lock_00005ff8",
            "code": "\nvoid releaseRecursiveLock_00005ff8(void)\n\n{\n  releaseRecursiveLock_00005ff8Helper(&__lock___env_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ff8": "release_recursive_lock_00005ff8",
                "__retarget_lock_release_recursive": "releaseRecursiveLockHelper"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006010": {
            "entrypoint": "0x00006010",
            "current_name": "find_byte_in_memory_00006010",
            "code": "\nvoid * find_byte_in_memory_00006010(void *memory_address,int byte_to_find,size_t memory_length)\n\n{\n  byte current_byte;\n  char is_zero;\n  char is_zero_8;\n  char is_zero_16;\n  char is_zero_24;\n  byte *next_byte_ptr;\n  uint *current_ptr;\n  byte *result_ptr;\n  uint byte_to_find_masked;\n  uint ptr_alignment;\n  uint memory_length_aligned;\n  uint xor_result_1;\n  uint xor_result_2;\n  bool is_nonzero_8;\n  bool is_nonzero_16;\n  bool is_nonzero_24;\n  bool is_nonzero_32;\n  \n  byte_to_find_masked = byte_to_find & 0xff;\n  if ((int)memory_length < 0x10) {\njoined_r0x00006070:\n    do {\n      if (memory_length == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      current_ptr = (uint *)((int)memory_address + 1);\n      current_byte = *memory_address;\n      memory_length = memory_length - 1;\n      memory_address = current_ptr;\n    } while (current_byte != byte_to_find_masked);\n  }\n  else {\n    ptr_alignment = (uint)memory_address & 7;\n    while( true ) {\n      if (ptr_alignment == 0) {\n        ptr_alignment = byte_to_find_masked | byte_to_find_masked << 8;\n        ptr_alignment = ptr_alignment | ptr_alignment << 0x10;\n        memory_length_aligned = memory_length & 0xfffffff8;\n        do {\n          current_ptr = (uint *)((int)memory_address + 8);\n                    /* WARNING: Load size is inaccurate */\n          memory_length_aligned = memory_length_aligned - 8;\n          xor_result_1 = *memory_address ^ ptr_alignment;\n          xor_result_2 = *(uint *)((int)memory_address + 4) ^ ptr_alignment;\n          is_zero = -((char)xor_result_1 == '\\0');\n          is_zero_8 = -((char)(xor_result_1 >> 8) == '\\0');\n          is_zero_16 = -((char)(xor_result_1 >> 0x10) == '\\0');\n          is_zero_24 = -((char)(xor_result_1 >> 0x18) == '\\0');\n          xor_result_1 = CONCAT13(is_zero_24,CONCAT12(is_zero_16,CONCAT11(is_zero_8,is_zero)));\n          is_nonzero_8 = (char)xor_result_2 != '\\0';\n          is_nonzero_16 = (char)(xor_result_2 >> 8) != '\\0';\n          is_nonzero_24 = (char)(xor_result_2 >> 0x10) != '\\0';\n          is_nonzero_32 = (char)(xor_result_2 >> 0x18) != '\\0';\n          xor_result_2 = CONCAT13(is_nonzero_32 * is_zero_24 - !is_nonzero_32,\n                            CONCAT12(is_nonzero_24 * is_zero_16 - !is_nonzero_24,\n                                     CONCAT11(is_nonzero_16 * is_zero_8 - !is_nonzero_16,is_nonzero_8 * is_zero - !is_nonzero_8)));\n          if (xor_result_2 != 0) {\n            if (xor_result_1 == 0) {\n              result_ptr = (byte *)((int)memory_address + 5);\n              xor_result_1 = xor_result_2;\n            }\n            else {\n              result_ptr = (byte *)((int)memory_address + 1);\n            }\n            if ((xor_result_1 & 1) == 0) {\n              is_nonzero_8 = (xor_result_1 & 0x100) == 0;\n              next_byte_ptr = result_ptr + 1;\n              if (is_nonzero_8) {\n                is_nonzero_8 = (xor_result_1 & 0x18000) == 0;\n                next_byte_ptr = result_ptr + 2;\n              }\n              result_ptr = next_byte_ptr;\n              if (is_nonzero_8) {\n                result_ptr = result_ptr + 1;\n              }\n            }\n            return result_ptr + -1;\n          }\n          memory_address = current_ptr;\n        } while (memory_length_aligned != 0);\n        memory_length = memory_length & 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      current_ptr = (uint *)((int)memory_address + 1);\n      memory_length = memory_length - 1;\n      if (*memory_address == byte_to_find_masked) break;\n      ptr_alignment = (uint)current_ptr & 7;\n      memory_address = current_ptr;\n      if (memory_length == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)current_ptr + -1);\n}\n\n",
            "renaming": {
                "FUN_00006010": "find_byte_in_memory_00006010",
                "__s": "memory_address",
                "__c": "byte_to_find",
                "__n": "memory_length",
                "bVar1": "current_byte",
                "cVar2": "is_zero",
                "cVar3": "is_zero_8",
                "cVar4": "is_zero_16",
                "cVar5": "is_zero_24",
                "pbVar6": "next_byte_ptr",
                "puVar7": "current_ptr",
                "pbVar8": "result_ptr",
                "uVar9": "byte_to_find_masked",
                "uVar10": "ptr_alignment",
                "uVar11": "memory_length_aligned",
                "uVar12": "xor_result_1",
                "uVar13": "xor_result_2",
                "bVar14": "is_nonzero_8",
                "bVar15": "is_nonzero_16",
                "bVar16": "is_nonzero_24",
                "bVar17": "is_nonzero_32"
            },
            "calling": [
                "_printf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060b0": {
            "entrypoint": "0x000060b0",
            "current_name": "copy_memory_000060b0",
            "code": "\nvoid * copy_memory_000060b0(void *destination,void *source,size_t length)\n\n{\n  undefined *src_ptr;\n  undefined *end_ptr;\n  undefined *dest_ptr;\n  \n  end_ptr = (undefined *)(length + (int)source);\n  dest_ptr = (undefined *)((int)destination + -1);\n  if ((undefined *)source != end_ptr) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      src_ptr = (undefined *)((int)source + 1);\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n      source = src_ptr;\n    } while (src_ptr != end_ptr);\n    return destination;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000060b0": "copy_memory_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "src_ptr",
                "puVar2": "end_ptr",
                "puVar3": "dest_ptr"
            },
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060cc": {
            "entrypoint": "0x000060cc",
            "current_name": "resize_and_copy_memory_000060cc",
            "code": "\nvoid * resizeAndCopyMemory_000060cc(undefined4 context,void *source,uint size,undefined4 extra)\n\n{\n  void *destination;\n  uint allocatedSize;\n  \n  if (source != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      destination = (void *)0x0;\n    }\n    else {\n      allocatedSize = _malloc_usable_size_r();\n      destination = source;\n      if ((allocatedSize < size) && (destination = (void *)_malloc_r(context,size), destination != (void *)0x0))\n      {\n        memcpy(destination,source,size);\n        _free_r(context,source);\n      }\n    }\n    return destination;\n  }\n  destination = (void *)_malloc_r(context,size,size,extra);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000060cc": "resize_and_copy_memory_000060cc",
                "param_1": "context",
                "param_2": "source",
                "param_3": "size",
                "param_4": "extra",
                "pvVar1": "destination",
                "uVar2": "allocatedSize"
            },
            "calling": [
                "__submore"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006118": {
            "entrypoint": "0x00006118",
            "current_name": "update_data_00006118",
            "code": "\nuint updateData_00006118(undefined4 inputValue,uint mask,uint *data,undefined4 extraParam)\n\n{\n  int result;\n  uint temp1;\n  uint temp2;\n  \n  if (mask == 0xffffffff) {\nLAB_00006120:\n    mask = 0xffffffff;\n  }\n  else {\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xffdf;\n    temp1 = data[1];\n    mask = mask & 0xff;\n    if (data[0xd] == 0) {\n      temp2 = *data;\n      if (((data[4] != 0) && (data[4] < temp2)) && (*(byte *)(temp2 - 1) == mask)) {\n        *data = temp2 - 1;\n        data[1] = temp1 + 1;\n        return mask;\n      }\n      data[0xf] = temp2;\n      data[0x10] = temp1;\n      data[0xd] = (uint)(data + 0x11);\n      data[0xe] = 3;\n      *(undefined *)((int)data + 0x46) = (char)mask;\n      *data = (uint)(undefined *)((int)data + 0x46);\n      temp1 = 1;\n    }\n    else {\n      if (((int)data[0xe] <= (int)temp1) &&\n         (result = __submore(inputValue,data,temp1,data[0xe],extraParam), result != 0))\n      goto LAB_00006120;\n      temp1 = *data;\n      *data = temp1 - 1;\n      *(char *)(temp1 - 1) = (char)mask;\n      temp1 = data[1] + 1;\n    }\n    data[1] = temp1;\n  }\n  return mask;\n}\n\n",
            "renaming": {
                "FUN_00006118": "update_data_00006118",
                "param_1": "inputValue",
                "param_2": "mask",
                "param_3": "data",
                "param_4": "extraParam",
                "iVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2"
            },
            "calling": [],
            "called": [
                "__submore"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006192": {
            "entrypoint": "0x00006192",
            "current_name": "update_data_00006192",
            "code": "\nundefined4 updateData_00006192(undefined4 status,undefined4 *data)\n\n{\n  if ((undefined4 *)data[13] != (undefined4 *)0x0) {\n    if ((undefined4 *)data[13] != data + 0x11) {\n      _free_r();\n    }\n    data[1] = data[16];\n    data[13] = 0;\n    if (data[16] != 0) {\n      *data = data[15];\n      return 0;\n    }\n  }\n  *data = data[4];\n  data[1] = 0;\n  *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006192": "update_data_00006192",
                "param_1": "status",
                "param_2": "data",
                "param_2[0xd]": "data[13]",
                "param_2[1]": "data[1]",
                "param_2[0x10]": "data[16]",
                "param_2[0xf]": "data[15]",
                "param_2[4]": "data[4]"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000061cc": {
            "entrypoint": "0x000061cc",
            "current_name": "parse_input_000061cc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint parseInput_000061cc(undefined4 arg1,byte **inputArray,byte *inputPtr,int **outputArray)\n\n{\n  int result;\n  void *searchResult;\n  uint ch;\n  byte *nextPtr;\n  uint flag;\n  int **outputPtr;\n  undefined buffer [256];\n  uint flag2;\n  undefined4 mode;\n  uint flag1;\n  int returnValue;\n  int count;\n  undefined *currentPtr;\n  int formatType;\n  undefined4 localFlag;\n  code *refillFunction;\n  \n  returnValue = 0;\n  count = 0;\n  localFlag = 0x6119;\n  refillFunction = refill_r + 1;\n  outputPtr = outputArray;\n  currentPtr = buffer;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      flag = (uint)*inputPtr;\n      if (flag == 0) {\n        return returnValue;\n      }\n      ch = (byte)(&DAT_00007a99)[flag] & 8;\n      nextPtr = inputPtr + 1;\n      if (((&DAT_00007a99)[flag] & 8) == 0) break;\n      while (((inputPtr = nextPtr, 0 < (int)inputArray[1] ||\n              (result = (*refillFunction)(arg1,inputArray), result == 0)) &&\n             ((int)((uint)(byte)(&DAT_00007a99)[**inputArray] << 0x1c) < 0))) {\n        count = count + 1;\n        inputArray[1] = inputArray[1] + -1;\n        *inputArray = *inputArray + 1;\n      }\n    }\n    if (flag == 0x25) break;\nLAB_00006352:\n    if (((int)inputArray[1] < 1) && (result = (*refillFunction)(arg1,inputArray), result != 0))\n    goto LAB_00006380;\n    if (**inputArray != flag) {\n      return returnValue;\n    }\n    *inputArray = *inputArray + 1;\n    count = count + 1;\n    inputArray[1] = inputArray[1] + -1;\n    inputPtr = nextPtr;\n  }\n  flag1 = ch;\n  flag2 = ch;\n  if (inputPtr[1] == 0x2a) {\n    nextPtr = inputPtr + 2;\n    flag2 = 0x10;\n  }\n  while( true ) {\n    ch = (uint)*nextPtr;\n    if (9 < ch - 0x30) break;\n    nextPtr = nextPtr + 1;\n    flag1 = (flag1 * 10 + ch) - 0x30;\n  }\n  searchResult = memchr(&DAT_00007c02,ch,3);\n  if (searchResult != (void *)0x0) {\n    flag2 = 1 << ((int)searchResult - 0x7c02U & 0xff) | flag2;\n    nextPtr = nextPtr + 1;\n  }\n  inputPtr = nextPtr + 1;\n  ch = (uint)*nextPtr;\n  if (ch < 0x79) {\n    if (0x57 < ch) {\n      switch(ch) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        inputPtr = (byte *)__sccl(buffer,inputPtr);\n        flag2 = flag2 | 0x40;\n        formatType = 1;\n        break;\n      case 99:\n        flag2 = flag2 | 0x40;\n        formatType = 0;\n        break;\n      case 100:\n      case 0x75:\n        mode = 10;\nLAB_000063a0:\n        if (ch < 0x6f) {\n          formatType = 3;\n        }\n        else {\n          formatType = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        formatType = 5;\n        break;\n      case 0x69:\n        mode = 0;\n        formatType = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(flag2 << 0x1b)) {\n          if ((int)(flag2 << 0x1f) < 0) {\n            *(short *)*outputPtr = (short)count;\n            outputPtr = outputPtr + 1;\n          }\n          else {\n            **outputPtr = count;\n            outputPtr = outputPtr + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        mode = 8;\n        formatType = 4;\n        break;\n      case 0x70:\n        flag2 = flag2 | 0x20;\n      case 0x58:\n      case 0x78:\n        flag2 = flag2 | 0x200;\n        mode = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        formatType = 2;\n      }\nLAB_000063ac:\n      if (((int)inputArray[1] < 1) && (result = (*refillFunction)(arg1,inputArray), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(flag2 << 0x19)) {\n        while ((int)((uint)(byte)(&DAT_00007a99)[**inputArray] << 0x1c) < 0) {\n          count = count + 1;\n          nextPtr = inputArray[1];\n          inputArray[1] = nextPtr + -1;\n          if ((int)(nextPtr + -1) < 1) {\n            result = (*refillFunction)(arg1,inputArray);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *inputArray = *inputArray + 1;\n          }\n        }\n      }\n      if (formatType < 3) {\n        result = _scanf_chars(arg1,&flag2,inputArray,&outputPtr);\n      }\n      else {\n        if (4 < formatType) goto LAB_000061f6;\n        result = _scanf_i(arg1,&flag2,inputArray,&outputPtr);\n      }\n      if (result == 1) {\n        return returnValue;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (returnValue == 0) {\nLAB_00006388:\n          returnValue = -1;\n        }\n        else if ((*(ushort *)(inputArray + 3) & 0x40) != 0) {\n          returnValue = -1;\n        }\n        return returnValue;\n      }\n      goto LAB_000061f6;\n    }\n    nextPtr = inputPtr;\n    if (ch == 0x25) goto LAB_00006352;\n    if (ch < 0x26) {\n      if (ch != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (ch - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  formatType = 3;\n  mode = 10;\n  goto LAB_000063ac;\n}\n\n",
            "renaming": {
                "FUN_000061cc": "parse_input_000061cc",
                "param_1": "arg1",
                "param_2": "inputArray",
                "param_3": "inputPtr",
                "param_4": "outputArray",
                "iVar1": "result",
                "pvVar2": "searchResult",
                "uVar3": "ch",
                "pbVar4": "nextPtr",
                "uVar5": "flag",
                "local_2b0": "outputPtr",
                "auStack_2ac": "buffer",
                "local_1ac": "flag2",
                "local_1a8": "mode",
                "local_1a4": "flag1",
                "local_1a0": "returnValue",
                "local_19c": "count",
                "local_198": "currentPtr",
                "local_194": "formatType",
                "local_30": "localFlag",
                "local_2c": "refillFunction",
                "__ssrefill_r": "refill_r"
            },
            "calling": [
                "siscanf"
            ],
            "called": [
                "__sccl",
                "__ssrefill_r",
                "_scanf_chars",
                "_scanf_i",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000064bc": {
            "entrypoint": "0x000064bc",
            "current_name": "process_data_000064bc",
            "code": "\nundefined4 process_data_000064bc(undefined4 status,uint *flags,byte **data_ptr,undefined4 *func_ptr)\n\n{\n  int result;\n  uint temp;\n  byte **current_data;\n  byte *current_byte;\n  byte *buffer;\n  byte *next_byte;\n  int counter;\n  \n  if (flags[2] == 0) {\n    if (flags[6] == 0) {\n      temp = 1;\n    }\n    else {\n      temp = 0xffffffff;\n    }\n    flags[2] = temp;\n  }\n  if (-1 < (int)(*flags << 0x1b)) {\n    current_data = (byte **)*func_ptr;\n    *func_ptr = current_data + 1;\n    buffer = *current_data;\n  }\n  counter = 0;\n  do {\n    temp = flags[6];\n    if (temp != 0) {\n      if (temp == 1) {\n        if (*(char *)(flags[5] + (uint)**data_ptr) == '\\0') {\n          if (counter == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*flags & 0x10) == 0) && (flags[3] = flags[3] + 1, flags[6] != 0)) {\n            *buffer = 0;\n          }\n          flags[4] = counter + flags[4];\n          return 0;\n        }\n      }\n      else if ((temp != 2) || ((int)((uint)(byte)(&DAT_00007a99)[**data_ptr] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    next_byte = buffer;\n    if (-1 < (int)(*flags << 0x1b)) {\n      next_byte = buffer + 1;\n      *buffer = **data_ptr;\n    }\n    current_byte = data_ptr[1];\n    *data_ptr = *data_ptr + 1;\n    temp = flags[2] - 1;\n    data_ptr[1] = current_byte + -1;\n    counter = counter + 1;\n    flags[2] = temp;\n    buffer = next_byte;\n    if ((temp == 0) ||\n       (((int)(current_byte + -1) < 1 &&\n        (result = (*(code *)flags[0x60])(status,data_ptr,temp,(code *)flags[0x60],func_ptr),\n        result != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "status",
                "param_2": "flags",
                "param_3": "data_ptr",
                "param_4": "func_ptr",
                "iVar1": "result",
                "uVar2": "temp",
                "ppbVar3": "current_data",
                "pbVar4": "current_byte",
                "unaff_r6": "buffer",
                "pbVar5": "next_byte",
                "iVar6": "counter"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000656c": {
            "entrypoint": "0x0000656c",
            "current_name": "decode_data_0000656c",
            "code": "\nundefined4 decodeData_0000656c(undefined4 input,uint *flags,byte **dataPtr,undefined4 *outputPtr)\n\n{\n  code *conversionFunc;\n  void *memchrResult;\n  int conversionResult;\n  undefined4 convertedValue;\n  uint temp;\n  byte *bytePtr;\n  uint length;\n  undefined4 *outputDataPtr;\n  uint *tempPtr1;\n  uint *tempPtr2;\n  uint *tempPtr3;\n  int unaffVar1;\n  int tempVar1;\n  undefined *local_34 [4];\n  \n  charArray1 = &DAT_00007c2f;\n  charArray2 = &DAT_00007c32;\n  charArray3 = &DAT_00007c35;\n  conversionFunc = _strtol_r;\n  if (flags[6] != 3) {\n    conversionFunc = _strtoul_r;\n  }\n  length = flags[2];\n  temp = length - 1;\n  if (0x15c < temp) {\n    unaffVar1 = length - 0x15d;\n    length = 0x15d;\n  }\n  if (0x15c < temp) {\n    flags[2] = length;\n  }\n  tempPtr3 = flags + 7;\n  if (temp < 0x15d) {\n    unaffVar1 = 0;\n  }\n  *flags = *flags | 0xd00;\n  tempVar1 = 0;\n  tempPtr2 = tempPtr3;\n  do {\n    memchrResult = memchr(local_34[tempVar1],(uint)**dataPtr,2);\n    if (memchrResult != (void *)0x0) {\n      if (tempVar1 == 1) {\n        if (flags[1] == 0) {\n          flags[1] = 8;\n          *flags = *flags | 0x200;\n        }\n        temp = *flags & 0xfffffaff;\nLAB_000065f4:\n        *flags = temp;\n      }\n      else if (tempVar1 == 2) {\n        if ((*flags & 0x600) != 0x200) goto LAB_00006624;\n        flags[1] = 0x10;\n        temp = *flags | 0x100;\n        goto LAB_000065f4;\n      }\n      temp = flags[2];\n      flags[2] = temp - 1;\n      if (temp != 0) {\n        bytePtr = *dataPtr;\n        *dataPtr = bytePtr + 1;\n        tempPtr1 = (uint *)((int)tempPtr2 + 1);\n        *(byte *)tempPtr2 = *bytePtr;\n        bytePtr = dataPtr[1];\n        dataPtr[1] = bytePtr + -1;\n        tempPtr2 = tempPtr1;\n        if (((int)(bytePtr + -1) < 1) &&\n           (conversionResult = (*(code *)flags[0x60])(input,dataPtr), conversionResult != 0)) {\n          tempVar1 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    tempVar1 = tempVar1 + 1;\n  } while (tempVar1 != 3);\n  if (flags[1] == 0) {\n    flags[1] = 10;\n  }\n  __sccl(flags[5],\"01234567]\" + (8 - flags[1]));\n  tempVar1 = 0;\n  while( true ) {\n    tempPtr1 = tempPtr2;\n    if (flags[2] == 0) break;\n    bytePtr = *dataPtr;\n    temp = (uint)*bytePtr;\n    if (*(char *)(flags[5] + temp) == '\\0') break;\n    if ((temp == 0x30) && ((int)(*flags << 0x14) < 0)) {\n      tempVar1 = tempVar1 + 1;\n      if (unaffVar1 != 0) {\n        unaffVar1 = unaffVar1 + -1;\n        flags[2] = flags[2] + 1;\n      }\n    }\n    else {\n      *flags = *flags & 0xfffff6ff;\n      tempPtr1 = (uint *)((int)tempPtr2 + 1);\n      *(byte *)tempPtr2 = *bytePtr;\n    }\n    bytePtr = dataPtr[1];\n    dataPtr[1] = bytePtr + -1;\n    if ((int)(bytePtr + -1) < 1) {\n      conversionResult = (*(code *)flags[0x60])(input,dataPtr);\n      if (conversionResult != 0) break;\n    }\n    else {\n      *dataPtr = *dataPtr + 1;\n    }\n    flags[2] = flags[2] - 1;\n    tempPtr2 = tempPtr1;\n  }\nLAB_000066ca:\n  if ((int)(*flags << 0x17) < 0) {\n    if (tempPtr3 < tempPtr1) {\n      (*(code *)flags[0x5f])(input,*(byte *)((int)tempPtr1 + -1),dataPtr);\n      tempPtr1 = (uint *)((int)tempPtr1 + -1);\n    }\n    if (tempPtr1 == tempPtr3) {\n      return 1;\n    }\n  }\n  if ((*flags & 0x10) == 0) {\n    *(byte *)tempPtr1 = 0;\n    convertedValue = (*(conversionFunc + 1))(input,tempPtr3,0,flags[1]);\n    outputDataPtr = (undefined4 *)*outputPtr;\n    temp = *flags;\n    *outputPtr = outputDataPtr + 1;\n    outputDataPtr = (undefined4 *)*outputDataPtr;\n    if ((temp & 0x20) == 0) {\n      if ((int)(temp << 0x1f) < 0) {\n        *(short *)outputDataPtr = (short)convertedValue;\n      }\n      else {\n        *outputDataPtr = convertedValue;\n      }\n    }\n    else {\n      *outputDataPtr = convertedValue;\n    }\n    flags[3] = flags[3] + 1;\n  }\n  flags[4] = (uint)((int)tempPtr1 + flags[4] + (tempVar1 - (int)tempPtr3));\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000656c": "decode_data_0000656c",
                "param_1": "input",
                "param_2": "flags",
                "param_3": "dataPtr",
                "param_4": "outputPtr",
                "pcVar1": "conversionFunc",
                "pvVar2": "memchrResult",
                "iVar3": "conversionResult",
                "uVar4": "convertedValue",
                "uVar5": "temp",
                "pbVar6": "bytePtr",
                "uVar7": "length",
                "puVar8": "outputDataPtr",
                "puVar9": "tempPtr1",
                "puVar10": "tempPtr2",
                "puVar11": "tempPtr3",
                "unaff_r9": "unaffVar1",
                "iVar12": "tempVar1",
                "local_34[0]": "charArray1",
                "local_34[1]": "charArray2",
                "local_34[2]": "charArray3"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "__sccl",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006754": {
            "entrypoint": "0x00006754",
            "current_name": "flush_file_00006754",
            "code": "\nint flushFile_00006754(FILE *file)\n\n{\n  int result;\n  \n  if ((*(ushort *)&file->_IO_read_base & 9) == 9) {\n    result = fflush(file);\n    return result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00006754": "flush_file_00006754",
                "param_1": "file",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006768": {
            "entrypoint": "0x00006768",
            "current_name": "process_data_stream_00006768",
            "code": "\nundefined4\nprocessDataStream_00006768(undefined4 *inputBuffer,undefined4 *stream,undefined4 size,undefined4 flags)\n\n{\n  undefined2 streamMode;\n  int result;\n  undefined4 tempVar;\n  ushort streamFlags;\n  uint shiftedSize;\n  \n  if ((inputBuffer != (undefined4 *)0x0) && (inputBuffer[6] == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = (undefined4 *)inputBuffer[1];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = (undefined4 *)inputBuffer[2];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = (undefined4 *)inputBuffer[3];\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  stream[1] = 0;\n  shiftedSize = (uint)*(ushort *)(stream + 3);\n  if ((int)(shiftedSize << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(shiftedSize << 0x1d) < 0) {\n    if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)stream[0xd] != stream + 0x11) {\n        _free_r(inputBuffer);\n      }\n      stream[1] = stream[0x10];\n      stream[0xd] = 0;\n      if (stream[0x10] != 0) {\n        *stream = stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(shiftedSize << 0x1b)) {\n      *inputBuffer = 9;\n      streamFlags = streamFlags | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(shiftedSize << 0x1c) < 0) {\n      result = _fflush_r(inputBuffer,stream,shiftedSize << 0x1c,shiftedSize,flags);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      stream[2] = 0;\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n      stream[6] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n  }\n  if (stream[4] == 0) {\n    __smakebuf_r(inputBuffer,stream);\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  streamMode = *(undefined2 *)(stream + 3);\n  if ((streamFlags & 3) != 0) {\n    *(undefined2 *)(stream + 3) = 1;\n    _fwalk(&impure_data,0x6755);\n    *(undefined2 *)(stream + 3) = streamMode;\n    if ((streamFlags & 9) == 9) {\n      __sflush_r(inputBuffer,stream);\n    }\n  }\n  tempVar = stream[4];\n  *stream = tempVar;\n  result = (*(code *)stream[9])(inputBuffer,stream[8],tempVar,stream[5]);\n  stream[1] = result;\n  if (0 < result) {\n    return 0;\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  if (result != 0) {\n    tempVar = 0;\n  }\n  else {\n    streamFlags = streamFlags | 0x20;\n  }\n  if (result != 0) {\n    stream[1] = tempVar;\n    streamFlags = streamFlags | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(stream + 3) = streamFlags;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006768": "process_data_stream_00006768",
                "param_1": "inputBuffer",
                "param_2": "stream",
                "param_3": "size",
                "param_4": "flags",
                "uVar1": "streamMode",
                "iVar2": "result",
                "uVar3": "tempVar",
                "uVar4": "streamFlags",
                "uVar5": "shiftedSize"
            },
            "calling": [
                "__srget_r"
            ],
            "called": [
                "_fflush_r",
                "__sinit",
                "__smakebuf_r",
                "_fwalk",
                "__sflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000687c": {
            "entrypoint": "0x0000687c",
            "current_name": "extract_toggle_bits_0000687c",
            "code": "\nbyte * extract_toggle_bits_0000687c(int size,byte *data)\n\n{\n  byte *result;\n  uint temp1;\n  int index;\n  uint next_byte;\n  uint start_index;\n  uint end_index;\n  bool is_repeating;\n  \n  next_byte = (uint)*data;\n  is_repeating = next_byte == 0x5e;\n  if (is_repeating) {\n    next_byte = (uint)data[1];\n    data = data + 2;\n  }\n  else {\n    data = data + 1;\n  }\n  index = size + -1;\n  do {\n    index = index + 1;\n    *(bool *)index = is_repeating;\n  } while (index != size + 0xff);\n  if (next_byte == 0) {\n    result = data + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      start_index = next_byte;\n      *(bool *)(size + start_index) = !is_repeating;\n      data = data + 1;\n      while( true ) {\n        next_byte = (uint)data[-1];\n        if (next_byte != 0x2d) break;\n        end_index = (uint)*data;\n        if ((end_index == 0x5d) || (temp1 = start_index, (int)end_index < (int)start_index)) goto LAB_000068aa;\n        do {\n          temp1 = temp1 + 1;\n          *(bool *)(size + temp1) = !is_repeating;\n        } while ((int)temp1 < (int)end_index);\n        index = ~start_index + end_index;\n        if ((int)end_index <= (int)start_index) {\n          index = 0;\n        }\n        start_index = start_index + 1 + index;\n        data = data + 2;\n      }\n      result = data;\n    } while ((next_byte != 0x5d) && (result = data + -1, next_byte != 0));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000687c": "extract_toggle_bits_0000687c",
                "param_1": "size",
                "param_2": "data",
                "pbVar1": "result",
                "uVar2": "temp1",
                "iVar3": "index",
                "uVar4": "next_byte",
                "uVar5": "start_index",
                "uVar6": "end_index",
                "bVar7": "is_repeating"
            },
            "calling": [
                "__ssvfiscanf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000068f0": {
            "entrypoint": "0x000068f0",
            "current_name": "initialize_flash_configuration_000068f0",
            "code": "\nundefined4 initialize_flash_configuration_000068f0(undefined4 size_of_flash_configuration,void **flash_configuration)\n\n{\n  void *allocated_memory;\n  void *previous_flash_size;\n  \n  if ((void **)flash_configuration[0xd] == flash_configuration + 0x11) {\n    allocated_memory = (void *)_malloc_r(size_of_flash_configuration,0x400);\n    if (allocated_memory != (void *)0x0) {\n      flash_configuration[0xe] = flash_configuration_field;\n      flash_configuration[0xd] = allocated_memory;\n      *(undefined *)((int)allocated_memory + 0x3ff) = *(undefined *)((int)flash_configuration + 0x46);\n      *(undefined *)((int)allocated_memory + 0x3fe) = *(undefined *)((int)flash_configuration + 0x45);\n      *(undefined *)((int)allocated_memory + 0x3fd) = *(undefined *)(flash_configuration + 0x11);\n      *flash_configuration = (void *)((int)allocated_memory + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    previous_flash_size = flash_configuration[0xe];\n    allocated_memory = (void *)_realloc_r(size_of_flash_configuration,flash_configuration[0xd],(void *)((int)previous_flash_size << 1));\n    if (allocated_memory != (void *)0x0) {\n      memcpy((void *)((int)allocated_memory + (int)previous_flash_size),allocated_memory,(size_t)previous_flash_size);\n      flash_configuration[0xd] = allocated_memory;\n      flash_configuration[0xe] = (void *)((int)previous_flash_size << 1);\n      *flash_configuration = (void *)((int)allocated_memory + (int)previous_flash_size);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000068f0": "initialize_flash_configuration_000068f0",
                "param_1": "size_of_flash_configuration",
                "param_2": "flash_configuration",
                "pvVar1": "allocated_memory",
                "__n": "previous_flash_size"
            },
            "calling": [
                "_sungetc_r"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006964": {
            "entrypoint": "0x00006964",
            "current_name": "calculate_result_00006964",
            "code": "\nint calculateResult_00006964(undefined4 input1,int input2)\n\n{\n  int result;\n  \n  result = *(int *)(input2 + -4) + -4;\n  if (*(int *)(input2 + -4) < 0) {\n    result = result + *(int *)(input2 + result);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006964": "calculate_result_00006964",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "result"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006974": {
            "entrypoint": "0x00006974",
            "current_name": "divide_with_conditions_00006974",
            "code": "\nint divideWithConditions_00006974(int dividend,int divisor,int num1,int num2)\n\n{\n  int result;\n  undefined tempBuffer [8];\n  \n  if ((num2 == 0) && (num1 == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    result = __aeabi_idiv0(dividend,divisor);\n    return result;\n  }\n  if (divisor < 0) {\n    result = -divisor - (uint)(dividend != 0);\n    if (num2 < 0) {\n      result = __udivmoddi4(-dividend,result,-num1,-num2 - (uint)(num1 != 0),tempBuffer);\n      return result;\n    }\n    result = __udivmoddi4(-dividend,result,num1,num2,tempBuffer);\n    return -result;\n  }\n  if (num2 < 0) {\n    result = __udivmoddi4(dividend,divisor,-num1,-num2 - (uint)(num1 != 0),tempBuffer);\n    return -result;\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006974": "divide_with_conditions_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "num1",
                "param_4": "num2",
                "iVar1": "result",
                "local_8": "tempBuffer"
            },
            "calling": [
                "gmtime_r"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006a14": {
            "entrypoint": "0x00006a14",
            "current_name": "calculate_quotient_remainder_00006a14",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong calculateQuotientRemainder_00006a14(uint dividend,uint dividend_low,uint divisor,uint divisor_low,uint *quotient_remainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint quotient_high;\n  int shift_amount;\n  uint dividend_high;\n  uint quotient_temp;\n  uint quotient;\n  uint remainder;\n  uint shifted_divisor;\n  uint quotient_temp2;\n  uint divisor_high;\n  bool carry_flag;\n  ulonglong result;\n  \n  if (divisor_low == 0) {\n    if (dividend_low < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      quotient = divisor;\n      if (shift_amount != 0) {\n        quotient = divisor << shift_amount;\n        dividend_low = dividend >> (0x20U - shift_amount & 0xff) | dividend_low << shift_amount;\n        dividend = dividend << shift_amount;\n      }\n      remainder = quotient >> 0x10;\n      quotient_temp2 = dividend_low / remainder;\n      dividend_high = dividend >> 0x10 | (dividend_low - remainder * quotient_temp2) * 0x10000;\n      quotient_high = quotient_temp2 * (quotient & 0xffff);\n      quotient_temp = quotient_temp2;\n      if (dividend_high <= quotient_high && quotient_high - dividend_high != 0) {\n        carry_flag = CARRY4(quotient,dividend_high);\n        dividend_high = quotient + dividend_high;\n        quotient_temp = quotient_temp2 - 1;\n        if ((carry_flag == false) && (dividend_high <= quotient_high && quotient_high - dividend_high != 0)) {\n          quotient_temp = quotient_temp2 - 2;\n          dividend_high = dividend_high + quotient;\n        }\n      }\n      quotient_temp2 = (dividend_high - quotient_high) / remainder;\n      remainder = dividend & 0xffff | ((dividend_high - quotient_high) - remainder * quotient_temp2) * 0x10000;\n      dividend_high = quotient_temp2 * (quotient & 0xffff);\n      quotient_high = quotient_temp2;\n      if (remainder <= dividend_high && dividend_high - remainder != 0) {\n        carry_flag = CARRY4(quotient,remainder);\n        remainder = quotient + remainder;\n        quotient_high = quotient_temp2 - 1;\n        if ((carry_flag == false) && (remainder <= dividend_high && dividend_high - remainder != 0)) {\n          quotient_high = quotient_temp2 - 2;\n          remainder = remainder + quotient;\n        }\n      }\n      remainder = remainder - dividend_high;\n      quotient_high = quotient_high | quotient_temp << 0x10;\n      quotient = 0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        dividend_low = dividend_low - divisor;\n        divisor_high = divisor >> 0x10;\n        shifted_divisor = divisor & 0xffff;\n        quotient = 1;\n        quotient_temp = divisor;\n      }\n      else {\n        quotient_temp = divisor << shift_amount;\n        divisor_high = quotient_temp >> 0x10;\n        quotient_high = dividend_low >> (0x20U - shift_amount & 0xff);\n        quotient = dividend >> (0x20U - shift_amount & 0xff) | dividend_low << shift_amount;\n        dividend_high = quotient_high / divisor_high;\n        shifted_divisor = quotient_temp & 0xffff;\n        quotient_temp2 = quotient >> 0x10 | (quotient_high - divisor_high * dividend_high) * 0x10000;\n        remainder = dividend_high * shifted_divisor;\n        dividend = dividend << shift_amount;\n        quotient_high = dividend_high;\n        if (quotient_temp2 <= remainder && remainder - quotient_temp2 != 0) {\n          carry_flag = CARRY4(quotient_temp,quotient_temp2);\n          quotient_temp2 = quotient_temp + quotient_temp2;\n          quotient_high = dividend_high - 1;\n          if ((carry_flag == false) && (quotient_temp2 <= remainder && remainder - quotient_temp2 != 0)) {\n            quotient_high = dividend_high - 2;\n            quotient_temp2 = quotient_temp2 + quotient_temp;\n          }\n        }\n        dividend_high = (quotient_temp2 - remainder) / divisor_high;\n        dividend_low = quotient & 0xffff | ((quotient_temp2 - remainder) - divisor_high * dividend_high) * 0x10000;\n        remainder = dividend_high * shifted_divisor;\n        quotient = dividend_high;\n        if (dividend_low <= remainder && remainder - dividend_low != 0) {\n          carry_flag = CARRY4(quotient_temp,dividend_low);\n          dividend_low = quotient_temp + dividend_low;\n          quotient = dividend_high - 1;\n          if ((carry_flag == false) && (dividend_low <= remainder && remainder - dividend_low != 0)) {\n            quotient = dividend_high - 2;\n            dividend_low = dividend_low + quotient_temp;\n          }\n        }\n        dividend_low = dividend_low - remainder;\n        quotient = quotient | quotient_high << 0x10;\n      }\n      quotient_temp2 = dividend_low / divisor_high;\n      remainder = dividend >> 0x10 | (dividend_low - divisor_high * quotient_temp2) * 0x10000;\n      quotient_high = shifted_divisor * quotient_temp2;\n      dividend_high = quotient_temp2;\n      if (remainder <= quotient_high && quotient_high - remainder != 0) {\n        carry_flag = CARRY4(quotient_temp,remainder);\n        remainder = quotient_temp + remainder;\n        dividend_high = quotient_temp2 - 1;\n        if ((carry_flag == false) && (remainder <= quotient_high && quotient_high - remainder != 0)) {\n          dividend_high = quotient_temp2 - 2;\n          remainder = remainder + quotient_temp;\n        }\n      }\n      quotient_temp2 = (remainder - quotient_high) / divisor_high;\n      remainder = dividend & 0xffff | ((remainder - quotient_high) - divisor_high * quotient_temp2) * 0x10000;\n      shifted_divisor = shifted_divisor * quotient_temp2;\n      quotient_high = quotient_temp2;\n      if (remainder <= shifted_divisor && shifted_divisor - remainder != 0) {\n        carry_flag = CARRY4(quotient_temp,remainder);\n        remainder = quotient_temp + remainder;\n        quotient_high = quotient_temp2 - 1;\n        if ((carry_flag == false) && (remainder <= shifted_divisor && shifted_divisor - remainder != 0)) {\n          quotient_high = quotient_temp2 - 2;\n          remainder = remainder + quotient_temp;\n        }\n      }\n      remainder = remainder - shifted_divisor;\n      quotient_high = quotient_high | dividend_high << 0x10;\n    }\n    if (quotient_remainder != (uint *)0x0) {\n      *quotient_remainder = remainder >> LZCOUNT(divisor);\n      quotient_remainder[1] = 0;\n    }\n  }\n  else if (dividend_low < divisor_low) {\n    if (quotient_remainder != (uint *)0x0) {\n      *quotient_remainder = dividend;\n      quotient_remainder[1] = dividend_low;\n      return 0;\n    }\n    quotient_high = 0;\n    quotient = 0;\n  }\n  else {\n    shift_amount = LZCOUNT(divisor_low);\n    if (shift_amount != 0) {\n      shifted_divisor = 0x20 - shift_amount;\n      dividend_high = divisor >> (shifted_divisor & 0xff) | divisor_low << shift_amount;\n      divisor_high = dividend_high >> 0x10;\n      quotient_high = dividend_low >> (shifted_divisor & 0xff);\n      quotient = dividend >> (shifted_divisor & 0xff) | dividend_low << shift_amount;\n      remainder = quotient_high / divisor_high;\n      quotient_temp = quotient >> 0x10 | (quotient_high - divisor_high * remainder) * 0x10000;\n      quotient_temp2 = remainder * (dividend_high & 0xffff);\n      dividend = dividend << shift_amount;\n      quotient_high = remainder;\n      if (quotient_temp <= quotient_temp2 && quotient_temp2 - quotient_temp != 0) {\n        carry_flag = CARRY4(dividend_high,quotient_temp);\n        quotient_temp = dividend_high + quotient_temp;\n        quotient_high = remainder - 1;\n        if ((carry_flag == false) && (quotient_temp <= quotient_temp2 && quotient_temp2 - quotient_temp != 0)) {\n          quotient_high = remainder - 2;\n          quotient_temp = quotient_temp + dividend_high;\n        }\n      }\n      remainder = (quotient_temp - quotient_temp2) / divisor_high;\n      quotient_temp = quotient & 0xffff | ((quotient_temp - quotient_temp2) - divisor_high * remainder) * 0x10000;\n      quotient_temp2 = remainder * (dividend_high & 0xffff);\n      quotient = remainder;\n      if (quotient_temp <= quotient_temp2 && quotient_temp2 - quotient_temp != 0) {\n        carry_flag = CARRY4(dividend_high,quotient_temp);\n        quotient_temp = dividend_high + quotient_temp;\n        quotient = remainder - 1;\n        if ((carry_flag == false) && (quotient_temp <= quotient_temp2 && quotient_temp2 - quotient_temp != 0)) {\n          quotient = remainder - 2;\n          quotient_temp = quotient_temp + dividend_high;\n        }\n      }\n      quotient = quotient | quotient_high << 0x10;\n      result = (ulonglong)quotient * (ulonglong)(divisor << shift_amount);\n      if (CONCAT44(quotient_temp - quotient_temp2,dividend) < result) {\n        result = result - CONCAT44(dividend_high,divisor << shift_amount);\n        quotient = quotient - 1;\n      }\n      if (quotient_remainder != (uint *)0x0) {\n        quotient_high = ((quotient_temp - quotient_temp2) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *quotient_remainder = quotient_high << (shifted_divisor & 0xff) | dividend - (uint)result >> shift_amount;\n        quotient_remainder[1] = quotient_high >> shift_amount;\n      }\n      return (ulonglong)quotient;\n    }\n    if ((divisor_low < dividend_low) || (divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_low = (dividend_low - divisor_low) - (uint)carry_flag;\n      quotient_high = 1;\n    }\n    else {\n      quotient_high = 0;\n    }\n    quotient = 0;\n    if (quotient_remainder != (uint *)0x0) {\n      *quotient_remainder = dividend;\n      quotient_remainder[1] = dividend_low;\n    }\n  }\n  return CONCAT44(quotient,quotient_high);\n}\n\n",
            "renaming": {
                "FUN_00006a14": "calculate_quotient_remainder_00006a14",
                "param_1": "dividend",
                "param_2": "dividend_low",
                "param_3": "divisor",
                "param_4": "divisor_low",
                "param_5": "quotient_remainder",
                "uVar1": "quotient_high",
                "iVar2": "shift_amount",
                "uVar3": "dividend_high",
                "uVar4": "quotient_temp",
                "uVar5": "quotient",
                "uVar6": "remainder",
                "uVar7": "shifted_divisor",
                "uVar8": "quotient_temp2",
                "uVar9": "divisor_high",
                "bVar10": "carry_flag",
                "uVar11": "result"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006cd4": {
            "entrypoint": "0x00006cd4",
            "current_name": "FUNC_00006cd4",
            "code": "\nvoid FUNC_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00006cd4": "FUNC_00006cd4"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 143532,
    "layers": [
        [
            "FUN_00000410",
            "FUN_00000428",
            "FUN_00000490",
            "FUN_000004b2",
            "FUN_000004d4",
            "FUN_000004f2",
            "FUN_00000514",
            "FUN_00000534",
            "FUN_00000566",
            "FUN_0000058e",
            "FUN_000005ca",
            "FUN_00000610",
            "FUN_00000698",
            "FUN_00000738",
            "FUN_00000794",
            "FUN_000007dc",
            "FUN_000008b8",
            "FUN_00000900",
            "FUN_0000091c",
            "FUN_00000930",
            "FUN_0000093c",
            "FUN_00000958",
            "FUN_00000974",
            "FUN_00000978",
            "FUN_0000099c",
            "FUN_00000a30",
            "FUN_00000a40",
            "FUN_00000a64",
            "FUN_00000aa8",
            "FUN_00000c80",
            "FUN_00000c90",
            "FUN_00000ca0",
            "FUN_00000cb0",
            "FUN_00000cc0",
            "FUN_00000cd0",
            "FUN_00000cf0",
            "FUN_00000d0c",
            "FUN_00000d2a",
            "FUN_00000d44",
            "FUN_00000d76",
            "FUN_00000d9c",
            "FUN_00000db0",
            "FUN_00000dc0",
            "FUN_00000dcc",
            "FUN_00000df4",
            "FUN_00000e14",
            "FUN_00000e38",
            "FUN_00000e58",
            "FUN_00000e64",
            "FUN_00000ed8",
            "FUN_00000f04",
            "FUN_00000f5c",
            "FUN_00000f80",
            "FUN_00000f8c",
            "FUN_00000fec",
            "FUN_00001034",
            "FUN_000010a0",
            "FUN_000010d4",
            "FUN_00001274",
            "FUN_0000129c",
            "FUN_000012b4",
            "FUN_000012e2",
            "FUN_00001318",
            "FUN_00001348",
            "FUN_00001360",
            "FUN_00001392",
            "FUN_000013b8",
            "FUN_00001448",
            "FUN_000014c4",
            "FUN_000015d0",
            "FUN_00001628",
            "FUN_00001688",
            "FUN_00001696",
            "FUN_000016c8",
            "FUN_000016ec",
            "FUN_00001710",
            "FUN_00001734",
            "FUN_00001748",
            "FUN_00001778",
            "FUN_000017dc",
            "FUN_0000182c",
            "FUN_000018bc",
            "FUN_0000191c",
            "FUN_00001960",
            "FUN_000019c0",
            "FUN_00001a18",
            "FUN_00001a3c",
            "FUN_00001a60",
            "FUN_00001ad4",
            "FUN_00001b10",
            "FUN_00001bb8",
            "FUN_00001c84",
            "FUN_00001cf0",
            "FUN_00001d08",
            "FUN_00001d3a",
            "FUN_00001d5e",
            "FUN_00001d80",
            "FUN_00001da2",
            "FUN_00001dc0",
            "FUN_00001ddc",
            "FUN_00001e0c",
            "FUN_00001e44",
            "FUN_00001ec4",
            "FUN_00001eea",
            "FUN_00001f80",
            "FUN_00001ff6",
            "FUN_00002028",
            "FUN_000020b8",
            "FUN_000020cc",
            "FUN_000020e0",
            "FUN_000020f4",
            "FUN_00002108",
            "FUN_0000211c",
            "FUN_00002270",
            "FUN_00002294",
            "FUN_000022be",
            "FUN_000022f0",
            "FUN_0000231c",
            "FUN_00002364",
            "FUN_00002396",
            "FUN_000023a4",
            "FUN_000023c8",
            "FUN_000023d0",
            "FUN_0000240c",
            "FUN_00002434",
            "FUN_000024bc",
            "FUN_00002538",
            "FUN_0000258c",
            "FUN_000025f4",
            "FUN_00002600",
            "FUN_00002624",
            "FUN_00002654",
            "FUN_00002690",
            "FUN_000026c0",
            "FUN_000026d8",
            "FUN_000026e4",
            "FUN_000026f0",
            "FUN_00002714",
            "FUN_00002744",
            "FUN_00002798",
            "FUN_000027b0",
            "FUN_0000281c",
            "FUN_0000285c",
            "FUN_00002894",
            "FUN_000028f0",
            "FUN_00002910",
            "FUN_0000294c",
            "FUN_00002970",
            "FUN_00002994",
            "FUN_00002a00",
            "FUN_00002a18",
            "FUN_00002a88",
            "FUN_00002b10",
            "FUN_00002d94",
            "FUN_00002e48",
            "FUN_00002e6c",
            "FUN_00002e9c",
            "FUN_00002eb4",
            "FUN_00002ecc",
            "FUN_00002f30",
            "FUN_00002f74",
            "FUN_00002fe0",
            "FUN_0000305c",
            "FUN_0000316c",
            "FUN_000031e0",
            "FUN_000031fc",
            "FUN_0000328c",
            "FUN_00003378",
            "FUN_000033c0",
            "FUN_000033f4",
            "FUN_00003444",
            "FUN_00003478",
            "FUN_000034c0",
            "FUN_00003524",
            "FUN_00003658",
            "FUN_00003688",
            "FUN_00003694",
            "FUN_00003810",
            "FUN_00003918",
            "FUN_000039e8",
            "FUN_00003d24",
            "FUN_00003d64",
            "FUN_00003d94",
            "FUN_00003dc4",
            "FUN_00003e58",
            "FUN_00003e9e",
            "FUN_00003ec4",
            "FUN_00003ff4",
            "FUN_00004042",
            "FUN_0000404c",
            "FUN_00004158",
            "FUN_000041d0",
            "FUN_000041f4",
            "FUN_0000423c",
            "FUN_00004248",
            "FUN_00004274",
            "FUN_00004280",
            "FUN_0000428c",
            "FUN_00004298",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_000043a0",
            "FUN_000043da",
            "FUN_00004418",
            "FUN_0000443c",
            "FUN_0000459c",
            "FUN_000045ee",
            "FUN_00004622",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_00004b34",
            "FUN_00004bd0",
            "FUN_00004c84",
            "FUN_00004cb4",
            "FUN_00004cdc",
            "FUN_00004db8",
            "FUN_00004dc8",
            "FUN_00004dea",
            "FUN_00004dee",
            "FUN_00004e26",
            "FUN_00004e4a",
            "FUN_00004e52",
            "FUN_00004e66",
            "FUN_00004e8c",
            "FUN_00004f84",
            "FUN_00004f98",
            "FUN_000050e8",
            "FUN_000050f4",
            "FUN_00005100",
            "FUN_0000510c",
            "FUN_00005404",
            "FUN_000054a8",
            "FUN_00005584",
            "FUN_000055ac",
            "FUN_0000562c",
            "FUN_000056a0",
            "FUN_000056b0",
            "FUN_000056b8",
            "FUN_00005700",
            "FUN_00005780",
            "FUN_00005790",
            "FUN_0000579c",
            "FUN_000057a8",
            "FUN_000057d2",
            "FUN_000057f8",
            "FUN_00005a58",
            "FUN_00005b34",
            "FUN_00005d80",
            "FUN_00005e10",
            "FUN_00005e68",
            "FUN_00005ebc",
            "FUN_00005ecc",
            "FUN_00005edc",
            "FUN_00005fd8",
            "FUN_00005fec",
            "FUN_00005ff8",
            "FUN_00006010",
            "FUN_000060b0",
            "FUN_000060cc",
            "FUN_00006118",
            "FUN_00006192",
            "FUN_000061cc",
            "FUN_000064bc",
            "FUN_0000656c",
            "FUN_00006754",
            "FUN_00006768",
            "FUN_0000687c",
            "FUN_000068f0",
            "FUN_00006964",
            "FUN_00006974",
            "FUN_00006a14"
        ]
    ],
    "locked_functions": []
}