{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_alarm_and_reset_callback_000026c0",
                "PTR_rtc_callback_000026d4": "PTR_rtc_callback",
                "rtt_clear_alarm": "clear_rtc_alarm"
            },
            "code": "void clear_alarm_and_reset_callback_000026c0(void)\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4_000026d4 = 0;\n  return;\n}",
            "called": [
                "rtt_clear_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "clear_alarm_and_reset_callback_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "*param_1": "reent",
                "param_2": "size",
                "puVar1": "start",
                "pvVar2": "new_start",
                "puVar3": "prev",
                "iVar4": "diff",
                "uVar5": "diff",
                "puVar6": "current",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_00004bd0(_reent *reent, uint size)\n{\n  uint aligned_size = (size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < size)) {\n    reent->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void *start = PTR___malloc_sbrk_start_00004c80;\n    uint *prev = *(uint **)PTR___malloc_free_list_00004c7c;\n    for (uint *current = *(uint **)PTR___malloc_free_list_00004c7c; current != (uint *)0x0;\n        current = (uint *)current[1]) {\n      uint diff = *current - aligned_size;\n      if (-1 < (int)diff) {\n        if (0xb < diff) {\n          *current = diff;\n          current = (uint *)((int)current + diff);\n          goto LAB_00004c34;\n        }\n        uint next = current[1];\n        if (prev == current) {\n          *(uint *)PTR___malloc_free_list_00004c7c = next;\n        }\n        if (prev != current) {\n          prev[1] = next;\n        }\n        goto LAB_00004c42;\n      }\n      prev = current;\n    }\n    if (*(int *)PTR___malloc_sbrk_start_00004c80 == 0) {\n      void *new_start = _sbrk_r(reent,0);\n      *(void **)start = new_start;\n    }\n    uint *new_mem = (uint *)_sbrk_r(reent,aligned_size);\n    if ((new_mem != (uint *)0xffffffff) &&\n       ((current = (uint *)((int)new_mem + 3U & 0xfffffffc), new_mem == current ||\n        (start = _sbrk_r(reent,(int)current - (int)new_mem), start != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *current = aligned_size;\nLAB_00004c42:\n      __malloc_unlock(reent);\n      uint end = (int)current + 0xbU & 0xfffffff8;\n      int diff = end - (int)(current + 1);\n      if (diff == 0) {\n        return end;\n      }\n      *(uint *)((int)current + diff) = (int)(current + 1) - end;\n      return end;\n    }\n    reent->_errno = 0xc;\n    __malloc_unlock(reent);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "_tzset_unlocked_r",
                "__submore",
                "_realloc_r",
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "disable_interrupts_and_remove_thread_from_scheduler_00000794",
                "PTR_sched_threads_000007d0": "threads",
                "PTR_sched_active_pid_000007cc": "active_pid",
                "PTR_sched_num_threads_000007d4": "num_threads",
                "PTR_sched_active_thread_000007d8": "active_thread",
                "sched_set_status": "set_thread_status",
                "cpu_switch_context_exit": "switch_context_exit"
            },
            "code": "void disable_interrupts_and_remove_thread_from_scheduler_00000794()\n{\n    disable_interrupts();\n    int* PTR_sched_num_PTR_sched_threads_000007d0_000007d4 = (int*)PTR_sched_PTR_sched_num_PTR_sched_threads_000007d0_000007d4_000007d4;\n    *PTR_sched_num_PTR_sched_threads_000007d0_000007d4 -= 1;\n    thread_t** PTR_sched_active_thread_000007d8 = (thread_t**)PTR_sched_PTR_sched_active_thread_000007d8_000007d8;\n    sched_set_status(*PTR_sched_active_thread_000007d8, 0);\n    *PTR_sched_active_thread_000007d8 = NULL;\n    cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "disable_interrupts_and_remove_thread_from_scheduler_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "decode_string_000064bc",
                "param_1": "input",
                "param_2": "length",
                "param_3": "buffer",
                "param_4": "callback",
                "puVar1": "output_buffer_pointer",
                "iVar2": "callback_return_value",
                "ppbVar4": "buffer_pointer",
                "pbVar5": "current_character",
                "unaff_r6": "output_buffer",
                "pbVar6": "output_buffer_pointer",
                "iVar7": "current_character_index"
            },
            "code": "undefined4 decode_string_000064bc(undefined4 input, uint *length, byte **buffer, undefined4 *callback)\n{\n  byte *output_buffer;\n  int current_character_index;\n  uint remaining_length;\n  byte **buffer_pointer;\n  byte *current_character;\n  byte *output_buffer_pointer;\n  int callback_return_value;\n  \n  if (length[2] == 0) {\n    if (length[6] == 0) {\n      remaining_length = 1;\n    }\n    else {\n      remaining_length = 0xffffffff;\n    }\n    length[2] = remaining_length;\n  }\n  output_buffer_pointer = PTR_DAT_00006568;\n  if (-1 < (int)(*length << 0x1b)) {\n    buffer_pointer = (byte **)*callback;\n    *callback = buffer_pointer + 1;\n    current_character = *buffer_pointer;\n  }\n  callback_return_value = 0;\n  do {\n    remaining_length = length[6];\n    if (remaining_length != 0) {\n      if (remaining_length == 1) {\n        if (*(char *)(length[5] + (uint)**buffer) == '\\0') {\n          if (callback_return_value == 0) {\n            return 1;\n          }\nLABEL_0000654a:\n          if (((*length & 0x10) == 0) && (length[3] = length[3] + 1, length[6] != 0)) {\n            *output_buffer_pointer = 0;\n          }\n          length[4] = callback_return_value + length[4];\n          return 0;\n        }\n      }\n      else if ((remaining_length != 2) || ((int)((uint)(byte)PTR_DAT_00006568[**buffer] << 0x1c) < 0))\n      goto LABEL_0000654a;\n    }\n    output_buffer = output_buffer_pointer;\n    if (-1 < (int)(*length << 0x1b)) {\n      output_buffer = output_buffer_pointer + 1;\n      *output_buffer_pointer = **buffer;\n    }\n    current_character = buffer[1];\n    *buffer = *buffer + 1;\n    remaining_length = length[2] - 1;\n    buffer[1] = current_character + -1;\n    callback_return_value = callback_return_value + 1;\n    length[2] = remaining_length;\n    output_buffer_pointer = output_buffer;\n    if ((remaining_length == 0) || (((int)(current_character + -1) < 1 && (current_character_index = (*(code *)length[0x60])(input, buffer, remaining_length, (code *)length[0x60], callback), current_character_index != 0)))) goto LABEL_0000654a;\n  } while( true );\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "decode_string_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_interrupt_flag_00002970",
                "rtt": "real_time_clock",
                "*(uint *)(DAT_00002990 + 0x14)": "flag_register",
                "uint": "uint32_t"
            },
            "code": "void clear_interrupt_flag_00002970(void)\n{\n  RTC_Type *real_time_clock;\n  uint32_t **(uint *)(DAT_00002990 + 0x14) = (uint32_t *)(DAT_00002990 + 0x14);\n  **(uint *)(DAT_00002990 + 0x14) &= 0xffffffef;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "rtc_poweroff"
            ],
            "imported": false,
            "current_name": "clear_interrupt_flag_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "execute_default_function_00000dc0"
            },
            "code": "void execute_default_function_00000dc0(void)\n{\n  execute_default_function_00000dc0();\n  return;\n}",
            "called": [
                "dummy_handler_default"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "execute_default_function_00000dc0"
        },
        "FUN_00000ca0": {
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PTR_s_USAGE_FAULT_HANDLER_00000cac": "usage_fault_handler"
            },
            "code": "void handle_usage_fault_00000ca0(void)\n{\n    core_panic(PANIC_USAGE_FAULT, PTR_s_USAGE_FAULT_HANDLER_00000cac);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ca0",
            "calling": [],
            "imported": false,
            "current_name": "handle_usage_fault_00000ca0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enableIRQinterrupts_if_privileged_mode_00000d0c",
                "state": "irq_interrupt_state",
                "bVar1": "is_privileged_mode",
                "enableIRQinterrupts": "enable_irq_interrupts"
            },
            "code": "void enableIRQinterrupts_if_privileged_mode_00000d0c(uint state)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    bool enable_irq_interrupts = (state & 1) == 1;\n    enableIRQinterrupts(enable_irq_interrupts);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "enableIRQinterrupts_if_privileged_mode_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "write_saul_register_00003d94",
                "dev": "saul_register",
                "data": "data",
                "iVar1": "result"
            },
            "code": "int write_saul_register_00003d94(saul_reg_t *saul_register, phydat_t *data) {\n  int result;\n  if (saul_register == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*saul_register->driver->write)(saul_register->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "write_saul_register_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "release_malloc_recursive_mutex_0000579c",
                "PTR___lock___malloc_recursive_mutex_000057a4": "lock_malloc_recursive_mutex"
            },
            "code": "void release_malloc_recursive_mutex_0000579c(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "release_malloc_recursive_mutex_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "send_data_over_uart_000015d0",
                "uart": "uart_id",
                "data": "data_to_send",
                "len": "data_length",
                "iVar1": "uart_config_offset",
                "dev": "uart_device",
                "i": "index"
            },
            "code": "void send_data_over_uart_000015d0(uart_t uart, uint8_t *data, size_t len)\n{\n  int uart_config_offset = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n  UART_Type *uart_device = (UART_Type *)uart_config_offset;\n  size_t i;\n  for (i = 0; i < len; i++) {\n    while (uart_device->STATUS & UART_STATUS_TX_FULL);\n    uart_device->DATA = data[i];\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "uart_stdio_write"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_000015d0"
        },
        "FUN_00004cdc": {
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "file_pointer",
                "param_2": "string_to_print",
                "cVar1": "current_char",
                "iVar2": "setup_result",
                "pcVar3": "buffer_pointer",
                "ppcVar4": "file_pointer_array",
                "uVar5": "return_value",
                "pcVar6": "string_pointer"
            },
            "code": "undefined4 print_string_00004cdc(int file_pointer, char *string_to_print)\n{\n  char current_char;\n  int setup_result;\n  char *buffer_pointer;\n  char **file_pointer_array;\n  undefined4 return_value;\n  char *string_pointer;\n  \n  if ((file_pointer != 0) && (*(int *)(file_pointer + 0x18) == 0)) {\n    __sinit();\n  }\n  file_pointer_array = *(char ***)(file_pointer + 8);\n  if (*(int *)(file_pointer + 0x18) == 0) {\n    __sinit(file_pointer);\n  }\n  if (file_pointer_array == (char **)PTR___sf_fake_stdin_00004dac) {\n    file_pointer_array = *(char ***)(file_pointer + 4);\n  }\n  else if (file_pointer_array == (char **)PTR___sf_fake_stdout_00004db0) {\n    file_pointer_array = *(char ***)(file_pointer + 8);\n  }\n  else if (file_pointer_array == (char **)PTR___sf_fake_stderr_00004db4) {\n    file_pointer_array = *(char ***)(file_pointer + 0xc);\n  }\n  if ((-1 < (int)file_pointer_array[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_pointer_array + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(file_pointer_array[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(file_pointer_array + 3) << 0x1c) < 0) && (file_pointer_array[4] != (char *)0x0)) || (setup_result = __swsetup_r(file_pointer,file_pointer_array), setup_result == 0)) {\n    string_pointer = string_to_print - 1;\n    do {\n      while( true ) {\n        string_pointer = string_pointer + 1;\n        current_char = *string_pointer;\n        buffer_pointer = file_pointer_array[2] + -1;\n        file_pointer_array[2] = buffer_pointer;\n        if (current_char == '\\0') {\n          if (-1 < (int)buffer_pointer) {\n            string_pointer = *file_pointer_array;\n            return_value = 10;\n            *file_pointer_array = string_pointer + 1;\n            *string_pointer = '\\n';\n            goto LAB_00004d64;\n          }\n          setup_result = __swbuf_r(file_pointer,10,file_pointer_array);\n          if (setup_result != -1) {\n            return_value = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)buffer_pointer < 0) && (((int)buffer_pointer < (int)file_pointer_array[6] || (current_char == '\\n')))) break;\n        buffer_pointer = *file_pointer_array;\n        *file_pointer_array = buffer_pointer + 1;\n        *buffer_pointer = current_char;\n      }\n      setup_result = __swbuf_r(file_pointer,current_char,file_pointer_array);\n    } while (setup_result != -1);\n  }\nLAB_00004d60:\n  return_value = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)file_pointer_array[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_pointer_array + 3) << 0x16))) {\n    __retarget_lock_release_recursive(file_pointer_array[0x16]);\n  }\n  return return_value;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__swsetup_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cdc",
            "calling": [
                "puts"
            ],
            "imported": false,
            "current_name": "print_string_00004cdc"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "scan_formatted_string_00005e68",
                "__s": "destination",
                "__format": "format",
                "local_80": "destination_start",
                "local_7c": "destination_length",
                "local_74": "field_width",
                "local_72": "field_precision",
                "local_70": "format_start",
                "local_6c": "format_length"
            },
            "code": "int scan_formatted_string_00005e68(char *destination, char *format, ...) {\n  int result;\n  va_list arguments;\n  size_t destination_length;\n  char *destination_start;\n  size_t destination_size;\n  unsigned short int field_width = 0x204;\n  unsigned short int field_precision = 0xffff;\n  char *format_start;\n  size_t format_length;\n  undefined4 local_5c;\n  undefined4 local_4c;\n  undefined4 local_38;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  destination_start = destination;\n  destination_size = strlen(destination);\n  local_5c = DAT_00005eb4;\n  local_4c = 0;\n  local_38 = 0;\n  format_start = format;\n  format_length = strlen(format);\n  \n  va_start(arguments, format);\n  result = __ssvfiscanf_r(*(undefined4 *)PTR__impure_ptr_00005eb8, &destination_start, format_start, &arguments);\n  va_end(arguments);\n  \n  return result;\n}",
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "scan_formatted_string_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_values_in_data_array_00000dcc",
                "DAT_00000df0": "data_array"
            },
            "code": "void set_values_in_data_array_00000dcc(void)\n{\n    DAT_00000df0[7] = 0xc520;\n    DAT_00000df0[7] = 0xd928;\n    *DAT_00000df0 = 0xd2;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "set_values_in_data_array_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_RTC_counter_0000285c",
                "counter": "new_counter",
                "puVar1": "counter_ptr",
                "rtt": "rtc"
            },
            "code": "void set_RTC_counter_0000285c(uint32_t counter)\n{\n  uint32_t *counter_ptr;\n  RTC_Type *rtc;\n  counter_ptr = DAT_00002890;\n  DAT_00002890[5] = DAT_00002890[5] & 0xffffffef;\n  *counter_ptr = counter;\n  counter_ptr[5] = counter_ptr[5] | 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "rtc_set_time"
            ],
            "imported": false,
            "current_name": "set_RTC_counter_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "disable_irq_and_enter_infinite_loop_00000e58",
                "irq_disable": "disable_irq",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void disable_irq_and_enter_infinite_loop_00000e58(void)\n{\n  disable_irq();\n  while( true )\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "irq_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "disable_irq_and_enter_infinite_loop_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_and_clear_another_00001778",
                "DAT_000017d0": "data_ptr",
                "DAT_000017d8": "bitwise_data",
                "*DAT_000017d0": "*data_ptr",
                "*(byte *)(DAT_000017d0 + 1)": "*data_ptr",
                "*(byte *)(DAT_000017d0 + 1) & 0xcf | 0x20": "(*data_ptr & 0xCF) | 0x20",
                "bit_clear8(DAT_000017d8,'\\x02')": "bit_clear8(bitwise_data, 0x02)"
            },
            "code": "void set_bit_and_clear_another_00001778(void)\n{\n  byte* DAT_000017d0 = (byte*)(DAT_000017d0 + 1);\n  *DAT_000017d0 = *(byte *)(DAT_000017d0 + 1) & 0xcf | 0x20;\n  bit_clear8(DAT_000017d8, 0x02);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_another_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "power_on_rtt_000026d8"
            },
            "code": "void power_on_rtt_000026d8(void)\n{\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_on_rtt_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zero_bits_00000566",
                "v": "value",
                "bVar1": "byte3",
                "bVar2": "byte0",
                "bVar3": "byte1",
                "bVar4": "byte2",
                "uVar5": "result"
            },
            "code": "uint count_leading_zero_bits_00000566(uint value) {\n  byte byte0 = (byte)value;\n  byte byte1 = (byte)(value >> 8);\n  byte byte2 = (byte)(value >> 16);\n  byte byte3 = (byte)(value >> 24);\n  uint result = count_leading_zeroes((uint)(byte)((byte0 & 1) << 7 | (byte0 & 0xfe) >> 1) << 24 | (uint)(byte)((byte1 & 1) << 7 | (byte1 & 0xfe) >> 1) << 16 | (uint)(byte)((byte2 & 1) << 7 | (byte2 & 0xfe) >> 1) << 8 | (uint)(byte)((byte3 & 1) << 7 | (byte3 & 0xfe) >> 1));\n  if (value == 0) {\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "sched_run"
            ],
            "imported": false,
            "current_name": "count_leading_zero_bits_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_address_from_ptr_and_bit_00001d08",
                "ptr": "ptr",
                "bit": "bit",
                "uint": "unsigned int",
                "lower_bits": "lower_bits",
                "upper_bits": "upper_bits",
                "shifted_lower_bits": "shifted_lower_bits",
                "added_bits": "added_bits"
            },
            "code": "void * calculate_address_from_ptr_and_bit_00001d08(void *ptr, uintptr_t bit) {\n    uint lower_bits = (uint)ptr & 0xfffff;\n    uint upper_bits = (uint)ptr & 0xf0000000;\n    uint shifted_lower_bits = lower_bits << 5;\n    uint added_bits = shifted_lower_bits + upper_bits + 0x2000000;\n    return (void *)(bit * 4 + added_bits);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_ptr_and_bit_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "year",
                "month": "month",
                "day": "day",
                "bVar1": "adjusted_month",
                "iVar2": "century",
                "iVar3": "year_in_century",
                "DAT_00003280": "magic_number_1",
                "PTR_t_00003284": "magic_array",
                "DAT_00003288": "magic_number_2"
            },
            "code": "int calculate_day_of_week_000031fc(int year, int month, int day) {\n  int adjusted_month = month;\n  if (month < 3) {\n    adjusted_month = 13 + month;\n    year--;\n  }\n  int century = year / 100;\n  int year_in_century = year % 100;\n  int adjusted_day = day + (26 * (adjusted_month + 1)) / 10 + year_in_century + year_in_century / 4 + century / 4 + 5 * century;\n  int day_of_week = adjusted_day % 7;\n  if (day_of_week < 0) {\n    day_of_week += 7;\n  }\n  return day_of_week;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "_parse_time"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_bit_at_position_000016ec",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bitband_address"
            },
            "code": "void set_bit_at_position_000016ec(uint8_t *data, uint8_t position) {\n  uint32_t *bitband_address = bitband_addr(data, (uint32_t)position);\n  *bitband_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016ec"
        },
        "FUN_00004e8c": {
            "renaming": {
                "_strtol_l_isra_0": "convert_string_to_long",
                "param_1": "result",
                "param_2": "str",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char",
                "uVar3": "is_digit",
                "uVar4": "digit",
                "uVar6": "max_value",
                "uVar7": "max_dividend",
                "iVar5": "overflow",
                "pbVar8": "prev_char",
                "pbVar9": "ptr",
                "FUN_00004e8c": "convert_string_to_long_00004e8c"
            },
            "code": "uint convert_string_to_long_00004e8c(undefined4 *result, byte *str, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint max_value;\n  uint overflow;\n  uint value = 0;\n  byte *ptr = str;\n  while (*ptr && isspace(*ptr)) {\n    ++ptr;\n  }\n  if (*ptr == '-') {\n    is_negative = 1;\n    ++ptr;\n  }\n  else if (*ptr == '+') {\n    ++ptr;\n  }\n  if (!base) {\n    if (*ptr == '0') {\n      base = 8;\n      ++ptr;\n      if ((*ptr == 'x') || (*ptr == 'X')) {\n        base = 16;\n        ++ptr;\n      }\n    }\n    else {\n      base = 10;\n    }\n  }\n  else if (base == 16) {\n    if ((*ptr == '0') && ((*(ptr + 1) == 'x') || (*(ptr + 1) == 'X'))) {\n      ptr += 2;\n    }\n  }\n  max_value = UINT_MAX / base;\n  while (*ptr) {\n    if (isdigit(*ptr)) {\n      digit_value = *ptr - '0';\n    }\n    else if (isalpha(*ptr)) {\n      digit_value = toupper(*ptr) - 'A' + 10;\n    }\n    else {\n      break;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (value > max_value) {\n      overflow = 1;\n    }\n    else {\n      overflow = 0;\n      value *= base;\n      if (value > (UINT_MAX - digit_value)) {\n        overflow = 1;\n      }\n      else {\n        value += digit_value;\n      }\n    }\n    ++ptr;\n  }\n  if (end_ptr) {\n    *end_ptr = ptr;\n  }\n  if (overflow) {\n    *result = is_negative ? 0 : UINT_MAX;\n    return UINT_MAX;\n  }\n  else {\n    *result = is_negative ? -value : value;\n    return 0;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e8c",
            "calling": [
                "_strtol_r",
                "strtol"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004e8c"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "execute_impure_ptr_function_00005100",
                "FUN_00005100_r": "execute_impure_ptr_function_recursive",
                "PTR__impure_ptr_00005108": "impure_ptr"
            },
            "code": "void execute_impure_ptr_function_00005100(void)\n{\n  execute_impure_ptr_function_00005100_recursive(*(undefined4 *)PTR__impure_ptr_00005108);\n  return;\n}",
            "called": [
                "_tzset_unlocked_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "execute_impure_ptr_function_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584_t": "DivisionResult",
                "FUN_00005584": "divide_00005584",
                "__numer": "numerator",
                "__denom": "denominator",
                "in_r2": "remainderAbs",
                "iVar1": "remainder",
                "uVar2": "quotientAbs"
            },
            "code": "typedef struct { int quotient; int remainder; } DivisionResult; \n\nDivisionResult divide_00005584(int numerator, int denominator) {\n    uint remainderAbs = abs(denominator);\n    uint quotientAbs = abs(numerator) / remainderAbs;\n    int remainder = abs(numerator) % remainderAbs;\n    if (numerator < 0 && remainder > 0) {\n        quotientAbs--;\n        remainder = remainderAbs - remainder;\n    }\n    else if (numerator > 0 && remainder < 0) {\n        quotientAbs++;\n        remainder = -remainderAbs + remainder;\n    }\n    if (numerator < 0) quotientAbs = -quotientAbs;\n    return (DivisionResult){ quotientAbs, remainder };\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "validate_structure"
            ],
            "imported": false,
            "current_name": "divide_00005584"
        },
        "FUN_00000cb0": {
            "renaming": {
                "FUN_00000cb0": "handle_debug_monitor_00000cb0",
                "PTR_s_DEBUG_MON_HANDLER_00000cbc": "debug_mon_handler"
            },
            "code": "void handle_debug_monitor_00000cb0(void)\n{\n   core_panic(PANIC_DEBUG_MON, PTR_s_DEBUG_MON_HANDLER_00000cbc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cb0",
            "calling": [],
            "imported": false,
            "current_name": "handle_debug_monitor_00000cb0"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "_malloc_r_00004248",
                "param_1": "bytes",
                "param_2": "num_elements",
                "puVar1": "allocated_memory",
                "iVar2": "allocation_size"
            },
            "code": "_malloc_r_00004248 _malloc_r_00004248(size_t bytes, int num_elements) {\n    size_t allocation_size = (num_elements - 1) * 0x68 + 0x74;\n    undefined4 *allocated_memory = (undefined4 *)_malloc_r_00004248(bytes, allocation_size);\n    if (allocated_memory != NULL) {\n        *allocated_memory = 0;\n        allocated_memory[1] = num_elements;\n        allocated_memory[2] = allocated_memory + 3;\n        memset(allocated_memory + 3, 0, allocation_size - 0x74);\n    }\n    return allocated_memory;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "_malloc_r_00004248"
        },
        "FUN_00000f5c": {
            "renaming": {
                "FUN_00000f5c": "start_RIOT_00000f5c",
                "auto_init": "auto_initialize",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "RIOT_VERSION",
                "main": "run_main"
            },
            "code": "void * start_RIOT_00000f5c(void *arg)\n{\n  auto_initialize();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  run_main();\n  return (void *)0x0;\n}",
            "called": [
                "iprintf",
                "main",
                "auto_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f5c",
            "calling": [],
            "imported": false,
            "current_name": "start_RIOT_00000f5c"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_pin_value_00001da2",
                "pin": "gpio_pin",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int get_pin_value_00001da2(gpio_t pin) {\n    int shifted_pin = pin >> 6;\n    int masked_pin = shifted_pin & 7;\n    return masked_pin;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "clk_en",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "port_num",
                "pin": "pin_num",
                "ctx_00": "context_value",
                "ctx": "context",
                "get_ctx": "get_context_value",
                "write_map": "write_to_map"
            },
            "code": "void write_context_to_map_00001ec4(int port_num, int pin_num) {\n  int context_value;\n  int context;\n  context_value = get_context_value(port_num, pin_num);\n  write_to_map(port_num, pin_num, context_value);\n  return;\n}",
            "called": [
                "write_map",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "write_context_to_map_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_interrupt_priority_00002744",
                "IRQn": "interrupt",
                "priority": "priority",
                "DMA0_IRQn": "DMA0_interrupt",
                "*(char *)(((byte)IRQn & 0xf) + DAT_00002790 + 0x14)": "interrupt_priority_offset_a",
                "*(char *)(IRQn + DAT_00002794 + 0x300)": "interrupt_priority_offset_b"
            },
            "code": "void set_interrupt_priority_00002744(IRQn_Type interrupt, uint32_t priority) {\n  if (interrupt < DMA0_IRQn) {\n    *(char *)(((byte)interrupt & 0xf) + *(char *)(((byte)IRQn & 0xf) + DAT_00002790 + 0x14) + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interrupt + *(char *)(IRQn + DAT_00002794 + 0x300) + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_rtt_counter_to_tm_00002624",
                "time": "time_struct",
                "t": "counter_time"
            },
            "code": "int convert_rtt_counter_to_tm_00002624(tm *time)\n{\n  time_t counter_time;\n  counter_time.seconds = rtt_get_counter();\n  counter_time.nanoseconds = 0;\n  gmtime_r(&counter_time, time);\n  return 0;\n}",
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "convert_rtt_counter_to_tm_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "port_num",
                "pin": "pin_num",
                "PTR_isr_map_00001e40": "pin_map_ptr"
            },
            "code": "uint32_t get_pin_value_00001e0c(uint8_t port, uint8_t pin) {\n    uint32_t *PTR_isr_map_00001e40 = (uint32_t *)(PTR_isr_map_00001e40 + ((pin >> 3) + port * 4) * 4);\n    uint8_t pin_offset = (pin & 7U) << 2;\n    uint32_t pin_value = (*PTR_isr_map_00001e40 >> pin_offset) & 0xf;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "walk_file_000041d0",
                "__stream": "__stream",
                "iVar1": "result",
                "_fwalk_reent": "_walk_file_reentrant",
                "PTR__global_impure_ptr_000041e8": "global_impure_ptr",
                "DAT_000041ec": "impure_data",
                "_FUN_000041d0_r": "walk_file_reentrant",
                "PTR__impure_ptr_000041f0": "impure_ptr"
            },
            "code": "int walk_file_000041d0(FILE *__stream)\n{\n    int result;\n    if (__stream == NULL)\n    {\n        result = _fwalk_reent(*PTR__global_PTR__impure_ptr_000041f0_000041e8, DAT_000041ec);\n        return result;\n    }\n    result = walk_file_000041d0_reentrant(*PTR__impure_ptr_000041f0, __stream);\n    return result;\n}\n",
            "called": [
                "_fflush_r",
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "print_prompt",
                "lflush"
            ],
            "imported": false,
            "current_name": "walk_file_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "initialize_EVP_PKEY_CTX_0000459c",
                "param_1": "ctx",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "fini_array_size",
                "ppcVar4": "fini_array_start",
                "iVar5": "i",
                "PTR___fini_array_end_000045d8": "DAT___fini_array_end_000045d8",
                "PTR___fini_array_end_000045d4": "DAT___fini_array_end_000045d4",
                "PTR___fini_array_end_000045e0": "DAT___fini_array_end_000045e0",
                "PTR___fini_array_end_000045dc": "DAT___fini_array_end_000045dc"
            },
            "code": "void initialize_EVP_PKEY_CTX_0000459c(EVP_PKEY_CTX *ctx) {\n  int fini_array_size = (int)PTR___fini_array_end_000045d8 - (int)PTR___fini_array_end_000045d4;\n  code **fini_array_start = (code **)PTR___fini_array_end_000045d4;\n  for (int i = 0; i < fini_array_size >> 2; i++) {\n    ctx = (EVP_PKEY_CTX *)(*fini_array_start)();\n    fini_array_start++;\n  }\n  _init(ctx);\n  code **fini_array_end = (code **)PTR___fini_array_end_000045e0;\n  fini_array_start = (code **)PTR___fini_array_end_000045dc;\n  for (int i = 0; i < (int)fini_array_end - (int)fini_array_start >> 2; i++) {\n    (**fini_array_start)();\n    fini_array_start++;\n  }\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uart",
                "baudrate": "baudrate",
                "config": "config",
                "clk_freq": "clk_freq",
                "ubd": "ubd"
            },
            "code": "void configure_uart_000014c4(UART_Type *uart, uint32_t baudrate) {\n  byte *config = *(byte **)(uart_config + uart * 0x20);\n  uint clk_freq = *(uint *)(uart_config + uart * 0x20 + 4);\n  config[3] &= 0xf3;\n  config[2] = uart_config[uart * 0x20 + 0x1d];\n  uint16_t ubd = clk_freq / (baudrate << 4);\n  config[0] = (byte)(ubd >> 8) & 0x1f;\n  config[1] = (byte)ubd;\n  config[10] = (byte)((clk_freq << 2) / baudrate + 1 >> 1) & 0x1f;\n  config[0x10] |= 0x88;\n  if ((config[0x10] & 0x70) == 0) {\n    config[0x13] = 0;\n  }\n  else {\n    config[0x13] = (char)(2 << (config[0x10] >> 4 & 7)) - 1;\n  }\n  config[0x15] = 1;\n  config[0x11] = 0xc0;\n  config[3] |= 0x2c;\n  NVIC_EnableIRQ(uart_config[uart * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_uart_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "allocate_memory_00004b34",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "free_list_ptr",
                "piVar2": "temp_ptr",
                "extraout_r1": "extra_ptr",
                "ppiVar3": "prev_ptr",
                "ppiVar4": "new_block_prev_ptr",
                "ppiVar5": "current_ptr",
                "ppiVar6": "new_block_ptr",
                "bVar7": "is_negative"
            },
            "code": "void allocate_memory_00004b34(int* error_code, int size, int arg3, int arg4)\n{\n    bool is_negative = false;\n    int** current_ptr = NULL;\n    int** prev_ptr = NULL;\n    int** free_list = *(int***)PTR___malloc_free_list_00004bcc;\n    int** new_block_ptr = (int**)(size + -4);\n\n    if (size == 0) {\n        return;\n    }\n\n    if (*new_block_ptr < 0) {\n        is_negative = true;\n        new_block_ptr = (int**)((int)new_block_ptr + **new_block_ptr);\n    }\n\n    __malloc_lock();\n    current_ptr = free_list;\n\n    while (current_ptr != NULL) {\n        prev_ptr = current_ptr;\n        current_ptr = (int**)current_ptr[1];\n\n        if (current_ptr == NULL || current_ptr > new_block_ptr) {\n            break;\n        }\n    }\n\n    if (current_ptr == NULL) {\n        new_block_ptr[1] = NULL;\n        *prev_ptr = new_block_ptr;\n    }\n    else if (current_ptr < new_block_ptr) {\n        new_block_ptr[1] = (int*)current_ptr[1];\n        *new_block_ptr = (int*)current_ptr;\n        *prev_ptr = new_block_ptr;\n    }\n    else if (current_ptr == new_block_ptr) {\n        new_block_ptr[1] = (int*)current_ptr[1];\n        *prev_ptr = new_block_ptr;\n    }\n    else {\n        *error_code = 0xc;\n    }\n\n    __malloc_unlock(error_code, prev_ptr, current_ptr, arg4);\n    return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "__ssrefill_r",
                "_realloc_r",
                "__srefill_r",
                "__sflush_r",
                "free",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "read_file_from_pos_000004f2",
                "r": "reent",
                "fd": "file_descriptor",
                "pos": "position",
                "dir": "direction"
            },
            "code": "_off_t read_file_from_pos_000004f2(_reent *reent, int file_descriptor, _off_t position, int direction)\n{\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "read_file_from_pos_000004f2"
        },
        "FUN_0000423c": {
            "renaming": {
                "FUN_0000423c": "call_fwalk_reent_with_reent_pointer_and_fns_0000423c",
                "param_1": "reent_pointer",
                "DAT_00004244": "fns"
            },
            "code": "void call_fwalk_reent_with_reent_pointer_and_fns_0000423c(void *reent_pointer, void (*DAT_00004244)(void *))\n{\n  _fwalk_reent(reent_pointer, DAT_00004244);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000423c",
            "calling": [],
            "imported": false,
            "current_name": "call_fwalk_reent_with_reent_pointer_and_fns_0000423c"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "byte_pointer1",
                "pbVar2": "byte_pointer2",
                "uVar3": "current_character"
            },
            "code": "int compare_strings_00004e66(char *string1, char *string2, size_t length) {\n  byte *byte_pointer1;\n  byte *byte_pointer2;\n  uint current_character;\n  \n  if (length != 0) {\n    byte_pointer2 = (byte *)(string2 + length - 1);\n    byte_pointer1 = (byte *)string1;\n    do {\n      current_character = (uint)*byte_pointer1;\n      byte_pointer2 = byte_pointer2 + 1;\n      if ((current_character != *byte_pointer2) || (byte_pointer1 + 1 == (byte *)(string1 + length))) break;\n      byte_pointer1 = byte_pointer1 + 1;\n    } while (current_character != 0);\n    length = current_character - *byte_pointer2;\n  }\n  return length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "reverse_string_00005ecc",
                "__s": "input_string",
                "pcVar3": "current_char",
                "pcVar2": "next_char",
                "cVar1": "current_char_value"
            },
            "code": "size_t reverse_string_00005ecc(char* input_string) {\n  char* current_char = input_string;\n  while (*current_char != '\\0') {\n    current_char++;\n  }\n  size_t string_length = current_char - input_string;\n  return string_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "_tzset_unlocked_r",
                "siscanf"
            ],
            "imported": false,
            "current_name": "reverse_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex": "mutex",
                "_FUN_0000129c": "lock_mutex_with_timeout"
            },
            "code": "void lock_mutex_0000129c(mutex_t *mutex)\n{\n  lock_mutex_0000129c_with_timeout(mutex, 1);\n  return;\n}",
            "called": [
                "_mutex_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "lock_mutex_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "transmit_uart_data_00001628",
                "uart": "uart_index",
                "data": "transmit_data",
                "dev": "uart_device",
                "uart_config_flags": "uart_flags",
                "uart_transmit_function": "uart_transmit",
                "uart_config": "uart_config_ptr"
            },
            "code": "void transmit_uart_data_00001628(uart_t uart) {\n  uint8_t data;\n  UART_Type *uart_device;\n  uint8_t uart_config_flags = *(byte *)(*(int *)(PTR_uart_config_00001680 + uart * 0x20) + 4);\n  code *uart_transmit_function = *(code **)(PTR_config_00001684 + uart * 8);\n  int *uart_config = *(int *)(PTR_config_00001684 + uart * 8);\n\n  if ((uart_config_flags & 0x20) != 0 && *uart_config != 0) {\n    uart_transmit_function(*(undefined4 *)(uart_config + 4), *(undefined *)(*(int *)(PTR_uart_config_00001680 + uart * 0x20) + 7));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "imported": false,
            "current_name": "transmit_uart_data_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_fll_factor_00001748",
                "factor": "new_factor",
                "DAT_00001774": "PTR_dat_00001774",
                "fll_ptr": "fll_pointer",
                "current_factor": "current_fll_factor",
                "new_factor": "new_fll_factor",
                "KINETIS_MCG_FLL_FACTOR_2929": "KINETIS_MCG_FLL_FACTOR_MASK"
            },
            "code": "void set_fll_factor_00001748(kinetis_mcg_fll_t factor) {\n    kinetis_mcg_fll_t* fll_ptr = (kinetis_mcg_fll_t*)(DAT_00001774 + 3);\n    kinetis_mcg_fll_t current_factor = *fll_ptr;\n    kinetis_mcg_fll_t new_factor = factor | (current_factor & ~KINETIS_MCG_FLL_FACTOR_2929);\n    *fll_ptr = new_factor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_fll_factor_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_rtc_alarm_0000294c",
                "PTR_": "rtc",
                "DAT_0000296c": "DAT_RTC",
                "uint": "unsigned int",
                "*alarm_reg": "alarm_register"
            },
            "code": "void set_rtc_alarm_0000294c(void)\n{\n  RTC_Type *PTR_ = PTR_RTC;\n  uint *alarm_reg = (uint *)(DAT_0000296c + 0x14);\n  *alarm_reg |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "rtt_init",
                "rtc_poweron"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "lockMallocRecursiveMutex_00005790"
            },
            "code": "void lockMallocRecursiveMutex_00005790(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "lockMallocRecursiveMutex_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_standard_file_descriptor_00000534",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "is_standard_file_descriptor"
            },
            "code": "int check_standard_file_descriptor_00000534(_reent *reent, int file_descriptor) {\n    int is_standard_file_descriptor;\n    reent->_errno = 0;\n    if ((file_descriptor == 0) || (file_descriptor == 1) || (file_descriptor == 2)) {\n        is_standard_file_descriptor = 1;\n    }\n    else {\n        is_standard_file_descriptor = 0;\n    }\n    return is_standard_file_descriptor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_standard_file_descriptor_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_condition_000017dc",
                "DAT_00001820": "data_register_1",
                "DAT_00001824": "data_register_2",
                "DAT_00001828": "data_register_3"
            },
            "code": "void set_bit_and_check_condition_000017dc(void)\n{\n  set_bit32(DAT_00001820, 0x1d);\n  if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n    *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n  }\n  *DAT_00001828 = *DAT_00001828 & 0xfff3ffff | 0x80000;\n  return;\n}",
            "called": [
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_bit_and_check_condition_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "print_uart_stdio_00000410",
                "ctx": "context"
            },
            "code": "int print_uart_stdio_00000410(EVP_PKEY_CTX *context)\n{\n  print_uart_stdio_00000410();\n  return (int)context;\n}",
            "called": [
                "uart_stdio_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "print_uart_stdio_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_second_node_000005ca",
                "list": "head",
                "plVar1": "second_node",
                "first": "head",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "clist_node_t* remove_second_node_000005ca(clist_node_t* list)\n{\n  list_node* second_node = list->next;\n  if (second_node == (list_node*)0x0) {\n    return (list_node*)0x0;\n  }\n  list_node* third_node = second_node->next;\n  if (third_node == (list_node*)0x0) {\n    list->next = (list_node*)0x0;\n  }\n  else {\n    second_node->next = third_node->next;\n  }\n  return second_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "remove_second_node_000005ca"
        },
        "FUN_000043da": {
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "data_size",
                "param_2": "process_func",
                "param_3": "param_3",
                "param_4": "param_4",
                "piVar3": "data_ptr",
                "uVar5": "result",
                "iVar6": "sub_data_ptr",
                "iVar4": "sub_data_end",
                "uVar1": "process_result",
                "iVar2": "process_length"
            },
            "code": "uint process_data_000043da(int data_size, code *process_func, undefined4 param_3, undefined4 param_4)\n{\n  uint result = 0;\n  int *data_ptr = (int *)(data_size + 0x48);\n  do {\n    int sub_data_ptr = data_ptr[1];\n    int sub_data_end = data_ptr[2];\n    while (sub_data_ptr = sub_data_ptr + -1, -1 < sub_data_ptr) {\n      if ((1 < *(ushort *)(sub_data_end + 0xc)) && (iVar2 = *(short *)(sub_data_end + 0xe) + 1, iVar2 != 0)) {\n        uint process_result = (*process_func)(data_size, sub_data_end, param_3, iVar2, param_4);\n        result = result | process_result;\n      }\n      sub_data_end = sub_data_end + 0x68;\n    }\n    data_ptr = (int *)*data_ptr;\n  } while (data_ptr != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043da",
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "process_data_000043da"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "release_recursive_mutex_00005ff8",
                "PTR___lock___env_recursive_mutex_00006000": "env_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00005ff8(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00005ff8"
        },
        "FUN_00006754": {
            "renaming": {
                "FUN_00006754": "flush_file_if_not_closed_00006754",
                "param_1": "file",
                "iVar1": "flush_result"
            },
            "code": "int flush_file_if_not_closed_00006754(FILE *file) {\n  int flush_result;\n\n  if ((*(unsigned short *)&file->_IO_read_base & 9) == 9) {\n    flush_result = fflush(file);\n    return flush_result;\n  }\n  return 0;\n}",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006754",
            "calling": [],
            "imported": false,
            "current_name": "flush_file_if_not_closed_00006754"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_IRQ_priority_00002714",
                "IRQn": "IRQ_number",
                "DAT_00002740": "IRQ_PRIORITY_REGISTER_ADDRESS",
                "PTR_": "pointer_",
                "DAT_": "data_"
            },
            "code": "void set_IRQ_priority_00002714(IRQn_Type IRQn)\n{\n  int* IRQ_priority_register = (int*)(DAT_00002740 + ((uint)(int)IRQn >> 5) * 4);\n  int IRQ_priority_bit = 1 << (IRQn & 0x1fU);\n  *IRQ_priority_register = IRQ_priority_bit;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_IRQ_priority_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "handle_interrupt_000020e0",
                "DAT_000020f0": "interrupt_type",
                "2": "IRQ_TYPE"
            },
            "code": "void handle_interrupt_000020e0(void)\n{\n  int DAT_000020f0 = 2;\n  irq_handler(DAT_000020f0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020e0"
        },
        "FUN_00004f80": {
            "renaming": {
                "FUN_00004f80": "parse_number_00004f80",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "next_char",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char_value",
                "uVar3": "char_info",
                "uVar4": "digit",
                "uVar5": "compare_result",
                "uVar6": "max_value",
                "uVar7": "div_result",
                "iVar5": "overflow",
                "pbVar8": "current_char_pointer",
                "pbVar9": "next_char_pointer",
                "output_value": "output_value",
                "is_negative": "is_negative",
                "current_char": "current_char",
                "digit_value": "digit_value",
                "max_value": "max_value",
                "overflow": "overflow",
                "current_char_pointer": "current_char_pointer",
                "next_char_pointer": "next_char_pointer",
                "char_info": "char_info",
                "digit": "digit",
                "compare_result": "compare_result"
            },
            "code": "uint parse_number_00004f80(undefined4 *output, byte *input_string, byte **next_char, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint max_value = UINT_MAX / base;\n  uint output_value = 0;\n  byte *current_char = input_string;\n  while (isspace(*current_char)) {\n    current_char++;\n  }\n  if (*current_char == '-') {\n    is_negative = 1;\n    current_char++;\n  }\n  else if (*current_char == '+') {\n    current_char++;\n  }\n  if (base == 0) {\n    if (*current_char != '0') {\n      base = 10;\n    }\n    else if ((current_char[1] & 0xdf) == 'X') {\n      base = 16;\n      current_char += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  else if (base == 16 && *current_char == '0' && (current_char[1] & 0xdf) == 'X') {\n    current_char += 2;\n  }\n  while (*current_char != '\\0') {\n    if (isdigit(*current_char)) {\n      digit_value = *current_char - '0';\n    }\n    else if (isalpha(*current_char)) {\n      digit_value = (*current_char & 0xdf) - 'A' + 10;\n    }\n    else {\n      break;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (output_value > max_value || (output_value == max_value && digit_value > UINT_MAX % base)) {\n      output_value = UINT_MAX;\n      is_negative = 1;\n    }\n    else {\n      output_value = output_value * base + digit_value;\n    }\n    current_char++;\n  }\n  if (is_negative) {\n    *output = 0x22;\n    if (next_char == NULL) {\n      return UINT_MAX;\n    }\n  }\n  else {\n    *output = output_value;\n    if (next_char == NULL) {\n      return output_value;\n    }\n    if (digit_value == 0) {\n      while (isspace(*current_char)) {\n        current_char++;\n      }\n      if (*current_char != '\\0') {\n        *next_char = current_char;\n      }\n      else {\n        *next_char = NULL;\n      }\n    }\n    else {\n      *next_char = current_char;\n    }\n  }\n  return output_value;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f80",
            "calling": [],
            "imported": false,
            "current_name": "parse_number_00004f80"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "PTR___lock___env_recursive_mutex_00005ff4": "env_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_00005fec(void)\n{\n    __retarget_lock_acquire_recursive(PTR___lock___PTR___lock___env_recursive_mutex_00005ff4_00005ff4);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convertStringToLong_00004f84",
                "__nptr": "str",
                "__endptr": "endptr",
                "__base": "base",
                "lVar1": "result",
                "_FUN_00004f84_l_isra_0": "strtol"
            },
            "code": "long convertStringToLong_00004f84(char *str, char **endptr, int base){\n                    long result = strtol(str, endptr, base);\n                    return result;\n                  }",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "atoi",
                "_parse_time"
            ],
            "imported": false,
            "current_name": "convertStringToLong_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_RTC_value_000028f0",
                "rtt": "rtc_instance",
                "*(int *)(DAT_0000290c + 8)": "*(uint32_t *)(rtc_instance + 8)"
            },
            "code": "uint32_t get_RTC_value_000028f0(void)\n{\n  RTC_Type *rtc_instance = (RTC_Type *)(DAT_0000290c);\n  uint32_t rtc_value = *(int *)(DAT_0000290c + 8);\n  return rtc_value + 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "rtc_get_alarm"
            ],
            "imported": false,
            "current_name": "get_RTC_value_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "tz_info",
                "uVar2": "is_dst",
                "uVar3": "month_days",
                "iVar4": "day_of_week",
                "puVar5": "month_info",
                "iVar6": "days_since_1900",
                "uVar7": "leap_year_offset",
                "iVar8": "month_index",
                "iVar9": "day_offset",
                "uVar10": "leading_zeroes"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year)\n{\n  uint32_t *tz_info = (uint32_t *)__gettzinfo();\n  if ((int)year < 0x7b2) {\n    return 0;\n  }\n  else {\n    uint32_t leading_zeroes = count_leading_zeroes(year % 400);\n    uint32_t days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    tz_info[1] = year;\n    uint32_t *month_info = tz_info;\n    do {\n      uint32_t month_days = month_info[5];\n      if (*(char *)(month_info + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          month_days < 0x3c ? month_days = 0 : month_days = 1;\n        }\n        else {\n          month_days = 0;\n        }\n        days_since_1900 += month_days + month_info[10] + -1;\n      }\n      else if (*(char *)(month_info + 2) == 'D') {\n        days_since_1900 += month_info[10];\n      }\n      else {\n        uint32_t leap_year_offset = leading_zeroes >> 5;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          leap_year_offset = 1;\n        }\n        uint32_t month_index = 0;\n        days_since_1900 = days_since_1900;\n        while( true ) {\n          month_index++;\n          if ((int)month_info[3] <= month_index) break;\n          days_since_1900 += *(int *)(PTR___month_lengths_000050e4 + month_index * 4 + leap_year_offset * 0x30 + -4);\n        }\n        int32_t day_of_week = month_info[10] - (days_since_1900 + 4U) % 7;\n        if (day_of_week < 0) {\n          day_of_week += 7;\n        }\n        for (day_of_week = (month_info[4] - 1) * 7 + day_of_week;\n            *(int *)(PTR___month_lengths_000050e4 + month_index * 4 + leap_year_offset * 0x30 + -4) <= day_of_week;\n            day_of_week = day_of_week + -7) {\n        }\n        days_since_1900 += day_of_week;\n      }\n      uint32_t seconds_since_1970 = month_info[10] + DAT_000050e0 * days_since_1900 + month_info[6];\n      month_info[8] = seconds_since_1970;\n      month_info[9] = (int)seconds_since_1970 >> 0x1f;\n      month_info = month_info + 10;\n    } while (tz_info + 0x14 != month_info);\n    uint32_t is_dst = (uint32_t)((int)((tz_info[9] - tz_info[0x13]) - (uint32_t)(tz_info[8] < tz_info[0x12])) < 0 != (SBORROW4(tz_info[9],tz_info[0x13]) != SBORROW4(tz_info[9] - tz_info[0x13],(uint32_t)(tz_info[8] < tz_info[0x12]))));\n    return is_dst;\n  }\n}",
            "called": [
                "__gettzinfo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "write_to_file_00004dee",
                "param_1": "reentrancy_structure",
                "param_2": "file_descriptor",
                "param_3": "data_buffer",
                "param_4": "data_size",
                "*(ushort *)(param_2 + 0xc)": "flag",
                "*(short *)(param_2 + 0xe)": "offset"
            },
            "code": "void write_to_file_00004dee(_reent *reentrancy_structure, int file_descriptor, void *data_buffer, size_t data_size) {\n  int offset = *(short *)(file_descriptor + 0xe);\n  uint16_t flag = *(ushort *)(file_descriptor + 0xc);\n  if ((int)(flag << 0x17) < 0) {\n    _lseek_r(reentrancy_structure, offset, 0, 2);\n  }\n  *(ushort *)(file_descriptor + 0xc) = flag & 0xefff;\n  _write_r(reentrancy_structure, offset, data_buffer, data_size);\n  return;\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "circular_buffer_t",
                "c": "temp_buffer",
                "size": "size",
                "PTR_assert_crash_message_00001030": "PTR_assert_crash_message_00001030"
            },
            "code": "void initialize_circular_buffer_00000fec(circular_buffer_t *buffer, uint32_t size) {\n  circular_buffer_t temp_buffer;\n  if ((size & (size - 1)) != 0) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00001030);\n  }\n  buffer->read_count = 0;\n  buffer->write_count = 0;\n  buffer->mask = size - 1;\n  return;\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "<original_function_name>": "allocate_memory",
                "r": "reent",
                "incr": "increment",
                "state_00": "disable_interrupts_state",
                "state": "interrupt_state",
                "res": "result",
                "PTR_heap_top_00000484": "PTR_heap_top",
                "PTR__eram_00000488": "PTR__eram",
                "PTR__sheap_0000048c": "PTR__sheap",
                "FUN_00000428": "allocate_memory_00000428"
            },
            "code": "void * allocate_memory_00000428(_reent *reent, ptrdiff_t increment){\n                      uint disable_interrupts_state;\n                      uint interrupt_state;\n                      void *result;\n\n                      disable_interrupts_state = disable_interrupts();\n                      result = *(void **)PTR_heap_top_00000484;\n                      if ((PTR__eram_00000488 < (undefined *)(increment + *(int *)PTR_heap_top_00000484)) || ((undefined *)(increment + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) {\n                        reent->_errno = 0xc;\n                        result = (void *)0xffffffff;\n                      } else {\n                        *(ptrdiff_t *)PTR_heap_top_00000484 = increment + *(int *)PTR_heap_top_00000484;\n                      }\n                      restore_interrupts(disable_interrupts_state);\n                      return result;\n                    }",
            "called": [
                "irq_disable",
                "irq_restore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "get_class_name_000039e8"
            },
            "code": "char* get_class_name_000039e8(uint8_t class_id)\\n{\\n  char* class_name = PTR_s_CLASS_UNKNOWN_00003d20;\\n  switch(class_id) {\\n    case \"\\0\":\\n      class_name = PTR_s_CLASS_UNDEF_00003cc0;\\n      break;\\n    case \"@\":\\n      class_name = PTR_s_ACT_ANY_00003cc4;\\n      break;\\n    case \"B\":\\n      class_name = PTR_s_ACT_LED_RGB_00003cc8;\\n      break;\\n    case \"C\":\\n      class_name = PTR_s_ACT_SERVO_00003ccc;\\n      break;\\n    case \"D\":\\n      class_name = PTR_s_ACT_MOTOR_00003cd0;\\n      break;\\n    case \"E\":\\n      class_name = PTR_s_ACT_SWITCH_00003cd4;\\n      break;\\n    case \"F\":\\n      class_name = PTR_s_ACT_DIMMER_00003cd8;\\n      break;\\n    case 0x80:\\n      class_name = PTR_s_SENSE_ANY_00003cdc;\\n      break;\\n    case 0x81:\\n      class_name = PTR_s_SENSE_BTN_00003ce0;\\n      break;\\n    case 0x82:\\n      class_name = PTR_s_SENSE_TEMP_00003ce4;\\n      break;\\n    case 0x83:\\n      class_name = PTR_s_SENSE_HUM_00003ce8;\\n      break;\\n    case 0x84:\\n      class_name = PTR_s_SENSE_LIGHT_00003cec;\\n      break;\\n    case 0x85:\\n      class_name = PTR_s_SENSE_ACCEL_00003cf0;\\n      break;\\n    case 0x86:\\n      class_name = PTR_s_SENSE_MAG_00003cf4;\\n      break;\\n    case 0x87:\\n      class_name = PTR_s_SENSE_GYRO_00003cf8;\\n      break;\\n    case 0x88:\\n      class_name = PTR_s_SENSE_COLOR_00003cfc;\\n      break;\\n    case 0x89:\\n      class_name = PTR_s_SENSE_PRESS_00003d00;\\n      break;\\n    case 0x8a:\\n      class_name = PTR_s_SENSE_ANALOG_00003d04;\\n      break;\\n    case 0x8b:\\n      class_name = PTR_s_SENSE_UV_00003d08;\\n      break;\\n    case 0x8c:\\n      class_name = PTR_s_SENSE_OBJTEMP_00003d0c;\\n      break;\\n    case 0x8d:\\n      class_name = PTR_s_SENSE_PULSE_COUNT_00003d10;\\n      break;\\n    case 0x8e:\\n      class_name = PTR_s_SENSE_DISTANCE_00003d14;\\n      break;\\n    case 0x8f:\\n      class_name = PTR_s_SENSE_CO2_00003d18;\\n      break;\\n    case \" \": case \"!\": case \"\\\"\": case \"#\": case \"$\": case \"%\": case \"&\": case \"\\\"\": case \"(\": case \")\": case \"*\": case \"+\": case \",\": case \"-\": case \".\": case \"/\": case \"0\" ... \"z\": case \"{\": case \"|\": case \"}\": case \"~\": case \"\\x7f\":\\n      break;\\n    default:\\n      if (class_id == 0xff) {\\n        return PTR_s_CLASS_ANY_00003d1c;\\n      }\\n  }\\n  return class_name;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "probe",
                "list"
            ],
            "imported": false,
            "current_name": "get_class_name_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "send_buffer_via_uart_00000e38",
                "buffer": "buffer_to_send",
                "len": "buffer_length"
            },
            "code": "int send_buffer_via_uart_00000e38(char *buffer_to_send, int buffer_length) {\n  uart_write(0, (uint8_t *)buffer_to_send, buffer_length);\n  return buffer_length;\n}",
            "called": [
                "uart_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_buffer_via_uart_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_full_00002294",
                "rb": "ring_buffer",
                "bVar1": "is_full_byte",
                "uVar2": "buffer_size",
                "bVar3": "is_buffer_full"
            },
            "code": "uint8_t is_full_00002294(tsrb_t *ring_buffer) {\n  uint8_t is_full_00002294 = 0;\n  uint16_t buffer_size = ring_buffer->size;\n  bool is_buffer_full = ring_buffer->writes - ring_buffer->reads == buffer_size;\n  if(is_buffer_full) {\n    is_full_00002294 = 1;\n  }\n  return is_full_00002294;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "is_full_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "print_formatted_integer_00003e9e",
                "out": "output_buffer",
                "val": "value",
                "fp_digits": "decimal_places",
                "sVar1": "buffer_len",
                "fmt_s32_dfp": "format_s32_decimal"
            },
            "code": "size_t print_formatted_integer_00003e9e(char *output_buffer, int16_t value, int decimal_places) {\n  size_t buffer_len = format_s32_decimal(output_buffer, (int)value, decimal_places);\n  return buffer_len;\n}",
            "called": [
                "fmt_s32_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "print_formatted_integer_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "print_time_00003378",
                "time": "time",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "iprintf",
                "tm_year": "year",
                "tm_mon": "month",
                "tm_mday": "day",
                "tm_hour": "hour",
                "tm_min": "minute",
                "tm_sec": "second"
            },
            "code": "int print_time_00003378(tm *time)\n{\n  int year = time->tm_year + 0x76c;\n  int month = time->tm_mon + 1;\n  int day = time->tm_mday;\n  int hour = time->tm_hour;\n  int minute = time->tm_min;\n  int second = time->tm_sec;\n  PTR_s__04i__02i__02i__02i__02i__02i_000033bc(\"%04d-%02d-%02d %02d:%02d:%02d\", year, month, day, hour, minute, second);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "print_time_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "processInputOutput_00006768",
                "param_1": "inputBuffer",
                "param_2": "outputBuffer",
                "param_3": "bufferLength",
                "param_4": "param_4",
                "uVar1": "flags",
                "iVar2": "result",
                "uVar3": "returnValue",
                "uVar4": "length",
                "uVar5": "temp"
            },
            "code": "undefined4 processInputOutput_00006768(undefined4 *inputBuffer, undefined4 *outputBuffer, undefined4 bufferLength, undefined4 param_4) {\n  ushort flags;\n  int result;\n  undefined4 returnValue;\n  uint length;\n  if ((inputBuffer != (undefined4 *)0x0) && (inputBuffer[6] == 0)) {\n    __sinit();\n  }\n  if (outputBuffer == (undefined4 *)PTR___sf_fake_stdin_00006868) {\n    outputBuffer = (undefined4 *)inputBuffer[1];\n  }\n  else if (outputBuffer == (undefined4 *)PTR___sf_fake_stdout_0000686c) {\n    outputBuffer = (undefined4 *)inputBuffer[2];\n  }\n  else if (outputBuffer == (undefined4 *)PTR___sf_fake_stderr_00006870) {\n    outputBuffer = (undefined4 *)inputBuffer[3];\n  }\n  length = (uint)*(ushort *)(outputBuffer + 3);\n  outputBuffer[1] = 0;\n  if ((int)(length << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(length << 0x1d) < 0) {\n    if ((undefined4 *)outputBuffer[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)outputBuffer[0xd] != outputBuffer + 0x11) {\n        _free_r(inputBuffer);\n      }\n      outputBuffer[1] = outputBuffer[0x10];\n      outputBuffer[0xd] = 0;\n      if (outputBuffer[0x10] != 0) {\n        *outputBuffer = outputBuffer[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(length << 0x1b)) {\n      *inputBuffer = 9;\n      flags = flags | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(length << 0x1c) < 0) {\n      result = _fflush_r(inputBuffer, outputBuffer, length << 0x1c, length, param_4);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      outputBuffer[2] = 0;\n      *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) & 0xfff7;\n      outputBuffer[6] = 0;\n    }\n    *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) | 4;\n  }\n  if (outputBuffer[4] == 0) {\n    __smakebuf_r(inputBuffer, outputBuffer);\n  }\n  flags = *(ushort *)(outputBuffer + 3);\n  returnValue = outputBuffer[4];\n  result = (*(code *)outputBuffer[9])(inputBuffer, outputBuffer[8], returnValue, outputBuffer[5]);\n  outputBuffer[1] = result;\n  if (0 < result) {\n    return 0;\n  }\n  flags = flags | 0x20;\n  if (result != 0) {\n    outputBuffer[1] = returnValue;\n    flags = flags | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(outputBuffer + 3) = flags;\n  return 0xffffffff;\n}",
            "called": [
                "_fwalk",
                "__sflush_r",
                "_free_r",
                "_fflush_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "__srget_r"
            ],
            "imported": false,
            "current_name": "processInputOutput_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "code": "void disable_watchdog_and_fix_cpu_errata_00000db0(void)\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}",
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "convert_tm_to_counter_and_set_rtt_00002600",
                "time": "time_input",
                "t": "time",
                "counter": "counter",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int convert_tm_to_counter_and_set_rtt_00002600(tm *time_input)\n{\n  uint32_t counter;\n  time_t time;\n  time = mktime(time_input);\n  rtt_set_counter(counter);\n  return 0;\n}",
            "called": [
                "rtt_set_counter",
                "mktime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "convert_tm_to_counter_and_set_rtt_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_unit_name_00003810",
                "unit": "unit_code",
                "pcVar1": "unit_name",
                "PTR_DAT_00003914": "default_unit_name",
                "PTR_DAT_000038cc": "unit_name_1",
                "PTR_DAT_000038d0": "unit_name_2",
                "PTR_DAT_000038d4": "unit_name_3",
                "PTR_PTR_s_R_000038d8": "unit_name_4",
                "PTR_DAT_000038dc": "unit_name_5",
                "PTR_DAT_000038e0": "unit_name_6",
                "PTR_DAT_000038e4": "unit_name_7",
                "PTR_DAT_000038e8": "unit_name_8",
                "PTR_DAT_000038ec": "unit_name_9",
                "PTR_DAT_000038f0": "unit_name_10",
                "PTR_DAT_000038f4": "unit_name_11",
                "PTR_DAT_000038f8": "unit_name_12",
                "PTR_DAT_000038fc": "unit_name_13",
                "PTR_DAT_00003900": "unit_name_14",
                "PTR_DAT_00003904": "unit_name_15",
                "PTR_DAT_0000390c": "unit_name_16",
                "PTR_DAT_00003910": "unit_name_17"
            },
            "code": "char* get_unit_name_00003810(uint8_t unit) {\n    char* unit_name;\n    switch(unit) {\n        case 0x02:\n            unit_name = PTR_DAT_000038cc;\n            break;\n        case 0x03:\n            unit_name = PTR_DAT_000038d0;\n            break;\n        case 0x04:\n            unit_name = PTR_DAT_000038d4;\n            break;\n        case 0x05:\n            unit_name = PTR_PTR_s_R_000038d8;\n            break;\n        case 0x06:\n            unit_name = PTR_DAT_000038dc;\n            break;\n        case 0x07:\n            unit_name = PTR_DAT_000038e0;\n            break;\n        case 0x08:\n            unit_name = PTR_DAT_000038e4;\n            break;\n        case 0x09:\n            unit_name = PTR_DAT_000038e8;\n            break;\n        case 0x0a:\n            unit_name = PTR_DAT_000038ec;\n            break;\n        case 0x0b:\n            unit_name = PTR_DAT_000038f0;\n            break;\n        case 0x0c:\n            unit_name = PTR_DAT_000038f4;\n            break;\n        case 0x0d:\n            unit_name = PTR_DAT_000038f8;\n            break;\n        case 0x0e:\n            unit_name = PTR_DAT_000038fc;\n            break;\n        case 0x0f:\n            unit_name = PTR_DAT_00003900;\n            break;\n        case 0x10:\n            unit_name = PTR_DAT_00003904;\n            break;\n        case 0x11:\n            unit_name = PTR_DAT_0000390c;\n            break;\n        case 0x13:\n            unit_name = PTR_DAT_00003910;\n            break;\n        case 0x15:\n            unit_name = PTR_DAT_000038cc8;\n            break;\n        default:\n            unit_name = PTR_DAT_00003914;\n            break;\n    }\n    return unit_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_unit_name_00003810"
        },
        "FUN_0000041c": {
            "renaming": {
                "FUN_0000041c": "do_nothing_0000041c"
            },
            "code": "\nvoid do_nothing_0000041c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000041c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0000041c"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "printLRValue_00000ed8",
                "in_lr": "lr_value",
                "lr_ptr": "lr_pointer",
                "PTR_DAT_00000ef4": "LR Value: %08X\\n"
            },
            "code": "void printLRValue_00000ed8(uint32_t *lr_pointer)\n{\n  uint32_t lr_value = *lr_pointer;\n  iprintf(\"PTR_DAT_00000ef4\", lr_value);\n  return;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "printLRValue_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "print_alarm_000031e0",
                "PTR_s_The_alarm_rang_000031f8": "alarm_message"
            },
            "code": "void print_alarm_000031e0(void *arg)\n{\n  char* PTR_s_The_alarm_rang_000031f8 = \"The alarm rang\";\n  puts(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "print_alarm_000031e0"
        },
        "FUN_000004d4": {
            "renaming": {
                "FUN_000004d4": "set_errno_to_19_000004d4",
                "r": "reent_ptr",
                "fd": "file_descriptor",
                "_errno": "_errno"
            },
            "code": "int set_errno_to_19_000004d4(_reent *reent_ptr, int file_descriptor)\n{\n  reent_ptr->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004d4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "set_errno_to_19_000004d4"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "handle_interrupt_000020f4",
                "DAT_00002104": "interrupt_data"
            },
            "code": "void handle_interrupt_000020f4(void)\n{\n    irq_handler(DAT_00002104, 3);\n    return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverseAndNegate_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "outputPtr",
                "uVar2": "charIndex2",
                "iVar3": "outputLength",
                "uVar4": "currentChar",
                "uVar5": "charIndex",
                "uVar6": "charIndex2",
                "bVar7": "isNegated"
            },
            "code": "byte * reverseAndNegate_0000687c(int length, byte *input)\n{\n  byte *outputPtr;\n  uint currentChar = (uint)*input;\n  bool isNegated = currentChar == 0x5e;\n  if (isNegated) {\n    currentChar = (uint)input[1];\n    input = input + 2;\n  }\n  else {\n    input = input + 1;\n  }\n  int outputLength = length + 0xfe;\n  do {\n    length = length + 1;\n    *(bool *)length = isNegated;\n  } while (length != outputLength);\n  if (currentChar == 0) {\n    outputPtr = input + -1;\n  }\n  else {\n    do {\n      uint charIndex = currentChar;\n      *(bool *)(length + charIndex) = !isNegated;\n      input = input + 1;\n      while (true) {\n        currentChar = (uint)input[-1];\n        if (currentChar != 0x2d) break;\n        uint charIndex2 = (uint)*input;\n        if ((charIndex2 == 0x5d) || (currentChar < charIndex2)) goto LAB_000068aa;\n        do {\n          charIndex = charIndex + 1;\n          *(bool *)(length + charIndex) = !isNegated;\n        } while (charIndex < charIndex2);\n        int charDiff = ~currentChar + charIndex2;\n        if (charIndex2 <= currentChar) {\n          charDiff = 0;\n        }\n        currentChar = currentChar + 1 + charDiff;\n        input = input + 2;\n      }\n      outputPtr = input + -1;\n    } while ((currentChar != 0x5d) && (outputPtr = input + -1, currentChar != 0));\n  }\n  return outputPtr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reverseAndNegate_0000687c"
        },
        "FUN_00004dea": {
            "renaming": {
                "FUN_00004dea": "return_zero_00004dea"
            },
            "code": "int return_zero_00004dea(void)\n{\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dea",
            "calling": [],
            "imported": false,
            "current_name": "return_zero_00004dea"
        },
        "FUN_00005edc": {
            "renaming": {
                "_strtoul_l_isra_0": "convert_string_to_unsigned_int",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char_value",
                "bVar3": "is_digit",
                "iVar4": "loop_status",
                "uVar5": "digit_value",
                "uVar6": "max_value",
                "pbVar7": "current_char",
                "pbVar8": "next_char",
                "is_whitespace": "is_whitespace",
                "is_valid_digit": "is_valid_digit",
                "PTR_DAT_00005fd0": "PTR_DAT_00005fd0",
                "FUN_00005edc": "convert_string_to_unsigned_int_00005edc"
            },
            "code": "uint convert_string_to_unsigned_int_00005edc(undefined4 *output, byte *input_string, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint result = 0;\n  uint max_value = 0xffffffff / base;\n  byte *current_char = input_string;\n  bool is_negative = false;\n\n  while (is_whitespace(*current_char)) {\n    current_char++;\n  }\n\n  if (*current_char == '-') {\n    is_negative = true;\n    current_char++;\n  }\n  else if (*current_char == '+') {\n    current_char++;\n  }\n\n  if (base == 0) {\n    if (*current_char != '0') {\n      base = 10;\n    }\n    else if ((current_char[1] & 0xdf) == 'X') {\n      base = 16;\n      current_char += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  else if (base == 16 && *current_char == '0' && (current_char[1] & 0xdf) == 'X') {\n    current_char += 2;\n  }\n\n  while (is_valid_digit(*current_char, base, &digit_value)) {\n    if (result > max_value || (result == max_value && digit_value > (0xffffffff % base))) {\n      *output = 0x22; // '\"'\n      result = 0xffffffff;\n      if (end_ptr == NULL) {\n        return 0xffffffff;\n      }\n      break;\n    }\n    result = result * base + digit_value;\n    current_char++;\n  }\n\n  if (is_negative) {\n    result = -result;\n  }\n\n  if (end_ptr != NULL) {\n    *end_ptr = current_char;\n  }\n\n  return result;\n}\n\nbool is_whitespace(byte c) {\n  return c == ' ' || c == '\\t' || c == '\\n' || c == '\\r';\n}\n\nbool is_valid_digit(byte c, uint base, uint *value) {\n  if ('0' <= c && c <= '9') {\n    *value = c - '0';\n    return *value < base;\n  }\n  else if ('A' <= c && c <= 'Z') {\n    *value = c - 'A' + 10;\n    return *value < base;\n  }\n  else if ('a' <= c && c <= 'z') {\n    *value = c - 'a' + 10;\n    return *value < base;\n  }\n  return false;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "imported": false,
            "current_name": "convert_string_to_unsigned_int_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "configure_gpio_pin_00001eea",
                "gpio_t": "gpio_pin_t",
                "gpio_mode_t": "gpio_pin_mode_t",
                "uVar1": "pin_number",
                "pGVar2": "gpio_register",
                "pPVar3": "port_register",
                "iVar4": "result",
                "FUN_00001eea_port": "configure_gpio_port",
                "pin_num": "get_pin_number",
                "gpio": "get_gpio_register",
                "PORT_Type": "port_register",
                "GPIO_Type": "gpio_register"
            },
            "code": "int configure_gpio_pin_00001eea(gpio_t pin, gpio_mode_t mode) {\n  uint32_t pin_number;\n  GPIO_Type *gpio_register;\n  PORT_Type *port_register;\n  int result = 0;\n  configure_gpio_port(pin, 0);\n  if (mode < GPIO_IN) {\n    pin_number = get_pin_number(pin);\n    gpio_register = get_gpio_register(pin);\n    gpio_register->PDDR |= 1 << (pin_number & 0xff);\n  } else {\n    pin_number = get_pin_number(pin);\n    gpio_register = get_gpio_register(pin);\n    gpio_register->PDDR &= ~(1 << (pin_number & 0xff));\n  }\n  port_register = get_port_register(pin);\n  int pin_index = get_pin_number(pin);\n  port_register->PCR[pin_index] = (byte)mode & 0x23 | 0x100;\n  return result;\n}",
            "called": [
                "port",
                "gpio",
                "gpio_init_port",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "command_line",
                "PTR_s_Welcome_to_RIOT__000023c4": "welcome_message",
                "shell_command_t": "shell_cmd_t",
                "startForkserver": "start_fork_server"
            },
            "code": "void run_shell_command_000023a4(void)\n{\n  char command_line[128];\n  start_fork_server(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n  shell_run((shell_command_t *)NULL, command_line, 0x80);\n}",
            "called": [
                "shell_run",
                "puts",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "run_shell_command_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "remove_first_node_0000240c",
                "list": "head",
                "plVar1": "removed_node"
            },
            "code": "list_node_t* remove_first_node_0000240c(list_node_t* head)\n{\n    list_node_t* removed_node = head->next;\n    if (removed_node != NULL)\n    {\n        head->next = removed_node->next;\n    }\n    return removed_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "remove_first_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "release_recursive_mutex_00004280",
                "PTR___lock___sfp_recursive_mutex_00004288": "sfp_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00004280(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "initialize_uart_ports_00001448",
                "uart": "uart_num",
                "PTR_uart_config_000014c0": "uart_config_ptr",
                "rx_pin": "rx_pin_num",
                "tx_pin": "tx_pin_num",
                "rx_gpio": "rx_gpio_port",
                "tx_gpio": "tx_gpio_port",
                "rx_pin_mode": "rx_pin_mode_config",
                "tx_pin_mode": "tx_pin_mode_config"
            },
            "code": "void initialize_uart_ports_00001448(uart_t uart){\n  short* PTR_uart_config_000014c0 = PTR_uart_config_000014c0 + uart * 0x20;\n  short rx_pin = *(PTR_uart_config_000014c0 + 4);\n  short tx_pin = *(PTR_uart_config_000014c0 + 5);\n  if (rx_pin != -1) {\n    gpio_t rx_gpio = *(gpio_t *)(PTR_uart_config_000014c0 + 2);\n    uint32_t rx_pin_mode = *(PTR_uart_config_000014c0 + 6);\n    gpio_init_port(rx_gpio, rx_pin_mode);\n  }\n  if (tx_pin != -1) {\n    gpio_t tx_gpio = *(gpio_t *)(PTR_uart_config_000014c0 + 3);\n    uint32_t tx_pin_mode = *(PTR_uart_config_000014c0 + 7);\n    gpio_init_port(tx_gpio, tx_pin_mode);\n  }\n  return;\n}",
            "called": [
                "gpio_init_port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_ports_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "handle_uart_interrupt_00001688"
            },
            "code": "void handle_uart_interrupt_00001688(void)\n{\n  irq_handler_uart(0);\n  return;\n}",
            "called": [
                "irq_handler_uart"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "string_to_convert",
                "lVar1": "converted_long"
            },
            "code": "long convert_string_to_long_00004042(char* string_to_convert) {\n  long converted_long = strtol(string_to_convert, (char**)0x0, 10);\n  return converted_long;\n}",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "get_IRQ_interrupts_enabled_status_00000cf0",
                "uVar2": "interrupts_enabled_status",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint get_IRQ_interrupts_enabled_status_00000cf0(void)\n{\n  bool is_privileged_mode;\n  uint32_t interrupts_enabled_status;\n  enable_IRQ_interrupts();\n  interrupts_enabled_status = 0;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    interrupts_enabled_status = isIRQinterruptsEnabled();\n  }\n  return interrupts_enabled_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "cpu_switch_context_exit"
            ],
            "imported": false,
            "current_name": "get_IRQ_interrupts_enabled_status_00000cf0"
        },
        "FUN_00006cd4": {
            "renaming": {
                "FUN_00006cd4": "do_nothing_00006cd4"
            },
            "code": "\nvoid do_nothing_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006cd4",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_00006cd4"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "start_system_00000f8c",
                "irq_disable": "disable_interrupts",
                "thread_create": "create_thread",
                "PTR_idle_stack_00000fdc": "idle_stack",
                "PTR_main_stack_00000fe8": "main_stack",
                "DAT_00000fd8": "idle_data",
                "DAT_00000fe4": "main_data",
                "PTR_idle_name_00000fd4": "idle_name",
                "PTR_main_name_00000fe0": "main_name",
                "cpu_switch_context_exit": "switch_cpu_context_exit"
            },
            "code": "void start_system_00000f8c(void)\\n{\\n    disable_interrupts();\\n    create_thread(PTR_idle_stack_00000fdc, 0x100, \"\\x0f\", 0xc, DAT_00000fd8, (void*)0x0, *(char**)PTR_idle_name_00000fd4);\\n    create_thread(PTR_main_stack_00000fe8, 0x600, \"\\a\", 0xc, DAT_00000fe4, (void*)0x0, *(char**)PTR_main_name_00000fe0);\\n    /* WARNING: Subroutine does not return */\\n    switch_cpu_context_exit();\\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "thread_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "start_system_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_alarm_00002894",
                "alarm": "alarm_time",
                "cb": "callback",
                "arg": "callback_arg",
                "iVar1": "rtt_address",
                "DAT_000028e8": "rtt_address_global_variable",
                "masked_value": "masked_value",
                "PTR_rtt_callback_000028ec": "rtt_callback_pointer_global_variable",
                "RTC_IRQn": "RTC_interrupt_number"
            },
            "code": "void set_alarm_00002894(uint32_t alarm_time, rtt_callback_t callback, void *callback_arg) {\n  int rtt_address = DAT_000028e8;\n  uint32_t masked_value = *(uint *)(rtt_address + 0x1c) & 0xfffffffb;\n  *(uint *)(rtt_address + 0x1c) = masked_value;\n  *(uint32_t *)(rtt_address + 8) = alarm_time - 1;\n  *(rtt_callback_t *)PTR_rtt_callback_000028ec = callback;\n  *(void **)(PTR_rtt_callback_000028ec + 4) = callback_arg;\n  *(uint *)(rtt_address + 0x1c) |= 4;\n  NVIC_SetPriority(RTC_IRQn, 10);\n  NVIC_EnableIRQ(RTC_IRQn);\n}\n",
            "called": [
                "NVIC_SetPriority",
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "set_alarm_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "flush_stream_if_not_empty_00004158",
                "param_1": "stream_pointer",
                "param_2": "stream_buffer",
                "uVar1": "ret_val"
            },
            "code": "int flush_stream_if_not_empty_00004158(int stream_pointer, char *stream_buffer) {\n  int ret_val;\n  if (*(int *)(stream_buffer + 0x10) != 0) {\n    if ((stream_pointer != 0) && (*(int *)(stream_pointer + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream_buffer == PTR___sf_fake_stdin_000041c4) {\n      stream_buffer = *(char **)(stream_pointer + 4);\n    }\n    else if (stream_buffer == PTR___sf_fake_stdout_000041c8) {\n      stream_buffer = *(char **)(stream_pointer + 8);\n    }\n    else if (stream_buffer == PTR___sf_fake_stderr_000041cc) {\n      stream_buffer = *(char **)(stream_pointer + 0xc);\n    }\n    if (*(short *)(stream_buffer + 0xc) != 0) {\n      if ((-1 < *(int *)(stream_buffer + 100) << 0x1f) && (-1 < (int)*(short *)(stream_buffer + 0xc) << 0x16)) {\n        __retarget_lock_acquire_recursive(*(int *)(stream_buffer + 0x58));\n      }\n      ret_val = __sflush_r(stream_pointer, stream_buffer);\n      if (*(int *)(stream_buffer + 100) << 0x1f < 0) {\n        return ret_val;\n      }\n      if ((int)((unsigned int)*(short *)(stream_buffer + 0xc) << 0x16) < 0) {\n        return ret_val;\n      }\n      __retarget_lock_release_recursive(*(int *)(stream_buffer + 0x58));\n      return ret_val;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "flush_stream_if_not_empty_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "alarm_time",
                "cb": "callback",
                "arg": "arg",
                "alarm": "alarm_seconds",
                "t": "unused_variable"
            },
            "code": "int set_rtc_alarm_00002654(tm *alarm_time, rtc_alarm_cb_t callback, void *arg) {\n  uint32_t alarm_seconds = mktime(alarm_time);\n  *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = callback;\n  rtt_set_alarm(alarm_seconds, DAT_0000268c, arg);\n  return 0;\n}",
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "_rtc_setalarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002654"
        },
        "FUN_00000aa8": {
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "exc_return": "exc_return",
                "r4_to_r11_stack": "r4_to_r11_stack",
                "iVar1": "stack_size_left",
                "uVar2": "bfar_value",
                "uVar3": "mmfar_value",
                "uVar4": "cfsr_value",
                "uVar5": "hfsr_value",
                "uVar6": "dfsr_value",
                "uVar7": "afsr_value",
                "uVar8": "r0_value",
                "uVar9": "r1_value",
                "uVar10": "r2_value",
                "uVar11": "r3_value",
                "uVar12": "r12_value",
                "stack_left": "stack_size_left",
                "psr": "psr_value",
                "lr": "lr_value",
                "r12": "r12_value",
                "r3": "r3_value",
                "r2": "r2_value",
                "r1": "r1_value",
                "r0": "r0_value",
                "afsr": "afsr_value",
                "dfsr": "dfsr_value",
                "hfsr": "hfsr_value",
                "cfsr": "cfsr_value",
                "mmfar": "mmfar_value",
                "bfar": "bfar_value",
                "orig_sp": "original_sp_pointer",
                "pc": "pc_value"
            },
            "code": "void handle_hard_fault_00000aa8(uint32_t *stack_pointer, uint32_t is_corrupted, uint32_t exc_return, uint32_t *r4_to_r11_stack)\n{\n    int stack_size_left;\n    uint32_t psr_value;\n    uint32_t lr_value;\n    uint32_t r12_value;\n    uint32_t r3_value;\n    uint32_t r2_value;\n    uint32_t r1_value;\n    uint32_t r0_value;\n    uint32_t afsr_value;\n    uint32_t dfsr_value;\n    uint32_t hfsr_value;\n    uint32_t cfsr_value;\n    uint32_t mmfar_value;\n    uint32_t bfar_value;\n    uint32_t *original_sp_pointer;\n    uint32_t program_counter_value;\n    uint32_t cfsr_bfar_valid_mask_value = *(uint *)(CFSR_BFARVALID_MASK_PTR);\n    uint32_t cfsr_mmar_valid_mask_value = *(uint *)(CFSR_MMARVALID_MASK_PTR);\n    uint32_t cfsr_value = *(uint *)(CFSR_PTR);\n    uint32_t hfsr_value = *(uint *)(HFSR_PTR);\n    uint32_t dfsr_value = *(uint *)(DFSR_PTR);\n    uint32_t afsr_value = *(uint *)(AFSR_PTR);\n    uint32_t mmfar_value = *(uint *)(MMFAR_PTR);\n    uint32_t bfar_value = *(uint *)(BFAR_PTR);\n    uint32_t pc_value = 0;\n\n    if (*(int *)ISR_STACK_PTR != ISR_STACK_LIMIT)\n    {\n        printf(\"ISR stack overflowed.\\n\");\n    }\n\n    if (is_corrupted == 0)\n    {\n        r0_value = *stack_pointer;\n        r1_value = stack_pointer[1];\n        r2_value = stack_pointer[2];\n        r3_value = stack_pointer[4];\n        r12_value = stack_pointer[5];\n        pc_value = stack_pointer[6];\n        printf(\"Context before hard fault:\\n\");\n        printf(\"r0: 0x%08lx, r1: 0x%08lx, r2: 0x%08lx\\n\", r0_value, r1_value, r2_value);\n        printf(\"r3: 0x%08lx, r12: 0x%08lx, lr: 0x%08lx, pc: 0x%08lx\\n\", r3_value, r12_value, lr_value, pc_value);\n    }\n    else\n    {\n        printf(\"Stack pointer corrupted. Resetting...\\n\");\n    }\n\n    printf(\"FSR/FAR:\\n\");\n    printf(\"CFSR: 0x%08lx\\n\", cfsr_value);\n    printf(\"HFSR: 0x%08lx\\n\", hfsr_value);\n    printf(\"DFSR: 0x%08lx\\n\", dfsr_value);\n    printf(\"AFSR: 0x%08lx\\n\", afsr_value);\n\n    if ((cfsr_value & cfsr_bfar_valid_mask_value) != 0)\n    {\n        printf(\"BFAR: 0x%08lx\\n\", bfar_value);\n    }\n\n    if ((cfsr_value & cfsr_mmar_valid_mask_value) != 0)\n    {\n        printf(\"MMFAR: 0x%08lx\\n\", mmfar_value);\n    }\n\n    printf(\"Exception return: 0x%08lx\\n\", exc_return);\n\n    if (is_corrupted == 0)\n    {\n        printf(\"Attempting to reconstruct state...\\n\");\n        printf(\"In GDB, set pc=0x%lx, frame=0, bt\\n\", pc_value);\n        stack_size_left = _stack_size_left(0x158);\n\n        if (stack_size_left < 0)\n        {\n            printf(\"ISR stack overflowed by at least %d bytes.\\n\", -stack_size_left);\n        }\n    }\n\n    software_bkpt(1);\n    core_panic(PANIC_HARD_FAULT, \"Hard fault handler\");\n}",
            "called": [
                "iprintf",
                "puts",
                "core_panic",
                "_stack_size_left"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000aa8",
            "calling": [
                "hard_fault_default"
            ],
            "imported": false,
            "current_name": "handle_hard_fault_00000aa8"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "setIRQPriority_00002538",
                "IRQn": "irqNumber",
                "priority": "irqPriority",
                "DAT_00002584": "irqRegOffset1",
                "DAT_00002588": "irqRegOffset2"
            },
            "code": "void setIRQPriority_00002538(IRQn_Type IRQn, uint32_t priority) {\n  if (IRQn < DMA0_IRQn) {\n    uint32_t regAddr = DAT_00002584 + 0x14 + ((byte)IRQn & 0xf);\n    char* reg = (char*)regAddr;\n    char priorityValue = (char)((priority & 0xff) << 4);\n    *reg = priorityValue;\n  }\n  else {\n    uint32_t regAddr = DAT_00002588 + 0x300 + IRQn;\n    char* reg = (char*)regAddr;\n    char priorityValue = (char)((priority & 0xff) << 4);\n    *reg = priorityValue;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "cortexm_init"
            ],
            "imported": false,
            "current_name": "setIRQPriority_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "file_descriptor",
                "pcVar2": "current_char",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int print_formatted_string_00004c84(char* format, ...)\n{\n    int file_descriptor = *(int*)PTR__impure_ptr_00004cb0;\n    char* current_char = format;\n    undefined4 arg1 = in_r1;\n    undefined4 arg2 = in_r2;\n    undefined4 arg3 = in_r3;\n    \n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n        __sinit(file_descriptor);\n    }\n    \n    int result = _vfprintf_r(file_descriptor, *(undefined4 *)(file_descriptor + 8), format, &arg1, current_char, &arg1);\n    return result;\n}",
            "called": [
                "_vfprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "phydat_dump",
                "_print_time",
                "ps",
                "write",
                "cpu_print_last_instruction",
                "list",
                "main_trampoline",
                "read",
                "print_help",
                "hard_fault_handler",
                "_rtc_handler",
                "core_panic",
                "_saul",
                "handle_input_line",
                "probe"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "argument_value",
                "data": "data",
                "dim": "dimensions",
                "dev": "device",
                "num": "device_number",
                "i": "i",
                "PTR_s_usage___s__s__device_id___value_0_00003154": "USAGE: %s %s %s <device_id> value...",
                "PTR_s_error__undefined_device_given_00003158": "ERROR: undefined device given",
                "PTR_s_Writing_to_device___i____s_0000315c": "Writing to device %i: %s",
                "PTR_s_error__device___i_is_not_writabl_00003160": "ERROR: device %i is not writable",
                "PTR_s_error__failure_to_FUN_0000305c_to_devic_00003164": "ERROR: failure to write to device %i",
                "PTR_s_data_successfully_written_to_dev_00003168": "Data successfully written to device %i"
            },
            "code": "void write_data_to_device_0000305c(int argument_count, char **arguments) {\n  int number_of_arguments;\n  phydat_t data;\n  int dimensions;\n  saul_reg_t *device;\n  int device_number;\n  int i;\n  if (argument_count < 4) {\n    iprintf(PTR_s_usage___s__s__device_id___value_0_00003154, *arguments, arguments[1]);\n  }\n  else {\n    device_number = atoi(arguments[2]);\n    device = saul_reg_find_nth(device_number);\n    if (device == (saul_reg_t *)0x0) {\n      puts(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(&data, 0, 8);\n      if (argument_count > 5) {\n        number_of_arguments = 6;\n      }\n      else {\n        number_of_arguments = argument_count;\n      }\n      dimensions = number_of_arguments - 3;\n      for (i = 0; i < dimensions; i++) {\n        int argument_value = atoi(arguments[i + 3]);\n        data.val[i] = (int16_t)argument_value;\n      }\n      iprintf(PTR_s_Writing_to_device___i____s_0000315c, device_number, device->name);\n      phydat_dump(&data, (uint8_t)dimensions);\n      int result = saul_reg_write_data_to_device_0000305c(device, &data);\n      if (result < 1) {\n        if (result == -0x86) {\n          iprintf(PTR_s_error__device___i_is_not_writabl_00003160, device_number);\n        }\n        else {\n          iprintf(PTR_s_error__failure_to_write_data_to_device_0000305c_to_devic_00003164, device_number);\n        }\n      }\n      else {\n        iprintf(PTR_s_data_successfully_written_to_dev_00003168, device_number);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "saul_reg_write",
                "memset",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "add_to_isrpipe_tsrb_000012b4",
                "isrpipe": "isrpipe",
                "c": "character",
                "iVar1": "add_result",
                "res": "N/A"
            },
            "code": "int add_to_isrpipe_tsrb_000012b4(isrpipe_t *isrpipe, char character){\n    int add_result = tsrb_add_one(&isrpipe->tsrb, character);\n    mutex_unlock(&isrpipe->mutex);\n    return add_result;\n}",
            "called": [
                "tsrb_add_one",
                "mutex_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "add_to_isrpipe_tsrb_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  undefined *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  uint *puVar14;\n  undefined4 uVar15;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  puVar14 = param_2;\n  uVar15 = param_3;\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    __s = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    __s = (undefined *)*puVar9;\n    pvVar6 = memchr(__s,0,param_2[1]);\n    if (pvVar6 != (void *)0x0) {\n      param_2[1] = (int)pvVar6 - (int)__s;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = __s;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)__s - (int)puVar13;\n  __s = puVar13;\nLAB_00005c84:\n  iVar4 = _printf_common(param_1,param_2,&local_24,param_3,param_4,puVar14,uVar15);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar7 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "insert_node_after_0000058e",
                "list": "current_node",
                "new_node": "new_node",
                "list_node": "clist_node_t",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void insert_node_after_0000058e(clist_node_t *current_node, clist_node_t *new_node) {\n  if (current_node->next == NULL) {\n    new_node->next = new_node;\n  }\n  else {\n    new_node->next = current_node->next;\n    current_node->next = new_node;\n  }\n  current_node->next = new_node;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "insert_node_after_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  void *local_34 [4];\n  \n  local_34[0] = *(void **)PTR_PTR_DAT_00006744;\n  local_34[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar4 = DAT_0000674c;\n  if (param_2[6] != 3) {\n    pcVar4 = DAT_00006748;\n  }\n  uVar7 = param_2[2];\n  uVar5 = uVar7 - 1;\n  if (0x15c < uVar5) {\n    unaff_r9 = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < uVar5) {\n    param_2[2] = uVar7;\n  }\n  puVar11 = param_2 + 7;\n  if (uVar5 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar12 = 0;\n  puVar10 = puVar11;\n  do {\n    pvVar1 = memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar1 != (void *)0x0) {\n      if (iVar12 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar5 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar5;\n      }\n      else if (iVar12 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar5 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 = param_2[2];\n      param_2[2] = uVar5 - 1;\n      if (uVar5 != 0) {\n        pbVar6 = *param_3;\n        *param_3 = pbVar6 + 1;\n        puVar9 = (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 = *pbVar6;\n        pbVar6 = param_3[1];\n        param_3[1] = pbVar6 + -1;\n        puVar10 = puVar9;\n        if (((int)(pbVar6 + -1) < 1) &&\n           (iVar2 = (*(code *)param_2[0x60])(param_1,param_3), iVar2 != 0)) {\n          iVar12 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 = iVar12 + 1;\n  } while (iVar12 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  __sccl(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar12 = 0;\n  while( true ) {\n    puVar9 = puVar10;\n    if (param_2[2] == 0) break;\n    pbVar6 = *param_3;\n    uVar5 = (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) == '\\0') break;\n    if ((uVar5 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar12 = iVar12 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar9 = (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 = *pbVar6;\n    }\n    pbVar6 = param_3[1];\n    param_3[1] = pbVar6 + -1;\n    if ((int)(pbVar6 + -1) < 1) {\n      iVar2 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar2 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar10 = puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar11 < puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 = (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 == puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar9 = 0;\n    uVar3 = (*pcVar4)(param_1,puVar11,0,param_2[1]);\n    puVar8 = (undefined4 *)*param_4;\n    uVar5 = *param_2;\n    *param_4 = puVar8 + 1;\n    puVar8 = (undefined4 *)*puVar8;\n    if ((uVar5 & 0x20) == 0) {\n      if ((int)(uVar5 << 0x1f) < 0) {\n        *(short *)puVar8 = (short)uVar3;\n      }\n      else {\n        *puVar8 = uVar3;\n      }\n    }\n    else {\n      *puVar8 = uVar3;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n",
            "called": [
                "__sccl",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_rtt_000025f4"
            },
            "code": "void initialize_rtt_000025f4(void)\n{\n  rtt_init();\n  return;\n}",
            "called": [
                "rtt_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "periph_init"
            ],
            "imported": false,
            "current_name": "initialize_rtt_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_00001ddc",
                "pin": "gpio_t pin",
                "iVar1": "int port_number",
                "DAT_00001e08": "DAT_00001e08",
                "bit_set32": "bit_set32"
            },
            "code": "void set_gpio_pin_00001ddc(gpio_t pin) \n{\n    int port_number = port_num(pin);\n    int bit_index = port_number + 9;\n    bit_set32(DAT_00001e08, bit_index);\n    return;\n}",
            "called": [
                "port_num",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_00002ecc",
                "num": "sensor_num",
                "dev": "sensor_device",
                "iVar1": "read_result",
                "pcVar2": "device_type",
                "pcVar3": "device_name",
                "res": "sensor_data",
                "dim": "sensor_data_dim",
                "PTR_s_error__failed_to_read_from_devic_00002f28": "error__failed_to_read_from_device",
                "PTR_s_Reading_from___i___s__s__00002f2c": "reading_from_device"
            },
            "code": "void read_sensor_data_00002ecc(int sensor_num, saul_reg_t *sensor_device) {\n  int read_result;\n  char *device_name;\n  char *device_type;\n  phydat_t sensor_data;\n  int sensor_data_dim;\n  \n  read_result = saul_reg_read(sensor_device, &sensor_data);\n  if (read_result < 1) {\n    iprintf(PTR_s_error__failed_to_read_from_devic_00002f28, sensor_num);\n  }\n  else {\n    device_name = sensor_device->name;\n    device_type = saul_class_to_str(sensor_device->driver->type);\n    iprintf(PTR_s_Reading_from___i___s__s__00002f2c, sensor_num, device_name, device_type);\n    phydat_dump(&sensor_data, (uint8_t)read_result);\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_read",
                "iprintf",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "read",
                "probe_all"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clearBitAtPosition_00000d76",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bitAddress"
            },
            "code": "void clearBitAtPosition_00000d76(uint32_t *data, uint8_t position) {\n    undefined4 *bitAddress = (undefined4 *)bitband_addr(data, (uint)position);\n    *bitAddress = 0;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "cpu_errata_fixes"
            ],
            "imported": false,
            "current_name": "clearBitAtPosition_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "write_char_to_output_buffer_000057a8",
                "param_1": "output_buffer_address",
                "param_2": "char_to_write",
                "param_3": "output_buffer_info",
                "iVar1": "remaining_buffer_space",
                "puVar2": "next_output_buffer_address"
            },
            "code": "int write_char_to_output_buffer_000057a8(undefined4 output_buffer_address, int char_to_write, undefined4 *output_buffer_info)\n{\n    int remaining_buffer_space = output_buffer_info[2] - 1;\n    output_buffer_info[2] = remaining_buffer_space;\n    if ((remaining_buffer_space < 0) && ((remaining_buffer_space < (int)output_buffer_info[6] || (char_to_write == 10)))) {\n        int buffer_flush_result = __swbuf_r();\n        return buffer_flush_result;\n    }\n    undefined *next_output_buffer_address = (undefined *)*output_buffer_info;\n    *output_buffer_info = next_output_buffer_address + 1;\n    *next_output_buffer_address = (char)char_to_write;\n    return char_to_write;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_char_to_output_buffer_000057a8"
        },
        "FUN_00004298": {
            "renaming": {
                "FUN_00004298": "release_recursive_mutex_00004298",
                "PTR___lock___sinit_recursive_mutex_000042a0": "sinit_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00004298(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004298",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004298"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_pointer_offset_00001696",
                "ptr": "original_ptr",
                "bit": "bit_shift",
                "ptr_val": "original_ptr_value",
                "high_bits": "high_order_bits",
                "low_bits": "low_order_bits",
                "offset": "pointer_offset"
            },
            "code": "void * calculate_pointer_offset_00001696(void *original_ptr, uintptr_t bit_shift) {\n  uintptr_t ptr_val = (uintptr_t)original_ptr;\n  uintptr_t high_bits = ptr_val & 0xf0000000;\n  uintptr_t low_bits = ptr_val & 0xfffff;\n  uintptr_t offset = (bit_shift * 4) + (high_bits | (low_bits << 5)) + 0x2000000;\n  return (void *)offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "bit_set8",
                "bit_clear8",
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_pointer_offset_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_used_words_000008b8",
                "num_used_words": "used_word_count",
                "ptr": "current_ptr"
            },
            "code": "int count_used_words_000008b8() {\n  ptrdiff_t used_word_count;\n  uint32_t *current_ptr;\n\n  for (current_ptr = (uint32_t *)PTR_isr_stack_000008f4; (*current_ptr == DAT_000008f8 && (current_ptr < PTR_heap_top_000008fc)); current_ptr++) {\n  }\n  used_word_count = ((int)PTR_heap_top_000008fc - (int)current_ptr) >> 2;\n  return used_word_count << 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "count_used_words_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "mutex_lock_000024bc",
                "mutex": "mutex",
                "state": "flags",
                "plVar2": "head_node",
                "process_priority": "process_priority",
                "irqstate": "flags",
                "__m____": "current_node",
                "next": "next_node",
                "process": "current_process",
                "bVar1": "process_priority"
            },
            "code": "void mutex_lock_000024bc(mutex_t *mutex)\n{\n  uint32_t flags;\n  list_node_t *head_node;\n  uint16_t process_priority;\n  clist_node_t *current_node;\n  list_node_t *next_node;\n  thread_t *current_process;\n\n  flags = disable_interrupts();\n  if (mutex->queue.next == NULL)\n  {\n    restore_interrupts(flags);\n  }\n  else if (mutex->queue.next == (list_node_t *)0xffffffff)\n  {\n    mutex->queue.next = NULL;\n    restore_interrupts(flags);\n  }\n  else\n  {\n    head_node = list_remove_head(&mutex->queue);\n    current_process = (thread_t *)(head_node - 2);\n    set_thread_status(current_process, THREAD_STATUS_BLOCKED);\n    if (mutex->queue.next == NULL)\n    {\n      mutex->queue.next = (list_node_t *)0xffffffff;\n    }\n    process_priority = *(uint16_t *)((int)&head_node[-1].next + 2);\n    restore_interrupts(flags);\n    sched_switch(process_priority);\n  }\n  return;\n}",
            "called": [
                "irq_disable",
                "irq_restore",
                "sched_set_status",
                "list_remove_head",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "mutex_lock_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "bytes_read",
                "buffer": "buffer",
                "count": "count"
            },
            "code": "_ssize_t read_from_uart_00000490(_reent *reent, int file_descriptor, void *buffer, size_t count) {\n  int bytes_read = uart_stdio_read((char *)buffer, count);\n  return bytes_read;\n}",
            "called": [
                "uart_stdio_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_from_uart_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "PTR_isr_stack_0000092c": "isr_stack_pointer"
            },
            "code": "void * get_isr_stack_pointer_0000091c(void)\n{\n  return PTR_isr_stack_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_isr_stack_pointer_0000091c"
        },
        "FUN_00005d80": {
            "renaming": {
                "FUN_00005d80": "write_to_stream_00005d80",
                "param_1": "stream_handle",
                "param_2": "character",
                "param_3": "stream",
                "iVar1": "buffer_size",
                "puVar2": "buffer_pointer"
            },
            "code": "uint write_to_stream_00005d80(int stream_handle, uint character, undefined4 *stream) {\n  int buffer_size;\n  undefined *buffer_pointer;\n\n  if ((stream_handle != 0) && (*(int *)(stream_handle + 0x18) == 0)) {\n    __sinit();\n  }\n\n  if (stream == (undefined4 *)stream_stdin) {\n    stream = *(undefined4 **)(stream_handle + 4);\n  }\n  else if (stream == (undefined4 *)stream_stdout) {\n    stream = *(undefined4 **)(stream_handle + 8);\n  }\n  else if (stream == (undefined4 *)stream_stderr) {\n    stream = *(undefined4 **)(stream_handle + 0xc);\n  }\n\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n\n  buffer_size = stream[2] + -1;\n  stream[2] = buffer_size;\n\n  if ((buffer_size < 0) && ((buffer_size < (int)stream[6] || ((character & 0xff) == 10)))) {\n    character = __swbuf_r(stream_handle, character, stream);\n  }\n  else {\n    buffer_pointer = (undefined *)*stream;\n    *stream = buffer_pointer + 1;\n    *buffer_pointer = (char)character;\n    character = character & 0xff;\n  }\n\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream[0x16]);\n  }\n\n  return character;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005d80",
            "calling": [
                "putchar"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005d80"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "configure_gpio_00001f80",
                "pin": "gpio_pin",
                "pcr": "pin_control_register",
                "pPVar1": "port",
                "iVar2": "pin_number",
                "pin_00": "unused_pin_number",
                "uVar3": "previous_pcr_value",
                "isr_state": "unused_isr_state"
            },
            "code": "void configure_gpio_00001f80(gpio_t pin, uint32_t pcr) {\n  PORT_Type *port = port(pin);\n  int pin_number = pin_num(pin);\n  uint32_t previous_pcr_value = port->PCR[pin_number];\n  port = port(pin);\n  pin_number = pin_num(pin);\n  port->PCR[pin_number] = pcr;\n  if ((previous_pcr_value & 0xf0000) != 0) {\n    int port_number = port_num(pin);\n    int pin_number = pin_num(pin);\n    ctx_clear(port_number, pin_number);\n  }\n  return;\n}",
            "called": [
                "ctx_clear",
                "clk_en",
                "port",
                "port_num",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "gpio_init",
                "uart_init_pins"
            ],
            "imported": false,
            "current_name": "configure_gpio_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_CPU_and_GPIO_pins_00000e64",
                "DAT_00000ed0": "thread_list_offset",
                "DAT_00000ed4": "gpio_48_address",
                "GPIO_OUT": "GPIO_OUTPUT",
                "0x2056": "GREEN_LED_PIN",
                "0x511a": "RED_LED_PIN",
                "0x2055": "BLUE_LED_PIN"
            },
            "code": "void initialize_CPU_and_GPIO_pins_00000e64(void)\n{\n    uint32_t *thread_list_ptr = thread_add_to_list + DAT_00000ed0 + 4;\n    *thread_list_ptr |= 0x200;\n    uint32_t *gpio_48_ptr = DAT_00000ed4 + 0x48;\n    *gpio_48_ptr &= 0xfefff8ff;\n    cpu_init();\n    gpio_init(GREEN_LED_PIN, GPIO_OUT);\n    gpio_init(RED_LED_PIN, GPIO_OUT);\n    gpio_init(BLUE_LED_PIN, GPIO_OUT);\n    gpio_set(GREEN_LED_PIN);\n    gpio_set(RED_LED_PIN);\n    gpio_set(BLUE_LED_PIN);\n    return;\n}",
            "called": [
                "gpio_set",
                "gpio_init",
                "cpu_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_CPU_and_GPIO_pins_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "power_off_rtt_000026e4",
                "rtt_poweroff": "rtt_poweroff"
            },
            "code": "void power_off_rtt_000026e4(void)\n{\n  rtt_poweroff();\n  return;\n}",
            "called": [
                "rtt_poweroff"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_off_rtt_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_address_from_bit_offset_00000d44",
                "ptr": "PTR_input_address",
                "bit": "bit_offset",
                "ptr_1": "input_address",
                "DAT_00000d4c": "upper_bits",
                "DAT_00000d50": "lower_bits",
                "DAT_00000d54": "offset"
            },
            "code": "void * calculate_address_from_bit_offset_00000d44(void *PTR_input_address, uintptr_t bit_DAT_00000d54) {\n\tuint32_t input_address = (uint32_t) PTR_input_address;\n\tuint32_t DAT_00000d4c = input_address & 0xf0000000;\n\tuint32_t DAT_00000d50 = input_address & 0xfffff;\n\tuint32_t DAT_00000d54 = (DAT_00000d50 << 5) + 0x2000000;\n\treturn (void *) (bit_DAT_00000d54 * 4 + DAT_00000d4c + DAT_00000d54);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "bit_clear32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_bit_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "process_thread",
                "status": "new_status",
                "PTR_sched_runqueues_00000730": "sched_runqueues_ptr",
                "PTR_runqueue_bitcache_00000734": "runqueue_bitcache_ptr",
                "priority": "thread_priority"
            },
            "code": "void update_process_status_00000698(thread_t *process, uint new_status) {\n    if (new_status < 9) {\n        if ((process->status > 8) && (clist_lpop((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4)), *(int *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4) == 0)) {\n            *(uint *)PTR_runqueue_bitcache_00000734 &= ~(1 << process->priority);\n        }\n    } else if (process->status < 9) {\n        clist_rpush((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4), &process->rq_entry);\n        *(uint *)PTR_runqueue_bitcache_00000734 |= 1 << process->priority;\n    }\n    process->status = (uint8_t)new_status;\n    return;\n}",
            "called": [
                "clist_lpop",
                "clist_rpush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "update_process_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "getIRQinterruptsEnabledStatus_00000cd0",
                "uVar2": "IRQinterruptsEnabledStatus",
                "bVar1": "isCurrentModePrivilegedStatus"
            },
            "code": "uint32_t getIRQinterruptsEnabledStatus_00000cd0(void)\n{\n  bool isCurrentModePrivilegedStatus;\n  uint32_t IRQinterruptsEnabledStatus;\n  uint32_t result;\n  uint32_t mask;\n  \n  IRQinterruptsEnabledStatus = 0;\n  isCurrentModePrivilegedStatus = (bool)isCurrentModePrivileged();\n  if (isCurrentModePrivilegedStatus) {\n    IRQinterruptsEnabledStatus = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return IRQinterruptsEnabledStatus;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "kinetis_mcg_init",
                "pm_off",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock",
                "core_panic",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "getIRQinterruptsEnabledStatus_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "panic_dummy_handler_00000cc0",
                "PTR_s_DUMMY_HANDLER_00000ccc": "dummy_handler"
            },
            "code": "void panic_dummy_handler_00000cc0(void)\n{\n    core_panic(PANIC_DUMMY_HANDLER, PTR_s_DUMMY_HANDLER_00000ccc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "dummy_handler"
            ],
            "imported": false,
            "current_name": "panic_dummy_handler_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_and_call_RTC_callback_00002994",
                "DAT_000029f8": "data",
                "PTR_rtt_callback_000029fc": "RTC_callback_pointer"
            },
            "code": "void check_and_call_RTC_callback_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_rtt_callback_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) &= 0xfffffffb;\n    (**(code **)PTR_rtt_callback_000029fc)(*(undefined4 *)(PTR_rtt_callback_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_rtt_callback_000029fc + 8) != 0)) {\n    (**(code **)(PTR_rtt_callback_000029fc + 8))(*(undefined4 *)(PTR_rtt_callback_000029fc + 0xc));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_and_call_RTC_callback_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "bVar1": "is_privileged_mode",
                "uVar2": "current_exception_number"
            },
            "code": "uint32_t get_current_exception_number_if_privileged_mode_00000d2a(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint32_t current_exception_number = 0;\n  if (is_privileged_mode)\n  {\n    current_exception_number = getCurrentExceptionNumber() & 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "sched_switch"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_gpio_output_high_00001ff6",
                "pin": "gpio_pin",
                "uVar1": "pin_num",
                "pGVar2": "gpio_ptr",
                "pin_num": "pin_number",
                "gpio": "get_gpio_pointer",
                "GPIO_Type": "GPIO_Type",
                "PSOR": "PSOR"
            },
            "code": "void set_gpio_output_high_00001ff6(gpio_t gpio_pin)\n{\n  uint32_t pin_num = pin_number(gpio_pin);\n  GPIO_Type *gpio_ptr = get_gpio_pointer(gpio_pin);\n  gpio_ptr->PSOR = 1 << (pin_num & 0xff);\n  return;\n}",
            "called": [
                "gpio",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "set_gpio_output_high_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_t",
                "baudrate": "uint32_t",
                "rx_cb": "uart_rx_cb_t",
                "arg": "void *",
                "PTR_assert_crash_message_0000143c": "ASSERT_CRASH_MESSAGE",
                "PTR_config_00001440": "CONFIG_RX_CALLBACK",
                "PTR_uart_config_00001444": "UART_CONFIG",
                "FUN_000013b8_pins": "initialize_uart_pins",
                "bit_set32": "set_bit"
            },
            "code": "int initialize_uart_000013b8(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_callback, void *argument) {\\n  int result;\\n  if (uart != 0) {\\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000143c);\\n  }\\n  *(uart_rx_cb_t *)PTR_config_00001440 = rx_callback;\\n  *(void **)CONFIG_ARGUMENT = argument;\\n  initialize_uart_000013b8_pins(0);\\n  set_bit(*(uint32_t **)(PTR_uart_config_00001444 + 0x18), PTR_uart_config_00001444[0x1c]);\\n  if (PTR_uart_config_00001444[0x1e] == \"\\0\") {\\n    initialize_uart_000013b8_port(0, baudrate);\\n    result = 0;\\n  }\\n  else {\\n    result = -1;\\n  }\\n  return result;\\n}",
            "called": [
                "uart_init_pins",
                "uart_init_uart",
                "core_panic",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "uart_stdio_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_000013b8"
        },
        "FUN_00000f80": {
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void *infinite_loop_00000f80(void *arg)\n{\n    while(true) {\n        // Do nothing\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f80",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_00000f80"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_shell_commands_00002a88",
                "*command_list": "*commands",
                "command_lists": "command_array",
                "i": "index",
                "*entry": "*command_entry",
                "PTR_s___20s__s_00002b04": "COMMAND_DESCRIPTION_FORMAT",
                "PTR_s_Command_00002b00": "COMMAND_LABEL",
                "PTR_s_Description_00002afc": "COMMAND_DESCRIPTION",
                "PTR_s__________________________________00002b08": "SEPARATOR",
                "0x0": "NULL",
                "shell_command_list": "DEFAULT_COMMAND_LIST"
            },
            "code": "void print_shell_commands_00002a88(shell_command_t *command_list)\n{\n  shell_command_t *command_lists[2];\n  uint32_t index;\n  shell_command_t *entry;\n  iprintf(\"%s\\t%s\\n\", \"Command\", \"Description\");\n  puts(\"--------------------------------------------------------\");\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)shell_command_list;\n  for (index = 0; index < 2; index++) {\n    entry = command_lists[index];\n    if (entry != NULL) {\n      for (; entry->name != NULL; entry++) {\n        iprintf(\"%s\\t%s\\n\", entry->name, entry->desc);\n      }\n    }\n  }\n  return;\n}\n",
            "called": [
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "print_shell_commands_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_count",
                "dev": "current_device",
                "PTR_saul_reg_00002f6c": "saul_device_pointer",
                "probe": "print_device_info",
                "PTR_DAT_00002f70": "device_info_message"
            },
            "code": "void print_saul_devices_00002f30(void)\n{\n  int device_count = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n  while (current_device != (saul_reg_t *)0x0) {\n    probe(device_count, current_device);\n    puts(PTR_DAT_00002f70);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_pin_value_00001e44",
                "port": "port_num",
                "pin": "pin_num",
                "ctx": "ctx_value",
                "iVar1": "pin_offset",
                "PTR_isr_map_00001ec0": "isr_map_ptr",
                "pin_register_ptr": "pin_register_ptr",
                "pin_mask": "pin_mask",
                "ctx_shift": "ctx_shift"
            },
            "code": "void set_pin_value_00001e44(int port_num, int pin_num, int ctx_value) {\n  int pin_offset = pin_num >> 3;\n  uint32_t* PTR_isr_map_00001ec0 = PTR_isr_map_00001ec0;\n  uint32_t* pin_register_ptr = PTR_isr_map_00001ec0 + (pin_offset + port_num * 4) * 4;\n  uint32_t pin_mask = ~(0xf << ((pin_num & 7U) << 2));\n  uint32_t ctx_shift = (pin_num & 7U) << 2;\n  *pin_register_ptr = (*pin_register_ptr & pin_mask) | (ctx_value << ctx_shift);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "set_pin_value_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_interrupt_enable_bit_00001318",
                "IRQn": "interrupt",
                "DAT_00001344": "interrupt_enable_register"
            },
            "code": "void set_interrupt_enable_bit_00001318(IRQn_Type interrupt)\n{\n    uint32_t* DAT_00001344 = (uint32_t*)(DAT_00001344 + ((uint32_t)interrupt >> 5) * 4);\n    uint32_t interrupt_enable_bit = 1 << (interrupt & 0x1fU);\n    *DAT_00001344 = interrupt_enable_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "uart_init_uart"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "N/A",
                "msp": "N/A"
            },
            "code": "void * get_main_stack_pointer_00000900(void)\n{\n  void *main_stack_pointer;\n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock_recursive",
                "PTR___lock___sfp_recursive_mutex_0000427c": "PTR_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_00004274(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "print_device_info_00002fe0",
                "argc": "argc",
                "argv": "argv",
                "iVar1": "device_id",
                "dev_00": "device",
                "dev": "N/A",
                "num": "N/A"
            },
            "code": "void print_device_info_00002fe0(int argc, char **argv)\n{\n    int device_id;\n    saul_reg_t *device;\n\n    if (argc < 3) {\n        iprintf(PTR_s_usage___s__s__device_id__all_00003050, *argv, argv[1]);\n    }\n    else {\n        if (strcmp(argv[2], PTR_DAT_00003054) == 0) {\n            probe_all();\n        }\n        else {\n            device_id = atoi(argv[2]);\n            device = saul_reg_find_nth(device_id);\n            if (device == (saul_reg_t *)0x0) {\n                puts(PTR_s_error__undefined_device_id_given_00003058);\n            }\n            else {\n                probe(device_id, device);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "probe_all",
                "strcmp",
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_device_info_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "get_gpio_pin_number_00001dc0",
                "pin": "gpio_pin",
                "MAX_NUM_PINS": "max_num_pins"
            },
            "code": "int get_gpio_pin_number_00001dc0(gpio_t pin) {\n    const int MAX_NUM_PINS = 0x3f;\n    return pin & MAX_NUM_PINS;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "gpio_set",
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_gpio_pin_number_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "DAT_00000e10": "int_flags",
                "PTR_uart_stdio_isrpipe_00000e0c": "isr_pipe"
            },
            "code": "void initialize_uart_00000df4(void)\n{\n  int baud_rate = 115200;\n  int uart_num = 0;\n  int DAT_00000e10 = 0x1c200;\n  void* PTR_uart_stdio_isrpipe_00000e0c = PTR_uart_stdio_isrpipe_00000e0c;\n  uart_init(uart_num, baud_rate, DAT_00000e10, PTR_uart_stdio_isrpipe_00000e0c);\n  return;\n}",
            "called": [
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_status_00002eb4",
                "argc": "num_args",
                "argv": "args",
                "ps": "print_status_info"
            },
            "code": "int print_status_00002eb4(int num_args, char **args)\n{\n  print_status_00002eb4_info();\n  return 0;\n}",
            "called": [
                "ps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_status_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_time_string_0000328c",
                "argv": "args",
                "time": "time_struct",
                "lVar1": "arg_long",
                "iVar2": "day_of_week",
                "end": "end_ptr",
                "i": "arg_short"
            },
            "code": "int parse_time_string_0000328c(char **args, tm *time_struct) {\n  long arg_long;\n  int day_of_week;\n  char *end_ptr;\n  short arg_short;\n\n  arg_long = strtol(*args, &end_ptr, 10);\n  arg_short = (short)arg_long;\n  time_struct->tm_year = arg_short - 1900;\n\n  arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n  arg_short = (short)arg_long;\n  time_struct->tm_mon = arg_short - 1;\n\n  arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n  time_struct->tm_mday = (int)arg_long;\n\n  arg_long = strtol(args[1], &end_ptr, 10);\n  time_struct->tm_hour = (int)arg_long;\n\n  arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n  time_struct->tm_min = (int)arg_long;\n\n  arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n  time_struct->tm_sec = (int)arg_long;\n\n  day_of_week = day_of_week(time_struct->tm_year + 1900, time_struct->tm_mon + 1, time_struct->tm_mday);\n  time_struct->tm_wday = day_of_week;\n  time_struct->tm_isdst = -1;\n  return 0;\n}",
            "called": [
                "dow",
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "_rtc_setalarm",
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "parse_time_string_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_structures_000041f4",
                "param_1": "data",
                "param_2": "input1",
                "param_3": "input2",
                "uVar1": "DAT_00004238"
            },
            "code": "void initialize_data_structures_000041f4(undefined4 *data, undefined2 input1, undefined2 input2) {\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  data[3] = input1;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  data[7] = 0;\n  data[8] = data;\n  data[9] = DAT_0000422c;\n  data[10] = DAT_00004230;\n  data[11] = DAT_00004234;\n  data[12] = DAT_00004238;\n}\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "process_command_0000316c",
                "argc": "arg_count",
                "argv": "arg_values",
                "iVar1": "comparison_result",
                "list": "list_commands",
                "read": "read_file",
                "write": "write_file"
            },
            "code": "int process_command_0000316c(int arg_count, char **arg_values) {\n  int comparison_result;\n  if (arg_count < 2) {\n    list_commands();\n  }\n  else {\n    comparison_result = strcmp(arg_values[1], PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      read_file(arg_count, arg_values);\n    }\n    else {\n      comparison_result = strcmp(arg_values[1], PTR_s_write_000031d8);\n      if (comparison_result == 0) {\n        write_file(arg_count, arg_values);\n      }\n      else {\n        iprintf(PTR_s_usage___s_read_write_000031dc, *arg_values);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "read",
                "iprintf",
                "strcmp",
                "write",
                "list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "process_command_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "call_rtc_callback_000026f0",
                "arg": "argument",
                "PTR_rtc_callback_00002710": "rtc_callback_ptr"
            },
            "code": "void call_rtc_callback_000026f0(void *arg)\n{\n    int *PTR_rtc_callback_00002710 = (int *)PTR_rtc_callback_00002710;\n    if (*PTR_rtc_callback_00002710 != 0) {\n        code *callback_function_ptr = *(code **)PTR_rtc_callback_00002710;\n        (*callback_function_ptr)(arg);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "call_rtc_callback_000026f0"
        },
        "FUN_0000510c": {
            "renaming": {
                "FUN_0000510c": "FUNC_0000510c"
            },
            "code": "\nvoid FUNC_0000510c(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  char *pcVar5;\n  void *__ptr;\n  size_t sVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  char cVar11;\n  bool bVar12;\n  ushort *puVar13;\n  int *piVar14;\n  ushort *puVar15;\n  int *piVar16;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar4 = __gettzinfo();\n  puVar1 = PTR_prev_tzenv_000053d8;\n  pcVar5 = (char *)_getenv_r(param_1,PTR_DAT_000053d4);\n  puVar2 = PTR_LAB_00007a5e_1_000053e0;\n  if (pcVar5 == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    puVar3 = PTR__tzname_000053e8;\n    __ptr = *(void **)puVar1;\n    *(undefined **)PTR__tzname_000053e8 = puVar2;\n    *(undefined **)(puVar3 + 4) = puVar2;\n    free(__ptr);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(char **)puVar1 == (char *)0x0) ||\n          (iVar8 = strcmp(pcVar5,*(char **)puVar1), iVar8 != 0)) {\n    free(*(void **)puVar1);\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)_malloc_r(param_1,sVar6 + 1);\n    *(char **)puVar1 = pcVar7;\n    if (pcVar7 != (char *)0x0) {\n      strcpy(pcVar7,pcVar5);\n    }\n    if (*pcVar5 == ':') {\n      pcVar5 = pcVar5 + 1;\n    }\n    iVar8 = siscanf(pcVar5,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&local_30);\n    if (0 < iVar8) {\n      pcVar7 = pcVar5 + local_30;\n      if (pcVar5[local_30] == '-') {\n        pcVar7 = pcVar7 + 1;\n        iVar8 = -1;\n      }\n      else {\n        if (pcVar5[local_30] == '+') {\n          pcVar7 = pcVar7 + 1;\n        }\n        iVar8 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar13 = &local_3a;\n      piVar14 = &local_30;\n      puVar15 = &local_38;\n      piVar16 = &local_30;\n      iVar9 = siscanf(pcVar7,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                      &local_30,&local_38,&local_30);\n      puVar1 = PTR___tzname_dst_00005400;\n      if (0 < iVar9) {\n        *(uint *)(iVar4 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n        puVar2 = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        pcVar7 = pcVar7 + local_30;\n        iVar8 = siscanf(pcVar7,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar13,piVar14,\n                        puVar15,piVar16);\n        if (iVar8 < 1) {\n          *(undefined4 *)(puVar2 + 4) = *(undefined4 *)puVar2;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(iVar4 + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(puVar2 + 4) = puVar1;\n          pcVar5 = pcVar7 + local_30;\n          if (pcVar7[local_30] == '-') {\n            pcVar5 = pcVar5 + 1;\n            iVar8 = -1;\n          }\n          else {\n            if (pcVar7[local_30] == '+') {\n              pcVar5 = pcVar5 + 1;\n            }\n            iVar8 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar9 = siscanf(pcVar5,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                          &local_30,&local_38,&local_30);\n          if (iVar9 < 1) {\n            iVar8 = *(int *)(iVar4 + 0x28) + -0xe10;\n          }\n          else {\n            iVar8 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n          }\n          *(int *)(iVar4 + 0x50) = iVar8;\n          pcVar5 = pcVar5 + local_30;\n          bVar12 = false;\n          iVar8 = iVar4;\n          while( true ) {\n            if (*pcVar5 == ',') {\n              pcVar5 = pcVar5 + 1;\n            }\n            cVar11 = *pcVar5;\n            if (cVar11 == 'M') {\n              iVar9 = siscanf(pcVar5,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,&local_34\n                              ,&local_30,&local_32,&local_30);\n              if (iVar9 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar8 + 0xc) = (uint)local_36;\n              *(uint *)(iVar8 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar8 + 8) = 0x4d;\n              *(uint *)(iVar8 + 0x14) = (uint)local_32;\n              pcVar7 = pcVar5 + local_30;\n            }\n            else {\n              if (cVar11 == 'J') {\n                pcVar5 = pcVar5 + 1;\n              }\n              else {\n                cVar11 = 'D';\n              }\n              uVar10 = strtoul(pcVar5,local_2c,10);\n              local_32 = (ushort)uVar10;\n              pcVar7 = local_2c[0];\n              if (local_2c[0] == pcVar5) {\n                if (bVar12) {\n                  *(undefined *)(iVar4 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar4 + 0x38) = 1;\n                  *(undefined4 *)(iVar4 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar4 + 8) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0xc) = 3;\n                  *(undefined4 *)(iVar4 + 0x10) = 2;\n                  *(undefined4 *)(iVar4 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar8 + 8) = cVar11;\n                *(ulong *)(iVar8 + 0x14) = uVar10 & 0xffff;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar7 == '/') {\n              siscanf(pcVar7,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,&local_38,\n                      &local_30);\n            }\n            *(uint *)(iVar8 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar8 = iVar8 + 0x28;\n            pcVar5 = pcVar7 + local_30;\n            if (bVar12) break;\n            bVar12 = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar4 + 4));\n          iVar8 = *(int *)(iVar4 + 0x28);\n          *(int *)PTR__timezone_000053dc = iVar8;\n          iVar8 = *(int *)(iVar4 + 0x50) - iVar8;\n          if (iVar8 != 0) {\n            iVar8 = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = iVar8;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tzcalc_limits",
                "_getenv_r",
                "strcpy",
                "siscanf",
                "strlen",
                "strcmp",
                "free",
                "_malloc_r",
                "strtoul"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000510c",
            "calling": [
                "_tzset_unlocked"
            ],
            "imported": false,
            "current_name": "FUNC_0000510c"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar2": "end_of_buffer",
                "iVar3": "bytes_written",
                "iVar1": "write_result"
            },
            "code": "int write_to_stream_000057d2(int file_descriptor, int character, void *buffer, int buffer_size) {\n  int bytes_written = 0;\n  void *end_of_buffer = buffer + buffer_size;\n  while (bytes_written != buffer_size) {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    int write_result = __sfputc_r(file_descriptor, *buffer, character, buffer_size, bytes_written);\n    bytes_written = write_result + 1;\n    buffer = buffer + 1;\n  }\n  return bytes_written;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_000057d2"
        },
        "FUN_00000958": {
            "renaming": {
                "FUN_00000958": "runScheduler_00000958",
                "PTR_sched_active_thread_00000970": "currentThreadPtr",
                "PTR_sched_active_thread_0000098c": "currentThreadPtr",
                "arg4": "arg4",
                "arg5": "arg5",
                "arg6": "arg6",
                "arg7": "arg7",
                "arg8": "arg8",
                "arg9": "arg9",
                "arg10": "arg10",
                "arg11": "arg11",
                "arg12": "arg12",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "getProcessStackPointer": "getProcessStackPointer",
                "setProcessStackPointer": "setProcessStackPointer",
                "isr_svc": "isr_svc",
                "sched_run": "sched_run",
                "bool": "bool",
                "int": "int",
                "code": "code",
                "undefined4": "undefined4"
            },
            "code": "void runScheduler_00000958(void)\n{\n    bool isPrivileged;\n    int stackPointer;\n    code *jumpTable;\n    undefined4 arg4;\n    undefined4 arg5;\n    undefined4 arg6;\n    undefined4 arg7;\n    undefined4 arg8;\n    undefined4 arg9;\n    undefined4 arg10;\n    undefined4 arg11;\n    undefined4 arg12;\n    code **PTR_sched_active_thread_00000970;\n    \n    stackPointer = getProcessStackPointer();\n    *(undefined4 *)(stackPointer + -4) = arg11;\n    *(undefined4 *)(stackPointer + -8) = arg10;\n    *(undefined4 *)(stackPointer + -0xc) = arg9;\n    *(undefined4 *)(stackPointer + -0x10) = arg8;\n    *(undefined4 *)(stackPointer + -0x14) = arg7;\n    *(undefined4 *)(stackPointer + -0x18) = arg6;\n    *(undefined4 *)(stackPointer + -0x1c) = arg5;\n    *(undefined4 *)(stackPointer + -0x20) = arg4;\n    *(undefined4 *)(stackPointer + -0x24) = arg12;\n    **(int **)PTR_sched_active_thread_00000970 = (int)(undefined4 *)(stackPointer + -0x24);\n    isr_svc();\n    sched_run();\n    jumpTable = *(code **)**(undefined4 **)PTR_sched_active_thread_00000970;\n    PTR_sched_active_thread_00000970 = (code **)**(undefined4 **)PTR_sched_active_thread_00000970 + 9;\n    isPrivileged = (bool)isCurrentModePrivileged();\n    if (isPrivileged) {\n        setProcessStackPointer(PTR_sched_active_thread_00000970);\n    }\n    (*jumpTable)(jumpTable,PTR_sched_active_thread_00000970);\n    return;\n}",
            "called": [
                "isr_svc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000958",
            "calling": [],
            "imported": false,
            "current_name": "runScheduler_00000958"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_file_mode_000056b8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "out_flags",
                "param_4": "out_error",
                "iVar1": "result",
                "uVar2": "flags",
                "sStack_68": "file_stat"
            },
            "code": "int check_file_mode_000056b8(_reent *reent, int file_descriptor, uint32_t *out_flags, uint32_t *out_error) {\n  int result;\n  uint32_t flags;\n  struct stat file_stat;\n\n  if (*(short *)(file_descriptor + 0xe) < 0 || _fstat_r(reent, (int)*(short *)(file_descriptor + 0xe), &file_stat) < 0) {\n    *out_error = 0;\n    if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x18) < 0) {\n      flags = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    flags = (uint32_t)((file_stat.st_mode & 0xf000) == 0x2000);\n  }\n  flags = 0x400;\n\nLAB_000056f8:\n  *out_flags = flags;\n  return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_mode_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_mode_to_low_power_00001a18",
                "DAT_00001a34": "byte_to_set",
                "kinetis_mcg_disable_pll": "disable_pll",
                "*PTR_current_mode_00001a38": "current_mode_ptr",
                "4": "LOW_POWER_MODE"
            },
            "code": "void set_mode_to_low_power_00001a18(void)\n{\n  set_bit_in_byte(DAT_00001a34, 0);\n  disable_pll();\n  **PTR_current_mode_00001a38 = LOW_POWER_MODE;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_mode_to_low_power_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_termination_character_00000d9c",
                "DAT_00000dac": "termination_character_pointer"
            },
            "code": "void clear_termination_character_00000d9c(void)\\n{\\n  bit_clear32(DAT_00000dac, \"\\0\");\\n  return;\\n}",
            "called": [
                "bit_clear32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "clear_termination_character_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "in_len": "input_len",
                "pad_len": "pad_len",
                "pad_char": "pad_char",
                "sVar1": "result",
                "out": "output",
                "n": "not_used"
            },
            "code": "size_t pad_string_00003ff4(char *output, size_t input_len, size_t pad_len, char pad_char) {\n  size_t result = input_len;\n  if ((input_len < pad_len) && (result = pad_len, output != NULL)) {\n    memmove(output + (pad_len - input_len), output, input_len);\n    memset(output, (uint)(byte)pad_char, pad_len - input_len);\n  }\n  return result;\n}",
            "called": [
                "memset",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "pad_string_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    div((int)&local_20,*param_1);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    div((int)&local_20,param_1[1]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    div((int)&local_20,param_1[2]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    div((int)&local_20,param_1[4]);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAYS_IN_MONTH_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "div"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_port_from_gpio_00001d5e",
                "pin": "gpio_pin",
                "PTR_Port_Type": "PORT_Type*",
                "DAT_00004004": "port_base_addr",
                "DAT_00004008": "pin_mask",
                "VAR_4h": "masked_pin",
                "VAR_8h": "port_addr"
            },
            "code": "PTR_Port_Type get_port_from_gpio_00001d5e(gpio_t gpio_pin) {\n  const uint32_t DAT_00004004 = 0x40048000;\n  const uint32_t DAT_00004008 = 0x7000;\n  uint32_t masked_pin = gpio_pin & DAT_00004008;\n  uint32_t port_addr = masked_pin | DAT_00004004;\n  return (PTR_Port_Type)port_addr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_port_from_gpio_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "enable_oscillator_and_set_fll_factor_0000191c",
                "DAT_00001958": "register_1",
                "PTR_current_mode_0000195c": "PTR_current_mode",
                "KINETIS_MCG_FLL_FACTOR_1920": "fll_factor",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "register_2": "register_2"
            },
            "code": "void enable_oscillator_and_set_fll_factor_0000191c(void) {\n  enable_oscillator();\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((register_2[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c_0000195c = 1;\n  return;\n}",
            "called": [
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "release_tz_mutex_000050f4",
                "PTR___lock___tz_mutex_000050fc": "tz_mutex_lock"
            },
            "code": "void release_tz_mutex_000050f4(void)\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}",
            "called": [
                "__retarget_lock_release"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "release_tz_mutex_000050f4"
        },
        "FUN_00000c80": {
            "renaming": {
                "FUN_00000c80": "handle_memory_management_error_00000c80",
                "PTR_s_MEM_MANAGE_HANDLER_00000c8c": "memory_management_handler"
            },
            "code": "void handle_memory_management_error_00000c80(void)\n{\n    core_panic(PANIC_MEM_MANAGE, PTR_s_MEM_MANAGE_HANDLER_00000c8c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c80",
            "calling": [],
            "imported": false,
            "current_name": "handle_memory_management_error_00000c80"
        },
        "FUN_00000a40": {
            "renaming": {
                "FUN_00000a40": "calculate_stack_offset_00000a40",
                "auStack_18": "stack_frame",
                "sp": "stack_pointer"
            },
            "code": "int calculate_stack_offset_00000a40(uint32_t required) {\n    undefined stack_frame[12];\n    uint32_t *stack_pointer;\n    stack_pointer = &stack_frame[0];\n    return (int)(stack_pointer + (-(int)PTR_isr_stack_00000a60 - required));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a40",
            "calling": [
                "hard_fault_handler"
            ],
            "imported": false,
            "current_name": "calculate_stack_offset_00000a40"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "process_data_00005a58",
                "param_1": "data",
                "param_2": "data_ptr1",
                "param_3": "data_ptr2",
                "param_4": "param_4",
                "param_5": "callback_func",
                "iVar1": "i",
                "uVar2": "result",
                "uVar3": "max_size",
                "uVar4": "offset",
                "bVar5": "is_offset_four",
                "LAB_00005afc": "error_handling",
                "padding": "padding",
                "remaining_size": "remaining_size",
                "j": "j"
            },
            "code": "undefined4 process_data_00005a58(undefined4 data, uint *data_ptr1, uint *data_ptr2, undefined4 param_4, code *callback_func)\\n\\\n    {\\n\\\n        int i;\\n\\\n        undefined4 result;\\n\\\n        uint max_size = data_ptr1[4];\\n\\\n        if ((int)data_ptr1[4] < (int)data_ptr1[2]) {\\n\\\n            max_size = data_ptr1[2];\\n\\\n        }\\n\\\n        *data_ptr2 = max_size;\\n\\\n        if (*(char *)((int)data_ptr1 + 0x43) != \"\\0\") {\\n\\\n            *data_ptr2 = max_size + 1;\\n\\\n        }\\n\\\n        if ((int)(*data_ptr1 << 0x1a) < 0) {\\n\\\n            *data_ptr2 = *data_ptr2 + 2;\\n\\\n        }\\n\\\n        uint offset = *data_ptr1 & 6;\\n\\\n        if (offset == 0) {\\n\\\n            for (; (int)offset < (int)(data_ptr1[3] - *data_ptr2); offset++) {\\n\\\n                int callback_result = (*callback_func)(data, param_4, (int)data_ptr1 + 0x19, 1);\\n\\\n                if (callback_result == -1) goto LAB_00005afc;\\n\\\n            }\\n\\\n        }\\n\\\n        uint padding = (uint)*(byte *)((int)data_ptr1 + 0x43);\\n\\\n        if (padding != 0) {\\n\\\n            padding = 1;\\n\\\n        }\\n\\\n        if ((int)(*data_ptr1 << 0x1a) < 0) {\\n\\\n            *(undefined *)((int)data_ptr1 + padding + 0x43) = 0x30;\\n\\\n            *(undefined *)((int)data_ptr1 + padding + 0x44) = *(undefined *)((int)data_ptr1 + 0x45);\\n\\\n            padding += 2;\\n\\\n        }\\n\\\n        int callback_result = (*callback_func)(data, param_4, (int)data_ptr1 + 0x43, padding);\\n\\\n        if (callback_result == -1) {\\n\\\n            result = 0xffffffff;\\n\\\n        }\\n\\\n        else {\\n\\\n            uint remaining_size = data_ptr1[3];\\n\\\n            bool is_offset_four = (*data_ptr1 & 6) == 4;\\n\\\n            if (is_offset_four) {\\n\\\n                remaining_size = remaining_size - *data_ptr2;\\n\\\n            }\\n\\\n            if (is_offset_four) {\\n\\\n                remaining_size = remaining_size & ~((int)remaining_size >> 0x1f);\\n\\\n            }\\n\\\n            else {\\n\\\n                remaining_size = 0;\\n\\\n            }\\n\\\n            if ((int)data_ptr1[4] < (int)data_ptr1[2]) {\\n\\\n                remaining_size = remaining_size + (data_ptr1[2] - data_ptr1[4]);\\n\\\n            }\\n\\\n            for (uint j = 0; remaining_size != j; j++) {\\n\\\n                int callback_result = (*callback_func)(data, param_4, (int)data_ptr1 + 0x1a, 1);\\n\\\n                if (callback_result == -1) goto LAB_00005afc;\\n\\\n            }\\n\\\n            result = 0;\\n\\\n        }\\n\\\n        return result;\\n\\\n    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "process_data_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_timezone_info_000056b0",
                "PTR_tzinfo_000056b4": "timezone_info_ptr"
            },
            "code": "const char* get_timezone_info_000056b0(void)\n{\n    return PTR_tzinfo_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "get_timezone_info_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "i": "current_position",
                "tmp": "current_node"
            },
            "code": "saul_reg_t * get_saul_reg_at_position_00003d24(int position)\n{\n  int current_position = 0;\n  saul_reg_t *current_node = *(saul_reg_t **)PTR_saul_reg_00003d60;\n  \n  while (current_position < position && current_node != (saul_reg_t *)0x0)\n  {\n    current_node = current_node->next;\n    current_position++;\n  }\n  \n  return current_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "get_saul_reg_at_position_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_memory_000060cc",
                "param_1": "size",
                "param_2": "ptr1",
                "param_3": "ptr2",
                "param_4": "size2",
                "pvVar1": "new_ptr",
                "pvVar2": "usable_size"
            },
            "code": "void * allocate_memory_000060cc(size_t size, void *ptr1, void *ptr2, size_t size2) {\n  void *new_ptr;\n  void *usable_size;\n  \n  if (ptr1 != NULL) {\n    if (ptr2 == NULL) {\n      free(ptr1);\n      new_ptr = ptr2;\n    }\n    else {\n      usable_size = malloc_usable_size(ptr1);\n      new_ptr = ptr1;\n      if ((usable_size < ptr2) && (new_ptr = malloc(size2), new_ptr != NULL)) {\n        memcpy(new_ptr, ptr1, size2);\n        free(ptr1);\n      }\n    }\n    return new_ptr;\n  }\n  new_ptr = malloc(size2);\n  return new_ptr;\n}",
            "called": [
                "_free_r",
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "__submore"
            ],
            "imported": false,
            "current_name": "allocate_memory_000060cc"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ring_buffer",
                "c": "data",
                "uVar1": "writes",
                "buffer_index": "buffer_index"
            },
            "code": "void write_to_ring_buffer_000022be(tsrb_t *ring_buffer, char data) \\n\\\n    { \\n\\\n        uint32_t writes = ring_buffer->writes; \\n\\\n        ring_buffer->writes = writes + 1; \\n\\\n        uint32_t buffer_index = writes & (ring_buffer->size - 1); \\n\\\n        ring_buffer->buf[buffer_index] = data; \\n\\\n    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "write_to_ring_buffer_000022be"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_num_digits_00003dc4",
                "out": "output",
                "val": "value",
                "local_20": "remainder",
                "ptr": "current_digit",
                "tmp": "power_of_10",
                "len": "num_digits",
                "DAT_00003e50": "max_value_for_single_digit",
                "DAT_00003e54": "max_value_for_single_digit"
            },
            "code": "size_t calculate_num_digits_00003dc4(char *output, uint32_t value) {\n  uint32_t power_of_10;\n  char *current_digit;\n  uint32_t remainder;\n  size_t num_digits = 1;\n  if (DAT_00003e50 < value) {\n    num_digits = 10;\n  }\n  else {\n    for (power_of_10 = 10; power_of_10 <= value; power_of_10 = power_of_10 * 10) {\n      num_digits = num_digits + 1;\n    }\n  }\n  if (output != (char *)0x0) {\n    current_digit = output + num_digits;\n    remainder = value;\n    do {\n      current_digit = current_digit + -1;\n      *current_digit = (char)remainder + (char)(uint)((ulonglong)DAT_00003e50 * (ulonglong)remainder >> 0x23) * -10 + '0';\n      remainder = (uint32_t)((ulonglong)DAT_00003e50 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return num_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "fmt_s32_dec"
            ],
            "imported": false,
            "current_name": "calculate_num_digits_00003dc4"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "handle_irq_00002108",
                "DAT_00002118": "device",
                "PTR_0000211c": "num_devices"
            },
            "code": "void handle_irq_00002108(void)\n{\n  irq_handler(DAT_00002118, PTR_0000211c);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_00002108"
        },
        "FUN_00000c90": {
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PTR_s_BUS_FAULT_HANDLER_00000c9c": "bus_fault_handler",
                "PANIC_BUS_FAULT": "PANIC_BUS_FAULT"
            },
            "code": "void handle_bus_fault_00000c90(void)\n{\n    core_panic(PANIC_BUS_FAULT, PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c90",
            "calling": [],
            "imported": false,
            "current_name": "handle_bus_fault_00000c90"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "get_GPIO_address_00001d80",
                "pin": "pin",
                "GPIO_Type": "GPIO_Type",
                "PIN_MASK": "PIN_MASK",
                "masked_pin": "masked_pin",
                "GPIO_BASE_ADDRESS": "GPIO_BASE_ADDRESS",
                "gpio_address": "gpio_address"
            },
            "code": "GPIO_Type* get_GPIO_address_00001d80(get_GPIO_address_00001d80_t pin) {\n\tconst uint32_t GPIO_BASE_ADDRESS = 0x400ff000;\n\tconst uint32_t PIN_MASK = 0x1c0;\n\tuint32_t masked_pin = pin & PIN_MASK;\n\tGPIO_Type* gpio_address = (GPIO_Type*)(masked_pin | GPIO_BASE_ADDRESS);\n\treturn gpio_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_address_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "get_rtc_alarm_status_000033c0",
                "iVar1": "status",
                "t": "alarm_time",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc_error_getting_alarm",
                "_print_time": "print_alarm_time"
            },
            "code": "int get_rtc_alarm_status_000033c0(void)\n{\n  int status;\n  tm alarm_time;\n  status = rtc_get_alarm(&alarm_time);\n  if (status != 0) {\n    puts(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    print_alarm_time(&alarm_time);\n  }\n  return (uint)(status != 0);\n}",
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_shell_command_00002b10",
                "command_list": "command_list",
                "line": "command_line",
                "iVar1": "result",
                "pcVar2": "next_pos",
                "local_48": "current_line",
                "local_44": "current_command",
                "handler": "command_handler",
                "argv": "arg_values",
                "local_34": "arg_count",
                "quote_char": "quote_char",
                "d": "dest",
                "c": "current",
                "arg": "arg_ptrs",
                "i": "index",
                "contains_esc_seq": "contains_escape_sequence",
                "argc": "arg_count",
                "pos": "current_pos"
            },
            "code": "void parse_shell_command_00002b10(shell_command_t *command_list, char *command_line) {\\n    int arg_count;\\n    char *arg_pos;\\n    char **args;\\n    uint contains_esc_seq = 0;\\n    char quote_char;\\n    char *d;\\n    char *c;\\n    shell_command_t *current_command;\\n    shell_command_handler_t handler;\\n    char___0_ *argv;\\n    uint i;\\n    char *pos = command_line;\\n\\n    current_command = command_list;\\n    arg_count = 0;\\n\\n    while (*pos != \"\\0\") {\\n        if (*pos > 0x20) {\\n            if ((*pos == \"\\\"\") || (*pos == \"\\\"\")) {\\n                quote_char = *pos;\\n                do {\\n                    pos++;\\n                    if (*pos == \"\\0\") {\\n                        pos = pos;\\n                        puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                        return;\\n                    }\\n                    if (*pos == \"\\\\\") {\\n                        contains_esc_seq++;\\n                        pos++;\\n                        if (*pos == \"\\0\") {\\n                            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                            return;\\n                        }\\n                    }\\n                } while (quote_char != *pos);\\n                if (*++pos > 0x20) {\\n                    puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                    return;\\n                }\\n            } else {\\n                do {\\n                    if (*pos == \"\\\\\") {\\n                        contains_esc_seq++;\\n                        pos++;\\n                        if (*pos == \"\\0\") {\\n                            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                            return;\\n                        }\\n                    }\\n                    pos++;\\n                    if (*pos == \"\\\"\") {\\n                        puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                        return;\\n                    }\\n                } while (*pos > 0x20);\\n            }\\n            arg_count++;\\n        }\\n        *pos++ = \"\\0\";\\n    }\\n\\n    if (arg_count != 0) {\\n        args = (char **)malloc(arg_count * sizeof(char *));\\n        argv = (char___0_ *)((int)args + arg_count * sizeof(char *));\\n        *(char **)((int)argv + arg_count * 4) = (char *)0x0;\\n        pos = command_line;\\n        for (i = 0; i < arg_count; i++) {\\n            while (*pos == \"\\0\") {\\n                pos++;\\n            }\\n            if ((*pos == \"\\\"\") || (*pos == \"\\\"\")) {\\n                pos++;\\n            }\\n            args[i] = pos;\\n            while (*pos != \"\\0\") {\\n                pos++;\\n            }\\n        }\\n        for (args = (char **)argv; (contains_esc_seq != 0 && (*args != (char *)0x0)); args++) {\\n            for (c = *args; *c != \"\\0\"; c++) {\\n                if (*c == \"\\\\\") {\\n                    for (d = c; *d != \"\\0\"; d++) {\\n                        *d = d[1];\\n                    }\\n                    contains_esc_seq--;\\n                    if (contains_esc_seq == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        handler = find_handler(current_command, *(char **)argv);\\n        if (handler == (shell_command_handler_t)0x0) {\\n            if (strcmp(PTR_DAT_00002d8c, *(char **)argv) == 0) {\\n                print_help(current_command);\\n            } else {\\n                iprintf(PTR_s_shell__command_not_found___s_00002d90, *(undefined4 *)argv);\\n            }\\n        } else {\\n            (*handler)(arg_count, args);\\n        }\\n        free(args);\\n    }\\n}",
            "called": [
                "iprintf",
                "find_handler",
                "print_help",
                "strcmp",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "parse_shell_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "set_kinetis_mcg_mode_00001b10",
                "mode": "mcg_mode",
                "PTR_mcg_mode_routing_00001bb4": "mcg_mode_routing",
                "PTR_current_mode_00001bb0": "current_mode",
                "KINETIS_MCG_MODE_NUMOF": "mcg_mode_numof",
                "kinetis_mcg_set_fei": "set_mcg_fei",
                "kinetis_mcg_set_fee": "set_mcg_fee",
                "kinetis_mcg_set_fbi": "set_mcg_fbi",
                "kinetis_mcg_set_fbe": "set_mcg_fbe",
                "kinetis_mcg_set_blpi": "set_mcg_blpi",
                "kinetis_mcg_set_blpe": "set_mcg_blpe",
                "kinetis_mcg_set_pbe": "set_mcg_pbe",
                "kinetis_mcg_set_pee": "set_mcg_pee"
            },
            "code": "int set_kinetis_mcg_mode_00001b10(kinetis_mcg_mode_t mode)\n{\n  int result;\n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      uint8_t PTR_current_mode_00001bb0 = *PTR_PTR_current_mode_00001bb0_00001bb0;\n      uint8_t routing_index = (uint)mode + (uint)PTR_current_mode_00001bb0 * 8;\n      uint8_t routing = PTR_PTR_mcg_mode_routing_00001bb4_00001bb4[routing_index];\n      switch(routing)\n      {\n        case 0: kinetis_mcg_set_fei(); break;\n        case 1: kinetis_mcg_set_fee(); break;\n        case 2: kinetis_mcg_set_fbi(); break;\n        case 3: kinetis_mcg_set_fbe(); break;\n        case 4: kinetis_mcg_set_blpi(); break;\n        case 5: kinetis_mcg_set_blpe(); break;\n        case 6: kinetis_mcg_set_pbe(); break;\n        case 7: kinetis_mcg_set_pee(); break;\n        default: return -1;\n      }\n    } while (mode != *PTR_PTR_current_mode_00001bb0_00001bb0);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}",
            "called": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_mode_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t FUNC_000047e4(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 = (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 = __tp->tm_year;\n  iVar10 = __tp->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + __tp->tm_mon * 4);\n  if (((1 < __tp->tm_mon) && ((uVar11 & 3) == 0)) &&\n     ((uVar11 != (uVar11 / 100) * 100 || (uVar11 + 0x76c == ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 = iVar10 + 1;\n  }\n  __tp->tm_yday = iVar10;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 < 0x47) {\n    if (uVar11 != 0x46) {\n      for (uVar8 = 0x45; (int)uVar11 < (int)uVar8; uVar8 = uVar8 - 1) {\n        if ((uVar8 & 3) == 0) {\n          if (uVar8 == (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 == 0) {\n              iVar6 = 0x16e;\n            }\n            else {\n              iVar6 = 0x16d;\n            }\n          }\n          else {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16d;\n        }\n        iVar10 = iVar10 - iVar6;\n      }\n      if ((uVar8 & 3) == 0) {\n        if (uVar11 == (uVar11 / 100) * 100) {\n          iVar6 = 0x16d;\n          if ((uVar11 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      iVar10 = iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 = 0x46;\n    do {\n      if ((uVar8 & 3) == 0) {\n        if (uVar8 % 100 == 0) {\n          if ((uVar8 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n          else {\n            iVar6 = 0x16d;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      uVar8 = uVar8 + 1;\n      iVar10 = iVar10 + iVar6;\n    } while (uVar11 != uVar8);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar10 +\n          (longlong)(__tp->tm_hour * 0xe10 + __tp->tm_min * 0x3c + __tp->tm_sec);\n  uVar14 = (uint)lVar1;\n  iVar6 = (int)((ulonglong)lVar1 >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 = __tp->tm_isdst;\n    uVar12 = uVar13;\n    if (0 < (int)uVar13) {\n      uVar12 = 1;\n    }\n    if ((piVar2[1] == __tp->tm_year + 0x76c) || (iVar4 = __tzcalc_limits(), iVar4 != 0)) {\n      uVar9 = piVar2[0x14];\n      uVar3 = piVar2[0x12];\n      uVar7 = piVar2[10];\n      uVar8 = uVar3 - uVar7;\n      iVar4 = (piVar2[0x13] - ((int)uVar7 >> 0x1f)) - (uint)(uVar3 < uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n           (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8)))) &&\n         (iVar5 = (piVar2[0x13] - ((int)uVar9 >> 0x1f)) - (uint)(uVar3 < uVar9),\n         bVar16 = uVar14 < uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 = piVar2[8] - uVar9;\n      iVar5 = (piVar2[9] - ((int)uVar9 >> 0x1f)) - (uint)((uint)piVar2[8] < uVar9);\n      if (*piVar2 != 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 ==\n            (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 = 0;\n        if ((int)uVar13 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 = uVar12 ^ uVar8;\n        uVar12 = uVar8;\n        if (uVar13 == 1) {\n          if (uVar8 == 0) {\n            iVar6 = uVar9 - uVar7;\n          }\n          else {\n            iVar6 = uVar7 - uVar9;\n          }\n          iVar4 = __tp->tm_mday;\n          uVar14 = uVar14 + iVar6;\n          __tp->tm_sec = __tp->tm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 = __tp->tm_mday - iVar4;\n          if (iVar4 != 0) {\n            if (iVar4 < 2) {\n              if (iVar4 == -2 || iVar4 + 2 < 0 != SCARRY4(iVar4,2)) {\n                iVar4 = 1;\n              }\n            }\n            else {\n              iVar4 = -1;\n            }\n            iVar6 = iVar4 + __tp->tm_yday;\n            iVar10 = iVar10 + iVar4;\n            if (iVar6 < 0) {\n              uVar8 = uVar11 - 1;\n              if ((uVar8 & 3) == 0) {\n                if (uVar8 == (uVar8 / 100) * 100) {\n                  iVar6 = 0x16d;\n                  if ((uVar11 + 0x76b) % 400 != 0) {\n                    iVar6 = 0x16c;\n                  }\n                }\n                else {\n                  iVar6 = 0x16d;\n                }\n              }\n              else {\n                iVar6 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 & 3) == 0) {\n                if (uVar11 == (uVar11 / 100) * 100) {\n                  iVar4 = 0x16d;\n                  if ((uVar11 + 0x76c) % 400 == 0) {\n                    iVar4 = 0x16e;\n                  }\n                }\n                else {\n                  iVar4 = 0x16e;\n                }\n              }\n              else {\n                iVar4 = 0x16d;\n              }\n              if (iVar4 <= iVar6) {\n                iVar6 = iVar6 - iVar4;\n              }\n            }\n            __tp->tm_yday = iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 !=\n          (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n            (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar13) {\n        uVar8 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 = uVar12;\n      if (uVar12 != 1) goto LAB_00004934;\n    }\n    tVar15 = uVar14 + piVar2[0x14];\n    uVar8 = 1;\n  }\n  __tz_unlock();\n  __tp->tm_isdst = uVar8;\n  __tp->tm_wday = (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits",
                "validate_structure",
                "__tz_lock",
                "_tzset_unlocked"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "rtc_set_time",
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "software_interrupt_handler_000023c8",
                "a0": "interrupt_code",
                "a1": "data",
                "a2": "flag"
            },
            "code": "uint32_t software_interrupt_handler_000023c8(uint32_t interrupt_code, uint32_t data, int32_t flag)\n{\n  software_interrupt(interrupt_code);\n  return data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "software_interrupt_handler_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_greater_than_sign_space_00002e48",
                "PTR__impure_ptr_00002e68": "impure_ptr",
                "DAT_00002e54": "file_ptr"
            },
            "code": "void print_greater_than_sign_space_00002e48(void)\n{\n  int* PTR__impure_ptr_00002e68 = *(int*)PTR__PTR__impure_ptr_00002e68_00002e68;\n  FILE* DAT_00002e54 = *(FILE**)(PTR__impure_ptr_00002e68 + 8);\n  _putchar('>');\n  _putchar(' ');\n  fflush(DAT_00002e54);\n  return;\n}",
            "called": [
                "_putchar",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "print_greater_than_sign_space_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "enable_irq_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_interrupt",
                "software_interrupt": "trigger_software_interrupt"
            },
            "code": "void enable_irq_and_trigger_software_interrupt_00000930(void)\n{\n  enable_interrupt();\n  trigger_software_interrupt(1);\n  while(true);\n}",
            "called": [
                "irq_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "sched_task_exit",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "enable_irq_and_trigger_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_and_yield_higher_priority_thread_00001348",
                "PTR_sched_context_switch_request_0000135c": "sched_context_switch_request_ptr",
                "*PTR_sched_context_switch_request_0000135c": "*sched_context_switch_request_ptr"
            },
            "code": "void check_and_yield_higher_priority_thread_00001348(void)\n{\n  int* PTR_sched_context_switch_request_0000135c = (int*)PTR_sched_context_switch_request_0000135c;\n  if (*PTR_sched_context_switch_request_0000135c != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "irq_handler_uart"
            ],
            "imported": false,
            "current_name": "check_and_yield_higher_priority_thread_00001348"
        },
        "FUN_00006118": {
            "renaming": {
                "FUN_00006118": "reverse_and_increment_00006118",
                "param_1": "start",
                "param_2": "value",
                "param_3": "buffer",
                "param_4": "end",
                "uVar2": "buffer_start",
                "uVar3": "new_value",
                "iVar1": "index"
            },
            "code": "uint reverse_and_increment_00006118(uint start, uint value, uint *buffer, uint end){\n  int index;\n  uint new_value;\n  uint buffer_start;\n  if (value == 0xffffffff) {\n    end = 0xffffffff;\n  }\n  else {\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xffdf;\n    buffer_start = buffer[0];\n    value = value & 0xff;\n    if (buffer[0xd] == 0) {\n      new_value = buffer_start - 1;\n      if (((buffer[4] != 0) && (buffer[4] < buffer_start)) && (*(byte *)(new_value) == value)) {\n        buffer[0] = new_value;\n        buffer[1] = buffer[1] + 1;\n        return value;\n      }\n      buffer[0xf] = buffer_start;\n      buffer[0x10] = buffer[1];\n      buffer[0xd] = (uint)(buffer + 0x11);\n      buffer[0xe] = 3;\n      *(undefined *)((int)buffer + 0x46) = (char)value;\n      buffer[0] = (uint)(undefined *)((int)buffer + 0x46);\n      new_value = 1;\n    }\n    else {\n      if (((int)buffer[0xe] <= (int)buffer_start) &&\n         (index = __submore(start,buffer,buffer_start,buffer[0xe],end), index != 0))\n      goto LAB_00006120;\n      new_value = buffer[0] - 1;\n      *(char *)(new_value) = (char)value;\n      buffer[0] = new_value;\n      new_value = buffer[1] + 1;\n    }\n    buffer[1] = new_value;\n  }\n  return value;\n}",
            "called": [
                "__submore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006118",
            "calling": [],
            "imported": false,
            "current_name": "reverse_and_increment_00006118"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_00001d3a(uint32_t *data, uint8_t bit_position) {\n  uint32_t *bit_address = (uint32_t *)bitband_addr(data, (uint32_t)bit_position);\n  *bit_address = 1;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "clk_en"
            ],
            "imported": false,
            "current_name": "set_bit_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "mutex": "mutex",
                "blocking": "blocking",
                "state": "irq_state",
                "iVar1": "acquired",
                "process": "waiting_thread",
                "irqstate": "irq_state",
                "me": "current_thread"
            },
            "code": "int acquire_mutex_00002434(mutex_t *mutex, int blocking)\n{\n  uint irq_state;\n  int acquired = 0;\n  thread_t *current_thread, *waiting_thread;\n\n  irq_state = disable_interrupts();\n  if (mutex->queue.next == NULL) {\n    mutex->queue.next = (list_node *)-1;\n    enable_interrupts(irq_state);\n    acquired = 1;\n  }\n  else if (blocking == 0) {\n    enable_interrupts(irq_state);\n    acquired = 0;\n  }\n  else {\n    current_thread = *(thread_t **)sched_active_thread;\n    set_thread_status(current_thread, THREAD_STATUS_BLOCKED);\n    if (mutex->queue.next == (list_node *)-1) {\n      mutex->queue.next = &current_thread->rq_entry;\n      current_thread->rq_entry.next = NULL;\n    }\n    else {\n      add_thread_to_list(&mutex->queue, current_thread);\n    }\n    enable_interrupts(irq_state);\n    yield_higher_priority_thread();\n    acquired = 1;\n  }\n  return acquired;\n}",
            "called": [
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable",
                "irq_restore",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "mutex_lock"
            ],
            "imported": false,
            "current_name": "acquire_mutex_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "initialize_stream_00005700",
                "param_1": "reent",
                "param_2": "stream",
                "uVar1": "bitMask",
                "iVar2": "memAllocated",
                "local_18": "localReent",
                "local_14": "localStream"
            },
            "code": "void initialize_stream_00005700(_reent *reent, int *stream)\n{\n    ushort bitMask;\n    int memAllocated;\n    _reent *localReent;\n    int *localStream;\n    \n    if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1e)) {\n        localReent = reent;\n        localStream = stream;\n        bitMask = __swhatbuf_r(reent, stream, &localReent, &localStream);\n        memAllocated = _malloc_r(reent, localReent);\n        if (memAllocated != 0) {\n            reent->__cleanup = cleanup;\n            *stream = memAllocated;\n            *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 0x80;\n            stream[5] = (int)localReent;\n            stream[4] = memAllocated;\n            if ((localStream != (int *)0x0) &&\n                (_isatty_r(reent, (int)*(short *)((int)stream + 0xe)) != 0)) {\n                *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(stream + 3) = bitMask | *(ushort *)(stream + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(stream + 3) << 0x16 < 0) {\n            return;\n        }\n        *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfffc | 2;\n    }\n    *stream = (int)stream + 0x47;\n    stream[4] = (int)stream + 0x47;\n    stream[5] = 1;\n    return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_stream_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_for_context_switch_request_00002798",
                "PTR_sched_context_switch_request_000027ac": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00002798(void)\n{\n  int* PTR_sched_context_switch_request_000027ac = (int*)PTR_sched_PTR_sched_context_switch_request_000027ac_000027ac;\n  if (*PTR_sched_context_switch_request_000027ac != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "isr_rtc"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "result",
                "_rtc_usage": "print_rtc_usage",
                "PTR_s_poweron_00003638": "POWER_ON_COMMAND",
                "PTR_s_poweroff_0000363c": "POWER_OFF_COMMAND",
                "PTR_s_clearalarm_00003640": "CLEAR_ALARM_COMMAND",
                "PTR_s_getalarm_00003644": "GET_ALARM_COMMAND",
                "PTR_s_setalarm_00003648": "SET_ALARM_COMMAND",
                "PTR_s_gettime_0000364c": "GET_TIME_COMMAND",
                "PTR_s_settime_00003650": "SET_TIME_COMMAND",
                "_rtc_poweron": "rtc_poweron",
                "_rtc_poweroff": "rtc_poweroff",
                "_rtc_clear_alarm": "rtc_clear_alarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "_rtc_gettime": "get_rtc_time",
                "_rtc_settime": "set_rtc_time"
            },
            "code": "int process_rtc_command_00003524(int argc, char **argv) {\n    int result;\n\n    if (argc < 2) {\n        print_rtc_usage();\n        result = 1;\n    }\n    else {\n        if (strncmp(argv[1], PTR_s_poweron_00003638, 7) == 0) {\n            rtc_poweron();\n        }\n        else if (strncmp(argv[1], PTR_s_poweroff_0000363c, 8) == 0) {\n            rtc_poweroff();\n        }\n        else if (strncmp(argv[1], PTR_s_clearalarm_00003640, 8) == 0) {\n            rtc_clear_alarm();\n        }\n        else if (strncmp(argv[1], PTR_s_getalarm_00003644, 8) == 0) {\n            get_rtc_alarm();\n        }\n        else if (strncmp(argv[1], PTR_s_setalarm_00003648, 8) == 0 && argc == 4) {\n            set_rtc_alarm(argv + 2);\n        }\n        else if (strncmp(argv[1], PTR_s_gettime_0000364c, 7) == 0) {\n            get_rtc_time();\n        }\n        else if (strncmp(argv[1], PTR_s_settime_00003650, 7) == 0 && argc == 4) {\n            set_rtc_time(argv + 2);\n        }\n        else {\n            printf(PTR_s_unknown_command_or_missing_param_00003654, argv[1]);\n            print_rtc_usage();\n            result = 1;\n        }\n        result = 0;\n    }\n    return result;\n}",
            "called": [
                "_rtc_setalarm",
                "rtc_poweroff",
                "_rtc_usage",
                "rtc_clear_alarm",
                "iprintf",
                "_rtc_settime",
                "strncmp",
                "_rtc_getalarm",
                "_rtc_gettime",
                "rtc_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "set_current_mode_to_zero_00001bb8",
                "DAT_00001c74": "status_flags",
                "DAT_00001c78": "control_reg",
                "DAT_00001c7c": "control_reg_2",
                "PTR_current_mode_00001c80": "PTR_current_mode"
            },
            "code": "void set_current_mode_to_zero_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_bit_in_byte(DAT_00001c78, 0x01);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_bit_in_byte(DAT_00001c78, 0x06);\n    while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  while ((DAT_00001c74[6] & 0x10) == 0);\n  while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_current_mode_00001c80_00001c80 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_zero_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "PTR___lock___sinit_recursive_mutex_00004294": "sinit_recursive_mutex_lock"
            },
            "code": "void acquire_recursive_lock_0000428c(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "total_bytes_read",
                "piVar2": "read_size_ptr",
                "uVar3": "read_size",
                "uVar4": "flags",
                "iVar5": "read_offset",
                "pcVar6": "read_func",
                "iVar7": "remaining_bytes",
                "uVar8": "data_size",
                "bVar9": "has_error"
            },
            "code": "int process_data_0000404c(uint *data, int *params) {\n  int total_bytes_read;\n  int *read_size_ptr;\n  uint read_size;\n  ushort flags;\n  int read_offset;\n  code *read_func;\n  int remaining_bytes;\n  int read_result;\n  uint data_size;\n  bool has_error;\n  \n  flags = *(ushort *)(params + 3);\n  read_size = (uint)flags;\n  if ((int)(read_size << 0x1c) < 0) {\n    int block_size = params[4];\n    if (block_size != 0) {\n      read_offset = read_size << 0x1e;\n      has_error = read_offset == 0;\n      data_size = *params;\n      if (has_error) {\n        read_offset = params[5];\n      }\n      *params = block_size;\n      if (!has_error) {\n        read_offset = 0;\n      }\n      params[2] = read_offset;\n      for (remaining_bytes = data_size - block_size; remaining_bytes > 0; remaining_bytes = remaining_bytes - read_offset) {\n        read_result = (*(code *)params[10])(data, params[8], block_size, remaining_bytes);\n        if (read_result < 1) {\n          *(ushort *)(params + 3) = flags | 0x40;\n          return -1;\n        }\n        block_size = block_size + read_result;\n      }\n    }\n  }\n  else {\n    if ((params[1] < 1) && (params[16] < 1)) {\n      return 0;\n    }\n    read_func = (code *)params[11];\n    if (read_func == (code *)0x0) {\n      return 0;\n    }\n    total_bytes_read = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      read_result = (*read_func)(data, params[8], read_size & 0x1000, 1);\n      if ((read_result == -1) && (data_size = *data, data_size != 0)) {\n        if ((data_size == 0x1d) || (data_size == 0x16)) {\n          *data = total_bytes_read;\n          return 0;\n        }\n        flags = *(ushort *)(params + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      read_result = params[21];\n    }\n    if (((int)((uint)*(ushort *)(params + 3) << 0x1d) < 0) && (read_result = read_result - params[1], params[13] != 0)) {\n      read_result = read_result - params[16];\n    }\n    read_result = (*(code *)params[11])(data, params[8], read_result, 0);\n    flags = *(ushort *)(params + 3);\n    if ((read_result == -1) && ((0x1d < *data || (-1 < (int)((params[22] >> (*data & 0xff)) << 0x1f)))) {\nLAB_00004104:\n      *(ushort *)(params + 3) = flags | 0x40;\n      return read_result;\n    }\n    params[1] = 0;\n    *params = params[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((read_result != -1 || (*data == 0)))) {\n      params[21] = read_result;\n    }\n    read_size_ptr = (int *)params[13];\n    *data = total_bytes_read;\n    if (read_size_ptr != (int *)0x0) {\n      if (read_size_ptr != params + 17) {\n        _free_r(data);\n      }\n      params[13] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "__srefill_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_saul_devices_info_00002f74",
                "dev": "current_device",
                "pcVar1": "device_type_str",
                "i": "device_count"
            },
            "code": "void print_saul_devices_info_00002f74(void)\n{\n  saul_reg_t *current_device;\n  char *device_type_str;\n  int device_count = 0;\n  current_device = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  if (current_device == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  while (current_device != (saul_reg_t *)0x0) {\n    device_type_str = saul_class_to_str(current_device->driver->type);\n    iprintf(PTR_s___i__s__s_00002fdc, device_count, device_type_str, current_device->name);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_saul_devices_info_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "get_stack_space_000010a0",
                "stack": "stack_pointer",
                "space_free": "free_space",
                "stackp": "stackp"
            },
            "code": "uintptr_t get_stack_space_000010a0(char *stack_pointer) {\n  uintptr_t free_space = 0;\n  uintptr_t *stackp = (uintptr_t *)stack_pointer;\n  while ((uintptr_t *)*stackp == stackp) {\n    stackp++;\n  }\n  free_space = (uintptr_t)stackp - (uintptr_t)stack_pointer;\n  return free_space;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_stack_space_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "get_data_from_isr_pipe_000012e2",
                "isrpipe": "isr_pipe",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "error_code",
                "res": "result"
            },
            "code": "int get_data_from_isr_pipe_000012e2(isrpipe_t *isr_pipe, char *buffer, size_t count)\n{\n    int error_code;\n    int result;\n    while( true )\n    {\n        error_code = tsrb_get(&isr_pipe->tsrb, buffer, count);\n        if (error_code != 0)\n        {\n            break;\n        }\n        mutex_lock(&isr_pipe->mutex);\n    }\n    return error_code;\n}",
            "called": [
                "mutex_lock",
                "tsrb_get"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "uart_stdio_read"
            ],
            "imported": false,
            "current_name": "get_data_from_isr_pipe_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "env_var_name",
                "param_2": "env_var_value",
                "param_3": "env_var_ptr",
                "param_4": "unused",
                "uStack_c": "env_var_value_ptr",
                "uStack_8": "unused"
            },
            "code": "void find_environment_variable_000056a0(char* env_var_name, char** env_var_value)\n{\n    char* env_var_ptr = NULL;\n    char* env_var_value_ptr = NULL;\n    env_var_ptr = env_var_name;\n    env_var_value_ptr = *env_var_value;\n    _findenv_r(env_var_name, env_var_value_ptr, &env_var_ptr, 0, 0);\n    *env_var_value = env_var_value_ptr;\n}\n",
            "called": [
                "_findenv_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "extract_data_from_tsrb_0000231c",
                "*rb": "*tsrb",
                "*dst": "*destination_buffer",
                "n": "buffer_size",
                "cVar1": "character",
                "iVar2": "is_tsrb_empty",
                "local_20": "buffer_pointer",
                "tmp": "remaining_buffer_size",
                "_pop": "tsrb_pop"
            },
            "code": "int extract_data_from_tsrb_0000231c(tsrb_t *tsrb, char *destination_buffer, size_t buffer_size) {\n    char character;\n    int is_tsrb_empty;\n    char *buffer_pointer = destination_buffer;\n    size_t remaining_buffer_size = buffer_size;\n    \n    while ((remaining_buffer_size != 0 && (is_tsrb_empty = tsrb_empty(tsrb), is_tsrb_empty == 0))) {\n        character = tsrb_pop(tsrb);\n        *buffer_pointer = character;\n        remaining_buffer_size--;\n        buffer_pointer++;\n    }\n    return buffer_size - remaining_buffer_size;\n}",
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "extract_data_from_tsrb_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = DAT_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar7 = (uint)*param_3;\n      if (uVar7 == 0) {\n        return local_1a0;\n      }\n      uVar5 = (byte)puVar1[uVar7] & 8;\n      pbVar6 = param_3 + 1;\n      if ((puVar1[uVar7] & 8) == 0) break;\n      while (((param_3 = pbVar6, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar7 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar7) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar6;\n  }\n  local_1a4 = uVar5;\n  local_1ac = uVar5;\n  if (param_3[1] == 0x2a) {\n    pbVar6 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar5 = (uint)*pbVar6;\n    if (9 < uVar5 - 0x30) break;\n    pbVar6 = pbVar6 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar5) - 0x30;\n  }\n  pvVar4 = memchr(PTR_DAT_000064b4,uVar5,3);\n  if (pvVar4 != (void *)0x0) {\n    local_1ac = 1 << ((int)pvVar4 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar6 = pbVar6 + 1;\n  }\n  param_3 = pbVar6 + 1;\n  uVar5 = (uint)*pbVar6;\n  if (uVar5 < 0x79) {\n    if (0x57 < uVar5) {\n      switch(uVar5) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar5 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar6 = param_2[1];\n          param_2[1] = pbVar6 + -1;\n          if ((int)(pbVar6 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = _scanf_chars(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = _scanf_i(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar6 = param_3;\n    if (uVar5 == 0x25) goto LAB_00006352;\n    if (uVar5 < 0x26) {\n      if (uVar5 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar5 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "_scanf_i",
                "__ssrefill_r",
                "__sccl",
                "_scanf_chars",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "siscanf"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "get_time_from_alarm_00002690",
                "time": "time_info",
                "t": "alarm_time"
            },
            "code": "int get_time_from_alarm_00002690(tm *time) {\n  time_t alarm_time;\n  alarm_time.seconds = rtt_get_alarm();\n  alarm_time.nanoseconds = 0;\n  gmtime_r((time_t *)&alarm_time,(tm *)time);\n  return 0;\n}",
            "called": [
                "gmtime_r",
                "rtt_get_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "get_time_from_alarm_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_00006010",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "size",
                "bVar1": "byte_val",
                "cVar2": "bool_val_1",
                "cVar3": "bool_val_2",
                "cVar4": "bool_val_3",
                "cVar5": "bool_val_4",
                "pbVar6": "byte_ptr",
                "puVar7": "uint_data",
                "pbVar8": "byte_ptr",
                "uVar9": "uint_val_1",
                "uVar10": "uint_val_2",
                "uVar11": "uint_val_3",
                "uVar12": "uint_val_4",
                "uVar13": "uint_val_5",
                "bVar14": "bool_val_1",
                "bVar15": "bool_val_2",
                "bVar16": "bool_val_3",
                "bVar17": "bool_val_4"
            },
            "code": "void * find_byte_00006010(void *data, int byte_to_find, size_t size)\n{\n    byte *byte_data = (byte *)data;\n    uint *uint_data;\n    byte *byte_ptr;\n    uint uint_val_1;\n    uint uint_val_2;\n    uint uint_val_3;\n    uint uint_val_4;\n    uint uint_val_5;\n    bool bool_val_1;\n    bool bool_val_2;\n    bool bool_val_3;\n    bool bool_val_4;\n\n    uint_val_1 = byte_to_find & 0xff;\n\n    if ((int)size < 0x10) {\n        do {\n            if (size == 0) {\n                return (void *)0x0;\n            }\n            uint_data = (uint *)((int)byte_data + 1);\n            byte_val = *byte_data;\n            size = size - 1;\n            byte_data = uint_data;\n        } while (byte_val != uint_val_1);\n    }\n    else {\n        uint_val_2 = (uint)byte_data & 7;\n        while (true) {\n            if (uint_val_2 == 0) {\n                uint_val_2 = uint_val_1 | uint_val_1 << 8;\n                uint_val_2 = uint_val_2 | uint_val_2 << 0x10;\n                uint_val_3 = size & 0xfffffff8;\n                do {\n                    uint_data = (uint *)((int)byte_data + 8);\n                    uint_val_3 = uint_val_3 - 8;\n                    uint_val_4 = *byte_data ^ uint_val_2;\n                    uint_val_5 = *(uint *)((int)byte_data + 4) ^ uint_val_2;\n                    bool_val_1 = (char)uint_val_4 != '\\0';\n                    bool_val_2 = (char)(uint_val_4 >> 8) != '\\0';\n                    bool_val_3 = (char)(uint_val_4 >> 0x10) != '\\0';\n                    bool_val_4 = (char)(uint_val_4 >> 0x18) != '\\0';\n                    uint_val_4 = CONCAT13(bool_val_4, CONCAT12(bool_val_3, CONCAT11(bool_val_2, bool_val_1)));\n                    bool_val_1 = (char)uint_val_5 != '\\0';\n                    bool_val_2 = (char)(uint_val_5 >> 8) != '\\0';\n                    bool_val_3 = (char)(uint_val_5 >> 0x10) != '\\0';\n                    bool_val_4 = (char)(uint_val_5 >> 0x18) != '\\0';\n                    uint_val_5 = CONCAT13(bool_val_4, CONCAT12(bool_val_3, CONCAT11(bool_val_2, bool_val_1)));\n                    if (uint_val_5 != 0) {\n                        if (uint_val_4 == 0) {\n                            byte_ptr = (byte *)((int)byte_data + 5);\n                            uint_val_4 = uint_val_5;\n                        }\n                        else {\n                            byte_ptr = (byte *)((int)byte_data + 1);\n                        }\n                        if ((uint_val_4 & 1) == 0) {\n                            bool_val_1 = (uint_val_4 & 0x100) == 0;\n                            byte_val = bool_val_1 ? (uint_val_4 & 0x18000) == 0 ? 3 : 4 : bool_val_1 ? 2 : 1;\n                            byte_ptr += byte_val;\n                        }\n                        return byte_ptr - 1;\n                    }\n                    byte_data = uint_data;\n                } while (uint_val_3 != 0);\n                size = size & 7;\n            }\n            uint_data = (uint *)((int)byte_data + 1);\n            size = size - 1;\n            if (*byte_data == uint_val_1) {\n                break;\n            }\n            uint_val_2 = (uint)uint_data & 7;\n            byte_data = uint_data;\n            if (size == 0) {\n                return (void *)0x0;\n            }\n        }\n    }\n    return (byte *)((int)uint_data + -1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_for_context_switch_request_00001cf0",
                "PTR_sched_context_switch_request_00001d04": "context_switch_request_ptr",
                "*PTR_sched_context_switch_request_00001d04": "*context_switch_request_ptr"
            },
            "code": "void check_for_context_switch_request_00001cf0(void)\n{\n  int *PTR_sched_context_switch_request_00001d04 = (int *)PTR_sched_context_switch_request_00001d04;\n  if (*PTR_sched_context_switch_request_00001d04 != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "irq_handler"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_number_00003ec4",
                "out": "output",
                "val": "value",
                "fp_digits": "decimal_places",
                "sVar1": "length",
                "val_00": "quotient",
                "iVar2": "temp",
                "div_len": "divisor",
                "abs": "abs_value",
                "e": "remainder",
                "div": "remainder",
                "pos": "position"
            },
            "code": "size_t format_number_00003ec4(char *output, int32_t value, int decimal_places) {\n  size_t length;\n  uint32_t divisor;\n  uint32_t quotient;\n  uint32_t remainder;\n  uint32_t abs_value;\n  uint32_t position = 0;\n  if (decimal_places + 7 < 0 != SCARRY4(decimal_places,7)) {\n    core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_00003fec);\n  }\n  if (decimal_places == 0) {\n    length = fmt_s32_dec(output, value);\n  }\n  else if (decimal_places < 1) {\n    divisor = *(uint32_t *)(PTR__tenmap_00003ff0 + decimal_places * -4);\n    abs_value = (value < 0) ? -value : value;\n    quotient = abs_value / divisor;\n    remainder = abs_value % divisor;\n    if (quotient == 0 && value < 0) {\n      if (output != (char *)0x0) {\n        *output = '-';\n      }\n      position = 1;\n    }\n    if (output == (char *)0x0) {\n      length = fmt_s32_dec((char *)0x0, quotient);\n      position += length + 1;\n    }\n    else {\n      length = fmt_s32_dec(output + position, quotient);\n      position += length;\n      output[position] = '.';\n      length = fmt_s32_dec(output + position + 1, remainder);\n      fmt_lpad(output + position + 1, length, -decimal_places, '0');\n      position -= decimal_places;\n    }\n  }\n  else {\n    length = fmt_s32_dec(output, value);\n    if (output != (char *)0x0) {\n      memset(output + length, '0', decimal_places);\n    }\n    position = length + decimal_places;\n  }\n  return position;\n}",
            "called": [
                "fmt_s32_dec",
                "fmt_lpad",
                "memset",
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "fmt_s16_dfp"
            ],
            "imported": false,
            "current_name": "format_number_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_from_bit_and_ptr_00001360",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void * calculate_address_from_bit_and_ptr_00001360(void *ptr, uintptr_t bit){\n    uintptr_t upper_bits = (uintptr_t)ptr & 0xf0000000;\n    uintptr_t lower_bits = (uintptr_t)ptr & 0xfffff;\n    uintptr_t shifted_lower_bits = lower_bits << 5;\n    uintptr_t calculated_address = bit * 4 + upper_bits + shifted_lower_bits + 0x2000000;\n    return (void *)calculated_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_bit_and_ptr_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_char_00004622",
                "__s": "memory_start",
                "__c": "character",
                "__n": "num_bytes_to_fill",
                "puVar1": "current_byte"
            },
            "code": "void* fill_memory_with_char_00004622(void* memory_start, int character, size_t num_bytes_to_fill)\n{\n  unsigned char* current_byte;\n  unsigned char char_to_fill = (unsigned char)character;\n  for (current_byte = (unsigned char*)memory_start; current_byte < (unsigned char*)memory_start + num_bytes_to_fill; current_byte++) {\n    *current_byte = char_to_fill;\n  }\n  return memory_start;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "std",
                "__sfmoreglue",
                "fmt_s32_dfp",
                "fmt_lpad",
                "__sfp",
                "write"
            ],
            "imported": false,
            "current_name": "fill_memory_with_char_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_bit_0000093c",
                "DAT_00000954": "flag_data"
            },
            "code": "void set_flag_bit_0000093c(void)\n{\n  uint32_t *flag_ptr = (uint32_t *)(DAT_00000954 + 4);\n  *flag_ptr |= 0x10000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "cortexm_isr_end",
                "_mutex_lock",
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end"
            ],
            "imported": false,
            "current_name": "set_flag_bit_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "data_pointer",
                "DAT_00003684": "data_value",
                "PTR_": "ptr_",
                "uint": "unsigned_int"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* PTR_data = (uint*)(DAT_00003680 + 0xc);\n    *PTR_data = (DAT_00003684 | (*PTR_data & 0x700));\n    DataSynchronizationBarrier(0xf);\n    while(true)\n    {\n        // Do nothing, infinite loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "pm_reboot"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "enable_oscillator_and_set_fll_factor_000019c0",
                "DAT_00001a0c": "data_00001a0c",
                "DAT_00001a10": "data_00001a10",
                "PTR_current_mode_00001a14": "current_mode_ptr_00001a14"
            },
            "code": "void enable_oscillator_and_set_fll_factor_000019c0(void)\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  bit_clear8(DAT_00001a0c, '\\x01');\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  do {\n  } while ((DAT_00001a10[6] & 0xc) != 8);\n  kinetis_mcg_disable_pll();\n  *PTR_current_mode_00001a14 = 3;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_memory_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "source_ptr",
                "puVar2": "end_ptr",
                "puVar3": "destination_ptr"
            },
            "code": "void* copy_memory_000060b0(void* destination, const void* source, size_t num_bytes) {\n    unsigned char* dest = (unsigned char*) destination;\n    const unsigned char* src = (const unsigned char*) source;\n    for (size_t i = 0; i < num_bytes; i++) {\n        dest[i] = src[i];\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "copy_memory_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "call_afl_if_no_hypercall_000023d0",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_000023fc": "no_hypercall_ptr"
            },
            "code": "uint32_t call_afl_if_no_hypercall_000023d0(int ticks) {\n\tint* PTR_noHyperCall_000023fc = PTR_noHyperCall_000023fc;\n\tuint32_t result;\n\tif (*PTR_noHyperCall_000023fc == 0) {\n\t\tresult = aflCall(1, ticks, 0);\n\t}\n\telse {\n\t\tresult = 0;\n\t}\n\treturn result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "call_afl_if_no_hypercall_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "nmi_handler_00000a30",
                "PTR_s_NMI_HANDLER_00000a3c": "nmi_handler_ptr"
            },
            "code": "void nmi_handler_00000a30(void)\n{\n\tcore_panic(PANIC_NMI_HANDLER, PTR_s_NMI_HANDLER_00000a3c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "nmi_handler_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "usage_rtc_command_arguments",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_new_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_new_time"
            },
            "code": "int print_rtc_commands_000034c0(void)\n{\n  puts(PTR_s_usage__rtc__command___arguments__00003500);\n  puts(PTR_s_PTR_s_commands__00003504__00003504);\n  puts(PTR_s__poweron_power_the_interface_on_00003508);\n  puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n  puts(PTR_s__clearalarm_deactivate_the_current_alarm_00003510);\n  puts(PTR_s__getalarm_print_the_currently_set_alarm_00003514);\n  puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518_00003518);\n  puts(PTR_s__gettime_print_the_current_time_0000351c);\n  puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520_00003520);\n  return 0;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "print_rtc_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "acquire_time_zone_mutex_000050e8",
                "PTR___lock___tz_mutex_000050f0": "time_zone_mutex"
            },
            "code": "void acquire_time_zone_mutex_000050e8(void)\n{\n  __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "acquire_time_zone_mutex_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "data_address",
                "uVar1": "result",
                "iVar2": "global_data_address",
                "bVar3": "is_global_data",
                "PTR__global_impure_ptr_0000430c": "GLOBAL_DATA_PTR",
                "DAT_00004310": "GLOBAL_DATA_VALUE",
                "DATA_INITIALIZED_OFFSET": "0x18",
                "DATA_FIELD1_OFFSET": "0x48",
                "DATA_FIELD2_OFFSET": "0x4c",
                "DATA_FIELD3_OFFSET": "0x50",
                "FIELD1_PTR_OFFSET": "0x4",
                "FIELD2_PTR_OFFSET": "0x8",
                "FIELD3_PTR_OFFSET": "0xc"
            },
            "code": "void initialize_data_000042a4(int data_address)\n{\n  acquire_data_lock();\n  if (*(int *)(data_address + DATA_INITIALIZED_OFFSET) == 0) {\n    *(int *)(data_address + DATA_FIELD1_OFFSET) = 0;\n    *(int *)(data_address + DATA_FIELD2_OFFSET) = 0;\n    *(int *)(data_address + DATA_FIELD3_OFFSET) = 0;\n    int global_data_address = *(int *)PTR__global_impure_ptr_0000430c;\n    *(int *)(data_address + DATA_FIELD4_OFFSET) = DAT_00004310;\n    bool is_global_data = global_data_address == data_address;\n    if (is_global_data) {\n      global_data_address = 1;\n    }\n    if (is_global_data) {\n      *(int *)(data_address + DATA_INITIALIZED_OFFSET) = global_data_address;\n    }\n    int uVar1 = __sfp(data_address);\n    *(int *)(data_address + FIELD1_PTR_OFFSET) = uVar1;\n    uVar1 = __sfp(data_address);\n    *(int *)(data_address + FIELD2_PTR_OFFSET) = uVar1;\n    uVar1 = __sfp(data_address);\n    *(int *)(data_address + FIELD3_PTR_OFFSET) = uVar1;\n    std(*(int *)(data_address + FIELD1_PTR_OFFSET), 4, 0);\n    std(*(int *)(data_address + FIELD2_PTR_OFFSET), 9, 1);\n    std(*(int *)(data_address + FIELD3_PTR_OFFSET), 0x12, 2);\n    *(int *)(data_address + DATA_INITIALIZED_OFFSET) = 1;\n  }\n  release_data_lock();\n  return;\n}",
            "called": [
                "__sinit_lock_acquire",
                "__sinit_lock_release",
                "std",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "_fflush_r",
                "__sfp",
                "_puts_r",
                "getchar",
                "iprintf",
                "putchar",
                "__swsetup_r",
                "_vfprintf_r",
                "__srget_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "initialize_data_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_errno_to_permission_denied_00000514",
                "r": "reent",
                "fd": "file_descriptor",
                "st": "file_status",
                "_errno": "EACCES"
            },
            "code": "int set_errno_to_permission_denied_00000514(_reent *reent, int file_descriptor, stat *file_status)\n{\n  reent->_errno = EACCES;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_permission_denied_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "arg_count",
                "argv": "arg_values"
            },
            "code": "int reboot_system_00002e9c(int arg_count, char **arg_values)\n{\n  pm_reboot();\n  return 0;\n}",
            "called": [
                "pm_reboot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "reboot_system_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "setFLLFactorAndClearBit_00001960",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "DAT_000019b4": "DAT_current_mode",
                "DAT_000019b8": "DAT_000019b8",
                "PTR_current_mode_000019bc": "PTR_current_mode"
            },
            "code": "void setFLLFactorAndClearBit_00001960(void)\n{\n  setFLLFactor(KINETIS_MCG_FLL_FACTOR_1464);\n  clearBit(DAT_000019b4,'\\x01');\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_current_mode_000019bc = 2;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "setFLLFactorAndClearBit_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_current_mode_to_five_00001a3c",
                "DAT_00001a58": "mode_register",
                "kinetis_mcg_disable_pll": "disable_pll",
                "PTR_current_mode_00001a5c": "current_mode_ptr"
            },
            "code": "void set_current_mode_to_five_00001a3c(void)\n{\n  bit_set8(DAT_00001a58, 0x01);\n  disable_pll();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_five_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "code": "void * reverse_copy_000045ee(void *destination, const void *source, size_t num_bytes)\n{\n  unsigned char *src = (unsigned char*)source;\n  unsigned char *dest = (unsigned char*)destination;\n  \n  if (src < dest && dest < src + num_bytes) {\n    for (size_t i = num_bytes; i > 0; i--) {\n      dest[i-1] = src[i-1];\n    }\n  }\n  else {\n    for (size_t i = 0; i < num_bytes; i++) {\n      dest[i] = src[i];\n    }\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "write_to_stream_00005404",
                "param_1": "stream_handle",
                "param_2": "character",
                "param_3": "stream_buffer",
                "param_4": "flags",
                "iVar1": "buffer_size",
                "uVar2": "short_value",
                "puVar3": "buffer_pointer"
            },
            "code": "uint write_to_stream_00005404(int stream_handle, uint character, int *stream_buffer, undefined4 flags)\n{\n  int buffer_size;\n  uint short_value;\n  undefined *buffer_pointer;\n  if ((stream_handle != 0) && (*(int *)(stream_handle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (int *)PTR___sf_fake_stdin_0000549c) {\n    stream_buffer = *(int **)(stream_handle + 4);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stdout_000054a0) {\n    stream_buffer = *(int **)(stream_handle + 8);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stderr_000054a4) {\n    stream_buffer = *(int **)(stream_handle + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  short_value = (uint)*(ushort *)(stream_buffer + 3);\n  buffer_size = short_value << 0x1c;\n  if (((buffer_size < 0) && (short_value = stream_buffer[4], short_value != 0)) || (buffer_size = __swsetup_r(stream_handle, stream_buffer, buffer_size, short_value, flags), buffer_size == 0)) {\n    buffer_size = *stream_buffer - stream_buffer[4];\n    character = character & 0xff;\n    if ((buffer_size < stream_buffer[5]) || (buffer_size = _fflush_r(stream_handle, stream_buffer), buffer_size == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      buffer_pointer = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(buffer_pointer + 1);\n      *buffer_pointer = (char)character;\n      if (stream_buffer[5] != buffer_size + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      buffer_size = _fflush_r(stream_handle, stream_buffer);\n      if (buffer_size == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "_puts_r",
                "__sfputc_r",
                "_putc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "divide_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "unused",
                "iVar1": "quotient",
                "local_8": "unused"
            },
            "code": "int divide_00006974(int divide_00006974nd, int divisor, int *remainder) {\n  int quotient;\n  if (divisor == 0) {\n    quotient = divide_00006974nd > 0 ? INT_MAX : INT_MIN;\n    if (remainder) *remainder = 0;\n    return quotient;\n  }\n  if (divide_00006974nd == INT_MIN && divisor == -1) {\n    quotient = INT_MAX;\n    if (remainder) *remainder = 0;\n    return quotient;\n  }\n  quotient = divide_00006974nd / divisor;\n  if (remainder) *remainder = divide_00006974nd % divisor;\n  return quotient;\n}",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "gmtime_r"
            ],
            "imported": false,
            "current_name": "divide_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "find_and_initialize_00004314",
                "param_1": "error_code",
                "piVar1": "block_header",
                "piVar2": "block_footer",
                "iVar3": "current_block",
                "ppiVar4": "pointer_to_current_block",
                "PTR__global_impure_ptr_00004398": "current_block",
                "DAT_0000439c": "default_value",
                "__sinit": "initialize_block",
                "__retarget_lock_init_recursive": "initialize_recursive_lock",
                "FUN_00004314_lock_acquire": "find_and_initialize_lock_acquire",
                "FUN_00004314_lock_release": "find_and_initialize_lock_release"
            },
            "code": "int *find_and_initialize_00004314(int *error_code) {\n    int *result;\n    int *PTR__global_impure_ptr_00004398;\n    int **pointer_to_PTR__global_impure_ptr_00004398;\n    int **pointer_to_last_block;\n    int *block_header;\n    int *block_footer;\n    int block_size;\n    int i;\n    result = NULL;\n    find_and_initialize_00004314_lock_acquire();\n    PTR__global_impure_ptr_00004398 = PTR__global_impure_ptr_00004398;\n    if (*PTR__global_impure_ptr_00004398 == 0) {\n        __sinit(PTR__global_impure_ptr_00004398);\n    }\n    pointer_to_last_block = (int **)(PTR__global_impure_ptr_00004398 + 0x48);\n    pointer_to_PTR__global_impure_ptr_00004398 = *pointer_to_last_block;\n    while (true) {\n        block_header = pointer_to_PTR__global_impure_ptr_00004398[1];\n        block_footer = pointer_to_PTR__global_impure_ptr_00004398[2];\n        for (i = block_header[0]; i > 0; i--) {\n            if (*(short *)(block_footer + 3) == 0) {\n                block_footer[3] = DAT_0000439c;\n                block_footer[0x19] = 0;\n                __retarget_lock_init_recursive(block_footer + 0x16);\n                find_and_initialize_00004314_lock_release();\n                block_footer[1] = 0;\n                block_footer[2] = 0;\n                block_footer[4] = 0;\n                block_footer[5] = 0;\n                *block_footer = 0;\n                block_footer[6] = 0;\n                memset(block_footer + 0x17, 0, 8);\n                block_footer[0xd] = 0;\n                block_footer[0xe] = 0;\n                block_footer[0x12] = 0;\n                block_footer[0x13] = 0;\n                return block_footer;\n            }\n            block_footer += 0x1a;\n        }\n        if (pointer_to_PTR__global_impure_ptr_00004398[0] == NULL) {\n            block_size = 4;\n            result = __sfmoreglue(error_code, block_size);\n            if (result == NULL) {\n                find_and_initialize_00004314_lock_release();\n                *error_code = 0xc;\n                return NULL;\n            }\n            pointer_to_PTR__global_impure_ptr_00004398[0] = result;\n        }\n        pointer_to_last_block = pointer_to_PTR__global_impure_ptr_00004398;\n        pointer_to_PTR__global_impure_ptr_00004398 = *pointer_to_last_block;\n    }\n}",
            "called": [
                "__sfmoreglue",
                "memset",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "__sfp_lock_acquire",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "find_and_initialize_00004314"
        },
        "FUN_00005fd4": {
            "renaming": {
                "FUN_00005fd4": "parse_uint_from_string_00005fd4",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "next_char",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "digit_value",
                "bVar3": "is_negative",
                "iVar4": "parse_status",
                "uVar5": "digit_value",
                "uVar6": "max_uint_div_base",
                "pbVar7": "current_char",
                "pbVar8": "start_char",
                "PTR_DAT_00005fd0": "digit_properties"
            },
            "code": "uint parse_uint_from_string_00005fd4(undefined4 *output, byte *input_string, byte **next_char, uint base) {\n  uint digit_value;\n  uint overflow_threshold;\n  byte *current_char;\n  byte *start_char;\n  bool is_negative;\n  uint value;\n  int parse_status;\n  uint max_uint_div_base;\n  uint max_uint_mod_base;\n  \n  current_char = input_string;\n  do {\n    start_char = current_char;\n    current_char++;\n    digit_value = (uint)*start_char;\n    is_negative = (PTR_DAT_00005fd0[digit_value] & 8) != 0;\n  } while (is_negative);\n  if (digit_value == 0x2d) {\n    digit_value = (uint)*current_char;\n    is_negative = true;\n    current_char++;\n  }\n  else if (digit_value == 0x2b) {\n    digit_value = (uint)*current_char;\n    current_char++;\n  }\n  if (base == 0) {\n    if (digit_value != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if (base != 0x10 || digit_value != 0x30) {\n    goto LAB_00005f26;\n  }\n  if ((*current_char & 0xdf) == 0x58) {\n    digit_value = (uint)current_char[1];\n    base = 0x10;\n    current_char += 2;\n  }\n  else {\n    digit_value = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  parse_status = 0;\n  max_uint_div_base = 0xffffffff / base;\n  max_uint_mod_base = 0xffffffff % base;\n  value = 0;\n  do {\n    digit_value -= 0x30;\n    if (9 < digit_value) {\n      if (digit_value - 0x41 < 0x1a) {\n        digit_value -= 0x37;\n      }\n      else {\n        if (0x19 < digit_value - 0x61) break;\n        digit_value -= 0x57;\n      }\n    }\n    if ((int)base <= (int)digit_value) break;\n    if (((parse_status < 0) || (max_uint_div_base < value)) || ((max_uint_div_base == value && ((int)~(base * max_uint_div_base) < (int)digit_value)))) {\n      parse_status = -1;\n    }\n    else {\n      value = value * base + digit_value;\n      parse_status = 1;\n    }\n    digit_value = (uint)*current_char;\n    current_char++;\n  } while (true);\n  if (parse_status < 0) {\n    *output = 0x22;\n    value = 0xffffffff;\n    if (next_char == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (is_negative) {\n      value = -value;\n    }\n    if (next_char == (byte **)0x0) {\n      return value;\n    }\n    if (parse_status == 0) goto LAB_00005fb8;\n  }\n  start_char = current_char - 1;\nLAB_00005fb8:\n  *next_char = start_char;\n  return value;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd4",
            "calling": [],
            "imported": false,
            "current_name": "parse_uint_from_string_00005fd4"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "read_file_00004dc8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "_Var1": "bytes_read",
                "uVar2": "total_bytes_read",
                "bVar3": "success",
                "*(int *)(param_2 + 0x54)": "total_bytes_read",
                "*(ushort *)(param_2 + 0xc)": "flags"
            },
            "code": "void read_file_00004dc8(_reent *reent, int file_descriptor, void *buffer, size_t buffer_size) {\n  _ssize_t bytes_read = _read_r(reent, (int)*(short *)(file_descriptor + 0xe), buffer, buffer_size);\n  bool success = (bytes_read >= 0);\n  if (success) {\n    uint total_bytes_read = *(int *)(file_descriptor + 0x54) + bytes_read;\n    *(uint *)(file_descriptor + 0x54) = total_bytes_read;\n  }\n  else {\n    ushort flags = *(ushort *)(file_descriptor + 0xc);\n    flags &= 0xffffefff;\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n}\n",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "read_file_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "convert_string_to_ulong_00005fd8",
                "__nptr": "str",
                "__endptr": "endptr",
                "__base": "base",
                "uVar1": "result"
            },
            "code": "unsigned long convert_string_to_ulong_00005fd8(char* str, char** endptr, int base) {\n  unsigned long result = _convert_string_to_ulong_00005fd8_l_isra_0(*(unsigned long*)PTR__impure_ptr_00005fe8, str, endptr, base);\n  return result;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "convert_string_to_ulong_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_from_stream_00005e10",
                "param_1": "stream_handle",
                "param_2": "stream_ptr",
                "iVar1": "refill_result",
                "uVar2": "byte_read",
                "pbVar3": "current_byte"
            },
            "code": "uint read_byte_from_stream_00005e10(int stream_handle, byte **stream_ptr)\n{\n  int refill_result;\n  uint byte_read;\n  byte *current_byte;\n  \n  if ((stream_handle != 0) && (*(int *)(stream_handle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_ptr == (byte **)PTR___sf_fake_stdin_00005e5c) {\n    stream_ptr = *(byte ***)(stream_handle + 4);\n  }\n  else if (stream_ptr == (byte **)PTR___sf_fake_stdout_00005e60) {\n    stream_ptr = *(byte ***)(stream_handle + 8);\n  }\n  else if (stream_ptr == (byte **)PTR___sf_fake_stderr_00005e64) {\n    stream_ptr = *(byte ***)(stream_handle + 0xc);\n  }\n  refill_result = __srefill_r(stream_handle, stream_ptr);\n  if (refill_result == 0) {\n    stream_ptr[1] = stream_ptr[1] + -1;\n    current_byte = *stream_ptr;\n    *stream_ptr = current_byte + 1;\n    byte_read = (uint)*current_byte;\n  }\n  else {\n    byte_read = 0xffffffff;\n  }\n  return byte_read;\n}",
            "called": [
                "__srefill_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "_getc_r"
            ],
            "imported": false,
            "current_name": "read_byte_from_stream_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_rtc_alarm_000033f4",
                "argv": "time_input",
                "iVar1": "parse_result",
                "now": "current_time",
                "_parse_time": "parse_input_time",
                "rtc_set_alarm": "rtc_set_alarm",
                "DAT_0000343c": "ALARM_OFFSET"
            },
            "code": "int set_rtc_alarm_000033f4(char **time_input)\n{\n    int parse_result;\n    tm current_time;\n    parse_result = parse_input_time(time_input, &current_time);\n    if (parse_result == 0) {\n        int set_result = rtc_set_alarm(&current_time, DAT_0000343c, (void *)0x0);\n        if (set_result == -1) {\n            puts(PTR_s_rtc__error_setting_alarm_00003440);\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    else {\n        return 1;\n    }\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "decode_time_0000443c",
                "__timer": "time",
                "__decoded_time": "decoded_time",
                "iVar1": "quotient",
                "uVar2": "modulo",
                "uVar3": "days_since_sunday",
                "uVar4": "days_since_1900",
                "iVar5": "days_since_jan_1",
                "uVar6": "years_since_1900",
                "uVar9": "days_in_month",
                "tVar7": "seconds_since_epoch",
                "tVar8": "microseconds_since_epoch",
                "DAT_0000458c": "SECONDS_IN_DAY",
                "DAT_00004594": "DAYS_IN_4_YEARS",
                "DAT_00004590": "DAYS_IN_YEAR",
                "DAT_00004598": "DAYS_IN_100_YEARS",
                "bVar10": "is_negative",
                "count_leading_zeroes": "count_leading_zeros",
                "__tp": "decoded_time"
            },
            "code": "tm * decode_time_0000443c(time_t *__timer, tm *__decoded_time)\n{\n    int quotient;\n    uint modulo, days_since_sunday, days_since_1900, years_since_1900, leap_years_since_1900, days_since_jan_1, days_in_month;\n    time_t seconds_since_epoch = *__timer;\n    time_t microseconds_since_epoch = __timer[1];\n    quotient = __aeabi_ldivmod(seconds_since_epoch, microseconds_since_epoch, 86400, 0);\n    modulo = 86400;\n    __aeabi_ldivmod(seconds_since_epoch, microseconds_since_epoch, 86400, 0);\n    bool is_negative = (int)modulo < 0;\n    if (is_negative) {\n        modulo = modulo + 86400;\n        quotient = quotient + 1;\n    }\n    days_since_sunday = (quotient + 3) % 7;\n    days_since_jan_1 = quotient;\n    if (is_negative) {\n        days_since_jan_1 = quotient - 365;\n        if (leap_year(years_since_1900)) {\n            days_since_jan_1--;\n        }\n    }\n    years_since_1900 = days_since_jan_1 / 365;\n    leap_years_since_1900 = years_since_1900 / 4;\n    days_since_1900 = days_since_jan_1 - (years_since_1900 * 365 + leap_years_since_1900);\n    days_in_month = days_since_1900;\n    for (int month = 0; month < 12; month++) {\n        int days_in_previous_month = days_in_month;\n        days_in_month -= days_in_month_of_month[month];\n        if (days_in_month < 0) {\n            days_in_month = days_in_previous_month;\n            break;\n        }\n    }\n    __decoded_time->tm_sec = modulo % 60;\n    __decoded_time->tm_min = (modulo / 60) % 60;\n    __decoded_time->tm_hour = modulo / 3600;\n    __decoded_time->tm_mday = days_in_month + 1;\n    __decoded_time->tm_mon = month;\n    __decoded_time->tm_year = years_since_1900 + 1900;\n    __decoded_time->tm_wday = days_since_sunday;\n    __decoded_time->tm_yday = days_since_jan_1;\n    __decoded_time->tm_isdst = 0;\n    return __decoded_time;\n}",
            "called": [
                "__aeabi_ldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "decode_time_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_rtt_000027b0",
                "puVar1": "rtt_registers",
                "rtt": "rtt_module"
            },
            "code": "void initialize_rtt_000027b0(void)\n{\n  uint32_t *rtt_registers = DAT_00002814;\n  RTC_Type *rtt_module = (RTC_Type *) DAT_00002818;\n  \n  rtt_module->MODE2_CTRL.reg |= RTC_MODE2_CTRL_ENABLE_Msk;\n  rtt_registers[4] = 1;\n  rtt_registers[4] = 0;\n  if ((rtt_registers[5] & 1) != 0) {\n    *rtt_registers = 0;\n  }\n  rtt_registers[4] = 0x104;\n  rtt_registers[2] = 0xffffff42;\n  rtt_registers[7] = 0;\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "rtc_init"
            ],
            "imported": false,
            "current_name": "initialize_rtt_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "pcVar2": "destination_start"
            },
            "code": "char* copy_string_00005ebc(char* destination, char* source) {\n    char current_char;\n    char* destination_start = destination;\n    do {\n        current_char = *source;\n        *destination_start = current_char;\n        source++;\n        destination_start++;\n    } while (current_char != \"\\0\");\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "releaseMemoryIfNotBound_00006192",
                "param_1": "size",
                "param_2": "memoryBlock",
                "PTR_0000000d": "boundBlock",
                "PTR_00000010": "blockSize",
                "PTR_0000000f": "previousBlock",
                "PTR_00000004": "nextBlock"
            },
            "code": "unsigned int releaseMemoryIfNotBound_00006192(unsigned int size, unsigned int *memoryBlock)\n{\n    unsigned int *PTR_0000000d = (unsigned int *)memoryBlock[0xd];\n    if (PTR_0000000d != NULL)\n    {\n        if (PTR_0000000d != memoryBlock + 0x11)\n        {\n            free(PTR_0000000d);\n        }\n        memoryBlock[1] = memoryBlock[0x10];\n        memoryBlock[0xd] = NULL;\n        if (memoryBlock[0x10] != NULL)\n        {\n            *memoryBlock = memoryBlock[0xf];\n            return 0;\n        }\n    }\n    *memoryBlock = memoryBlock[4];\n    memoryBlock[1] = NULL;\n    *(unsigned short *)(memoryBlock + 3) |= 0x20;\n    return 0xffffffff;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "releaseMemoryIfNotBound_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_bit_6_of_dat_00001744_00001734",
                "DAT_00001744": "dat_00001744"
            },
            "code": "void clear_bit_6_of_dat_00001744_00001734(void)\n{\n  bit_clear8(DAT_00001744, 0x06);\n  return;\n}",
            "called": [
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "clear_bit_6_of_dat_00001744_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "read_isr_pipe_00000e14",
                "buffer": "data_buffer",
                "count": "buffer_size",
                "iVar1": "bytes_read"
            },
            "code": "int read_isr_pipe_00000e14(char *buffer, int count)\n{\n  int bytes_read;\n  bytes_read = isrpipe_read((isrpipe_t *)PTR_uart_stdio_isrpipe_00000e34, buffer, count);\n  return bytes_read;\n}",
            "called": [
                "isrpipe_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "read_isr_pipe_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "get_rtc_type_0000281c",
                "*rtt": "rtc_type",
                "i": "loop_counter",
                "t": "rtc_value"
            },
            "code": "uint32_t get_rtc_type_0000281c(void)\n{\n  RTC_Type *rtc_type;\n  int i = 0;\n  uint32_t t;\n  \n  while (i < 3 && (t = *DAT_00002858) != *DAT_00002858)\n  {\n    i++;\n  }\n  return t;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "get_rtc_type_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "get_write_status_00002270",
                "rb": "ring_buffer",
                "bVar1": "write_status",
                "uVar2": "num_writes",
                "bVar3": "is_full"
            },
            "code": "uint32_t get_write_status_00002270(tsrb_t *ring_buffer) {\n  uint32_t num_writes = ring_buffer->writes;\n  bool is_full = (ring_buffer->reads == num_writes);\n  uint8_t write_status = is_full ? 1 : 0;\n  if (!is_full) {\n    write_status = 0;\n  }\n  return write_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "get_write_status_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "call_function_with_ptr_00005780",
                "__ptr": "pointer",
                "PTR__impure_ptr_0000578c": "impure_ptr"
            },
            "code": "void call_function_with_ptr_00005780(void *__ptr)\n{\n  function_with_ptr(*(undefined4 *)PTR__PTR__impure_ptr_0000578c_0000578c,__ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "call_function_with_ptr_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "handle_interrupt_000020cc",
                "DAT_000020dc": "interrupt_type"
            },
            "code": "void handle_interrupt_000020cc(void)\n{\n  int DAT_000020dc = DAT_000020dc;\n  irq_handler(DAT_000020dc, 1);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396",
                "rtc_init": "rtc_initialize"
            },
            "code": "void initialize_rtc_00002396(void)\n{\n  rtc_init();\n  return;\n}",
            "called": [
                "rtc_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_rtc_00002396"
        },
        "FUN_00004e4a": {
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reent",
                "param_2": "file_descriptor"
            },
            "code": "void close_file_00004e4a(_reent *reent, int file_descriptor) {\n  _close_r(reent, (int)*(short *)(file_descriptor + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e4a",
            "calling": [],
            "imported": false,
            "current_name": "close_file_00004e4a"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "write_character_to_output_00004cb4",
                "__c": "character",
                "in_r3": "in_register_3",
                "iVar1": "impure_ptr_value",
                "PTR__impure_ptr_00004cd8": "PTR__impure_ptr_00004cd8",
                "__sinit": "__sinit",
                "_putc_r": "_putc_r"
            },
            "code": "int write_character_to_output_00004cb4(int character) {\n  undefined4 in_register_3;\n  int impure_ptr_value = *(int *)PTR__impure_ptr_00004cd8;\n  if ((impure_ptr_value != 0) && (*(int *)(impure_ptr_value + 0x18) == 0)) {\n    __sinit(impure_ptr_value);\n  }\n  int result = _putc_r(impure_ptr_value, character, *(undefined4 *)(impure_ptr_value + 8), in_register_3);\n  return result;\n}",
            "called": [
                "_putc_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "_putchar"
            ],
            "imported": false,
            "current_name": "write_character_to_output_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_rtc_time_00003478",
                "argv": "arguments",
                "now": "current_time",
                "iVar1": "status",
                "_parse_time": "parse_time_from_arguments",
                "rtc_set_time": "rtc_set_time",
                "PTR_s_rtc__error_setting_time_000034bc": "PTR_s_rtc__error_setting_time_000034bc"
            },
            "code": "int set_rtc_time_00003478(char **arguments)\n{\n  int status;\n  tm current_time;\n  \n  status = parse_time_from_arguments(arguments,&current_time);\n  if (status == 0) {\n    status = rtc_set_time(&current_time);\n    if (status == -1) {\n      puts(PTR_s_rtc__error_setting_time_000034bc);\n      status = 1;\n    }\n    else {\n      status = 0;\n    }\n  }\n  else {\n    status = 1;\n  }\n  return status;\n}",
            "called": [
                "rtc_set_time",
                "_parse_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_time_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "handle_port_interrupt_00002028",
                "port_num": "port_number",
                "iVar1": "context_index",
                "uVar2": "interrupt_status",
                "ctx": "context_index",
                "status": "interrupt_status",
                "i": "i",
                "PTR_isr_ctx_000020b4": "isr_context_pointer"
            },
            "code": "void handle_port_interrupt_00002028(PORT_Type *port, int port_number) {\n  int context_index;\n  uint32_t interrupt_status;\n  uint32_t pin_mask;\n\n  interrupt_status = port->ISFR;\n  for (int i = 0; i < 32; i++) {\n    pin_mask = 1 << (i & 0xffU);\n    if ((interrupt_status & pin_mask) && ((port->PCR[i] & 0xf0000) != 0)) {\n      port->ISFR = pin_mask;\n      context_index = get_context_index(port_number, i);\n      (**(code **)(PTR_isr_ctx_000020b4 + context_index * 0xc))\n                (*(undefined4 *)(PTR_isr_ctx_000020b4 + context_index * 0xc + 4));\n    }\n  }\n  end_interrupt();\n  return;\n}",
            "called": [
                "cortexm_isr_end",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "isr_porte",
                "isr_portd",
                "isr_portb",
                "isr_portc",
                "isr_porta"
            ],
            "imported": false,
            "current_name": "handle_port_interrupt_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_bit_at_position_000016c8",
                "ptr": "memory_address",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_at_position_000016c8(uint32_t *memory_address, uint8_t bit_position)\n{\n  uint32_t *bit_address = (uint32_t *)(0x42000000 + ((memory_address - 0x20000000) * 32) + (bit_position * 4));\n  *bit_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "set_current_mode_to_six_00001a60",
                "DAT_00001ac4": "mode_register",
                "DAT_00001ac8": "control_register",
                "DAT_00001acc": "bit_register",
                "*PTR_current_mode_00001ad0": "*current_mode"
            },
            "code": "void set_current_mode_to_six_00001a60(void)\n{\n  clear_bit_in_byte(DAT_00001ac4, 0x01);\n  *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 0x08);\n  set_bit_in_byte(DAT_00001ac4, 0x06);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_current_mode_00001ad0 = 6;\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_six_00001a60"
        },
        "FUN_000004b2": {
            "renaming": {
                "FUN_000004b2": "write_data_to_uart_000004b2",
                "r": "reent_ptr",
                "fd": "file_descriptor",
                "data": "data_ptr",
                "count": "data_size",
                "iVar1": "write_count"
            },
            "code": "_ssize_t write_data_to_uart_000004b2(_reent *reent_ptr, int file_descriptor, void *data_ptr, size_t data_size)\n{\n  int write_count;\n  write_count = uart_stdio_write((char *)data_ptr, data_size);\n  return write_count;\n}",
            "called": [
                "uart_stdio_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004b2",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_data_to_uart_000004b2"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_kernel_0000099c",
                "uStack_18": "stack_limit",
                "top": "stack_top",
                "PTR__etext_00000a14": "etext",
                "pre_startup": "pre_startup",
                "PTR_isr_stack_00000a18": "isr_stack",
                "DAT_00000a1c": "default_isr_value",
                "PTR_heap_top_00000a20": "heap_top",
                "PTR_sched_num_threads_00000a24": "sched_num_threads",
                "PTR_sched_num_threads_00000a28": "sheap",
                "post_startup": "post_startup",
                "board_init": "board_init",
                "__libc_init_array": "__libc_init_array",
                "kernel_init": "kernel_init"
            },
            "code": "void initialize_kernel_0000099c(void)\n{\n  uint32_t stack_limit;\n  uint32_t *stack_top;\n  uint32_t *src;\n  uint32_t *dst;\n\n  stack_top = &stack_limit;\n  src = (uint32_t *)PTR__etext_00000a14;\n  pre_startup();\n  dst = (uint32_t *)PTR_isr_stack_00000a18;\n  while (dst < &stack_limit) {\n    *dst = DAT_00000a1c;\n    dst++;\n  }\n  dst = (uint32_t *)PTR_heap_top_00000a20;\n  while (dst < PTR_sched_num_threads_00000a24) {\n    *dst = *src;\n    src++;\n    dst++;\n  }\n  dst = (uint32_t *)PTR_sched_num_threads_00000a24;\n  while (dst < PTR_sched_num_threads_00000a28) {\n    *dst = 0;\n    dst++;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}",
            "called": [
                "pre_startup",
                "board_init",
                "post_startup",
                "kernel_init",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_kernel_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "read_input_00002d94",
                "buf": "buffer",
                "size": "buffer_size",
                "c_00": "character",
                "bVar1": "byte_value",
                "bVar2": "is_buffer_empty",
                "c": "character_count",
                "line_buf_ptr": "buffer_ptr",
                "_putchar": "putchar",
                "uint": "unsigned_int"
            },
            "code": "int read_input_00002d94(char *buffer, size_t buffer_size) {\n  int character;\n  byte byte_value;\n  bool is_buffer_empty;\n  int character_count;\n  char *buffer_ptr;\n  buffer_ptr = buffer;\n  while (true) {\n    if ((int)(buffer_size - 1) <= (int)buffer_ptr - (int)buffer) {\n      return -1;\n    }\n    character = getchar();\n    if (character < 0) {\n      break;\n    }\n    if ((character == 0xd) || (character == 10)) {\n      *buffer_ptr = '\\0';\n      putchar(0xd);\n      putchar(10);\n      is_buffer_empty = buffer_ptr == buffer;\n      if (is_buffer_empty) {\n        buffer = (char *)0x1;\n      }\n      byte_value = (byte)buffer;\n      if (!is_buffer_empty) {\n        byte_value = 0;\n      }\n      return (uint)byte_value;\n    }\n    if ((character == 8) || (character == 0x7f)) {\n      if (buffer_ptr != buffer) {\n        buffer_ptr = buffer_ptr + -1;\n        *buffer_ptr = '\\0';\n        putchar(8);\n        putchar(0x20);\n        putchar(8);\n      }\n    }\n    else {\n      *buffer_ptr = (char)character;\n      putchar(character);\n      buffer_ptr = buffer_ptr + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "getchar",
                "_putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "read_input_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "getPrefixUnit_00003918",
                "scale": "scale",
                "cVar1": "prefixUnit"
            },
            "code": "char getPrefixUnit_00003918(int8_t scale) {\n    char prefixUnit;\n    switch(scale) {\n        case 2:\n            prefixUnit = 'h';\n            break;\n        case 3:\n            prefixUnit = 'k';\n            break;\n        case 6:\n            prefixUnit = 'M';\n            break;\n        case 9:\n            prefixUnit = 'G';\n            break;\n        case 12:\n            prefixUnit = 'T';\n            break;\n        case 15:\n            prefixUnit = 'P';\n            break;\n        case -15:\n            prefixUnit = 'f';\n            break;\n        case -12:\n            prefixUnit = 'p';\n            break;\n        case -9:\n            prefixUnit = 'n';\n            break;\n        case -6:\n            prefixUnit = 'u';\n            break;\n        case -3:\n            prefixUnit = 'm';\n            break;\n        default:\n            prefixUnit = '\\0';\n            break;\n    }\n    return prefixUnit;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "getPrefixUnit_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "data",
                "iVar1": "result"
            },
            "code": "int read_sensor_data_00003d64(saul_reg_t *sensor, phydat_t *data){\n  int result;\n  if (sensor == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "probe"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "str1",
                "__s2": "str2",
                "uVar2": "current_char_str1",
                "bVar1": "current_char_str2",
                "bVar3": "is_same_char"
            },
            "code": "int compare_strings_00004e52(char* str1, char* str2) {\n  char current_char_str1;\n  char current_char_str2;\n  bool is_same_char;\n  do {\n    current_char_str1 = *str1;\n    current_char_str2 = *str2;\n    is_same_char = current_char_str1 == current_char_str2;\n    if (current_char_str1 == '\\0') {\n      break;\n    }\n    str1++;\n    str2++;\n  } while (is_same_char);\n  return current_char_str1 - current_char_str2;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "_tzset_unlocked_r",
                "read",
                "find_handler",
                "strcmp",
                "_saul",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stacksize": "stack_size",
                "state_00": "state",
                "process": "thread",
                "local_30": "remaining_stack_size",
                "local_2c": "stack_boundary",
                "stack_size": "aligned_stack_size",
                "stackp": "stack_pointer",
                "i": "pid",
                "name": "name",
                "function": "function",
                "arg": "arg",
                "priority": "priority",
                "flags": "flags",
                "misalignment": "misalignment",
                "total_stacksize": "total_stack_size"
            },
            "code": "kernel_pid_t create_thread_000010d4(char *stack, int stack_size, char priority, int flags, thread_task_func_t function, void *arg, char *name)\\n{\\n  uint state;\\n  char *stack_ptr;\\n  uint aligned_stack_size;\\n  thread_t *thread;\\n  int remaining_stack_size;\\n  uintptr_t *stack_boundary;\\n  uintptr_t *stack_pointer;\\n  uintptr_t misalignment;\\n  int total_stack_size;\\n  kernel_pid_t pid = 0;\\n  if ((byte)priority >= 0x10) {\\n    return -0x16;\\n  }\\n  aligned_stack_size = (stack_size - 0x30U) & 0xfffffffc;\\n  stack_ptr = stack;\\n  if (((uint)stack & 3) != 0) {\\n    misalignment = 4 - ((uint)stack & 3);\\n    stack_boundary = (uintptr_t *)(stack + misalignment);\\n    aligned_stack_size -= misalignment;\\n    stack_ptr = (char *)stack_boundary;\\n  }\\n  thread = (thread_t *)(aligned_stack_size + (int)stack_ptr);\\n  if ((flags & 8U) == 0) {\\n    *stack_boundary = (uintptr_t)stack_boundary;\\n  }\\n  else {\\n    for (stack_pointer = stack_boundary; stack_pointer < (uintptr_t *)(aligned_stack_size + (int)stack_ptr); stack_pointer++) {\\n      *stack_pointer = (uintptr_t)stack_pointer;\\n    }\\n  }\\n  state = irq_disable();\\n  for (pid = 1; pid < 0x21; pid++) {\\n    if (*(int *)(PTR_sched_threads_0000126c + pid * 4) == 0) {\\n      *(thread_t **)(PTR_sched_threads_0000126c + pid * 4) = thread;\\n      thread->pid = pid;\\n      thread->sp = thread_stack_init(function, arg, stack_boundary, aligned_stack_size);\\n      thread->stack_start = (char *)stack_boundary;\\n      thread->stack_size = stack_size;\\n      thread->name = name;\\n      thread->priority = priority;\\n      thread->status = \"\\0\";\\n      (thread->rq_entry).next = NULL;\\n      thread->wait_data = NULL;\\n      (thread->msg_waiters).next = NULL;\\n      cib_init(&thread->msg_queue, 0);\\n      *(int *)PTR_sched_num_threads_00001270 = *(int *)PTR_sched_num_threads_00001270 + 1;\\n      if ((flags & 1U) == 0) {\\n        sched_set_status(thread, 10);\\n        if ((flags & 4U) == 0) {\\n          irq_restore(state);\\n          sched_switch(priority);\\n          return pid;\\n        }\\n      }\\n      else {\\n        sched_set_status(thread, 1);\\n      }\\n      irq_restore(state);\\n      return pid;\\n    }\\n  }\\n  irq_restore(state);\\n  return -0x8b;\\n}",
            "called": [
                "irq_disable",
                "thread_stack_init",
                "cib_init",
                "irq_restore",
                "sched_set_status",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "kernel_init"
            ],
            "imported": false,
            "current_name": "create_thread_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_thread_priority_00000738",
                "other_prio": "other_priority",
                "iVar1": "irq_status",
                "current_prio": "current_priority",
                "active_thread": "active_thread",
                "on_runqueue": "on_runqueue"
            },
            "code": "void check_thread_priority_00000738(uint16_t other_priority) {\n  int irq_status;\n  uint16_t current_priority;\n  thread_t *active_thread;\n  int on_runqueue;\n  \n  active_thread = *(thread_t **)PTR_sched_active_thread_0000078c;\n  current_priority = *(byte *)(active_thread + 4);\n  on_runqueue = *(byte *)(active_thread + 5);\n  \n  if (current_priority < 9 || other_priority < on_runqueue) {\n    irq_status = irq_is_in();\n    if (irq_status == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(undefined4 *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "thread_create",
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "check_thread_priority_00000738"
        },
        "FUN_000045e6": {
            "renaming": {
                "FUN_000045e6": "do_nothing_000045e6"
            },
            "code": "\nvoid do_nothing_000045e6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e6",
            "calling": [
                "__tz_lock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e6"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "convert_int_to_string_00003e58",
                "out": "output_string",
                "val": "input_int",
                "local_18": "positive_value",
                "local_14": "current_position",
                "negative": "is_negative"
            },
            "code": "size_t convert_int_to_string_00003e58(char *output_string, int32_t input_int)\n{\n  size_t string_length;\n  uint32_t positive_value;\n  char *current_position;\n  uint is_negative;\n  positive_value = input_int;\n  current_position = output_string;\n  is_negative = -(input_int >> 0x1f);\n  if (is_negative != 0) {\n    if (output_string != NULL) {\n      current_position = output_string + 1;\n      *output_string = '-';\n    }\n    positive_value = -input_int;\n  }\n  string_length = fmt_u32_dec(current_position, positive_value);\n  return is_negative + string_length;\n}",
            "called": [
                "fmt_u32_dec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "convert_int_to_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "read_file_00004e26",
                "param_1": "reentrant",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "file_position",
                "uVar2": "file_status",
                "bVar3": "is_error"
            },
            "code": "void read_file_00004e26(_reent *reentrant, int file_descriptor, _off_t offset, int whence){\n                      _off_t file_position;\n                      ushort file_status;\n                      bool is_error;\n                      \n                      file_position = _lseek_r(reentrant, *(short *)(file_descriptor + 0xe), offset, whence);\n                      is_error = file_position == -1;\n                      if (is_error) {\n                        file_status = *(ushort *)(file_descriptor + 0xc) & 0xefff;\n                      }\n                      else {\n                        *(_off_t *)(file_descriptor + 0x54) = file_position;\n                        file_status = *(ushort *)(file_descriptor + 0xc) | 0x1000;\n                      }\n                      if (is_error) {\n                        *(ushort *)(file_descriptor + 0xc) = file_status;\n                      }\n                      if (!is_error) {\n                        *(ushort *)(file_descriptor + 0xc) = file_status;\n                      }\n                      return;\n                    }",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "read_file_00004e26"
        },
        "FUN_00000978": {
            "renaming": {
                "FUN_00000978": "execute_active_thread_00000978",
                "PTR_sched_active_thread_0000098c": "active_thread_pointer",
                "isCurrentModePrivileged": "is_privileged_mode",
                "setProcessStackPointer": "set_process_stack_pointer",
                "UNRECOVERED_JUMPTABLE": "jumptable",
                "ppcVar2": "process_stack_pointer"
            },
            "code": "void execute_active_thread_00000978(void)\n{\n  bool is_privileged_mode;\n  code *jumptable;\n  code **process_stack_pointer;\n  \n  jumptable = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  process_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(process_stack_pointer);\n  }\n  /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n  /* WARNING: Treating indirect jump as call */\n  (*jumptable)(jumptable,process_stack_pointer);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000978",
            "calling": [],
            "imported": false,
            "current_name": "execute_active_thread_00000978"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "_puts_r",
                "__sinit_lock_acquire",
                "_fflush_r",
                "_vfprintf_r",
                "__sfp_lock_acquire",
                "_putc_r",
                "__malloc_lock",
                "__env_lock",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  void *pvVar6;\n  int *piVar7;\n  byte *pbVar8;\n  int unaff_r7;\n  byte *pbVar9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar4 = __swsetup_r(param_1,param_2), iVar4 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar2 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar9 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar8 = pbVar9;\n  if (*pbVar8 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar9 = pbVar8 + 1;\n  if (*pbVar8 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar4 = (int)pbVar8 - (int)param_3;\n  if (iVar4 != 0) {\n    iVar5 = __sfputs_r(param_1,param_2,param_3,iVar4);\n    if (iVar5 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar4;\n  }\n  if (*pbVar8 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar9 = pbVar8 + 1;\n  while( true ) {\n    pbVar8 = pbVar9 + 1;\n    pvVar6 = memchr(PTR_s___0__00005a44,(uint)*pbVar9,5);\n    puVar3 = PTR_DAT_00005a54;\n    if (pvVar6 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar6 - (int)puVar2 & 0xffU) | local_88;\n    pbVar9 = pbVar8;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar9 == 0x2a) {\n    piVar7 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar7;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar1 = false;\n    iVar4 = local_7c;\n    pbVar8 = pbVar9;\n    while( true ) {\n      if (9 < *pbVar8 - 0x30) break;\n      iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n      bVar1 = true;\n      pbVar8 = pbVar8 + 1;\n    }\n    if (bVar1) {\n      local_7c = iVar4;\n    }\n  }\n  if (*pbVar8 == 0x2e) {\n    if (pbVar8[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar8 = pbVar8 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar4 = 0;\n      while( true ) {\n        pbVar8 = pbVar8 + 1;\n        if (9 < *pbVar8 - 0x30) break;\n        iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar4;\n      }\n    }\n  }\n  pvVar6 = memchr(PTR_DAT_00005a54,(uint)*pbVar8,3);\n  if (pvVar6 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar6 - (int)puVar3 & 0xffU);\n    pbVar8 = pbVar8 + 1;\n  }\n  param_3 = pbVar8 + 1;\n  local_70 = *pbVar8;\n  pvVar6 = memchr(PTR_s_efgEFG_00005a48,(uint)local_70,6);\n  if (pvVar6 == (void *)0x0) {\n    iVar4 = _printf_i(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar4 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar4 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar4 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar4;\n  pbVar9 = param_3;\n  unaff_r7 = iVar4;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "__sfputs_r",
                "__retarget_lock_acquire_recursive",
                "__swsetup_r",
                "memchr",
                "__retarget_lock_release_recursive",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initializeSystemClock_000018bc",
                "DAT_00001910": "gSystemControlRegister1",
                "DAT_00001914": "gSystemControlRegister2",
                "PTR_current_mode_00001918": "gCurrentMode",
                "kinetis_mcg_set_fll_factor": "setFLLFactor",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLLFactor1464",
                "bit_clear8": "clearBit8"
            },
            "code": "void initializeSystemClock_000018bc(void)\n{\n  setFLLFactor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4;\n  clearBit8(DAT_00001914, 0x01);\n  while ((DAT_00001910[6] & 0x10) == 0);\n  while ((DAT_00001910[6] & 0xc) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initializeSystemClock_000018bc"
        },
        "FUN_00000974": {
            "renaming": {
                "FUN_00000974": "run_active_thread_00000974",
                "bVar1": "is_privileged",
                "UNRECOVERED_JUMPTABLE": "active_thread_fn",
                "ppcVar2": "active_thread_stack_ptr"
            },
            "code": "void run_active_thread_00000974(void)\n{\n  bool is_privileged;\n  code *active_thread_fn;\n  code **active_thread_stack_ptr;\n  \n  sched_run();\n  active_thread_fn = *(code **)**(undefined4 **)sched_active_thread;\n  active_thread_stack_ptr = (code **)**(undefined4 **)sched_active_thread + 9;\n  is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    setProcessStackPointer(active_thread_stack_ptr);\n  }\n  (*active_thread_fn)(active_thread_fn,active_thread_stack_ptr);\n  return;\n}",
            "called": [
                "sched_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000974",
            "calling": [
                "isr_pendsv"
            ],
            "imported": false,
            "current_name": "run_active_thread_00000974"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "panic_00000f04",
                "crash_code": "code",
                "message": "msg",
                "uStack_18": "stack_var1",
                "uStack_14": "stack_var2",
                "local_10": "msg",
                "local_9": "code"
            },
            "code": "void panic_00000f04(panic_00000f04_t crash_code, char *message){\n  undefined4 stack_var1;\n  undefined4 stack_var2;\n  char *msg;\n  panic_00000f04_t code;\n  \n  msg = message;\n  code = crash_code;\n  \n  if (*(int *)PTR_crashed_00000f4c == 0) {\n    *(undefined4 *)PTR_crashed_00000f4c = 1;\n    if (crash_code == PANIC_ASSERT_FAIL) {\n      print_last_instruction();\n    }\n    print(PTR_s_____RIOT_kernel_panic_00000f04___s_00000f50,msg);\n    ps();\n    print(PTR_DAT_00000f54);\n    print(PTR_s_____halted__00000f58);\n  }\n  \n  disable_interrupts();\n  panic_00000f04_arch();\n  stack_var2 = 0xf4d;\n  power_management_off();\n  stack_var1 = (int)&stack_var1 + 1;\n  auto_initialize();\n  print(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return;\n}",
            "called": [
                "irq_disable",
                "ps",
                "iprintf",
                "pm_off",
                "panic_arch",
                "cpu_print_last_instruction"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "thread_add_to_list",
                "bus_fault_default",
                "cib_init",
                "fmt_s32_dfp",
                "uart_init",
                "mem_manage_default",
                "debug_mon_default",
                "hard_fault_handler",
                "dummy_handler_default",
                "nmi_default",
                "usage_fault_default"
            ],
            "imported": false,
            "current_name": "panic_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "perform_context_switch_00000610",
                "uVar1": "bit_index",
                "iVar2": "current_thread_id",
                "iVar3": "next_thread_id",
                "active_thread": "active_thread",
                "nextrq": "runqueue_node",
                "__m____": "runqueue_node",
                "next_thread": "next_thread"
            },
            "code": "int perform_context_switch_00000610(void)\n{\n  uint32_t bit_index;\n  int current_thread_id;\n  int next_thread_id;\n  thread_t *active_thread;\n  clist_node_t *runqueue_node;\n  thread_t *next_thread;\n\n  *(uint32_t *)sched_context_switch_request = 0;\n  current_thread_id = *(int *)sched_active_thread;\n  bit_index = bitarithm_lsb(*(uint32_t *)runqueue_bitcache);\n  runqueue_node = **(clist_node_t ***)(queues + bit_index * 4);\n  next_thread_id = runqueue_node->thread_id;\n\n  if (current_thread_id == next_thread_id - 8) {\n    return 0;\n  }\n  else {\n    if ((current_thread_id != 0) && (*(char *)(current_thread_id + 4) == '\t')) {\n      *(char *)(current_thread_id + 4) = '\\n';\n    }\n    *(uint16_t *)sched_active_pid = *(uint16_t *)(next_thread_id - 2);\n    *(int *)sched_active_thread = next_thread_id - 8;\n    return 1;\n  }\n}",
            "called": [
                "bitarithm_lsb"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [
                "isr_svc"
            ],
            "imported": false,
            "current_name": "perform_context_switch_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_phydat_data_00003694",
                "data": "phydat_data",
                "dim": "num_dimensions",
                "sVar1": "length",
                "pcVar2": "unit_string",
                "cVar3": "unit_indicator",
                "uVar4": "bit_set",
                "bVar5": "is_bit_set",
                "num": "num_buffer",
                "len": "num_buffer_length",
                "i": "dimension_index"
            },
            "code": "void display_phydat_data_00003694(phydat_t *data, uint8_t num_dimensions) {\n  size_t length;\n  char *unit_string;\n  char scale_prefix;\n  uint8_t i;\n\n  if ((data == NULL) || (num_dimensions > 3)) {\n    puts(Unable_to_display_data_object);\n  }\n  else {\n    iprintf(Data: );\n    for (i = 0; i < num_dimensions; i++) {\n      if (data->unit < 20) {\n        bool is_bit_set = (DAT_000037ec & (1 << data->unit)) != 0;\n        char unit_indicator = is_bit_set ? 1 : 0;\n        if (unit_indicator == 0) {\n          scale_prefix = phydat_prefix_from_scale(data->scale);\n        }\n        else {\n          scale_prefix = 0;\n        }\n      }\n      else {\n        scale_prefix = phydat_prefix_from_scale(data->scale);\n      }\n      iprintf(%s );\n      if (num_dimensions < 2) {\n        iprintf( );\n      }\n      else {\n        iprintf(_%u , i);\n      }\n      if (scale_prefix == 0) {\n        if (data->scale == 0) {\n          iprintf(%d , data->val[i]);\n        }\n        else if ((data->scale + 4 < 0 == SCARRY4(data->scale, 4)) && (data->scale < 0)) {\n          length = fmt_s16_dfp(num, data->val[i], data->scale);\n          num[length] = 0;\n          iprintf(%s , num);\n        }\n        else {\n          iprintf(%dE%d , data->val[i], data->scale);\n        }\n      }\n      else {\n        iprintf(%6d%c , data->val[i], scale_prefix);\n      }\n      unit_string = phydat_unit_to_str(data->unit);\n      iprintf(%s, unit_string);\n    }\n  }\n}",
            "called": [
                "fmt_s16_dfp",
                "phydat_unit_to_str",
                "phydat_prefix_from_scale",
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "write",
                "probe"
            ],
            "imported": false,
            "current_name": "display_phydat_data_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "tsrb_push_00002364",
                "rb": "ring_buffer",
                "c": "data",
                "iVar1": "is_full"
            },
            "code": "int tsrb_push_00002364(tsrb_t *ring_buffer, char data) {\n  int is_full = tsrb_full(ring_buffer);\n  if (is_full == 0) {\n    _push(ring_buffer, data);\n    return 0;\n  }\n  else {\n    return -1;\n  }\n}",
            "called": [
                "tsrb_full",
                "_push"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "tsrb_push_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "set_current_mode_to_7_00001ad4",
                "*DAT_00001b08": "*data_register",
                "DAT_00001b08": "data_register",
                "*PTR_current_mode_00001b0c": "*current_mode_ptr",
                "PTR_current_mode_00001b0c": "current_mode_ptr"
            },
            "code": "void set_current_mode_to_7_00001ad4(void)\n{\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  do {\n  } while ((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_current_mode_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_7_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_peripherals_00001274",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals",
                "*DAT_00001298": "*PTR_DAT_00001298"
            },
            "code": "void initialize_peripherals_00001274(void)\n{\n  initialize_cortexm();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals_00001274();\n  return;\n}",
            "called": [
                "cortexm_init",
                "kinetis_mcg_init",
                "periph_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "initialize_peripherals_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "shell_command_loop_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_length",
                "iVar1": "input_length",
                "res": "result",
                "print_prompt": "print_shell_prompt",
                "readline": "read_input_line",
                "handle_input_line": "handle_input"
            },
            "code": "void shell_command_loop_00002e6c(shell_command_t *commands, char *input_buffer, int buffer_length)\n{\n  int input_length;\n  int result;\n\n  print_shell_prompt();\n  do {\n    input_length = read_input_line(input_buffer, buffer_length);\n    if (input_length == 0) {\n      handle_input(commands, input_buffer);\n    }\n    print_shell_prompt();\n  } while (true);\n}",
            "called": [
                "readline",
                "print_prompt",
                "handle_input_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "shell_command_loop_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_rtc_time_or_print_error_00003444",
                "iVar1": "rtc_error_code",
                "t": "current_time",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_time_or_print_error_00003444(void)\n{\n  int rtc_error_code;\n  tm current_time;\n  rtc_error_code = rtc_get_time(&current_time);\n  if (rtc_error_code != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(rtc_error_code != 0);\n}",
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_time_or_print_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "code": "void reset_system_00003688(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "_reboot_handler"
            ],
            "imported": false,
            "current_name": "reset_system_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_bit_to_one_00001392",
                "ptr": "pointer_to_bitfield",
                "bit": "bit_position",
                "puVar1": "bitband_address"
            },
            "code": "void set_bit_to_one_00001392(uint32_t *pointer_to_bitfield, uint8_t bit_position)\n{\n  undefined4 *bitband_address = (undefined4 *)bitband_addr(pointer_to_bitfield, (uint)bit_position);\n  *bitband_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_bit_to_one_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_rtc_callback_00002910",
                "DAT_00002944": "rtc_data",
                "PTR_rtt_callback_00002948": "rtc_callback"
            },
            "code": "void clear_rtc_callback_00002910(void)\n{\n  int rtt_data = DAT_00002944;\n  uint32_t* rtt_callback_ptr = (uint32_t*)(PTR_rtt_callback_00002948);\n  *rtt_callback_ptr &= ~(1U << 2);\n  *(uint32_t*)(rtt_data + 8) = 0;\n  *rtt_callback_ptr = 0;\n  *(rtt_callback_ptr + 1) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "rtc_clear_alarm"
            ],
            "imported": false,
            "current_name": "clear_rtc_callback_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "readChar_00004418",
                "iVar1": "impurePtr",
                "_getc_r": "getChar",
                "*(int *)PTR__impure_ptr_00004438": "impurePtrValue",
                "*(int *)(iVar1 + 0x18)": "flag",
                "__sinit": "initializeStream",
                "*(undefined4 *)(iVar1 + 4)": "streamBuffer"
            },
            "code": "int readChar_00004418(void)\n{\n  int impurePtr = *(int *)PTR__impure_ptr_00004438;\n  if ((impurePtr != 0) && (*(int *)(impurePtr + 0x18) == 0)) {\n    __sinit(impurePtr);\n  }\n  int character = _getc_r(impurePtr,*(undefined4 *)(impurePtr + 4));\n  return character;\n}",
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "readline"
            ],
            "imported": false,
            "current_name": "readChar_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_interrupt_priorities_0000258c",
                "i": "index"
            },
            "code": "void initialize_interrupt_priorities_0000258c(void)\n{\n  uint32_t index;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  NVIC_SetPriority(PendSV_IRQn, 1);\n  NVIC_SetPriority(SVCall_IRQn, 1);\n  for (index = 0; index < 0x66; index++) {\n    NVIC_SetPriority((IRQn_Type)index, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_interrupt_priorities_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c": "character"
            },
            "code": "void print_character_00002a00(int character) {\n  putchar(character);\n  return;\n}",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "readline",
                "print_prompt"
            ],
            "imported": false,
            "current_name": "print_character_00002a00"
        },
        "FUN_00000a64": {
            "renaming": {
                "FUN_00000a64": "handle_hard_fault_exception_00000a64",
                "sp": "main_sp",
                "corrupted": "is_corrupted",
                "unaff_r4": "unaff_r4",
                "unaff_r5": "unaff_r5",
                "unaff_r6": "unaff_r6",
                "unaff_r7": "unaff_r7",
                "unaff_r8": "unaff_r8",
                "unaff_r9": "unaff_r9",
                "unaff_r10": "unaff_r10",
                "unaff_r11": "unaff_r11",
                "in_lr": "lr_value"
            },
            "code": "void handle_hard_fault_exception_00000a64(void)\n{\n    uint32_t *main_sp;\n    uint32_t is_corrupted;\n    uint32_t unaff_r4;\n    undefined4 unaff_r5;\n    undefined4 unaff_r6;\n    undefined4 unaff_r7;\n    undefined4 unaff_r8;\n    undefined4 unaff_r9;\n    undefined4 unaff_r10;\n    undefined4 unaff_r11;\n    uint lr_value;\n    if ((eram_start < &stack_pointer) || (&stack_pointer <= eram_end)) {\n        is_corrupted = 1;\n        heap_pointer = (BADSPACEBASE *)heap_top;\n    } else {\n        is_corrupted = 0;\n    }\n    if ((lr_value & 4) == 0) {\n        main_sp = (uint32_t *)getMainStackPointer();\n    } else {\n        main_sp = (uint32_t *)getProcessStackPointer();\n    }\n    *(undefined4 *)((int)heap_pointer - 4) = unaff_r11;\n    *(undefined4 *)((int)heap_pointer - 8) = unaff_r10;\n    *(undefined4 *)((int)heap_pointer - 0xc) = unaff_r9;\n    *(undefined4 *)((int)heap_pointer - 0x10) = unaff_r8;\n    *(undefined4 *)((int)heap_pointer - 0x14) = unaff_r7;\n    *(undefined4 *)((int)heap_pointer - 0x18) = unaff_r6;\n    *(undefined4 *)((int)heap_pointer - 0x1c) = unaff_r5;\n    *(uint32_t *)((int)heap_pointer - 0x20) = unaff_r4;\n    hard_fault_handler(main_sp, is_corrupted, lr_value, (uint32_t *)((int)heap_pointer - 0x20));\n}",
            "called": [
                "hard_fault_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a64",
            "calling": [],
            "imported": false,
            "current_name": "handle_hard_fault_exception_00000a64"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "find_and_execute_code_blocks_000043a0",
                "param_1": "start_address",
                "param_2": "execute_code_block",
                "piVar2": "current_block",
                "uVar1": "executed",
                "iVar3": "current_code_block",
                "uVar4": "result",
                "iVar5": "block_size"
            },
            "code": "uint find_and_execute_code_blocks_000043a0(int start_address, code *execute_code_block){\n  uint result = 0;\n  int *current_block = (int *)(start_address + 0x48);\n  do {\n    int block_size = current_block[1];\n    int current_code_block = current_block[2];\n    while (block_size-- > 0) {\n      if ((*(ushort *)(current_code_block + 0xc) > 1) && (*(short *)(current_code_block + 0xe) != -1)) {\n        uint executed = (*execute_code_block)(current_code_block);\n        result |= executed;\n      }\n      current_code_block += 0x68;\n    }\n    current_block = (int *)*current_block;\n  } while (current_block != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "__srefill_r"
            ],
            "imported": false,
            "current_name": "find_and_execute_code_blocks_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_thread_info_0000211c",
                "queued_name": "queued_name",
                "stacksz": "stacksz",
                "queued": "queued",
                "sname": "state",
                "state": "state",
                "p": "thread",
                "isr_sp": "isr_sp",
                "isr_start": "isr_start",
                "isr_usage": "isr_usage",
                "i": "i",
                "overall_used": "overall_used",
                "overall_stacksz": "overall_stacksz"
            },
            "code": "void print_thread_info_0000211c(void)\n{\n  char queued_name[2] = {'_', '_'};\n  int overall_used = 0;\n  int overall_stacksz = 0x200;\n  kernel_pid_t i;\n  for (i = 1; i < 0x21; i++) {\n    thread_t *thread = *(thread_t **)(sched_threads + i * 4);\n    if (thread != NULL) {\n      char *state = state_names[thread->state];\n      int stacksz = thread->stack_size;\n      overall_stacksz += stacksz;\n      char *queued = queued_name + (thread->priority > 8);\n      int usage = stacksz - thread_measure_stack_free(thread->stack);\n      overall_used += usage;\n      printf(\"%3d %-20s %-8s %1s %3d %6d %6d %p %d\\n\", thread->pid, thread->name, state, queued, thread->priority, stacksz, usage, thread->stack, thread->flags);\n    }\n  }\n  printf(\"Free: %d/%d bytes\\n\", overall_stacksz - overall_used, overall_stacksz);\n}\n",
            "called": [
                "thread_isr_stack_pointer",
                "thread_isr_stack_start",
                "iprintf",
                "thread_isr_stack_usage",
                "thread_measure_stack_free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "_ps_handler",
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_thread_info_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_env_value_by_key_0000562c",
                "param_1": "lock",
                "param_2": "key",
                "param_3": "index",
                "cVar1": "current_char",
                "puVar2": "env_ptr",
                "ppcVar3": "env_list_ptr",
                "iVar4": "cmp_result",
                "pcVar5": "env_entry_ptr",
                "ppcVar6": "current_env_entry_ptr",
                "__n": "key_length"
            },
            "code": "char* find_env_value_by_key_0000562c(undefined4 lock, char* key, int* index) {\n    char current_char;\n    undefined* env_ptr;\n    char** env_list_ptr;\n    int cmp_result;\n    char* env_entry_ptr;\n    char** current_env_entry_ptr;\n    size_t key_length;\n    __env_lock();\n    env_ptr = PTR_environ_0000569c;\n    env_entry_ptr = key;\n    if (*(char ***)PTR_environ_0000569c != (char **)0x0) {\n        do {\n            current_char = *env_entry_ptr;\n            if (current_char == '\\0') {\n                key_length = (int)env_entry_ptr - (int)key;\n                env_list_ptr = *(char ***)PTR_environ_0000569c;\n                while (true) {\n                    current_env_entry_ptr = env_list_ptr;\n                    if (*current_env_entry_ptr == (char *)0x0) break;\n                    cmp_result = strncmp(*current_env_entry_ptr, key, key_length);\n                    env_list_ptr = current_env_entry_ptr + 1;\n                    if ((cmp_result == 0) && (env_entry_ptr = *current_env_entry_ptr, env_entry_ptr[key_length] == '=')) {\n                        *index = (int)current_env_entry_ptr - *(int *)env_ptr >> 2;\n                        __env_unlock(lock);\n                        return env_entry_ptr + key_length + 1;\n                    }\n                }\n                break;\n            }\n            env_entry_ptr = env_entry_ptr + 1;\n        } while (current_char != '=');\n    }\n    __env_unlock(lock);\n    return (char *)0x0;\n}",
            "called": [
                "__env_unlock",
                "strncmp",
                "__env_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "_getenv_r"
            ],
            "imported": false,
            "current_name": "find_env_value_by_key_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "handle_interrupt_000020b8",
                "DAT_000020c8": "interrupt_number"
            },
            "code": "void handle_interrupt_000020b8(void)\n{\n  int DAT_000020c8 = DAT_000020c8;\n  int interrupt_type = 0;\n  irq_handler(DAT_000020c8, interrupt_type);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "execute_shell_command_00002a18",
                "command_list": "command_list",
                "command": "command",
                "iVar1": "comparison_result",
                "command_lists": "lists",
                "i": "index",
                "entry": "entry"
            },
            "code": "execute_shell_command_00002a18texecute_shell_command_00002a18yexecute_shell_command_00002a18pexecute_shell_command_00002a18eexecute_shell_command_00002a18dexecute_shell_command_00002a18eexecute_shell_command_00002a18fexecute_shell_command_00002a18 execute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18uexecute_shell_command_00002a18cexecute_shell_command_00002a18texecute_shell_command_00002a18 execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18texecute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18cexecute_shell_command_00002a18hexecute_shell_command_00002a18aexecute_shell_command_00002a18rexecute_shell_command_00002a18*execute_shell_command_00002a18 execute_shell_command_00002a18nexecute_shell_command_00002a18aexecute_shell_command_00002a18mexecute_shell_command_00002a18eexecute_shell_command_00002a18;execute_shell_command_00002a18 execute_shell_command_00002a18iexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18 execute_shell_command_00002a18(execute_shell_command_00002a18*execute_shell_command_00002a18hexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18lexecute_shell_command_00002a18eexecute_shell_command_00002a18rexecute_shell_command_00002a18)execute_shell_command_00002a18(execute_shell_command_00002a18iexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18 execute_shell_command_00002a18aexecute_shell_command_00002a18rexecute_shell_command_00002a18gexecute_shell_command_00002a18cexecute_shell_command_00002a18,execute_shell_command_00002a18 execute_shell_command_00002a18cexecute_shell_command_00002a18hexecute_shell_command_00002a18aexecute_shell_command_00002a18rexecute_shell_command_00002a18*execute_shell_command_00002a18*execute_shell_command_00002a18 execute_shell_command_00002a18aexecute_shell_command_00002a18rexecute_shell_command_00002a18gexecute_shell_command_00002a18vexecute_shell_command_00002a18)execute_shell_command_00002a18;execute_shell_command_00002a18}execute_shell_command_00002a18 execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18texecute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18\nexecute_shell_command_00002a18iexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18 execute_shell_command_00002a18eexecute_shell_command_00002a18xexecute_shell_command_00002a18eexecute_shell_command_00002a18cexecute_shell_command_00002a18uexecute_shell_command_00002a18texecute_shell_command_00002a18eexecute_shell_command_00002a18_execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18(execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18texecute_shell_command_00002a18*execute_shell_command_00002a18 execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18lexecute_shell_command_00002a18iexecute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18,execute_shell_command_00002a18 execute_shell_command_00002a18cexecute_shell_command_00002a18hexecute_shell_command_00002a18aexecute_shell_command_00002a18rexecute_shell_command_00002a18*execute_shell_command_00002a18 execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18)execute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18iexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18 execute_shell_command_00002a18iexecute_shell_command_00002a18 execute_shell_command_00002a18=execute_shell_command_00002a18 execute_shell_command_00002a180execute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18texecute_shell_command_00002a18*execute_shell_command_00002a18 execute_shell_command_00002a18lexecute_shell_command_00002a18iexecute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18sexecute_shell_command_00002a18[execute_shell_command_00002a18]execute_shell_command_00002a18 execute_shell_command_00002a18=execute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18lexecute_shell_command_00002a18iexecute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18,execute_shell_command_00002a18 execute_shell_command_00002a18Pexecute_shell_command_00002a18Texecute_shell_command_00002a18Rexecute_shell_command_00002a18_execute_shell_command_00002a18_execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18lexecute_shell_command_00002a18iexecute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18_execute_shell_command_00002a180execute_shell_command_00002a180execute_shell_command_00002a180execute_shell_command_00002a180execute_shell_command_00002a182execute_shell_command_00002a18aexecute_shell_command_00002a188execute_shell_command_00002a184execute_shell_command_00002a18}execute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18wexecute_shell_command_00002a18hexecute_shell_command_00002a18iexecute_shell_command_00002a18lexecute_shell_command_00002a18eexecute_shell_command_00002a18 execute_shell_command_00002a18(execute_shell_command_00002a18iexecute_shell_command_00002a18 execute_shell_command_00002a18<execute_shell_command_00002a18 execute_shell_command_00002a182execute_shell_command_00002a18)execute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18sexecute_shell_command_00002a18hexecute_shell_command_00002a18eexecute_shell_command_00002a18lexecute_shell_command_00002a18lexecute_shell_command_00002a18_execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18_execute_shell_command_00002a18texecute_shell_command_00002a18*execute_shell_command_00002a18 execute_shell_command_00002a18eexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18yexecute_shell_command_00002a18 execute_shell_command_00002a18=execute_shell_command_00002a18 execute_shell_command_00002a18lexecute_shell_command_00002a18iexecute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18sexecute_shell_command_00002a18[execute_shell_command_00002a18iexecute_shell_command_00002a18]execute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18iexecute_shell_command_00002a18fexecute_shell_command_00002a18 execute_shell_command_00002a18(execute_shell_command_00002a18eexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18yexecute_shell_command_00002a18 execute_shell_command_00002a18!execute_shell_command_00002a18=execute_shell_command_00002a18 execute_shell_command_00002a18Nexecute_shell_command_00002a18Uexecute_shell_command_00002a18Lexecute_shell_command_00002a18Lexecute_shell_command_00002a18)execute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18fexecute_shell_command_00002a18oexecute_shell_command_00002a18rexecute_shell_command_00002a18 execute_shell_command_00002a18(execute_shell_command_00002a18;execute_shell_command_00002a18 execute_shell_command_00002a18eexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18yexecute_shell_command_00002a18-execute_shell_command_00002a18>execute_shell_command_00002a18nexecute_shell_command_00002a18aexecute_shell_command_00002a18mexecute_shell_command_00002a18eexecute_shell_command_00002a18 execute_shell_command_00002a18!execute_shell_command_00002a18=execute_shell_command_00002a18 execute_shell_command_00002a18Nexecute_shell_command_00002a18Uexecute_shell_command_00002a18Lexecute_shell_command_00002a18Lexecute_shell_command_00002a18;execute_shell_command_00002a18 execute_shell_command_00002a18eexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18yexecute_shell_command_00002a18+execute_shell_command_00002a18+execute_shell_command_00002a18)execute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18iexecute_shell_command_00002a18fexecute_shell_command_00002a18 execute_shell_command_00002a18(execute_shell_command_00002a18sexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18cexecute_shell_command_00002a18mexecute_shell_command_00002a18pexecute_shell_command_00002a18(execute_shell_command_00002a18eexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18yexecute_shell_command_00002a18-execute_shell_command_00002a18>execute_shell_command_00002a18nexecute_shell_command_00002a18aexecute_shell_command_00002a18mexecute_shell_command_00002a18eexecute_shell_command_00002a18,execute_shell_command_00002a18 execute_shell_command_00002a18cexecute_shell_command_00002a18oexecute_shell_command_00002a18mexecute_shell_command_00002a18mexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18)execute_shell_command_00002a18 execute_shell_command_00002a18=execute_shell_command_00002a18=execute_shell_command_00002a18 execute_shell_command_00002a180execute_shell_command_00002a18)execute_shell_command_00002a18 execute_shell_command_00002a18{execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18rexecute_shell_command_00002a18eexecute_shell_command_00002a18texecute_shell_command_00002a18uexecute_shell_command_00002a18rexecute_shell_command_00002a18nexecute_shell_command_00002a18 execute_shell_command_00002a18eexecute_shell_command_00002a18nexecute_shell_command_00002a18texecute_shell_command_00002a18rexecute_shell_command_00002a18yexecute_shell_command_00002a18-execute_shell_command_00002a18>execute_shell_command_00002a18hexecute_shell_command_00002a18aexecute_shell_command_00002a18nexecute_shell_command_00002a18dexecute_shell_command_00002a18lexecute_shell_command_00002a18eexecute_shell_command_00002a18rexecute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18}execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18}execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18}execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18iexecute_shell_command_00002a18+execute_shell_command_00002a18+execute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18}execute_shell_command_00002a18\nexecute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18 execute_shell_command_00002a18rexecute_shell_command_00002a18eexecute_shell_command_00002a18texecute_shell_command_00002a18uexecute_shell_command_00002a18rexecute_shell_command_00002a18nexecute_shell_command_00002a18 execute_shell_command_00002a180execute_shell_command_00002a18;execute_shell_command_00002a18\nexecute_shell_command_00002a18}execute_shell_command_00002a18\nexecute_shell_command_00002a18",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "execute_shell_command_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "process_input_output_000054a8",
                "param_1": "input_buffer",
                "param_2": "output_buffer",
                "uVar1": "output_buffer_flags",
                "uVar2": "output_buffer_flags_2",
                "uVar3": "output_buffer_length",
                "uVar4": "output_buffer_length_3",
                "iVar5": "impure_ptr"
            },
            "code": "uint process_input_output_000054a8(undefined4 *input_buffer, undefined4 *output_buffer) {\n  int impure_ptr = *(int *)PTR__impure_ptr_00005574;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (output_buffer == (undefined4 *)PTR___sf_fake_stdin_00005578) {\n    output_buffer = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (output_buffer == (undefined4 *)PTR___sf_fake_stdout_0000557c) {\n    output_buffer = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (output_buffer == (undefined4 *)PTR___sf_fake_stderr_00005580) {\n    output_buffer = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  uint output_buffer_length = (uint)*(ushort *)(output_buffer + 3);\n  ushort output_buffer_flags = *(ushort *)(output_buffer + 3);\n  if (-1 < (int)(output_buffer_length << 0x1c)) {\n    if (-1 < (int)(output_buffer_length << 0x1b)) {\n      *input_buffer = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(output_buffer_length << 0x1d) < 0) {\n      if ((undefined4 *)output_buffer[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)output_buffer[0xd] != output_buffer + 0x11) {\n          _free_r(input_buffer);\n        }\n        output_buffer[0xd] = 0;\n      }\n      *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) & 0xffdb;\n      output_buffer[1] = 0;\n      *output_buffer = output_buffer[4];\n    }\n    *(ushort *)(output_buffer + 3) = output_buffer_flags | 8;\n  }\n  if ((output_buffer[4] == 0) && ((*(ushort *)(output_buffer + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(input_buffer,output_buffer);\n  }\n  ushort output_buffer_flags_2 = *(ushort *)(output_buffer + 3);\n  uint output_buffer_length_2 = (uint)output_buffer_flags_2;\n  ushort output_buffer_flags_3 = *(ushort *)(output_buffer + 3);\n  uint output_buffer_length_3 = output_buffer_length_2 & 1;\n  if ((output_buffer_flags_2 & 1) == 0) {\n    if (-1 < (int)(output_buffer_length_2 << 0x1e)) {\n      output_buffer_length_3 = output_buffer[5];\n    }\n    output_buffer[2] = output_buffer_length_3;\n  }\n  else {\n    output_buffer[2] = 0;\n    output_buffer[6] = -output_buffer[5];\n  }\n  if (output_buffer[4] != 0) {\n    return 0;\n  }\n  if ((output_buffer_flags_3 & 0x80) == 0) {\n    return output_buffer_length_2 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(output_buffer + 3) = output_buffer_flags | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "_puts_r",
                "__swbuf_r",
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "process_input_output_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "create_thread_stack_000007dc",
                "task_func": "thread_task_func",
                "arg": "argument",
                "stack_start": "stack_start_address",
                "stack_size": "stack_size",
                "uVar1": "rounded_stack_size",
                "stk": "stack_pointer",
                "DAT_000008b4": "unknown_data"
            },
            "code": "char* create_thread_stack_000007dc(thread_task_func_t task_func, void* arg, void* stack_start, int stack_size) {\n    uint32_t* stack_pointer;\n    uint32_t rounded_stack_size = (uint32_t)stack_size + (uint32_t)stack_start & 0xfffffffc;\n    stack_pointer = (uint32_t*)(rounded_stack_size - 4);\n    *stack_pointer = 0x77777777;\n    if (((uint)stack_pointer & 7) != 0) {\n        stack_pointer = (uint32_t*)(rounded_stack_size - 8);\n        *stack_pointer = 0x88888888;\n    }\n    stack_pointer[-1] = 0x1000000;\n    stack_pointer[-2] = (uint32_t)task_func;\n    stack_pointer[-3] = DAT_000008b4;\n    stack_pointer--;\n    *stack_pointer = 0;\n    for (int i = 3; i > 0; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n    stack_pointer--;\n    *stack_pointer = (uint32_t)arg;\n    for (int i = 0xb; i > 3; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n    stack_pointer[-1] = 0xfffffffd;\n    return (char*)(stack_pointer - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "create_thread_stack_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_bit_00001710",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bitband_address"
            },
            "code": "void clear_bit_00001710(uint8_t *data, uint8_t bit_position)\n{\n    uint32_t *bitband_address = bitband_addr(data, (uint32_t)bit_position);\n    *bitband_address = 0;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "clear_bit_00001710"
        },
        "FUN_000045ea": {
            "renaming": {
                "FUN_000045ea": "do_nothing_000045ea"
            },
            "code": "\nvoid do_nothing_000045ea(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ea",
            "calling": [
                "__tz_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ea"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "_puts_r",
                "__sinit_lock_release",
                "__env_unlock",
                "__malloc_unlock",
                "_fflush_r",
                "__sfp_lock_release",
                "_vfprintf_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list_entry": "current_thread",
                "__m____": "temp",
                "new_node": "new_node",
                "my_prio": "thread_priority"
            },
            "code": "void insert_thread_into_list_00001034(list_node_t *list, thread_t *thread)\n{\n  list_node_t *current_node;\n  thread_t *current_thread;\n  clist_node_t *temp;\n  list_node_t *new_node;\n  uint16_t thread_priority;\n  \n  if (thread->status < 9) {\n    current_node = list;\n    while ((current_node->next != (list_node *)0x0 &&\n           (*(byte *)((int)&current_node->next[-1].next + 1) <= thread->priority))) {\n      current_node = current_node->next;\n    }\n    (thread->rq_entry).next = current_node->next;\n    current_node->next = &thread->rq_entry;\n    return;\n  }\n  core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000109c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "insert_thread_into_list_00001034"
        },
        "FUN_000055ac": {
            "renaming": {
                "FUN_000055ac": "read_byte_000055ac",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "uVar1": "byte_read",
                "pbVar2": "stream_pointer"
            },
            "code": "uint read_byte_000055ac(int file_descriptor, byte **stream)\n{\n  uint byte_read;\n  byte *stream_pointer;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (byte **)PTR___sf_fake_stdin_00005620) {\n    stream = *(byte ***)(file_descriptor + 4);\n  }\n  else if (stream == (byte **)PTR___sf_fake_stdout_00005624) {\n    stream = *(byte ***)(file_descriptor + 8);\n  }\n  else if (stream == (byte **)PTR___sf_fake_stderr_00005628) {\n    stream = *(byte ***)(file_descriptor + 0xc);\n  }\n  if ((-1 < (int)stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  stream_pointer = stream[1];\n  stream[1] = stream_pointer + -1;\n  if ((int)(stream_pointer + -1) < 0) {\n    byte_read = __srget_r(file_descriptor, stream);\n  }\n  else {\n    stream_pointer = *stream;\n    *stream = stream_pointer + 1;\n    byte_read = (uint)*stream_pointer;\n  }\n  if ((-1 < (int)stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream[0x16]);\n  }\n  return byte_read;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__srget_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000055ac",
            "calling": [
                "getchar"
            ],
            "imported": false,
            "current_name": "read_byte_000055ac"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_value_00006964",
                "param_1": "param_1",
                "param_2": "array_index",
                "iVar1": "array_value"
            },
            "code": "int calculate_value_00006964(int param_1, int array_index)\n{\n  int array_value = *(int *)(array_index + -4) + -4;\n  if (*(int *)(array_index + -4) < 0) {\n    array_value = array_value + *(int *)(array_index + array_value);\n  }\n  return array_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_bit_and_set_another_0000182c",
                "tmp": "temporary_variable",
                "DAT_000018b4": "data_array",
                "DAT_000018b8": "another_data_array"
            },
            "code": "void clear_bit_and_set_another_0000182c(void)\n{\n  uint8_t tmp;\n  DAT_000018b4[8] &= 0xd0;\n  bit_set8(DAT_000018b8, 0);\n  bit_clear8(DAT_000018b4, 1);\n  bit_clear8(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "clear_bit_and_set_another_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "reverse_string_00004db8",
                "__s": "string_to_reverse",
                "iVar1": "reversed_string_length",
                "PTR__impure_ptr_00004dc4": "PTR__impure_ptr_00004dc4"
            },
            "code": "int reverse_string_00004db8(char* string_to_reverse) {\n  int reversed_string_length = strlen(string_to_reverse);\n  char* reversed_string = malloc(reversed_string_length * sizeof(char));\n  for (int i = 0; i < reversed_string_length; i++) {\n    reversed_string[i] = string_to_reverse[reversed_string_length - i - 1];\n  }\n  reversed_string[reversed_string_length] = '\\0';\n  return reversed_string;\n}",
            "called": [
                "_puts_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "phydat_dump",
                "_rtc_setalarm",
                "_rtc_usage",
                "write",
                "list",
                "main",
                "read",
                "print_help",
                "_rtc_settime",
                "probe_all",
                "_rtc_getalarm",
                "_rtc_gettime",
                "hard_fault_handler",
                "_alarm_handler",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "reverse_string_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "read_next_byte_000022f0",
                "rb": "ring_buffer",
                "uVar1": "current_position",
                "reads": "reads",
                "buf": "buf",
                "size": "size"
            },
            "code": "char read_next_byte_000022f0(tsrb_t *ring_buffer) {\n  uint32_t current_position = ring_buffer->reads;\n  ring_buffer->reads = current_position + 1;\n  uint32_t buffer_size = ring_buffer->size;\n  uint32_t buffer_index = current_position & (buffer_size - 1);\n  return ring_buffer->buf[buffer_index];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "read_next_byte_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initializeClocks_00001c84",
                "state": "interruptState",
                "mask": "clockConfig",
                "kinetis_mcg_set_safe_mode": "setSafeMode",
                "DAT_00001ce8": "dataPointer1",
                "DAT_00001cec": "dataPointer2",
                "initializeMCGIRCLK": "initializeMCGIRClock",
                "initializeERCLK32K": "initializeERCLK32K",
                "kinetis_mcg_set_mode": "setMode",
                "KINETIS_MCG_MODE_PEE": "kinesisMCGModePEE",
                "irq_disable": "disableInterrupts",
                "irq_restore": "restoreInterrupts"
            },
            "code": "void initializeClocks_00001c84(void)\n{\n  uint32_t interruptState;\n  uint32_t clockConfig;\n\n  interruptState = disableInterrupts();\n  setSafeMode();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[0xc] = 0;\n  *DAT_00001cec = (*DAT_00001cec & 199) | 0x38;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  initializeMCGIRCLK();\n  initializeERCLK32K();\n  setMode(KINETIS_MCG_MODE_PEE);\n  restoreInterrupts(interruptState);\n}\n",
            "called": [
                "kinetis_mcg_init_erclk32k",
                "irq_disable",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initializeClocks_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "flash_configuration_field_allocation_000068f0",
                "param_1": "size",
                "param_2": "flash_config_field_ptr",
                "pvVar1": "new_flash_config_field_ptr",
                "__n": "flash_config_field_size",
                "DAT_00000046": "flash_config_field_data_1",
                "DAT_00000045": "flash_config_field_data_2",
                "PTR_DAT_00000058": "flash_configuration_field"
            },
            "code": "undefined4 flash_configuration_field_allocation_000068f0(size_t size, void **flash_config_field_ptr)\n{\n  void *new_flash_config_field_ptr;\n  void *flash_config_field_size;\n  void *flash_config_field_data;\n\n  if ((void **)flash_config_field_ptr[13] == flash_config_field_ptr + 17) {\n    new_flash_config_field_ptr = (void *)malloc(size, 0x400);\n    if (new_flash_config_field_ptr != (void *)0x0) {\n      flash_config_field_ptr[14] = PTR_DAT_00000058;\n      flash_config_field_ptr[13] = new_flash_config_field_ptr;\n      *(undefined *)((int)new_flash_config_field_ptr + 0x3ff) = *(undefined *)((int)flash_config_field_ptr + 0x46);\n      *(undefined *)((int)new_flash_config_field_ptr + 0x3fe) = *(undefined *)((int)flash_config_field_ptr + 0x45);\n      *(undefined *)((int)new_flash_config_field_ptr + 0x3fd) = *(undefined *)(flash_config_field_ptr + 0x11);\n      *flash_config_field_ptr = (void *)((int)new_flash_config_field_ptr + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    flash_config_field_size = flash_config_field_ptr[14];\n    new_flash_config_field_ptr = (void *)realloc(size, flash_config_field_ptr[13], (void *)((int)flash_config_field_size << 1));\n    if (new_flash_config_field_ptr != (void *)0x0) {\n      flash_config_field_data = (void *)((int)new_flash_config_field_ptr + (int)flash_config_field_size);\n      memcpy(flash_config_field_data, new_flash_config_field_ptr, (size_t)flash_config_field_size);\n      flash_config_field_ptr[13] = new_flash_config_field_ptr;\n      flash_config_field_ptr[14] = (void *)((int)flash_config_field_size << 1);\n      *flash_config_field_ptr = flash_config_field_data;\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_realloc_r",
                "memcpy",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [
                "_sungetc_r"
            ],
            "imported": false,
            "current_name": "flash_configuration_field_allocation_000068f0"
        }
    },
    "used_tokens": 203357,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000ca0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00004cdc",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00004e8c",
            "FUN_00005584",
            "FUN_00000cb0",
            "FUN_00004248",
            "FUN_00000f5c",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_0000423c",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_000005ca",
            "FUN_000043da",
            "FUN_00005ff8",
            "FUN_00006754",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00004f80",
            "FUN_00005fec",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000004d4",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00004dea",
            "FUN_00005edc",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00000aa8",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00004298",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00005d80",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_00000f80",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_00000958",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00000c80",
            "FUN_00000a40",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_000022be",
            "FUN_00003dc4",
            "FUN_00002108",
            "FUN_00000c90",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00006118",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00005fd4",
            "FUN_00004dc8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004e4a",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_000004b2",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000978",
            "FUN_000018bc",
            "FUN_00000974",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_00000a64",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_000055ac",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_000022f0",
            "FUN_000068f0"
        ],
        [
            "FUN_00000dc0",
            "FUN_00005100",
            "FUN_000041d0",
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00004f84",
            "FUN_00001eea",
            "FUN_0000305c",
            "FUN_000013b8",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_00005fd8",
            "FUN_00005780",
            "FUN_00000f04",
            "FUN_00004db8",
            "FUN_00001c84"
        ]
    ],
    "locked_functions": []
}