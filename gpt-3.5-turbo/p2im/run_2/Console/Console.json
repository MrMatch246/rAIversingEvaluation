{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "initialize_data_000026c0",
                "PTR_DAT_000026d4": "pointer_data",
                "reset_data_00002910": "reset_data"
            },
            "code": "void initialize_data_000026c0(void)\n{\n  reset_data();\n  *(int *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_data_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_block_00004bd0",
                "param_1": "block_size",
                "param_2": "requested_size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "unused_ptr",
                "uVar2": "updated_value",
                "puVar3": "current_block_ptr",
                "iVar4": "remaining_block_size",
                "uVar5": "difference",
                "puVar6": "previous_block_ptr",
                "uVar7": "block_size_with_header"
            },
            "code": "uint allocate_memory_block_00004bd0(uint *block_size, uint requested_size, uint arg3, uint arg4)\\n\\\n{\\n\\\n  uint *current_block_ptr;\\n\\\n  uint block_size_with_header;\\n\\\n  uint remaining_block_size;\\n\\\n  uint *previous_block_ptr;\\n\\\n  uint updated_block_size;\\n\\\n\\\n  block_size_with_header = (requested_size + 3 & 0xfffffffc) + 8;\\n\\\n  if (block_size_with_header < 0xc) {\\n\\\n    block_size_with_header = 0xc;\\n\\\n  }\\n\\\n  if (((int)block_size_with_header < 0) || (block_size_with_header < requested_size)) {\\n\\\n    *block_size = 0xc;\\n\\\n  }\\n\\\n  else {\\n\\\n    do_nothing_with_pointer_00005790();\\n\\\n    current_block_ptr = PTR_DAT_00004c7c;\\n\\\n    previous_block_ptr = *(uint **)PTR_DAT_00004c7c;\\n\\\n    while (current_block_ptr != (uint *)0x0) {\\n\\\n      remaining_block_size = *current_block_ptr - block_size_with_header;\\n\\\n      if (-1 < (int)remaining_block_size) {\\n\\\n        if (0xb < remaining_block_size) {\\n\\\n          *current_block_ptr = remaining_block_size;\\n\\\n          current_block_ptr = (uint *)((int)current_block_ptr + remaining_block_size);\\n\\\n          goto LAB_00004c34;\\n\\\n        }\\n\\\n        updated_block_size = current_block_ptr[1];\\n\\\n        if (previous_block_ptr == current_block_ptr) {\\n\\\n          *(uint **)PTR_DAT_00004c7c = (uint *)updated_block_size;\\n\\\n        }\\n\\\n        if (previous_block_ptr != current_block_ptr) {\\n\\\n          previous_block_ptr[1] = updated_block_size;\\n\\\n        }\\n\\\n        goto LAB_00004c42;\\n\\\n      }\\n\\\n      previous_block_ptr = current_block_ptr;\\n\\\n      current_block_ptr = (uint *)current_block_ptr[1];\\n\\\n    }\\n\\\n    if (*(int *)PTR_DAT_00004c80 == 0) {\\n\\\n      uint updated_value = get_updated_array_value_00000428(block_size, 0, previous_block_ptr, 0, arg4);\\n\\\n      *(uint *)PTR_DAT_00004c80 = updated_value;\\n\\\n    }\\n\\\n    current_block_ptr = (uint *)get_updated_array_value_00000428(block_size, block_size_with_header);\\n\\\n    if ((current_block_ptr != (uint *)0xffffffff) &&\\n\\\n       ((previous_block_ptr = (uint *)((int)current_block_ptr + 3U & 0xfffffffc), current_block_ptr == previous_block_ptr ||\\n\\\n        (updated_block_size = get_updated_array_value_00000428(block_size, (int)previous_block_ptr - (int)current_block_ptr), updated_block_size != -1)))) {\\n\\\n      *previous_block_ptr = block_size_with_header;\\n\\\nLAB_00004c42:\\n\\\n      do_nothing_with_pointer_0000579c(block_size);\\n\\\n      block_size_with_header = (int)previous_block_ptr + 0xbU & 0xfffffff8;\\n\\\n      remaining_block_size = block_size_with_header - (int)(previous_block_ptr + 1);\\n\\\n      if (remaining_block_size == 0) {\\n\\\n        return block_size_with_header;\\n\\\n      }\\n\\\n      *(uint *)((int)previous_block_ptr + remaining_block_size) = (int)(previous_block_ptr + 1) - block_size_with_header;\\n\\\n      return block_size_with_header;\\n\\\n    }\\n\\\n    *block_size = 0xc;\\n\\\n    do_nothing_with_pointer_0000579c(block_size);\\n\\\n  }\\n\\\n  return 0;\\n\\\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790",
                "FUN_00000428"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005700",
                "FUN_00004248",
                "FUN_00005100",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "get_updated_stack_00000794",
                "extraout_r1": "extraout_result",
                "iVar1": "iVarCounter",
                "puVar2": "puVarPtr",
                "uVar3": "uVarIndex",
                "iStack_1c": "iStackCounter",
                "iStack_18": "iStackIndex",
                "piStack_14": "piStackPtr"
            },
            "code": "int * get_updated_stack_00000794(void)\n{\n    int extraout_result;\n    int iVarCounter;\n    undefined4 *puVarPtr;\n    uint uVarIndex;\n    int iStackCounter;\n    int iStackIndex;\n    int *piStackPtr;\n    getIRQInterruptsEnabledState_00000cd0();\n    *(undefined4 *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n    *piRam000007d4 = *piRam000007d4 + -1;\n    update_node_00000698(*puRam000007d8,0);\n    puVarPtr = puRam000007d8;\n    iVarCounter = 0;\n    *puRam000007d8 = 0;\n    execute_interrupt_and_wait_00000930();\n    uVarIndex = (int)puVarPtr + iVarCounter & 0xfffffffc;\n    piStackPtr = (int *)(uVarIndex - 4);\n    *piStackPtr = 0x77777777;\n    if (((uint)piStackPtr & 7) != 0) {\n        piStackPtr = (int *)(uVarIndex - 8);\n        *piStackPtr = 0x88888888;\n    }\n    piStackPtr[-1] = 0x1000000;\n    piStackPtr[-2] = iVarCounter << 0xd;\n    piStackPtr[-3] = DAT_000008b4;\n    piStackPtr = piStackPtr + -4;\n    *piStackPtr = 0;\n    for (iStackCounter = 3; 0 < iStackCounter; iStackCounter = iStackCounter + -1) {\n        piStackPtr = piStackPtr + -1;\n        *piStackPtr = iStackCounter;\n    }\n    piStackPtr = piStackPtr + -1;\n    *piStackPtr = extraout_result;\n    for (iStackIndex = 0xb; 3 < iStackIndex; iStackIndex = iStackIndex + -1) {\n        piStackPtr = piStackPtr + -1;\n        *piStackPtr = iStackIndex;\n    }\n    piStackPtr[-1] = -3;\n    return piStackPtr + -1;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "get_updated_stack_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "data_length",
                "param_2": "data",
                "param_3": "data_ptr",
                "param_4": "callback_result",
                "puVar1": "PTR_DAT_00006568",
                "iVar2": "callback_return_value",
                "iVar7": "data_remaining",
                "ppbVar4": "next_byte",
                "pbVar5": "current_byte",
                "unaff_r6": "output_byte",
                "pbVar6": "output_byte"
            },
            "code": "int process_data_000064bc(uint32_t data_length, uint32_t *data, uint8_t **data_ptr, uint32_t *callback_result) {\n  uint8_t *current_byte;\n  uint8_t *output_byte;\n  uint8_t *next_byte;\n  uint32_t data_remaining;\n  uint32_t callback_return_value;\n  uint32_t flags;\n\n  if (data[2] == 0) {\n    if (data[6] == 0) {\n      flags = 1;\n    }\n    else {\n      flags = 0xffffffff;\n    }\n    data[2] = flags;\n  }\n  current_byte = *data_ptr;\n  output_byte = NULL;\n  callback_return_value = 0;\n  data_remaining = 0;\n\n  while (true) {\n    data_remaining = data[2];\n    if (data_remaining == 0) {\n      if (output_byte != NULL) {\n        *output_byte = 0;\n      }\n      data[4] += callback_return_value;\n      return 0;\n    }\n    next_byte = *data_ptr + 1;\n    if (-1 < (int32_t)(*data << 0x1b)) {\n      output_byte = *data_ptr;\n      *output_byte = **data_ptr;\n      *data_ptr = output_byte + 1;\n    }\n    current_byte = *data_ptr;\n    *data_ptr = current_byte + 1;\n    data[2] = data_remaining - 1;\n    if (data_remaining == 1) {\n      if (*(char *)(data[5] + (uint32_t)*current_byte) == '\\0') {\n        if (callback_return_value == 0) {\n          return 1;\n        }\n        if ((data[0] & 0x10) == 0) {\n          output_byte = *data_ptr;\n          *output_byte = 0;\n          *data_ptr = output_byte + 1;\n        }\n        data[4] += callback_return_value;\n        return 0;\n      }\n    }\n    else if (data[6] == 2 && (int32_t)((uint32_t)(uint8_t)PTR_DAT_00006568[*current_byte] << 0x1c) >= 0) {\n      continue;\n    }\n    callback_return_value = (*(code *)data[0x60])(data_length, data_ptr, data_remaining, (code *)data[0x60], callback_result);\n    if (callback_return_value != 0) {\n      if (output_byte != NULL) {\n        *output_byte = 0;\n      }\n      data[4] += callback_return_value;\n      return 0;\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_bit_in_uint_at_offset_from_dat_00002990_00002970",
                "DAT_00002990": "dat_00002990",
                "PTR_000029a4": "ptr_000029a4",
                "PTR_000029a8": "ptr_000029a8",
                "PTR_000029ac": "ptr_000029ac"
            },
            "code": "void clear_bit_in_uint_at_offset_from_dat_00002990_00002970(uint offset)\n{\n    uint* data = (uint*)(DAT_00002990 + offset);\n    *data &= 0xFFFFFFEF;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint_at_offset_from_dat_00002990_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "check_IRQ_interrupts_enabled_status_00000dc0"
            },
            "code": "void check_IRQ_interrupts_enabled_status_00000dc0(void)\n{\n  get_IRQ_interrupts_enabled_status();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "check_IRQ_interrupts_enabled_status_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_interrupts_if_privileged_00000d0c",
                "param_1": "permission_bit",
                "bVar1": "is_privileged_mode"
            },
            "code": "void enable_interrupts_if_privileged_00000d0c(uint permission_bit){\n    bool is_privileged_mode = (bool)isCurrentModePrivileged();\n    if (is_privileged_mode) {\n        enableIRQinterrupts((permission_bit & 1) == 1);\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "enable_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "perform_operation_00003d94",
                "param_1": "operation_type",
                "param_2": "input_value",
                "uVar1": "result"
            },
            "code": "int32_t perform_operation_00003d94(int32_t operation_type, int32_t input_value)\n{\n  int32_t result;\n  if (operation_type == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(function_pointer **)(*(int32_t *)(operation_type + 0x0C) + 0x04))(*(int32_t *)(operation_type + 0x04), input_value);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "perform_operation_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_pointer_0000579c",
                "PTR_DAT_000057a4": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "index",
                "param_2": "data_address",
                "param_3": "size",
                "iVar1": "memory_location",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int index, int data_address, uint size){\n  int memory_location = *(int *)(PTR_DAT_00001624 + index * 0x20);\n  for (uint i = 0; i < size; i++) {\n    while (-1 < *(char *)(memory_location + 4));\n    *(undefined *)(memory_location + 7) = *(undefined *)(i + data_address);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "param_1": "input_data",
                "param_2": "data_length",
                "param_3": "output_data",
                "param_4": "output_length",
                "local_80": "start_index",
                "local_7c": "end_index",
                "local_74": "null_terminator_index",
                "local_72": "negative_one",
                "local_70": "output_end_index",
                "local_6c": "end_index",
                "local_5c": "data_ptr",
                "local_4c": "zero",
                "local_38": "negative_one",
                "uStack_8": "output_data",
                "uStack_4": "output_length",
                "PTR_LAB_00004dea_1_00005eb4": "data_buffer",
                "*DAT_00005eb8": "process_data_helper"
            },
            "code": "void process_data_00005e68(int input_data, int data_length, int output_data, int output_length)\n{\n  int start_index = 0;\n  int end_index = 0;\n  int null_terminator_index = find_null_terminator();\n  char *data_ptr = PTR_LAB_00004dea_1_00005eb4;\n  int zero = 0;\n  int negative_one = -1;\n  int output_end_index = null_terminator_index;\n  end_index = null_terminator_index;\n  *DAT_00005eb8(*PTR_LAB_00004dea_1_00005eb4, &start_index, &end_index, input_data);\n  return;\n}",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_default_values_00000dcc",
                "DAT_00000df0": "data_ptr"
            },
            "code": "void set_default_values_00000dcc(void)\n{\n\tint* DAT_00000df0 = DAT_00000df0;\n\tDAT_00000df0[7] = 0xc520;\n\tDAT_00000df0[7] = 0xd928;\n\t*DAT_00000df0 = 0xd2;\n\treturn;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_default_values_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_value_0000285c",
                "param_1": "value_to_set",
                "puVar1": "flag_ptr",
                "DAT_00002890": "flag_array"
            },
            "code": "void set_flag_and_value_0000285c(int value_to_set)\n{\n  int *flag_ptr;\n\n  flag_ptr = DAT_00002890;\n  DAT_00002890[5] = DAT_00002890[5] & 0xffffffef;\n  *flag_ptr = value_to_set;\n  flag_ptr[5] = flag_ptr[5] | 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "set_flag_and_value_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "runInfiniteLoop_00000e58",
                "getIRQInterruptsEnabledState_00000cd0": "getIRQInterruptsEnabledState"
            },
            "code": "void runInfiniteLoop_00000e58(void)\n{\n  getIRQInterruptsEnabledState();\n  while(1) {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "runInfiniteLoop_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_memory_bit_and_clear_two_bytes_00001778",
                "DAT_000017d0": "data",
                "DAT_000017d8": "offset",
                "clear_memory_at_calculated_address_00001710": "clear_memory_at_calculated_address"
            },
            "code": "void set_memory_bit_and_clear_two_bytes_00001778(byte* DAT_000017d0, int DAT_000017d8){\n  byte* byte_to_modify = DAT_000017d0 + DAT_000017d8 + 1;\n  *byte_to_modify = (*byte_to_modify & 0xCF) | 0x20;\n  clear_memory_at_calculated_address(DAT_000017d0 + 0x10, 2);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_memory_bit_and_clear_two_bytes_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "enable_interrupts_000026d8"
            },
            "code": "void enable_interrupts_000026d8(void)\n{\n  enable_interrupts_000026d8_0000294c();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "enable_interrupts_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zeroes_in_integer_00000566",
                "param_1": "input_integer",
                "bVar1": "byte_1",
                "bVar2": "byte_2",
                "bVar3": "byte_3",
                "bVar4": "byte_4",
                "uVar5": "leading_zeroes"
            },
            "code": "uint32_t count_leading_zeroes_in_integer_00000566(uint32_t input_integer) {\n    uint32_t byte_1 = (uint32_t)(input_integer & 0xff);\n    uint32_t byte_2 = (uint32_t)((input_integer >> 8) & 0xff);\n    uint32_t byte_3 = (uint32_t)((input_integer >> 16) & 0xff);\n    uint32_t byte_4 = (uint32_t)((input_integer >> 24) & 0xff);\n    uint32_t concatenated_bytes = (byte_1 << 24) | (byte_2 << 16) | (byte_3 << 8) | byte_4;\n    uint32_t leading_zeroes = count_leading_zeroes(concatenated_bytes);\n    if (input_integer == 0) {\n        leading_zeroes = 32;\n    }\n    return leading_zeroes;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_in_integer_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_memory_address_00001d08",
                "param_1": "address",
                "param_2": "offset",
                "return": "calculated_address"
            },
            "code": "int calculate_memory_address_00001d08(uint address, int offset) {\n    int base_address = (address & 0xf0000000) | ((address & 0xfffff) << 5);\n    int calculated_address = base_address + offset * 4 + 0x2000000;\n    return calculated_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_score_000031fc",
                "param_1": "player_score",
                "param_2": "player_level",
                "param_3": "previous_score",
                "iVar2": "effective_level",
                "bVar1": "is_level_high",
                "adjusted_score": "adjusted_score",
                "score_delta": "score_delta"
            },
            "code": "int calculate_score_000031fc(int player_score, int player_level, int previous_score)\n{\n  int effective_level = player_level;\n  if (player_level < 3) {\n    effective_level = 1;\n  }\n  byte is_level_high = 0;\n  if (effective_level > 2) {\n    is_level_high = 1;\n  }\n  player_score = player_score - (uint)is_level_high;\n  int adjusted_score = player_score;\n  if (player_score < 0) {\n    adjusted_score = player_score + 3;\n  }\n  int score_delta = (((adjusted_score >> 2) + player_score) - (int)((longlong)DAT_00003280 * (longlong)adjusted_score >> 0x25)) + (int)((longlong)DAT_00003280 * (longlong)adjusted_score >> 0x27) + *(int *)(DAT_00003284 + (effective_level + -1) * 4) + previous_score;\n  return score_delta + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)score_delta) >> 0x20) + score_delta >> 2) - (score_delta >> 0x1f)) * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_score_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_flag_at_calculated_address_000016ec",
                "param_1": "address",
                "param_2": "flag",
                "puVar1": "address_pointer",
                "calculate_address_00001696": "calculate_address"
            },
            "code": "void set_flag_at_calculated_address_000016ec(undefined4 address, undefined flag) {\n  undefined *address_pointer;\n  address_pointer = (undefined *)calculate_address(address, flag);\n  *address_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_00001a18",
                "FUN_00001778",
                "FUN_00001a3c",
                "FUN_0000182c",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "set_flag_at_calculated_address_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "FUNC_00005100"
            },
            "code": "\nvoid FUNC_00005100(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  int iVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  char cVar9;\n  char *pcVar10;\n  bool bVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort *puVar14;\n  int *piVar15;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  uVar4 = *DAT_00005108;\n  iVar5 = get_data_000056b0();\n  puVar1 = PTR_DAT_000053d8;\n  pcVar6 = (char *)find_key_index_000056a0(uVar4,PTR_DAT_000053d4);\n  puVar2 = PTR_DAT_000053e0;\n  if (pcVar6 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    puVar3 = DAT_000053e8;\n    uVar4 = *(undefined4 *)puVar1;\n    *DAT_000053e8 = puVar2;\n    puVar3[1] = puVar2;\n    insert_node_at_position_00005780(uVar4);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(int *)puVar1 == 0) || (iVar7 = compare_bytes_00004e52(), iVar7 != 0)) {\n    insert_node_at_position_00005780(*(undefined4 *)puVar1);\n    iVar7 = find_null_terminator_00005ecc(pcVar6);\n    iVar7 = allocate_memory_block_00004bd0(uVar4,iVar7 + 1);\n    *(int *)puVar1 = iVar7;\n    if (iVar7 != 0) {\n      copy_string_00005ebc(iVar7,pcVar6);\n    }\n    if (*pcVar6 == ':') {\n      pcVar6 = pcVar6 + 1;\n    }\n    iVar7 = process_data_00005e68(pcVar6,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&local_30);\n    if (0 < iVar7) {\n      pcVar10 = pcVar6 + local_30;\n      if (pcVar6[local_30] == '-') {\n        pcVar10 = pcVar10 + 1;\n        iVar7 = -1;\n      }\n      else {\n        if (pcVar6[local_30] == '+') {\n          pcVar10 = pcVar10 + 1;\n        }\n        iVar7 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar12 = &local_3a;\n      piVar13 = &local_30;\n      puVar14 = &local_38;\n      piVar15 = &local_30;\n      iVar8 = process_data_00005e68(pcVar10,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                           &local_30,&local_38,&local_30);\n      puVar1 = PTR_DAT_00005400;\n      if (0 < iVar8) {\n        *(uint *)(iVar5 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n        puVar3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        pcVar10 = pcVar10 + local_30;\n        iVar7 = process_data_00005e68(pcVar10,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar12,piVar13,\n                             puVar14,piVar15);\n        if (iVar7 < 1) {\n          puVar3[1] = *puVar3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(iVar5 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          puVar3[1] = puVar1;\n          pcVar6 = pcVar10 + local_30;\n          if (pcVar10[local_30] == '-') {\n            pcVar6 = pcVar6 + 1;\n            iVar7 = -1;\n          }\n          else {\n            if (pcVar10[local_30] == '+') {\n              pcVar6 = pcVar6 + 1;\n            }\n            iVar7 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar8 = process_data_00005e68(pcVar6,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a\n                               ,&local_30,&local_38,&local_30);\n          if (iVar8 < 1) {\n            iVar7 = *(int *)(iVar5 + 0x28) + -0xe10;\n          }\n          else {\n            iVar7 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n          }\n          *(int *)(iVar5 + 0x50) = iVar7;\n          pcVar6 = pcVar6 + local_30;\n          bVar11 = false;\n          iVar7 = iVar5;\n          while( true ) {\n            if (*pcVar6 == ',') {\n              pcVar6 = pcVar6 + 1;\n            }\n            cVar9 = *pcVar6;\n            if (cVar9 == 'M') {\n              iVar8 = process_data_00005e68(pcVar6,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,\n                                   &local_34,&local_30,&local_32,&local_30);\n              if (iVar8 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar7 + 0xc) = (uint)local_36;\n              *(uint *)(iVar7 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar7 + 8) = 0x4d;\n              *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              pcVar10 = pcVar6 + local_30;\n            }\n            else {\n              if (cVar9 == 'J') {\n                pcVar6 = pcVar6 + 1;\n              }\n              else {\n                cVar9 = 'D';\n              }\n              local_32 = convert_string_to_integer_00005fd8(pcVar6,local_2c,10);\n              pcVar10 = local_2c[0];\n              if (local_2c[0] == pcVar6) {\n                if (bVar11) {\n                  *(undefined *)(iVar5 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar5 + 0x38) = 1;\n                  *(undefined4 *)(iVar5 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar5 + 8) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0xc) = 3;\n                  *(undefined4 *)(iVar5 + 0x10) = 2;\n                  *(undefined4 *)(iVar5 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar7 + 8) = cVar9;\n                *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar10 == '/') {\n              process_data_00005e68(pcVar10,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,\n                           &local_38,&local_30);\n            }\n            *(uint *)(iVar7 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar7 = iVar7 + 0x28;\n            pcVar6 = pcVar10 + local_30;\n            if (bVar11) break;\n            bVar11 = true;\n          }\n          calculate_day_of_week_00004f98(*(undefined4 *)(iVar5 + 4));\n          iVar7 = *(int *)(iVar5 + 0x28);\n          *(int *)PTR_DAT_000053dc = iVar7;\n          iVar7 = *(int *)(iVar5 + 0x50) - iVar7;\n          if (iVar7 != 0) {\n            iVar7 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = iVar7;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005ecc",
                "FUN_00005e68",
                "FUN_00005ebc",
                "FUN_00004e52",
                "FUN_000056a0",
                "FUN_00005780",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_00004bd0",
                "FUN_00005fd8"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_1": "result",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *result, uint dividend, uint divisor)\n{\n  uint quotient;\n  uint remainder;\n  quotient = dividend / divisor;\n  remainder = dividend % divisor;\n  if ((int)dividend < 0) {\n    if (0 < (int)remainder) {\n      quotient--;\n      remainder += divisor;\n    }\n  }\n  else if ((int)remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  *result = quotient;\n  result[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_block_of_memory_00004248",
                "param_1": "starting_address",
                "param_2": "block_size",
                "puVar1": "memory_block_address",
                "iVar2": "index_of_last_element_in_array"
            },
            "code": "undefined4 * allocate_and_initialize_block_of_memory_00004248(undefined4 starting_address,int block_size)\n{\n  undefined4 *memory_block_address;\n  int index_of_last_element_in_array;\n  \n  index_of_last_element_in_array = (block_size + -1) * 0x68;\n  memory_block_address = (undefined4 *)allocate_memory_block_00004bd0(starting_address,index_of_last_element_in_array + 0x74);\n  if (memory_block_address != (undefined4 *)0x0) {\n    *memory_block_address = 0;\n    memory_block_address[1] = block_size;\n    memory_block_address[2] = memory_block_address + 3;\n    fill_array_with_value_00004622(memory_block_address + 3,0,index_of_last_element_in_array + 0x68);\n  }\n  return memory_block_address;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_block_of_memory_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_bits_from_right_00001da2",
                "param_1": "input_num",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort get_bits_from_right_00001da2(ushort input_num) {\n    ushort bits_to_get = 7;\n    ushort shifted_num = input_num >> 6;\n    ushort extracted_bits = shifted_num & bits_to_get;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "get_bits_from_right_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "extract_bits_and_update_array_00001ec4",
                "param_1": "array",
                "param_2": "index",
                "uVar1": "extracted_bits"
            },
            "code": "void extract_bits_and_update_array_00001ec4(uint_array array, uint index) {\n  uint extracted_bits = extract_bits_from_uint_array(array, index);\n  update_bits_at_index(array, index, extracted_bits);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "extract_bits_and_update_array_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "update_data_00002744",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002790": "data_ptr_1",
                "DAT_00002794": "data_ptr_2"
            },
            "code": "void update_data_00002744(byte data, uint value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002790 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002794 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "update_data_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_unix_time_to_datetime_and_return_zero_00002624",
                "param_1": "unix_time",
                "local_10": "first_nonmatching_element",
                "uStack_c": "stack_variable"
            },
            "code": "int convert_unix_time_to_datetime_and_return_zero_00002624(undefined4 unix_time)\n{\n  undefined4 first_nonmatching_element = find_first_nonmatching_element_0000281c();\n  undefined4 stack_variable = 0;\n  convert_unix_time_to_datetime_0000443c(&first_nonmatching_element, unix_time);\n  return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "convert_unix_time_to_datetime_and_return_zero_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "extract_bits_from_uint_array_00001e0c",
                "param_1": "index",
                "param_2": "array",
                "PTR_DAT_00001e40": "uint_array",
                "num_bits_to_extract": "num_bits_to_extract",
                "array_index": "array_index",
                "bit_index": "bit_index",
                "extracted_bits": "extracted_bits"
            },
            "code": "uint extract_bits_from_uint_array_00001e0c(int index, uint* array, uint num_bits_to_extract) {\n    uint array_index = (num_bits_to_extract >> 3) + index * 4;\n    uint bit_index = (num_bits_to_extract & 7) << 2;\n    uint extracted_bits = *(uint *)(PTR_DAT_00001e40 + array_index * 4) >> bit_index & 0xf;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "extract_bits_from_uint_array_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0",
                "param_1": "data",
                "param_2": "param_2",
                "param_3": "param_3",
                "pcVar1": "function_pointer",
                "iVar2": "pointer_to_data",
                "uVar3": "function_result",
                "iVar4": "inner_data_length",
                "piVar5": "pointer_to_data",
                "iVar6": "inner_data",
                "uVar7": "result",
                "iVar8": "inner_data_length",
                "puVar9": "data_pointer"
            },
            "code": "uint process_data_000041d0(uint data, undefined4 param_2, undefined4 param_3)\n{\n  code *function_pointer = DAT_000041ec;\n  if (data == 0)\n  {\n    int *pointer_to_data = (int *)(*(int *)PTR_DAT_000041e8 + 0x48);\n    uint result = 0;\n    undefined *data_pointer = PTR_DAT_000041e8;\n    do\n    {\n      int inner_data = pointer_to_data[2];\n      int inner_data_length = pointer_to_data[1];\n      while (inner_data_length = inner_data_length - 1, -1 < inner_data_length)\n      {\n        if ((1 < *(ushort *)(inner_data + 0xc)) && (*(short *)(inner_data + 0xe) + 1 != 0))\n        {\n          uint function_result = (*function_pointer)(*(int *)PTR_DAT_000041e8, inner_data, param_3, *(short *)(inner_data + 0xe) + 1, data_pointer);\n          result = result | function_result;\n        }\n        inner_data = inner_data + 0x68;\n      }\n      pointer_to_data = (int *)*pointer_to_data;\n    } while (pointer_to_data != (int *)0x0);\n    return result;\n  }\n  uint result = process_data_000041d0_00004158(*DAT_000041f0, data);\n  return result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "execute_code_blocks_0000459c",
                "puVar1": "start_block_ptr",
                "puVar2": "end_block_ptr",
                "iVar3": "num_blocks",
                "ppcVar4": "block_func_ptr",
                "iVar5": "i"
            },
            "code": "void execute_code_blocks_0000459c(void)\n{\n  undefined *start_block_ptr;\n  undefined *end_block_ptr;\n  int num_blocks;\n  code **block_func_ptr;\n  int i;\n  num_blocks = (int)PTR_DAT_000045d8 - (int)PTR_DAT_000045d4;\n  block_func_ptr = (code **)PTR_DAT_000045d4;\n  for (i = 0; start_block_ptr = PTR_DAT_000045dc, end_block_ptr = PTR_DAT_000045e0, i != num_blocks >> 2; i++) {\n    (**block_func_ptr)();\n    block_func_ptr++;\n  }\n  store_values_and_return_00000410();\n  block_func_ptr = (code **)start_block_ptr;\n  for (num_blocks = 0; num_blocks != (int)end_block_ptr - (int)start_block_ptr >> 2; num_blocks++) {\n    (**block_func_ptr)();\n    block_func_ptr++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "execute_code_blocks_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_bit_in_array_000014c4",
                "param_1": "index",
                "param_2": "arraySize",
                "pbVar1": "array",
                "uVar2": "arrayValue",
                "uVar3": "quotient"
            },
            "code": "void set_bit_in_array_000014c4(int index, uint arraySize) {\\n\\\n        byte *array = *(byte **)(PTR_DAT_000015cc + index * 0x20);\\n\\\n        uint arrayValue = *(uint *)(PTR_DAT_000015cc + index * 0x20 + 4);\\n\\\n        array[3] &= 0xf3;\\n\\\n        array[2] = PTR_DAT_000015cc[index * 0x20 + 0x1d];\\n\\\n        uint quotient = arrayValue / (arraySize << 4);\\n\\\n        array[0] = (byte)(quotient >> 8) & 0x1f;\\n\\\n        array[1] = (byte)quotient;\\n\\\n        array[10] = (byte)((arrayValue << 2) / arraySize + 1 >> 1) & 0x1f;\\n\\\n        array[0x10] |= 0x88;\\n\\\n        if ((array[0x10] & 0x70) == 0) {\\n\\\n            array[0x13] = 0;\\n\\\n        }\\n\\\n        else {\\n\\\n            array[0x13] = (char)(2 << (array[0x10] >> 4 & 7)) - 1;\\n\\\n        }\\n\\\n        array[0x15] = 1;\\n\\\n        array[0x11] = 0xc0;\\n\\\n        array[3] |= 0x2c;\\n\\\n        set_bit_in_array_000014c4_00001318((int)(char)PTR_DAT_000015cc[index * 0x20 + 0x14]);\\n\\\n    }",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "insert_node_at_position_00004b34",
                "param_1": "error_code",
                "param_2": "head",
                "param_3": "position",
                "param_4": "value",
                "puVar1": "pointer",
                "piVar2": "prev",
                "extraout_r1": "next",
                "ppiVar3": "current",
                "ppiVar4": "prev_ptr",
                "ppiVar5": "prev_ptr_next",
                "ppiVar6": "new_node",
                "bVar7": "is_same_node"
            },
            "code": "void insert_node_at_position_00004b34(int *error_code, int **head, int position, int *value) {\n  if (position < 1) {\n    *error_code = 0xc;\n    return;\n  }\n  int **current = head;\n  int current_position = 1;\n  while (*current != NULL && current_position < position) {\n    current_position++;\n    current = (int **)*current;\n  }\n  if (current_position < position) {\n    *error_code = 0xc;\n    return;\n  }\n  int *new_node = (int *)malloc(8);\n  *new_node = *value;\n  int **next = current;\n  current = &new_node;\n  *current = (int *)next;\n  if (position == 1) {\n    *head = current;\n  }\n  else {\n    int **prev = head;\n    while (*prev != current) {\n      prev = (int **)*prev;\n    }\n    *prev = current;\n  }\n  *error_code = 0;\n}\n",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_0000404c",
                "FUN_00005780",
                "FUN_000060cc",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_00006192"
            ],
            "imported": false,
            "current_name": "insert_node_at_position_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_19_000004f2",
                "param_1": "param"
            },
            "code": "int set_param_to_19_000004f2(int *param)\n{\n    *param = 19;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_byte_arrays_00004e66",
                "param_1": "array1",
                "param_2": "length1",
                "param_3": "length2",
                "pbVar1": "ptr1",
                "pbVar2": "ptr2",
                "uVar3": "byte_value"
            },
            "code": "int compare_byte_arrays_00004e66(byte *array1, int length1, byte *array2, int length2) {\n  byte *ptr1;\n  byte *ptr2;\n  uint byte_value;\n  \n  if (length2 != 0) {\n    ptr2 = (byte *)(length1 + -1);\n    ptr1 = array1;\n    do {\n      byte_value = (uint)*ptr1;\n      ptr2 = ptr2 + 1;\n      if ((byte_value != *ptr2) || (ptr1 + 1 == array1 + length2)) break;\n      ptr1 = ptr1 + 1;\n    } while (byte_value != 0);\n    length2 = byte_value - *ptr2;\n  }\n  return length2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_byte_arrays_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_null_terminator_00005ecc",
                "param_1": "string",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "char *find_null_terminator_00005ecc(char *string)\n{\n  char current_char;\n  char *current_ptr = string;\n  do {\n    current_ptr++;\n    current_char = *current_ptr;\n  } while (current_char != '\\0');\n  return current_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005e68",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_null_terminator_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "set_node_value_to_one_0000129c",
                "param_1": "node",
                "set_or_get_node_value_00002434": "set_or_get_node_value"
            },
            "code": "void set_node_value_to_one_0000129c(void* node){\n  set_or_get_node_value(node, 1);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "set_node_value_to_one_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_and_execute_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "ptr_dat_00001680",
                "PTR_DAT_00001684": "ptr_dat_00001684",
                "ptr_1": "ptr_1",
                "ptr_2": "ptr_2",
                "byte_ptr": "byte_ptr",
                "int_ptr": "int_ptr",
                "code": "code_ptr",
                "undefined4": "undefined4_ptr",
                "undefined": "undefined_ptr"
            },
            "code": "void check_and_execute_function_00001628(int index)\n{\n    int* PTR_DAT_00001680 = PTR_DAT_00001680;\n    int* PTR_DAT_00001684 = PTR_DAT_00001684;\n    int* ptr_1 = PTR_DAT_00001680 + index * 0x20;\n    int* ptr_2 = PTR_DAT_00001684 + index * 8;\n    byte* byte_ptr = (byte*)(*ptr_1 + 4);\n    int* int_ptr = *ptr_2;\n    if((*byte_ptr & 0x20) && int_ptr)\n    {\n        code* code_ptr = *(code**)int_ptr;\n        undefined4* undefined4_ptr = (undefined4*)(*ptr_2 + 4);\n        undefined* undefined_ptr = (undefined*)(*ptr_1 + 7);\n        code_ptr(*undefined4_ptr, *undefined_ptr);\n    }\n    check_and_set_flag_if_not_zero_00001348();\n    return;\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_and_execute_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_flag_00001748",
                "param_1": "flag_value",
                "DAT_00001774": "flag_data",
                "PTR_DAT_00001774": "flag_data_pointer"
            },
            "code": "void set_flag_00001748(byte flag_value){\n    byte* flag_ptr = PTR_DAT_00001774 + 3;\n    *flag_ptr = flag_value | (*flag_ptr & 0x1f);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_0000191c",
                "FUN_000018bc"
            ],
            "imported": false,
            "current_name": "set_flag_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "enable_interrupts_0000294c",
                "DAT_0000296c": "interrupt_register"
            },
            "code": "void enable_interrupts_0000294c(void)\n{\n  uint32_t *interrupt_flag = (uint32_t *)(DAT_0000296c + 0x14);\n  *interrupt_flag |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "enable_interrupts_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "is_valid_input_00000534",
                "*param_1": "*input",
                "param_2": "size",
                "uVar1": "is_valid"
            },
            "code": "int is_valid_input_00000534(int* input, int size) {\n    *input = 0;\n    if (size == 0 || size == 1 || size == 2) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "is_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_calculated_address_to_one_000017dc",
                "DAT_00001820": "address",
                "DAT_00001824": "address",
                "DAT_00001828": "address",
                "set_calculated_address_to_one_000016c8": "set_calculated_address_to_one",
                "uint": "uint32_t",
                "undefined4": "uint32_t"
            },
            "code": "void set_calculated_address_to_one_000017dc(uint32_t* DAT_00001820, uint32_t value) {\n    set_calculated_address_to_one_000017dc_000016c8(DAT_00001820, value);\n    if ((*(uint32_t *)(DAT_00001820 + 0x10) & 0x100) == 0) {\n        *(uint32_t *)(DAT_00001820 + 0x10) = 0x104;\n    }\n    *DAT_00001820 = *DAT_00001820 & 0xfff3ffff | 0x80000;\n    return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "set_calculated_address_to_one_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "store_values_and_return_00000410",
                "store_values_in_memory_00000df4": "store_values_in_memory"
            },
            "code": "void store_values_and_return_00000410(void)\n{\n  store_values_in_memory();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "store_values_and_return_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_head_node_000005ca",
                "param_1": "head",
                "puVar1": "node_to_remove"
            },
            "code": "undefined4* remove_head_node_000005ca(int* head) {\n  undefined4* node_to_remove;\n  if (*head == 0) {\n    node_to_remove = NULL;\n  }\n  else {\n    node_to_remove = *(undefined4**)*head;\n    if (node_to_remove == (undefined4*)*head) {\n      *head = 0;\n    }\n    else {\n      *(undefined4*)*head = *node_to_remove;\n    }\n  }\n  return node_to_remove;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "remove_head_node_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "DAT_data"
            },
            "code": "void do_nothing_with_data_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_in_array_00002714",
                "param_1": "bit_position",
                "*(int *)(DAT_00002740 + ((uint)(int)(char)param_1 >> 5) * 4)": "array_ptr",
                "1 << (param_1 & 0x1f)": "bit_mask"
            },
            "code": "void set_bit_in_array_00002714(byte bit_position) {\n    int* *(int *)(DAT_00002740 + ((uint)(int)(char)param_1 >> 5) * 4) = (int*)(DAT_00002740 + ((uint)(int)(char)bit_position >> 5) * 4);\n    int bit_mask = 1 << (bit_position & 0x1f);\n    **(int *)(DAT_00002740 + ((uint)(int)(char)param_1 >> 5) * 4) = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "extract_bits_and_call_function_if_flag_set_000020e0",
                "DAT_000020f0": "data",
                "extract_bits_and_call_function_if_flag_set_00002028": "extract_bits_and_call_function_if_flag_set_00002028",
                "2": "flag_bit_position"
            },
            "code": "void extract_bits_and_call_function_if_flag_set_000020e0(int* DAT_000020f0, int flag_bit_position) {\n    extract_bits_and_call_function_if_flag_set_000020e0_00002028(DAT_000020f0, flag_bit_position);\n    return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_if_flag_set_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_with_data_00005fec",
                "DAT_00005ff4": "DAT_data",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005fec(void)\n{\n  do_nothing(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "parseNumber_00004f84",
                "param_1": "inputString",
                "param_2": "nextChar",
                "param_3": "base",
                "uVar1": "digitValue",
                "uVar2": "currentCharValue",
                "uVar3": "isHexadecimal",
                "uVar4": "digit",
                "iVar5": "overflowed",
                "uVar6": "overflowLimit",
                "uVar7": "maxResult",
                "pbVar8": "currentCharPtr",
                "pbVar9": "nextCharPtr",
                "PTR_DAT_00004f7c": "charProperties",
                "DAT_00004f94": "errorFlag"
            },
            "code": "uint parseNumber_00004f84(byte *inputString, byte **nextChar, uint base) {\n  uint digitValue;\n  uint sign = 1;\n  uint overflowLimit;\n  int overflowed = 0;\n  byte *currentChar;\n  uint result = 0;\n  currentChar = inputString;\n  while ((byte)PTR_DAT_00004f7c[*currentChar] & 8) {\n    currentChar++;\n  }\n  if (*currentChar == 0x2d) {\n    sign = -1;\n    currentChar++;\n  }\n  else if (*currentChar == 0x2b) {\n    currentChar++;\n  }\n  if (base == 0) {\n    if (*currentChar != 0x30) {\n      base = 10;\n    }\n    else if ((*(currentChar + 1) & 0xdf) == 0x58) {\n      base = 16;\n      currentChar += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  else if (base != 16 || *currentChar != 0x30) {\n    base = 10;\n  }\n  overflowLimit = (uint)(0x7FFFFFFF / base);\n  while (*currentChar != 0) {\n    digitValue = *currentChar - 0x30;\n    if (digitValue > 9) {\n      digitValue = (byte)PTR_DAT_00004f7c[*currentChar] & 0x1f;\n    }\n    if (digitValue >= base) {\n      break;\n    }\n    if (!overflowed) {\n      if (result > overflowLimit) {\n        overflowed = 1;\n      }\n      else {\n        result *= base;\n        if (result + digitValue < result) {\n          overflowed = 1;\n        }\n        else {\n          result += digitValue;\n        }\n      }\n    }\n    currentChar++;\n  }\n  if (overflowed) {\n    *(undefined4 *)*DAT_00004f94 = 0x22;\n    result = (sign == 1 ? 0x7FFFFFFF : 0x80000000);\n    if (nextChar == (byte **)0x0) {\n      return result;\n    }\n  }\n  else {\n    result *= sign;\n    if (nextChar == (byte **)0x0) {\n      return result;\n    }\n    if (overflowed == 0 && *currentChar != 0) {\n      *nextChar = currentChar;\n    }\n  }\n  *nextChar = currentChar;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "parseNumber_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "FUNC_000028f0"
            },
            "code": "\nint FUNC_000028f0(void)\n\n{\n  return *(int *)(DAT_0000290c + 8) + 1;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "FUNC_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "data",
                "uVar2": "result",
                "uVar3": "month",
                "iVar4": "is_leap_year",
                "puVar5": "month_data",
                "iVar6": "year_index",
                "uVar7": "leap_year_index",
                "iVar8": "month_index",
                "iVar9": "day_index",
                "uVar10": "leading_zeroes"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year) {\n  uint32_t *data = (uint32_t *)get_data_000056b0();\n  if (year < 0x7b2) {\n    return 0;\n  }\n  uint32_t leading_zeroes = count_leading_zeroes(year % 400);\n  uint32_t year_index = (year - 0x7b2) * 0x16d + ((int32_t)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n  data[1] = year;\n  uint32_t *month_data = data;\n  do {\n    uint32_t month = month_data[5];\n    if (*(char *)(month_data + 2) == 'J') {\n      if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n        if (month < 0x3c) {\n          year_index = year_index;\n        }\n        else {\n          year_index += 1;\n        }\n      }\n      else {\n        year_index = year_index;\n      }\n      year_index += month + -1;\n    }\n    else if (*(char *)(month_data + 2) == 'D') {\n      year_index += month;\n    }\n    else {\n      uint32_t leap_year_index = leading_zeroes >> 5;\n      if (((year & 3) == 0) && (year % 100 != 0)) {\n        leap_year_index = 1;\n      }\n      uint32_t month_index = 0;\n      year_index = year_index;\n      while (true) {\n        month_index += 1;\n        if (month_data[3] <= month_index) break;\n        year_index += *(int32_t *)(PTR_DAT_000050e4 + month_index * 4 + leap_year_index * 0x30 + -4);\n      }\n      uint32_t day_index = month - (year_index + 4U) % 7;\n      if (day_index < 0) {\n        day_index += 7;\n      }\n      for (day_index = (month_data[4] - 1) * 7 + day_index; *(int32_t *)(PTR_DAT_000050e4 + month_index * 4 + leap_year_index * 0x30 + -4) <= day_index; day_index = day_index + -7) {\n      }\n      year_index += day_index;\n    }\n    month = month_data[10] + DAT_000050e0 * year_index + month_data[6];\n    month_data[8] = month;\n    month_data[9] = (int32_t)month >> 0x1f;\n    month_data = month_data + 10;\n  } while (data + 0x14 != month_data);\n  uint32_t carry = data[9];\n  uint32_t previous_year = data[0x13];\n  data[0] = (uint32_t)((int32_t)((carry - previous_year) - (uint32_t)(data[8] < data[0x12])) < 0 != (SBORROW4(carry,previous_year) != SBORROW4(carry - previous_year,(uint32_t)(data[8] < data[0x12]))));\n  return 1;\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_00005100",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "copy_data_to_memory_00004dee",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "param_4": "offset",
                "uVar1": "return_value"
            },
            "code": "int copy_data_to_memory_00004dee(int destination, int source, int size, int offset)\\n\\\n    {\\n\\\n        int return_value;\\n\\\n        if ((int)((uint)*(ushort *)(source + offset) << 0x17) < 0)\\n\\\n        {\\n\\\n            set_param_to_19(destination, (int)*(short *)(source + offset + 2), 0, 2);\\n\\\n        }\\n\\\n        *(ushort *)(source + offset) = *(ushort *)(source + offset) & 0xefff;\\n\\\n        return_value = copy_data_to_memory_00004dee_00000e38(destination, source, size);\\n\\\n        return return_value;\\n\\\n    }",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "copy_data_to_memory_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_memory_00000fec",
                "param_1": "memory",
                "param_2": "size_minus_one",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION"
            },
            "code": "void initialize_memory_00000fec(uint32_t *memory, uint32_t size_minus_one)\n{\n    if ((size_minus_one & (size_minus_one - 1)) != 0)\n    {\n        process_data_and_print_relocation_info_00000f04(3, PTR_s_FAILED_ASSERTION__00001030);\n    }\n\n    memory[0] = 0;\n    memory[1] = 0;\n    memory[2] = size_minus_one;\n    return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_memory_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "get_updated_array_value_00000428",
                "param_1": "array_ptr",
                "param_2": "new_value",
                "uVar1": "interrupts_enabled_state",
                "local_c": "current_array_value"
            },
            "code": "uint32_t get_updated_array_value_00000428(uint32_t *array_ptr, uint32_t new_value)\n    {\n        uint32_t interrupts_enabled_state = getIRQInterruptsEnabledState();\n        uint32_t current_array_value = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n        \n        if ((DAT_00000488 < (uint32_t)(new_value + *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484)) || ((uint32_t)(new_value + *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484) < DAT_0000048c))\n        {\n            *array_ptr = 0xc;\n            current_array_value = 0xffffffff;\n        }\n        else\n        {\n            *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484 = new_value + *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n        }\n        \n        enable_interrupts_if_privileged_00000d0c(interrupts_enabled_state);\n        return current_array_value;\n    }",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "get_updated_array_value_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClassFromChar_000039e8",
                "param_1": "c",
                "puVar1": "result"
            },
            "code": "char* getClassFromChar_000039e8(char c) {\n    char* result = PTR_s_CLASS_UNKNOWN_00003d20;\n    switch (c) {\n        case '\\0':\n            result = DAT_00003cc0;\n            break;\n        case '@':\n            result = DAT_00003cc4;\n            break;\n        case 'B':\n            result = DAT_00003cc8;\n            break;\n        case 'C':\n            result = PTR_s_ACT_SERVO_00003ccc;\n            break;\n        case 'D':\n            result = PTR_s_ACT_MOTOR_00003cd0;\n            break;\n        case 'E':\n            result = PTR_s_ACT_SWITCH_00003cd4;\n            break;\n        case 'F':\n            result = PTR_s_ACT_DIMMER_00003cd8;\n            break;\n        case -0x80:\n            result = PTR_s_SENSE_ANY_00003cdc;\n            break;\n        case -0x7f:\n            result = PTR_s_SENSE_BTN_00003ce0;\n            break;\n        case -0x7e:\n            result = PTR_s_SENSE_TEMP_00003ce4;\n            break;\n        case -0x7d:\n            result = PTR_s_SENSE_HUM_00003ce8;\n            break;\n        case -0x7c:\n            result = PTR_s_SENSE_LIGHT_00003cec;\n            break;\n        case -0x7b:\n            result = PTR_s_SENSE_ACCEL_00003cf0;\n            break;\n        case -0x7a:\n            result = PTR_s_SENSE_MAG_00003cf4;\n            break;\n        case -0x79:\n            result = PTR_s_SENSE_GYRO_00003cf8;\n            break;\n        case -0x78:\n            result = PTR_s_SENSE_COLOR_00003cfc;\n            break;\n        case -0x77:\n            result = PTR_s_SENSE_PRESS_00003d00;\n            break;\n        case -0x76:\n            result = PTR_s_SENSE_ANALOG_00003d04;\n            break;\n        case -0x75:\n            result = PTR_s_SENSE_UV_00003d08;\n            break;\n        case -0x74:\n            result = PTR_s_SENSE_OBJTEMP_00003d0c;\n            break;\n        case -0x73:\n            result = PTR_s_SENSE_PULSE_COUNT_00003d10;\n            break;\n        case -0x72:\n            result = PTR_s_SENSE_DISTANCE_00003d14;\n            break;\n        case -0x71:\n            result = PTR_s_SENSE_CO2_00003d18;\n            break;\n        default:\n            if (c == -1) {\n                return PTR_s_CLASS_ANY_00003d1c;\n            }\n            break;\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "getClassFromChar_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "copy_data_to_memory_00000e38",
                "param_1": "destination",
                "param_2": "source",
                "copy_data_to_memory_000015d0": "memcpy",
                "PTR_": "destination_",
                "DAT_": "source_"
            },
            "code": "int copy_data_to_memory_00000e38(int offset, int* destination, int* source) {\n    memcpy(destination+offset, source, sizeof(source));\n    return *source;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_difference_equal_to_third_00002294",
                "param_1": "data_ptr",
                "iVar2": "difference",
                "bVar3": "is_equal",
                "uVar1": "result"
            },
            "code": "bool is_difference_equal_to_third_00002294(int data_ptr)\n{\n  int first_value = *(int *)(data_ptr + 8);\n  int second_value = *(int *)(data_ptr + 12);\n  int difference = second_value - first_value;\n  bool is_equal = difference == *(int *)(data_ptr + 4);\n  if (is_equal) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "is_difference_equal_to_third_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "count_digits_and_relocate_00003e9e",
                "param_1": "data",
                "param_2": "length",
                "param_3": "destination",
                "uVar1": "num_digits"
            },
            "code": "int count_digits_and_relocate_00003e9e(unsigned int* data, int length, unsigned int* destination) {\n  int num_digits = 0;\n  for (int i = 0; i < length; i++) {\n    if (data[i] != 0) {\n      num_digits++;\n    }\n    destination[i] = data[i];\n  }\n  return num_digits;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "count_digits_and_relocate_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "process_data_00003378",
                "param_1": "data_array",
                "*param_1": "data_array[0]"
            },
            "code": "int process_data_00003378(uint32_t *data_array)\n{\n    uint32_t sum = data_array[5] + 0x76c;\n    uint32_t index = data_array[4] + 1;\n    uint32_t param3 = data_array[3];\n    uint32_t param2 = data_array[2];\n    uint32_t param1 = data_array[1];\n    uint32_t param0 = *data_array;\n    process_data_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc, sum, index, param3, param2, param1, param0);\n    return 0;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_00003444",
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "process_data_00003378",
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUNC_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,param_1[5] + 0x76c,param_1[4] + 1,\n               param_1[3],param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_data_00006768",
                "param_1": "device_data",
                "param_2": "node_data",
                "param_3": "data_size",
                "param_4": "param_4",
                "uVar1": "node_data_word",
                "iVar2": "process_data_result",
                "uVar3": "device_data_word",
                "uVar4": "node_data_word_ushort",
                "uVar5": "data_size_uint",
                "initialize_blocks_000042a4": "initialize_blocks",
                "PTR_DAT_00006868": "node_data_ptr_1",
                "PTR_DAT_0000686c": "node_data_ptr_2",
                "PTR_DAT_00006870": "node_data_ptr_3",
                "insert_node_at_position_00004b34": "insert_node_at_position",
                "process_data_00004158": "process_data_2",
                "initialize_device_00005700": "initialize_device",
                "count_valid_items_000043a0": "count_valid_items",
                "PTR_DAT_00006874": "valid_items_ptr",
                "PTR_LAB_00006754_1_00006878": "valid_items_lab"
            },
            "code": "undefined4 process_data_00006768(undefined4 *device_data, undefined4 *node_data, undefined4 data_size, undefined4 param_4)\\n\\\n    {\\n\\\n        undefined2 node_data_word;\\n\\\n        int process_data_00006768_result;\\n\\\n        undefined4 device_data_word;\\n\\\n        ushort node_data_word_ushort;\\n\\\n        uint data_size_uint;\\n\\\n        if ((device_data != (undefined4 *)0x0) && (device_data[6] == 0)) {\\n\\\n            initialize_blocks();\\n\\\n        }\\n\\\n        if (node_data == (undefined4 *)PTR_DAT_00006868) {\\n\\\n            node_data = (undefined4 *)device_data[1];\\n\\\n        }\\n\\\n        else if (node_data == (undefined4 *)PTR_DAT_0000686c) {\\n\\\n            node_data = (undefined4 *)device_data[2];\\n\\\n        }\\n\\\n        else if (node_data == (undefined4 *)PTR_DAT_00006870) {\\n\\\n            node_data = (undefined4 *)device_data[3];\\n\\\n        }\\n\\\n        node_data_word_ushort = *(ushort *)(node_data + 3);\\n\\\n        node_data[1] = 0;\\n\\\n        data_size_uint = (uint)*(ushort *)(node_data + 3);\\n\\\n        if ((int)(data_size_uint << 0x1a) < 0) {\\n\\\n            return 0xffffffff;\\n\\\n        }\\n\\\n        if ((int)(data_size_uint << 0x1d) < 0) {\\n\\\n            if ((undefined4 *)node_data[0xd] != (undefined4 *)0x0) {\\n\\\n                if ((undefined4 *)node_data[0xd] != node_data + 0x11) {\\n\\\n                    insert_node_at_position(device_data);\\n\\\n                }\\n\\\n                node_data[1] = node_data[0x10];\\n\\\n                node_data[0xd] = 0;\\n\\\n                if (node_data[0x10] != 0) {\\n\\\n                    *node_data = node_data[0xf];\\n\\\n                    return 0;\\n\\\n                }\\n\\\n            }\\n\\\n        }\\n\\\n        else {\\n\\\n            if (-1 < (int)(data_size_uint << 0x1b)) {\\n\\\n                *device_data = 9;\\n\\\n                node_data_word_ushort = node_data_word_ushort | 0x40;\\n\\\n                goto LAB_00006868;\\n\\\n            }\\n\\\n            if ((int)(data_size_uint << 0x1c) < 0) {\\n\\\n                process_data_00006768_result = process_data_00006768_2(device_data, node_data, data_size_uint << 0x1c, data_size_uint, param_4);\\n\\\n                if (process_data_00006768_result != 0) {\\n\\\n                    return 0xffffffff;\\n\\\n                }\\n\\\n                node_data[2] = 0;\\n\\\n                *(ushort *)(node_data + 3) = *(ushort *)(node_data + 3) & 0xfff7;\\n\\\n                node_data[6] = 0;\\n\\\n            }\\n\\\n            *(ushort *)(node_data + 3) = *(ushort *)(node_data + 3) | 4;\\n\\\n        }\\n\\\n        if (node_data[4] == 0) {\\n\\\n            initialize_device(device_data, node_data);\\n\\\n        }\\n\\\n        node_data_word_ushort = *(ushort *)(node_data + 3);\\n\\\n        node_data_word = *(undefined2 *)(node_data + 3);\\n\\\n        if ((node_data_word_ushort & 3) != 0) {\\n\\\n            *(undefined2 *)(node_data + 3) = 1;\\n\\\n            count_valid_items(PTR_DAT_00006874, PTR_LAB_00006754_1_00006878);\\n\\\n            *(undefined2 *)(node_data + 3) = node_data_word;\\n\\\n            if ((node_data_word_ushort & 9) == 9) {\\n\\\n                process_data_00006768_3(device_data, node_data);\\n\\\n            }\\n\\\n        }\\n\\\n        device_data_word = node_data[4];\\n\\\n        *node_data = device_data_word;\\n\\\n        process_data_00006768_result = (*(code *)node_data[9])(device_data, node_data[8], device_data_word, node_data[5]);\\n\\\n        node_data[1] = process_data_00006768_result;\\n\\\n        if (0 < process_data_00006768_result) {\\n\\\n            return 0;\\n\\\n        }\\n\\\n        node_data_word_ushort = *(ushort *)(node_data + 3);\\n\\\n        if (process_data_00006768_result != 0) {\\n\\\n            device_data_word = 0;\\n\\\n        }\\n\\\n        else {\\n\\\n            node_data_word_ushort = node_data_word_ushort | 0x20;\\n\\\n        }\\n\\\n        if (process_data_00006768_result != 0) {\\n\\\n            node_data[1] = device_data_word;\\n\\\n            node_data_word_ushort = node_data_word_ushort | 0x40;\\n\\\n        }\\n\\\n        LAB_00006868:\\n\\\n        *(ushort *)(node_data + 3) = node_data_word_ushort;\\n\\\n        return 0xffffffff;\\n\\\n    }",
            "called": [
                "FUN_0000404c",
                "FUN_00005700",
                "FUN_000043a0",
                "FUN_00004158",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "process_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "initialize_and_clear_memory_00000db0",
                "set_default_values_00000dcc": "set_default_values",
                "clear_memory_and_return_00000d9c": "clear_memory_and_return"
            },
            "code": "void initialize_and_clear_memory_00000db0(void)\n{\n  set_default_values();\n  clear_memory_and_return();\n  return;\n}",
            "called": [
                "FUN_00000dcc",
                "FUN_00000d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_and_clear_memory_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_and_set_flag_00002600",
                "param_1": "input",
                "uVar1": "processed_input",
                "FUNC_000047e4": "process_input",
                "set_flag_and_value_0000285c": "set_flag_and_value"
            },
            "code": "int process_and_set_flag_00002600(int input)\n{\n  int processed_input = process_input(input);\n  set_flag_and_value(processed_input);\n  return 0;\n}",
            "called": [
                "FUN_0000285c",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_and_set_flag_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_label_by_param_value_00003810",
                "param_1": "param_value",
                "puVar1": "label_ptr"
            },
            "code": "undefined* get_label_by_param_value_00003810(undefined param_value) {\n    undefined* label_ptr = PTR_LAB_00003914;\n    switch(param_value) {\n        case 2:\n            label_ptr = PTR_LAB_000038cc;\n            break;\n        case 3:\n            label_ptr = PTR_LAB_000038d0;\n            break;\n        case 4:\n            label_ptr = PTR_LAB_000038d4;\n            break;\n        case 5:\n            label_ptr = PTR_LAB_000038d8;\n            break;\n        case 6:\n            label_ptr = PTR_LAB_000038dc;\n            break;\n        case 7:\n            label_ptr = PTR_LAB_000038e0;\n            break;\n        case 8:\n            label_ptr = PTR_LAB_000038e4;\n            break;\n        case 9:\n            label_ptr = PTR_LAB_000038e8;\n            break;\n        case 10:\n            label_ptr = PTR_LAB_000038ec;\n            break;\n        case 0xb:\n            label_ptr = PTR_LAB_000038f0;\n            break;\n        case 0xc:\n            label_ptr = PTR_LAB_000038f4;\n            break;\n        case 0xd:\n            label_ptr = PTR_LAB_000038f8;\n            break;\n        case 0xe:\n            label_ptr = PTR_LAB_000038fc;\n            break;\n        case 0xf:\n            label_ptr = PTR_LAB_00003900;\n            break;\n        case 0x10:\n            label_ptr = PTR_LAB_00003904;\n            break;\n        case 0x11:\n            label_ptr = PTR_LAB_0000390c;\n            break;\n        case 0x13:\n            label_ptr = PTR_LAB_00003910;\n            break;\n        case 0x15:\n            label_ptr = PTR_LAB_00003908;\n    }\n    return label_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_label_by_param_value_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "execute_function_with_pointer_00000ed8",
                "PTR_DAT_00000ef4": "PTR_FUNCTION_POINTER_DAT",
                "in_lr": "return_address",
                "FUNC_00004c84": "execute_function_with_pointer_and_return_address"
            },
            "code": "void execute_function_with_pointer_00000ed8(void)\n{\n  undefined4 return_address;\n  execute_function_with_pointer_00000ed8_and_return_address(PTR_DAT_00000ef4, return_address);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_function_with_pointer_00000ed8",
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUNC_00004c84(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "alarmRang_000031e0",
                "FUNC_00004db8": "printAlarmMessage",
                "PTR_s_The_alarm_rang_000031f8": "alarmMessage"
            },
            "code": "void alarmRang_000031e0() \n{\n  printAlarmMessage(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "alarmRang_000031e0",
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  FUNC_00004db8(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "extractBitsAndCallFunctionIfFlagSet_000020f4",
                "DAT_00002104": "PTR_array"
            },
            "code": "void extractBitsAndCallFunctionIfFlagSet_000020f4(void)\n{\n  extract_bits_and_call_function_if_flag_set(DAT_00002104, 3);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "extractBitsAndCallFunctionIfFlagSet_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "process_string_0000687c",
                "param_1": "str_len",
                "param_2": "str",
                "pbVar1": "result",
                "uVar2": "j",
                "iVar3": "i",
                "uVar4": "current_char",
                "uVar5": "range_end",
                "uVar6": "j",
                "bVar7": "is_carrot"
            },
            "code": "byte* process_string_0000687c(int str_len, byte* str) {\n  byte* result;\n  uint current_char;\n  bool is_carrot;\n  bool is_dash;\n  uint range_end;\n  uint i;\n  uint j;\n  is_carrot = false;\n  current_char = (uint)*str;\n  if (current_char == 0x5e) {\n    is_carrot = true;\n    current_char = (uint)str[1];\n    str += 2;\n  }\n  else {\n    str++;\n  }\n  i = str_len - 1;\n  do {\n    i++;\n    *(bool*)i = is_carrot;\n  } while (i != str_len + 255);\n  if (current_char == 0) {\n    result = str - 1;\n  }\n  else {\n    do {\n      is_dash = false;\n      range_end = current_char;\n      *(bool*)(str_len + range_end) = !is_carrot;\n      str++;\n      while (true) {\n        current_char = (uint)str[-1];\n        if (current_char != 0x2d) {\n          break;\n        }\n        range_end = (uint)*str;\n        if ((range_end == 0x5d) || ((int)range_end < (int)current_char)) {\n          is_dash = true;\n          break;\n        }\n        j = current_char;\n        do {\n          j++;\n          *(bool*)(str_len + j) = !is_carrot;\n        } while ((int)j < (int)range_end);\n        i = ~current_char + range_end;\n        if ((int)range_end <= (int)current_char) {\n          i = 0;\n        }\n        current_char = range_end + 1 + i;\n        str += 2;\n      }\n      result = str - 1;\n    } while ((current_char != 0x5d) && (result = str - 1, current_char != 0));\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_string_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "convert_string_to_integer_00005edc",
                "param_1": "result",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "value",
                "bVar3": "is_negative",
                "iVar4": "digit_count",
                "uVar5": "max_value",
                "uVar6": "value",
                "pbVar7": "current_char_ptr",
                "pbVar8": "end_char_ptr",
                "PTR_DAT_00005fd0": "character_properties",
                "UINT32_MAX": "max_uint"
            },
            "code": "uint convert_string_to_integer_00005edc(undefined4 *result, byte *str, byte **endptr, uint base)\n{\n  uint digit_value;\n  uint value;\n  byte *current_char_ptr;\n  byte *end_char_ptr;\n  byte char_value;\n  bool is_negative = false;\n  int digit_count = 0;\n  uint max_value = UINT32_MAX / base;\n  value = 0;\n  current_char_ptr = str;\n  while (PTR_DAT_00005fd0[*current_char_ptr] & 8)\n  {\n    current_char_ptr++;\n  }\n  if (*current_char_ptr == 45)\n  {\n    is_negative = true;\n    current_char_ptr++;\n  }\n  else if (*current_char_ptr == 43)\n  {\n    current_char_ptr++;\n  }\n  if (base == 0)\n  {\n    if (*current_char_ptr != 48)\n    {\n      base = 10;\n    }\n    else if ((current_char_ptr[1] & 0xdf) == 88)\n    {\n      base = 16;\n      current_char_ptr += 2;\n    }\n    else\n    {\n      base = 8;\n    }\n  }\n  while (true)\n  {\n    char_value = *current_char_ptr;\n    if (char_value == 0)\n    {\n      break;\n    }\n    digit_value = char_value - 48;\n    if (9 < digit_value)\n    {\n      if (char_value < 65 || char_value > 122)\n      {\n        break;\n      }\n      digit_value = char_value - 55;\n    }\n    if (digit_value >= base)\n    {\n      break;\n    }\n    if (digit_count > 0)\n    {\n      if (max_value < value)\n      {\n        digit_count = -1;\n        break;\n      }\n      value *= base;\n    }\n    value += digit_value;\n    digit_count++;\n    current_char_ptr++;\n  }\n  if (digit_count < 0)\n  {\n    *result = 34;\n    value = UINT32_MAX;\n    if (endptr == NULL)\n    {\n      return UINT32_MAX;\n    }\n  }\n  else\n  {\n    if (is_negative)\n    {\n      value = -value;\n    }\n    if (endptr == NULL)\n    {\n      return value;\n    }\n    if (digit_count == 0)\n    {\n      end_char_ptr = str;\n    }\n    else\n    {\n      end_char_ptr = current_char_ptr - 1;\n    }\n  }\n  *endptr = end_char_ptr;\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "convert_string_to_integer_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "set_and_update_array_value_00001eea",
                "param_1": "address",
                "param_2": "value",
                "uVar1": "least_six_bits",
                "iVar2": "value_address",
                "iVar3": "memory_address"
            },
            "code": "int set_and_update_array_value_00001eea(uint16_t address, uint8_t value) {\n    uint8_t least_six_bits = mask_least_six_bits(address);\n    set_memory_value_and_update_array(address, 0);\n    int value_address = calculate_value_address(address);\n    if (value < 0) {\n        *(uint32_t *)(value_address + 0x14) |= 1 << (least_six_bits & 0xff);\n    }\n    else {\n        *(uint32_t *)(value_address + 0x14) &= ~(1 << (least_six_bits & 0xff));\n    }\n    int memory_address = get_memory_address(address);\n    *(uint32_t *)(memory_address + least_six_bits * 4) = value & 0x23 | 0x100;\n    return 0;\n}",
            "called": [
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0",
                "FUN_00001d5e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_and_update_array_value_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "processInputAndParseCommandLineArgs_000023a4",
                "auStack_88": "inputBuffer",
                "uVar1": "returnVal",
                "check_interrupt_status_and_trigger_000023d0": "checkInterruptAndTrigger",
                "FUNC_00004db8": "initializeFunction",
                "process_input_loop_and_parse_command_line_arguments_00002e6c": "processInputLoop",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "int processInputAndParseCommandLineArgs_000023a4() {\n    int returnVal;\n    char inputBuffer[128];\n\n    checkInterruptAndTrigger(0);\n    initializeFunction(uRam000023c4);\n    returnVal = processInputLoop(inputBuffer, 0x80);\n    softwareInterrupt(0x3f);\n    return returnVal;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000023d0",
                "FUN_00002e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "processInputAndParseCommandLineArgs_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "get_next_element_0000240c",
                "param_1": "current_element",
                "puVar1": "next_element"
            },
            "code": "undefined4* get_next_element_0000240c(undefined4* current_element)\n{\n    undefined4* next_element = (undefined4*) *current_element;\n    if (next_element != (undefined4*)0x0) {\n        *current_element = *next_element;\n    }\n    return next_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "get_next_element_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_and_return_00004280",
                "PTR_DAT_00004288": "PTR_DATA",
                "do_nothing_000045ec": "do_nothing_with_pointer"
            },
            "code": "void do_nothing_and_return_00004280(void)\n{\n  do_nothing_with_pointer(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "updateMemoryValues_00001448",
                "param_1": "index",
                "value1": "memoryValue1",
                "value2": "memoryValue2",
                "PTR_DAT_000014c0": "memoryDataPointer",
                "set_memory_value_and_update_array_00001f80": "updateMemoryValueAndArray",
                "arrayValue1": "arrayValue1",
                "arrayValue2": "arrayValue2"
            },
            "code": "void updateMemoryValues_00001448(int index)\n{\n    short value1 = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n    short value2 = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n    if (value1 != -1) {\n        undefined2 memoryValue1 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n        undefined4 arrayValue1 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0xc);\n        set_memory_value_and_update_array_00001f80(memoryValue1, arrayValue1);\n    }\n    if (value2 != -1) {\n        undefined2 memoryValue2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n        undefined4 arrayValue2 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0x10);\n        set_memory_value_and_update_array_00001f80(memoryValue2, arrayValue2);\n    }\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "updateMemoryValues_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "execute_main_function_00001688",
                "check_and_execute_function_00001628": "execute_sub_function"
            },
            "code": "void execute_main_function_00001688(void)\n{\n  execute_sub_function(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "execute_main_function_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "parse_and_convert_string_to_integer_00004042",
                "param_1": "input_string",
                "parseNumber_00004f84": "parseNumber"
            },
            "code": "void parse_and_convert_string_to_integer_00004042(char* input_string)\n{\n  parseNumber(input_string, 0, 10);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "parse_and_convert_string_to_integer_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "is_irq_interrupts_enabled_00000cf0",
                "uVar2": "is_interrupts_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_irq_interrupts_enabled_00000cf0(void)\n{\n  bool is_privileged_mode = is_current_mode_privileged();\n  bool is_interrupts_enabled = false;\n  if (is_privileged_mode) {\n    is_interrupts_enabled = is_IRQ_interrupts_enabled();\n  }\n  return is_interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "is_irq_interrupts_enabled_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "initialize_memory_and_interrupts_00000f8c",
                "puRam00000fd4": "memory_ptr_1",
                "uRam00000fd8": "unused_var_1",
                "allocateMemoryAndInitialize_000010d4": "allocate_memory_and_initialize",
                "puRam00000fe0": "memory_ptr_2",
                "uRam00000fe4": "unused_var_2",
                "uRam00000fe8": "memory_ptr_3",
                "execute_interrupt_and_wait_00000930": "execute_interrupt_and_wait",
                "process_data_and_print_relocation_info_00000f04": "process_data_and_print_relocation_info"
            },
            "code": "void initialize_memory_and_interrupts_00000f8c(void)\n{\n  bool interrupts_enabled = get_irq_interrupts_enabled_state();\n  uint32_t* memory_ptr_1 = (uint32_t*)0x20000000;\n  uint32_t* memory_ptr_2 = (uint32_t*)0x20100000;\n  uint32_t* memory_ptr_3 = (uint32_t*)0x20200000;\n  allocate_memory_and_initialize(memory_ptr_1, 0x100, 0xf, 0xc);\n  allocate_memory_and_initialize(memory_ptr_2, 0x600, 7);\n  uint32_t interrupt_result = execute_interrupt_and_wait(0xfd3);\n  if ((interrupt_result & (interrupt_result - 1)) != 0) {\n    process_data_and_print_relocation_info(3, \"FAILED ASSERTION: interrupt_result is not a power of 2\");\n  }\n  memory_ptr_3[0] = 0;\n  memory_ptr_3[1] = 0;\n  memory_ptr_3[2] = interrupt_result - 1;\n  return;\n}",
            "called": [
                "FUN_000010d4",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_memory_and_interrupts_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "update_data_and_set_bit_00002894",
                "param_1": "count",
                "param_2": "data",
                "param_3": "flag",
                "DAT_000028e8": "data_array_start",
                "PTR_DAT_000028ec": "DATA_PTR_OFFSET",
                "update_data_00002744": "update_data",
                "set_bit_in_array_00002714": "set_bit_in_array",
                "iVar1": "data_start"
            },
            "code": "void update_data_and_set_bit_00002894(int count, uint32_t data, uint32_t flag)\n{\n  int data_start = DAT_000028e8;\n  *(uint32_t *)(data_start + DATA_FLAG_OFFSET) = *(uint32_t *)(data_start + DATA_FLAG_OFFSET) & 0xfffffffb;\n  *(int *)(data_start + DATA_COUNT_OFFSET) = count - 1;\n  *(uint32_t *)PTR_DAT_000028ec = data;\n  *(uint32_t *)(PTR_DAT_000028ec + sizeof(uint32_t)) = flag;\n  *(uint32_t *)(data_start + DATA_FLAG_OFFSET) = *(uint32_t *)(data_start + DATA_FLAG_OFFSET) | 4;\n  update_data(0x2e, 10);\n  set_bit_in_array(0x2e);\n  return;\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "update_data_and_set_bit_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "process_data_00004158",
                "param_1": "data_ptr",
                "param_2": "config_ptr",
                "uVar1": "result",
                "PTR_DAT_000041c4": "original_config_ptr_1",
                "PTR_DAT_000041c8": "original_config_ptr_2",
                "PTR_DAT_000041cc": "original_config_ptr_3"
            },
            "code": "int process_data_00004158(int data_ptr, char *config_ptr) {\n    int result;\n    if (*(int *)(config_ptr + 0x10) != 0) {\n        if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n            call_function_000042a4();\n        }\n        if (config_ptr == PTR_DAT_000041c4) {\n            config_ptr = *(char **)(data_ptr + 4);\n        }\n        else if (config_ptr == PTR_DAT_000041c8) {\n            config_ptr = *(char **)(data_ptr + 8);\n        }\n        else if (config_ptr == PTR_DAT_000041cc) {\n            config_ptr = *(char **)(data_ptr + 0xc);\n        }\n        if (*(short *)(config_ptr + 0xc) != 0) {\n            if ((*(int *)(config_ptr + 100) >= 0) && (*(short *)(config_ptr + 0xc) >= 0)) {\n                do_nothing_000045e8(*(int *)(config_ptr + 0x58));\n            }\n            result = process_data_00004158_0000404c(data_ptr, config_ptr);\n            if (*(int *)(config_ptr + 100) < 0 || *(short *)(config_ptr + 0xc) < 0) {\n                return result;\n            }\n            do_nothing_000045ec(*(int *)(config_ptr + 0x58));\n            return result;\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_00005404",
                "FUN_00006768",
                "FUN_000041d0"
            ],
            "imported": false,
            "current_name": "process_data_00004158",
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUNC_000042a4();\n    }\n    if (param_2 == PTR_DAT_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR_DAT_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR_DAT_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = process_data_0000404c(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "execute_and_update_data_00002654",
                "param_1": "input_param",
                "param_2": "data_param",
                "param_3": "flag_param",
                "uVar1": "result"
            },
            "code": "int execute_and_update_data_00002654(int input_param, int data_param, int flag_param)\n{\n  int result = FUNC_000047e4(input_param);\n  *(int *)PTR_DAT_00002688 = data_param;\n  update_data_and_set_bit_00002894(result, PTR_execute_function_if_not_null_000026f0_1_0000268c, flag_param);\n  return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "execute_and_update_data_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "store_byte_00002538",
                "param_1": "byteToStore",
                "param_2": "valueToStore",
                "PTR_00002584": "DAT_00002584",
                "PTR_00002588": "DAT_00002588"
            },
            "code": "void store_byte_00002538(byte byteToStore, uint valueToStore) {\n  if (byteToStore < 0) {\n    char* ptr1 = (char*)((byteToStore & 0xf) + PTR_00002584 + 0x14);\n    *ptr1 = (char)((valueToStore & 0xff) << 4);\n  }\n  else {\n    char* ptr2 = (char*)(byteToStore + PTR_00002588 + 0x300);\n    *ptr2 = (char)((valueToStore & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "store_byte_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "process_data_00004c84",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "iVar1": "ptr_i",
                "uVar2": "param_1",
                "uStack_c": "param_2",
                "uStack_8": "param_3",
                "uStack_4": "param_4",
                "FUNC_000042a4": "cleanup",
                "FUNC_000057f8": "process",
                "*DAT_00004cb0": "*PTR_00004cb0"
            },
            "code": "void process_data_00004c84(undefined4 data_1, undefined4 data_2, undefined4 data_3, undefined4 data_4) {\n  int *ptr_i = *DAT_00004cb0;\n  undefined4 param_1 = data_1;\n  undefined4 param_2 = data_2;\n  undefined4 param_3 = data_3;\n  undefined4 param_4 = data_4;\n  if ((ptr_i != 0) && (*(int *)(ptr_i + 0x18) == 0)) {\n    cleanup(ptr_i);\n  }\n  process(ptr_i, *(undefined4 *)(ptr_i + 8), data_1, &param_2, param_1, &param_3);\n  return;\n}\n",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_00000f04",
                "FUN_00002ecc",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00003694",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_0000211c",
                "FUN_00000ed8"
            ],
            "imported": false,
            "current_name": "process_data_00004c84",
            "code_backup": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *DAT_00004cb0;\n  uVar2 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    FUNC_000042a4(iVar1);\n  }\n  FUNC_000057f8(iVar1,*(undefined4 *)(iVar1 + 8),param_1,&uStack_c,uVar2,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "process_device_data_0000305c",
                "param_1": "num_args",
                "param_2": "args",
                "uVar1": "arg_value",
                "auStack_20": "arg_array",
                "local_18": "num_values",
                "local_14": "device_index",
                "local_10": "device_id",
                "local_c": "i",
                "process_data_00004c84": "process_data",
                "parse_and_convert_string_to_integer_00004042": "parse_and_convert_string_to_integer",
                "get_nth_element_00003d24": "get_device_index",
                "FUNC_00004db8": "log_error",
                "fill_array_with_value_00004622": "fill_array_with_value",
                "display_data_object_00003694": "display_data_object",
                "perform_operation_00003d94": "perform_operation"
            },
            "code": "void process_device_data_0000305c(int num_args, undefined4 *args)\n{\n    undefined2 arg_value;\n    undefined2 arg_array[4];\n    uint num_values;\n    int device_index;\n    undefined4 device_id;\n    \n    if (num_args < 4) {\n        process_data(PTR_s_usage___s__s__device_id___value_0_00003154, *args, args[1]);\n    }\n    else {\n        device_id = parse_and_convert_string_to_integer(args[2]);\n        device_index = get_device_index(device_id);\n        if (device_index == 0) {\n            log_error(PTR_s_error__undefined_device_given_00003158);\n        }\n        else {\n            fill_array_with_value(arg_array, 0, 8);\n            if (num_args > 5) {\n                num_args = 6;\n            }\n            num_values = num_args - 3;\n            for (int i = 0; i < (int)num_values; i++) {\n                arg_value = parse_and_convert_string_to_integer(args[i + 3]);\n                arg_array[i] = arg_value;\n            }\n            process_data(PTR_s_Writing_to_device___i____s_0000315c, device_id, *(undefined4 *)(device_index + 8));\n            display_data_object(arg_array, num_values & 0xff);\n            num_values = perform_operation(device_index, arg_array);\n            if ((int)num_values < 1) {\n                if (num_values == -0x86) {\n                    process_data(PTR_s_error__device___i_is_not_writabl_00003160, device_id);\n                }\n                else {\n                    process_data(PTR_s_error__failure_to_write_to_devic_00003164, device_id);\n                }\n            }\n            else {\n                process_data(PTR_s_data_successfully_written_to_dev_00003168, device_id);\n            }\n        }\n    }\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003d94",
                "FUN_00003d24",
                "FUN_00003694",
                "FUN_00004042",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_device_data_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "check_and_increment_if_not_equal_000012b4",
                "param_1": "ptr",
                "param_2": "value",
                "uVar1": "result",
                "check_difference_and_increment_if_not_equal_00002364": "check_difference_and_increment_if_not_equal",
                "checkAndSetExceptionFlag_000024bc": "check_and_set_exception_flag"
            },
            "code": "int check_and_increment_if_not_equal_000012b4(int* ptr, int value) {\n\tint result = check_difference_and_increment_if_not_equal_00002364(ptr + 1, value);\n\tcheck_and_set_exception_flag_000024bc(ptr);\n\treturn result;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "check_and_increment_if_not_equal_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  puVar7 = (undefined *)((int)param_2 + 0x43);\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    puVar7 = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    puVar7 = (undefined *)*puVar9;\n    iVar4 = find_byte_00006010(puVar7,0,param_2[1],puVar9,param_1,param_2,param_3);\n    if (iVar4 != 0) {\n      param_2[1] = iVar4 - (int)puVar7;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = puVar7;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)puVar7 - (int)puVar13;\n  puVar7 = puVar13;\nLAB_00005c84:\n  iVar4 = decode_data_00005a58(param_1,param_2,&local_24,param_3,param_4);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,puVar7,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar6 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "update_pointer_0000058e",
                "param_1": "pointer_to_data",
                "param_2": "new_data",
                "*param_1": "*pointer_to_data",
                "*param_2": "*new_data"
            },
            "code": "void update_pointer_0000058e(int *pointer_to_data, undefined4 *new_data) {\n  if (*pointer_to_data == 0) {\n    *new_data = new_data;\n  }\n  else {\n    *new_data = *(undefined4 *)*pointer_to_data;\n    *(undefined4 **) *pointer_to_data = new_data;\n  }\n  *pointer_to_data = (int)new_data;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "update_pointer_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined4 local_34 [4];\n  \n  local_34[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  local_34[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar3 = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (param_2[6] != 3) {\n    pcVar3 = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  uVar6 = param_2[2];\n  uVar4 = uVar6 - 1;\n  if (0x15c < uVar4) {\n    unaff_r9 = uVar6 - 0x15d;\n    uVar6 = 0x15d;\n  }\n  if (0x15c < uVar4) {\n    param_2[2] = uVar6;\n  }\n  puVar10 = param_2 + 7;\n  if (uVar4 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar11 = 0;\n  puVar9 = puVar10;\n  do {\n    iVar1 = find_byte_00006010(local_34[iVar11],**param_3,2);\n    if (iVar1 != 0) {\n      if (iVar11 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar4 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar4;\n      }\n      else if (iVar11 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar4 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 = param_2[2];\n      param_2[2] = uVar4 - 1;\n      if (uVar4 != 0) {\n        pbVar5 = *param_3;\n        *param_3 = pbVar5 + 1;\n        puVar8 = (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 = *pbVar5;\n        pbVar5 = param_3[1];\n        param_3[1] = pbVar5 + -1;\n        puVar9 = puVar8;\n        if (((int)(pbVar5 + -1) < 1) &&\n           (iVar1 = (*(code *)param_2[0x60])(param_1,param_3), iVar1 != 0)) {\n          iVar11 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 = iVar11 + 1;\n  } while (iVar11 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  process_string_0000687c(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar11 = 0;\n  while( true ) {\n    puVar8 = puVar9;\n    if (param_2[2] == 0) break;\n    pbVar5 = *param_3;\n    uVar4 = (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) == '\\0') break;\n    if ((uVar4 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar11 = iVar11 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar8 = (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 = *pbVar5;\n    }\n    pbVar5 = param_3[1];\n    param_3[1] = pbVar5 + -1;\n    if ((int)(pbVar5 + -1) < 1) {\n      iVar1 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar9 = puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar10 < puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 = (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 == puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar8 = 0;\n    uVar2 = (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 = (undefined4 *)*param_4;\n    uVar4 = *param_2;\n    *param_4 = puVar7 + 1;\n    puVar7 = (undefined4 *)*puVar7;\n    if ((uVar4 & 0x20) == 0) {\n      if ((int)(uVar4 << 0x1f) < 0) {\n        *(short *)puVar7 = (short)uVar2;\n      }\n      else {\n        *puVar7 = uVar2;\n      }\n    }\n    else {\n      *puVar7 = uVar2;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "enable_interrupts_000025f4",
                "enable_interrupts_000027b0": "enable_interrupts"
            },
            "code": "void enable_interrupts_000025f4() {\n    enable_interrupts_000025f4_000027b0();\n    return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "enable_interrupts_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_memory_value_00001ddc",
                "param_1": "bits",
                "cVar1": "bits_from_right",
                "DAT_00001e08": "memory_location",
                "get_bits_from_right_00001da2": "get_bits_from_right",
                "set_memory_value_to_one_00001d3a": "set_memory_value_to_one"
            },
            "code": "void set_memory_value_00001ddc(char bits) {\n  char bits_from_right = get_bits_from_right(bits);\n  char offset = '\t';\n  char value = bits_from_right + offset;\n  set_memory_value_00001ddc_to_one(DAT_00001e08, value);\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "set_memory_value_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_and_display_00002ecc",
                "param_1": "device_address",
                "param_2": "data_size",
                "auStack_1c": "data_buffer",
                "local_14": "data_length",
                "uVar1": "data_class",
                "uVar2": "device_data"
            },
            "code": "void read_data_from_device_and_display_00002ecc(uint device_address, int data_size) {\n    uint data_length = execute_device_read_function(data_size, data_buffer);\n    if (data_length < 1) {\n        process_error_message(PTR_s_error__failed_to_read_from_device_00002f28, device_address);\n    }\n    else {\n        uint device_data = *(uint *)(data_size + 8);\n        uint data_class = get_class_from_character(*(char *)(*(int *)(data_size + 0xc) + 8));\n        process_data_message(PTR_s_Reading_from___i___s__s__00002f2c, device_address, device_data, data_class);\n        display_data_object(data_buffer, data_length & 0xff);\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00003d64",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002fe0",
                "FUN_00002f30"
            ],
            "imported": false,
            "current_name": "read_data_from_device_and_display_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_memory_and_return_00000d76",
                "param_1": "ptr",
                "param_2": "size",
                "puVar1": "mem_ptr",
                "*puVar1": "*((void**)mem_ptr)"
            },
            "code": "void clear_memory_and_return_00000d76(void* ptr, size_t size)\n{\n  void* mem_ptr;\n  mem_ptr = multiply_and_shift(ptr, size);\n  *((void**)mem_ptr) = NULL;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "clear_memory_and_return_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "process_device_input_000057a8",
                "param_1": "num_bytes_received",
                "param_2": "input_byte",
                "param_3": "input_buffer",
                "iVar1": "buffer_size",
                "puVar2": "buffer_pointer",
                "process_device_data_00005404()": "process_device_data()"
            },
            "code": "int process_device_input_000057a8(int num_bytes_received, int input_byte, int *input_buffer){\n  int buffer_size = input_buffer[2] - 1;\n  input_buffer[2] = buffer_size;\n  if((buffer_size < 0) && ((buffer_size < (int)input_buffer[6] || (input_byte == 10)))) {\n    int error_code = process_device_data();\n    return error_code;\n  }\n  undefined *buffer_pointer = (undefined *)*input_buffer;\n  *input_buffer = buffer_pointer + 1;\n  *buffer_pointer = (char)input_byte;\n  return input_byte;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "process_device_input_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_address_00001696",
                "param_1": "address",
                "param_2": "offset"
            },
            "code": "int calculate_address_00001696(uint32_t address, int offset) {\n    uint32_t upper_bits = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    uint32_t result = offset * 4 + upper_bits + shifted_lower_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_000016ec",
                "FUN_000016c8",
                "FUN_00001710"
            ],
            "imported": false,
            "current_name": "calculate_address_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "get_num_relocations_000008b8",
                "local_c": "relocation_ptr",
                "PTR_DAT_000008f4": "relocation_array_start",
                "DAT_000008f8": "relocation_type",
                "PTR_Elf32_Rel_ARRAY_000008fc": "relocation_array_end"
            },
            "code": "int get_num_relocations_000008b8(void)\n{\n  int *relocation_ptr;\n  for (relocation_ptr = (int *)PTR_DAT_000008f4; (*relocation_ptr == DAT_000008f8 && (relocation_ptr < PTR_Elf32_Rel_ARRAY_000008fc)); relocation_ptr++)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)relocation_ptr >> 2) << 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_num_relocations_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "checkAndSetExceptionFlag_000024bc",
                "param_1": "nodeList",
                "uVar1": "nodeValue",
                "uVar2": "interruptState",
                "iVar3": "nextNodeIndex",
                "getIRQInterruptsEnabledState_00000cd0": "getIRQInterruptsEnabledState",
                "enable_interrupts_if_privileged_00000d0c": "enableInterruptsIfPrivileged",
                "get_next_element_0000240c": "getNextNodeIndex",
                "update_node_00000698": "updateNode",
                "check_exception_and_set_flag_00000738": "checkExceptionAndSetFlag"
            },
            "code": "void checkAndSetExceptionFlag_000024bc(int *nodeList)\n{\n  int nextNodeIndex;\n  undefined interruptState;\n  interruptState = getIRQInterruptsEnabledState();\n  if (*nodeList == 0) {\n    enableInterruptsIfPrivileged(interruptState);\n  }\n  else if (*nodeList == -1) {\n    *nodeList = 0;\n    enableInterruptsIfPrivileged(interruptState);\n  }\n  else {\n    nextNodeIndex = getNextNodeIndex(nodeList);\n    updateNode(nextNodeIndex - 8, 10);\n    if (*nodeList == 0) {\n      *nodeList = -1;\n    }\n    undefined nodeValue = *(undefined *)(nextNodeIndex - 3);\n    enableInterruptsIfPrivileged(interruptState);\n    checkExceptionAndSetFlag(nodeValue);\n  }\n  return;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000240c",
                "FUN_00000cd0",
                "FUN_00000738"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "checkAndSetExceptionFlag_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "count_matching_integers_00000490",
                "param_1": "array1",
                "param_2": "array2",
                "param_3": "array1",
                "param_4": "array2",
                "uVar1": "matching_count"
            },
            "code": "int count_matching_integers_00000490(int* array1, int* array2) {\n  int matching_count = 0;\n  for (int i = 0; i < sizeof(array1)/sizeof(int); i++) {\n    for (int j = 0; j < sizeof(array2)/sizeof(int); j++) {\n      if (array1[i] == array2[j]) {\n        matching_count++;\n        break;\n      }\n    }\n  }\n  return matching_count;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "count_matching_integers_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_pointer_data_0000091c",
                "PTR_DAT_0000092c": "pointer_data"
            },
            "code": "const char* get_pointer_data_0000091c()() {\n    return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_pointer_data_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "set_memory_value_and_update_array_00001f80",
                "param_1": "memory_address",
                "param_2": "value",
                "iVar1": "memory_address_pointer",
                "iVar2": "masked_address",
                "uVar3": "bits_from_right",
                "uVar4": "masked_bits",
                "uVar5": "current_value"
            },
            "code": "void set_memory_value_and_update_array_00001f80(int memory_address, int value) {\n  int masked_address = mask_least_six_bits(memory_address);\n  uint current_value = *(uint *)(get_memory_address(memory_address) + masked_address * 4);\n  *(undefined4 *)(get_memory_address(memory_address) + masked_address * 4) = value;\n  if ((current_value & 0xf0000) != 0) {\n    uint bits_from_right = get_bits_from_right(memory_address);\n    uint masked_bits = mask_least_six_bits(memory_address);\n    extract_bits_and_update_array(bits_from_right, masked_bits);\n  }\n  return;\n}",
            "called": [
                "FUN_00001dc0",
                "FUN_00001ddc",
                "FUN_00001ec4",
                "FUN_00001d5e",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001448",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "set_memory_value_and_update_array_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "enable_interrupts_and_set_flags_00000e64",
                "find_and_set_next_item_00001034": "next_item_ptr",
                "DAT_00000ed0": "data_ptr",
                "DAT_00000ed4": "array_ptr",
                "set_and_update_array_value_00001eea": "set_and_update_array_value",
                "setBitAtPosition_00001ff6": "setBitAtPosition"
            },
            "code": "void enable_interrupts_and_set_flags_00000e64(void)\n{\n    uint *next_item_ptr = find_and_set_next_item_00001034;\n    uint *DAT_00000ed0 = DAT_00000ed0;\n    uint *DAT_00000ed4 = DAT_00000ed4;\n\n    uint *flag_ptr = next_item_ptr + *DAT_00000ed0 + 4;\n    *flag_ptr |= 0x200;\n\n    uint *array_value_ptr = DAT_00000ed4 + 0x48;\n    *array_value_ptr &= 0xfefff8ff;\n\n    setup_system_and_enable_interrupts_00001274();\n\n    set_and_update_array_value_00001eea(0x2056, 0x80);\n    set_and_update_array_value_00001eea(0x511a, 0x80);\n    set_and_update_array_value_00001eea(0x2055, 0x80);\n\n    setBitAtPosition_00001ff6(0x2056);\n    setBitAtPosition_00001ff6(0x511a);\n    setBitAtPosition_00001ff6(0x2055);\n}",
            "called": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001274"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "enable_interrupts_and_set_flags_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "clearBitInUnsignedIntAtOffsetFromData_000026e4",
                "clear_bit_in_uint_at_offset_from_dat_00002990_00002970": "clearBitInUnsignedIntAtOffsetFromData",
                "PTR_DATA": "data",
                "OFFSET": "offset"
            },
            "code": "void clearBitInUnsignedIntAtOffsetFromData_000026e4(void)\n{\n  clearBitInUnsignedIntAtOffsetFromData_000026e4(PTR_DATA, OFFSET);\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clearBitInUnsignedIntAtOffsetFromData_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "multiply_and_shift_00000d44",
                "param_1": "input_value",
                "param_2": "multiplier",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int multiply_and_shift_00000d44(uint input_value, int multiplier) {\n    uint shifted_input = (input_value & 0xfffff) << 5;\n    uint masked_input = input_value & 0xf0000000;\n    int result = multiplier * 4 + masked_input + shifted_input + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "multiply_and_shift_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_node_00000698",
                "param_1": "node_index",
                "param_2": "node_value",
                "PTR_DAT_00000730": "node_pointer_array",
                "PTR_DAT_00000734": "node_status",
                "remove_head_node_000005ca": "remove_head_node",
                "update_pointer_0000058e": "update_pointer"
            },
            "code": "void update_node_00000698(int node_index, uint8_t node_value) {\n    if (node_value < 9) {\n        if ((8 < *(byte *)(node_index + 4)) &&\n           (remove_head_node(PTR_DAT_00000730 + (uint)*(byte *)(node_index + 5) * 4),\n           *(int *)(PTR_DAT_00000730 + (uint)*(byte *)(node_index + 5) * 4) == 0)) {\n            *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 & ~(1 << *(sbyte *)(node_index + 5));\n        }\n    }\n    else if (*(byte *)(node_index + 4) < 9) {\n        update_pointer(PTR_DAT_00000730 + (uint)*(byte *)(node_index + 5) * 4, node_index + 8);\n        *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 | 1 << *(sbyte *)(node_index + 5);\n    }\n    *(char *)(node_index + 4) = (char)node_value;\n    return;\n}",
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_000024bc",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_node_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "getIRQInterruptsEnabledState_00000cd0",
                "uVar2": "are_interrupts_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "getIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0vgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ggetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0mgetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0=getIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0(getIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0)getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0CgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0MgetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0PgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0vgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ggetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0(getIRQInterruptsEnabledState_00000cd0)getIRQInterruptsEnabledState_00000cd0;getIRQInterruptsEnabledState_00000cd0\ngetIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0=getIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0fgetIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0;getIRQInterruptsEnabledState_00000cd0\ngetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0fgetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0(getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0vgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ggetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0mgetIRQInterruptsEnabledState_00000cd0ogetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0)getIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0{getIRQInterruptsEnabledState_00000cd0\ngetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0=getIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0IgetIRQInterruptsEnabledState_00000cd0RgetIRQInterruptsEnabledState_00000cd0QgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0EgetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0(getIRQInterruptsEnabledState_00000cd0)getIRQInterruptsEnabledState_00000cd0;getIRQInterruptsEnabledState_00000cd0\ngetIRQInterruptsEnabledState_00000cd0}getIRQInterruptsEnabledState_00000cd0\ngetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0IgetIRQInterruptsEnabledState_00000cd0RgetIRQInterruptsEnabledState_00000cd0QgetIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0(getIRQInterruptsEnabledState_00000cd0)getIRQInterruptsEnabledState_00000cd0;getIRQInterruptsEnabledState_00000cd0\ngetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0 getIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0igetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0rgetIRQInterruptsEnabledState_00000cd0ugetIRQInterruptsEnabledState_00000cd0pgetIRQInterruptsEnabledState_00000cd0tgetIRQInterruptsEnabledState_00000cd0sgetIRQInterruptsEnabledState_00000cd0_getIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0ngetIRQInterruptsEnabledState_00000cd0agetIRQInterruptsEnabledState_00000cd0bgetIRQInterruptsEnabledState_00000cd0lgetIRQInterruptsEnabledState_00000cd0egetIRQInterruptsEnabledState_00000cd0dgetIRQInterruptsEnabledState_00000cd0;getIRQInterruptsEnabledState_00000cd0",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_000010d4",
                "FUN_00000f8c",
                "FUN_00000794",
                "FUN_00000f04",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00000e58",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "getIRQInterruptsEnabledState_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "get_IRQ_interrupts_enabled_status_00000cc0",
                "uVar2": "irq_interrupts_enabled_status",
                "bVar1": "is_privileged_mode",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "isIRQinterruptsEnabled": "isIRQinterruptsEnabled",
                "disableIRQinterrupts": "disableIRQinterrupts"
            },
            "code": "uint32_t get_IRQ_interrupts_enabled_status_00000cc0(void)\n{\n    bool is_privileged_mode = (bool)isCurrentModePrivileged();\n    uint32_t irq_interrupts_enabled_status = 0;\n    if (is_privileged_mode)\n    {\n        irq_interrupts_enabled_status = isIRQinterruptsEnabled();\n    }\n    disableIRQinterrupts();\n    return irq_interrupts_enabled_status;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "get_IRQ_interrupts_enabled_status_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_and_execute_data_flag_00002994",
                "DAT_000029f8": "data_ptr",
                "PTR_DAT_000029fc": "function_ptr",
                "check_data_flag_00002798": "check_data_flag"
            },
            "code": "void check_and_execute_data_flag_00002994()\n{\n  int DAT_000029f8 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_DAT_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) &= 0xfffffffb;\n    (**(code **)PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  check_data_flag_00002798();\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_and_execute_data_flag_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "uVar2": "current_exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint get_current_exception_number_if_privileged_mode_00000d2a(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint current_exception_number = 0;\n  if (is_privileged_mode)\n  {\n    current_exception_number = getCurrentExceptionNumber();\n    current_exception_number = current_exception_number & 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "setBitAtPosition_00001ff6",
                "param_1": "position",
                "uVar1": "maskedValue",
                "iVar2": "calculatedValue"
            },
            "code": "void setBitAtPosition_00001ff6(uint8_t position) {\n    uint8_t maskedValue = maskLeastSixBits(position);\n    int calculatedValue = calculateValue(position);\n    *(int *)(calculatedValue + 4) = 1 << (maskedValue & 0xff);\n    return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "setBitAtPosition_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "store_memory_values_000013b8",
                "param_1": "index",
                "param_2": "bit_array",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "return_value",
                "updateMemoryValues_00001448": "updateMemoryValues",
                "set_memory_location_to_one_00001392": "set_memory_location_to_one",
                "set_bit_in_array_000014c4": "set_bit_in_array"
            },
            "code": "undefined4 store_memory_values_000013b8(int index, undefined4 bit_array, undefined4 value1, undefined4 value2)\\n{\\n    undefined4 return_value;\\n    if (index != 0) {\\n        process_data_and_print_relocation_info(3, PTR_s_FAILED_ASSERTION__0000143c);\\n    }\\n    *(undefined4 *)(PTR_DAT_00001440 + index * 8) = value1;\\n    *(undefined4 *)(PTR_DAT_00001440 + index * 8 + 4) = value2;\\n    updateMemoryValues(index);\\n    set_memory_location_to_one(*(undefined4 *)(PTR_DAT_00001444 + index * 0x20 + 0x18), PTR_DAT_00001444[index * 0x20 + 0x1c]);\\n    if (PTR_DAT_00001444[index * 0x20 + 0x1e] == \"\\0\") {\\n        set_bit_in_array(index, bit_array);\\n        return_value = 0;\\n    }\\n    else {\\n        return_value = 0xffffffff;\\n    }\\n    return return_value;\\n}",
            "called": [
                "FUN_00001392",
                "FUN_00000f04",
                "FUN_000014c4",
                "FUN_00001448"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "store_memory_values_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_command_descriptions_00002a88",
                "param_1": "commands",
                "local_18": "command_info",
                "local_10": "index",
                "local_c": "current_command",
                "FUNC_00004c84": "print_command_description",
                "PTR_s___20s__s_00002b04": "header",
                "PTR_s_Command_00002b00": "command",
                "PTR_s_Description_00002afc": "description",
                "FUNC_00004db8": "print_separator",
                "PTR_s__________________________________00002b08": "separator",
                "PTR_PTR_s_reboot_00002b0c": "reboot"
            },
            "code": "void print_command_descriptions_00002a88(int *PTR_s_Command_00002b00s)\n{\n  int *PTR_s_Command_00002b00_info[2];\n  uint index;\n  int *current_PTR_s_Command_00002b00;\n  print_PTR_s___20s__s_00002b04(PTR_s___20s__s_00002b04, PTR_s_Command_00002b00, PTR_s_Description_00002afc);\n  print_PTR_s__________________________________00002b08(PTR_s__________________________________00002b08);\n  PTR_s_Command_00002b00_info[0] = PTR_s_Command_00002b00s;\n  PTR_s_Command_00002b00_info[1] = (int *)PTR_PTR_s_PTR_PTR_s_reboot_00002b0c_00002b0c;\n  for (index = 0; index < 2; index++) {\n    current_PTR_s_Command_00002b00 = PTR_s_Command_00002b00_info[index];\n    if (current_PTR_s_Command_00002b00 != (int *)0x0) {\n      for (; *current_PTR_s_Command_00002b00 != 0; current_PTR_s_Command_00002b00 += 3) {\n        print_PTR_s_Command_00002b00_PTR_s_Description_00002afc(PTR_s___20s__s_00002b04, *current_PTR_s_Command_00002b00, current_PTR_s_Command_00002b00[1]);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "print_command_descriptions_00002a88",
            "code_backup": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18 [2];\n  uint local_10;\n  int *local_c;\n  \n  FUNC_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  FUNC_00004db8(PTR_s__________________________________00002b08);\n  local_18[0] = param_1;\n  local_18[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    local_c = local_18[local_10];\n    if (local_c != (int *)0x0) {\n      for (; *local_c != 0; local_c = local_c + 3) {\n        FUNC_00004c84(PTR_s___20s__s_00002b04,*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "read_and_display_data_from_device_00002f30",
                "local_10": "data_index",
                "local_c": "data_ptr"
            },
            "code": "void read_and_display_data_from_device_00002f30(void)\n{\n  int data_index = 0;\n  undefined4 *data_ptr = *(undefined4 **)PTR_DAT_00002f6c;\n  \n  while(data_ptr != (undefined4 *)0x0)\n  {\n    read_data_from_device_and_display_00002ecc(data_index, data_ptr);\n    FUNC_00004db8(PTR_DAT_00002f70);\n    data_index = data_index + 1;\n    data_ptr = (undefined4 *)*data_ptr;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_and_display_data_from_device_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "update_bits_at_index_00001e44",
                "param_1": "index",
                "param_2": "bit_mask",
                "param_3": "value",
                "iVar1": "bit_shift",
                "PTR_DAT_00001ec0": "target_address",
                "clear_mask": "clear_mask",
                "set_mask": "set_mask"
            },
            "code": "void update_bits_at_index_00001e44(int index, uint32_t bit_mask, int value)\n{\n  int bit_shift = (int)bit_mask >> 3;\n  uint32_t* PTR_DAT_00001ec0 = (uint32_t*)(PTR_DAT_00001ec0 + (bit_shift + index * 4) * 4);\n  uint32_t clear_mask = ~(0xf << ((bit_mask & 7) << 2));\n  uint32_t set_mask = value << ((bit_mask & 7) << 2);\n  \n  *PTR_DAT_00001ec0 = (*PTR_DAT_00001ec0 & clear_mask) | set_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "update_bits_at_index_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_in_array_00001318",
                "param_1": "bit",
                "DAT_00001344": "array",
                "int": "unsigned int",
                "uint": "unsigned int",
                "char": "unsigned char"
            },
            "code": "void set_bit_in_array_00001318(unsigned char bit, unsigned int* DAT_00001344) {\n    unsigned int index = bit >> 5;\n    unsigned int offset = bit & 0x1f;\n    unsigned int mask = 1 << offset;\n    DAT_00001344[index] |= mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_stack_pointer"
            },
            "code": "unsigned int get_main_stack_pointer_00000900() {\n  unsigned int main_stack_pointer;\n  main_stack_pointer = getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_with_pointer_00004274",
                "PTR_DAT_0000427c": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00004274(void)\n{\n  do_nothing(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "process_device_data_00002fe0",
                "param_1": "device_count",
                "param_2": "device_data",
                "iVar1": "device_id",
                "uVar2": "device_data_value",
                "process_data_00004c84": "process_data",
                "PTR_s_usage___s__s__device_id__all_00003050": "PTR_s_usage___s__s__device_id__all_00003050",
                "compare_bytes_00004e52": "compare_device_id_bytes",
                "PTR_DAT_00003054": "PTR_DAT_00003054",
                "read_and_display_data_from_device_00002f30": "read_and_display_data_from_device",
                "parse_and_convert_string_to_integer_00004042": "parse_and_convert_string_to_integer",
                "get_nth_element_00003d24": "get_nth_device_id",
                "FUNC_00004db8": "display_error",
                "PTR_s_error__undefined_device_id_given_00003058": "PTR_s_error__undefined_device_id_given_00003058",
                "read_data_from_device_and_display_00002ecc": "read_data_from_device_and_display"
            },
            "code": "void process_device_data_00002fe0(int device_count, undefined4 *device_data)\n{\n    int device_id;\n    undefined4 device_data_value;\n\n    if (device_count < 3) {\n        process_data(PTR_s_usage___s__s__device_id__all_00003050, *device_data, device_data[1]);\n    }\n    else {\n        device_id = compare_device_id_bytes(device_data[2], PTR_DAT_00003054);\n        if (device_id == 0) {\n            read_and_display_data_from_device();\n        }\n        else {\n            device_data_value = parse_and_convert_string_to_integer(device_data[2]);\n            device_id = get_nth_device_id(device_data_value);\n            if (device_id == 0) {\n                display_error(PTR_s_error__undefined_device_id_given_00003058);\n            }\n            else {\n                read_data_from_device_and_display(device_data_value, device_id);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002ecc",
                "FUN_00002f30",
                "FUN_00003d24",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_device_data_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "mask_least_six_bits_00001dc0",
                "param_1": "input_num"
            },
            "code": "ushort mask_least_six_bits_00001dc0(ushort input_num) {\n  ushort least_six_bits = input_num & 0x3f;\n  return least_six_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "mask_least_six_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "store_values_in_memory_00000df4",
                "PTR_check_and_increment_if_not_equal_000012b4_1_00000e10": "check_ptr",
                "DAT_00000e0c": "data",
                "store_memory_values_000013b8": "store_memory_values"
            },
            "code": "void store_values_in_memory_00000df4(void)\n{\n    int starting_address = 0;\n    int ending_address = 0x1c200;\n    int* PTR_check_and_increment_if_not_equal_000012b4_1_00000e10 = PTR_check_and_increment_if_not_equal_000012b4_1_00000e10;\n    int DAT_00000e0c = DAT_00000e0c;\n    store_memory_values_000013b8(starting_address, ending_address, PTR_check_and_increment_if_not_equal_000012b4_1_00000e10, DAT_00000e0c);\n    return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "store_values_in_memory_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_relocation_information_00002eb4",
                "undefined4": "int"
            },
            "code": "int print_relocation_information_00002eb4() {\n    print_relocation_info_0000211c();\n    return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_relocation_information_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_input_and_calculate_score_0000328c",
                "param_1": "input_array",
                "param_2": "output_array",
                "local_10": "current_position",
                "local_a": "parsed_number"
            },
            "code": "int parse_input_and_calculate_score_0000328c(int *input_array, int *output_array)\n{\n  int current_position;\n  short parsed_number;\n  parsed_number = parseNumber(*input_array, &current_position, 10);\n  output_array[5] = parsed_number - 0x76c;\n  parsed_number = parseNumber(current_position + 1, &current_position, 10);\n  output_array[4] = parsed_number - 1;\n  parsed_number = parseNumber(current_position + 1, &current_position, 10);\n  output_array[3] = (int)parsed_number;\n  parsed_number = parseNumber(input_array[1], &current_position, 10);\n  output_array[2] = (int)parsed_number;\n  parsed_number = parseNumber(current_position + 1, &current_position, 10);\n  output_array[1] = (int)parsed_number;\n  parsed_number = parseNumber(current_position + 1, &current_position, 10);\n  *output_array = (int)parsed_number;\n  int score = calculate_score(output_array[5] + 0x76c, output_array[4] + 1, output_array[3]);\n  output_array[6] = score;\n  output_array[8] = -1;\n  return 0;\n}",
            "called": [
                "FUN_00004f84",
                "FUN_000031fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_000033f4",
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "parse_input_and_calculate_score_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data_array",
                "param_2": "value1",
                "param_3": "value2",
                "puVar1": "PTR_LAB_00004e4a_1_00004238"
            },
            "code": "void initialize_data_000041f4(undefined4 *data_array, undefined2 value1, undefined2 value2) {\n  data_array[0] = 0;\n  data_array[1] = 0;\n  data_array[2] = 0;\n  data_array[3] = value1;\n  data_array[4] = 0;\n  data_array[5] = 0;\n  data_array[6] = 0;\n  data_array[7] = 0;\n  data_array[8] = data_array;\n  data_array[9] = PTR_count_and_update_matching_integers_00004dc8_1_0000422c;\n  data_array[10] = DAT_00004230;\n  data_array[11] = PTR_set_param_and_update_flag_00004e26_1_00004234;\n  data_array[12] = PTR_LAB_00004e4a_1_00004238;\n  data_array[25] = 0;\n}",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_data_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "process_device_data_0000316c",
                "param_1": "device_id",
                "param_2": "device_data",
                "iVar1": "byte_comparison_result",
                "PTR_DAT_000031d4": "PTR_DEVICE_DATA",
                "PTR_s_write_000031d8": "PTR_S_WRITE",
                "PTR_s_usage___s_read_write_000031dc": "PTR_S_USAGE_S_READ_WRITE"
            },
            "code": "int process_device_data_0000316c(int device_id, uint32_t* device_data)\n{\n    if (device_id < 2) {\n        print_device_info();\n    }\n    else {\n        int byte_comparison_result = compare_bytes(device_data[1], PTR_DAT_000031d4);\n        if (byte_comparison_result == 0) {\n            process_device_data_0000316c(device_id, device_data);\n        }\n        else {\n            byte_comparison_result = compare_bytes(device_data[1], PTR_s_write_000031d8);\n            if (byte_comparison_result == 0) {\n                process_device_data_0000316c_write(device_id, device_data);\n            }\n            else {\n                process_data(PTR_s_usage___s_read_write_000031dc, *device_data);\n            }\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00004e52",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "process_device_data_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "execute_function_if_not_null_000026f0",
                "param_1": "function_pointer",
                "PTR_DAT_00002710": "function_pointer",
                "int": "int",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void execute_function_if_not_null_000026f0(int* PTR_DAT_00002710) {\n  if (*PTR_DAT_00002710 != 0) {\n    (**(void (**)())PTR_DAT_00002710)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_not_null_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_input_devices_000057d2",
                "param_1": "device_count",
                "param_2": "device_type",
                "param_3": "device_input",
                "param_4": "input_length",
                "iVar1": "result",
                "puVar2": "end_input"
            },
            "code": "int process_input_devices_000057d2(int device_count, int device_type, char *device_input, int input_length) {\n  int processed_count = 0;\n  char *current_input = device_input;\n  \n  while (processed_count < input_length) {\n    int result = process_device_input(device_count, *current_input, device_type, input_length, processed_count);\n    processed_count = result + 1;\n    current_input++;\n  }\n  \n  return result;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_input_devices_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_device_state_and_set_response_000056b8",
                "param_1": "device_id",
                "param_2": "device_status",
                "param_3": "response",
                "param_4": "flags",
                "iVar1": "status",
                "uVar2": "device_flags",
                "auStack_68": "device_stack",
                "local_64": "device_flags"
            },
            "code": "int check_device_state_and_set_response_000056b8(int device_id, int device_status, int* response, uint* flags){\n  int status;\n  uint device_flags;\n  undefined device_stack[4];\n  \n  if ((*(short *)(device_status + 0xe) < 0) ||\n     (status = set_device_status(device_id,(int)*(short *)(device_status + 0xe),device_stack), status < 0)) {\n    *flags = 0;\n    if ((int)((uint)*(ushort *)(device_status + 0xc) << 0x18) < 0) {\n      device_flags = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *flags = (uint)((device_flags & 0xf000) == 0x2000);\n  }\n  device_flags = 0x400;\nLAB_000056f8:\n  *response = device_flags;\n  return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_device_state_and_set_response_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_flag_and_clear_memory_00001a18",
                "DAT_00001a34": "DAT_flag_address",
                "PTR_DAT_00001a38": "PTR_data_address",
                "set_flag_at_calculated_address_000016ec": "set_flag_at_calculated_address",
                "clear_six_bytes_of_memory_at_address_calculated_in_function_00001734": "clear_six_bytes_of_memory_at_calculated_address"
            },
            "code": "void set_flag_and_clear_memory_00001a18(void)\n{\n  set_flag_at_calculated_address(DAT_00001a34, 1);\n  clear_six_bytes_of_memory_at_calculated_address();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_flag_and_clear_memory_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_memory_and_return_00000d9c",
                "DAT_00000dac": "memory",
                "clear_memory_and_return_00000d76": "clear_memory_and_return"
            },
            "code": "void clear_memory_and_return_00000d9c(void *DAT_00000dac, int value) {\n  clear_memory_and_return_00000d9c(DAT_00000dac, value);\n  return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "clear_memory_and_return_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "copy_and_fill_00003ff4",
                "param_1": "length",
                "param_2": "start",
                "param_3": "end",
                "param_4": "value",
                "uVar1": "result",
                "reverse_copy_000045ee": "reverse_copy",
                "fill_array_with_value_00004622": "fill_array_with_value"
            },
            "code": "uint copy_and_fill_00003ff4(uint length, uint start, uint end, undefined value) {\n  uint result = end;\n  if ((start < end) && (length != 0)) {\n    reverse_copy(length + start - end, start, end);\n    fill_array_with_value(length, value, end - start);\n  }\n  return result;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "copy_and_fill_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    divide_and_remainder_00005584(&local_20,*param_1,0x3c);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    divide_and_remainder_00005584(&local_20,param_1[1],0x3c);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    divide_and_remainder_00005584(&local_20,param_1[2],0x18);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    divide_and_remainder_00005584(&local_20,param_1[4],0xc);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAT_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "getMemoryAddress_00001d5e",
                "param_1": "address"
            },
            "code": "uint16_t getMemoryAddress_00001d5e(ushort address)\n{\n    uint16_t memoryAddress = address & 0x7000 | 0x40048000;\n    return memoryAddress;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001f80",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "getMemoryAddress_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "improved_function_0000191c",
                "*DAT_00001958": "data_ptr",
                "*PTR_DAT_0000195c": "ptr",
                "set_memory_bit_and_clear_two_bytes_00001778": "set_memory_bit_and_clear_two_bytes",
                "set_flag_00001748": "set_flag",
                "DAT_00001958[6]": "data_ptr + 6"
            },
            "code": "void improved_function_0000191c(void)\n{\n    set_memory_bit();\n    clear_two_bytes();\n}\n\nvoid set_flag(unsigned char flag)\n{\n    unsigned char *flag_*PTR_DAT_0000195c = (unsigned char *) 0x00001748;\n    *flag_*PTR_DAT_0000195c = flag;\n}\n\nvoid clear_bits(unsigned char **DAT_00001958)\n{\n    **DAT_00001958 = **DAT_00001958 & 0x3b;\n}\n\nvoid wait_for_condition(unsigned char **DAT_00001958, unsigned char mask)\n{\n    while ((**DAT_00001958 & mask) != 0) {}\n}\n\nvoid set_pointer_value(unsigned char **PTR_DAT_0000195c)\n{\n    **PTR_DAT_0000195c = 1;\n}\n\nvoid improved_function_0000191c(void)\n{\n    improved_function_0000191c();\n    set_flag(0x40);\n    clear_bits(DAT_00001958);\n    wait_for_condition(DAT_00001958 + 6, 0xc);\n    set_pointer_value(PTR_DAT_0000195c);\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "improved_function_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_pointer_to_data_000050f4",
                "PTR_DAT_000050fc": "pointer_to_data"
            },
            "code": "const char* get_pointer_to_data_000050f4() {\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "decode_data_00005a58",
                "param_1": "input",
                "param_2": "data",
                "param_3": "output",
                "param_4": "size",
                "param_5": "callback",
                "iVar1": "index",
                "uVar2": "result",
                "uVar3": "i",
                "uVar4": "min_size",
                "bVar5": "has_padding",
                "padding_size": "padding_size",
                "data_size": "data_size",
                "data_offset": "data_offset",
                "callback_result": "callback_result",
                "data_type": "data_type"
            },
            "code": "undefined4 decode_data_00005a58(undefined4 input, uint *data, uint *output, undefined4 size, code *callback)\\n\\\n{\\n\\\n    int index = 0;\\n\\\n    undefined4 result = 0;\\n\\\n    uint max_size = data[4];\\n\\\n    uint min_size = data[2];\\n\\\n    bool has_padding = (*(char *)((int)data + 0x43) != \"\\0\");\\n\\\n    uint padding_size = 0;\\n\\\n    uint data_size = 0;\\n\\\n    uint data_offset = 0;\\n\\\n    uint i = 0;\\n\\\n    uint callback_result = 0;\\n\\\n    uint data_type = *data & 6;\\n\\\n\\\n    if (max_size < min_size) {\\n\\\n        max_size = min_size;\\n\\\n    }\\n\\\n    *output = max_size;\\n\\\n    if (has_padding) {\\n\\\n        *output = max_size + 1;\\n\\\n        padding_size = 1;\\n\\\n    }\\n\\\n    if ((int)(*data << 0x1a) < 0) {\\n\\\n        *output = *output + 2;\\n\\\n        padding_size += 2;\\n\\\n    }\\n\\\n    if (data_type == 0) {\\n\\\n        for (i = 0; i < (data[3] - *output); i++) {\\n\\\n            callback_result = (*callback)(input, size, (int)data + 0x19, 1);\\n\\\n            if (callback_result == -1) {\\n\\\n                goto ERROR;\\n\\\n            }\\n\\\n        }\\n\\\n    }\\n\\\n    if (has_padding) {\\n\\\n        padding_size = 1;\\n\\\n    }\\n\\\n    if ((int)(*data << 0x1a) < 0) {\\n\\\n        *(undefined *)((int)data + padding_size + 0x43) = 0x30;\\n\\\n        *(undefined *)((int)data + padding_size + 0x44) = *(undefined *)((int)data + 0x45);\\n\\\n        padding_size += 2;\\n\\\n    }\\n\\\n    callback_result = (*callback)(input, size, (int)data + 0x43, padding_size);\\n\\\n    if (callback_result == -1) {\\n\\\n        goto ERROR;\\n\\\n    }\\n\\\n    data_size = data[3];\\n\\\n    bool is_type_4 = (data_type == 4);\\n\\\n    if (is_type_4) {\\n\\\n        data_size = data_size - *output;\\n\\\n    }\\n\\\n    if (is_type_4) {\\n\\\n        data_size = data_size & ~((int)data_size >> 0x1f);\\n\\\n    }\\n\\\n    else {\\n\\\n        data_size = 0;\\n\\\n    }\\n\\\n    if (max_size < min_size) {\\n\\\n        data_size = data_size + (min_size - max_size);\\n\\\n    }\\n\\\n    for (data_offset = 0; data_offset != data_size; data_offset++) {\\n\\\n        callback_result = (*callback)(input, size, (int)data + 0x1a, 1);\\n\\\n        if (callback_result == -1) {\\n\\\n            goto ERROR;\\n\\\n        }\\n\\\n    }\\n\\\n    result = 0;\\n\\\n    goto END;\\n\\\nERROR:\\n\\\n    result = 0xffffffff;\\n\\\nEND:\\n\\\n    return result;\\n\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "decode_data_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_data_000056b0",
                "DAT_000056b4": "data"
            },
            "code": "int get_data_000056b0(){\n  return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_data_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_nth_element_00003d24",
                "param_1": "n",
                "local_10": "element_count",
                "local_c": "current_element"
            },
            "code": "undefined4 * get_nth_element_00003d24(int n){\n                      undefined4 *current_element = *(undefined4 **)PTR_DAT_00003d60;\n                      int element_count = 0;\n                      while (element_count < n && current_element != (undefined4 *)0x0) {\n                        current_element = (undefined4 *)*current_element;\n                        element_count++;\n                      }\n                      return current_element;\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "get_nth_element_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_and_insert_node_000060cc",
                "param_1": "mem_block_size",
                "param_2": "node_pos",
                "param_3": "str_len",
                "param_4": "mem_block_data",
                "uVar1": "result",
                "uVar2": "calculated_result"
            },
            "code": "uint allocate_and_insert_node_000060cc(uint mem_block_size, uint node_pos, uint str_len, uint mem_block_data) {\n  uint result;\n  uint calculated_result;\n  if (node_pos != 0) {\n    if (str_len == 0) {\n      insert_node_at_position();\n      result = str_len;\n    }\n    else {\n      calculated_result = calculate_result();\n      result = node_pos;\n      if ((calculated_result < str_len) && (result = allocate_memory_block(mem_block_size, str_len), result != 0)) {\n        copy_string(result, node_pos, str_len);\n        insert_node_at_position(mem_block_data, node_pos);\n      }\n    }\n    return result;\n  }\n  result = allocate_memory_block(mem_block_size, str_len, str_len, mem_block_data);\n  return result;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_00006964",
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "allocate_and_insert_node_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "count_digits_00003dc4",
                "param_1": "num",
                "param_2": "limit",
                "local_20": "remainder",
                "local_14": "digits",
                "local_10": "factor",
                "local_c": "digit_count"
            },
            "code": "int count_digits_00003dc4(int num, uint limit) {\n  uint factor = 10;\n  int digit_count = 1;\n  if (DAT_00003e50 < limit) {\n    digit_count = 10;\n  }\n  else {\n    while (factor <= limit) {\n      factor *= 10;\n      digit_count++;\n    }\n  }\n  if (num != 0) {\n    char *digits = (char *)(digit_count + num);\n    uint remainder = limit;\n    do {\n      digits--;\n      *digits = (char)remainder + (char)((uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10) + '0';\n      remainder = (uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return digit_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "count_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_set_value_at_index_000022be",
                "param_1": "array",
                "param_2": "value",
                "uVar1": "index",
                "PTR_": "array",
                "DAT_": "value"
            },
            "code": "void increment_and_set_value_at_index_000022be(int *PTR_, undefined DAT_) {\n  uint index = PTR_[3];\n  PTR_[3] = index + 1;\n  uint offset = index & (PTR_[1] - 1U);\n  *(undefined *)((offset) + *(PTR_)) = DAT_;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_set_value_at_index_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "process_data_00002108",
                "DAT_00002118": "data_ptr",
                "extract_bits_and_call_function_if_flag_set_00002028": "extract_bits_and_call_function_if_flag_set"
            },
            "code": "void process_data_00002108(uint8_t *data, uint8_t num_bits);\n\nvoid process_data_00002108(void)\n{\n  uint8_t *DAT_00002118 = DAT_00002118;\n  process_data_00002108(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "process_data_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "calculateValue_00001d80",
                "param_1": "value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint calculateValue_00001d80(ushort value) {\n    uint mask = 0x1c0;\n    uint constant = 0x400ff000;\n    return (value & mask) | constant;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "calculateValue_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "is_unix_time_converted_to_datetime_successful_000033c0",
                "iVar1": "conversion_result",
                "auStack_2c": "datetime_array",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc__error_getting_alarm_000033f0",
                "process_data_00003378": "process_data_00003378",
                "FUNC_00004db8": "FUNC_00004db8"
            },
            "code": "bool is_unix_time_converted_to_datetime_successful_000033c0(void)\n{\n  int conversion_result;\n  undefined datetime_array[36];\n  \n  conversion_result = convert_unix_time_to_datetime_00002690(datetime_array);\n  if (conversion_result != 0)\n  {\n    FUNC_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else\n  {\n    process_data_00003378(datetime_array);\n  }\n  return conversion_result != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "is_unix_time_converted_to_datetime_successful_000033c0",
            "code_backup": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = convert_unix_time_to_datetime_00002690(auStack_2c);\n  if (iVar1 != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_data_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_command_line_arguments_00002b10",
                "param_1": "num_args",
                "param_2": "args",
                "local_48": "arg_list",
                "local_3c": "matching_function",
                "local_38": "current_arg_ptr",
                "local_34": "arg_count",
                "local_2d": "quote_type",
                "local_2c": "escape_char_ptr",
                "local_28": "char_ptr",
                "local_24": "arg_ptr",
                "local_20": "i",
                "local_1c": "escape_count",
                "local_18": "arg_length",
                "local_14": "current_char"
            },
            "code": "void parse_command_line_arguments_00002b10(uint32_t num_args, char **args){\\n    uint32_t arg_count = 0;\\n    uint32_t escape_count = 0;\\n    char *current_arg = args[0];\\n    while(*current_arg){\\n        if(*current_arg > 0x20){\\n            if((*current_arg == \"\\\"\") || (*current_arg == \"\\\"\")){\\n                char quote_type = *current_arg;\\n                do{\\n                    current_arg++;\\n                    if(*current_arg == 0){\\n                        print_command_descriptions_00002a88(args[1]);\\n                        return;\\n                    }\\n                    if(*current_arg == 0x5c){\\n                        escape_count++;\\n                        current_arg++;\\n                        if(*current_arg == 0){\\n                            print_command_descriptions_00002a88(args[1]);\\n                            return;\\n                        }\\n                    }\\n                }while(quote_type != *current_arg);\\n                if(*(current_arg + 1) > 0x20){\\n                    print_command_descriptions_00002a88(args[1]);\\n                    return;\\n                }\\n            }\\n            else{\\n                do{\\n                    if(*current_arg == 0x5c){\\n                        escape_count++;\\n                        current_arg++;\\n                        if(*current_arg == 0){\\n                            print_command_descriptions_00002a88(args[1]);\\n                            return;\\n                        }\\n                    }\\n                    current_arg++;\\n                    if(*current_arg == \"\\\"\"){\\n                        print_command_descriptions_00002a88(args[1]);\\n                        return;\\n                    }\\n                }while(*current_arg > 0x20);\\n            }\\n            arg_count++;\\n        }\\n        if(*current_arg == 0){\\n            break;\\n        }\\n        *current_arg = 0;\\n        current_arg++;\\n    }\\n    if(arg_count != 0){\\n        char **arg_list = (char **)((int)args - ((arg_count + 1) * 4 + 7 & 0xfffffff8));\\n        arg_list[arg_count] = (char *)0x0;\\n        current_arg = args[0];\\n        for(uint32_t i = 0; i < arg_count; i++){\\n            while(*current_arg == 0){\\n                current_arg++;\\n            }\\n            if((*current_arg == \"\\\"\") || (*current_arg == \"\\\"\")){\\n                current_arg++;\\n            }\\n            arg_list[i] = current_arg;\\n            while(*current_arg){\\n                current_arg++;\\n            }\\n        }\\n        for(char **arg = arg_list; (escape_count != 0 && (*arg != (char *)0x0)); arg++){\\n            for(char *c = *arg; *c != \"\\0\"; c++){\\n                if(*c == \"\\\"){\\n                    for(char *d = c; *d != \"\\0\"; d++){\\n                        *d = *(d + 1);\\n                    }\\n                    escape_count--;\\n                    if(escape_count == 0){\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        code *matching_function = (code *)find_matching_byte_sequence_00002a18(args[0], arg_list);\\n        if(matching_function == (code *)0x0){\\n            int32_t cmp_result = compare_bytes_00004e52(PTR_DAT_00002d8c, arg_list);\\n            if(cmp_result == 0){\\n                print_command_descriptions_00002a88(args[1]);\\n            }\\n            else{\\n                process_data_00004c84(PTR_s_shell__command_not_found___s_00002d90, arg_list);\\n            }\\n        }\\n        else{\\n            (*matching_function)(arg_count, arg_list);\\n        }\\n    }\\n    return;\\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002a88",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_command_line_arguments_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "execute_system_command_00001b10",
                "param_1": "command_index",
                "PTR_DAT_00001bb4": "COMMAND_LIST",
                "PTR_DAT_00001bb0": "COMMAND_LIST_START",
                "initialize_system_000018bc": "initialize_system",
                "improved_function_0000191c": "execute_improved_function",
                "initialize_system_00001960": "initialize_system_settings",
                "reverse_engineered_function_000019c0": "execute_reverse_engineered_function",
                "set_flag_and_clear_memory_00001a18": "set_flag_and_clear_memory",
                "set_flag_and_clear_memory_00001a3c": "set_flag_and_clear_memory2",
                "clear_memory_and_set_flag_00001a60": "clear_memory_and_set_flag",
                "clear_bitmask_and_wait_until_set_00001ad4": "clear_bitmask_and_wait_until_set"
            },
            "code": "uint32_t execute_system_command_00001b10(uint8_t command_index) {\n  uint32_t result = 0;\n  if (command_index < COMMAND_COUNT) {\n    do {\n      uint8_t command = PTR_DAT_00001bb4[(uint32_t)command_index + (uint32_t)(*PTR_DAT_00001bb0) * COMMAND_SIZE];\n      switch (command) {\n      case 0:\n        initialize_system();\n        break;\n      case 1:\n        execute_improved_function();\n        break;\n      case 2:\n        initialize_system_settings();\n        break;\n      case 3:\n        execute_reverse_engineered_function();\n        break;\n      case 4:\n        set_flag_and_clear_memory();\n        break;\n      case 5:\n        set_flag_and_clear_memory2();\n        break;\n      case 6:\n        clear_memory_and_set_flag();\n        break;\n      case 7:\n        clear_bitmask_and_wait_until_set();\n        break;\n      default:\n        return 0xffffffff;\n      }\n    } while (command_index != *PTR_DAT_00001bb0);\n  }\n  else {\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001960",
                "FUN_00001ad4",
                "FUN_00001a3c",
                "FUN_0000191c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "execute_system_command_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUNC_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 = (int *)get_data_000056b0();\n  FUNC_00004634(param_1);\n  uVar12 = param_1[5];\n  iVar11 = param_1[3] + -1 + *(int *)(PTR_DAT_00004adc + param_1[4] * 4);\n  if (((1 < param_1[4]) && ((uVar12 & 3) == 0)) &&\n     ((uVar12 != (uVar12 / 100) * 100 || (uVar12 + 0x76c == ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 = iVar11 + 1;\n  }\n  param_1[7] = iVar11;\n  if (20000 < (int)&PTR_DAT_00002710 + uVar12) {\n    iVar7 = -1;\n    iVar5 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 < 0x47) {\n    if (uVar12 != 0x46) {\n      for (uVar9 = 0x45; (int)uVar12 < (int)uVar9; uVar9 = uVar9 - 1) {\n        if ((uVar9 & 3) == 0) {\n          if (uVar9 == (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 == 0) {\n              iVar7 = 0x16e;\n            }\n            else {\n              iVar7 = 0x16d;\n            }\n          }\n          else {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16d;\n        }\n        iVar11 = iVar11 - iVar7;\n      }\n      if ((uVar9 & 3) == 0) {\n        if (uVar12 == (uVar12 / 100) * 100) {\n          iVar7 = 0x16d;\n          if ((uVar12 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      iVar11 = iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 = 0x46;\n    do {\n      if ((uVar9 & 3) == 0) {\n        if (uVar9 % 100 == 0) {\n          if ((uVar9 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n          else {\n            iVar7 = 0x16d;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      uVar9 = uVar9 + 1;\n      iVar11 = iVar11 + iVar7;\n    } while (uVar12 != uVar9);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar11 +\n          (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1);\n  uVar15 = (uint)lVar1;\n  iVar7 = (int)((ulonglong)lVar1 >> 0x20);\n  get_pointer_to_data_000050e8();\n  FUNC_00005100();\n  uVar9 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    uVar12 = piVar3[10];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 = param_1[8];\n    uVar13 = uVar14;\n    if (0 < (int)uVar14) {\n      uVar13 = 1;\n    }\n    if ((piVar3[1] == param_1[5] + 0x76c) || (iVar5 = calculate_day_of_week_00004f98(), iVar5 != 0)) {\n      uVar10 = piVar3[0x14];\n      uVar4 = piVar3[0x12];\n      uVar8 = piVar3[10];\n      uVar9 = uVar4 - uVar8;\n      iVar5 = (piVar3[0x13] - ((int)uVar8 >> 0x1f)) - (uint)(uVar4 < uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n           (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9)))) &&\n         (iVar6 = (piVar3[0x13] - ((int)uVar10 >> 0x1f)) - (uint)(uVar4 < uVar10),\n         bVar16 = uVar15 < uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 = piVar3[8] - uVar10;\n      iVar6 = (piVar3[9] - ((int)uVar10 >> 0x1f)) - (uint)((uint)piVar3[8] < uVar10);\n      if (*piVar3 != 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 ==\n            (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 = 0;\n        if ((int)uVar14 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 = uVar13 ^ uVar9;\n        uVar13 = uVar9;\n        if (uVar15 == 1) {\n          if (uVar9 == 0) {\n            iVar7 = uVar10 - uVar8;\n          }\n          else {\n            iVar7 = uVar8 - uVar10;\n          }\n          iVar5 = param_1[3];\n          *param_1 = *param_1 + iVar7;\n          lVar2 = lVar1 + iVar7;\n          FUNC_00004634(param_1);\n          iVar5 = param_1[3] - iVar5;\n          lVar1 = lVar1 + iVar7;\n          if (iVar5 != 0) {\n            if (iVar5 < 2) {\n              if (iVar5 == -2 || iVar5 + 2 < 0 != SCARRY4(iVar5,2)) {\n                iVar5 = 1;\n              }\n            }\n            else {\n              iVar5 = -1;\n            }\n            iVar7 = iVar5 + param_1[7];\n            iVar11 = iVar11 + iVar5;\n            if (iVar7 < 0) {\n              uVar9 = uVar12 - 1;\n              if ((uVar9 & 3) == 0) {\n                if (uVar9 == (uVar9 / 100) * 100) {\n                  iVar7 = 0x16d;\n                  if ((uVar12 + 0x76b) % 400 != 0) {\n                    iVar7 = 0x16c;\n                  }\n                }\n                else {\n                  iVar7 = 0x16d;\n                }\n              }\n              else {\n                iVar7 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 & 3) == 0) {\n                if (uVar12 == (uVar12 / 100) * 100) {\n                  iVar5 = 0x16d;\n                  if ((uVar12 + 0x76c) % 400 == 0) {\n                    iVar5 = 0x16e;\n                  }\n                }\n                else {\n                  iVar5 = 0x16e;\n                }\n              }\n              else {\n                iVar5 = 0x16d;\n              }\n              if (iVar5 <= iVar7) {\n                iVar7 = iVar7 - iVar5;\n              }\n            }\n            param_1[7] = iVar7;\n            lVar1 = lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 !=\n          (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n            (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar14) {\n        uVar9 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 = uVar13;\n      if (uVar13 != 1) goto LAB_00004934;\n    }\n    uVar12 = piVar3[0x14];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 = 1;\n  }\n  get_pointer_to_data_000050f4();\n  param_1[8] = uVar9;\n  param_1[6] = (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
            "called": [
                "FUN_00004634",
                "FUN_000050e8",
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_000050f4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "trigger_system_interrupt_000023c8"
            },
            "code": "void trigger_system_interrupt_000023c8(void)\n{\n  software_interrupt(0x3f);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "trigger_system_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "process_data_and_return_00002e48",
                "0x3e": "first_value",
                "0x20": "second_value",
                "process_data_000041d0": "process_data",
                "*DAT_00002e68": "ptr_to_data"
            },
            "code": "void process_data_and_return_00002e48(void)\n{\n    int first_value = 0x3e;\n    int second_value = 0x20;\n    int* *DAT_00002e68 = *(int**)(DAT_00002e68 + 8);\n    process_data_wrapper_00002a00(first_value);\n    process_data_wrapper_00002a00(second_value);\n    process_data_000041d0(**DAT_00002e68);\n    return;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_000041d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_data_and_return_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "execute_interrupt_and_wait_00000930",
                "is_irq_interrupts_enabled_00000cf0": "is_irq_interrupts_enabled",
                "DAT_00000cf0": "are_interrupts_enabled"
            },
            "code": "void execute_interrupt_and_wait_00000930(void)\n{\n  bool DAT_00000cf0 = is_irq_interrupts_enabled();\n  software_interrupt(1);\n  while(DAT_00000cf0);\n}",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "execute_interrupt_and_wait_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_and_set_flag_if_not_zero_00001348",
                "PTR_DAT_0000135c": "ptr",
                "set_flag_for_dat_954_0000093c": "set_flag"
            },
            "code": "void check_and_set_flag_if_not_zero_00001348(void)\n{\n  int* PTR_DAT_0000135c = (int*)PTR_DAT_0000135c;\n  if (*PTR_DAT_0000135c != 0)\n  {\n    set_flag_for_dat_954_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_if_not_zero_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_memory_value_to_one_00001d3a",
                "param_1": "memory_address",
                "param_2": "offset",
                "puVar1": "address",
                "*puVar1": "value_at_address"
            },
            "code": "void set_memory_value_to_one_00001d3a(void* memory_address, int offset){\n    void* address = calculate_memory_address(memory_address, offset);\n    int* value_at_address = (int*)address;\n    *value_at_address = 1;\n    return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_memory_value_to_one_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "set_or_get_node_value_00002434",
                "param_1": "node_value",
                "param_2": "set_value",
                "uVar1": "irq_enabled_state",
                "iVar2": "node_ptr"
            },
            "code": "int set_or_get_node_value_00002434(int *node_value, int set_value) {\n  int irq_enabled_state = getIRQInterruptsEnabledState();\n  if (*node_value == 0) {\n    *node_value = -1;\n    enable_interrupts_if_privileged(irq_enabled_state);\n    return 1;\n  }\n  else if (set_value == 0) {\n    enable_interrupts_if_privileged(irq_enabled_state);\n    return 0;\n  }\n  else {\n    int node_ptr = *(int *)PTR_DAT_000024b8;\n    update_node(node_ptr, 2);\n    if (*node_value == -1) {\n      *node_value = node_ptr + 8;\n      *(int *)(*node_value) = 0;\n    }\n    else {\n      find_and_set_next_item(node_value, node_ptr);\n    }\n    enable_interrupts_if_privileged(irq_enabled_state);\n    set_flag_for_dat_954();\n    return 1;\n  }\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00001034",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "set_or_get_node_value_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "initialize_device_00005700",
                "param_1": "device_id",
                "param_2": "device_info",
                "local_18": "device_size",
                "local_14": "local_device_info",
                "uVar1": "device_state",
                "iVar2": "allocated_memory_block"
            },
            "code": "void initialize_device_00005700(int device_id, int *device_info)\n{\n    ushort device_state;\n    int allocated_memory_block;\n    int device_size;\n    int *local_device_info;\n\n    if ((int)((uint)*(ushort *)(device_info + 3) << 0x1e) >= 0)\n    {\n        local_device_info = device_info;\n        device_state = check_device_state_and_set_response(device_id, device_info, &device_size, &local_device_info);\n        allocated_memory_block = allocate_memory_block(device_id, device_size);\n        if (allocated_memory_block != 0)\n        {\n            *(undefined **)(device_id + 0x28) = PTR_DAT_0000577c;\n            *device_info = allocated_memory_block;\n            *(ushort *)(device_info + 3) = *(ushort *)(device_info + 3) | 0x80;\n            device_info[5] = device_size;\n            device_info[4] = allocated_memory_block;\n            if ((local_device_info != (int *)0x0) && (is_valid_input(device_id, (int)*(short *)((int)device_info + 0xe)) != 0))\n            {\n                *(ushort *)(device_info + 3) = *(ushort *)(device_info + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(device_info + 3) = device_state | *(ushort *)(device_info + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(device_info + 3) << 0x16 >= 0)\n        {\n            *(ushort *)(device_info + 3) = *(ushort *)(device_info + 3) & 0xfffc | 2;\n        }\n        return;\n    }\n    *device_info = (int)device_info + 0x47;\n    device_info[4] = (int)device_info + 0x47;\n    device_info[5] = 1;\n    return;\n}",
            "called": [
                "FUN_00000534",
                "FUN_00004bd0",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "initialize_device_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_data_flag_00002798",
                "PTR_DAT_000027ac": "data_ptr",
                "set_flag_for_dat_954_0000093c": "set_data_flag"
            },
            "code": "void check_data_flag_00002798(void)\n{\n    int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n    if (*PTR_DAT_000027ac != 0)\n    {\n        set_flag_for_dat_954_0000093c();\n    }\n    return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "check_data_flag_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "param_1": "num_params",
                "param_2": "command_data",
                "iVar1": "command_index",
                "uVar2": "success",
                "initialize_rtc_commands_000034c0": "initialize_rtc_commands",
                "compare_byte_arrays_00004e66": "compare_command_to_known_commands",
                "PTR_s_poweron_00003638": "POWER_ON",
                "PTR_s_poweroff_0000363c": "POWER_OFF",
                "PTR_s_clearalarm_00003640": "CLEAR_ALARM",
                "PTR_s_getalarm_00003644": "GET_ALARM",
                "PTR_s_setalarm_00003648": "SET_ALARM",
                "calculate_score_and_execute_000033f4": "calculate_score_and_execute",
                "PTR_s_gettime_0000364c": "GET_TIME",
                "is_unix_time_converted_to_datetime_and_returned_zero_00003444": "is_unix_time_converted_to_datetime_and_returned_zero",
                "PTR_s_settime_00003650": "SET_TIME",
                "process_data_00004c84": "process_data",
                "PTR_s_unknown_command_or_missing_param_00003654": "PTR_s_unknown_command_or_missing_param",
                "initialize_data_000026c0": "initialize_data",
                "is_unix_time_converted_to_datetime_successful_000033c0": "is_unix_time_converted_to_datetime_successful",
                "calculate_score_and_parse_input_00003478": "calculate_score_and_parse_input",
                "enable_interrupts_000026d8": "enable_interrupts",
                "clearBitInUnsignedIntAtOffsetFromData_000026e4": "clear_bit_in_unsigned_int_at_offset_from_data"
            },
            "code": "int process_rtc_command_00003524(int num_params, int command_data) {\n  int command_index;\n  int success = 0;\n  if (num_params < 2) {\n    initialize_rtc_commands();\n    success = 1;\n  }\n  else {\n    command_index = compare_command_to_known_commands(command_data);\n    if (command_index == PTR_s_poweron_00003638) {\n      enable_interrupts();\n    }\n    else if (command_index == PTR_s_poweroff_0000363c) {\n      clear_bit_in_unsigned_int_at_offset_from_data();\n    }\n    else if (command_index == PTR_s_clearalarm_00003640) {\n      initialize_data();\n    }\n    else if (command_index == PTR_s_getalarm_00003644) {\n      is_unix_time_converted_to_datetime_successful();\n    }\n    else if (command_index == PTR_s_setalarm_00003648 && num_params == 4) {\n      calculate_score_and_execute(command_data + 8);\n    }\n    else if (command_index == PTR_s_gettime_0000364c) {\n      is_unix_time_converted_to_datetime_and_returned_zero();\n    }\n    else if (command_index == PTR_s_settime_00003650 && num_params == 4) {\n      calculate_score_and_parse_input(command_data + 8);\n    }\n    else {\n      process_data(PTR_s_unknown_command_or_missing_param_00003654, command_data);\n      initialize_rtc_commands();\n      success = 1;\n    }\n  }\n  return success;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000026c0",
                "FUN_00003478",
                "FUN_000033f4",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00004e66",
                "FUN_000034c0",
                "FUN_000033c0",
                "FUN_000026e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "clear_memory_if_flag_set_or_set_flag_and_clear_memory_00001bb8",
                "DAT_00001c74": "memory_array",
                "DAT_00001c78": "memory_array[2]",
                "DAT_00001c7c": "memory_array[3]",
                "PTR_DAT_00001c80": "memory_address"
            },
            "code": "void clear_memory_if_flag_set_or_set_flag_and_clear_memory_00001bb8(){\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_memory_at_address(DAT_00001c78,1);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((DAT_00001c74[0] & 0xc0) == 0) {\n      DAT_00001c74[0] = DAT_00001c74[0] & 0x3f | 0x80;\n      do {\n      } while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_memory_at_address(DAT_00001c7c,6);\n    do {\n    } while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  set_flag(0);\n  DAT_00001c74[0] = DAT_00001c74[0] & 0x3b | 4;\n  do {\n  } while ((DAT_00001c74[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_DAT_00001c80 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_memory_if_flag_set_or_set_flag_and_clear_memory_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "do_nothing_with_dat_0000428c",
                "DAT_00004294": "DAT_dat"
            },
            "code": "void do_nothing_with_dat_0000428c(void)\n{\n  do_nothing_with_dat_0000428c(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_with_dat_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "total_bytes_processed",
                "piVar2": "node_to_insert",
                "uVar3": "num_bytes_to_process",
                "uVar4": "original_value",
                "iVar5": "bytes_left",
                "pcVar6": "data_processing_function",
                "iVar7": "bytes_processed",
                "uVar8": "original_data_value",
                "bVar9": "block_size_is_zero"
            },
            "code": "int process_data_0000404c(uint *data, int *params)\n{\n  int total_bytes_processed = 0;\n  int *current_position = params;\n  uint num_bytes_to_process = (uint)*(ushort *)(current_position + 3);\n  if ((int)(num_bytes_to_process << 0x1c) < 0) {\n    int bytes_processed;\n    int bytes_left = *(current_position + 0) - *(current_position + 4);\n    int block_size = *(current_position + 5);\n    bool block_size_is_zero = (num_bytes_to_process << 0x1e) == 0;\n    if (!block_size_is_zero) {\n      block_size = 0;\n    }\n    *(current_position) = *(current_position + 4);\n    *(current_position + 2) = block_size;\n    while (bytes_left > 0) {\n      bytes_processed = (*(code *)*(current_position + 10))(data, *(current_position + 8), *(current_position + 4), bytes_left);\n      if (bytes_processed < 1) {\n        *(ushort *)(current_position + 3) = *(ushort *)(current_position + 3) | 0x40;\n        return -1;\n      }\n      total_bytes_processed += bytes_processed;\n      bytes_left -= bytes_processed;\n    }\n  }\n  else {\n    code *data_processing_function = (code *)*(current_position + 0xb);\n    if (data_processing_function == (code *)0x0) {\n      return 0;\n    }\n    uint original_data_value = *data;\n    *data = 0;\n    if ((num_bytes_to_process & 0x1000) == 0) {\n      int bytes_processed = (*data_processing_function)(data, *(current_position + 8), num_bytes_to_process & 0x1000, 1);\n      if ((bytes_processed == -1) && (*data != 0)) {\n        if ((*data == 0x1d) || (*data == 0x16)) {\n          *data = original_data_value;\n          return 0;\n        }\n        *(ushort *)(current_position + 3) = *(ushort *)(current_position + 3) | 0x40;\n        return bytes_processed;\n      }\n    }\n    else {\n      int bytes_processed = *(current_position + 0x15);\n    }\n    if (((int)((uint)*(ushort *)(current_position + 3) << 0x1d) < 0) && (*(current_position + 0xd) != 0)) {\n      int bytes_processed = bytes_processed - *(current_position + 1);\n      if (*(current_position + 0xd) != 0x0) {\n        bytes_processed = bytes_processed - *(current_position + 0x10);\n      }\n    }\n    int bytes_processed = (*(code *)*(current_position + 0xb))(data, *(current_position + 8), bytes_processed, 0);\n    if ((bytes_processed == -1) && ((0x1d < *data || (-1 < (int)((DAT_00004154 >> (*data & 0xff)) << 0x1f)))) {\n      *(ushort *)(current_position + 3) = *(ushort *)(current_position + 3) | 0x40;\n      return bytes_processed;\n    }\n    *(current_position + 1) = 0;\n    *(current_position) = *(current_position + 4);\n    if (((int)((uint)num_bytes_to_process << 0x13) < 0) && ((bytes_processed != -1 || (*data == 0)))) {\n      *(current_position + 0x15) = bytes_processed;\n    }\n    int *node_to_insert = (int *)*(current_position + 0xd);\n    *data = original_data_value;\n    if (node_to_insert != (int *)0x0) {\n      if (node_to_insert != current_position + 0x11) {\n        insert_node_at_position_00004b34(data);\n      }\n      *(current_position + 0xd) = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_device_info_00002f74",
                "local_14": "current_device_ptr",
                "local_18": "device_count",
                "uVar1": "device_info_ptr",
                "PTR_DAT_00002fd0": "current_device_data_ptr",
                "PTR_s_No_devices_found_00002fd8": "no_devices_error_message",
                "PTR_s_ID_Class_Name_00002fd4": "device_id_class_name_message",
                "getClassFromChar_000039e8": "get_device_info_from_char",
                "PTR_s___i__s__s_00002fdc": "device_details_message"
            },
            "code": "void print_device_info_00002f74(void)\n{\n  undefined4 device_info_ptr;\n  int device_count = 0;\n  undefined4 *current_device_ptr;\n  \n  current_device_ptr = *(undefined4 **)PTR_DAT_00002fd0;\n  if (current_device_ptr == (undefined4 *)0x0) {\n    print_error_message(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    print_message(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; current_device_ptr != (undefined4 *)0x0; current_device_ptr = (undefined4 *)*current_device_ptr) {\n    device_info_ptr = getClassFromChar_000039e8(*(undefined *)(current_device_ptr[3] + 8));\n    print_device_details(PTR_s___i__s__s_00002fdc,device_count,device_info_ptr,current_device_ptr[2]);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_device_info_00002f74",
            "code_backup": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 = *(undefined4 **)PTR_DAT_00002fd0;\n  local_18 = 0;\n  if (local_14 == (undefined4 *)0x0) {\n    FUNC_00004db8(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    FUNC_00004db8(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; local_14 != (undefined4 *)0x0; local_14 = (undefined4 *)*local_14) {\n    uVar1 = getClassFromChar_000039e8(*(undefined *)(local_14[3] + 8));\n    FUNC_00004c84(PTR_s___i__s__s_00002fdc,local_18,uVar1,local_14[2]);\n    local_18 = local_18 + 1;\n  }\n  return;\n}\n\n"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculate_distance_to_start_000010a0",
                "param_1": "start_address",
                "local_c": "current_address"
            },
            "code": "int calculate_distance_to_start_000010a0(int *start_address)\n{\n  int *current_address;\n  for (current_address = start_address; (int *)*current_address == current_address; current_address++) {\n  }\n  return (int)current_address - (int)start_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "calculate_distance_to_start_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "find_matching_integer_count_000012e2",
                "param_1": "array",
                "param_2": "size",
                "param_3": "target",
                "iVar1": "count"
            },
            "code": "int find_matching_integer_count_000012e2(int *array, int size, int target) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (array[i] == target) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint find_matching_integer_count_000012e2(int *array, int size, int target) {\n    int count = 0;\n    while (find_matching_integer_count_000012e2(array, size, target) == 0) {\n        *array = 1;\n    }\n    return count;\n}",
            "called": [
                "FUN_0000129c",
                "FUN_0000231c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "find_matching_integer_count_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_key_index_000056a0",
                "param_1": "key",
                "param_2": "array",
                "param_3": "index",
                "param_4": "array_size",
                "uStack_c": "index_ptr",
                "uStack_8": "array_size_ptr"
            },
            "code": "void find_key_index_000056a0(int key, int* array, int* index, int array_size) {\n  *index = -1;\n  for (int i = 0; i < array_size; i++) {\n    if (array[i] == key) {\n      *index = i;\n      return;\n    }\n  }\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_key_index_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "count_matching_integers_0000231c",
                "param_1": "value",
                "param_2": "array",
                "param_3": "array_size",
                "uVar1": "incremented_value",
                "local_20": "current_element",
                "local_14": "count",
                "is_int_equal_to_pointer_00002270": "is_int_equal_to_pointer",
                "increment_and_return_value_at_index_000022f0": "increment_and_return_value_at_index"
            },
            "code": "int count_matching_integers_0000231c(int value, int *array, int array_size) {\n  int count = 0;\n  int *current_element = array;\n  while (array_size != 0 && !is_int_equal_to_pointer(value, *current_element)) {\n    int incremented_value = increment_and_return_value_at_index(value);\n    *current_element = incremented_value;\n    array_size--;\n    current_element++;\n    count++;\n  }\n  return count;\n}",
            "called": [
                "FUN_000022f0",
                "FUN_00002270"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "count_matching_integers_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = PTR_LAB_00006118_1_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar6 = (uint)*param_3;\n      if (uVar6 == 0) {\n        return local_1a0;\n      }\n      uVar4 = (byte)puVar1[uVar6] & 8;\n      pbVar5 = param_3 + 1;\n      if ((puVar1[uVar6] & 8) == 0) break;\n      while (((param_3 = pbVar5, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar6 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar6) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar5;\n  }\n  local_1a4 = uVar4;\n  local_1ac = uVar4;\n  if (param_3[1] == 0x2a) {\n    pbVar5 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar4 = (uint)*pbVar5;\n    if (9 < uVar4 - 0x30) break;\n    pbVar5 = pbVar5 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar4) - 0x30;\n  }\n  iVar3 = find_byte_00006010(PTR_DAT_000064b4,uVar4,3);\n  if (iVar3 != 0) {\n    local_1ac = 1 << (iVar3 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar5 = pbVar5 + 1;\n  }\n  param_3 = pbVar5 + 1;\n  uVar4 = (uint)*pbVar5;\n  if (uVar4 < 0x79) {\n    if (0x57 < uVar4) {\n      switch(uVar4) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)process_string_0000687c(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar4 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar5 = param_2[1];\n          param_2[1] = pbVar5 + -1;\n          if ((int)(pbVar5 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = process_data_000064bc(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = FUNC_0000656c(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar5 = param_3;\n    if (uVar4 == 0x25) goto LAB_00006352;\n    if (uVar4 < 0x26) {\n      if (uVar4 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar4 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_000064bc",
                "FUN_0000687c",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_00006192"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_unix_time_to_datetime_00002690",
                "param_1": "unix_time",
                "local_10": "datetime",
                "uStack_c": "zero",
                "FUNC_000028f0": "get_current_time",
                "convert_unix_time_to_datetime_0000443c": "convert_unix_time_to_datetime_helper"
            },
            "code": "undefined4 convert_unix_time_to_datetime_00002690(undefined4 unix_time)\n{\n  undefined4 datetime;\n  undefined4 zero = 0;\n\n  datetime = get_current_time();\n  convert_unix_time_to_datetime_00002690_0000443c(&datetime, unix_time);\n\n  return zero;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "convert_unix_time_to_datetime_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_00006010",
                "param_1": "data",
                "param_2": "byte_to_find",
                "param_3": "length",
                "bVar1": "current_byte_value",
                "cVar2": "bit_0",
                "cVar3": "bit_8",
                "cVar4": "bit_16",
                "cVar5": "bit_24",
                "pbVar6": "next_byte",
                "puVar7": "current_uint",
                "pbVar8": "result",
                "uVar9": "offset",
                "uVar10": "remaining_length_rounded",
                "uVar11": "xor_result_1",
                "uVar12": "xor_result_2",
                "bVar13": "bit_0_xor_result_2",
                "bVar14": "bit_8_xor_result_2",
                "bVar15": "bit_16_xor_result_2",
                "bVar16": "bit_24_xor_result_2"
            },
            "code": "byte* find_byte_00006010(uint* data, uint byte_to_find, uint length) {\n  byte* result = NULL;\n  byte* current_byte = (byte*)data;\n  uint remaining_length = length;\n  while (remaining_length > 0) {\n    if (*current_byte == byte_to_find) {\n      result = current_byte;\n      break;\n    }\n    current_byte++;\n    remaining_length--;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_00005b34",
                "FUN_000057f8",
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "imported": false,
            "current_name": "find_byte_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_dat_flag_00001cf0",
                "PTR_DAT_00001d04": "flag_ptr",
                "set_flag_for_dat_954_0000093c": "set_dat_flag_954_0000093c"
            },
            "code": "void check_dat_flag_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0)\n  {\n    set_dat_flag_954_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "check_dat_flag_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "count_digits_and_relocate_00003ec4",
                "param_1": "output_string",
                "param_2": "input_number",
                "param_3": "relocation_amount",
                "iVar1": "digit_count",
                "uVar2": "remainder_digits",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "output_length"
            },
            "code": "int count_digits_and_relocate_00003ec4(undefined *output_string, uint input_number, int relocation_amount) {\n  int digit_count;\n  int output_length = 0;\n  if (relocation_amount + 7 < 0 != SCARRY4(relocation_amount, 7)) {\n    process_data_and_print_relocation_info_00000f04(3, PTR_s_FAILED_ASSERTION__00003fec);\n  }\n  if (relocation_amount == 0) {\n    digit_count = count_digits_00003e58(output_string, input_number);\n    output_length = digit_count;\n  }\n  else if (relocation_amount < 1) {\n    uint divisor = *(uint *)(PTR_DAT_00003ff0 + relocation_amount * -4);\n    uint quotient = input_number / divisor;\n    uint remainder = input_number - divisor * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && ((int)input_number < 0)) {\n      if (output_string != (undefined *)0x0) {\n        *output_string = 0x2d;\n      }\n      output_length = 1;\n    }\n    if (output_string == (undefined *)0x0) {\n      digit_count = count_digits_00003e58(0, quotient);\n      output_length = digit_count + 1 + output_length;\n    }\n    else {\n      digit_count = count_digits_00003e58(output_string + output_length, quotient);\n      digit_count = output_length + digit_count;\n      output_length = digit_count + 1;\n      output_string[digit_count] = 0x2e;\n      uint remainder_digits = count_digits_00003e58(output_string + output_length, remainder);\n      copy_and_fill_00003ff4(output_string + output_length, remainder_digits, -relocation_amount, 0x30);\n    }\n    output_length = -relocation_amount + output_length;\n  }\n  else {\n    digit_count = count_digits_00003e58(output_string, input_number);\n    if (output_string != (undefined *)0x0) {\n      fill_array_with_value_00004622(output_string + digit_count, 0x30, relocation_amount);\n    }\n    output_length = relocation_amount + digit_count;\n  }\n  return output_length;\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00003e58",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "count_digits_and_relocate_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_00001360",
                "param_1": "address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_address_00001360(uint32_t address, int offset) {\n    uint32_t upper_bits = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int result = offset * 4 + upper_bits + shifted_lower_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_address_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_array_with_value_00004622",
                "param_1": "array",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "end_of_array",
                "*puVar1": "*end_of_array",
                "*param_1": "*array"
            },
            "code": "void fill_array_with_value_00004622(void *array, int value, int size) {\n  void *end_of_array;\n  end_of_array = array + size;\n  for (; array != end_of_array; array = array + 1) {\n    *array = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00003ec4",
                "FUN_0000305c",
                "FUN_00004248",
                "FUN_000041f4",
                "FUN_00003ff4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "fill_array_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_for_dat_954_0000093c",
                "DAT_00000954": "dat_954",
                "ptr_dat_954_plus_4": "ptr_dat_954_plus_4"
            },
            "code": "void set_flag_for_dat_954_0000093c(void)\n{\n    uint32_t* ptr_DAT_00000954_plus_4 = (uint32_t*)(DAT_00000954 + 4);\n    *ptr_DAT_00000954_plus_4 |= 0x10000000;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00001cf0",
                "FUN_00002434",
                "FUN_00001348",
                "FUN_00000738",
                "FUN_00002798"
            ],
            "imported": false,
            "current_name": "set_flag_for_dat_954_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "ptr_data_buffer",
                "DAT_00003684": "data_mask"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* ptr_data = (uint*)(DAT_00003680 + 0xc);\n    *ptr_data = DAT_00003684 | (*ptr_data & 0x700);\n    DataSynchronizationBarrier(0xf);\n    while(true)\n    {\n        // Do nothing, infinite loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "reverse_engineered_function_000019c0",
                "DAT_00001a0c": "address_to_clear",
                "DAT_00001a10": "address_to_set_bit",
                "PTR_DAT_00001a14": "pointer_to_set_value"
            },
            "code": "void reverse_engineered_function_000019c0(void)\n{\n  set_memory_bit_and_clear_two_bytes();\n}\n\nvoid set_flag(unsigned char flag)\n{\n  set_flag(flag);\n}\n\nvoid clear_memory_at_address(unsigned char *address, unsigned int size)\n{\n  clear_memory_at_calculated_address(address, size);\n}\n\nvoid set_bit_in_memory(unsigned char *address, unsigned char bit)\n{\n  *address = *address & 0x3b | bit;\n}\n\nvoid wait_until_bit_in_memory_is_set(unsigned char *address, unsigned char bit)\n{\n  while ((*address & bit) != bit);\n}\n\nvoid clear_six_bytes_of_memory_at_address(unsigned char *address)\n{\n  clear_six_bytes_of_memory_at_address_calculated_in_function(address);\n}\n\nvoid set_pointer_to_value(unsigned char *pointer, unsigned char value)\n{\n  *pointer = value;\n}\n\nvoid reverse_engineered_function_000019c0(void)\n{\n  reverse_engineered_function_000019c0();\n  set_flag(0x40);\n  clear_memory_at_address(DAT_00001a0c, 1);\n  set_bit_in_memory(DAT_00001a10, 0x80);\n  wait_until_bit_in_memory_is_set(DAT_00001a10 + 6, 0xc);\n  clear_six_bytes_of_memory_at_address(DAT_00001734);\n  set_pointer_to_value(PTR_DAT_00001a14, 3);\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "reverse_engineered_function_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_string_000060b0",
                "param_1": "dest_offset",
                "param_2": "dest",
                "param_3": "length",
                "puVar1": "next_src",
                "puVar2": "src_end",
                "puVar3": "dest_end",
                "*puVar3": "*dest_end",
                "*param_2": "*src"
            },
            "code": "void copy_string_000060b0(int dest_offset, char *dest, char *src, int length) {\n  char *src_end = src + length;\n  char *dest_end = (char *)(dest_offset + -1);\n  if (src != src_end) {\n    do {\n      char *next_src = src + 1;\n      dest_end = dest_end + 1;\n      *dest_end = *src;\n      src = next_src;\n    } while (next_src != src_end);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_string_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "check_interrupt_status_and_trigger_000023d0",
                "param_1": "interrupt_number",
                "uVar1": "result",
                "PTR_DAT_000023fc": "interrupt_status_ptr",
                "trigger_system_interrupt_000023c8": "trigger_system_interrupt"
            },
            "code": "int check_interrupt_status_and_trigger_000023d0(int interrupt_number) {\n  int* PTR_DAT_000023fc = (int*)PTR_DAT_000023fc;\n  int interrupt_status = *PTR_DAT_000023fc;\n  int result;\n  if (interrupt_status == 0) {\n    result = trigger_system_interrupt_000023c8(1, interrupt_number, 0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_interrupt_status_and_trigger_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "get_relocated_data_00000a30",
                "auStack_20": "relocated_data",
                "in_r3": "offset",
                "PTR_DAT_00000a60": "N/A",
                "process_data_and_print_relocation_info_00000f04": "process_data_and_print_relocation_info",
                "uRam00000a3c": "relocated_data_parameter"
            },
            "code": "char *get_relocated_data_00000a30(void)\n{\n    int offset;\n    char relocated_data[24];\n    \n    offset = get_offset();\n    process_data_and_print_relocation_info(4, relocated_data);\n    return relocated_data + (-offset - *(int *)(offset + 0x4c));\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "get_relocated_data_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "initialize_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "usage_command_arguments",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int initialize_rtc_commands_000034c0(void)\n{\n    execute_rtc_command(PTR_s_usage__rtc__command___arguments__00003500);\n    execute_rtc_command(PTR_s_commands__00003504);\n    execute_rtc_command(PTR_s__poweron_power_the_interface_on_00003508);\n    execute_rtc_command(PTR_s__poweroff_power_the_interface_of_0000350c);\n    execute_rtc_command(PTR_s__clearalarm_deactivate_the_curre_00003510);\n    execute_rtc_command(PTR_s__getalarm_print_the_currently_al_00003514);\n    execute_rtc_command(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n    execute_rtc_command(PTR_s__gettime_print_the_current_time_0000351c);\n    execute_rtc_command(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n    return 0;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_rtc_commands_000034c0",
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  FUNC_00004db8(PTR_s_usage__rtc__command___arguments__00003500);\n  FUNC_00004db8(PTR_s_commands__00003504);\n  FUNC_00004db8(PTR_s__poweron_power_the_interface_on_00003508);\n  FUNC_00004db8(PTR_s__poweroff_power_the_interface_of_0000350c);\n  FUNC_00004db8(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  FUNC_00004db8(PTR_s__getalarm_print_the_currently_al_00003514);\n  FUNC_00004db8(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  FUNC_00004db8(PTR_s__gettime_print_the_current_time_0000351c);\n  FUNC_00004db8(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_pointer_to_data_000050e8",
                "PTR_DAT_000050f0": "pointer_to_data"
            },
            "code": "const void* get_pointer_to_data_000050e8() {\n  return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_blocks_000042a4",
                "param_1": "block_id",
                "uVar1": "block_value",
                "iVar2": "ptr_value",
                "bVar3": "is_block_id"
            },
            "code": "void initialize_blocks_000042a4(int block_id)\n{\n    undefined4 block_value;\n    int ptr_value;\n    bool is_block_id;\n\n    do_nothing_with_data();\n    if (*(int *)(block_id + 0x18) == 0)\n    {\n        *(undefined4 *)(block_id + 0x48) = 0;\n        *(undefined4 *)(block_id + 0x4c) = 0;\n        *(undefined4 *)(block_id + 0x50) = 0;\n        ptr_value = *(int *)PTR_DAT_0000430c;\n        *(undefined **)(block_id + 0x28) = PTR_DAT_00004310;\n        is_block_id = ptr_value == block_id;\n        if (is_block_id)\n        {\n            ptr_value = 1;\n        }\n        if (is_block_id)\n        {\n            *(int *)(block_id + 0x18) = ptr_value;\n        }\n        block_value = allocate_and_initialize_block_00004314(block_id);\n        *(undefined4 *)(block_id + 4) = block_value;\n        block_value = allocate_and_initialize_block_00004314(block_id);\n        *(undefined4 *)(block_id + 8) = block_value;\n        block_value = allocate_and_initialize_block_00004314(block_id);\n        *(undefined4 *)(block_id + 0xc) = block_value;\n        initialize_data_000041f4(*(undefined4 *)(block_id + 4), 4, 0);\n        initialize_data_000041f4(*(undefined4 *)(block_id + 8), 9, 1);\n        initialize_data_000041f4(*(undefined4 *)(block_id + 0xc), 0x12, 2);\n        *(undefined4 *)(block_id + 0x18) = 1;\n    }\n    do_nothing(DAT_000042a0);\n    return;\n}",
            "called": [
                "FUN_0000428c",
                "FUN_000041f4",
                "FUN_000045ec",
                "FUN_00004314"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004c84",
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_00006768",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "initialize_blocks_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_param_to_19_00000514",
                "param_1": "param_array",
                "*param_1": "*param_array"
            },
            "code": "int set_param_to_19_00000514(int *param_array)\n{\n  *param_array = 19;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_param_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "synchronize_data_00002e9c"
            },
            "code": "int synchronize_data_00002e9c() {\n    synchronize_data_00002e9c_00003688();\n    return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "synchronize_data_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initialize_system_00001960",
                "set_flag_00001748": "set_flag_for_system",
                "clear_memory_at_calculated_address_00001710": "clear_memory_at_calculated_address",
                "DAT_000019b4": "system_data",
                "DAT_000019b8": "system_data_flags",
                "PTR_DAT_000019bc": "system_data_ptr"
            },
            "code": "void initialize_system_00001960(void)\n{\n  set_flag_for_system(0xa0);\n  clear_memory_at_calculated_address(DAT_000019b4, 1);\n  *DAT_000019b8 = *DAT_000019b8 & 0x3b | 0x44;\n  do {\n  } while ((DAT_000019b8[6] & 0xc) != 4);\n  do {\n  } while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_flag_and_clear_memory_00001a3c",
                "DAT_00001a58": "DAT_flag_address",
                "PTR_DAT_00001a5c": "PTR_data_value",
                "clear_six_bytes_of_memory_at_address_calculated_in_function_00001734": "clear_six_bytes_of_memory_at_calculated_address"
            },
            "code": "void set_flag_and_clear_memory_00001a3c(void)\n{\n  set_flag_at_calculated_address(DAT_00001a58, 1);\n  clear_six_bytes_of_memory_at_calculated_address();\n  *PTR_DAT_00001a5c = 5;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_flag_and_clear_memory_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "destination_end",
                "puVar2": "source_end"
            },
            "code": "void reverse_copy_000045ee(char* destination, char* source, int length) {\n  char* source_end = source + length;\n  if ((source < destination) && (destination < source_end)) {\n    char* destination_end = destination + length;\n    while (destination_end != destination) {\n      source_end--;\n      destination_end--;\n      *destination_end = *source_end;\n    }\n  }\n  else {\n    destination--;\n    for (; source != source_end; source++) {\n      destination++;\n      *destination = *source;\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "process_device_data_00005404",
                "param_1": "device_id",
                "param_2": "data",
                "param_3": "device_data_ptr",
                "param_4": "param_4",
                "iVar1": "device_data_length",
                "uVar2": "data_length",
                "puVar3": "data_ptr"
            },
            "code": "uint process_device_data_00005404(int device_id, uint data, int *device_data_ptr, undefined4 param_4)\n{\n  int device_data_length;\n  uint data_length;\n  undefined *data_ptr;\n  \n  if ((device_id != 0) && (*(int *)(device_id + 0x18) == 0)) {\n    initialize_device_data_blocks();\n  }\n  if (device_data_ptr == (int *)PTR_DAT_0000549c) {\n    device_data_ptr = *(int **)(device_id + 4);\n  }\n  else if (device_data_ptr == (int *)PTR_DAT_000054a0) {\n    device_data_ptr = *(int **)(device_id + 8);\n  }\n  else if (device_data_ptr == (int *)PTR_DAT_000054a4) {\n    device_data_ptr = *(int **)(device_id + 0xc);\n  }\n  device_data_ptr[2] = device_data_ptr[6];\n  data_length = (uint)*(ushort *)(device_data_ptr + 3);\n  device_data_length = data_length << 0x1c;\n  if (((device_data_length < 0) && (data_length = device_data_ptr[4], data_length != 0)) ||\n     (device_data_length = clean_device_data(device_id, device_data_ptr, device_data_length, data_length, param_4), device_data_length == 0)) {\n    device_data_length = *device_data_ptr - device_data_ptr[4];\n    data = data & 0xff;\n    if ((device_data_length < device_data_ptr[5]) || (device_data_length = process_data(device_id, device_data_ptr), device_data_length == 0)) {\n      device_data_ptr[2] = device_data_ptr[2] + -1;\n      data_ptr = (undefined *)*device_data_ptr;\n      *device_data_ptr = (int)(data_ptr + 1);\n      *data_ptr = (char)data;\n      if (device_data_ptr[5] != device_data_length + 1) {\n        if (-1 < (int)((uint)*(ushort *)(device_data_ptr + 3) << 0x1f)) {\n          return data;\n        }\n        if (data != 10) {\n          return data;\n        }\n      }\n      device_data_length = process_data(device_id, device_data_ptr);\n      if (device_data_length == 0) {\n        return data;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_000057a8",
                "FUN_00004db8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "process_device_data_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "ImprovedFunction_00006974",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "output1",
                "uVar2": "result",
                "local_8": "localArray"
            },
            "code": "typedef unsigned long long u64;\\\ntypedef unsigned int u32;\\\ntypedef int s32;\\\ntypedef unsigned short u16;\\\ntypedef unsigned char u8;\\\n\\\nu64 ImprovedFunction_00006974(s32 input1, s32 input2, s32 input3, s32 input4)\\\n{\\\n  s32 output1;\\\n  s32 output2;\\\n  u64 result;\\\n  u8 localArray[8];\\\n\\\n  if (input4 == 0 && input3 == 0)\\\n  {\\\n    if (input2 < 0)\\\n    {\\\n      output1 = 0;\\\n      output2 = -2147483648;\\\n    }\\\n    else if (input2 != 0 || input1 != 0)\\\n    {\\\n      output1 = 2147483647;\\\n      output2 = -1;\\\n    }\\\n    return ((u64)output2 << 32) | (u32)output1;\\\n  }\\\n  if (input2 < 0)\\\n  {\\\n    output1 = -input2 - (input1 != 0);\\\n    if (input4 < 0)\\\n    {\\\n      result = FUNC_00006a14(-input1, output1, -input3, -input4 - (input3 != 0), localArray);\\\n      return ((u64)-(s32)(result >> 32) - ((s32)result != 0) << 32) | -(s32)result;\\\n    }\\\n    result = FUNC_00006a14(-input1, output1, input3, input4, localArray);\\\n    return ((u64)-(s32)(result >> 32) - ((s32)result != 0) << 32) | -(s32)result;\\\n  }\\\n  if (input4 < 0)\\\n  {\\\n    result = FUNC_00006a14(input1, input2, -input3, -input4 - (input3 != 0), localArray);\\\n    return ((u64)-(s32)(result >> 32) - ((s32)result != 0) << 32) | -(s32)result;\\\n  }\\\n  result = FUNC_00006a14();\\\n  return result;\\\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "ImprovedFunction_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "allocate_and_initialize_block_00004314",
                "*param_1": "errorCode",
                "piVar1": "currentBlockPtr",
                "piVar2": "blockPtr",
                "iVar3": "CURRENT_BLOCK_PTR",
                "ppiVar4": "nextBlockPtrPtr",
                "do_nothing_with_pointer_00004274": "do_nothing_with_pointer",
                "FUNC_000042a4": "initialize_block",
                "DAT_0000439c": "DEFAULT_VALUE",
                "do_nothing_000045e4": "do_nothing",
                "do_nothing_and_return_00004280": "do_nothing_and_return",
                "fill_array_with_value_00004622": "fill_array_with_value"
            },
            "code": "int *allocate_and_initialize_block_00004314(undefined4 *errorCode){\n  int *blockPtr;\n  int *currentBlockPtr;\n  int currentBlockValue;\n  int **nextBlockPtrPtr;\n  do_nothing_with_pointer();\n  currentBlockValue = *(int *)CURRENT_BLOCK_PTR;\n  if (*(int *)(currentBlockValue + 0x18) == 0) {\n    initialize_block(currentBlockValue);\n  }\n  nextBlockPtrPtr = (int **)(currentBlockValue + 0x48);\n  do {\n    currentBlockPtr = nextBlockPtrPtr[1];\n    blockPtr = nextBlockPtrPtr[2];\n    while (currentBlockPtr = (int *)((int)currentBlockPtr + -1), -1 < (int)currentBlockPtr) {\n      if (*(short *)(blockPtr + 3) == 0) {\n        blockPtr[3] = DAT_0000439c;\n        blockPtr[0x19] = 0;\n        do_nothing(blockPtr + 0x16);\n        do_nothing_and_return();\n        blockPtr[1] = 0;\n        blockPtr[2] = 0;\n        blockPtr[4] = 0;\n        blockPtr[5] = 0;\n        *blockPtr = 0;\n        blockPtr[6] = 0;\n        fill_array_with_value(blockPtr + 0x17,0,8);\n        blockPtr[0xd] = 0;\n        blockPtr[0xe] = 0;\n        blockPtr[0x12] = 0;\n        blockPtr[0x13] = 0;\n        return blockPtr;\n      }\n      blockPtr = blockPtr + 0x1a;\n    }\n    if (*nextBlockPtrPtr == (int *)0x0) {\n      currentBlockPtr = (int *)allocate_and_initialize_block_00004314_of_memory(errorCode,4);\n      *nextBlockPtrPtr = currentBlockPtr;\n      if (currentBlockPtr == (int *)0x0) {\n        do_nothing_and_return();\n        *errorCode = 0xc;\n        return (int *)0x0;\n      }\n    }\n    nextBlockPtrPtr = (int **)*nextBlockPtrPtr;\n  } while( true );\n}",
            "called": [
                "FUN_000045e4",
                "FUN_00004274",
                "FUN_00004248",
                "FUN_00004280",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_block_00004314",
            "code_backup": "\nint * FUN_00004314(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  do_nothing_with_pointer_00004274();\n  iVar3 = *(int *)PTR_DAT_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUNC_000042a4(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        do_nothing_000045e4(piVar2 + 0x16);\n        do_nothing_and_return_00004280();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        fill_array_with_value_00004622(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_block_of_memory_00004248(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        do_nothing_and_return_00004280();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "count_and_update_matching_integers_00004dc8",
                "param_1": "array",
                "param_2": "array_length",
                "iVar1": "matching_count",
                "bVar3": "is_match",
                "uVar2": "result",
                "*(short *)(param_2 + 0xe)": "match_value",
                "*(int *)(param_2 + 0x54)": "count",
                "*(ushort *)(param_2 + 0xc)": "result"
            },
            "code": "void count_and_update_matching_integers_00004dc8(int* array, int array_length, int* match_value, int* count, int* result) {\n    int matching_count = count_matching_integers(array, *match_value);\n    bool is_match = matching_count > -1;\n    if (is_match) {\n        *count += matching_count;\n        *result = *count;\n    }\n    else {\n        *result = *result & 0xffffefff;\n    }\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "count_and_update_matching_integers_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "convert_string_to_integer_00005fd8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "*DAT_00005fe8": "string"
            },
            "code": "void convert_*convert_string_to_integer_00005fd8(char* *DAT_00005fe8, int param1, int param2, int param3){\n  convert_*convert_string_to_integer_00005fd8(*DAT_00005fe8, param1, param2, param3);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "convert_string_to_integer_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "readByte_00005e10",
                "param_1": "bufferAddress",
                "param_2": "bufferPtr",
                "iVar1": "processResult",
                "pbVar3": "buffer",
                "initialize_blocks_000042a4": "initializeBlocks",
                "process_data_00006768": "processData"
            },
            "code": "uint readByte_00005e10(int bufferAddress, byte **bufferPtr)\n{\n    int blockInit = *(int *)(bufferAddress + 0x18);\n    if (bufferAddress != 0 && blockInit == 0)\n    {\n        initializeBlocks();\n    }\n    if (bufferPtr == (byte **)bufferPtr1)\n    {\n        bufferPtr = *(byte ***)(bufferAddress + 4);\n    }\n    else if (bufferPtr == (byte **)bufferPtr2)\n    {\n        bufferPtr = *(byte ***)(bufferAddress + 8);\n    }\n    else if (bufferPtr == (byte **)bufferPtr3)\n    {\n        bufferPtr = *(byte ***)(bufferAddress + 0xc);\n    }\n    int processResult = processData(bufferAddress, bufferPtr);\n    if (processResult == 0)\n    {\n        bufferPtr[1] = bufferPtr[1] - 1;\n        byte *buffer = *bufferPtr;\n        *bufferPtr = buffer + 1;\n        uint readByte_00005e10 = (uint)*buffer;\n    }\n    else\n    {\n        uint readByte_00005e10 = 0xffffffff;\n    }\n    return readByte_00005e10;\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "readByte_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "calculate_score_and_execute_000033f4",
                "param_1": "input",
                "iVar1": "score",
                "uVar2": "result",
                "auStack_2c": "input_buffer",
                "parse_input_and_calculate_score_0000328c": "parse_input_and_calculate_score",
                "execute_and_update_data_00002654": "execute_and_update_data",
                "PTR_FUN_000031e0_1_0000343c": "PTR_FUN_000031e0_1_0000343c",
                "FUNC_00004db8": "print_error",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_s_rtc__error_setting_alarm_00003440"
            },
            "code": "int calculate_score_and_execute_000033f4(int input)\n{\n  int score;\n  char input_buffer[36];\n  \n  score = parse_input_and_calculate_score(input, input_buffer);\n  if (score == 0) {\n    int result = execute_and_update_data(input_buffer, PTR_FUN_000031e0_1_0000343c, 0);\n    if (result == -1) {\n      print_error(PTR_s_rtc__error_setting_alarm_00003440);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_00002654",
                "FUN_00004db8",
                "FUN_0000328c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_score_and_execute_000033f4",
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = parse_input_and_calculate_score_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = execute_and_update_data_00002654(auStack_2c,PTR_FUN_000031e0_1_0000343c,0);\n    if (iVar1 == -1) {\n      FUNC_00004db8(PTR_s_rtc__error_setting_alarm_00003440);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_unix_time_to_datetime_0000443c",
                "param_1": "unix_time",
                "param_2": "datetime",
                "iVar1": "days_since_epoch",
                "uVar2": "seconds_since_midnight",
                "uVar3": "days_since_1900",
                "uVar4": "days_since_year_start",
                "uVar5": "year",
                "uVar6": "leap_year",
                "uVar8": "day_of_year",
                "bVar9": "is_negative_days_since_epoch"
            },
            "code": "uint * convert_unix_time_to_datetime_0000443c(uint32_t *unix_time, uint32_t *datetime)\n{\n  int days_since_epoch = ImprovedFunction_00006974(unix_time[0], unix_time[1], DAT_0000458c, 0);\n  uint seconds_since_midnight = days_since_epoch % 86400;\n  uint days_since_1900 = days_since_epoch / 86400 + 1900 * 365 + (1900 - 1600) / 4 - (1900 - 1600) / 100 + (1900 - 1600) / 400 - (days_since_epoch < 0);\n  uint days_since_year_start = days_since_1900 - (days_since_1900 / 1461) + (days_since_1900 / 36524) - (days_since_1900 / 146097) - 365 * (days_since_1900 / 365);\n  uint year = 100 * (days_since_1900 / 36524 - days_since_1900 / 1461) + days_since_year_start / 365;\n  uint leap_year = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n  uint day_of_year = days_since_year_start - (365 * days_since_year_start / 365) + leap_year;\n  uint month = (5 * day_of_year + 2) / 153;\n  uint day = day_of_year - (153 * month + 2) / 5 + 1;\n  datetime[0] = year;\n  datetime[1] = month + 1;\n  datetime[2] = day;\n  datetime[3] = (days_since_epoch + 2) % 7;\n  datetime[4] = seconds_since_midnight / 3600;\n  datetime[5] = (seconds_since_midnight % 3600) / 60;\n  datetime[6] = seconds_since_midnight % 60;\n  datetime[7] = 0;\n  return datetime;\n}\n",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "convert_unix_time_to_datetime_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "enable_interrupts_000027b0",
                "*puVar1": "interrupt_controller",
                "DAT_00002814": "interrupt_controller_ptr"
            },
            "code": "void enable_interrupts_000027b0(void)\n{\n  uint32_t *interrupt_controller = DAT_00002814;\n  interrupt_controller[0x103c/4] |= 0x20000000;\n  interrupt_controller[4] = 1;\n  interrupt_controller[4] = 0;\n  if ((interrupt_controller[5] & 1) != 0) {\n    *interrupt_controller = 0;\n  }\n  interrupt_controller[4] = 0x104;\n  interrupt_controller[2] = 0xffffff42;\n  interrupt_controller[7] = 0;\n  enable_interrupts_000027b0_0000294c();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "enable_interrupts_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_character"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source)\n{\n  char current_character;\n  do {\n    current_character = *source;\n    *destination = current_character;\n    source = source + 1;\n    destination = destination + 1;\n  } while (current_character != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "remove_node_if_not_null_00006192",
                "param_1": "node_value",
                "param_2": "node_list",
                "next_node_ptr": "next_node_pointer"
            },
            "code": "unsigned int remove_node_if_not_null_00006192(unsigned int node_value, unsigned int *node_list) {\n    unsigned int *next_node_ptr = (unsigned int *)node_list[0xD];\n    if (next_node_ptr != NULL) {\n        if (next_node_ptr != node_list + 0x11) {\n            insert_node_at_position();\n        }\n        node_list[0xD] = NULL;\n        node_list[1] = node_list[0x10];\n        if (node_list[0x10] != NULL) {\n            *node_list = node_list[0xF];\n            return 0;\n        }\n    }\n    *node_list = node_list[4];\n    node_list[1] = NULL;\n    *(unsigned short *)(node_list + 3) = *(unsigned short *)(node_list + 3) | 0x20;\n    return 0xFFFFFFFF;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "remove_node_if_not_null_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_six_bytes_of_memory_at_address_calculated_in_function_00001734",
                "DAT_00001744": "PTR_memory_address",
                "clear_memory_at_calculated_address_00001710": "clear_memory"
            },
            "code": "void clear_six_bytes_of_memory_at_address_calculated_in_function_00001734(void)\n{\n  clear_memory(DAT_00001744,6);\n  return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_000019c0",
                "FUN_00001a18",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "clear_six_bytes_of_memory_at_address_calculated_in_function_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "count_matching_integers_00000e14",
                "param_1": "integers",
                "param_2": "target",
                "uVar1": "count",
                "DAT_00000e34": "size"
            },
            "code": "int count_matching_integers_00000e14(int *integers, int target, int DAT_00000e34) {\n    int count = 0;\n    for (int i = 0; i < DAT_00000e34; i++) {\n        if (integers[i] == target) {\n            count++;\n        }\n    }\n    return count;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "count_matching_integers_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_nonmatching_element_0000281c",
                "local_10": "num_attempts",
                "local_c": "first_element"
            },
            "code": "int find_first_nonmatching_element_0000281c(void)\n{\n  int num_attempts = 0;\n  int first_element = *DAT_00002858;\n  while (num_attempts < 3 && first_element == *DAT_00002858) {\n    num_attempts++;\n  }\n  return first_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_nonmatching_element_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_int_equal_to_pointer_00002270",
                "param_1": "pointer_param",
                "uVar1": "bool_var",
                "iVar2": "int_var",
                "bVar3": "is_equal"
            },
            "code": "bool is_int_equal_to_pointer_00002270(int pointer_param) {\n    int int_var = *(int *)(pointer_param + 0xc);\n    bool is_equal = *(int *)(pointer_param + 8) == int_var;\n    if (is_equal) {\n        int_var = 1;\n    }\n    return (bool)int_var;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "is_int_equal_to_pointer_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "insert_node_at_position_00005780",
                "param_1": "data",
                "*DAT_0000578c": "list"
            },
            "code": "void insert_node_at_position_00005780(void* *DAT_0000578c, undefined4 data){\n  insert_node_at_position_00005780_00004b34(**DAT_0000578c,data);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "insert_node_at_position_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "extract_bits_and_call_function_if_flag_set_000020cc",
                "DAT_000020dc": "flag_ptr",
                "extract_bits_and_call_function_if_flag_set_00002028": "extract_bits_and_call_function_if_flag_set",
                "1": "flag_bit"
            },
            "code": "void extract_bits_and_call_function_if_flag_set_000020cc(unsigned char* DAT_000020dc, int flag_bit) {\n  extract_bits_and_call_function_if_flag_set_000020cc(DAT_000020dc, flag_bit);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_if_flag_set_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "enable_interrupts_00002396",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void enable_interrupts_00002396() {\n  enable_interrupts_00002396_000025f4();\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "enable_interrupts_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "process_data_00004cb4",
                "param_1": "data_byte",
                "puVar1": "current_block",
                "uVar2": "new_val",
                "puVar3": "current_byte",
                "unaff_r4": "unaff_r4",
                "iVar4": "data_block",
                "unaff_r5": "unaff_r5"
            },
            "code": "uint process_data_00004cb4(uint data_byte)\n{\n  int data_block = *data_block_ptr;\n  if ((data_block != 0) && (*(int *)(data_block + 0x18) == 0)) {\n    initialize_blocks(data_block);\n  }\n  uint *current_block = *(uint **)(data_block + 8);\n  if ((data_block != 0) && (*(int *)(data_block + 0x18) == 0)) {\n    initialize_blocks(data_block);\n  }\n  if (current_block == (uint *)current_block_ptr1) {\n    current_block = *(uint **)(data_block + 4);\n  }\n  else if (current_block == (uint *)current_block_ptr2) {\n    current_block = *(uint **)(data_block + 8);\n  }\n  else if (current_block == (uint *)current_block_ptr3) {\n    current_block = *(uint **)(data_block + 0xc);\n  }\n  if ((-1 < (int)(current_block[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(current_block + 3) << 0x16))) {\n    do_nothing(current_block[0x16]);\n  }\n  uint new_val = current_block[2] - 1;\n  current_block[2] = new_val;\n  if (((int)new_val < 0) && (((int)new_val < (int)current_block[6] || (new_val = data_byte & 0xff, new_val == 10))))\n  {\n    data_byte = process_device_data(data_block, data_byte, current_block, new_val, unaff_r4, unaff_r5);\n  }\n  else {\n    byte *current_byte = (byte *)*current_block;\n    *current_block = current_byte + 1;\n    *current_byte = (char)data_byte;\n    data_byte = data_byte & 0xff;\n  }\n  if ((-1 < (int)(current_block[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(current_block + 3) << 0x16))) {\n    do_nothing(current_block[0x16]);\n  }\n  return data_byte;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "process_data_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "calculate_score_and_parse_input_00003478",
                "param_1": "input",
                "iVar1": "score",
                "auStack_2c": "input_buffer",
                "parse_input_and_calculate_score_0000328c": "parse_input_and_calculate_score",
                "process_and_set_flag_00002600": "process_input_and_set_flag",
                "FUNC_00004db8": "print_error_message"
            },
            "code": "int calculate_score_and_parse_input_00003478(int input) {\n    int score;\n    char input_buffer[36];\n    score = parse_input_and_calculate_score(input, input_buffer);\n    if (score == 0) {\n        score = process_input_and_set_flag(input_buffer);\n        if (score == -1) {\n            print_error_message(PTR_s_rtc__error_setting_time_000034bc);\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    else {\n        return 1;\n    }\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00002600",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_score_and_parse_input_00003478",
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = parse_input_and_calculate_score_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = process_and_set_flag_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      FUNC_00004db8(PTR_s_rtc__error_setting_time_000034bc);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "extract_bits_and_call_function_if_flag_set_00002028",
                "param_1": "data_array_index",
                "param_2": "bit_mask_array",
                "uVar2": "bit_mask",
                "local_c": "bit_index",
                "iVar1": "extracted_bits"
            },
            "code": "void extract_bits_and_call_function_if_flag_set_00002028(int data_array_index, uint bit_mask_array)\n{\n  int extracted_bits;\n  uint bit_mask = *(uint *)(data_array_index + 0xa0);\n  for (uint bit_index = 0; bit_index < 0x20; bit_index++) {\n    if (((bit_mask & 1 << (bit_index & 0xff)) != 0) && ((*(uint *)(data_array_index + bit_index * 4) & 0xf0000) != 0)) {\n      *(int *)(data_array_index + 0xa0) = 1 << (bit_index & 0xff);\n      extracted_bits = extract_bits_from_uint_array(param_2, bit_index);\n      (**(code **)(PTR_DAT_000020b4 + extracted_bits * 0xc))(*(undefined4 *)(PTR_DAT_000020b4 + extracted_bits * 0xc + 4));\n    }\n  }\n  check_dat_flag();\n  return;\n}",
            "called": [
                "FUN_00001cf0",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020f4",
                "FUN_000020e0",
                "FUN_000020b8",
                "FUN_000020cc",
                "FUN_00002108"
            ],
            "imported": false,
            "current_name": "extract_bits_and_call_function_if_flag_set_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_calculated_address_to_one_000016c8",
                "param_1": "address",
                "param_2": "param",
                "puVar1": "address_as_int_ptr",
                "calculate_address_00001696": "calculate_address",
                "*puVar1": "*address_as_int_ptr"
            },
            "code": "void set_calculated_address_to_one_000016c8(void* address, char param)\n{\n  void* calculated_address = calculate_address(address, param);\n  int* address_as_int_ptr = (int*) calculated_address;\n  *address_as_int_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_calculated_address_to_one_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "clear_memory_and_set_flag_00001a60",
                "DAT_00001ac4": "memory_address",
                "DAT_00001ac8": "data_address",
                "DAT_00001acc": "flag_address",
                "PTR_DAT_00001ad0": "pointer_to_value",
                "clear_memory_at_calculated_address_00001710": "clear_memory",
                "set_flag_at_calculated_address_000016ec": "set_flag"
            },
            "code": "void clear_memory_and_set_flag_00001a60(void)\n{\n    int* DAT_00001ac8 = DAT_00001ac8;\n    clear_memory_at_calculated_address_00001710(DAT_00001ac4, 1);\n    *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n    while ((DAT_00001ac8[6] & 0xc) != 8);\n    set_flag_at_calculated_address_000016ec(DAT_00001acc, 6);\n    while ((DAT_00001ac8[6] & 0x20) == 0);\n    while ((DAT_00001ac8[6] & 0x40) == 0);\n    *PTR_DAT_00001ad0 = 6;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "clear_memory_and_set_flag_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_and_execute_code_blocks_0000099c",
                "local_14": "stack_ptr1",
                "local_10": "global_ptr1",
                "local_c": "global_ptr2",
                "uStack_18": "stack_var1",
                "DAT_00000a14": "DAT_GLOBAL_ARRAY",
                "initialize_and_clear_memory_00000db0": "initialize_and_clear_memory",
                "PTR_DAT_00000a18": "PTR_Elf32_Rel_ARRAY",
                "DAT_00000a1c": "DAT_GLOBAL_VAR1",
                "PTR_Elf32_Rel_ARRAY_00000a20": "PTR_GLOBAL_ARRAY",
                "PTR_DAT_00000a24": "PTR_GLOBAL_ARRAY_END",
                "PTR_DAT_00000a28": "PTR_GLOBAL_VAR_ARRAY",
                "DAT_00000a2c": "PTR_GLOBAL_VAR_ARRAY_END",
                "do_nothing_00000990": "do_nothing",
                "enable_interrupts_and_set_flags_00000e64": "enable_interrupts_and_set_flags",
                "execute_code_blocks_0000459c": "execute_code_blocks",
                "initialize_memory_and_interrupts_00000f8c": "initialize_memory_and_interrupts"
            },
            "code": "void initialize_and_execute_code_blocks_0000099c(void)\n{\n  undefined4 stack_var1;\n  undefined4 *stack_ptr1;\n  undefined4 *global_ptr1;\n  undefined4 *global_ptr2;\n  initialize_and_clear_memory();\n  global_ptr1 = (undefined4 *)PTR_DAT_00000a18;\n  stack_ptr1 = DAT_00000a14;\n  while (global_ptr1 < &stack_var1) {\n    *global_ptr1 = DAT_00000a1c;\n    global_ptr1++;\n  }\n  global_ptr1 = (undefined4 *)PTR_Elf32_Rel_ARRAY_00000a20;\n  while (global_ptr1 < PTR_DAT_00000a24) {\n    *global_ptr1 = *stack_ptr1;\n    stack_ptr1++;\n    global_ptr1++;\n  }\n  global_ptr1 = (undefined4 *)PTR_DAT_00000a28;\n  while( true ) {\n    if (DAT_00000a2c <= global_ptr1) break;\n    *global_ptr1 = 0;\n    global_ptr1++;\n  }\n  do_nothing();\n  enable_interrupts_and_set_flags();\n  execute_code_blocks();\n  initialize_memory_and_interrupts();\n  return;\n}\n",
            "called": [
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000db0",
                "FUN_0000459c",
                "FUN_00000990"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_execute_code_blocks_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "process_input_string_00002d94",
                "param_1": "input_string",
                "param_2": "string_length",
                "iVar1": "byte_read",
                "bVar2": "current_byte",
                "bVar3": "is_start_of_string",
                "local_c": "current_position"
            },
            "code": "uint process_input_string_00002d94(undefined *input_string, int string_length)\n{\n  int byte_read;\n  byte current_byte;\n  bool is_start_of_string = true;\n  undefined *current_position = input_string;\n  while( true ) {\n    if (string_length + -1 <= (int)current_position - (int)input_string) {\n      return 0xffffffff;\n    }\n    byte_read = readByteFromBlock_00004418();\n    if (byte_read < 0) break;\n    if ((byte_read == 0xd) || (byte_read == 10)) {\n      *current_position = 0;\n      process_data_wrapper_00002a00(0xd);\n      process_data_wrapper_00002a00(10);\n      bool is_start_of_string = current_position == input_string;\n      if (is_start_of_string) {\n        input_string = (undefined *)0x1;\n      }\n      current_byte = (byte)input_string;\n      if (!is_start_of_string) {\n        current_byte = 0;\n      }\n      return (uint)current_byte;\n    }\n    if ((byte_read == 8) || (byte_read == 0x7f)) {\n      if (current_position != input_string) {\n        current_position = current_position - 1;\n        *current_position = 0;\n        process_data_wrapper_00002a00(8);\n        process_data_wrapper_00002a00(0x20);\n        process_data_wrapper_00002a00(8);\n      }\n    }\n    else {\n      *current_position = (char)byte_read;\n      process_data_wrapper_00002a00(byte_read);\n      current_position = current_position + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_00004418"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_string_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_opcode_00003918",
                "param_1": "opcode_id",
                "uVar1": "opcode",
                "case 2": "case 0x02",
                "case 3": "case 0x03",
                "case 6": "case 0x06",
                "case 9": "case 0x09",
                "case 0xc": "case 0x0C",
                "case 0xf": "case 0x0F",
                "case 0xf1": "case 0xF1",
                "case 0xf4": "case 0xF4",
                "case 0xf7": "case 0xF7",
                "case 0xfa": "case 0xFA",
                "case 0xfd": "case 0xFD"
            },
            "code": "uint8_t get_opcode_00003918(uint8_t opcode_id) {\n    uint8_t opcode;\n    switch(opcode_id) {\n        case 0x02:\n            opcode = 0x68;\n            break;\n        case 0x03:\n            opcode = 0x6b;\n            break;\n        case 0x06:\n            opcode = 0x4d;\n            break;\n        case 0x09:\n            opcode = 0x47;\n            break;\n        case 0x0C:\n            opcode = 0x54;\n            break;\n        case 0x0F:\n            opcode = 0x50;\n            break;\n        case 0xF1:\n            opcode = 0x66;\n            break;\n        case 0xF4:\n            opcode = 0x70;\n            break;\n        case 0xF7:\n            opcode = 0x6e;\n            break;\n        case 0xFA:\n            opcode = 0x75;\n            break;\n        case 0xFD:\n            opcode = 0x6d;\n            break;\n        default:\n            opcode = 0x00;\n            break;\n    }\n    return opcode;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_opcode_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_ptr",
                "param_2": "arg2",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d64(int function_ptr, int arg1, int arg2) {\n  int result;\n  if (function_ptr == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(function_ptr + 0xc))(*(int *)(function_ptr + 4), arg2);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_bytes_00004e52",
                "param_1": "first_array",
                "param_2": "second_array",
                "uVar2": "first_byte_value",
                "bVar1": "second_byte_value",
                "bVar3": "bytes_match"
            },
            "code": "int compare_bytes_00004e52(byte *first_array, byte *second_array) {\n    byte first_byte;\n    byte second_byte;\n    bool bytes_match;\n\n    do {\n        first_byte = *first_array;\n        second_byte = *second_array;\n        bytes_match = first_byte == 1;\n        if (first_byte != 0) {\n            bytes_match = first_byte == second_byte;\n        }\n        first_array++;\n        second_array++;\n    } while (bytes_match);\n\n    return first_byte - second_byte;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002b10",
                "FUN_00004e52",
                "FUN_00005100",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002a18"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "allocateMemoryAndInitialize_000010d4",
                "param_1": "address",
                "param_2": "size",
                "param_3": "flags",
                "param_4": "param_4",
                "param_5": "param_5",
                "param_6": "param_6",
                "param_7": "param_7",
                "uVar1": "state",
                "uVar2": "allocatedMemory",
                "iVar3": "index",
                "uVar4": "alignedSize",
                "puVar5": "memoryPointer",
                "local_30": "temp",
                "local_2c": "alignedAddress",
                "local_10": "counter",
                "local_c": "i",
                "local_a": "j"
            },
            "code": "int allocateMemoryAndInitialize_000010d4(uint32_t address, int size, byte flags, uint32_t param_4, undefined4 param_5, undefined4 param_6, undefined4 param_7)\n{\n    undefined4 state;\n    undefined4 allocatedMemory;\n    int index;\n    uint32_t alignedAddress;\n    uint32_t alignedSize;\n    undefined4 *memoryPointer;\n    uint32_t counter;\n    uint32_t temp;\n    uint32_t i;\n    uint32_t j;\n    if (flags >= 16) {\n        return -22;\n    }\n    alignedAddress = address;\n    alignedSize = size;\n    if ((address & 3) != 0) {\n        temp = 4 - (address & 3);\n        alignedAddress = temp + address;\n        alignedSize = size - temp;\n    }\n    counter = (alignedSize - 48) & 0xfffffffc;\n    memoryPointer = (undefined4 *)(counter + alignedAddress);\n    if ((flags & 8) == 0) {\n        *(uint32_t *)alignedAddress = alignedAddress;\n    }\n    else {\n        for (i = alignedAddress; i < counter + alignedAddress; i = i + 4) {\n            *(uint32_t *)i = i;\n        }\n    }\n    state = getIRQInterruptsEnabledState_00000cd0();\n    j = 0;\n    for (i = 1; i < 33; i = i + 1) {\n        if (*(int *)(PTR_DAT_0000126c + i * 4) == 0) {\n            j = i;\n            break;\n        }\n    }\n    if (j == 0) {\n        enable_interrupts_if_privileged_00000d0c(state);\n        return -139;\n    }\n    *(undefined4 **)(PTR_DAT_0000126c + j * 4) = memoryPointer;\n    *(short *)((int)memoryPointer + 6) = j;\n    allocatedMemory = allocate_memory_000007dc(param_5, param_6, alignedAddress, counter);\n    *memoryPointer = allocatedMemory;\n    memoryPointer[9] = alignedAddress;\n    memoryPointer[0xb] = size;\n    memoryPointer[10] = param_7;\n    *(byte *)((int)memoryPointer + 5) = flags;\n    *(undefined *)(memoryPointer + 1) = 0;\n    memoryPointer[2] = 0;\n    memoryPointer[3] = 0;\n    memoryPointer[4] = 0;\n    initialize_memory_00000fec(memoryPointer + 5, 0);\n    memoryPointer[8] = 0;\n    *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n    if ((flags & 1) == 0) {\n        update_node_00000698(memoryPointer, 10);\n        if ((flags & 4) == 0) {\n            enable_interrupts_if_privileged_00000d0c(state);\n            check_exception_and_set_flag_00000738(flags);\n            return (int)j;\n        }\n    }\n    else {\n        update_node_00000698(memoryPointer, 1);\n    }\n    enable_interrupts_if_privileged_00000d0c(state);\n    index = (int)j;\n    return index;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000fec",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000738",
                "FUN_000007dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "allocateMemoryAndInitialize_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_exception_and_set_flag_00000738",
                "param_1": "exception_num",
                "iVar1": "current_exception_num",
                "PTR_DAT_0000078c": "ptr_dat_1",
                "PTR_DAT_00000790": "ptr_dat_2"
            },
            "code": "void check_exception_and_set_flag_00000738(ushort exception_num) {\n  int current_exception_num = get_current_exception_number_if_privileged_mode_00000d2a();\n  int max_exception_num = *(byte *)(*(int *)PTR_DAT_0000078c + 4);\n  int min_exception_num = *(byte *)(*(int *)PTR_DAT_0000078c + 5);\n  if (max_exception_num < 9 || exception_num < min_exception_num) {\n    if (current_exception_num == 0) {\n      set_flag_for_dat_954_0000093c();\n    }\n    else {\n      *(undefined4 *)PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "check_exception_and_set_flag_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "count_digits_00003e58",
                "param_1": "num_array",
                "param_2": "num_digits",
                "local_18": "abs_num_digits",
                "local_14": "num_ptr",
                "count_digits_00003dc4": "count_digits_helper"
            },
            "code": "int count_digits_00003e58(int *num_array, int num_digits) {\n  int digit_count;\n  int is_negative = num_digits >> 0x1f;\n  int abs_num_digits = num_digits;\n  int *num_ptr = num_array;\n  if (is_negative != 0) {\n    if (num_array != (int *)0x0) {\n      num_ptr = num_array + 1;\n      *num_array = 0x2d;\n    }\n    abs_num_digits = -num_digits;\n  }\n  digit_count = count_digits_00003e58_helper(num_ptr, abs_num_digits);\n  return is_negative + digit_count;\n}\n",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "count_digits_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "set_param_and_update_flag_00004e26",
                "param_1": "param_value",
                "param_2": "param_buffer",
                "iVar1": "result",
                "uVar2": "flag",
                "bVar3": "is_result_minus_one"
            },
            "code": "void set_param_and_update_flag_00004e26(int param_value, int* param_buffer)\n{\n    int result = set_param_to_19_000004f2(param_value, (int)*(short *)(param_buffer + 0xe));\n    bool is_result_minus_one = result == -1;\n    ushort flag = *(ushort *)(param_buffer + 0xc);\n    if (is_result_minus_one) {\n        flag &= 0xefff;\n    }\n    else {\n        *(int *)(param_buffer + 0x54) = result;\n        flag |= 0x1000;\n    }\n    *(ushort *)(param_buffer + 0xc) = flag;\n}\n",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "set_param_and_update_flag_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_00004db8",
                "FUN_00005790",
                "FUN_00004274",
                "FUN_0000428c",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  bool bVar6;\n  byte *pbVar7;\n  int unaff_r7;\n  byte *pbVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_blocks_000042a4();\n  }\n  if (param_2 == PTR_DAT_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar3 = clean_device_data_000054a8(param_1,param_2), iVar3 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar1 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar7 = pbVar8;\n  if (*pbVar7 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar8 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar3 = (int)pbVar7 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = process_input_devices_000057d2(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar7 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar7 + 1;\n  while( true ) {\n    pbVar7 = pbVar8 + 1;\n    iVar3 = find_byte_00006010(PTR_s___0__00005a44,*pbVar8,5);\n    puVar2 = PTR_DAT_00005a54;\n    if (iVar3 == 0) break;\n    local_88 = 1 << (iVar3 - (int)puVar1 & 0xffU) | local_88;\n    pbVar8 = pbVar7;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar5 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar5;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar6 = false;\n    iVar3 = local_7c;\n    pbVar7 = pbVar8;\n    while( true ) {\n      if (9 < *pbVar7 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n      bVar6 = true;\n      pbVar7 = pbVar7 + 1;\n    }\n    if (bVar6) {\n      local_7c = iVar3;\n    }\n  }\n  if (*pbVar7 == 0x2e) {\n    if (pbVar7[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar7 = pbVar7 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar6 = false;\n      local_84 = 0;\n      iVar3 = 0;\n      while( true ) {\n        pbVar7 = pbVar7 + 1;\n        if (9 < *pbVar7 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n        bVar6 = true;\n      }\n      if (bVar6) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  iVar3 = find_byte_00006010(PTR_DAT_00005a54,*pbVar7,3);\n  if (iVar3 != 0) {\n    local_88 = local_88 | 0x40 << (iVar3 - (int)puVar2 & 0xffU);\n    pbVar7 = pbVar7 + 1;\n  }\n  param_3 = pbVar7 + 1;\n  local_70 = *pbVar7;\n  iVar3 = find_byte_00006010(PTR_s_efgEFG_00005a48,local_70,6);\n  if (iVar3 == 0) {\n    iVar3 = FUNC_00005b34(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar3 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar3 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar3 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar3;\n  pbVar8 = param_3;\n  unaff_r7 = iVar3;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00005b34",
                "FUN_00006010",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4",
                "FUN_000057d2"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_system_000018bc",
                "set_flag_00001748": "set_flag",
                "*DAT_00001910": "*status_register",
                "clear_memory_at_calculated_address_00001710": "clear_memory",
                "DAT_00001914": "address_to_clear",
                "*PTR_DAT_00001918": "*flag_pointer"
            },
            "code": "void initialize_system_000018bc(void)\n{\n  set_flag(160);\n  *DAT_00001910 = *DAT_00001910 & 59 | 4;\n  clear_memory(DAT_00001914,1);\n  do {\n  } while ((status_register[6] & 16) == 0);\n  do {\n  } while ((status_register[6] & 12) != 0);\n  *PTR_DAT_00001918 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "process_data_and_print_relocation_info_00000f04",
                "param_1": "data",
                "param_2": "data_size",
                "*piRam00000f4c": "is_relocation_info_printed",
                "local_10": "data_size",
                "local_9": "data",
                "execute_function_with_pointer_00000ed8": "execute_function_with_pointer",
                "process_data_00004c84": "process_data",
                "print_relocation_info_0000211c": "print_relocation_info",
                "getIRQInterruptsEnabledState_00000cd0": "get_interrupt_state",
                "do_nothing_00000ef8": "do_nothing",
                "runInfiniteLoop_00000e58": "run_infinite_loop",
                "uRam00000f50": "uRam_data_1",
                "uRam00000f54": "uRam_data_2",
                "uRam00000f58": "uRam_data_3",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "main_ptr",
                "processInputAndParseCommandLineArgs_000023a4": "process_input_and_parse_command_line_args",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "uStack_18": "stack_pointer"
            },
            "code": "void process_data_and_print_relocation_info_00000f04(char data, int data_size){\n  static int is_relocation_info_printed = 0;\n  static int* jump_table = NULL;\n  if (!is_relocation_info_printed) {\n    is_relocation_info_printed = 1;\n    if (data == '\\x03') {\n      execute_function_with_pointer();\n    }\n    process_data(uRam00000f50, data_size);\n    print_relocation_info();\n    process_data(uRam00000f54, data_size);\n    process_data(uRam00000f58, data_size);\n  }\n  get_interrupt_state();\n  do_nothing();\n  jump_table = (int*)0xf4d;\n  run_infinite_loop();\n  do_nothing();\n  process_data(PTR_s_main____This_is_RIOT___Version__2_00000f7c, data_size);\n  process_input_and_parse_command_line_args();\n  (*jump_table)(0);\n}",
            "called": [
                "FUN_00004c84",
                "FUN_0000211c",
                "FUN_00002400",
                "FUN_00000ed8",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_000023a4",
                "FUN_00000e58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000fec",
                "FUN_00001034",
                "FUN_00000a30"
            ],
            "imported": false,
            "current_name": "process_data_and_print_relocation_info_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "process_data_00000610",
                "iVar1": "index_ptr",
                "iVar2": "current_ptr",
                "uVar3": "result",
                "count_leading_zeroes_in_integer_00000566": "count_leading_zeroes",
                "PTR_DAT_00000684": "result_ptr",
                "PTR_DAT_00000688": "current_ptr_ptr",
                "PTR_DAT_0000068c": "data_value_ptr",
                "PTR_DAT_00000690": "index_ptr_ptr"
            },
            "code": "int process_data_00000610(int num)\n{\n  int zero_count = 0;\n  for (int i = 31; i >= 0; i--) {\n    if ((num & (1 << i)) == 0) {\n      zero_count++;\n    }\n    else {\n      break;\n    }\n  }\n  return zero_count;\n}\n\nint process_data_00000610()\n{\n  int current_ptr = *(int *)PTR_DAT_00000688;\n  int data_value = *(int *)PTR_DAT_0000068c;\n  *(int *)PTR_DAT_00000684 = 0;\n  int index = process_data_00000610(data_value);\n  int index_ptr = **(int **)(PTR_DAT_00000690 + index * 4);\n  if (current_ptr == index_ptr + -8) {\n    return 0;\n  }\n  else {\n    if ((current_ptr != 0) && (*(char *)(current_ptr + 4) == '\t')) {\n      *(char *)(current_ptr + 4) = '\n';\n    }\n    *(char *)(index_ptr + -4) = '\t';\n    *(short *)PTR_DAT_00000694 = *(short *)(index_ptr + -2);\n    *(int *)PTR_DAT_00000688 = index_ptr + -8;\n    return 1;\n  }\n}",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "process_data_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "data_object_address",
                "param_2": "data_object_size",
                "uVar1": "label",
                "cVar2": "current_opcode",
                "uVar3": "bit_mask",
                "bVar4": "bit_is_set",
                "auStack_18": "stack_buffer",
                "local_10": "digits_count",
                "local_a": "message_buffer",
                "local_9": "current_index"
            },
            "code": "void display_data_object_00003694(int data_object_address, byte data_object_size)\n{\n  undefined4 uVar1;\n  char current_opcode;\n  uint bit_mask;\n  bool bit_is_set;\n  undefined stack_buffer[8];\n  int digits_count;\n  char message_buffer;\n  byte current_index;\n  if ((data_object_address == 0) || (3 < data_object_size)) {\n    display_error_message(\"Unable to display data object.\");\n  }\n  else {\n    process_data(\"Data:\");\n    for (current_index = 0; current_index < data_object_size; current_index = current_index + 1) {\n      if (*(byte *)(data_object_address + 6) < 0x14) {\n        bit_mask = DAT_000037ec & 1 << (uint)*(byte *)(data_object_address + 6);\n        bit_is_set = bit_mask != 0;\n        if (bit_is_set) {\n          bit_mask = 1;\n        }\n        current_opcode = (char)bit_mask;\n        if (!bit_is_set) {\n          current_opcode = '\\0';\n        }\n        if (current_opcode == '\\0') goto skip_opcode_processing;\n        message_buffer = '\\0';\n      }\n      else {\n        skip_opcode_processing:\n        message_buffer = get_opcode(data_object_address + 7);\n      }\n      process_data(\"[\", current_index, \"]: \");\n      if (data_object_size < 2) {\n        process_data(\"(empty)\");\n      }\n      else {\n        process_data(\"0x%04X\", *(short *)(data_object_address + (uint)current_index * 2));\n      }\n      if (message_buffer == '\\0') {\n        if (*(char *)(data_object_address + 7) == '\\0') {\n          process_data(\" (%d)\", *(short *)(data_object_address + (uint)current_index * 2));\n        }\n        else if ((*(char *)(data_object_address + 7) + 4 < 0 == SCARRY4((int)*(char *)(data_object_address + 7),4)) && (*(char *)(data_object_address + 7) < '\\0')) {\n          digits_count = count_digits_and_relocate(stack_buffer, *(short *)(data_object_address + (uint)current_index * 2), *(char *)(data_object_address + 7));\n          stack_buffer[digits_count] = 0;\n          process_data(\" (%s)\", stack_buffer);\n        }\n        else {\n          process_data(\" (%d, %d)\", *(short *)(data_object_address + (uint)current_index * 2), *(char *)(data_object_address + 7));\n        }\n      }\n      else {\n        process_data(\" (%d, '%c')\", *(short *)(data_object_address + (uint)current_index * 2), message_buffer);\n      }\n      uVar1 = get_label_by_param_value(*(undefined *)(data_object_address + 6));\n      process_data(\" [\", uVar1, \"]\\n\");\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003e9e",
                "FUN_00003918",
                "FUN_00003810"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_0000305c",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_difference_and_increment_if_not_equal_00002364",
                "param_1": "array",
                "param_2": "value",
                "iVar1": "is_equal",
                "uVar2": "return_value",
                "is_difference_equal_to_third_00002294": "is_difference_equal_to_third",
                "increment_and_set_value_at_index_000022be": "increment_and_set_value_at_index"
            },
            "code": "int check_difference_and_increment_if_not_equal_00002364(int* array, int value) {\n    int is_equal = is_difference_equal_to_third(array);\n    if (is_equal == 0) {\n        increment_and_set_value_at_index(array, value);\n        return 0;\n    }\n    else {\n        return -1;\n    }\n}",
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_difference_and_increment_if_not_equal_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "clear_bitmask_and_wait_until_set_00001ad4",
                "*DAT_00001b08": "data",
                "*PTR_DAT_00001b0c": "result",
                "bitmask": "bitmask"
            },
            "code": "void clear_bitmask_and_wait_until_set_00001ad4(void)\n{\n  unsigned char **DAT_00001b08 = DAT_00001b08;\n  unsigned char bitmask = 0x3f;\n  **DAT_00001b08 &= bitmask;\n  while ((*DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "clear_bitmask_and_wait_until_set_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "setup_system_and_enable_interrupts_00001274",
                "DAT_00001298": "data_pointer_1",
                "setup_flags_and_constants_0000258c": "setup_flags_and_constants",
                "initialize_system_00001c84": "initialize_system",
                "enable_interrupts_00002396": "enable_interrupts"
            },
            "code": "void setup_system_and_enable_interrupts_00001274(void)\n{\n  setup_flags_and_constants();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  initialize_system();\n  enable_interrupts();\n  return;\n}",
            "called": [
                "FUN_0000258c",
                "FUN_00001c84",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "setup_system_and_enable_interrupts_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "process_input_loop_and_parse_command_line_arguments_00002e6c",
                "param_1": "argc",
                "param_2": "argv",
                "param_3": "input_string",
                "iVar1": "input_processing_result",
                "process_data_and_return_00002e48": "process_data_and_return",
                "process_input_string_00002d94": "process_input_string",
                "parse_command_line_arguments_00002b10": "parse_command_line_arguments"
            },
            "code": "void process_input_loop_and_parse_command_line_arguments_00002e6c(int argc, char **argv, char *input_string) {\n  int input_processing_result;\n  process_data_and_return();\n  do {\n    input_processing_result = process_input_string(input_string, argc);\n    if (input_processing_result == 0) {\n      parse_command_line_arguments(argc, argv);\n    }\n    process_data_and_return();\n  } while (true);\n}",
            "called": [
                "FUN_00002d94",
                "FUN_00002b10",
                "FUN_00002e48"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "process_input_loop_and_parse_command_line_arguments_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "is_unix_time_converted_to_datetime_and_returned_zero_00003444",
                "iVar1": "conversion_result",
                "auStack_2c": "datetime",
                "convert_unix_time_to_datetime_and_return_zero_00002624": "convert_unix_time_to_datetime_and_return_zero",
                "PTR_s_rtc__error_getting_time_00003474": "PTR_s_rtc__error_getting_time",
                "process_data_00003378": "process_data"
            },
            "code": "bool is_unix_time_converted_to_datetime_and_returned_zero_00003444(void)\n{\n  int conversion_result;\n  undefined datetime[36];\n  \n  conversion_result = convert_unix_time_to_datetime_and_return_zero(datetime);\n  if (conversion_result != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_time_00003474_00003474);\n  }\n  else {\n    process_data(datetime);\n  }\n  return conversion_result != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002624"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "is_unix_time_converted_to_datetime_and_returned_zero_00003444",
            "code_backup": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = convert_unix_time_to_datetime_and_return_zero_00002624(auStack_2c);\n  if (iVar1 != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    process_data_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "synchronize_data_00003688",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void synchronize_data_00003688() \n{\n    synchronize_data_00003688_00003658();\n    return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_memory_location_to_one_00001392",
                "param_1": "address",
                "param_2": "size",
                "puVar1": "memory_location"
            },
            "code": "void set_memory_location_to_one_00001392(void* address, size_t size)\n{\n  undefined4 *memory_location;\n  memory_location = (undefined4 *)calculate_address(address, size);\n  *memory_location = 1;\n  return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_memory_location_to_one_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "reset_data_00002910",
                "DAT_00002944": "DATA_ADDRESS",
                "PTR_DAT_00002948": "DATA_POINTER",
                "iVar1": "data_address",
                "*(uint *)(DAT_00002944 + 0x1c)": "data_ptr",
                "*(undefined4 *)(iVar1 + 8)": "var1",
                "*(undefined4 *)PTR_DAT_00002948": "var2",
                "*(undefined4 *)(PTR_DAT_00002948 + 4)": "var3"
            },
            "code": "void reset_data_00002910(void)\n{\n  int data_address = DAT_00002944;\n  uint* *(uint *)(DAT_00002944 + 0x1c) = (uint*)(data_address + 0x1c);\n  **(uint *)(DAT_00002944 + 0x1c) = (**(uint *)(DAT_00002944 + 0x1c)) & 0xfffffffb;\n  *(undefined4 *)(data_address + 8) = 0;\n  *(undefined4 *)PTR_DAT_00002948 = 0;\n  *(undefined4 *)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "reset_data_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "readByteFromBlock_00004418",
                "*DAT_00004438": "blockPointer",
                "initialize_blocks_000042a4": "initializeBlocks",
                "PTR_DAT_00005620": "blockPointerConstant1",
                "PTR_DAT_00005624": "blockPointerConstant2",
                "PTR_DAT_00005628": "blockPointerConstant3",
                "**ppbVar2": "blockPtr",
                "*pbVar3": "bytePtr",
                "iVar4": "blockAddr",
                "uVar1": "byteValue"
            },
            "code": "uint readByteFromBlock_00004418()\n{\n  uint byteValue;\n  byte **blockPtr;\n  byte *bytePtr;\n  int blockAddr = **DAT_00004438;\n  if ((blockAddr != 0) && (*(int *)(blockAddr + 0x18) == 0)) {\n    initialize_blocks_000042a4(blockAddr);\n  }\n  blockPtr = *(byte ***)(blockAddr + 4);\n  if ((blockAddr != 0) && (*(int *)(blockAddr + 0x18) == 0)) {\n    initialize_blocks_000042a4();\n  }\n  if (blockPtr == (byte **)PTR_DAT_00005620) {\n    blockPtr = *(byte ***)(blockAddr + 4);\n  }\n  else if (blockPtr == (byte **)PTR_DAT_00005624) {\n    blockPtr = *(byte ***)(blockAddr + 8);\n  }\n  else if (blockPtr == (byte **)PTR_DAT_00005628) {\n    blockPtr = *(byte ***)(blockAddr + 0xc);\n  }\n  if ((-1 < (int)blockPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(blockPtr + 3) << 0x16))) {\n    do_nothing_000045e8(blockPtr[0x16]);\n  }\n  bytePtr = blockPtr[1];\n  blockPtr[1] = bytePtr + -1;\n  if ((int)(bytePtr + -1) < 0) {\n    byteValue = readByte_00005e10(blockAddr,blockPtr);\n  }\n  else {\n    bytePtr = *blockPtr;\n    *blockPtr = bytePtr + 1;\n    byteValue = (uint)*bytePtr;\n  }\n  if ((-1 < (int)blockPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(blockPtr + 3) << 0x16))) {\n    do_nothing_000045ec(blockPtr[0x16]);\n  }\n  return byteValue;\n}",
            "called": [
                "FUN_000045e8",
                "FUN_00005e10",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "readByteFromBlock_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "setup_flags_and_constants_0000258c",
                "local_c": "index"
            },
            "code": "void setup_flags_and_constants_0000258c(void)\n{\n  uint8_t index;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  store_byte_00002538(0xfffffffe, 1);\n  store_byte_00002538(0xfffffffb, 1);\n  for (index = 0; index < 0x66; index++) {\n    store_byte_00002538((int)(char)index, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "setup_flags_and_constants_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "process_data_wrapper_00002a00",
                "param_1": "data"
            },
            "code": "void process_data_wrapper_00002a00(void* data){\n  process_data(data);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002d94",
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_wrapper_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "count_valid_items_000043a0",
                "param_1": "item_count",
                "param_2": "callback_function",
                "piVar2": "item_ptr",
                "uVar1": "count",
                "iVar3": "item_data_ptr",
                "uVar4": "total_count",
                "iVar5": "item_count"
            },
            "code": "uint count_valid_items_000043a0(int item_count, code *callback_function) {\n  uint total_count = 0;\n  int *item_ptr = (int *)(item_count + 0x48);\n  do {\n    int item_count = item_ptr[1];\n    int item_data_ptr = item_ptr[2];\n    while (item_count = item_count + -1, -1 < item_count) {\n      if ((1 < *(ushort *)(item_data_ptr + 0xc)) && (*(short *)(item_data_ptr + 0xe) != -1)) {\n        uint count = (*callback_function)(item_data_ptr);\n        total_count = total_count | count;\n      }\n      item_data_ptr = item_data_ptr + 0x68;\n    }\n    item_ptr = (int *)*item_ptr;\n  } while (item_ptr != (int *)0x0);\n  return total_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "count_valid_items_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_relocation_info_0000211c",
                "local_40": "relocation_value",
                "local_3c": "relocation_offset",
                "local_38": "relocation_address",
                "local_34": "relocation_table_ptr",
                "local_30": "relocation_type",
                "local_2c": "relocation_ptr",
                "local_28": "relocation_symbol",
                "local_24": "relocation_table_ptr",
                "local_20": "total_relocations",
                "local_1a": "relocation_index",
                "local_18": "total_distance",
                "local_14": "relocation_distance_to_start"
            },
            "code": "void print_relocation_info_0000211c(void)\n{\n  int total_relocations = 0;\n  int total_distance = 0;\n  uint8_t relocation_index = 0;\n  uint16_t relocation_type = 0;\n  uint32_t relocation_address = 0;\n  uint32_t relocation_value = 0;\n  uint32_t relocation_offset = 0;\n  uint32_t relocation_size = 0;\n  uint32_t relocation_symbol = 0;\n  uint32_t relocation_section = 0;\n  uint32_t relocation_addend = 0;\n  uint32_t *relocation_ptr = NULL;\n  uint32_t *relocation_table_ptr = NULL;\n  uint32_t *relocation_table_end_ptr = NULL;\n  process_data_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248);\n  total_relocations = get_num_relocations_000008b8();\n  relocation_table_ptr = get_pointer_data_0000091c();\n  relocation_table_end_ptr = get_main_stack_pointer_00000900();\n  process_data_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,total_relocations,relocation_table_ptr,relocation_table_end_ptr);\n  total_distance += 0x200;\n  if (total_relocations > 0) {\n    total_distance += total_relocations;\n  }\n  for (relocation_index = 1; relocation_index < 0x21; relocation_index++) {\n    relocation_ptr = *(uint32_t **)(PTR_DAT_00002258 + relocation_index * 4);\n    if (relocation_ptr != NULL) {\n      relocation_type = *(uint16_t *)(relocation_ptr + 1);\n      relocation_table_ptr = (uint32_t *)(DAT_0000225c + relocation_type * 4);\n      relocation_address = (uint32_t)(&relocation_value) + (uint32_t)(8 < relocation_type);\n      relocation_offset = relocation_ptr[0xb];\n      total_distance += relocation_offset;\n      relocation_distance_to_start = calculate_distance_to_start_000010a0(relocation_ptr[9]);\n      relocation_offset -= relocation_distance_to_start;\n      total_relocations += relocation_offset;\n      process_data_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   *(int16_t *)((int)relocation_ptr + 6),relocation_ptr[10],relocation_table_ptr,relocation_address,\n                   *(uint8_t *)((int)relocation_ptr + 5),relocation_ptr[0xb],relocation_offset,relocation_ptr[9],*relocation_ptr);\n    }\n  }\n  process_data_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,total_distance,total_relocations);\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000008b8",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_0000091c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "print_relocation_info_0000211c",
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  undefined4 local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUNC_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248\n              );\n  local_20 = get_num_relocations_000008b8();\n  local_24 = get_pointer_data_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUNC_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(PTR_DAT_00002258 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = *(undefined4 *)(DAT_0000225c + local_30 * 4);\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = calculate_distance_to_start_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUNC_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUNC_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_key_index_0000562c",
                "param_1": "param",
                "param_2": "key",
                "param_3": "key_indices",
                "cVar1": "current_char",
                "ppiVar2": "key_list_ptr",
                "piVar3": "current_key_ptr",
                "iVar4": "comparison_result",
                "pcVar5": "key_ptr",
                "piVar6": "current_key_indices_ptr",
                "iVar7": "key_length"
            },
            "code": "int find_key_index_0000562c(undefined4 param_1, char *key, int *key_indices) {\n  char current_char;\n  int **key_list_ptr = DAT_0000569c;\n  if (*DAT_0000569c != (int *)0x0) {\n    do {\n      current_char = *key;\n      if (current_char == '\\0') {\n        int key_length = (int)key - (int)param_2;\n        int *current_key_ptr = *DAT_0000569c;\n        while (true) {\n          int *current_key_indices_ptr = current_key_ptr;\n          if (*current_key_indices_ptr == 0) break;\n          int comparison_result = compare_byte_arrays_00004e66(*current_key_indices_ptr, key, key_length);\n          current_key_ptr = current_key_indices_ptr + 1;\n          if ((comparison_result == 0) && (comparison_result = *current_key_indices_ptr, *(char *)(comparison_result + key_length) == '=')) {\n            *key_indices = (int)current_key_indices_ptr - (int)*key_list_ptr >> 2;\n            do_nothing_with_data_00005ff8(param_1);\n            return comparison_result + key_length + 1;\n          }\n        }\n        break;\n      }\n      key = key + 1;\n    } while (current_char != '=');\n  }\n  do_nothing_with_data_00005ff8(param_1);\n  return 0;\n}",
            "called": [
                "FUN_00005fec",
                "FUN_00005ff8",
                "FUN_00004e66"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_key_index_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "extract_bits_and_call_function_if_flag_set_000020b8",
                "DAT_000020c8": "data",
                "PTR_": "flag"
            },
            "code": "void extract_bits_and_call_function_if_flag_set_000020b8(uint8_t* DAT_000020c8, int PTR_) {\n  extract_bits_and_call_function_if_flag_set_000020b8(DAT_000020c8, PTR_);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_if_flag_set_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_matching_byte_sequence_00002a18",
                "param_1": "possible_matches",
                "param_2": "byte_to_match",
                "local_18": "sequences",
                "local_10": "sequence_index",
                "local_c": "current_sequence",
                "iVar1": "match_result"
            },
            "code": "int find_matching_byte_sequence_00002a18(int* possible_matches, uint8_t byte_to_match) {\n  int* current_sequence;\n  int sequence_index = 0;\n  int* sequences[2] = {possible_matches, PTR_PTR_s_reboot_00002a84};\n  while (sequence_index < 2) {\n    current_sequence = sequences[sequence_index];\n    if (current_sequence != NULL) {\n      while (*current_sequence != 0) {\n        int match_result = compare_bytes_00004e52(*current_sequence, byte_to_match);\n        if (match_result == 0) {\n          return current_sequence[2];\n        }\n        current_sequence += 3;\n      }\n    }\n    sequence_index++;\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "find_matching_byte_sequence_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "clean_device_data_000054a8",
                "*param_1": "*output",
                "*param_2": "*input",
                "uVar1": "device_status",
                "uVar2": "device_status_copy",
                "uVar3": "device_status_copy_uint",
                "uVar4": "device_status_uint",
                "iVar5": "device_data_ptr"
            },
            "code": "uint clean_device_data_000054a8(undefined4 *output, undefined4 *input)\n{\n  ushort device_status;\n  ushort device_status_copy;\n  uint device_status_copy_uint;\n  uint device_status_uint;\n  int device_data_ptr;\n  \n  device_data_ptr = *device_data_global_ptr;\n  if ((device_data_ptr != 0) && (*(int *)(device_data_ptr + 0x18) == 0)) {\n    clean_device_data_000054a8(device_data_ptr);\n  }\n  if (input == (undefined4 *)device_data_ptr_1) {\n    input = *(undefined4 **)(device_data_ptr + 4);\n  }\n  else if (input == (undefined4 *)device_data_ptr_2) {\n    input = *(undefined4 **)(device_data_ptr + 8);\n  }\n  else if (input == (undefined4 *)device_data_ptr_3) {\n    input = *(undefined4 **)(device_data_ptr + 0xc);\n  }\n  device_status_uint = (uint)*(ushort *)(input + 3);\n  device_status_copy = *(ushort *)(input + 3);\n  if (-1 < (int)(device_status_uint << 0x1c)) {\n    if (-1 < (int)(device_status_uint << 0x1b)) {\n      *output = 9;\n      goto LAB_000054d8;\n    }\n    if ((undefined4 *)input[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)input[0xd] != input + 0x11) {\n        insert_node_at_position_00004b34(output);\n      }\n      input[0xd] = 0;\n    }\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n    input[1] = 0;\n    *input = input[4];\n  }\n  *(ushort *)(input + 3) = *(ushort *)(input + 3) | 8;\n  if ((input[4] == 0) && ((*(ushort *)(input + 3) & 0x280) != 0x200)) {\n    initialize_device_data(output, input);\n  }\n  device_status_copy_uint = (uint)device_status_copy;\n  if ((device_status_copy & 1) == 0) {\n    if (-1 < (int)(device_status_copy_uint << 0x1e)) {\n      device_status_uint = input[5];\n    }\n    input[2] = device_status_uint;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((device_status_copy & 0x80) == 0) {\n    return device_status_uint & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(input + 3) = device_status_copy | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "clean_device_data_000054a8",
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *DAT_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    FUNC_000042a4(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          insert_node_at_position_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    initialize_device_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "allocate_memory_000007dc",
                "param_1": "val1",
                "param_2": "val2",
                "param_3": "val3",
                "param_4": "size",
                "uVar1": "aligned_size",
                "local_14": "i",
                "local_10": "i",
                "local_c": "memory"
            },
            "code": "int * allocate_memory_000007dc(uint32_t size, int val1, int val2, int val3)\n{\n  uint32_t aligned_size = (size + val3) & 0xfffffffc;\n  int *memory = (int *)(aligned_size - 4);\n  *memory = 0x77777777;\n  if (((uint32_t)memory & 7) != 0) {\n    memory = (int *)(aligned_size - 8);\n    *memory = 0x88888888;\n  }\n  memory[-1] = 0x1000000;\n  memory[-2] = val1;\n  memory[-3] = DAT_000008b4;\n  memory = memory - 4;\n  *memory = 0;\n  for (int i = 3; i > 0; i--) {\n    memory--;\n    *memory = i;\n  }\n  memory--;\n  *memory = val2;\n  for (int i = 0xb; i > 3; i--) {\n    memory--;\n    *memory = i;\n  }\n  memory[-1] = -3;\n  return memory - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "allocate_memory_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_memory_at_calculated_address_00001710",
                "param_1": "address",
                "param_2": "value",
                "puVar1": "address_to_clear"
            },
            "code": "void clear_memory_at_calculated_address_00001710(int address, char value) {\n    char *address_to_clear = (char *)calculate_address(address, value);\n    *address_to_clear = 0;\n    return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_00001778",
                "FUN_00001734",
                "FUN_0000182c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "clear_memory_at_calculated_address_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_0000579c",
                "FUN_00004158",
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "find_and_set_next_item_00001034",
                "param_1": "list",
                "param_2": "item_index",
                "local_1c": "current_item"
            },
            "code": "void find_and_set_next_item_00001034(int **list, int item_index) {\n  int **current_item;\n  if (item_index > 8) {\n    process_data_and_print_relocation_info_00000f04(3, PTR_s_FAILED_ASSERTION__0000109c);\n  }\n  for (current_item = list; (*current_item != (int *)0x0 && (*(byte *)((int)*current_item + -3) <= *(byte *)(item_index + 5))); current_item = (int **)*current_item) {\n  }\n  *(int **)(item_index + 8) = *current_item;\n  *current_item = (int *)(int **)(item_index + 8);\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "find_and_set_next_item_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_result_00006964",
                "param_1": "array_start",
                "param_2": "index",
                "iVar1": "array_end"
            },
            "code": "int calculate_result_00006964(int array_start, int index) {\n  int array_end = *(int *)(index + -4) + -4;\n  if (*(int *)(index + -4) < 0) {\n    array_end += *(int *)(index + array_end);\n  }\n  return array_end;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_result_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_memory_and_set_flag_0000182c",
                "PTR_000018b4": "memory_address",
                "DAT_000018b8": "flag_address"
            },
            "code": "void clear_memory_and_set_flag_0000182c(void)\n{\n  byte *PTR_000018b4 = (byte *)(DAT_000018b4 + 8);\n  *PTR_000018b4 &= 0xd0;\n  set_flag(DAT_000018b8, 0);\n  clear_memory(DAT_000018b4);\n  clear_memory(DAT_000018b4);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_memory_and_set_flag_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "FUNC_00004db8"
            },
            "code": "\nundefined4 FUNC_00004db8(int param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  char **ppcVar5;\n  undefined4 uVar6;\n  char *pcVar7;\n  \n  iVar3 = *DAT_00004dc4;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    initialize_blocks_000042a4();\n  }\n  ppcVar5 = *(char ***)(iVar3 + 8);\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    initialize_blocks_000042a4(iVar3);\n  }\n  if (ppcVar5 == (char **)PTR_DAT_00004dac) {\n    ppcVar5 = *(char ***)(iVar3 + 4);\n  }\n  else if (ppcVar5 == (char **)PTR_DAT_00004db0) {\n    ppcVar5 = *(char ***)(iVar3 + 8);\n  }\n  else if (ppcVar5 == (char **)PTR_DAT_00004db4) {\n    ppcVar5 = *(char ***)(iVar3 + 0xc);\n  }\n  if ((-1 < (int)ppcVar5[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar5 + 3) << 0x16))) {\n    do_nothing_000045e8(ppcVar5[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ppcVar5 + 3) << 0x1c) < 0) && (ppcVar5[4] != (char *)0x0)) ||\n     (iVar2 = clean_device_data_000054a8(iVar3,ppcVar5), iVar2 == 0)) {\n    pcVar7 = (char *)(param_1 + -1);\n    do {\n      while( true ) {\n        pcVar7 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar4 = ppcVar5[2] + -1;\n        ppcVar5[2] = pcVar4;\n        if (cVar1 == '\\0') {\n          if (-1 < (int)pcVar4) {\n            pcVar7 = *ppcVar5;\n            uVar6 = 10;\n            *ppcVar5 = pcVar7 + 1;\n            *pcVar7 = '\\n';\n            goto LAB_00004d64;\n          }\n          iVar3 = process_device_data_00005404(iVar3,10,ppcVar5);\n          if (iVar3 != -1) {\n            uVar6 = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)pcVar4 < 0) && (((int)pcVar4 < (int)ppcVar5[6] || (cVar1 == '\\n')))) break;\n        pcVar4 = *ppcVar5;\n        *ppcVar5 = pcVar4 + 1;\n        *pcVar4 = cVar1;\n      }\n      iVar2 = process_device_data_00005404(iVar3,cVar1,ppcVar5);\n    } while (iVar2 != -1);\n  }\nLAB_00004d60:\n  uVar6 = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)ppcVar5[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar5 + 3) << 0x16))) {\n    do_nothing_000045ec(ppcVar5[0x16]);\n  }\n  return uVar6;\n}\n\n",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_000031e0",
                "FUN_000033f4",
                "FUN_00002fe0",
                "FUN_00002f30",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000033c0",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003478",
                "FUN_000023a4",
                "FUN_000034c0"
            ],
            "imported": false,
            "current_name": "FUNC_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "increment_and_return_value_at_index_000022f0",
                "param_1": "array",
                "uVar1": "index",
                "param_1[2]": "array[2]",
                "param_1[1]": "array[1]",
                "*(undefined *)((uVar1 & param_1[1] - 1U) + *param_1)": "*(undefined *)((masked_index) + *array)"
            },
            "code": "undefined increment_and_return_value_at_index_000022f0(int *array)\n{\n  uint index = array[2];\n  array[2] = index + 1;\n  uint mask = array[1] - 1U;\n  uint masked_index = index & mask;\n  return *(undefined *)((masked_index) + *array);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_and_return_value_at_index_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "uVar1": "interrupts_enabled_state",
                "getIRQInterruptsEnabledState_00000cd0": "getIRQInterruptsEnabledState",
                "clear_memory_if_flag_set_or_set_flag_and_clear_memory_00001bb8": "clearMemoryIfFlagSetOrSetFlagAndClearMemory",
                "DAT_00001ce8": "systemData",
                "clear_memory_and_set_flag_0000182c": "clearMemoryAndSetFlag",
                "set_calculated_address_to_one_000017dc": "setCalculatedAddressToOne",
                "execute_system_command_00001b10": "executeSystemCommand",
                "enable_interrupts_if_privileged_00000d0c": "enableInterruptsIfPrivileged"
            },
            "code": "void initialize_system_00001c84(void)\n{\n    int interrupts_enabled_state = getIRQInterruptsEnabledState();\n    clearMemoryIfFlagSetOrSetFlagAndClearMemory();\n    *(unsigned int *)(DAT_00001ce8 + 0x1044) = 0x220000;\n    DAT_00001ce8[0xc] = 0;\n    *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n    DAT_00001ce8[4] = 0x13;\n    DAT_00001ce8[5] = 0;\n    clearMemoryAndSetFlag();\n    setCalculatedAddressToOne();\n    executeSystemCommand(7);\n    enableInterruptsIfPrivileged(interrupts_enabled_state);\n}",
            "called": [
                "FUN_00001bb8",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_0000182c",
                "FUN_00001b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_system_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_or_insert_block_of_memory_000068f0",
                "param_1": "allocation_size",
                "param_2": "memory_block_pointer",
                "iVar1": "current_block_pointer",
                "iVar2": "current_block_size"
            },
            "code": "undefined4 allocate_or_insert_block_of_memory_000068f0(undefined4 allocation_size, int *memory_block_pointer)\n{\n  int current_block_pointer;\n  int current_block_size;\n  \n  if ((int *)memory_block_pointer[0xd] == memory_block_pointer + 0x11) { // if the current block is full\n    current_block_pointer = allocate_memory_block_00004bd0(allocation_size, 0x400); // allocate a new block\n    if (current_block_pointer != 0) { // if allocation was successful\n      memory_block_pointer[0xe] = 0x400; // set the size of the new block\n      memory_block_pointer[0xd] = current_block_pointer; // set the pointer to the new block\n      *(undefined *)(current_block_pointer + 0x3ff) = *(undefined *)((int)memory_block_pointer + 0x46);\n      *(undefined *)(current_block_pointer + 0x3fe) = *(undefined *)((int)memory_block_pointer + 0x45);\n      *(undefined *)(current_block_pointer + 0x3fd) = *(undefined *)(memory_block_pointer + 0x11);\n      *memory_block_pointer = current_block_pointer + 0x3fd;\n      return 0;\n    }\n  }\n  else { // if the current block has free space\n    current_block_size = memory_block_pointer[0xe];\n    current_block_pointer = allocate_and_insert_node_000060cc(allocation_size, (int *)memory_block_pointer[0xd], current_block_size << 1); // double the size of the current block\n    if (current_block_pointer != 0) { // if allocation was successful\n      copy_string_000060b0(current_block_pointer + current_block_size, current_block_pointer, current_block_size);\n      memory_block_pointer[0xd] = current_block_pointer; // set the pointer to the current block\n      memory_block_pointer[0xe] = current_block_size << 1; // set the size of the current block\n      *memory_block_pointer = current_block_pointer + current_block_size;\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_000060cc",
                "FUN_00004bd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "allocate_or_insert_block_of_memory_000068f0"
        }
    },
    "used_tokens": 185817,
    "layers": [
        [
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_00005584",
            "FUN_00001da2",
            "FUN_00002744",
            "FUN_00001e0c",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_000039e8",
            "FUN_00002294",
            "FUN_00003810",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00000cf0",
            "FUN_00002538",
            "FUN_0000058e",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_0000091c",
            "FUN_00000d44",
            "FUN_00000cd0",
            "FUN_00000d2a",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00001dc0",
            "FUN_000026f0",
            "FUN_00001d5e",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00001d80",
            "FUN_000023c8",
            "FUN_0000428c",
            "FUN_000010a0",
            "FUN_00006010",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000060b0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_000045ee",
            "FUN_00006974",
            "FUN_00005ebc",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_00001ad4",
            "FUN_00002910",
            "FUN_000043a0",
            "FUN_000007dc",
            "FUN_00006964",
            "FUN_000022f0"
        ],
        [
            "FUN_000026c0",
            "FUN_00005e68",
            "FUN_00000e58",
            "FUN_000026d8",
            "FUN_000016ec",
            "FUN_00001ec4",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_00004f98",
            "FUN_00000428",
            "FUN_00000e38",
            "FUN_00002600",
            "FUN_00004042",
            "FUN_00002894",
            "FUN_00000d76",
            "FUN_000026e4",
            "FUN_00000698",
            "FUN_00001ff6",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_000056b8",
            "FUN_00003ff4",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002798",
            "FUN_0000231c",
            "FUN_00001cf0",
            "FUN_000023d0",
            "FUN_00005fd8",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_000016c8",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000610",
            "FUN_00002364",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_0000258c",
            "FUN_0000562c",
            "FUN_00002a18",
            "FUN_00001710"
        ],
        [
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_00001778",
            "FUN_00002624",
            "FUN_00001628",
            "FUN_000017dc",
            "FUN_00004dee",
            "FUN_00002654",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_000024bc",
            "FUN_00002994",
            "FUN_00000d9c",
            "FUN_00001bb8",
            "FUN_0000404c",
            "FUN_000056a0",
            "FUN_00002690",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00005780",
            "FUN_00002028",
            "FUN_00001a60",
            "FUN_000018bc",
            "FUN_0000182c"
        ],
        [
            "FUN_00004248",
            "FUN_000020e0",
            "FUN_00000db0",
            "FUN_000020f4",
            "FUN_00001688",
            "FUN_000012b4",
            "FUN_00001f80",
            "FUN_00001a18",
            "FUN_0000191c",
            "FUN_000060cc",
            "FUN_00002108",
            "FUN_00005700",
            "FUN_000019c0",
            "FUN_00001a3c",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_000020b8"
        ],
        [
            "FUN_00001eea",
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84"
        ],
        [
            "FUN_00001274"
        ],
        [
            "FUN_000031e0",
            "FUN_000034c0",
            "FUN_000033f4",
            "FUN_00003478"
        ],
        [
            "FUN_00003378",
            "FUN_00000ed8",
            "FUN_0000211c"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00002a88",
            "FUN_000033c0",
            "FUN_00002f74",
            "FUN_00003444"
        ],
        [
            "FUN_00004158",
            "FUN_00004c84",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_00002b10",
            "FUN_00003524",
            "FUN_000042a4"
        ],
        [
            "FUN_00006768",
            "FUN_00005404"
        ],
        [
            "FUN_000057a8",
            "FUN_00005e10",
            "FUN_00004cb4"
        ],
        [
            "FUN_000057d2",
            "FUN_00004418",
            "FUN_00002a00"
        ],
        [
            "FUN_00002e48",
            "FUN_00002d94"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000fec",
            "FUN_00000cc0",
            "FUN_000013b8",
            "FUN_00003ec4",
            "FUN_00000a30",
            "FUN_00001034"
        ],
        [
            "FUN_00000dc0",
            "FUN_00003e9e",
            "FUN_00000e64",
            "FUN_00000df4",
            "FUN_00002434",
            "FUN_000010d4"
        ],
        [
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_00003694"
        ],
        [
            "FUN_0000459c",
            "FUN_0000305c",
            "FUN_00002ecc",
            "FUN_000012e2"
        ],
        [
            "FUN_00002f30",
            "FUN_00000e14",
            "FUN_0000099c"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ]
    ],
    "locked_functions": []
}