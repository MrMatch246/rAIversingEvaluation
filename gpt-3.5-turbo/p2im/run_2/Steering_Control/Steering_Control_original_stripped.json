{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_completed_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeCompletedFlag_000800f4(undefined4 input)\n\n{\n  if ((char)isCompleted == '\\0') {\n    isCompleted._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_completed_flag_000800f4",
                "param_1": "input",
                "completed_7857": "isCompleted"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080148": {
            "entrypoint": "0x00080148",
            "current_name": "trigger_software_interrupt_00080148",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t triggerSoftwareInterrupt_00080148(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_00080148": "trigger_software_interrupt_00080148"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008014c": {
            "entrypoint": "0x0008014c",
            "current_name": "execute_afl_call_0008014c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_0008014c(int ticks)\n\n{\n  uint32_t result;\n  \n  if (noHyperCall == 0) {\n    result = aflCall(1,ticks,0);\n    return result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008014c": "execute_afl_call_0008014c",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_servos_00080164",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServos_00080164(void)\n\n{\n  void *dataBuffer;\n  size_t dataSize;\n  \n  Servo::write(&throttle,0x5a,dataBuffer,dataSize);\n  Servo::write(&steering,0x5a,dataBuffer,dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_servos_00080164",
                "in_r2": "dataBuffer",
                "in_r3": "dataSize"
            },
            "calling": [
                "loop",
                "setup"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080184": {
            "entrypoint": "0x00080184",
            "current_name": "initialize_servos_00080184",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServos_00080184(void)\n\n{\n  undefined4 unusedParameter;\n  \n  Servo::Servo(&steeringServo);\n  Servo::Servo(&throttleServo);\n  String::String(&emptyCommand,\"\");\n  __aeabi_atexit(&emptyCommand,0x81473,&__dso_handle);\n  String::String(&emptyValue,\"\");\n  __aeabi_atexit(&emptyValue,0x81473,&__dso_handle,unusedParameter);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080184": "initialize_servos_00080184",
                "in_r3": "unusedParameter",
                "steering": "steeringServo",
                "throttle": "throttleServo",
                "command": "emptyCommand",
                "value": "emptyValue"
            },
            "calling": [],
            "called": [
                "Servo",
                "String",
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_robot_000801e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRobot_000801e0(void)\n\n{\n  UARTClass::begin(&serial,0xe100);\n  pinMode(0xd,1);\n  pinMode(6,1);\n  pinMode(0x39,0);\n  pinMode(4,0);\n  pinMode(3,0);\n  pinMode(2,0);\n  Servo::attach(&steeringServo,5);\n  Servo::attach(&throttleServo,6);\n  straightAndStop();\n  delay(1000);\n  startForkserver(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_robot_000801e0",
                "Serial": "serial",
                "steering": "steeringServo",
                "throttle": "throttleServo"
            },
            "calling": [
                "main"
            ],
            "called": [
                "straightAndStop",
                "delay",
                "attach",
                "begin",
                "startForkserver",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_function_00080250",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid controlFunction_00080250(void)\n\n{\n  uchar uVar1;\n  uint32_t value;\n  int rawMotorInput;\n  int bytesAvailable;\n  long fileDescriptor;\n  Servo *servoObject;\n  uint currentLEDstatus;\n  int fileDescriptor_00;\n  int inChargeFlag;\n  int inChargeFlag_00;\n  int fileDescriptor_01;\n  void *pointerVariable;\n  size_t sizeVariable;\n  textString stackVariable;\n  \n  receiverMode = measurePulse(4,1,20000);\n  pause(10);\n  currentLEDstatus = (uint)LEDstatus;\n  LEDstatus = SUB41(currentLEDstatus ^ 1,0);\n  setDigitalOutput(0valued,currentLEDstatus ^ 1);\n  if (receiverMode < 0value641) {\n    if (receiverMode - 0value385U < 299) {\n      if (autonomousMode != false) {\n        stopMotion();\n        Printer::printLine((Printer *)&Serial,\"Entered manual control autonomousMode.\");\n        autonomousMode = false;\n      }\n      pause(10);\n      value = measurePulse(3,1,20000);\n      receiverSteering = scaleRange(0,1000,2000,0value28,0value96);\n      pointerVariable = (void *)0value7d0;\n      sizeVariable = 0value28;\n      rvalueMotor = scaleRange(value,1000,2000,0value28,0value96);\n      while (bytesAvailable = UART::checkAvailable(&Serial), 0 < bytesAvailable) {\n        UART::readBytes(&Serial,fileDescriptor_00,pointerVariable,sizeVariable);\n        Printer::print((Printer *)&Serial,receiverSteering,10);\n        Printer::print((Printer *)&Serial,\",\");\n        pointerVariable = (void *)0valuea;\n        Printer::printLine((Printer *)&Serial,rvalueMotor,10);\n      }\n      Servo::setAngle(&throttle,rvalueMotor,pointerVariable,sizeVariable);\n      Servo::setAngle(&steering,receiverSteering,pointerVariable,sizeVariable);\n    }\n    else {\n      if (autonomousMode == false) {\n        stopMotion();\n        Printer::printLine((Printer *)&Serial,\"Entered autonomous control autonomousMode.\");\n      }\n      sizeVariable = 1;\n      autonomousMode = true;\nLAB_00080346:\n      bytesAvailable = UART::checkAvailable(&Serial);\n      if (0 < bytesAvailable) {\n        DataStream::readBytestextStringUntil((DataStream *)&Serial,',');\n        textString::operator=(&command,&stackVariable);\n        textString::~textString(&stackVariable,inChargeFlag);\n        pointerVariable = (void *)0valuea;\n        DataStream::readBytestextStringUntil((DataStream *)&Serial,'\\n');\n        textString::operator=(&value,&stackVariable);\n        textString::~textString(&stackVariable,inChargeFlag_00);\n        UART::readBytes(&Serial,fileDescriptor_01,pointerVariable,sizeVariable);\n        uVar1 = textString::isSame(&command,\"steer\");\n        if (uVar1 == '\\0') goto LAB_0008039c;\n        fileDescriptor = textString::toInteger(&value);\n        servoObject = &steering;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    stopMotion();\n    Printer::printLine((Printer *)&Serial,\"error\");\n  }\n  return;\nLAB_0008039c:\n  uVar1 = textString::isSame(&command,\"motor\");\n  if (uVar1 != '\\0') {\n    fileDescriptor = textString::toInteger(&value);\n    servoObject = &throttle;\nLAB_000803b2:\n    Servo::setAngle(servoObject,fileDescriptor,pointerVariable,sizeVariable);\n  }\n  goto LAB_00080346;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_function_00080250",
                "rxMotorRaw": "rawMotorInput",
                "iVar2": "bytesAvailable",
                "__fd": "fileDescriptor",
                "this": "servoObject",
                "uVar3": "currentLEDstatus",
                "__in_chrg": "inChargeFlag",
                "__in_chrg_00": "inChargeFlag_00",
                "SStack_1c": "stackVariable",
                "rxMode": "receiverMode",
                "rxSteer": "receiverSteering",
                "mode": "autonomousMode",
                "x": "value",
                "__fd_00": "fileDescriptor_00",
                "__fd_01": "fileDescriptor_01",
                "pvVar4": "pointerVariable",
                "sVar5": "sizeVariable",
                "UARTClass": "UART",
                "Print": "Printer",
                "pulseIn": "measurePulse",
                "digitalWrite": "setDigitalOutput",
                "delay": "pause",
                "map": "scaleRange",
                "available": "checkAvailable",
                "read": "readBytes",
                "println": "printLine",
                "write": "setAngle",
                "straightAndStop": "stopMotion",
                "String": "textString",
                "Stream": "DataStream",
                "equals": "isSame",
                "toInt": "toInteger"
            },
            "calling": [
                "main"
            ],
            "called": [
                "println",
                "print",
                "write",
                "pulseIn",
                "available",
                "equals",
                "~String",
                "straightAndStop",
                "readStringUntil",
                "operator=",
                "println",
                "delay",
                "toInt",
                "digitalWrite",
                "map",
                "read",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "configure_timer_channel_000803fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoperipheralID configureTimerChannel_000803fc(Tc *timer,uint32_t channel,uint32_t peripheralID,IRQn_Type interruptNumber)\n\n{\n  pmc_enable_periph_clk(peripheralID);\n  TC_Configure(timer,channel,0xc002);\n  TC_SetRA(timer,channel,0xa41);\n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interruptNumber & 0x1fU);\n  timer->TC_CHANNEL[channel].TC_IER = 4;\n  TC_Start(timer,channel);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "configure_timer_channel_000803fc",
                "tc": "timer",
                "id": "peripheralID",
                "irqn": "interruptNumber"
            },
            "calling": [
                "attach"
            ],
            "called": [
                "TC_SetRA",
                "pmc_enable_periph_clk",
                "TC_Configure",
                "TC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_servo_timer_0008044c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateServoTimer_0008044c(sequence16_Sequence_t sequence,Tc *timerCounter,uint8_t channelIndex)\n\n{\n  uint timerIndex;\n  uint servoCount;\n  RwReg reloadValue;\n  int offset;\n  \n  timerIndex = (uint)sequence;\n  if ((channelArray[timerIndex] & 0x80U) == 0) {\n    offset = timerIndex * 0xc;\n    if ((channelArray[timerIndex] + offset < (int)(uint)totalServos) &&\n       ((int)((uint)(byte)servoArray[channelArray[timerIndex] + offset].Pin << 0x19) < 0)) {\n      digitalWrite((byte)servoArray[offset + channelArray[timerIndex]].Pin & 0x3f,0);\n    }\n  }\n  else {\n    timerCounter->TC_CHANNEL[channelIndex].TC_CCR = timerCounter->TC_CHANNEL[channelIndex].TC_CCR | 4;\n  }\n  servoCount = (uint)totalServos;\n  channelArray[timerIndex] = channelArray[timerIndex] + '\\x01';\n  offset = timerIndex * 0xc;\n  if ((channelArray[timerIndex] + offset < (int)servoCount) && (channelArray[timerIndex] < '\\f')) {\n    timerCounter->TC_CHANNEL[channelIndex].TC_RA =\n         timerCounter->TC_CHANNEL[channelIndex].TC_CV + servoArray[channelArray[timerIndex] + offset].ticks;\n    if (-1 < (int)((uint)(byte)servoArray[channelArray[timerIndex] + offset].Pin << 0x19)) {\n      return;\n    }\n    digitalWrite((byte)servoArray[offset + channelArray[timerIndex]].Pin & 0x3f,1);\n    return;\n  }\n  reloadValue = (SystemCoreClock / 1000000) * 20000 >> 5;\n  if (reloadValue <= timerCounter->TC_CHANNEL[channelIndex].TC_CV + 4) {\n    reloadValue = timerCounter->TC_CHANNEL[channelIndex].TC_CV + 4;\n  }\n  timerCounter->TC_CHANNEL[channelIndex].TC_RA = reloadValue;\n  channelArray[timerIndex] = -1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_servo_timer_0008044c",
                "timer": "sequence",
                "tc": "timerCounter",
                "channel": "channelIndex",
                "uVar1": "timerIndex",
                "uVar2": "servoCount",
                "RVar3": "reloadValue",
                "iVar4": "offset",
                "Channel": "channelArray",
                "ServoCount": "totalServos",
                "servos": "servoArray"
            },
            "calling": [
                "TC4_Handler",
                "TC2_Handler",
                "TC0_Handler",
                "TC3_Handler",
                "TC5_Handler"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080558": {
            "entrypoint": "0x00080558",
            "current_name": "initialize_servo_handler_00080558",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServoHandler_00080558(void)\n\n{\n  Servo_Handler(_timer1,(Tc *)0x40084000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080558": "initialize_servo_handler_00080558"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080568": {
            "entrypoint": "0x00080568",
            "current_name": "initialize_servo_handler_00080568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServoHandler_00080568(void)\n\n{\n  Servo_Handler(timer,(Tc *)0x40084000,'\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080568": "initialize_servo_handler_00080568",
                "_timer2": "timer"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080578": {
            "entrypoint": "0x00080578",
            "current_name": "initialize_servo_00080578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServo_00080578(void)\n\n{\n  handleServo(timer,(timerControl *)0x40084000,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080578": "initialize_servo_00080578",
                "Servo_Handler": "handleServo",
                "_timer3": "timer",
                "Tc": "timerControl"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080588": {
            "entrypoint": "0x00080588",
            "current_name": "servo_control_00080588",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid servoControl_00080588(void)\n\n{\n  Servo_Handler(_timer4,(Tc *)0x40080000,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080588": "servo_control_00080588"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080598": {
            "entrypoint": "0x00080598",
            "current_name": "initialize_servo_handler_00080598",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServoHandler_00080598(void)\n\n{\n  Servo_Handler(_servoTimer,(Tc *)0x40080000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080598": "initialize_servo_handler_00080598",
                "timer5": "servoTimer"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "initialize_servo_000805a8",
            "code": "\n/* DWARF original prototype: Servo *  Servo(Servo * servo) */\n\nServo * __servocall Servo::initializeServo_000805a8(Servo *servo)\n\n{\n  uint8_t newCount;\n  uint count;\n  \n  count = (uint)totalServoCount;\n  if (count < 0x3c) {\n    newCount = totalServoCount + '\\x01';\n    servo->servoIndex = totalServoCount;\n    totalServoCount = newCount;\n    servoArray[count].ticks = (SystemCoreClock / 1000000) * 0x5dc >> 5;\n    return servo;\n  }\n  servo->servoIndex = 0xff;\n  return servo;\n}\n\n",
            "renaming": {
                "this": "servo",
                "uVar1": "newCount",
                "uVar2": "count",
                "ServoCount": "totalServoCount",
                "servos": "servoArray",
                "FUN_000805a8": "initialize_servo_000805a8"
            },
            "calling": [
                "_GLOBAL__sub_I_steering"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805e8": {
            "entrypoint": "0x000805e8",
            "current_name": "attach_000805e8",
            "code": "\n/* DWARF original prototype: uint8_t  attach_000805e8(Servo * servo, int servoPin, int minimum, int maximum) */\n\nuint8_t __servocall Servo::attach_000805e8(Servo *servo,int servoPin,int minimum,int maximum)\n\n{\n  ServoPin_t servoPin_t;\n  timer16_Sequence_t16_Sequence_t timer16_Sequence_t;\n  Tc *timerController;\n  uint32_t channel;\n  uint32_t timerId;\n  int iteration;\n  uint index;\n  \n  if (0x3b < servo->servoIndex) goto LAB_00080660;\n  servoPinMode(servoPin,1);\n  index = (uint)servo->servoIndex;\n  servoPin_t = servos[index].Pin;\n  servo->maximum = (int8_t)((0x960U - maximum) / 4);\n  channel = index / 0xc;\n  servos[index].Pin = (ServoPin_t)((byte)servoPin_t & 0xc0 | (byte)servoPin & 0x3f);\n  servo->minimum = (int8_t)((0x220U - minimum) / 4);\n  iteration = 0;\n  do {\n    if ((int)((uint)(byte)servos[iteration + channel * 0xc].Pin << 0x19) < 0) goto LAB_00080652;\n    iteration = iteration + 1;\n  } while (iteration != 0xc);\n  if (channel == 0) {\n    timerController = (Tc *)0x40084000;\n    timerId = 0x1e;\nLAB_0008064c:\n    _initISR(timerController,channel,timerId,(IRQn_Type)timerId);\n  }\n  else {\n    if (channel == 1) {\n      timerController = (Tc *)0x40084000;\n      timerId = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (channel == 2) {\n      timerController = (Tc *)0x40084000;\n      timerId = 0x20;\n      goto LAB_0008064c;\n    }\n    if (channel == 3) {\n      timerController = (Tc *)0x40080000;\n      channel = 2;\n      timerId = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (channel == 4) {\n      timerController = (Tc *)0x40080000;\n      channel = 0;\n      timerId = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  servos[servo->servoIndex].Pin = (ServoPin_t)((byte)servos[servo->servoIndex].Pin | 0x40);\nLAB_00080660:\n  return servo->servoIndex;\n}\n\n",
            "renaming": {
                "FUN_000805e8": "attach_000805e8",
                "this": "servo",
                "pin": "servoPin",
                "min": "minimum",
                "max": "maximum",
                "SVar1": "servoPin_t",
                "timer": "timer16_Sequence_t",
                "tc": "timerController",
                "id": "timerId",
                "iVar2": "iteration",
                "uVar3": "index"
            },
            "calling": [
                "attach"
            ],
            "called": [
                "_initISR",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "attach_servo_000806a0",
            "code": "\n/* DWARF original prototype: uint8_t  attach(Servo * servo, int servoPin) */\n\nuint8_t __servocall Servo::attachServo_000806a0(Servo *servo,int servoPin)\n\n{\n  uint8_t returnValue;\n  \n  returnValue = attach(servo,servoPin,0x220,0x960);\n  return returnValue;\n}\n\n",
            "renaming": {
                "this": "servo",
                "pin": "servoPin",
                "uVar1": "returnValue",
                "FUN_000806a0": "attach_servo_000806a0"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806ac": {
            "entrypoint": "0x000806ac",
            "current_name": "write_microseconds_000806ac",
            "code": "\n/* DWARF original prototype: void  writeMicroseconds_000806ac(Servo * servo, int microseconds) */\n\nvoid __servocall Servo::writeMicroseconds_000806ac(Servo *servo,int microseconds)\n\n{\n  byte *ptrChannel;\n  int rangeMinDifference;\n  int rangeMaxDifference;\n  \n  if (servo->index < 0x3c) {\n    rangeMinDifference = 0x88 - servo->min;\n    rangeMaxDifference = rangeMinDifference * 4;\n    if ((microseconds + rangeMinDifference * -4 < 0 == SBORROW4(microseconds,rangeMaxDifference)) &&\n       (rangeMaxDifference = (600 - servo->max) * 4, microseconds <= rangeMaxDifference)) {\n      rangeMaxDifference = microseconds;\n    }\n    servoArray[servo->index].ticks = (SystemCoreClock / 1000000) * (rangeMaxDifference + -2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "servo",
                "value": "microseconds",
                "channel": "ptrChannel",
                "iVar1": "rangeMinDifference",
                "iVar2": "rangeMaxDifference",
                "servoIndex": "index",
                "servos": "servoArray",
                "FUN_000806ac": "write_microseconds_000806ac"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "write_servo_value_000806f8",
            "code": "\n/* DWARF original prototype: void  write(Servo * servo, int value) */\n\nssize_t __servocall Servo::writeServoValue_000806f8(Servo *servo,int fileDescriptor,void *buffer,size_t size)\n\n{\n  if (fileDescriptor < 0x220) {\n    if (0xb3 < fileDescriptor) {\n      fileDescriptor = 0xb4;\n    }\n    fileDescriptor = mapValue(fileDescriptor & ~(fileDescriptor >> 0x1f),0,0xb4,(0x88 - servo->minimumValue) * 4,(600 - servo->maximumValue) * 4);\n  }\n  sendServoPulse(servo,fileDescriptor);\n  return returnValue;\n}\n\n",
            "renaming": {
                "this": "servo",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "map": "mapValue",
                "writeMicroseconds": "sendServoPulse",
                "(ssize_t)this": "returnValue",
                "min": "minimumValue",
                "max": "maximumValue",
                "FUN_000806f8": "write_servo_value_000806f8"
            },
            "calling": [
                "straightAndStop",
                "loop"
            ],
            "called": [
                "writeMicroseconds",
                "map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008073c": {
            "entrypoint": "0x0008073c",
            "current_name": "handle_serial_interrupt_0008073c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialInterrupt_0008073c(void)\n\n{\n  UARTClass::IrqHandler(serialPort);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073c": "handle_serial_interrupt_0008073c",
                "&Serial": "serialPort"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080750": {
            "entrypoint": "0x00080750",
            "current_name": "initialize_uart_00080750",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_00080750(void)\n\n{\n  UARTClass::IrqHandler(uartInstance);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080750": "initialize_uart_00080750",
                "&Serial1.super_UARTClass": "uartInstance"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008075c": {
            "entrypoint": "0x0008075c",
            "current_name": "handle_serial2_irq_0008075c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial2Irq_0008075c(void)\n\n{\n  handleInterrupt(serial2Ptr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008075c": "handle_serial2_irq_0008075c",
                "UARTClass::IrqHandler": "handleInterrupt",
                "&Serial2.super_UARTClass": "serial2Ptr"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080768": {
            "entrypoint": "0x00080768",
            "current_name": "handle_serial3_irq_00080768",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial3Irq_00080768(void)\n\n{\n  UARTClass::IrqHandler(serial3Class);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080768": "handle_serial3_irq_00080768",
                "&Serial3.super_UARTClass": "serial3Class"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_hardware_00080774",
            "code": "\n\n\nint initializeHardware_00080774(EVP_PKEY_CTX *context)\n\n{\n  int result;\n  uint32_t pin;\n  uint32_t nextPin;\n  \n  SystemInit();\n  _DAT_e000e014 = SystemCoreClock / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  __libc_init_array();\n  pin = 0;\n  do {\n    nextPin = pin + 1;\n    digitalWrite(pin,0);\n    pin = nextPin;\n  } while (nextPin != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  PIO_Configure(&DAT_400e0e00,1,0x300,0);\n  digitalWrite(0,1);\n  PIO_Configure(&DAT_400e0e00,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,0x3000,0);\n  PIO_Configure(&DAT_400e1400,2,0x30,0);\n  PIO_Configure(&DAT_400e1000,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,3,0);\n  PIO_Configure(&DAT_400e1000,1,0xc000,0);\n  pmc_enable_periph_clk(0x25);\n  adc_init(0x400c0000,SystemCoreClock,20000000,0xc);\n  adc_configure_timing(0x400c0000,0,0x300000,1);\n  adc_configure_trigger(0x400c0000,0,0);\n  adc_disable_interrupt(0x400c0000,0xffffffff);\n  result = adc_disable_all_channel(0x400c0000);\n  analogOutputInit();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_hardware_00080774",
                "ctx": "context",
                "iVar1": "result",
                "ulPin": "pin",
                "uVar2": "nextPin"
            },
            "calling": [
                "main"
            ],
            "called": [
                "adc_disable_all_channel",
                "SystemInit",
                "pmc_enable_periph_clk",
                "digitalWrite",
                "adc_configure_trigger",
                "adc_disable_interrupt",
                "analogOutputInit",
                "__libc_init_array",
                "adc_configure_timing",
                "adc_init",
                "PIO_Configure"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_serial_communication_0008089c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_0008089c(void)\n\n{\n  RingBuffer::RingBuffer(&buffer1ForReceivingData);\n  RingBuffer::RingBuffer(&buffer1ForTransmittingData);\n  UARTDevice::UARTDevice(&UART1,(Uart *)0x400e0800,UART_IRQn,8,&buffer1ForReceivingData,&buffer1ForTransmittingData);\n  RingBuffer::RingBuffer(&buffer2ForReceivingData);\n  RingBuffer::RingBuffer(&buffer3ForReceivingData);\n  RingBuffer::RingBuffer(&buffer4ForReceivingData);\n  RingBuffer::RingBuffer(&buffer2ForTransmittingData);\n  RingBuffer::RingBuffer(&buffer3ForTransmittingData);\n  RingBuffer::RingBuffer(&buffer4ForTransmittingData);\n  USARTDevice::USARTDevice(&USART0,(Usart *)0x40098000,USART0_IRQn,0x11,&buffer2ForReceivingData,&buffer2ForTransmittingData);\n  USARTDevice::USARTDevice(&USART1,(Usart *)0x4009c000,USART1_IRQn,0x12,&buffer3ForReceivingData,&buffer3ForTransmittingData);\n  USARTDevice::USARTDevice(&USART3,(Usart *)0x400a4000,USART3_IRQn,0x14,&buffer4ForReceivingData,&buffer4ForTransmittingData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_serial_communication_0008089c",
                "rx_buffer1": "buffer1ForReceivingData",
                "tx_buffer1": "buffer1ForTransmittingData",
                "Serial": "UART1",
                "UARTClass": "UARTDevice",
                "rx_buffer2": "buffer2ForReceivingData",
                "rx_buffer3": "buffer3ForReceivingData",
                "rx_buffer4": "buffer4ForReceivingData",
                "tx_buffer2": "buffer2ForTransmittingData",
                "tx_buffer3": "buffer3ForTransmittingData",
                "tx_buffer4": "buffer4ForTransmittingData",
                "Serial1": "USART0",
                "Serial2": "USART1",
                "Serial3": "USART3",
                "USARTClass": "USARTDevice"
            },
            "calling": [],
            "called": [
                "UARTClass",
                "USARTClass",
                "RingBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "process_serial_events_00080970",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processSerialEvents_00080970(void)\n\n{\n  int availableData;\n  \n  availableData = UARTClass::available(&Serial);\n  if (availableData != 0) {\n    serialEvent();\n  }\n  availableData = UARTClass::available(&Serial1);\n  if (availableData != 0) {\n    serialEvent1();\n  }\n  availableData = UARTClass::available(&Serial2);\n  if (availableData != 0) {\n    serialEvent2();\n  }\n  availableData = UARTClass::available(&Serial3);\n  if (availableData != 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "process_serial_events_00080970",
                "iVar1": "availableData",
                "&Serial1.super_UARTClass": "&Serial1",
                "&Serial2.super_UARTClass": "&Serial2",
                "&Serial3.super_UARTClass": "&Serial3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "serialEvent",
                "serialEvent1",
                "serialEvent2",
                "available",
                "serialEvent3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809b4": {
            "entrypoint": "0x000809b4",
            "current_name": "update_data_field_000809b4",
            "code": "\nvoid updateDataField_000809b4(int objectAddress,undefined4 newValue,int flag)\n\n{\n  if (flag != 0) {\n    *(undefined4 *)(objectAddress + 100) = newValue;\n    return;\n  }\n  *(undefined4 *)(objectAddress + 0x60) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809b4": "update_data_field_000809b4",
                "param_1": "objectAddress",
                "param_2": "newValue",
                "param_3": "flag"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_data_000809be",
            "code": "\nvoid updateData_000809be(int ptrData,undefined4 dataType,uint newValue)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(ptrData + 0x44) = newValue;\n  switch(dataType) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(ptrData + 0x70) & *(uint *)(ptrData + 0x70) & ~newValue;\n    break;\n  case 2:\n    updatedValue = *(uint *)(ptrData + 0x70) | newValue;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(ptrData + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(ptrData + 4) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_data_000809be",
                "param_1": "ptrData",
                "param_2": "dataType",
                "param_3": "newValue",
                "uVar1": "updatedValue"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "update_param_values_000809e4",
            "code": "\nvoid updateParamValues_000809e4(undefined4 *paramArray,undefined4 newValue,uint flag)\n\n{\n  bool isFlagNegative;\n  \n  isFlagNegative = (int)(flag << 0x1f) < 0;\n  paramArray[0x11] = newValue;\n  if (isFlagNegative) {\n    paramArray[0x19] = newValue;\n  }\n  if (!isFlagNegative) {\n    paramArray[0x18] = newValue;\n  }\n  isFlagNegative = (flag & 10) != 0;\n  if (isFlagNegative) {\n    paramArray[8] = newValue;\n  }\n  if (!isFlagNegative) {\n    paramArray[9] = newValue;\n  }\n  if (((int)(flag << 0x1e) < 0) || ((int)(flag << 0x1c) < 0)) {\n    paramArray[0x20] = newValue;\n  }\n  paramArray[5] = newValue;\n  *paramArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "update_param_values_000809e4",
                "param_1": "paramArray",
                "param_2": "newValue",
                "param_3": "flag",
                "bVar1": "isFlagNegative"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "set_param_values_00080a0a",
            "code": "\nvoid set_param_values_00080a0a(undefined4 *output_array,undefined4 value,int condition_1,int condition_2,int condition_3)\n\n{\n  output_array[17] = value;\n  if (condition_3 == 0) {\n    output_array[24] = value;\n  }\n  else {\n    output_array[25] = value;\n  }\n  if (condition_2 == 0) {\n    output_array[21] = value;\n  }\n  else {\n    output_array[20] = value;\n  }\n  if (condition_1 == 0) {\n    output_array[13] = value;\n  }\n  else {\n    output_array[12] = value;\n  }\n  output_array[4] = value;\n  *output_array = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "set_param_values_00080a0a",
                "param_1": "output_array",
                "param_2": "value",
                "param_3": "condition_1",
                "param_4": "condition_2",
                "param_5": "condition_3",
                "param_1[0x11]": "output_array[17]",
                "param_1[0x18]": "output_array[24]",
                "param_1[0x19]": "output_array[25]",
                "param_1[0x15]": "output_array[21]",
                "param_1[0x14]": "output_array[20]",
                "param_1[0xd]": "output_array[13]",
                "param_1[0xc]": "output_array[12]",
                "param_1[4]": "output_array[4]"
            },
            "calling": [
                "digitalWrite",
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "set_peripheral_00080a30",
            "code": "\nundefined4 setPeripheral_00080a30(int deviceAddress,int peripheralType,undefined4 peripheralConfig,uint peripheralData)\n\n{\n  bool isNegative;\n  \n  switch(peripheralType) {\n  case 1:\n  case 2:\n    setPeripheral_00080a30State(deviceAddress,peripheralType,peripheralConfig);\n    isNegative = (int)(peripheralData << 0x1f) < 0;\n    *(undefined4 *)(deviceAddress + 0x44) = peripheralConfig;\n    if (isNegative) {\n      *(undefined4 *)(deviceAddress + 100) = peripheralConfig;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(deviceAddress + 0x60) = peripheralConfig;\n    }\n    break;\n  case 3:\n    setInput(deviceAddress,peripheralConfig,peripheralData,0x809e5,deviceAddress);\n    break;\n  case 4:\n  case 5:\n    setOutput(deviceAddress,peripheralConfig,peripheralType == 5,(peripheralData << 0x1d) >> 0x1f,peripheralData & 1,peripheralType,peripheralConfig\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "set_peripheral_00080a30",
                "param_1": "deviceAddress",
                "param_2": "peripheralType",
                "param_3": "peripheralConfig",
                "param_4": "peripheralData",
                "bVar1": "isNegative",
                "PIO_SetPeripheral": "setPeripheralState",
                "PIO_SetInput": "setInput",
                "PIO_SetOutput": "setOutput"
            },
            "calling": [
                "init",
                "pinMode"
            ],
            "called": [
                "PIO_SetInput",
                "PIO_SetOutput",
                "PIO_SetPeripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_flag_00080a94",
            "code": "\nuint checkFlag_00080a94(int dataPointer,uint flag)\n\n{\n  uint result;\n  \n  result = *(uint *)(dataPointer + 8) & flag;\n  if (result != 0) {\n    if ((flag & *(uint *)(dataPointer + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_flag_00080a94",
                "param_1": "dataPointer",
                "param_2": "flag",
                "uVar1": "result"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "set_bit_if_not_set_00080aa8",
            "code": "\n\n\nundefined4 setBitIfNotSet_00080aa8(uint value)\n\n{\n  uint bitMask;\n  \n  if (value < 0x2d) {\n    if (value < 0x20) {\n      bitMask = 1 << (value & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (value - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "set_bit_if_not_set_00080aa8",
                "param_1": "value",
                "uVar1": "bitMask"
            },
            "calling": [
                "init",
                "_initISR",
                "init",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aec": {
            "entrypoint": "0x00080aec",
            "current_name": "check_and_set_bit_00080aec",
            "code": "\n\n\nundefined4 checkAndSetBit_00080aec(uint value)\n\n{\n  uint bitMask;\n  uint result;\n  \n  if (value < 0x2d) {\n    if (value < 0x20) {\n      bitMask = 1 << (value & 0xff);\n      result = _DAT_400e0618 & bitMask;\n      if (result == bitMask) {\n        _DAT_400e0614 = result;\n      }\n    }\n    else {\n      bitMask = 1 << (value - 0x20 & 0xff);\n      result = _DAT_400e0708 & bitMask;\n      if (result == bitMask) {\n        _DAT_400e0704 = result;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aec": "check_and_set_bit_00080aec",
                "param_1": "value",
                "uVar1": "bitMask",
                "uVar2": "result"
            },
            "calling": [
                "pinMode",
                "end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "configure_tc_channel_00080b2c",
            "code": "\nvoid configureTCChannel_00080b2c(undefined4 param1,uint channelSize,char *channelName)\n\n{\n  int offset;\n  int tcChannelAddress;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(channelSize,param1);\n  if (2 < channelSize) {\n    channelName = \"TC_Configure\";\n    combinedParams = __assert_func(\"../source/tc.c\",0x40,\"TC_Configure\",\n                          \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  offset = (int)((ulonglong)combinedParams >> 0x20) * 0x40;\n  tcChannelAddress = (int)combinedParams + offset;\n  *(undefined4 *)((int)combinedParams + offset) = 2;\n  *(undefined4 *)(tcChannelAddress + 0x28) = 0xffffffff;\n  *(char **)(tcChannelAddress + 4) = channelName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "configure_tc_channel_00080b2c",
                "param_1": "param1",
                "param_2": "channelSize",
                "param_3": "channelName",
                "iVar1": "offset",
                "iVar2": "tcChannelAddress",
                "uVar3": "combinedParams"
            },
            "calling": [
                "_initISR"
            ],
            "called": [
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b64": {
            "entrypoint": "0x00080b64",
            "current_name": "set_channel_value_00080b64",
            "code": "\nvoid setChannelValue_00080b64(undefined4 value1,uint value2)\n\n{\n  undefined8 combinedValues;\n  \n  combinedValues = CONCAT44(value2,value1);\n  if (2 < value2) {\n    combinedValues = __assert_func(\"../source/tc.c\",0x5c,\"TC_Start\",\n                          \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  *(undefined4 *)((int)combinedValues + (int)((ulonglong)combinedValues >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b64": "set_channel_value_00080b64",
                "param_1": "value1",
                "param_2": "value2",
                "uVar1": "combinedValues"
            },
            "calling": [
                "_initISR"
            ],
            "called": [
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "store_value_at_offset_00080b90",
            "code": "\nvoid storeValueAtOffset_00080b90(int baseAddress,int index,dataType value)\n\n{\n  *(dataType *)(baseAddress + index * 0x40 + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "store_value_at_offset_00080b90",
                "param_1": "baseAddress",
                "param_2": "index",
                "param_3": "value",
                "undefined4": "dataType"
            },
            "calling": [
                "_initISR"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_system_00080b98",
            "code": "\n\n\nvoid initializeSystem_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  systemClock = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_system_00080b98",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c20": {
            "entrypoint": "0x00080c20",
            "current_name": "copy_memory_and_initialize_00080c20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid copyMemoryAndInitialize_00080c20(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  \n  for (index = 0; source + index < destination; index = index + 4) {\n    *(undefined4 *)(source + index) = *(undefined4 *)(sourceStart + index);\n  }\n  for (pointer = destination; pointer < destinationEnd; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  executeMain();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080c20": "copy_memory_and_initialize_00080c20",
                "iVar1": "index",
                "puVar2": "pointer",
                "banzai": "source",
                "&completed_7857": "destination",
                "&_etext": "sourceStart",
                "&_ebss": "destinationEnd",
                "main": "executeMain"
            },
            "calling": [],
            "called": [
                "banzai",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "calculate_threshold_00080c98",
            "code": "\nundefined4 calculateThreshold_00080c98(undefined4 *threshold,uint size,int factor,int time)\n\n{\n  uint quotient;\n  uint index;\n  uint thresholdValues [16];\n  \n  thresholdValues[0] = 0;\n  thresholdValues[1] = 8;\n  thresholdValues[2] = 0x10;\n  thresholdValues[3] = 0x18;\n  thresholdValues[4] = 0x40;\n  thresholdValues[5] = 0x50;\n  thresholdValues[6] = 0x60;\n  thresholdValues[7] = 0x70;\n  thresholdValues[8] = 0x200;\n  thresholdValues[9] = 0x240;\n  thresholdValues[10] = 0x280;\n  thresholdValues[11] = 0x2c0;\n  thresholdValues[12] = 0x300;\n  thresholdValues[13] = 0x340;\n  thresholdValues[14] = 0x380;\n  thresholdValues[15] = 0x3c0;\n  *threshold = 1;\n  threshold[1] = 0;\n  threshold[0x48] = 0x202;\n  threshold[0x41] = 0;\n  threshold[0x45] = 0;\n  quotient = size / (uint)(factor * 2);\n  if (size == factor * 2 * quotient) {\n    quotient = quotient - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(time * (int)(((ulonglong)size / (ulonglong)((quotient + 1) * 2)) / 1000000)) <=\n        thresholdValues[index]) {\n      threshold[1] = (index & 0xf) << 0x10 | (quotient & 0xff) << 8 | threshold[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "calculate_threshold_00080c98",
                "param_1": "threshold",
                "param_2": "size",
                "param_3": "factor",
                "param_4": "time",
                "uVar1": "quotient",
                "uVar2": "index",
                "local_58": "thresholdValues"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_data_00080d30",
            "code": "\nvoid updateData_00080d30(int dataPtr,uint value,uint flag)\n\n{\n  *(uint *)(dataPtr + 4) = value | *(uint *)(dataPtr + 4) | (flag & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_data_00080d30",
                "param_1": "dataPtr",
                "param_2": "value",
                "param_3": "flag"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "update_data_00080d3e",
            "code": "\nvoid updateData_00080d3e(int baseAddress,uint value1,uint value2,uint value3)\n\n{\n  *(uint *)(baseAddress + 4) =\n       value2 | *(uint *)(baseAddress + 4) | (value1 & 0xf) << 0x18 | (value3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "update_data_00080d3e",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_value_00080d58",
            "code": "\nvoid setBitValue_00080d58(int baseAddress,uint bitPosition)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_value_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitPosition"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "initialize_parameter_00080d62",
            "code": "\nvoid initializeParameter_00080d62(int parameter)\n\n{\n  *(undefined4 *)(parameter + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "initialize_parameter_00080d62",
                "param_1": "parameter"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_param_value_00080d6a",
            "code": "\nvoid setParamValue_00080d6a(int objectAddress,undefined4 newValue)\n\n{\n  *(undefined4 *)(objectAddress + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_param_value_00080d6a",
                "param_1": "objectAddress",
                "param_2": "newValue"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d70": {
            "entrypoint": "0x00080d70",
            "current_name": "execute_isr_00080d70",
            "code": "\nvoid execute_isr_00080d70(void)\n\n{\n  if (isr_function != (code *)0x0) {\n    (*isr_function)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d70": "execute_isr_00080d70",
                "gpf_isr": "isr_function"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d80": {
            "entrypoint": "0x00080d80",
            "current_name": "process_interrupts_00080d80",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_00080d80(void)\n\n{\n  uint8_t numLeadingZeros;\n  uint32_t interruptStatus;\n  uint count;\n  \n  for (interruptStatus = _DAT_400e0e4c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << count)) {\n    count = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (pioACallbacks[count] != (interruptCB)0x0) {\n      (*pioACallbacks[count])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d80": "process_interrupts_00080d80",
                "leading_zeros": "numLeadingZeros",
                "isr": "interruptStatus",
                "uVar1": "count",
                "callbacksPioA": "pioACallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080db8": {
            "entrypoint": "0x00080db8",
            "current_name": "process_interrupts_00080db8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_00080db8(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t interruptFlags;\n  uint leadingZerosCount;\n  \n  for (interruptFlags = _DAT_400e104c; (uint)LZCOUNT(interruptFlags) < 0x20; interruptFlags = interruptFlags & ~(1 << leadingZerosCount)) {\n    leadingZerosCount = 0x1fU - LZCOUNT(interruptFlags) & 0xff;\n    if (interruptCallbacks[leadingZerosCount] != (interruptCB)0x0) {\n      (*interruptCallbacks[leadingZerosCount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080db8": "process_interrupts_00080db8",
                "isr": "interruptFlags",
                "uVar1": "leadingZerosCount",
                "callbacksPioB": "interruptCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080df0": {
            "entrypoint": "0x00080df0",
            "current_name": "execute_callbacks_00080df0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid executeCallbacks_00080df0(void)\n\n{\n  uint8_t numLeadingZeros;\n  uint32_t interruptStatus;\n  uint shiftAmount;\n  \n  for (interruptStatus = _DAT_400e124c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioC[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioC[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080df0": "execute_callbacks_00080df0",
                "leading_zeros": "numLeadingZeros",
                "isr": "interruptStatus",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e28": {
            "entrypoint": "0x00080e28",
            "current_name": "handle_interrupts_00080e28",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupts_00080e28(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t interruptStatus;\n  uint leadingZerosCount;\n  \n  for (interruptStatus = _DAT_400e144c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << leadingZerosCount)) {\n    leadingZerosCount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (interruptCallbacks[leadingZerosCount] != (interruptCB)0x0) {\n      (*interruptCallbacks[leadingZerosCount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e28": "handle_interrupts_00080e28",
                "isr": "interruptStatus",
                "uVar1": "leadingZerosCount",
                "callbacksPioD": "interruptCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e60": {
            "entrypoint": "0x00080e60",
            "current_name": "infinite_loop_00080e60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00080e60(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e60": "infinite_loop_00080e60"
            },
            "calling": [
                "__halt"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e62": {
            "entrypoint": "0x00080e62",
            "current_name": "infinite_loop_00080e62",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00080e62(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e62": "infinite_loop_00080e62"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e66": {
            "entrypoint": "0x00080e66",
            "current_name": "do_nothing_loop_00080e66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid do_nothing_loop_00080e66(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e66": "do_nothing_loop_00080e66"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e6a": {
            "entrypoint": "0x00080e6a",
            "current_name": "reset_and_increment_time_tick_00080e6a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetAndIncrementTimeTick_00080e6a(void)\n\n{\n  int result;\n  \n  result = __false();\n  if (result == 0) {\n    tickReset();\n    TimeTick_Increment();\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e6a": "reset_and_increment_time_tick_00080e6a",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "tickReset",
                "TimeTick_Increment",
                "__false"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "initialize_00080e80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initialize_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "initialize_00080e80"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e84": {
            "entrypoint": "0x00080e84",
            "current_name": "infinite_loop_00080e84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00080e84(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e84": "infinite_loop_00080e84"
            },
            "calling": [
                "PendSV_Handler",
                "__halt",
                "SVC_Handler"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "allocate_memory_00080e88",
            "code": "\nvoid * allocateMemory_00080e88(intptr_t bytesToAllocate)\n\n{\n  uchar *previousHeap;\n  uchar *currentHeap;\n  \n  if (_sbrk::heap == (uchar *)0x0) {\n    _sbrk::heap = &_ebss;\n  }\n  previousHeap = _sbrk::heap;\n  _sbrk::heap = _sbrk::heap + bytesToAllocate;\n  return previousHeap;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "allocate_memory_00080e88",
                "__delta": "bytesToAllocate",
                "puVar1": "previousHeap",
                "prev_heap": "currentHeap"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ea4": {
            "entrypoint": "0x00080ea4",
            "current_name": "copy_string_00080ea4",
            "code": "\nint copy_string_00080ea4(char *source,char *destination)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00080ea4": "copy_string_00080ea4",
                "__from": "source",
                "__to": "destination"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "check_file_descriptor_00080eaa",
            "code": "\nint checkFileDescriptor_00080eaa(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "check_file_descriptor_00080eaa",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "set_file_permissions_00080eb0",
            "code": "\nint setFilePermissions_00080eb0(int fileDescriptor,stat *fileStatus)\n\n{\n  *(undefined4 *)((int)&fileStatus->deviceNumber + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "set_file_permissions_00080eb0",
                "__fd": "fileDescriptor",
                "__buf": "fileStatus",
                "st_dev": "deviceNumber"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "check_file_status_00080eba",
            "code": "\nint checkFileStatus_00080eba(int fileDescriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "check_file_status_00080eba",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "get_file_offset_00080ebe",
            "code": "\n__off_t get_file_offset_00080ebe(int file_descriptor,__off_t offset,int whence)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "get_file_offset_00080ebe",
                "__fd": "file_descriptor",
                "__offset": "offset",
                "__whence": "whence"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "parse_file_00080ec2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint parse_file_00080ec2(int file_descriptor,char *buffer_ptr,int buffer_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "parse_file_00080ec2",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer_ptr",
                "len_UNUSED": "buffer_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "convert_byte_array_to_unsigned_00080ec8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint convertByteArrayToUnsigned_00080ec8(int fileDescriptor,char *byteArray,int arrayLength)\n\n{\n  int index;\n  \n  for (index = 0; index < arrayLength; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)(byte)byteArray[index];\n  }\n  return arrayLength & ~(arrayLength >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "convert_byte_array_to_unsigned_00080ec8",
                "file_UNUSED": "fileDescriptor",
                "ptr": "byteArray",
                "len": "arrayLength",
                "iVar1": "index"
            },
            "calling": [
                "_write_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "exit_with_status_00080eec",
            "code": "\nvoid exitWithStatus_00080eec(int status)\n\n{\n  printStatus(\"Exiting with status %d.\\n\",status);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "exit_with_status_00080eec",
                "__status": "status",
                "iprintf": "printStatus"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080efc(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "get_process_id_00080efe",
            "code": "\n\n\nProcessId getProcessId_00080efe(void)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "get_process_id_00080efe",
                "__pid_t": "ProcessId"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f04": {
            "entrypoint": "0x00080f04",
            "current_name": "get_tick_count_00080f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_00080f04(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00080f04": "get_tick_count_00080f04",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "timedRead"
            ],
            "called": [
                "GetTickCount"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080f08(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "loop",
                "setup",
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0a": {
            "entrypoint": "0x00080f0a",
            "current_name": "FUNC_00080f0a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080f0a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f0a": "FUNC_00080f0a"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "configure_pin_00080f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00080f0c(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  undefined4 peripheralMode;\n  byte pinStatusLow;\n  byte pinStatus;\n  Pio *pinPort;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    if ((g_pinStatus[pinNumber] & 0xf) == 4) {\n      adc_disable_channel(0x400c0000,g_APinDescription[pinNumber].ulADCChannelNumber);\n    }\n    pinStatus = g_pinStatus[pinNumber];\n    pinStatusLow = pinStatus & 0xf;\n    if ((pinStatusLow < 3) && (pinStatus != 0)) {\n      if (pinStatusLow == 2) {\n        if (pinMode == 0) {\n          return;\n        }\n      }\n      else if (pinStatusLow == 1) {\n        if (pinMode == 2) {\n          return;\n        }\n      }\n      else if (pinStatusLow == 3) {\n        if (pinMode == 1) {\n          return;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (pinMode != 1) {\nLAB_00080f68:\n      if (pinMode == 0) {\n        pmc_enable_periph_clk(g_APinDescription[pinNumber].ulPeripheralId);\n        PIO_Configure(g_APinDescription[pinNumber].pPort,3,g_APinDescription[pinNumber].pinNumber,0);\n        pinStatus = g_pinStatus[pinNumber] & 0xf0 | 2;\n      }\n      else {\n        if (pinMode != 2) {\n          return;\n        }\n        pmc_enable_periph_clk(g_APinDescription[pinNumber].ulPeripheralId);\n        PIO_Configure(g_APinDescription[pinNumber].pPort,3,g_APinDescription[pinNumber].pinNumber,1);\n        pinStatus = g_pinStatus[pinNumber] & 0xf0 | 1;\n      }\n      g_pinStatus[pinNumber] = pinStatus;\n      return;\n    }\n    pinPort = g_APinDescription[pinNumber].pPort;\n    if (pinStatus >> 4 == 0) {\n      peripheralMode = 4;\n    }\n    else {\n      peripheralMode = 5;\n    }\n    PIO_Configure(pinPort,peripheralMode,g_APinDescription[pinNumber].pinNumber,\n                  g_APinDescription[pinNumber].pinNumberConfiguration);\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf0 | 3;\n    if (pinPort->PIO_OSR == 0xffffffff) {\n      pmc_disable_periph_clk(g_APinDescription[pinNumber].ulPeripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "configure_pin_00080f0c",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "uVar1": "peripheralMode",
                "bVar2": "pinStatusLow",
                "bVar3": "pinStatus",
                "pPVar4": "pinPort"
            },
            "calling": [
                "digitalWrite",
                "setup",
                "attach"
            ],
            "called": [
                "pmc_enable_periph_clk",
                "pmc_disable_periph_clk",
                "adc_disable_channel",
                "PIO_Configure"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "set_pin_value_00081014",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinValue_00081014(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  int outputStatus;\n  uint32_t pin;\n  Pio *port;\n  uint32_t newValue;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    newValue = pinValue;\n    if ((g_pinStatus[pinNumber] & 0xf) == 5) {\n      pinMode(pinNumber,1);\n    }\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf | (byte)(pinValue << 4);\n    port = g_APinDescription[pinNumber].pPort;\n    pin = g_APinDescription[pinNumber].pinNumber;\n    outputStatus = PIO_GetOutputDataStatus(port,pin);\n    if (outputStatus == 0) {\n      PIO_PullUp(port,pin,pinValue);\n      return;\n    }\n    PIO_SetOutput(port,pin,pinValue,0,1,newValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "set_pin_value_00081014",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "iVar1": "outputStatus",
                "uVar2": "pin",
                "uVar4": "newValue",
                "pPVar3": "port"
            },
            "calling": [
                "init",
                "loop",
                "Servo_Handler"
            ],
            "called": [
                "PIO_GetOutputDataStatus",
                "PIO_SetOutput",
                "pinMode",
                "PIO_PullUp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081084": {
            "entrypoint": "0x00081084",
            "current_name": "write_to_buffer_00081084",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0008109a */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * print_object, uint8_t * buffer, size_t size) */\n\nssize_t __print_objectcall Print::write_to_buffer_00081084(Print *print_object,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *updated_print_object;\n  void *current_position;\n  \n  current_position = (void *)0x0;\n  updated_print_object = print_object;\n  while ((current_position != buffer &&\n         (updated_print_object = (Print *)(**print_object->_vptr_Print)(updated_print_object,(uint)*(byte *)(file_descriptor + (int)current_position)),\n         updated_print_object != (Print *)0x0))) {\n    current_position = (void *)((int)current_position + 1);\n  }\n  return (ssize_t)current_position;\n}\n\n",
            "renaming": {
                "this": "print_object",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pvVar2": "current_position",
                "pPVar1": "updated_print_object",
                "FUN_00081084": "write_to_buffer_00081084"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "write_to_file_000810a6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000810be */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * print_instance, char * str) */\n\nssize_t __print_instancecall Print::write_to_file_000810a6(Print *print_instance,int file_descriptor,void *buffer,size_t size_of_buffer)\n\n{\n  size_t string_length;\n  int bytes_written;\n  \n  if (file_descriptor != 0) {\n    string_length = strlen((char *)file_descriptor);\n    bytes_written = (*print_instance->_vptr_Print[1])(string_length,file_descriptor,string_length,print_instance->_vptr_Print[1],size_of_buffer);\n    return bytes_written;\n  }\n  return file_descriptor;\n}\n\n",
            "renaming": {
                "this": "print_instance",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size_of_buffer",
                "sVar1": "string_length",
                "iVar2": "bytes_written",
                "FUN_000810a6": "write_to_file_000810a6"
            },
            "calling": [
                "println",
                "println",
                "print",
                "printNumber"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "print_string_000810c4",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printObj, char * stringToPrint) */\n\nsize_t __printObjcall Print::printString_000810c4(Print *printObj,char *stringToPrint)\n\n{\n  size_t bytesWritten;\n  void *arg1;\n  size_t arg2;\n  \n  bytesWritten = write(printObj,(int)stringToPrint,arg1,arg2);\n  return bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "print_string_000810c4",
                "this": "printObj",
                "str": "stringToPrint",
                "sVar1": "bytesWritten",
                "in_r2": "arg1",
                "in_r3": "arg2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "print_character_000810cc",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000810d2 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char c) */\n\nsize_t __thiscall Print::printCharacter_000810cc(Print *this,char c)\n\n{\n  size_t result;\n  \n  result = (**this->_vptr_Print)(this,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "sVar1": "result",
                "FUN_000810cc": "print_character_000810cc"
            },
            "calling": [
                "print"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "print_text_000810d8",
            "code": "\n/* DWARF original prototype: size_t  println(Print * printInstance) */\n\nsize_t __printInstancecall Print::printText_000810d8(Print *printInstance)\n\n{\n  size_t bytesWritten;\n  void *dataPointer;\n  size_t dataSize;\n  \n  bytesWritten = write(printInstance,(int)&DAT_00085635,dataPointer,dataSize);\n  return bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "print_text_000810d8",
                "this": "printInstance",
                "in_r2": "dataPointer",
                "in_r3": "dataSize",
                "sVar1": "bytesWritten"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "write_and_print_000810e8",
            "code": "\n/* DWARF original prototype: size_t  println(Print * printObject, char * c) */\n\nsize_t __printObjectcall Print::writeAndPrint_000810e8(Print *printObject,char *c)\n\n{\n  ssize_t writeResult;\n  size_t printlnResult;\n  void *pointer;\n  size_t size;\n  \n  writeResult = write(printObject,(int)c,pointer,size);\n  printlnResult = println(printObject);\n  return printlnResult + writeResult;\n}\n\n",
            "renaming": {
                "this": "printObject",
                "sVar1": "writeResult",
                "sVar2": "printlnResult",
                "in_r2": "pointer",
                "in_r3": "size",
                "FUN_000810e8": "write_and_print_000810e8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "print_number_000810fc",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbertNumber(Prinumbert * printer, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printercall Prinumbert::printNumber_000810fc(Prinumbert *printer,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char *ptrEnd;\n  size_t bytesWritten;\n  void *basePtr;\n  char c;\n  uinumbert dividend;\n  char *ptrChar;\n  char convertedChar;\n  uinumbert remainder;\n  char buffer [33];\n  \n  basePtr = (void *)(uinumbert)numberBase;\n  buffer[32] = '\\0';\n  if (basePtr < (void *)0x2) {\n    basePtr = (void *)0xa;\n  }\n  ptrEnd = buffer + 0x1f;\n  do {\n    ptrChar = ptrEnd;\n    dividend = number / (uinumbert)basePtr;\n    remainder = number - (inumbert)basePtr * dividend & 0xff;\n    convertedChar = (char)remainder;\n    if (remainder < 10) {\n      convertedChar = convertedChar + '0';\n    }\n    else {\n      convertedChar = convertedChar + '7';\n    }\n    *ptrChar = convertedChar;\n    number = dividend;\n    ptrEnd = ptrChar + -1;\n  } while (dividend != 0);\n  bytesWritten = write(printer,(inumbert)ptrChar,basePtr,0);\n  returnumber bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "print_number_000810fc",
                "this": "printer",
                "n": "number",
                "base": "numberBase",
                "pcVar1": "ptrEnd",
                "sVar2": "bytesWritten",
                "__buf": "basePtr",
                "uVar3": "dividend",
                "__fd": "ptrChar",
                "cVar4": "convertedChar",
                "uVar5": "remainder",
                "buf": "buffer"
            },
            "calling": [
                "print"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "print_formatted_number_0008113a",
            "code": "\n/* WARNING: Heritempage AFTER dead removal. Example locatempionumber: r0 : 0x0008114a */\n/* WARNING: Restempartemped tempo delay deadcode eliminumberatempionumber for space: registemper */\n/* WARNING: Exceeded maximum restempartemps witemph more penumberdinumberg */\n/* DWARF originumberal protempotempype: size_temp  prinumbertemp(Prinumbertemp * print_object, lonumberg number, inumbertemp number_base) */\n\nsize_temp __print_objectcall Prinumbertemp::print_formatted_number_0008113a(Prinumbertemp *print_object,lonumberg number,inumbertemp number_base)\n\n{\n  size_temp result;\n  inumbertemp temp;\n  size_temp sub_result;\n  uinumbertemp8_temp base_as_byte;\n  \n  if (number_base == 0) {\n    result = (**print_object->_vptempr_Prinumbertemp)(print_object,number & 0xff);\n    retempurnumber result;\n  }\n  base_as_byte = (uinumbertemp8_temp)number_base;\n  if ((number_base == 10) && (base_as_byte = '\\number', number < 0)) {\n    result = prinumbertemp(print_object,'-');\n    sub_result = prinumbertempNumber(print_object,-number,(uinumbertemp8_temp)number_base);\n    retempurnumber sub_result + result;\n  }\n  result = prinumbertempNumber(print_object,number,base_as_byte);\n  retempurnumber result;\n}\n\n",
            "renaming": {
                "this": "print_object",
                "n": "number",
                "base": "number_base",
                "sVar1": "result",
                "t": "temp",
                "sVar2": "sub_result",
                "base_00": "base_as_byte",
                "FUN_0008113a": "print_formatted_number_0008113a"
            },
            "calling": [
                "println",
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081176": {
            "entrypoint": "0x00081176",
            "current_name": "print_with_base_00081176",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x0008114a */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObject, inumbert number, inumbert baseNumber) */\n\nsize_t __printObjectcall Prinumbert::printWithBase_00081176(Prinumbert *printObject,inumbert number,inumbert baseNumber)\n\n{\n  size_t size1;\n  size_t size2;\n  uinumbert8_t baseByte;\n  \n  if (baseNumber == 0) {\n    size1 = (**printObject->_vptr_Prinumbert)(printObject,number & 0xff);\n    returnumber size1;\n  }\n  baseByte = (uinumbert8_t)baseNumber;\n  if ((baseNumber == 10) && (baseByte = '\\number', number < 0)) {\n    size1 = prinumbert(printObject,'-');\n    size2 = prinumbertNumber(printObject,-number,(uinumbert8_t)baseNumber);\n    returnumber size2 + size1;\n  }\n  size1 = prinumbertNumber(printObject,number,baseByte);\n  returnumber size1;\n}\n\n",
            "renaming": {
                "FUN_00081176": "print_with_base_00081176",
                "this": "printObject",
                "n": "number",
                "base": "baseNumber",
                "sVar1": "size1",
                "sVar2": "size2",
                "base_00": "baseByte"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "print_number_with_base_0008117a",
            "code": "\n/* DWARF original prototype: size_t  println(Print * printer, int number, int numberBase) */\n\nsize_t __printercall Print::printNumberWithBase_0008117a(Print *printer,int number,int numberBase)\n\n{\n  size_t printResult;\n  size_t printlnResult;\n  \n  printResult = print(printer,number,numberBase);\n  printlnResult = println(printer);\n  return printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "print_number_with_base_0008117a",
                "this": "printer",
                "num": "number",
                "base": "numberBase",
                "sVar1": "printResult",
                "sVar2": "printlnResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "check_and_execute_banzai_00081190",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkAndExecuteBanzai_00081190(void)\n\n{\n  if ((counter != -1) && (counter = counter + -1, counter == 0)) {\n    executeBanzai();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "check_and_execute_banzai_00081190",
                "ticks": "counter",
                "banzai": "executeBanzai"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "banzai"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_ring_buffer_000811b0",
            "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * ringBuffer) */\n\nRingBuffer * __ringBuffercall RingBuffer::initializeRingBuffer_000811b0(RingBuffer *ringBuffer)\n\n{\n  memset(ringBuffer,0,0x80);\n  ringBuffer->headIndex = 0;\n  ringBuffer->tailIndex = 0;\n  return ringBuffer;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_ring_buffer_000811b0",
                "this": "ringBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "store_char_000811ca",
            "code": "\n/* DWARF orhead_indexghead_indexnal prototype: vohead_indexd  store_char_000811ca(Rhead_indexngBuffer * ring_buffer, uhead_indexnt8_t c) */\n\nvohead_indexd __ring_buffercall Rhead_indexngBuffer::store_char_000811ca(Rhead_indexngBuffer *ring_buffer,uhead_indexnt8_t c)\n\n{\n  head_indexnt head_index;\n  uhead_indexnt next_head_index;\n  \n  head_index = ring_buffer->_head_indexHead;\n  next_head_index = head_index + 1U & 0x7f;\n  head_indexf (next_head_index != ring_buffer->_head_indexTahead_indexl) {\n    ring_buffer->_aucBuffer[ring_buffer->_head_indexHead] = c;\n    ring_buffer->_head_indexHead = next_head_index;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "store_char_000811ca",
                "this": "ring_buffer",
                "i": "head_index",
                "uVar1": "next_head_index"
            },
            "calling": [
                "IrqHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "timed_read_000811e8",
            "code": "\n/* DWARF original prototype: int  timedRead_000811e8(Stream * stream) */\n\nint __streamcall Stream::timedRead_000811e8(Stream *stream)\n\n{\n  uint32_t currentMillis;\n  int character;\n  int c;\n  \n  currentMillis = millis();\n  stream->_startMillis = currentMillis;\n  do {\n    character = (*(stream->super_Print)._vptr_Print[3])();\n    if (-1 < character) {\n      return character;\n    }\n    currentMillis = millis();\n  } while (currentMillis - stream->_startMillis < stream->_timeout);\n  return -1;\n}\n\n",
            "renaming": {
                "this": "stream",
                "uVar1": "currentMillis",
                "iVar2": "character",
                "FUN_000811e8": "timed_read_000811e8"
            },
            "calling": [
                "readStringUntil"
            ],
            "called": [
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "read_string_until_00081214",
            "code": "\n/* DWARF original prototype: String  readStringUntil_00081214(Stream * stream, char terminator) */\n\nString * __streamcall Stream::readStringUntil_00081214(Stream *stream,char terminator)\n\n{\n  String *result;\n  String *string;\n  int character;\n  int c;\n  \n  String::String(result,\"\");\n  while( true ) {\n    character = timedRead(stream);\n    if ((character < 0) || (character == terminator)) break;\n    String::concat(result,(char)character);\n  }\n  stringurn result;\n}\n\n",
            "renaming": {
                "FUN_00081214": "read_string_until_00081214",
                "this": "stream",
                "in_r0": "result",
                "ret": "string",
                "iVar1": "character"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "timedRead",
                "String",
                "concat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081244": {
            "entrypoint": "0x00081244",
            "current_name": "is_uart_valid_00081244",
            "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * uartInstance) */\n\nbool __uartInstancecall UARTClass::isUARTValid_00081244(UARTClass *uartInstance)\n\n{\n  return true;\n}\n\n",
            "renaming": {
                "FUN_00081244": "is_uart_valid_00081244",
                "this": "uartInstance"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "get_available_bytes_00081248",
            "code": "\n/* DWARF original prototype: int  available(UARTClass * uart) */\n\nint __uartcall UARTClass::getAvailableBytes_00081248(UARTClass *uart)\n\n{\n  return uart->rxBuffer->bufferHead - uart->rxBuffer->bufferTail & 0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "get_available_bytes_00081248",
                "this": "uart",
                "_rx_buffer": "rxBuffer",
                "_iHead": "bufferHead",
                "_iTail": "bufferTail"
            },
            "calling": [
                "loop",
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008125a": {
            "entrypoint": "0x0008125a",
            "current_name": "peek_0008125a",
            "code": "\n/* DWARF original prototype: int  peek_0008125a(UARTClass * uart) */\n\nint __uartcall UARTClass::peek_0008125a(UARTClass *uart)\n\n{\n  uint value;\n  RingBuffer *ringBuffer;\n  \n  ringBuffer = uart->rxBuffer;\n  if (ringBuffer->headIndex == ringBuffer->tailIndex) {\n    value = 0xffffffff;\n  }\n  else {\n    value = (uint)ringBuffer->buffer[ringBuffer->tailIndex];\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_0008125a": "peek_0008125a",
                "this": "uart",
                "pRVar2": "ringBuffer",
                "uVar1": "value",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "read_byte_from_buffer_00081276",
            "code": "\n/* DWARF original prototype: int  read(UARTClass * uart) */\n\nssize_t __uartcall UARTClass::readByteFromBuffer_00081276(UARTClass *uart,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte currentByte;\n  byte uc;\n  Buffer *pRVar2;\n  \n  pRVar2 = uart->rxBuffer;\n  if (pRVar2->headIndex != pRVar2->tailIndex) {\n    currentByte = pRVar2->bufferData[pRVar2->tailIndex];\n    pRVar2->tailIndex = pRVar2->tailIndex + 1U & 0x7f;\n    return (uint)currentByte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081276": "read_byte_from_buffer_00081276",
                "this": "uart",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "uint8_t": "byte",
                "RingBuffer": "Buffer",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "bufferData",
                "bVar1": "currentByte"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812a0": {
            "entrypoint": "0x000812a0",
            "current_name": "wait_for_transmission_completion_000812a0",
            "code": "\n/* DWARF original prototype: void  flush(UARTClass * uartInstance) */\n\nvoid __uartInstancecall UARTClass::waitForTransmissionCompletion_000812a0(UARTClass *uartInstance)\n\n{\n  do {\n  } while (uartInstance->transmitBuffer->headIndex != uartInstance->transmitBuffer->tailIndex);\n  do {\n  } while (-1 < (int)(uartInstance->uartPeripheral->UART_SR << 0x16));\n  return;\n}\n\n",
            "renaming": {
                "FUN_000812a0": "wait_for_transmission_completion_000812a0",
                "this": "uartInstance",
                "_tx_buffer": "transmitBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_pUart": "uartPeripheral"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "write_to_uart_000812b8",
            "code": "\n/* DWARF original prototype: size_t  write(UARTClass * uart_instance, uint8_t uc_data) */\n\nssize_t __uart_instancecall UARTClass::write_to_UART_000812b8(UARTClass *uart_instance,int data,void *buffer,size_t buffer_size)\n\n{\n  RingBuffer *ring_buffer;\n  uint next_head;\n  \n  ring_buffer = uart_instance->_tx_buffer;\n  if (((int)(uart_instance->_pUart->UART_SR << 0x1e) < 0) && (ring_buffer->_iTail == ring_buffer->_iHead)) {\n    uart_instance->_pUart->UART_THR = data;\n  }\n  else {\n    next_head = ring_buffer->_iHead + 1U & 0x8000007f;\n    if ((int)next_head < 0) {\n      next_head = (next_head - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (ring_buffer->_iTail == next_head);\n    ring_buffer->_aucBuffer[ring_buffer->_iHead] = (uchar)data;\n    uart_instance->_tx_buffer->_iHead = next_head;\n    uart_instance->_pUart->UART_IER = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "write_to_uart_000812b8",
                "this": "uart_instance",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "buffer_size",
                "pRVar1": "ring_buffer",
                "uVar2": "next_head"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008130c": {
            "entrypoint": "0x0008130c",
            "current_name": "end_uart_0008130c",
            "code": "\n/* DWARF original prototype: void  end(UARTClass * uartObj) */\n\nvoid __uartObjcall UARTClass::endUART_0008130c(UARTClass *uartObj)\n\n{\n  uartObj->rxBuffer->newHead = uartObj->rxBuffer->newTail;\n  (**(code **)(*(int *)uartObj + 0x14))();\n  *(int *)((((uint)(int)uartObj->irqValue >> 5) + 0x20) * 4 + -0x1fff1f00) =\n       1 << (uint)(byte)(uartObj->irqValue & 0x1f);\n  pmc_disable_periph_clk(uartObj->_dwId);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008130c": "end_uart_0008130c",
                "this": "uartObj",
                "_rx_buffer": "rxBuffer",
                "_iHead": "newHead",
                "_iTail": "newTail",
                "_dwIrq": "irqValue"
            },
            "calling": [],
            "called": [
                "pmc_disable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_uart_00081348",
            "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * UARTObject, Uart * uartPointer, IRQn_Type interruptType,\n   uint32_t deviceId, RingBuffer * receiveBuffer, RingBuffer * transmitBuffer) */\n\nUARTClass * __UARTObjectcall\nUARTClass::initializeUART_00081348(UARTClass *UARTObject,Uart *uartPointer,IRQn_Type interruptType,uint32_t deviceId,RingBuffer *receiveBuffer,\n          RingBuffer *transmitBuffer)\n\n{\n  *(undefined4 *)&UARTObject->field_0x4 = 0;\n  *(undefined4 *)&UARTObject->field_0x8 = 1000;\n  UARTObject->_uartPointer = uartPointer;\n  *(undefined ***)UARTObject = &PTR_write_1_00085650;\n  UARTObject->_interruptType = interruptType;\n  UARTObject->_rx_buffer = receiveBuffer;\n  UARTObject->_deviceId = deviceId;\n  UARTObject->_tx_buffer = transmitBuffer;\n  return UARTObject;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_uart_00081348",
                "this": "UARTObject",
                "pUart": "uartPointer",
                "dwIrq": "interruptType",
                "dwId": "deviceId",
                "pRx_buffer": "receiveBuffer",
                "pTx_buffer": "transmitBuffer"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription",
                "USARTClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008136c": {
            "entrypoint": "0x0008136c",
            "current_name": "initialize_uart_0008136c",
            "code": "\n/* DWARF original prototype: void  init(UARTClass * uartClass, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __uartClasscall UARTClass::initializeUART_0008136c(UARTClass *uartClass,EVP_PKEY_CTX *evpPkeyContext)\n\n{\n  uint irqPriority;\n  RingBuffer *rxBuffer;\n  RwReg uartModeReg;\n  Uart *uart;\n  \n  pmc_enable_periph_clk(uartClass->peripheralClockId);\n  uart = uartClass->uartPtr;\n  uart->UART_PTCR = 0x202;\n  uart->UART_CR = 0xac;\n  uart->UART_MR = uartModeReg;\n  uart->UART_BRGR = systemCoreClock / (uint)evpPkeyContext >> 4;\n  uart->UART_IDR = 0xffffffff;\n  uart->UART_IER = 0x61;\n  irqPriority = (uint)(int)uartClass->irq >> 5;\n  *(int *)(irqPriority * 4 + -0x1fff1f00) = 1 << (uint)(byte)(uartClass->irq & 0x1f);\n  rxBuffer = uartClass->_rx_buffer;\n  rxBuffer->_iTail = 0;\n  rxBuffer->_iHead = 0;\n  rxBuffer = uartClass->_tx_buffer;\n  rxBuffer->_iTail = 0;\n  rxBuffer->_iHead = 0;\n  uart->UART_CR = 0x50;\n  return irqPriority;\n}\n\n",
            "renaming": {
                "FUN_0008136c": "initialize_uart_0008136c",
                "this": "uartClass",
                "ctx": "evpPkeyContext",
                "uVar1": "irqPriority",
                "pRVar2": "rxBuffer",
                "in_r2": "uartModeReg",
                "pUVar3": "uart",
                "_dwId": "peripheralClockId",
                "_pUart": "uartPtr",
                "_dwIrq": "irq",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "begin",
                "begin"
            ],
            "called": [
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_uart_000813dc",
            "code": "\n/* DWARF original prototype: void  begin(UARTClass * uartInstance, uint32_t baudRate) */\n\nvoid __uartInstancecall UARTClass::initializeUART_000813dc(UARTClass *uartInstance,uint32_t baudRate)\n\n{\n  init(uartInstance,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_uart_000813dc",
                "this": "uartInstance",
                "dwBaudRate": "baudRate"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e4": {
            "entrypoint": "0x000813e4",
            "current_name": "handle_uart_interrupt_000813e4",
            "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * uartObject) */\n\nvoid __uartObjectcall UARTClass::handleUARTInterrupt_000813e4(UARTClass *uartObject)\n\n{\n  RingBuffer *txBuffer;\n  uint32_t uartStatus;\n  RoReg uartSR;\n  \n  uartSR = uartObject->_pUart->UART_SR;\n  if ((int)(uartSR << 0x1f) < 0) {\n    RingBuffer::store_char(uartObject->_rx_buffer,(uint8_t)uartObject->_pUart->UART_RHR);\n  }\n  if ((int)(uartSR << 0x1e) < 0) {\n    txBuffer = uartObject->_tx_buffer;\n    if (txBuffer->_iTail != txBuffer->_iHead) {\n      uartObject->_pUart->UART_THR = (uint)txBuffer->_aucBuffer[txBuffer->_iTail];\n      txBuffer->_iTail = txBuffer->_iTail + 1U & 0x7f;\n      return;\n    }\n    uartObject->_pUart->UART_IDR = 2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "uartObject",
                "pRVar1": "txBuffer",
                "status": "uartStatus",
                "RVar2": "uartSR",
                "FUN_000813e4": "handle_uart_interrupt_000813e4"
            },
            "calling": [
                "USART3_Handler",
                "USART0_Handler",
                "USART1_Handler",
                "UART_Handler"
            ],
            "called": [
                "store_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008142e": {
            "entrypoint": "0x0008142e",
            "current_name": "initialize_usart_0008142e",
            "code": "\n/* DWARF original prototype: void  begin(USARTClass * usartInstance, uint32_t baudRate) */\n\nvoid __usartInstancecall USARTClass::initializeUSART_0008142e(USARTClass *usartInstance,uint32_t baudRate)\n\n{\n  UARTClass::init(&usartInstance->super_UARTClass,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008142e": "initialize_usart_0008142e",
                "this": "usartInstance",
                "dwBaudRate": "baudRate"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "initialize_usart_00081438",
            "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * USARTInstance, Usart * usartPtr, IRQn_Type\n   interruptNum, uint32_t id, RingBuffer * rxBuffer, RingBuffer * txBuffer) */\n\nUSARTClass * __USARTInstancecall\nUSARTClass::initializeUSART_00081438(USARTClass *USARTInstance,Usart *usartPtr,IRQn_Type interruptNum,uint32_t id,RingBuffer *rxBuffer,\n          RingBuffer *txBuffer)\n\n{\n  UARTInstance::UARTInstance(&USARTInstance->superUARTInstance,(Uart *)usartPtr,interruptNum,id,rxBuffer,txBuffer);\n  *(undefined ***)&USARTInstance->superUARTInstance = &PTR_write_1_00085680;\n  USARTInstance->pUsart = usartPtr;\n  return USARTInstance;\n}\n\n",
            "renaming": {
                "FUN_00081438": "initialize_usart_00081438",
                "this": "USARTInstance",
                "pUsart": "usartPtr",
                "dwIrq": "interruptNum",
                "dwId": "id",
                "pRx_buffer": "rxBuffer",
                "pTx_buffer": "txBuffer",
                "UARTClass": "UARTInstance",
                "super_UARTClass": "superUARTInstance",
                "_pUsart": "pUsart"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "UARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "map_value_0008145c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nlong mapValue_0008145c(long inputValue,long inputMin,long inputMax,long outputMin,long outputMax)\n\n{\n  return (uint)((inputValue - inputMin) * (outputMax - outputMin)) / (uint)(inputMax - inputMin) + outputMin;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "map_value_0008145c",
                "x": "inputValue",
                "in_min": "inputMin",
                "in_max": "inputMax",
                "out_min": "outputMin",
                "out_max": "outputMax"
            },
            "calling": [
                "write",
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081470": {
            "entrypoint": "0x00081470",
            "current_name": "FUNC_00081470",
            "code": "\n/* DWARF original prototype: void  StringIfHelper(String * this) */\n\nvoid __thiscall String::FUNC_00081470(String *this)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081470": "FUNC_00081470"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "deallocate_string_buffer_00081472",
            "code": "\n/* DWARF original prototype: void *  ~String(String * stringObject, int unusedParameter) */\n\nvoid * __stringObjectcall String::deallocateStringBuffer_00081472(String *stringObject,int unusedParameter)\n\n{\n  free(stringObject->buffer);\n  return stringObject;\n}\n\n",
            "renaming": {
                "FUN_00081472": "deallocate_string_buffer_00081472",
                "this": "stringObject",
                "__in_chrg": "unusedParameter"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "clear_string_00081480",
            "code": "\n/* DWARF original prototype: void  invalidate(String * str) */\n\nvoid __strcall String::clearString_00081480(String *str)\n\n{\n  if (str->strBuffer != (char *)0x0) {\n    free(str->strBuffer);\n  }\n  str->strBuffer = (char *)0x0;\n  str->length = 0;\n  str->capacity = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "str",
                "buffer": "strBuffer",
                "len": "length",
                "FUN_00081480": "clear_string_00081480"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "resize_buffer_00081496",
            "code": "\n/* DWARF original prototype: uchar  changeBuffer(String * strObj, uint newSize) */\n\nuchar __strObjcall String::resizeBuffer_00081496(String *strObj,uint newSize)\n\n{\n  char *newBuffer;\n  char *newbuffer;\n  \n  newBuffer = (char *)reallocate(strObj->buffer,newSize + 1);\n  if (newBuffer != (char *)0x0) {\n    strObj->buffer = newBuffer;\n    strObj->capacity = newSize;\n    newBuffer = (char *)0x1;\n  }\n  return (uchar)newBuffer;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "maxStrLen": "newSize",
                "pcVar1": "newBuffer",
                "realloc": "reallocate",
                "FUN_00081496": "resize_buffer_00081496"
            },
            "calling": [
                "reserve"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "reserve_string_buffer_000814ae",
            "code": "\n/* DWARF original prototype: uchar  reserve(String * str, uint newSize) */\n\nuchar __strcall String::reserveStringBuffer_000814ae(String *str,uint newSize)\n\n{\n  uchar success;\n  \n  if ((str->buffer == (char *)0x0) || (str->capacity < newSize)) {\n    success = resizeBuffer(str,newSize);\n    if (success == '\\0') {\n      return '\\0';\n    }\n    if (str->len == 0) {\n      *str->buffer = '\\0';\n    }\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "this": "str",
                "size": "newSize",
                "uVar1": "success",
                "changeBuffer": "resizeBuffer",
                "FUN_000814ae": "reserve_string_buffer_000814ae"
            },
            "calling": [
                "copy",
                "concat"
            ],
            "called": [
                "changeBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "copy_string_000814d0",
            "code": "\n/* DWARF original prototype: String *  copy(String * strObject, char * cstr, uint length) */\n\nint __strObjectcall String::copyString_000814d0(String *strObject,EVP_PKEY_CTX *destination,EVP_PKEY_CTX *source)\n\n{\n  uchar reserveSuccess;\n  \n  reserveSuccess = reserve(strObject,(uint)source);\n  if (reserveSuccess == '\\0') {\n    invalidate(strObject);\n  }\n  else {\n    strObject->len = (uint)source;\n    strcpy(strObject->buffer,(char *)destination);\n  }\n  return (int)strObject;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "copy_string_000814d0",
                "this": "strObject",
                "dst": "destination",
                "src": "source",
                "uVar1": "reserveSuccess"
            },
            "calling": [
                "String"
            ],
            "called": [
                "invalidate",
                "strcpy",
                "reserve"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "initialize_string_000814f6",
            "code": "\n/* DWARF original prototype: String *  String(String * stringObject, char * inputString) */\n\nString * __stringObjectcall String::initializeString_000814f6(String *stringObject,char *inputString)\n\n{\n  EVP_PKEY_CTX *stringLength;\n  \n  stringObject->buffer = (char *)0x0;\n  stringObject->capacity = 0;\n  stringObject->len = 0;\n  if (inputString != (char *)0x0) {\n    stringLength = (EVP_PKEY_CTX *)strlen(inputString);\n    copy(stringObject,(EVP_PKEY_CTX *)inputString,stringLength);\n  }\n  return stringObject;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "cstr": "inputString",
                "src": "stringLength",
                "FUN_000814f6": "initialize_string_000814f6"
            },
            "calling": [
                "readStringUntil",
                "_GLOBAL__sub_I_steering"
            ],
            "called": [
                "copy",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "copy_string_0008151c",
            "code": "\n/* DWARF original prototype: void  move(String * destinationString, String * sourceString) */\n\nvoid __destinationStringcall String::copyString_0008151c(String *destinationString,String *sourceString)\n\n{\n  char *dst;\n  \n  dst = destinationString->buffer;\n  if (dst != (char *)0x0) {\n    if ((sourceString->buffer != (char *)0x0) && (sourceString->len <= destinationString->capacity)) {\n      strcpy(dst,sourceString->buffer);\n      destinationString->len = sourceString->len;\n      goto LAB_00081558;\n    }\n    free(dst);\n  }\n  destinationString->buffer = sourceString->buffer;\n  destinationString->capacity = sourceString->capacity;\n  destinationString->len = sourceString->len;\n  sourceString->buffer = (char *)0x0;\n  sourceString->capacity = 0;\nLAB_00081558:\n  sourceString->len = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "destinationString",
                "rhs": "sourceString",
                "__dest": "dst",
                "FUN_0008151c": "copy_string_0008151c"
            },
            "calling": [
                "operator="
            ],
            "called": [
                "free",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "assign_string_00081560",
            "code": "\n/* DWARF original prototype: String *  operator=(String * destination, String * source) */\n\nString * __destinationcall String::assignString_00081560(String *destination,String *source)\n\n{\n  if (destination != source) {\n    move(destination,source);\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "this": "destination",
                "rval": "source",
                "FUN_00081560": "assign_string_00081560"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "move"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "concatenate_strings_00081570",
            "code": "\n/* DWARF original prototype: uchar  concat(String * stringObject, char * inputString, uint inputLength) */\n\nuchar __stringObjectcall String::concatenateStrings_00081570(String *stringObject,char *inputString,uint inputLength)\n\n{\n  uchar success;\n  uint newSize;\n  \n  if (inputString == (char *)0x0) {\n    return '\\0';\n  }\n  if (inputLength != 0) {\n    newSize = stringObject->len + inputLength;\n    success = reserve(stringObject,newSize);\n    if (success == '\\0') {\n      return '\\0';\n    }\n    strcpy(stringObject->buffer + stringObject->len,inputString);\n    stringObject->len = newSize;\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "cstr": "inputString",
                "length": "inputLength",
                "uVar1": "success",
                "size": "newSize",
                "FUN_00081570": "concatenate_strings_00081570"
            },
            "calling": [
                "concat"
            ],
            "called": [
                "strcpy",
                "reserve"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "concatenate_characters_0008159e",
            "code": "\n/* DWARF original prototype: uchar  concat(String * stringObject, char c) */\n\nuchar __stringObjectcall String::concatenateCharacters_0008159e(String *stringObject,char c)\n\n{\n  uchar uVar1;\n  char buffer [2];\n  short stackVariable;\n  \n  uVar1 = concat(stringObject,buffer,1);\n  return uVar1;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "buf": "buffer",
                "sStack_a": "stackVariable",
                "FUN_0008159e": "concatenate_characters_0008159e"
            },
            "calling": [
                "readStringUntil"
            ],
            "called": [
                "concat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "compare_string_000815b8",
            "code": "\n/* DWARF original prototype: uchar  equals(String * strObj, char * cString) */\n\nuchar __strObjcall String::compareString_000815b8(String *strObj,char *cString)\n\n{\n  uchar result;\n  uint comparisonResult;\n  \n  if (strObj->len == 0) {\n    if (cString == (char *)0x0) {\n      return '\\x01';\n    }\n  }\n  else {\n    if (cString != (char *)0x0) {\n      comparisonResult = strcmp(strObj->buffer,cString);\n      goto LAB_000815d4;\n    }\n    cString = strObj->buffer;\n  }\n  comparisonResult = (uint)(byte)*cString;\nLAB_000815d4:\n  result = '\\x01' - (char)comparisonResult;\n  if (1 < comparisonResult) {\n    result = '\\0';\n  }\n  return result;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "cstr": "cString",
                "uVar1": "result",
                "uVar2": "comparisonResult",
                "FUN_000815b8": "compare_string_000815b8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "convert_string_to_long_000815de",
            "code": "\n/* DWARF original prototype: long  toInt(String * str) */\n\nlong __strcall String::convertStringToLong_000815de(String *str)\n\n{\n  long convertedValue;\n  \n  if (str->buffer != (char *)0x0) {\n    convertedValue = atol(str->buffer);\n    return convertedValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "this": "str",
                "lVar1": "convertedValue",
                "FUN_000815de": "convert_string_to_long_000815de"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "atol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "run_program_000815ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runProgram_000815ec(void)\n\n{\n  EVP_PKEY_CTX *pkeyContext;\n  \n  _watchdogDefaultSetup();\n  init(pkeyContext);\n  initVariant();\n  delay(1);\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "run_program_000815ec",
                "in_r0": "pkeyContext"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "delay",
                "init",
                "loop",
                "_watchdogDefaultSetup",
                "setup",
                "serialEventRun",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "disable_watchdog_timer_00081618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableWatchdogTimer_00081618(void)\n\n{\n  disableWatchdog(0x400e1a50);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "disable_watchdog_timer_00081618",
                "WDT_Disable": "disableWatchdog"
            },
            "calling": [
                "main"
            ],
            "called": [
                "WDT_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "measure_pulse_width_00081624",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t measurePulseWidth_00081624(uint32_t pinNumber,uint32_t desiredState,uint32_t timeoutMs)\n\n{\n  uint32_t pulseCount;\n  uint32_t pulseWidth;\n  uint32_t pinMask;\n  uint32_t bitMask;\n  \n  pinMask = g_APinDescription[pinNumber].ulPin;\n  if (desiredState == 0) {\n    pinMask = 0;\n  }\n  pulseCount = countPulseASM(&(g_APinDescription[pinNumber].pPort)->PIO_PDSR,g_APinDescription[pinNumber].ulPin,\n                        pinMask,((SystemCoreClock / 1000000) * timeoutMs) / 0x12);\n  if (pulseCount != 0) {\n    pulseCount = (uint32_t)((ulonglong)(pulseCount * 18000 + 16000) / ((ulonglong)SystemCoreClock / 1000));\n  }\n  return pulseCount;\n}\n\n",
            "renaming": {
                "FUN_00081624": "measure_pulse_width_00081624",
                "pin": "pinNumber",
                "state": "desiredState",
                "timeout": "timeoutMs",
                "uVar1": "pulseCount",
                "width": "pulseWidth",
                "stateMask": "pinMask",
                "bit": "bitMask"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "countPulseASM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_bit_conditions_00081684",
            "code": "\nint check_bit_conditions_00081684(uint *bit_array,uint bit_mask,uint desired_value,int num_iterations)\n\n{\n  int counter;\n  \n  do {\n    if ((*bit_array & bit_mask) != desired_value) {\n      do {\n        if ((*bit_array & bit_mask) == desired_value) {\n          counter = 0;\n          do {\n            if ((*bit_array & bit_mask) != desired_value) {\n              return counter;\n            }\n            counter = counter + 1;\n          } while (num_iterations != counter);\n          return 0;\n        }\n        num_iterations = num_iterations + -1;\n      } while (num_iterations != 0);\n      return 0;\n    }\n    num_iterations = num_iterations + -1;\n  } while (num_iterations != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_bit_conditions_00081684",
                "param_1": "bit_array",
                "param_2": "bit_mask",
                "param_3": "desired_value",
                "param_4": "num_iterations",
                "iVar1": "counter"
            },
            "calling": [
                "pulseIn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816c8": {
            "entrypoint": "0x000816c8",
            "current_name": "increment_tick_count_000816c8",
            "code": "\nvoid incrementTickCount_000816c8(void)\n\n{\n  tickCounter = tickCounter + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816c8": "increment_tick_count_000816c8",
                "_dwTickCount": "tickCounter"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_tick_count_000816d8",
            "code": "\nundefined4 getTickCount_000816d8(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_tick_count_000816d8",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "millis"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816e4": {
            "entrypoint": "0x000816e4",
            "current_name": "initialize_parameter_000816e4",
            "code": "\nvoid initializeParameter_000816e4(int p)\n\n{\n  *(undefined4 *)(p + 4) = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816e4": "initialize_parameter_000816e4",
                "param_1": "p"
            },
            "calling": [
                "_watchdogDefaultSetup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "register_exit_handler_000816ec",
            "code": "\nvoid registerExitHandler_000816ec(undefined4 exitHandler,undefined4 handlerPriority)\n\n{\n  __cxa_atexit(handlerPriority,exitHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "register_exit_handler_000816ec",
                "param_1": "exitHandler",
                "param_2": "handlerPriority"
            },
            "calling": [
                "_GLOBAL__sub_I_steering"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "log_and_abort_000816f8",
            "code": "\nvoid logAndAbort_000816f8(undefined4 assertion,undefined4 lineNumber,char *functionName,undefined4 failedCondition)\n\n{\n  char *separator;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    separator = functionName;\n  }\n  else {\n    separator = \", function: \";\n  }\n  formattedPrint(*(undefined4 *)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           failedCondition,assertion,lineNumber,separator,functionName);\n                    \n  terminate();\n}\n\n",
            "renaming": {
                "FUN_000816f8": "log_and_abort_000816f8",
                "param_1": "assertion",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "failedCondition",
                "pcVar1": "separator",
                "fiprintf": "formattedPrint",
                "abort": "terminate"
            },
            "calling": [
                "TC_Configure",
                "TC_Start"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081734": {
            "entrypoint": "0x00081734",
            "current_name": "convert_string_to_long_00081734",
            "code": "\nlong convertStringToLong_00081734(char *stringToConvert)\n\n{\n  long convertedLongValue;\n  \n  convertedLongValue = strtol(stringToConvert,(char **)0x0,10);\n  return convertedLongValue;\n}\n\n",
            "renaming": {
                "FUN_00081734": "convert_string_to_long_00081734",
                "__nptr": "stringToConvert",
                "lVar1": "convertedLongValue"
            },
            "calling": [
                "toInt"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008173c": {
            "entrypoint": "0x0008173c",
            "current_name": "register_exit_procedure_0008173c",
            "code": "\nvoid registerExitProcedure_0008173c(undefined4 exitProcParam1,undefined4 exitProcParam2,undefined4 exitProcParam3)\n\n{\n  __register_exitproc(2,exitProcParam1,exitProcParam2,exitProcParam3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008173c": "register_exit_procedure_0008173c",
                "param_1": "exitProcParam1",
                "param_2": "exitProcParam2",
                "param_3": "exitProcParam3"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "print_stack_values_00081750",
            "code": "\nvoid printStackValues_00081750(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 stackValue1;\n  undefined4 stackValue2;\n  \n  stackValue1 = arg2;\n  stackValue2 = arg3;\n  _vfiprintf_r(_impure_ptr,formatString,arg1,&stackValue1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "print_stack_values_00081750",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_8": "stackValue1",
                "uStack_4": "stackValue2"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "initialize_and_execute_functions_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid initialize_and_execute_functions_00081778(void)\n\n{\n  int loop_counter;\n  code **function_array_ptr;\n  \n  _init();\n  function_array_ptr = (code **)0x8584c;\n  loop_counter = 0;\n  do {\n    loop_counter = loop_counter + 1;\n    function_array_ptr = function_array_ptr + 1;\n    (**function_array_ptr)();\n  } while (loop_counter != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "initialize_and_execute_functions_00081778",
                "iVar1": "loop_counter",
                "ppcVar2": "function_array_ptr"
            },
            "calling": [
                "init"
            ],
            "called": [
                "register_fini",
                "frame_dummy",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "print_formatted_message_000817c8",
            "code": "\nvoid printFormattedMessage_000817c8(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 arg1_copy;\n  undefined4 arg2_copy;\n  undefined4 arg3_copy;\n  \n  arg1_copy = arg1;\n  arg2_copy = arg2;\n  arg3_copy = arg3;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),formatString,&arg1_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "print_formatted_message_000817c8",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_c": "arg1_copy",
                "uStack_8": "arg2_copy",
                "uStack_4": "arg3_copy"
            },
            "calling": [
                "_exit"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "allocate_memory_000817f0",
            "code": "\nvoid * allocateMemory_000817f0(size_t size)\n\n{\n  void *allocatedMemory;\n  \n  allocatedMemory = (void *)_malloc_r(_impure_ptr,size);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "allocate_memory_000817f0",
                "__size": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "free_memory_00081800",
            "code": "\nvoid freeMemory_00081800(void *memoryPtr)\n\n{\n  _free_r(_impure_ptr,memoryPtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "free_memory_00081800",
                "__ptr": "memoryPtr"
            },
            "calling": [
                "move",
                "invalidate",
                "~String"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "allocate_memory_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocateMemory_00081810(undefined4 *param_1,uint size)\n\n{\n  undefined1 *ptr1;\n  int var1;\n  uint var2;\n  uint var3;\n  int var4;\n  uint var5;\n  uint var6;\n  uint var7;\n  undefined4 *ptr2;\n  undefined1 *ptr3;\n  undefined1 *ptr4;\n  undefined1 *ptr5;\n  uint var8;\n  undefined4 *ptr6;\n  undefined4 *ptr7;\n  undefined1 *ptr8;\n  \n  if (size + 0xb < 0x17) {\n    var8 = 0x10;\n    if (0x10 < size) goto LAB_00081876;\n  }\n  else {\n    var8 = size + 0xb & 0xfffffff8;\n    if (((int)var8 < 0) || (var8 < size)) {\nLAB_00081876:\n      *param_1 = 0xc;\n      return (int *)0x0;\n    }\n  }\n  mallocLock(param_1);\n  ptr6 = DAT_20070474;\n  if (var8 < 0x1f8) {\n    ptr5 = *(undefined1 **)((int)&DAT_20070470 + var8);\n    if ((ptr5 != &malloc_av + var8) ||\n       (ptr4 = ptr5 + 8, ptr5 = *(undefined1 **)(ptr5 + 0x14), ptr4 != ptr5)) {\n      var7 = *(uint *)(ptr5 + 4);\n      var4 = *(int *)(ptr5 + 0xc);\n      var8 = *(uint *)(ptr5 + (var7 & 0xfffffffc) + 4);\n      var1 = *(int *)(ptr5 + 8);\n      *(int *)(var1 + 0xc) = var4;\n      *(int *)(var4 + 8) = var1;\n      *(uint *)(ptr5 + (var7 & 0xfffffffc) + 4) = var8 | 1;\n      mallocUnlock(param_1);\n      return (int *)(ptr5 + 8);\n    }\n    var7 = (var8 >> 3) + 2;\n  }\n  else {\n    var7 = var8 >> 9;\n    if (var7 == 0) {\n      var4 = 0x7e;\n      var1 = 0x3f;\n    }\n    else if (var7 < 5) {\n      var1 = (var8 >> 6) + 0x38;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x15) {\n      var1 = var7 + 0x5b;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x55) {\n      var1 = (var8 >> 0xc) + 0x6e;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x155) {\n      var1 = (var8 >> 0xf) + 0x77;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x555) {\n      var1 = (var8 >> 0x12) + 0x7c;\n      var4 = var1 * 2;\n    }\n    else {\n      var4 = 0xfc;\n      var1 = 0x7e;\n    }\n    for (ptr5 = (undefined1 *)(&DAT_20070470)[var4]; &malloc_av + var4 * 4 != ptr5;\n        ptr5 = *(undefined1 **)(ptr5 + 0xc)) {\n      var7 = *(uint *)(ptr5 + 4) & 0xfffffffc;\n      if (0xf < (int)(var7 - var8)) {\n        var1 = var1 + -1;\n        break;\n      }\n      if (-1 < (int)(var7 - var8)) {\n        var8 = *(uint *)(ptr5 + var7 + 4);\n        var4 = *(int *)(ptr5 + 0xc);\n        var1 = *(int *)(ptr5 + 8);\n        *(int *)(var1 + 0xc) = var4;\n        *(int *)(var4 + 8) = var1;\n        *(uint *)(ptr5 + var7 + 4) = var8 | 1;\n        mallocUnlock(param_1);\n        return (int *)(ptr5 + 8);\n      }\n    }\n    var7 = var1 + 1;\n  }\n  var2 = DAT_20070468;\n  if ((undefined1 **)DAT_20070474 != &DAT_2007046c) {\n    var2 = DAT_20070474[1];\n    var3 = var2 & 0xfffffffc;\n    var5 = var3 - var8;\n    if (0xf < (int)var5) {\n      ptr7 = (undefined4 *)(var8 + (int)DAT_20070474);\n      DAT_20070474[1] = var8 | 1;\n      DAT_20070474 = ptr7;\n      DAT_20070478 = ptr7;\n      ptr7[3] = &DAT_2007046c;\n      ptr7[2] = &DAT_2007046c;\n      ptr7[1] = var5 | 1;\n      *(uint *)((int)ptr7 + var5) = var5;\n      mallocUnlock(param_1);\n      return ptr6 + 2;\n    }\n    DAT_20070478 = &DAT_2007046c;\n    DAT_20070474 = &DAT_2007046c;\n    if (-1 < (int)var5) {\n      *(uint *)((int)ptr6 + var3 + 4) = *(uint *)((int)ptr6 + var3 + 4) | 1;\n      mallocUnlock(param_1);\n      return ptr6 + 2;\n    }\n    if (var3 < 0x200) {\n      var3 = var2 & 0xfffffff8;\n      var1 = *(int *)((int)&DAT_2007046c + var3);\n      var2 = 1 << ((int)(var2 >> 3) >> 2 & 0xffU) | DAT_20070468;\n      ptr6[2] = var1;\n      ptr6[3] = &malloc_av + var3;\n      DAT_20070468 = var2;\n      *(undefined4 **)((int)&DAT_2007046c + var3) = ptr6;\n      *(undefined4 **)(var1 + 0xc) = ptr6;\n    }\n    else {\n      var5 = var2 >> 9;\n      if (var5 < 5) {\n        var4 = (var2 >> 6) + 0x38;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x15) {\n        var4 = var5 + 0x5b;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x55) {\n        var4 = (var2 >> 0xc) + 0x6e;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x155) {\n        var4 = (var2 >> 0xf) + 0x77;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x555) {\n        var4 = (var2 >> 0x12) + 0x7c;\n        var1 = var4 * 2;\n      }\n      else {\n        var1 = 0xfc;\n        var4 = 0x7e;\n      }\n      ptr5 = (&DAT_2007046c)[var1];\n      if (ptr5 == &malloc_av + var1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (var4 >> 2 & 0xffU);\n        ptr4 = ptr5;\n      }\n      else {\n        do {\n          ptr4 = ptr5;\n          if ((*(uint *)(ptr5 + 4) & 0xfffffffc) <= var3) break;\n          ptr5 = *(undefined1 **)(ptr5 + 8);\n          ptr4 = ptr5;\n        } while (&malloc_av + var1 * 4 != ptr5);\n        ptr5 = *(undefined1 **)(ptr4 + 0xc);\n      }\n      var2 = DAT_20070468;\n      ptr6[3] = ptr5;\n      ptr6[2] = ptr4;\n      *(undefined4 **)(ptr5 + 8) = ptr6;\n      *(undefined4 **)(ptr4 + 0xc) = ptr6;\n    }\n  }\n  ptr5 = DAT_2007046c;\n  var3 = 1 << ((int)var7 >> 2 & 0xffU);\n  if (var3 <= var2) {\n    if ((var2 & var3) == 0) {\n      var7 = var7 & 0xfffffffc;\n      do {\n        var3 = var3 << 1;\n        var7 = var7 + 4;\n      } while ((var2 & var3) == 0);\n    }\n    do {\n      ptr7 = (undefined4 *)(&malloc_av + var7 * 8);\n      ptr6 = ptr7;\n      var2 = var7;\n      do {\n        for (ptr2 = (undefined4 *)ptr6[3]; ptr6 != ptr2; ptr2 = (undefined4 *)ptr2[3])\n        {\n          var5 = ptr2[1] & 0xfffffffc;\n          var6 = var5 - var8;\n          if (0xf < (int)var6) {\n            var4 = ptr2[2];\n            var1 = ptr2[3];\n            ptr6 = (undefined4 *)(var8 + (int)ptr2);\n            ptr2[1] = var8 | 1;\n            *(int *)(var4 + 0xc) = var1;\n            *(int *)(var1 + 8) = var4;\n            DAT_20070474 = ptr6;\n            DAT_20070478 = ptr6;\n            ptr6[3] = &DAT_2007046c;\n            ptr6[2] = &DAT_2007046c;\n            ptr6[1] = var6 | 1;\n            *(uint *)((int)ptr6 + var6) = var6;\n            mallocUnlock(param_1);\n            return ptr2 + 2;\n          }\n          if (-1 < (int)var6) {\n            var1 = ptr2[2];\n            var4 = ptr2[3];\n            *(uint *)((int)ptr2 + var5 + 4) = *(uint *)((int)ptr2 + var5 + 4) | 1;\n            *(int *)(var1 + 0xc) = var4;\n            *(int *)(var4 + 8) = var1;\n            mallocUnlock(param_1);\n            return ptr2 + 2;\n          }\n        }\n        var2 = var2 + 1;\n        ptr6 = ptr6 + 2;\n      } while ((var2 & 3) != 0);\n      do {\n        var5 = var7 & 3;\n        ptr6 = ptr7 + -2;\n        var7 = var7 - 1;\n        if (var5 == 0) {\n          DAT_20070468 = DAT_20070468 & ~var3;\n          break;\n        }\n        ptr7 = (undefined4 *)*ptr7;\n      } while (ptr7 == ptr6);\n      var3 = var3 * 2;\n      if ((DAT_20070468 <= var3 && var3 - DAT_20070468 != 0) || (var7 = var2, var3 == 0))\n      break;\n      for (; (DAT_20070468 & var3) == 0; var3 = var3 << 1) {\n        var7 = var7 + 4;\n      }\n    } while( true );\n  }\n  var7 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  if ((var8 <= var7) && (var2 = var7 - var8, ptr4 = DAT_2007046c, 0xf < (int)var2))\n  goto LAB_00081b1a;\n  ptr8 = DAT_2007046c + var7;\n  if (mallocSbrkBase == (undefined1 *)0xffffffff) {\n    var2 = var8 + mallocTopPad + 0x10;\n  }\n  else {\n    var2 = var8 + mallocTopPad + 0x100f & 0xfffff000;\n  }\n  ptr4 = (undefined1 *)sbrk(param_1,var2);\n  if ((ptr4 == (undefined1 *)0xffffffff) || ((ptr4 < ptr8 && (ptr5 != &malloc_av))))\n  {\n    var7 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    ptr4 = DAT_2007046c;\n  }\n  else {\n    ptr3 = mallocCurrentMallinfo + var2;\n    mallocCurrentMallinfo = ptr3;\n    if ((ptr8 == ptr4) && (((uint)ptr8 & 0xfff) == 0)) {\n      *(uint *)(DAT_2007046c + 4) = var2 + var7 | 1;\n    }\n    else {\n      ptr1 = ptr4;\n      if (mallocSbrkBase != (undefined1 *)0xffffffff) {\n        ptr1 = mallocSbrkBase;\n        mallocCurrentMallinfo = ptr3 + ((int)ptr4 - (int)ptr8);\n      }\n      mallocSbrkBase = ptr1;\n      var3 = (uint)ptr4 & 7;\n      if (var3 == 0) {\n        var1 = 0x1000;\n      }\n      else {\n        ptr4 = ptr4 + (8 - var3);\n        var1 = 0x1008 - var3;\n      }\n      var1 = var1 - ((uint)(ptr4 + var2) & 0xfff);\n      var4 = sbrk(param_1,var1);\n      if (var4 == -1) {\n        var2 = 1;\n        var1 = 0;\n      }\n      else {\n        var2 = (var4 - (int)ptr4) + var1 | 1;\n      }\n      ptr3 = mallocCurrentMallinfo + var1;\n      DAT_2007046c = ptr4;\n      mallocCurrentMallinfo = ptr3;\n      *(uint *)(ptr4 + 4) = var2;\n      if (ptr5 != &malloc_av) {\n        if (var7 < 0x10) {\n          *(undefined4 *)(ptr4 + 4) = 1;\n          var7 = 0;\n          goto LAB_00081b04;\n        }\n        var7 = var7 - 0xc & 0xfffffff8;\n        *(uint *)(ptr5 + 4) = var7 | *(uint *)(ptr5 + 4) & 1;\n        *(undefined4 *)(ptr5 + var7 + 4) = 5;\n        *(undefined4 *)(ptr5 + var7 + 8) = 5;\n        if (0xf < var7) {\n          _free_r(param_1,ptr5 + 8);\n          ptr3 = mallocCurrentMallinfo;\n        }\n      }\n    }\n    if (mallocMaxSbrkedMem < ptr3) {\n      mallocMaxSbrkedMem = ptr3;\n    }\n    if (mallocMaxTotalMem < ptr3) {\n      mallocMaxTotalMem = ptr3;\n    }\n    var7 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    ptr4 = DAT_2007046c;\n  }\nLAB_00081b04:\n  var2 = var7 - var8;\n  if ((var7 < var8) || ((int)var2 < 0x10)) {\n    mallocUnlock(param_1);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  DAT_2007046c = ptr4 + var8;\n  *(uint *)(ptr4 + 4) = var8 | 1;\n  *(uint *)(DAT_2007046c + 4) = var2 | 1;\n  mallocUnlock(param_1);\n  return (int *)(ptr4 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "allocate_memory_00081810",
                "param_2": "size",
                "puVar1": "ptr1",
                "iVar2": "var1",
                "uVar3": "var2",
                "uVar4": "var3",
                "iVar5": "var4",
                "uVar6": "var5",
                "uVar7": "var6",
                "uVar8": "var7",
                "puVar9": "ptr2",
                "puVar10": "ptr3",
                "puVar11": "ptr4",
                "puVar12": "ptr5",
                "uVar13": "var8",
                "puVar14": "ptr6",
                "puVar15": "ptr7",
                "puVar16": "ptr8",
                "__malloc_av_": "malloc_av",
                "__malloc_lock": "mallocLock",
                "__malloc_unlock": "mallocUnlock",
                "_sbrk_r": "sbrk",
                "__malloc_top_pad": "mallocTopPad",
                "__malloc_sbrk_base": "mallocSbrkBase",
                "__malloc_current_mallinfo": "mallocCurrentMallinfo",
                "__malloc_max_sbrked_mem": "mallocMaxSbrkedMem",
                "__malloc_max_total_mem": "mallocMaxTotalMem"
            },
            "calling": [
                "malloc",
                "__smakebuf_r",
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "mem_copy_00081d48",
            "code": "\nvoid * mem_copy_00081d48(void *dest,void *src,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined4 *src_ptr;\n  undefined4 *dest_ptr;\n  undefined *dest_ptr_tmp;\n  undefined4 *src_ptr;\n  undefined *src_ptr_tmp;\n  uint remaining_bytes;\n  uint alignment_padding;\n  bool is_aligned;\n  \n  dest_ptr = (undefined4 *)dest;\n  if ((((uint)src | (uint)dest) & 3) != 0) {\n    if (size < 8) {\n      alignment_padding = size - 4;\n      dest_ptr = (undefined *)dest;\n      if (3 < size) {\n        do {\n          src_ptr_tmp = (undefined *)src;\n          dest_ptr_tmp = dest_ptr;\n          is_aligned = alignment_padding != 0;\n          alignment_padding = alignment_padding - 1;\n          *dest_ptr_tmp = *src_ptr_tmp;\n          dest_ptr = dest_ptr_tmp + 1;\n          src = src_ptr_tmp + 1;\n        } while (is_aligned);\n        dest_ptr_tmp[1] = src_ptr_tmp[1];\n        dest_ptr_tmp[2] = src_ptr_tmp[2];\n        dest_ptr_tmp[3] = src_ptr_tmp[3];\n        return dest;\n      }\n      goto LAB_00081dcc;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dest & 3) != 0)) {\n      alignment_padding = 4 - ((uint)dest & 3);\n      size = size - alignment_padding;\n      src_ptr = (undefined4 *)dest;\n      src_ptr = (undefined4 *)src;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)dest & 1) != 0) {\n        src_ptr = (undefined4 *)((int)src + 1);\n        src_ptr = (undefined4 *)((int)dest + 1);\n        *(undefined *)dest = *src;\n      }\n      dest_ptr = src_ptr;\n      src = src_ptr;\n      if ((alignment_padding & 2) != 0) {\n        src = (void *)((int)src_ptr + 2);\n        dest_ptr = (undefined4 *)((int)src_ptr + 2);\n        *(undefined2 *)src_ptr = *(undefined2 *)src_ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *dest_ptr = *src;\n    dest_ptr[1] = *(undefined4 *)((int)src + 4);\n    dest_ptr[2] = *(undefined4 *)((int)src + 8);\n    dest_ptr[3] = *(undefined4 *)((int)src + 0xc);\n    dest_ptr[4] = *(undefined4 *)((int)src + 0x10);\n    dest_ptr[5] = *(undefined4 *)((int)src + 0x14);\n    dest_ptr[6] = *(undefined4 *)((int)src + 0x18);\n    dest_ptr[7] = *(undefined4 *)((int)src + 0x1c);\n    dest_ptr[8] = *(undefined4 *)((int)src + 0x20);\n    dest_ptr[9] = *(undefined4 *)((int)src + 0x24);\n    dest_ptr[10] = *(undefined4 *)((int)src + 0x28);\n    dest_ptr[0xb] = *(undefined4 *)((int)src + 0x2c);\n    dest_ptr[0xc] = *(undefined4 *)((int)src + 0x30);\n    dest_ptr[0xd] = *(undefined4 *)((int)src + 0x34);\n    dest_ptr[0xe] = *(undefined4 *)((int)src + 0x38);\n    dest_ptr[0xf] = *(undefined4 *)((int)src + 0x3c);\n    dest_ptr = dest_ptr + 0x10;\n    src = (undefined4 *)((int)src + 0x40);\n    size = size - 0x40;\n  }\n  remaining_bytes = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *dest_ptr = *src;\n      dest_ptr[1] = *(undefined4 *)((int)src + 4);\n      dest_ptr[2] = *(undefined4 *)((int)src + 8);\n      dest_ptr[3] = *(undefined4 *)((int)src + 0xc);\n      dest_ptr = dest_ptr + 4;\n      src = (void *)((int)src + 0x10);\n      is_aligned = 0xf < remaining_bytes;\n      remaining_bytes = remaining_bytes - 0x10;\n    } while (is_aligned);\n  }\n  alignment_padding = remaining_bytes + 0xc;\n  src_ptr = dest_ptr;\n  src_ptr = (undefined4 *)src;\n  if (0xfffffff3 < remaining_bytes) {\n    do {\n      src = src_ptr + 1;\n      *src_ptr = *src_ptr;\n      is_aligned = 3 < alignment_padding;\n      alignment_padding = alignment_padding - 4;\n      dest_ptr = src_ptr + 1;\n      src_ptr = src_ptr + 1;\n      src_ptr = (undefined4 *)src;\n    } while (is_aligned);\n  }\nLAB_00081dcc:\n  if (alignment_padding + 4 != 0) {\n    src_ptr = dest_ptr;\n    src_ptr = (undefined4 *)src;\n                    /* WARNING: Load size is inaccurate */\n    if ((alignment_padding & 1) != 0) {\n      src_ptr = (undefined4 *)((int)src + 1);\n      src_ptr = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = *src;\n    }\n    if ((alignment_padding + 4 & 2) != 0) {\n      *(undefined2 *)src_ptr = *(undefined2 *)src_ptr;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "mem_copy_00081d48",
                "__dest": "dest",
                "__src": "src",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "puVar3": "dest_ptr",
                "puVar4": "dest_ptr_tmp",
                "puVar5": "src_ptr",
                "puVar6": "src_ptr_tmp",
                "uVar7": "remaining_bytes",
                "uVar8": "alignment_padding",
                "bVar9": "is_aligned"
            },
            "calling": [
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "reverse_copy_00081e34",
            "code": "\nvoid * reverseCopy_00081e34(void *destination,void *source,size_t size)\n\n{\n  int iterationVariable;\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *destPtr2;\n  undefined *srcPtr2;\n  uint remainingSize;\n  undefined *destPtr3;\n  uint remainingSize2;\n  \n  if ((source < destination) && (srcPtr2 = (undefined *)((int)source + size), destination < srcPtr2)) {\n    destPtr3 = (undefined *)((int)destination + size);\n    iterationVariable = size - 1;\n    if (size != 0) {\n      do {\n        srcPtr2 = srcPtr2 + -1;\n        iterationVariable = iterationVariable + -1;\n        destPtr3 = destPtr3 + -1;\n        *destPtr3 = *srcPtr2;\n      } while (iterationVariable != -1);\n    }\n    return destination;\n  }\n  destPtr = (undefined4 *)destination;\n  if (size < 0x10) {\n    if (size == 0) {\n      return destination;\n    }\n  }\n  else if ((((uint)destination | (uint)source) & 3) == 0) {\n    srcPtr = (undefined4 *)source;\n    do {\n      destPtr2 = destPtr + 4;\n      *destPtr = *srcPtr;\n      destPtr[1] = srcPtr[1];\n      destPtr[2] = srcPtr[2];\n      destPtr[3] = srcPtr[3];\n      destPtr = destPtr2;\n      srcPtr = srcPtr + 4;\n    } while (destPtr2 != (undefined4 *)((int)destination + (size - 0x10 & 0xfffffff0) + 0x10));\n    remainingSize2 = size & 0xf;\n    iterationVariable = ((size - 0x10 >> 4) + 1) * 0x10;\n    source = (void *)((int)source + iterationVariable);\n    destPtr = (undefined4 *)(iterationVariable + (int)destination);\n    remainingSize = remainingSize2;\n    srcPtr = destPtr;\n    destPtr2 = (undefined4 *)source;\n    if (3 < remainingSize2) {\n      do {\n        remainingSize = remainingSize - 4;\n        *srcPtr = *destPtr2;\n        srcPtr = srcPtr + 1;\n        destPtr2 = destPtr2 + 1;\n      } while (3 < remainingSize);\n      iterationVariable = (remainingSize2 - 4 & 0xfffffffc) + 4;\n      destPtr = (undefined4 *)((int)destPtr + iterationVariable);\n      source = (void *)((int)source + iterationVariable);\n      remainingSize2 = size & 3;\n    }\n    size = remainingSize2;\n    if (size == 0) {\n      return destination;\n    }\n  }\n  srcPtr = destPtr;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    destPtr2 = (undefined4 *)((int)srcPtr + 1);\n    *(undefined *)srcPtr = *source;\n    source = (undefined4 *)((int)source + 1);\n    srcPtr = destPtr2;\n  } while (destPtr2 != (undefined4 *)(size + (int)destPtr));\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "reverse_copy_00081e34",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "iVar1": "iterationVariable",
                "puVar2": "destPtr",
                "puVar3": "srcPtr",
                "puVar4": "destPtr2",
                "puVar5": "srcPtr2",
                "uVar6": "remainingSize",
                "puVar7": "destPtr3",
                "uVar8": "remainingSize2"
            },
            "calling": [
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "memset_00081f00",
            "code": "\nvoid * memset_00081f00(void *dst,int __c,size_t count)\n\n{\n  uint *dst;\n  uint *src;\n  uint *src;\n  uint u32Value;\n  uint tempCount;\n  bool isCountZero;\n  \n  src = (uint *)dst;\n  if (((uint)dst & 3) != 0) {\n    isCountZero = count == 0;\n    dst = (uint *)dst;\n    count = count - 1;\n    if (isCountZero) {\n      return dst;\n    }\n    while( true ) {\n      src = (uint *)((int)dst + 1);\n      *(char *)dst = (char)__c;\n      if (((uint)src & 3) == 0) break;\n      isCountZero = count == 0;\n      dst = src;\n      count = count - 1;\n      if (isCountZero) {\n        return dst;\n      }\n    }\n  }\n  if (3 < count) {\n    u32Value = __c & 0xffU | (__c & 0xffU) << 8;\n    u32Value = u32Value | u32Value << 0x10;\n    tempCount = count;\n    dst = src;\n    if (0xf < count) {\n      tempCount = count - 0x10;\n      do {\n        *dst = u32Value;\n        dst[1] = u32Value;\n        dst[2] = u32Value;\n        dst[3] = u32Value;\n        dst = dst + 4;\n      } while (dst != (uint *)((int)src + (tempCount & 0xfffffff0) + 0x10));\n      count = count & 0xf;\n      src = src + ((tempCount >> 4) + 1) * 4;\n      tempCount = count;\n      dst = src;\n      if (count < 4) goto LAB_00081f7c;\n    }\n    do {\n      count = count - 4;\n      *src = u32Value;\n      src = src + 1;\n    } while (3 < count);\n    src = (uint *)((int)dst + (tempCount - 4 & 0xfffffffc) + 4);\n    count = tempCount & 3;\n  }\nLAB_00081f7c:\n  if (count != 0) {\n    dst = src;\n    do {\n      src = (uint *)((int)dst + 1);\n      *(char *)dst = (char)__c;\n      dst = src;\n    } while (src != (uint *)(count + (int)src));\n  }\n  return dst;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "memset_00081f00",
                "__s": "dst",
                "__n": "count",
                "puVar1": "dst",
                "puVar2": "src",
                "puVar3": "src",
                "uVar4": "u32Value",
                "uVar5": "tempCount",
                "bVar6": "isCountZero"
            },
            "calling": [
                "__sinit",
                "RingBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "reallocate_memory_00081f9c",
            "code": "\nvoid * reallocateMemory_00081f9c(void *oldPointer,size_t newSize)\n\n{\n  void *newPointer;\n  \n  newPointer = (void *)_realloc_r(_impure_ptr,oldPointer,newSize);\n  return newPointer;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "reallocate_memory_00081f9c",
                "__ptr": "oldPointer",
                "__size": "newSize",
                "pvVar1": "newPointer"
            },
            "calling": [
                "changeBuffer"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "allocate_memory_00081fac",
            "code": "\nint * allocateMemory_00081fac(undefined4 *lock,int *ptr,uint size)\n\n{\n  int temp1;\n  int *result;\n  uint var3;\n  size_t var4;\n  uint var5;\n  int temp2;\n  int *temp3;\n  uint var8;\n  uint var9;\n  int *temp4;\n  \n  if (ptr == (int *)0x0) {\n    result = (int *)_malloc_r(lock,size);\n    return result;\n  }\n  __malloc_lock();\n  var5 = ptr[-1];\n  var8 = var5 & 0xfffffffc;\n  result = ptr + -2;\n  if (size + 0xb < 0x17) {\n    var9 = 0x10;\n  }\n  else {\n    var9 = size + 0xb & 0xfffffff8;\n    if ((int)var9 < 0) goto LAB_00082078;\n  }\n  if (var9 < size) {\nLAB_00082078:\n    *lock = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)var8 < (int)var9) {\n    temp1 = (int)result + var8;\n    if (DAT_2007046c == temp1) {\n      var3 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n      temp1 = DAT_2007046c;\n      if ((int)(var9 + 0x10) <= (int)(var3 + var8)) {\n        DAT_2007046c = (int)result + var9;\n        *(uint *)(DAT_2007046c + 4) = (var3 + var8) - var9 | 1;\n        ptr[-1] = var9 | ptr[-1] & 1U;\n        __malloc_unlock(lock);\n        return ptr;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp1 + 4) & 0xfffffffe) + temp1 + 4) & 1) == 0) {\n      var3 = *(uint *)(temp1 + 4) & 0xfffffffc;\n      if ((int)var9 <= (int)(var3 + var8)) {\n        temp2 = *(int *)(temp1 + 0xc);\n        temp1 = *(int *)(temp1 + 8);\n        *(int *)(temp1 + 0xc) = temp2;\n        *(int *)(temp2 + 8) = temp1;\n        var8 = var3 + var8;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      var3 = 0;\n      temp1 = 0;\n    }\n    if (-1 < (int)(var5 << 0x1f)) {\n      temp4 = (int *)((int)result - ptr[-2]);\n      var5 = (temp4[1] & 0xfffffffcU) + var8;\n      if (temp1 != 0) {\n        if (temp1 == DAT_2007046c) {\n          if ((int)(var9 + 0x10) <= (int)(var3 + var5)) {\n            result = temp4 + 2;\n            temp1 = *result;\n            temp2 = temp4[3];\n            var4 = var8 - 4;\n            *(int *)(temp1 + 0xc) = temp2;\n            *(int *)(temp2 + 8) = temp1;\n            if (var4 < 0x25) {\n              temp3 = result;\n              if (0x13 < var4) {\n                temp4[2] = *ptr;\n                temp4[3] = ptr[1];\n                if (var4 < 0x1c) {\n                  ptr = ptr + 2;\n                  temp3 = temp4 + 4;\n                }\n                else {\n                  temp4[4] = ptr[2];\n                  temp4[5] = ptr[3];\n                  if (var4 == 0x24) {\n                    temp4[6] = ptr[4];\n                    temp3 = ptr + 5;\n                    ptr = ptr + 6;\n                    temp4[7] = *temp3;\n                    temp3 = temp4 + 8;\n                  }\n                  else {\n                    ptr = ptr + 4;\n                    temp3 = temp4 + 6;\n                  }\n                }\n              }\n              *temp3 = *ptr;\n              temp3[1] = ptr[1];\n              temp3[2] = ptr[2];\n            }\n            else {\n              memmove(result,ptr,var4);\n            }\n            DAT_2007046c = (int)temp4 + var9;\n            *(uint *)(DAT_2007046c + 4) = (var3 + var5) - var9 | 1;\n            temp4[1] = var9 | temp4[1] & 1U;\n            __malloc_unlock(lock);\n            return result;\n          }\n        }\n        else {\n          var3 = var3 + var5;\n          if ((int)var9 <= (int)var3) {\n            temp2 = *(int *)(temp1 + 0xc);\n            temp1 = *(int *)(temp1 + 8);\n            *(int *)(temp1 + 0xc) = temp2;\n            *(int *)(temp2 + 8) = temp1;\n            temp3 = temp4 + 2;\n            temp1 = *temp3;\n            temp2 = temp4[3];\n            var4 = var8 - 4;\n            *(int *)(temp1 + 0xc) = temp2;\n            *(int *)(temp2 + 8) = temp1;\n            var8 = var3;\n            if (var4 < 0x25) {\n              result = temp3;\n              if (0x13 < var4) {\n                temp4[2] = *ptr;\n                temp4[3] = ptr[1];\n                if (var4 < 0x1c) {\n                  ptr = ptr + 2;\n                  result = temp4 + 4;\n                }\n                else {\n                  temp4[4] = ptr[2];\n                  temp4[5] = ptr[3];\n                  if (var4 == 0x24) {\n                    temp4[6] = ptr[4];\n                    result = ptr + 5;\n                    ptr = ptr + 6;\n                    temp4[7] = *result;\n                    result = temp4 + 8;\n                  }\n                  else {\n                    ptr = ptr + 4;\n                    result = temp4 + 6;\n                  }\n                }\n              }\n              *result = *ptr;\n              result[1] = ptr[1];\n              result[2] = ptr[2];\n              var5 = temp4[1];\n              result = temp4;\n              ptr = temp3;\n            }\n            else {\n              memmove(temp3,ptr,var4);\n              var5 = temp4[1];\n              result = temp4;\n              ptr = temp3;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)var9 <= (int)var5) {\n        temp3 = temp4 + 2;\n        temp1 = *temp3;\n        temp2 = temp4[3];\n        var4 = var8 - 4;\n        *(int *)(temp1 + 0xc) = temp2;\n        *(int *)(temp2 + 8) = temp1;\n        var8 = var5;\n        if (var4 < 0x25) {\n          result = temp3;\n          if (0x13 < var4) {\n            temp4[2] = *ptr;\n            temp4[3] = ptr[1];\n            if (var4 < 0x1c) {\n              ptr = ptr + 2;\n              result = temp4 + 4;\n            }\n            else {\n              temp4[4] = ptr[2];\n              temp4[5] = ptr[3];\n              if (var4 == 0x24) {\n                temp4[6] = ptr[4];\n                result = ptr + 5;\n                ptr = ptr + 6;\n                temp4[7] = *result;\n                result = temp4 + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                result = temp4 + 6;\n              }\n            }\n          }\n          *result = *ptr;\n          result[1] = ptr[1];\n          result[2] = ptr[2];\n          var5 = temp4[1];\n          result = temp4;\n          ptr = temp3;\n        }\n        else {\n          memmove(temp3,ptr,var4);\n          var5 = temp4[1];\n          result = temp4;\n          ptr = temp3;\n        }\n        goto LAB_00082088;\n      }\n    }\n    temp4 = (int *)_malloc_r(lock,size);\n    if (temp4 == (int *)0x0) goto LAB_000820a0;\n    var5 = ptr[-1];\n    if (temp4 + -2 != (int *)((var5 & 0xfffffffe) + (int)result)) {\n      var4 = var8 - 4;\n      if (var4 < 0x25) {\n        result = ptr;\n        temp3 = temp4;\n        if (0x13 < var4) {\n          *temp4 = *ptr;\n          temp4[1] = ptr[1];\n          if (var4 < 0x1c) {\n            result = ptr + 2;\n            temp3 = temp4 + 2;\n          }\n          else {\n            temp4[2] = ptr[2];\n            temp4[3] = ptr[3];\n            if (var4 == 0x24) {\n              temp4[4] = ptr[4];\n              temp4[5] = ptr[5];\n              result = ptr + 6;\n              temp3 = temp4 + 6;\n            }\n            else {\n              result = ptr + 4;\n              temp3 = temp4 + 4;\n            }\n          }\n        }\n        *temp3 = *result;\n        temp3[1] = result[1];\n        temp3[2] = result[2];\n      }\n      else {\n        memmove(temp4,ptr,var4);\n      }\n      _free_r(lock,ptr);\n      goto LAB_000820a0;\n    }\n    var8 = var8 + (temp4[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  var3 = var8 - var9;\n  temp4 = ptr;\n  if (var3 < 0x10) {\n    result[1] = var5 & 1 | var8;\n    *(uint *)((int)result + var8 + 4) = *(uint *)((int)result + var8 + 4) | 1;\n  }\n  else {\n    result[1] = var5 & 1 | var9;\n    *(uint *)((int)result + var9 + 4) = var3 | 1;\n    *(uint *)((int)result + var3 + var9 + 4) = *(uint *)((int)result + var3 + var9 + 4) | 1;\n    _free_r(lock,(int)result + var9 + 8);\n  }\nLAB_000820a0:\n  __malloc_unlock(lock);\n  return temp4;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "allocate_memory_00081fac",
                "param_1": "lock",
                "param_2": "ptr",
                "param_3": "size",
                "iVar1": "temp1",
                "piVar2": "result",
                "uVar3": "var3",
                "sVar4": "var4",
                "uVar5": "var5",
                "iVar6": "temp2",
                "piVar7": "temp3",
                "uVar8": "var8",
                "uVar9": "var9",
                "piVar10": "temp4"
            },
            "calling": [
                "__sfvwrite_r",
                "realloc"
            ],
            "called": [
                "memmove",
                "_malloc_r",
                "__malloc_unlock",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "allocate_memory_0008236c",
            "code": "\nvoid allocateMemory_0008236c(int *error,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "allocate_memory_0008236c",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_strings_00082390",
            "code": "\nint compareStrings_00082390(char *string1,char *string2)\n\n{\n  uint *ptr1;\n  int result;\n  byte *bytePtr1;\n  byte *bytePtr2;\n  uint *ptr2;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  \n  if ((((uint)string1 | (uint)string2) & 7) != 0) {\n    ptr1 = (uint *)string1;\n    if (((uint)string1 & 3) != 0) {\n      ptr1 = (uint *)((uint)string1 & 0xfffffffc) + 1;\n      temp1 = *(uint *)((uint)string1 & 0xfffffffc);\n      bytePtr1 = (byte *)string2;\n      if (((uint)string1 & 1) == 0) {\nLAB_00082410:\n        bytePtr2 = bytePtr1 + 1;\n        temp2 = temp1 >> 0x10 & 0xff;\n        result = temp2 - *bytePtr1;\n        if (result != 0) {\n          return result;\n        }\n        if (temp2 == 0) {\n          return 0;\n        }\n      }\n      else {\n        bytePtr2 = (byte *)string2;\n        if (((uint)string1 & 2) == 0) {\n          bytePtr1 = (byte *)(string2 + 1);\n          temp2 = temp1 >> 8 & 0xff;\n          result = temp2 - (byte)*string2;\n          if (result != 0) {\n            return result;\n          }\n          if (temp2 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      string2 = (char *)(bytePtr2 + 1);\n      result = (temp1 >> 0x18) - (uint)*bytePtr2;\n      if ((result != 0) || (temp1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    temp1 = (uint)string2 & 3;\n    if (temp1 != 0) {\n      ptr2 = (uint *)((uint)string2 & 0xfffffffc);\n      if (temp1 == 2) {\n        temp1 = *ptr2;\n        do {\n          ptr2 = ptr2 + 1;\n          temp3 = *ptr1;\n          temp1 = temp1 >> 0x10;\n          temp4 = temp3 + 0xfefefeff & ~temp3;\n          temp5 = temp4 & 0x80808080;\n          temp2 = temp3 & 0xffff;\n          if ((temp4 & 0x8080) != 0 || temp2 != temp1) goto LAB_0008258e;\n          temp1 = *ptr2;\n          temp2 = temp2 ^ temp3;\n          temp3 = temp1 * 0x10000;\n          ptr1 = ptr1 + 1;\n        } while (temp5 == 0 && temp2 == temp3);\n      }\n      else if (temp1 < 2) {\n        temp1 = *ptr2;\n        do {\n          ptr2 = ptr2 + 1;\n          temp3 = *ptr1;\n          temp1 = temp1 >> 8;\n          temp4 = temp3 + 0xfefefeff & ~temp3;\n          temp5 = temp4 & 0x80808080;\n          temp2 = temp3 & 0xffffff;\n          if ((temp4 & 0x808080) != 0 || temp2 != temp1) goto LAB_0008258e;\n          temp1 = *ptr2;\n          temp2 = temp2 ^ temp3;\n          temp3 = temp1 * 0x1000000;\n          ptr1 = ptr1 + 1;\n        } while (temp5 == 0 && temp2 == temp3);\n      }\n      else {\n        temp1 = *ptr2;\n        do {\n          ptr2 = ptr2 + 1;\n          temp3 = *ptr1;\n          temp1 = temp1 >> 0x18;\n          temp4 = temp3 + 0xfefefeff & ~temp3;\n          temp5 = temp4 & 0x80808080;\n          temp2 = temp3 & 0xff;\n          if ((temp4 & 0x80) != 0 || temp2 != temp1) goto LAB_0008258e;\n          temp1 = *ptr2;\n          temp2 = temp2 ^ temp3;\n          temp3 = temp1 * 0x100;\n          ptr1 = ptr1 + 1;\n        } while (temp5 == 0 && temp2 == temp3);\n      }\n      temp2 = temp2 << 0x18 | (temp2 >> 8 & 0xff) << 0x10 | (temp2 >> 0x10 & 0xff) << 8 |\n              temp2 >> 0x18;\n      temp1 = (temp3 >> 8 & 0xff) << 0x10 | (temp3 >> 0x10 & 0xff) << 8 | temp3 >> 0x18;\n      goto LAB_0008259e;\n    }\n    string1 = (char *)ptr1;\n    ptr2 = (uint *)string2;\n    if (((uint)ptr1 & 4) != 0) {\n      string1 = (char *)(ptr1 + 1);\n      temp1 = *ptr1;\n      ptr2 = (uint *)((int)string2 + 4);\n      temp3 = *(uint *)string2;\n      temp5 = temp1 + 0xfefefeff & ~temp1 & 0x80808080;\n      if (temp1 != temp3 || temp5 != 0) {\nLAB_0008259a:\n        temp2 = temp1 << 0x18 | (temp1 >> 8 & 0xff) << 0x10 | (temp1 >> 0x10 & 0xff) << 8 |\n                temp1 >> 0x18;\n        temp1 = temp3 << 0x18 | (temp3 >> 8 & 0xff) << 0x10 | (temp3 >> 0x10 & 0xff) << 8 |\n                temp3 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    string2 = (char *)ptr2;\n    if (((uint)ptr2 & 4) != 0) {\n      temp1 = *ptr2;\n      ptr1 = ptr2 + 1;\n      do {\n        temp2 = *(uint *)string1;\n        temp3 = *(uint *)((int)string1 + 4);\n        temp5 = temp2 + 0xfefefeff & ~temp2 & 0x80808080;\n        if (temp2 != temp1 || temp5 != 0) goto LAB_0008258e;\n        temp4 = *ptr1;\n        temp1 = ptr1[1];\n        temp5 = temp3 + 0xfefefeff & ~temp3 & 0x80808080;\n        string1 = (char *)((int)string1 + 8);\n        ptr1 = ptr1 + 2;\n      } while (temp3 == temp4 && temp5 == 0);\n      temp2 = temp3 << 0x18 | (temp3 >> 8 & 0xff) << 0x10 | (temp3 >> 0x10 & 0xff) << 8 |\n              temp3 >> 0x18;\n      temp1 = temp4 << 0x18 | (temp4 >> 8 & 0xff) << 0x10 | (temp4 >> 0x10 & 0xff) << 8 |\n              temp4 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    temp1 = *(uint *)string1;\n    temp2 = *(uint *)((int)string1 + 4);\n    temp3 = *(uint *)string2;\n    temp4 = *(uint *)((int)string2 + 4);\n    temp5 = temp1 + 0xfefefeff & ~temp1 & 0x80808080;\n    if (temp1 != temp3 || temp5 != 0) goto LAB_0008259a;\n    temp5 = temp2 + 0xfefefeff & ~temp2 & 0x80808080;\n    string1 = (char *)((int)string1 + 8);\n    string2 = (char *)((int)string2 + 8);\n  } while (temp2 == temp4 && temp5 == 0);\n  temp2 = temp2 << 0x18 | (temp2 >> 8 & 0xff) << 0x10 | (temp2 >> 0x10 & 0xff) << 8 | temp2 >> 0x18;\n  temp1 = temp4 << 0x18 | (temp4 >> 8 & 0xff) << 0x10 | (temp4 >> 0x10 & 0xff) << 8 | temp4 >> 0x18;\nLAB_0008259e:\n  temp3 = temp5 << 0x18 | (temp5 >> 8 & 0xff) << 0x10 | (temp5 >> 0x10 & 0xff) << 8 |\n          temp5 >> 0x18;\n  if (temp3 != 0) {\n    temp3 = 0x18 - LZCOUNT(temp3);\n    temp2 = temp2 >> (temp3 & 0xff);\n    temp1 = temp1 >> (temp3 & 0xff);\n  }\n  result = 1;\n  if (temp2 <= temp1) {\n    result = -(uint)(temp2 < temp1);\n  }\n  return result;\nLAB_0008258e:\n  temp2 = temp2 << 0x18 | (temp2 >> 8 & 0xff) << 0x10 | (temp2 >> 0x10 & 0xff) << 8 | temp2 >> 0x18;\n  temp1 = temp1 << 0x18 | (temp1 >> 8 & 0xff) << 0x10 | (temp1 >> 0x10 & 0xff) << 8 | temp1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_strings_00082390",
                "__s1": "string1",
                "__s2": "string2",
                "puVar1": "ptr1",
                "iVar2": "result",
                "pbVar3": "bytePtr1",
                "pbVar4": "bytePtr2",
                "puVar5": "ptr2",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar9": "temp4",
                "uVar10": "temp5"
            },
            "calling": [
                "equals"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_000825cc",
            "code": "\nchar * copy_string_000825cc(char *destination,char *source)\n\n{\n  char current_char;\n  ushort current_short;\n  uint *ptr_3;\n  uint *ptr_4;\n  uint current_uint;\n  uint current_uint2;\n  uint *ptr_7;\n  uint *ptr_8;\n  char *new_dest;\n  bool flag;\n  \n  new_dest = destination;\n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      current_char = *source;\n      *new_dest = current_char;\n      source = source + 1;\n      new_dest = new_dest + 1;\n    } while (current_char != '\\0');\n    return destination;\n  }\n  ptr_8 = (uint *)destination;\n  if (((uint)source & 3) != 0) {\n    ptr_4 = (uint *)source;\n    if (((uint)source & 1) != 0) {\n      ptr_4 = (uint *)(source + 1);\n      current_char = *source;\n      ptr_8 = (uint *)(destination + 1);\n      *destination = current_char;\n      if (current_char == '\\0') {\n        return destination;\n      }\n    }\n    source = (char *)ptr_4;\n    if (((uint)ptr_4 & 2) != 0) {\n      source = (char *)((int)ptr_4 + 2);\n      current_short = *(ushort *)ptr_4;\n      flag = (current_short & 0xff) == 0;\n      if (flag) {\n        *(char *)ptr_8 = (char)current_short;\n      }\n      else {\n        *(ushort *)ptr_8 = current_short;\n        flag = (current_short & 0xff00) == 0;\n        ptr_8 = (uint *)((int)ptr_8 + 2);\n      }\n      if (flag) {\n        return destination;\n      }\n    }\n  }\n  current_uint = *(uint *)source;\n  ptr_4 = (uint *)((int)source + 4);\n  ptr_7 = ptr_8;\n  if (((uint)source & 4) != 0) {\n    if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) goto LAB_00082630;\n    ptr_7 = ptr_8 + 1;\n    *ptr_8 = current_uint;\n    ptr_4 = (uint *)((int)source + 8);\n    current_uint = *(uint *)((int)source + 4);\n  }\n  while( true ) {\n    ptr_3 = ptr_4 + 1;\n    current_uint2 = *ptr_4;\n    ptr_8 = ptr_7;\n    if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) break;\n    ptr_8 = ptr_7 + 1;\n    *ptr_7 = current_uint;\n    current_uint = current_uint2;\n    if ((current_uint2 + 0xfefefeff & ~current_uint2 & 0x80808080) != 0) break;\n    ptr_4 = ptr_4 + 2;\n    current_uint = *ptr_3;\n    ptr_7 = ptr_7 + 2;\n    *ptr_8 = current_uint2;\n  }\nLAB_00082630:\n  do {\n    *(char *)ptr_8 = (char)current_uint;\n    current_uint2 = current_uint & 0xff;\n    current_uint = current_uint >> 8 | current_uint << 0x18;\n    ptr_8 = (uint *)((int)ptr_8 + 1);\n  } while (current_uint2 != 0);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_000825cc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "uVar2": "current_short",
                "puVar3": "ptr_3",
                "puVar4": "ptr_4",
                "uVar5": "current_uint",
                "uVar6": "current_uint2",
                "puVar7": "ptr_7",
                "puVar8": "ptr_8",
                "pcVar9": "new_dest",
                "bVar10": "flag"
            },
            "calling": [
                "copy",
                "concat",
                "move"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "count_non_zero_bytes_00082688",
            "code": "\nsize_t countNonZeroBytes_00082688(char *string)\n\n{\n  size_t offset;\n  uint *wordPointer;\n  uint word;\n  bool isZero;\n  \n  wordPointer = (uint *)((uint)string & 0xfffffffc);\n  offset = -((uint)string & 3);\n  word = *wordPointer;\n  if (((uint)string & 3) != 0) {\n    word = word | 0xffffffffU >> ((offset + 4 & 0x1f) << 3);\n  }\n  while (wordPointer = wordPointer + 1, (word + 0xfefefeff & ~word & 0x80808080) == 0) {\n    offset = offset + 4;\n    word = *wordPointer;\n  }\n  isZero = (word & 0xff) == 0;\n  if (!isZero) {\n    offset = offset + 1;\n    isZero = (word & 0xff00) == 0;\n  }\n  if (!isZero) {\n    offset = offset + 1;\n    isZero = (word & 0xff0000) == 0;\n  }\n  if (!isZero) {\n    offset = offset + 1;\n  }\n  return offset;\n}\n\n",
            "renaming": {
                "FUN_00082688": "count_non_zero_bytes_00082688",
                "__s": "string",
                "sVar1": "offset",
                "puVar2": "wordPointer",
                "uVar3": "word",
                "bVar4": "isZero"
            },
            "calling": [
                "String",
                "_vfiprintf_r",
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000826e8": {
            "entrypoint": "0x000826e8",
            "current_name": "parse_integer_000826e8",
            "code": "\nuint parseInteger_000826e8(undefined4 *outputValue,byte *inputString,byte **remainingString,uint base)\n\n{\n  byte charClass;\n  byte positiveSign;\n  uint result;\n  byte *currentChar;\n  uint charValue;\n  byte *nextChar;\n  int decimalAdjust;\n  int parseSuccess;\n  uint maxQuotient;\n  uint minQuotient;\n  \n  currentChar = inputString;\n  do {\n    nextChar = currentChar;\n    currentChar = nextChar + 1;\n    charValue = (uint)*nextChar;\n    charClass = *(byte *)(__ctype_ptr__ + charValue + 1);\n    positiveSign = charClass & 8;\n  } while ((charClass & 8) != 0);\n  if (charValue == 0x2d) {\n    currentChar = nextChar + 2;\n    charValue = (uint)nextChar[1];\n    positiveSign = 1;\n  }\n  else if (charValue == 0x2b) {\n    charValue = (uint)nextChar[1];\n    currentChar = nextChar + 2;\n  }\n  if ((base & 0xffffffef) == 0) {\n    if (charValue == 0x30) {\n      if ((*currentChar & 0xdf) == 0x58) {\n        charValue = (uint)currentChar[1];\n        base = 0x10;\n        currentChar = currentChar + 2;\n      }\n      else if (base == 0) {\n        base = 8;\n      }\n    }\n    else if (base == 0) {\n      base = 10;\n    }\n  }\n  if (positiveSign == 0) {\n    minQuotient = 0x7fffffff;\n  }\n  else {\n    minQuotient = 0x80000000;\n  }\n  maxQuotient = minQuotient / base;\n  parseSuccess = 0;\n  result = 0;\n  do {\n    charClass = *(byte *)(__ctype_ptr__ + charValue + 1);\n    if ((charClass & 4) == 0) {\n      if ((charClass & 3) == 0) break;\n      if ((charClass & 3) == 1) {\n        decimalAdjust = 0x37;\n      }\n      else {\n        decimalAdjust = 0x57;\n      }\n      decimalAdjust = charValue - decimalAdjust;\n    }\n    else {\n      decimalAdjust = charValue - 0x30;\n    }\n    if ((int)base <= decimalAdjust) break;\n    if (parseSuccess != -1) {\n      if ((maxQuotient <= result && result != maxQuotient) ||\n         ((result == maxQuotient && ((int)(minQuotient - base * maxQuotient) < decimalAdjust)))) {\n        parseSuccess = -1;\n      }\n      else {\n        result = base * result + decimalAdjust;\n        parseSuccess = 1;\n      }\n    }\n    charValue = (uint)*currentChar;\n    currentChar = currentChar + 1;\n  } while( true );\n  if (parseSuccess == -1) {\n    if (positiveSign == 0) {\n      result = 0x7fffffff;\n    }\n    else {\n      result = 0x80000000;\n    }\n    *outputValue = 0x22;\n    if (remainingString == (byte **)0x0) {\n      return result;\n    }\n  }\n  else {\n    if (positiveSign != 0) {\n      result = -result;\n    }\n    if (remainingString == (byte **)0x0) {\n      return result;\n    }\n    if (parseSuccess == 0) goto LAB_0008278c;\n  }\n  inputString = currentChar + -1;\nLAB_0008278c:\n  *remainingString = inputString;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000826e8": "parse_integer_000826e8",
                "param_1": "outputValue",
                "param_2": "inputString",
                "param_3": "remainingString",
                "param_4": "base",
                "bVar1": "charClass",
                "bVar2": "positiveSign",
                "uVar3": "result",
                "pbVar4": "currentChar",
                "uVar5": "charValue",
                "pbVar6": "nextChar",
                "iVar7": "decimalAdjust",
                "iVar8": "parseSuccess",
                "uVar9": "maxQuotient",
                "uVar10": "minQuotient"
            },
            "calling": [
                "strtol"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000827fc": {
            "entrypoint": "0x000827fc",
            "current_name": "parse_integer_000827fc",
            "code": "\nlong parseInteger_000827fc(char *numberString,char **nextCharacterPointer,int numberBase)\n\n{\n  long parsedInteger;\n  \n  parsedInteger = _strtol_r(_impure_ptr,numberString,nextCharacterPointer,numberBase);\n  return parsedInteger;\n}\n\n",
            "renaming": {
                "FUN_000827fc": "parse_integer_000827fc",
                "__nptr": "numberString",
                "__endptr": "nextCharacterPointer",
                "__base": "numberBase",
                "lVar1": "parsedInteger"
            },
            "calling": [
                "atol"
            ],
            "called": [
                "_strtol_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082814": {
            "entrypoint": "0x00082814",
            "current_name": "send_signal_00082814",
            "code": "\nint send_signal_00082814(process_id_t process_id,int signal_number)\n\n{\n  int result;\n  \n  result = _kill_r(_impure_ptr,process_id,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082814": "send_signal_00082814",
                "__pid": "process_id",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "write_to_file_00082824",
            "code": "\nint writeToFile_00082824(undefined4 file_descriptor,int buffer_length,int **buffer)\n\n{\n  int *current_buffer;\n  int result;\n  int *remaining_buffer;\n  uint count;\n  undefined4 *current_char;\n  uint current_buffer_length;\n  uint shifted_buffer_length;\n  \n  if (-1 < *(int *)(buffer_length + 100) << 0x12) {\n    result = __sfvwrite_r();\n    buffer[2] = (int *)0x0;\n    buffer[1] = (int *)0x0;\n    return result;\n  }\n  remaining_buffer = buffer[2];\n  current_buffer = *buffer;\n  while (remaining_buffer != (int *)0x0) {\n    current_buffer_length = current_buffer[1];\n    shifted_buffer_length = current_buffer_length >> 2;\n    if (shifted_buffer_length != 0) {\n      current_char = (undefined4 *)(*current_buffer + -4);\n      count = 0;\n      do {\n        current_char = current_char + 1;\n        result = _fputwc_r(file_descriptor,*current_char,buffer_length);\n        count = count + 1;\n        if (result == -1) goto LAB_00082864;\n      } while (shifted_buffer_length != count);\n      remaining_buffer = buffer[2];\n    }\n    remaining_buffer = (int *)((int)remaining_buffer - (current_buffer_length & 0xfffffffc));\n    buffer[2] = remaining_buffer;\n    current_buffer = current_buffer + 2;\n  }\n  result = 0;\nLAB_00082864:\n  buffer[2] = (int *)0x0;\n  buffer[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082824": "write_to_file_00082824",
                "param_1": "file_descriptor",
                "param_2": "buffer_length",
                "param_3": "buffer",
                "piVar1": "current_buffer",
                "iVar2": "result",
                "piVar3": "remaining_buffer",
                "uVar4": "count",
                "puVar5": "current_char",
                "uVar6": "current_buffer_length",
                "uVar7": "shifted_buffer_length"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_fputwc_r",
                "__sfvwrite_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "format_string_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint formatString_0008289c(int string,int format,int *******args,int **argPointers)\n\n{\n  bool isPositive;\n  bool isArgument;\n  bool hasFlag;\n  char flagCharacter;\n  bool hasWidth;\n  void *pointerVoid;\n  int ********pargHolder;\n  int *pointerInt;\n  int result;\n  char character;\n  int *******pcurrentChar;\n  uint number;\n  int **tempPointer;\n  uint tempNumber;\n  uint tempCharacter;\n  int tempResult;\n  int ********ptempArgHolder;\n  int tempVar;\n  int *******tempArgs;\n  int *tempPointerInt;\n  int *******argPointer;\n  uint tempVar;\n  int *tempPointerInt;\n  int *******argPointerInt;\n  undefined4 tempVar;\n  int ********tempString;\n  bool isNegative;\n  longlong tempLongLong;\n  int *******argCounter;\n  int *******maxArgs;\n  int **tempArgPointer;\n  int width;\n  char *flags;\n  char flagCharacter;\n  undefined paddingCharacter;\n  undefined tempCharacter;\n  int ********argHolder;\n  int argCounter;\n  int *******argPointer;\n  undefined paddingCharacter;\n  char tempCharacter;\n  undefined tempCharacter;\n  undefined argHolderArray [4];\n  int *******tempArray [16];\n  \n  if ((string != 0) && (*(int *)(string + 0x38) == 0)) {\n    tempStringinit();\n  }\n  tempNumber = (uint)*(ushort *)(format + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(format + 0xc) << 0x12)) {\n    tempNumber = tempNumber | 0x2000;\n    *(short *)(format + 0xc) = (short)tempNumber;\n    *(uint *)(format + 100) = *(uint *)(format + 100) & 0xffffdfff;\n  }\n  if (((int)(tempNumber << 0x1c) < 0) && (*(int *)(format + 0x10) != 0)) {\n    if ((tempNumber & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    result = tempStringwsetup_r(string,format);\n    if (result != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(format + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(format + 0xe)) {\n    result = tempStringbprintf(string,format,args,argPointers);\n    return result;\n  }\nLAB_000828ee:\n  flags = (char *)0x0;\n  argPointer = (int *******)0x0;\n  argCounter = 0;\n  width = 0;\n  pargHolder = (int ********)argHolderArray;\n  tempArgPointer = argPointers;\n  argHolder = (int ********)argHolderArray;\nLAB_00082902:\n  pcurrentChar = args;\n  if ((*(char *)args != '\\0') && (*(char *)args != '%')) {\n    do {\n      pcurrentChar = (int *******)((int)pcurrentChar + 1);\n      if (*(char *)pcurrentChar == '\\0') break;\n    } while (*(char *)pcurrentChar != '%');\n    argPointer = (int *******)((int)pcurrentChar - (int)args);\n    if (argPointer != (int *******)0x0) {\n      argCounter = argCounter + 1;\n      argPointer = (int *******)((int)argPointer + (int)argPointer);\n      *pargHolder = args;\n      pargHolder[1] = argPointer;\n      if (argCounter < 8) {\n        pargHolder = pargHolder + 2;\n      }\n      else {\n        if (argPointer == (int *******)0x0) {\n          width = width + (int)argPointer;\n          argCounter = 0;\n          pargHolder = (int ********)argHolderArray;\n          goto LAB_00082952;\n        }\n        result = tempStringprint_r_part_0(string,format,&argHolder);\n        pargHolder = (int ********)argHolderArray;\n        if (result != 0) goto LAB_00083142;\n      }\n      width = width + (int)argPointer;\n    }\n  }\nLAB_00082952:\n  if (*(char *)pcurrentChar != '\\0') {\n    flagCharacter = '\\0';\n    tempCharacter = (uint)*(byte *)((int)pcurrentChar + 1);\n    tempNumber = 0;\n    hasWidth = false;\n    isArgument = false;\n    isPositive = false;\n    hasFlag = false;\n    isNegative = false;\n    argPointer = (int *******)0x0;\n    maxArgs = (int *******)0xffffffff;\n    args = (int *******)((int)pcurrentChar + 1);\nLAB_00082976:\n    args = (int *******)((int)args + 1);\nLAB_0008297a:\n    switch(tempCharacter) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (tempCharacter != 0) {\n        argCounter = (int *******)0x1;\n        maxArgs = (int *******)0x1;\n        tempString = (int ********)&paddingCharacter;\n        paddingCharacter = (char)tempCharacter;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      hasFlag = true;\n      tempCharacter = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2a:\n      argPointer = (int *******)*tempArgPointer;\n      tempArgPointer = tempArgPointer + 1;\n      if ((int)argPointer < 0) {\n        argPointer = (int *******)-(int)argPointer;\n        goto switchD_00082984_caseD_2d;\n      }\n      tempCharacter = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2b:\n      tempCharacter = (uint)*(byte *)args;\n      flagCharacter = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      tempNumber = tempNumber | 4;\n      tempCharacter = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2e:\n      tempCharacter = (uint)*(byte *)args;\n      pcurrentChar = (int *******)((int)args + 1);\n      if (tempCharacter == 0x2a) {\n        tempCharacter = (uint)*(byte *)((int)args + 1);\n        maxArgs = (int *******)*tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        args = pcurrentChar;\n        if ((int)maxArgs < 0) {\n          maxArgs = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      number = tempCharacter - 0x30;\n      if (number < 10) {\n        tempVar = 0;\n        do {\n          args = (int *******)((int)pcurrentChar + 1);\n          tempCharacter = (uint)*(byte *)pcurrentChar;\n          tempVar = number + tempVar * 10;\n          number = tempCharacter - 0x30;\n          pcurrentChar = args;\n        } while (number < 10);\n        maxArgs = (int *******)(tempVar | (int)tempVar >> 0x1f);\n      }\n      else {\n        maxArgs = (int *******)0x0;\n        args = pcurrentChar;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      tempNumber = tempNumber | 0x80;\n      tempCharacter = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      isArgument = true;\n      if (isPositive == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      tempArgPointer = (int **)((int)tempArgPointer + 7U & 0xfffffff8);\n      tempPointerInt = *tempArgPointer;\n      tempPointerInt = tempArgPointer[1];\n      tempArgPointer = tempArgPointer + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      isArgument = true;\n      if (isPositive != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      result = (uint)isArgument << 4;\n      tempResult = (uint)isPositive << 5;\n      if ((isArgument == 0) && (tempResult = (uint)isNegative << 6, isNegative != 0)) {\n        tempPointerInt = (int *)(uint)*(ushort *)tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        tempPointerInt = (int *)0x0;\n      }\n      else {\n        result = tempResult;\n        tempPointerInt = *tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        tempPointerInt = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      isArgument = true;\n      if (isPositive != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((isArgument) || (isNegative == false)) {\n        result = 1;\n        tempPointerInt = *tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        tempPointerInt = (int *)0x0;\n      }\n      else {\n        tempPointerInt = (int *)0x0;\n        tempPointerInt = (int *)(uint)*(ushort *)tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        result = 1;\n      }\n      break;\n    case 0x58:\n      flags = \"0123456789ABCDEF\";\n      if (isPositive == false) goto LAB_00082efa;\nLAB_00082d1a:\n      tempPointer = (int **)((int)tempArgPointer + 7U & 0xfffffff8);\n      tempArgPointer = tempPointer + 2;\n      tempPointerInt = *tempPointer;\n      tempPointerInt = tempPointer[1];\n      goto LAB_00082d2e;\n    case 99:\n      tempPointerInt = *tempArgPointer;\n      tempArgPointer = tempArgPointer + 1;\n      argCounter = (int *******)0x1;\n      paddingCharacter = SUB41(tempPointerInt,0);\n      maxArgs = (int *******)0x1;\n      tempString = (int ********)&paddingCharacter;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (isPositive != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((isArgument == false) && (isNegative != false)) {\n        tempPointerInt = (int *)(int)*(short *)tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        tempPointerInt = (int *)((int)tempPointerInt >> 0x1f);\n      }\n      else {\n        tempPointerInt = *tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        tempPointerInt = (int *)((int)tempPointerInt >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)tempPointerInt < 0) {\n        isNegative = tempPointerInt != (int *)0x0;\n        tempPointerInt = (int *)-(int)tempPointerInt;\n        tempPointerInt = (int *)(-(int)tempPointerInt - (uint)isNegative);\n        flagCharacter = '-';\n        flagCharacter = '-';\n        result = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)maxArgs) {\n        tempNumber = tempNumber & 0xffffff7f;\n      }\n      hasWidth = false;\n      tempCharacter = (uint)tempPointerInt | (uint)tempPointerInt;\n      result = 1;\n      flagCharacter = flagCharacter;\n      goto joined_r0x00082adc;\n    case 0x68:\n      isNegative = true;\n      tempCharacter = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x6c:\n      tempCharacter = (uint)*(byte *)args;\n      if (tempCharacter == 0x6c) {\n        isPositive = true;\n        tempCharacter = (uint)*(byte *)((int)args + 1);\n        args = (int *******)((int)args + 1);\n      }\n      else {\n        isArgument = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (isPositive == false) {\n        if (isArgument == false) {\n          if (isNegative) {\n            tempPointerInt = *tempArgPointer;\n            tempArgPointer = tempArgPointer + 1;\n            *(short *)tempPointerInt = (short)width;\n          }\n          else {\n            tempPointerInt = *tempArgPointer;\n            tempArgPointer = tempArgPointer + 1;\n            *tempPointerInt = width;\n          }\n        }\n        else {\n          tempPointerInt = *tempArgPointer;\n          tempArgPointer = tempArgPointer + 1;\n          *tempPointerInt = width;\n        }\n      }\n      else {\n        tempPointerInt = *tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        *tempPointerInt = width;\n        tempPointerInt[1] = width >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (isPositive == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      tempPointer = (int **)((int)tempArgPointer + 7U & 0xfffffff8);\n      tempArgPointer = tempPointer + 2;\n      tempPointerInt = *tempPointer;\n      tempPointerInt = tempPointer[1];\n      result = 0;\n      break;\n    case 0x70:\n      tempPointerInt = *tempArgPointer;\n      tempArgPointer = tempArgPointer + 1;\n      tempCharacter = 0x78;\n      hasWidth = true;\n      tempPointerInt = (int *)0x0;\n      paddingCharacter = 0x30;\n      flags = \"0123456789abcdef\";\n      result = 2;\n      break;\n    case 0x71:\n      isPositive = true;\n      tempCharacter = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x73:\n      tempString = (int ********)*tempArgPointer;\n      flagCharacter = '\\0';\n      tempArgPointer = tempArgPointer + 1;\n      if (tempString != (int ********)0x0) {\n        if ((int)maxArgs < 0) {\n          maxArgs = (int *******)strlen((char *)tempString);\n          pcurrentChar = (int *******)0x0;\n          flagCharacter = flagCharacter;\n        }\n        else {\n          pointerVoid = memchr(tempString,0,(size_t)maxArgs);\n          flagCharacter = flagCharacter;\n          if (pointerVoid == (void *)0x0) {\n            pcurrentChar = (int *******)0x0;\n          }\n          else {\n            tempArgs = (int *******)((int)pointerVoid - (int)tempString);\n            if ((int)maxArgs <= (int)(int *******)((int)pointerVoid - (int)tempString)) {\n              tempArgs = maxArgs;\n            }\n            pcurrentChar = (int *******)0x0;\n            maxArgs = tempArgs;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < maxArgs) {\n        maxArgs = (int *******)0x6;\n      }\n      argCounter = (int *******)((uint)maxArgs & ~((int)maxArgs >> 0x1f));\n      tempString = (int ********)&UNK_00085728;\nLAB_00082d76:\n      flagCharacter = '\\0';\n      pcurrentChar = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!isPositive) goto LAB_00082ce0;\nLAB_00082bc6:\n      tempPointer = (int **)((int)tempArgPointer + 7U & 0xfffffff8);\n      tempArgPointer = tempPointer + 2;\n      tempPointerInt = *tempPointer;\n      tempPointerInt = tempPointer[1];\n      result = 1;\n      break;\n    case 0x78:\n      flags = \"0123456789abcdef\";\n      if (isPositive != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((isArgument == false) && (isNegative != false)) {\n        tempPointerInt = (int *)0x0;\n        tempPointerInt = (int *)(uint)*(ushort *)tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n      }\n      else {\n        tempPointerInt = *tempArgPointer;\n        tempArgPointer = tempArgPointer + 1;\n        tempPointerInt = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((hasFlag) && (((uint)tempPointerInt | (uint)tempPointerInt) != 0)) {\n        hasWidth = true;\n        paddingCharacter = 0x30;\n        result = 2;\n        tempCharacter = (char)tempCharacter;\n      }\n      else {\n        result = 2;\n      }\n    }\n    flagCharacter = '\\0';\n    flagCharacter = '\\0';\nLAB_00082ace:\n    if (-1 < (int)maxArgs) {\n      tempNumber = tempNumber & 0xffffff7f;\n    }\n    tempCharacter = (uint)tempPointerInt | (uint)tempPointerInt;\njoined_r0x00082adc:\n    tempLongLong = CONCAT44(tempPointerInt,tempPointerInt);\n    pcurrentChar = maxArgs;\n    if ((tempCharacter == 0) && (maxArgs == (int *******)0x0)) {\n      tempString = (int ********)argHolderArray;\n      if ((result != 0) || (!hasFlag)) goto LAB_00082b04;\n      tempString = (int ********)(&tempCharacter + 1);\n      tempCharacter = '0';\n      goto LAB_00082afe;\n    }\n    if (result == 1) {\n      if (tempPointerInt != (int *)0x0 || (int *)0x9 < tempPointerInt) {\n        ptempArgHolder = (int ********)(&tempCharacter + 1);\n        do {\n          tempString = ptempArgHolder;\n          tempVar = (undefined4)((ulonglong)tempLongLong >> 0x20);\n          character = '\\n';\n          __aeabi_uldivmod((int)tempLongLong,tempVar,10,0);\n          *(char *)tempString = character + '0';\n          tempLongLong = __aeabi_uldivmod((int)tempLongLong,tempVar,10,0);\n          ptempArgHolder = (int ********)((int)tempString + -1);\n        } while (tempLongLong != 0);\n        maxArgs = (int *******)((int)argHolderArray - (int)tempString);\n        goto LAB_00082b04;\n      }\n      tempCharacter = (char)tempPointerInt + '0';\n      tempString = (int ********)(&tempCharacter + 1);\n      goto LAB_00083282;\n    }\n    ptempArgHolder = (int ********)(&tempCharacter + 1);\n    if (result != 2) goto LAB_000830e2;\n    do {\n      tempString = ptempArgHolder;\n      tempCharacter = (uint)tempPointerInt & 0xf;\n      tempPointerInt = (int *)((uint)tempPointerInt >> 4 | (int)tempPointerInt << 0x1c);\n      tempPointerInt = (int *)((uint)tempPointerInt >> 4);\n      *(char *)tempString = flags[tempCharacter];\n      ptempArgHolder = (int ********)((int)tempString + -1);\n    } while (((uint)tempPointerInt | (uint)tempPointerInt) != 0);\n    maxArgs = (int *******)((int)argHolderArray - (int)tempString);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (argPointer != (int *******)0x0) {\n    tempStringprint_r_part_0(string,format,&argHolder);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(format + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return width;\nLAB_000830e2:\n  do {\n    tempString = ptempArgHolder;\n    pointerInt = (int *)((uint)tempPointerInt >> 3 | (int)tempPointerInt << 0x1d);\n    tempPointerInt = (int *)((uint)tempPointerInt >> 3);\n    result = ((uint)tempPointerInt & 7) + 0x30;\n    *(char *)tempString = (char)result;\n    ptempArgHolder = (int ********)((int)tempString + -1);\n    tempPointerInt = pointerInt;\n  } while (((uint)pointerInt | (uint)tempPointerInt) != 0);\n  if (hasFlag) {\n    if (result == 0x30) {\nLAB_00082afe:\n      maxArgs = (int *******)((int)argHolderArray - (int)tempString);\n    }\n    else {\n      *(undefined *)((int)tempString + -1) = 0x30;\n      tempString = ptempArgHolder;\n      maxArgs = (int *******)((int)argHolderArray - (int)ptempArgHolder);\n    }\n  }\n  else {\nLAB_00083282:\n    maxArgs = (int *******)((int)argHolderArray - (int)tempString);\n  }\nLAB_00082b04:\n  argCounter = maxArgs;\n  if ((int)maxArgs < (int)pcurrentChar) {\n    argCounter = pcurrentChar;\n  }\n  if (flagCharacter != '\\0') {\n    argCounter = (int *******)((int)argCounter + 1);\n  }\nLAB_00082b1e:\n  if (hasWidth) {\n    argCounter = (int *******)((int)argCounter + 2);\n  }\n  if ((tempNumber == 0) &&\n     (tempArgs = (int *******)((int)argPointer - (int)argCounter), 0 < (int)tempArgs)) {\n    if ((int)tempArgs < 0x11) {\n      argCounter = argCounter + 1;\n    }\n    else {\n      do {\n        argPointerInt = tempArgs;\n        result = argCounter + 1;\n        argPointer = argPointer + 4;\n        *pargHolder = (int *******)0x856f0;\n        pargHolder[1] = (int *******)0x10;\n        if (result < 8) {\n          tempResult = argCounter + 2;\n          pargHolder = pargHolder + 2;\n          argCounter = result;\n        }\n        else if (argPointer == (int *******)0x0) {\n          tempResult = 1;\n          pargHolder = (int ********)argHolderArray;\n          argCounter = 0;\n        }\n        else {\n          argCounter = result;\n          result = tempStringprint_r_part_0(string,format,&argHolder);\n          if (result != 0) goto LAB_00083142;\n          tempResult = argCounter + 1;\n          pargHolder = (int ********)argHolderArray;\n        }\n        tempArgs = argPointerInt + -4;\n      } while (0x10 < (int)tempArgs);\n      tempArgs = argPointerInt + -4;\n      argCounter = tempResult;\n    }\n    argPointer = (int *******)((int)argPointer + (int)tempArgs);\n    *pargHolder = (int *******)0x856f0;\n    pargHolder[1] = tempArgs;\n    if (argCounter < 8) {\n      result = argCounter + 1;\n      pargHolder = pargHolder + 2;\n    }\n    else if (argPointer == (int *******)0x0) {\n      result = 1;\n      argCounter = 0;\n      pargHolder = (int ********)argHolderArray;\n    }\n    else {\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n      result = argCounter + 1;\n      pargHolder = (int ********)argHolderArray;\n    }\n  }\n  else {\n    result = argCounter + 1;\n  }\n  tempResult = result;\n  if (flagCharacter != '\\0') {\n    argPointer = (int *******)((int)argPointer + 1);\n    tempResult = 1;\n    *pargHolder = (int *******)&flagCharacter;\n    pargHolder[1] = (int *******)0x1;\n    argCounter = result;\n    if (result < 8) {\n      tempResult = result + 1;\n      pargHolder = pargHolder + 2;\n    }\n    else if (argPointer == (int *******)0x0) {\n      argCounter = 0;\n      pargHolder = (int ********)argHolderArray;\n    }\n    else {\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n      tempResult = argCounter + 1;\n      pargHolder = (int ********)argHolderArray;\n    }\n  }\n  result = tempResult;\n  tempVar = argCounter;\n  if (hasWidth) {\n    argPointer = (int *******)((int)argPointer + 2);\n    *pargHolder = (int *******)&paddingCharacter;\n    pargHolder[1] = (int *******)0x2;\n    if (tempResult < 8) {\n      result = tempResult + 1;\n      tempVar = tempResult;\n      pargHolder = pargHolder + 2;\n    }\n    else if (argPointer == (int *******)0x0) {\n      result = 1;\n      tempVar = 0;\n      pargHolder = (int ********)argHolderArray;\n    }\n    else {\n      argCounter = tempResult;\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n      result = argCounter + 1;\n      tempVar = argCounter;\n      pargHolder = (int ********)argHolderArray;\n    }\n  }\n  argCounter = tempVar;\n  if ((tempNumber == 0x80) &&\n     (tempArgs = (int *******)((int)argPointer - (int)argCounter), 0 < (int)tempArgs)) {\n    if (0x10 < (int)tempArgs) {\n      do {\n        while( true ) {\n          argPointerInt = tempArgs;\n          argCounter = tempVar + 1;\n          argPointer = argPointer + 4;\n          *pargHolder = (int *******)\"0000000000000000\";\n          pargHolder[1] = (int *******)0x10;\n          if (7 < argCounter) break;\n          result = tempVar + 2;\n          pargHolder = pargHolder + 2;\nLAB_000831f2:\n          tempVar = argCounter;\n          tempArgs = argPointerInt + -4;\n          if ((int)(argPointerInt + -4) < 0x11) goto LAB_00083218;\n        }\n        if (argPointer != (int *******)0x0) {\n          result = tempStringprint_r_part_0(string,format,&argHolder);\n          if (result == 0) {\n            result = argCounter + 1;\n            pargHolder = (int ********)argHolderArray;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        result = 1;\n        tempVar = 0;\n        tempArgs = argPointerInt + -4;\n        pargHolder = (int ********)argHolderArray;\n      } while (0x10 < (int)(argPointerInt + -4));\nLAB_00083218:\n      tempArgs = argPointerInt + -4;\n    }\n    argPointer = (int *******)((int)argPointer + (int)tempArgs);\n    *pargHolder = (int *******)\"0000000000000000\";\n    pargHolder[1] = tempArgs;\n    argCounter = result;\n    if (result < 8) {\n      result = result + 1;\n      pargHolder = pargHolder + 2;\n    }\n    else if (argPointer == (int *******)0x0) {\n      result = 1;\n      argCounter = 0;\n      pargHolder = (int ********)argHolderArray;\n    }\n    else {\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n      result = argCounter + 1;\n      pargHolder = (int ********)argHolderArray;\n    }\n  }\n  pcurrentChar = (int *******)((int)pcurrentChar - (int)maxArgs);\n  ptempArgHolder = (int ********)argHolderArray;\n  if ((int)pcurrentChar < 1) {\nLAB_0008302a:\n    argPointer = (int *******)((int)argPointer + (int)maxArgs);\n    *pargHolder = (int *******)tempString;\n    pargHolder[1] = maxArgs;\n    maxArgs = argPointer;\n    argCounter = result;\n    if (result < 8) goto LAB_000831be;\n    if (argPointer == (int *******)0x0) {\n      argCounter = 0;\n    }\n    else {\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    tempResult = argCounter;\n    if (0x10 < (int)pcurrentChar) {\n      do {\n        while( true ) {\n          tempArgs = pcurrentChar;\n          argCounter = tempResult + 1;\n          argPointer = argPointer + 4;\n          *pargHolder = (int *******)\"0000000000000000\";\n          pargHolder[1] = (int *******)0x10;\n          if (7 < argCounter) break;\n          result = tempResult + 2;\n          pargHolder = pargHolder + 2;\nLAB_00082fe6:\n          tempResult = argCounter;\n          pcurrentChar = tempArgs + -4;\n          if ((int)(tempArgs + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (argPointer != (int *******)0x0) {\n          result = tempStringprint_r_part_0(string,format,&argHolder);\n          if (result == 0) {\n            result = argCounter + 1;\n            pargHolder = (int ********)argHolderArray;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        result = 1;\n        pargHolder = (int ********)argHolderArray;\n        tempResult = 0;\n        pcurrentChar = tempArgs + -4;\n      } while (0x10 < (int)(tempArgs + -4));\nLAB_0008300e:\n      pcurrentChar = tempArgs + -4;\n    }\n    argPointer = (int *******)((int)argPointer + (int)pcurrentChar);\n    *pargHolder = (int *******)\"0000000000000000\";\n    pargHolder[1] = pcurrentChar;\n    if (result < 8) {\n      result = result + 1;\n      pargHolder = pargHolder + 2;\n      goto LAB_0008302a;\n    }\n    if (argPointer != (int *******)0x0) {\n      argCounter = result;\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n      result = argCounter + 1;\n      pargHolder = (int ********)argHolderArray;\n      goto LAB_0008302a;\n    }\n    tempArray[0] = maxArgs;\n    argCounter = 1;\n    pargHolder = (int ********)argHolderArray;\n    argHolderArray = (undefined  [4])tempString;\nLAB_000831be:\n    ptempArgHolder = pargHolder + 2;\n    argPointer = maxArgs;\n  }\n  if (((tempNumber & 4) != 0) &&\n     (pcurrentChar = (int *******)((int)argPointer - (int)argCounter), 0 < (int)pcurrentChar)) {\n    result = argCounter;\n    if ((int)pcurrentChar < 0x11) {\n      tempResult = argCounter + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          argCounter = result + 1;\n          argPointer = argPointer + 4;\n          *ptempArgHolder = (int *******)0x856f0;\n          ptempArgHolder[1] = (int *******)0x10;\n          if (7 < argCounter) break;\n          tempResult = result + 2;\n          ptempArgHolder = ptempArgHolder + 2;\nLAB_0008307a:\n          pcurrentChar = pcurrentChar + -4;\n          result = argCounter;\n          if ((int)pcurrentChar < 0x11) goto LAB_000830a2;\n        }\n        if (argPointer != (int *******)0x0) {\n          result = tempStringprint_r_part_0(string,format,&argHolder);\n          if (result == 0) {\n            tempResult = argCounter + 1;\n            ptempArgHolder = (int ********)argHolderArray;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        pcurrentChar = pcurrentChar + -4;\n        tempResult = 1;\n        result = 0;\n        ptempArgHolder = (int ********)argHolderArray;\n      } while (0x10 < (int)pcurrentChar);\n    }\nLAB_000830a2:\n    argPointer = (int *******)((int)argPointer + (int)pcurrentChar);\n    *ptempArgHolder = (int *******)0x856f0;\n    ptempArgHolder[1] = pcurrentChar;\n    argCounter = tempResult;\n    if (7 < tempResult) {\n      if (argPointer == (int *******)0x0) {\n        if ((int)argCounter < (int)argPointer) {\n          argCounter = argPointer;\n        }\n        width = width + (int)argCounter;\n        goto LAB_00083186;\n      }\n      result = tempStringprint_r_part_0(string,format,&argHolder);\n      if (result != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)argCounter < (int)argPointer) {\n    argCounter = argPointer;\n  }\n  width = width + (int)argCounter;\n  if ((argPointer != (int *******)0x0) &&\n     (result = tempStringprint_r_part_0(string,format,&argHolder), result != 0)) goto LAB_00083142;\nLAB_00083186:\n  argCounter = 0;\n  pargHolder = (int ********)argHolderArray;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  number = tempCharacter - 0x30;\n  argPointer = (int *******)0x0;\n  pcurrentChar = args;\n  do {\n    args = (int *******)((int)pcurrentChar + 1);\n    tempCharacter = (uint)*(byte *)pcurrentChar;\n    argPointer = (int *******)(number + (int)argPointer * 10);\n    number = tempCharacter - 0x30;\n    pcurrentChar = args;\n  } while (number < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  tempCharacter = (uint)*(byte *)args;\n  if (flagCharacter == '\\0') {\n    flagCharacter = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "format_string_0008289c",
                "param_1": "string",
                "param_2": "format",
                "param_3": "args",
                "param_4": "argPointers",
                "bVar1": "isPositive",
                "bVar2": "isArgument",
                "bVar3": "hasFlag",
                "cVar4": "flagCharacter",
                "bVar5": "hasWidth",
                "pvVar6": "pointerVoid",
                "pppppppiVar7": "argHolder",
                "piVar8": "pointerInt",
                "iVar9": "result",
                "cVar10": "character",
                "ppppppiVar11": "currentChar",
                "uVar12": "number",
                "ppiVar13": "tempPointer",
                "uVar14": "tempNumber",
                "uVar15": "tempCharacter",
                "iVar16": "tempResult",
                "pppppppiVar17": "tempArgHolder",
                "iVar18": "tempVar",
                "pppppppiVar19": "tempArgs",
                "piVar20": "tempPointerInt",
                "pppppppiVar21": "argPointer",
                "uVar22": "tempVar",
                "piVar23": "tempPointerInt",
                "pppppppiVar24": "argPointerInt",
                "uVar25": "tempVar",
                "__s": "tempString",
                "bVar26": "isNegative",
                "lVar27": "tempLongLong",
                "local_dc": "argCounter",
                "local_d4": "maxArgs",
                "local_c8": "tempArgPointer",
                "local_c4": "width",
                "local_c0": "flags",
                "local_a1": "flagCharacter",
                "local_a0": "paddingCharacter",
                "local_9f": "tempCharacter",
                "local_9c": "argHolder",
                "local_98": "argCounter",
                "local_94": "argPointer",
                "local_90": "paddingCharacter",
                "cStack_6a": "tempCharacter",
                "local_69": "tempCharacter",
                "local_68": "argHolderArray",
                "local_64": "tempArray"
            },
            "calling": [
                "__sbprintf",
                "iprintf",
                "fiprintf"
            ],
            "called": [
                "__sprint_r.part.0",
                "memchr",
                "__sbprintf",
                "__sinit",
                "__swsetup_r",
                "strlen",
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "print_formatted_string_000834f0",
            "code": "\nint printFormattedString_000834f0(undefined4 printStream,int data)\n\n{\n  int printResult;\n  int flushResult;\n  undefined *local_488 [2];\n  undefined4 bufferSize;\n  ushort shortValue;\n  undefined2 ushortValue;\n  undefined *stringBuffer;\n  undefined4 bufferSize;\n  undefined4 zero;\n  undefined4 paramValue1;\n  undefined4 paramValue2;\n  undefined4 paramValue3;\n  undefined stackBuffer [1024];\n  \n  paramValue3 = *(undefined4 *)(data + 100);\n  paramValue1 = *(undefined4 *)(data + 0x1c);\n  ushortValue = *(undefined2 *)(data + 0xe);\n  paramValue2 = *(undefined4 *)(data + 0x24);\n  local_488[0] = stackBuffer;\n  shortValue = *(ushort *)(data + 0xc) & 0xfffd;\n  bufferSize = 0x400;\n  bufferSize = 0x400;\n  zero = 0;\n  stringBuffer = local_488[0];\n  printResult = _vfiprintf_r(printStream,local_488);\n  if ((-1 < printResult) && (flushResult = _fflush_r(printStream,local_488), flushResult != 0)) {\n    printResult = -1;\n  }\n  if ((int)((uint)shortValue << 0x19) < 0) {\n    *(ushort *)(data + 0xc) = *(ushort *)(data + 0xc) | 0x40;\n  }\n  return printResult;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "print_formatted_string_000834f0",
                "param_1": "printStream",
                "param_2": "data",
                "iVar1": "printResult",
                "iVar2": "flushResult",
                "local_480": "bufferSize",
                "local_47c": "shortValue",
                "local_47a": "ushortValue",
                "local_478": "stringBuffer",
                "local_474": "bufferSize",
                "local_470": "zero",
                "local_46c": "paramValue1",
                "local_464": "paramValue2",
                "local_424": "paramValue3",
                "auStack_420": "stackBuffer"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_vfiprintf_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "check_and_update_status_0008356c",
            "code": "\nundefined4 check_and_update_status_0008356c(undefined4 *status_ptr,int *data_ptr)\n\n{\n  int some_index;\n  int some_value;\n  uint ushort_value_1;\n  ushort ushort_value_2;\n  \n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x38) == 0)) {\n    __sinit();\n  }\n  ushort_value_2 = *(ushort *)(data_ptr + 3);\n  ushort_value_1 = (uint)ushort_value_2;\n  if ((int)(ushort_value_1 << 0x1c) < 0) {\n    some_value = data_ptr[4];\n  }\n  else {\n    if (-1 < (int)(ushort_value_1 << 0x1b)) {\n      *status_ptr = 9;\n      *(ushort *)(data_ptr + 3) = ushort_value_2 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(ushort_value_1 << 0x1d) < 0) {\n      if ((int *)data_ptr[0xc] != (int *)0x0) {\n        if ((int *)data_ptr[0xc] != data_ptr + 0x10) {\n          _free_r(status_ptr);\n          ushort_value_2 = *(ushort *)(data_ptr + 3);\n        }\n        data_ptr[0xc] = 0;\n      }\n      some_value = data_ptr[4];\n      ushort_value_2 = ushort_value_2 & 0xffdb;\n      *data_ptr = some_value;\n      data_ptr[1] = 0;\n    }\n    else {\n      some_value = data_ptr[4];\n    }\n    *(ushort *)(data_ptr + 3) = ushort_value_2 | 8;\n    ushort_value_1 = (uint)(ushort_value_2 | 8);\n  }\n  if ((some_value == 0) && ((ushort_value_1 & 0x280) != 0x200)) {\n    __smakebuf_r(status_ptr,data_ptr);\n    ushort_value_1 = (uint)*(ushort *)(data_ptr + 3);\n    some_value = data_ptr[4];\n  }\n  if ((ushort_value_1 & 1) == 0) {\n    some_index = 0;\n    if (-1 < (int)(ushort_value_1 << 0x1e)) {\n      some_index = data_ptr[5];\n    }\n    data_ptr[2] = some_index;\n  }\n  else {\n    data_ptr[6] = -data_ptr[5];\n    data_ptr[2] = 0;\n  }\n  if ((some_value == 0) && ((int)((uint)*(ushort *)(data_ptr + 3) << 0x18) < 0)) {\n    *(ushort *)(data_ptr + 3) = *(ushort *)(data_ptr + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "check_and_update_status_0008356c",
                "param_1": "status_ptr",
                "param_2": "data_ptr",
                "iVar1": "some_index",
                "iVar2": "some_value",
                "uVar3": "ushort_value_1",
                "uVar4": "ushort_value_2"
            },
            "calling": [
                "_vfiprintf_r",
                "__sfvwrite_r",
                "__swbuf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083630": {
            "entrypoint": "0x00083630",
            "current_name": "update_data_00083630",
            "code": "\nundefined4 updateData_00083630(int dataFlag,undefined4 newData,undefined4 dataAddress,undefined4 additionalData)\n\n{\n  undefined4 *dataPtr;\n  uint index;\n  uint bitFlag;\n  \n  if (DAT_20070180 == (undefined4 *)0x0) {\n    DAT_20070180 = (undefined4 *)&DAT_20070184;\n  }\n  index = DAT_20070180[1];\n  dataPtr = DAT_20070180;\n  if (0x1f < (int)index) {\n    dataPtr = (undefined4 *)malloc(400);\n    if (dataPtr == (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *dataPtr = DAT_20070180;\n    dataPtr[1] = 0;\n    index = 0;\n    DAT_20070180 = dataPtr;\n    dataPtr[0x62] = 0;\n    dataPtr[99] = 0;\n  }\n  if (dataFlag != 0) {\n    bitFlag = 1 << (index & 0xff);\n    dataPtr[index + 0x22] = dataAddress;\n    dataPtr[0x62] = dataPtr[0x62] | bitFlag;\n    dataPtr[index + 0x42] = additionalData;\n    if (dataFlag == 2) {\n      dataPtr[99] = bitFlag | dataPtr[99];\n    }\n  }\n  dataPtr[1] = index + 1;\n  dataPtr[index + 2] = newData;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083630": "update_data_00083630",
                "param_1": "dataFlag",
                "param_2": "newData",
                "param_3": "dataAddress",
                "param_4": "additionalData",
                "puVar1": "dataPtr",
                "uVar2": "index",
                "uVar3": "bitFlag"
            },
            "calling": [
                "atexit",
                "__cxa_atexit"
            ],
            "called": [
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000836dc) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "terminate_program_000836ec",
            "code": "\n\n\nvoid terminate_program_000836ec(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_000836ec": "terminate_program_000836ec"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836fc": {
            "entrypoint": "0x000836fc",
            "current_name": "register_exit_process_000836fc",
            "code": "\nint register_exit_process_000836fc(function_data *function_data)\n\n{\n  int exit_proc_register_result;\n  \n  exit_proc_register_result = __register_exitproc(0,function_data,0,0);\n  return exit_proc_register_result;\n}\n\n",
            "renaming": {
                "FUN_000836fc": "register_exit_process_000836fc",
                "__func": "function_data",
                "iVar1": "exit_proc_register_result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083708": {
            "entrypoint": "0x00083708",
            "current_name": "decode_and_process_data_00083708",
            "code": "\nundefined4 decodeAndProcessData_00083708(int *input_data,int *decode_info)\n\n{\n  int *temp_ptr;\n  int remaining_bytes;\n  ushort decode_flags;\n  uint temp_flags;\n  int temp_value;\n  code *decoder_function;\n  int temp_var;\n  \n  decode_flags = *(ushort *)(decode_info + 3);\n  if ((int)((uint)decode_flags << 0x1c) < 0) {\n    temp_var = decode_info[4];\n    if (temp_var == 0) {\n      return 0;\n    }\n    remaining_bytes = *decode_info;\n    if ((decode_flags & 3) == 0) {\n      temp_value = decode_info[5];\n    }\n    else {\n      temp_value = 0;\n    }\n    *decode_info = temp_var;\n    remaining_bytes = remaining_bytes - temp_var;\n    decode_info[2] = temp_value;\n    do {\n      if (remaining_bytes < 1) {\n        return 0;\n      }\n      temp_value = (*(code *)decode_info[9])(input_data,decode_info[7],temp_var,remaining_bytes);\n      remaining_bytes = remaining_bytes - temp_value;\n      temp_var = temp_var + temp_value;\n    } while (0 < temp_value);\nLAB_000837c8:\n    *(ushort *)(decode_info + 3) = *(ushort *)(decode_info + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(decode_info + 3) = decode_flags | 0x800;\n  if ((decode_info[1] < 1) && (decode_info[0xf] < 1)) {\n    return 0;\n  }\n  decoder_function = (code *)decode_info[10];\n  if (decoder_function == (code *)0x0) {\n    return 0;\n  }\n  temp_flags = (uint)(decode_flags | 0x800);\n  temp_var = *input_data;\n  *input_data = 0;\n  if ((decode_flags & 0x1000) == 0) {\n    remaining_bytes = (*decoder_function)(input_data,decode_info[7],temp_flags & 0x1000,1);\n    if ((remaining_bytes == -1) && (temp_value = *input_data, temp_value != 0)) {\n      if ((temp_value == 0x1d) || (temp_value == 0x16)) {\n        *input_data = temp_var;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    temp_flags = (uint)*(ushort *)(decode_info + 3);\n    decoder_function = (code *)decode_info[10];\n  }\n  else {\n    remaining_bytes = decode_info[0x14];\n  }\n  if (((int)(temp_flags << 0x1d) < 0) && (remaining_bytes = remaining_bytes - decode_info[1], decode_info[0xc] != 0)) {\n    remaining_bytes = remaining_bytes - decode_info[0xf];\n  }\n  remaining_bytes = (*decoder_function)(input_data,decode_info[7],remaining_bytes,0);\n  if (remaining_bytes == -1) {\n    temp_value = *input_data;\n    if (temp_value != 0) {\n      if ((temp_value != 0x1d) && (temp_value != 0x16)) {\n        *(ushort *)(decode_info + 3) = *(ushort *)(decode_info + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(decode_info + 3) = *(ushort *)(decode_info + 3) & 0xf7ff;\n      *decode_info = decode_info[4];\n      decode_info[1] = 0;\n      goto LAB_00083774;\n    }\n    decode_flags = *(ushort *)(decode_info + 3) & 0xf7ff;\n    decode_info[1] = 0;\n    *(ushort *)(decode_info + 3) = decode_flags;\n    *decode_info = decode_info[4];\n  }\n  else {\n    decode_flags = *(ushort *)(decode_info + 3) & 0xf7ff;\n    *decode_info = decode_info[4];\n    *(ushort *)(decode_info + 3) = decode_flags;\n    decode_info[1] = 0;\n  }\n  if ((int)((uint)decode_flags << 0x13) < 0) {\n    decode_info[0x14] = remaining_bytes;\n  }\nLAB_00083774:\n  temp_ptr = (int *)decode_info[0xc];\n  *input_data = temp_var;\n  if (temp_ptr == (int *)0x0) {\n    return 0;\n  }\n  if (temp_ptr != decode_info + 0x10) {\n    _free_r(input_data);\n  }\n  decode_info[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083708": "decode_and_process_data_00083708",
                "param_1": "input_data",
                "param_2": "decode_info",
                "piVar1": "temp_ptr",
                "iVar2": "remaining_bytes",
                "uVar3": "decode_flags",
                "uVar4": "temp_flags",
                "iVar5": "temp_value",
                "pcVar6": "decoder_function",
                "iVar7": "temp_var"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "initialize_and_flush_00083850",
            "code": "\nvoid initializeAndFlush_00083850(int memoryLocation,int dataLocation)\n\n{\n  if ((memoryLocation != 0) && (*(int *)(memoryLocation + 0x38) == 0)) {\n    __sinit();\n  }\n  if (*(short *)(dataLocation + 0xc) == 0) {\n    return;\n  }\n  __sflush_r(memoryLocation);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083850": "initialize_and_flush_00083850",
                "param_1": "memoryLocation",
                "param_2": "dataLocation"
            },
            "calling": [
                "__sbprintf",
                "__sfvwrite_r",
                "__swbuf_r",
                "_fclose_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008387c": {
            "entrypoint": "0x0008387c",
            "current_name": "perform_function_traversal_0008387c",
            "code": "\nvoid performFunctionTraversal_0008387c(undefined4 param)\n\n{\n  walkFunction(param,0x84485);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008387c": "perform_function_traversal_0008387c",
                "param_1": "param",
                "_fwalk": "walkFunction"
            },
            "calling": [],
            "called": [
                "_fwalk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_data_structures_00083888",
            "code": "\nvoid initializeDataStructures_00083888(int dataStructures)\n\n{\n  undefined4 *ptr1;\n  undefined4 *ptr2;\n  \n  if (*(int *)(dataStructures + 0x38) == 0) {\n    ptr1 = *(undefined4 **)(dataStructures + 4);\n    *(undefined4 *)(dataStructures + 0x3c) = 0x8387d;\n    *(undefined4 *)(dataStructures + 0x2e4) = 3;\n    *(int *)(dataStructures + 0x2e8) = dataStructures + 0x2ec;\n    *(undefined4 *)(dataStructures + 0x2e0) = 0;\n    *(undefined2 *)(ptr1 + 3) = 4;\n    *ptr1 = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[0x19] = 0;\n    *(undefined2 *)((int)ptr1 + 0xe) = 0;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    memset(ptr1 + 0x17,0,8);\n    ptr2 = *(undefined4 **)(dataStructures + 8);\n    ptr1[7] = ptr1;\n    ptr1[8] = 0x84221;\n    ptr1[9] = 0x84245;\n    ptr1[10] = 0x8427d;\n    ptr1[0xb] = 0x8429d;\n    *(undefined2 *)((int)ptr2 + 0xe) = 1;\n    *(undefined2 *)(ptr2 + 3) = 9;\n    *ptr2 = 0;\n    ptr2[1] = 0;\n    ptr2[2] = 0;\n    ptr2[0x19] = 0;\n    ptr2[4] = 0;\n    ptr2[5] = 0;\n    ptr2[6] = 0;\n    memset(ptr2 + 0x17,0,8);\n    ptr1 = *(undefined4 **)(dataStructures + 0xc);\n    ptr2[7] = ptr2;\n    ptr2[8] = 0x84221;\n    ptr2[9] = 0x84245;\n    ptr2[10] = 0x8427d;\n    ptr2[0xb] = 0x8429d;\n    *(undefined2 *)(ptr1 + 3) = 0x12;\n    *(undefined2 *)((int)ptr1 + 0xe) = 2;\n    *ptr1 = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[0x19] = 0;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    memset(ptr1 + 0x17,0,8);\n    ptr1[7] = ptr1;\n    ptr1[8] = 0x84221;\n    ptr1[9] = 0x84245;\n    ptr1[10] = 0x8427d;\n    ptr1[0xb] = 0x8429d;\n    *(undefined4 *)(dataStructures + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_data_structures_00083888",
                "param_1": "dataStructures",
                "puVar1": "ptr1",
                "puVar2": "ptr2"
            },
            "calling": [
                "_vfiprintf_r",
                "__swsetup_r",
                "_fflush_r",
                "__swbuf_r",
                "_fclose_r"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083984": {
            "entrypoint": "0x00083984",
            "current_name": "execute_fini_array_functions_00083984",
            "code": "\nvoid execute_fini_array_functions_00083984(void)\n\n{\n  int counter;\n  code **function_pointer;\n  \n  counter = 1;\n  function_pointer = (code **)&_end_of_fini_array;\n  do {\n    counter = counter + -1;\n    function_pointer = function_pointer + -1;\n    (**function_pointer)();\n  } while (counter != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083984": "execute_fini_array_functions_00083984",
                "iVar1": "counter",
                "ppcVar2": "function_pointer",
                "_fini_array_end": "end_of_fini_array"
            },
            "calling": [],
            "called": [
                "__do_global_dtors_aux",
                "_fini"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "convert_and_print_string_000839b4",
            "code": "\nuint convertAndPrintString_000839b4(undefined4 locale,uint length,byte **output)\n\n{\n  int maxBytes;\n  uint result;\n  uint convertedCharacter;\n  byte *buffer;\n  uint iteration;\n  byte character;\n  byte stackBuffer [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(output + 3) << 0x12)) {\n    *(ushort *)(output + 3) = *(ushort *)(output + 3) | 0x2000;\n    output[0x19] = (byte *)((uint)output[0x19] | 0x2000);\n  }\n  maxBytes = __locale_mb_cur_max();\n  if ((maxBytes == 1) && (length - 1 < 0xff)) {\n    convertedCharacter = length & 0xff;\n    character = (byte)convertedCharacter;\n    result = 1;\n  }\n  else {\n    result = _wcrtomb_r(locale,&character,length,output + 0x17);\n    if (result == 0xffffffff) {\n      *(ushort *)(output + 3) = *(ushort *)(output + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (result == 0) {\n      return length;\n    }\n    convertedCharacter = (uint)character;\n  }\n  iteration = 0;\n  do {\n    buffer = output[2] + -1;\n    output[2] = buffer;\n    if ((int)buffer < 0) {\n      if ((int)output[6] <= (int)buffer) {\n        **output = (byte)convertedCharacter;\n        buffer = *output;\n        convertedCharacter = (uint)*buffer;\n        if (convertedCharacter != 10) goto LAB_00083a04;\n      }\n      maxBytes = __swbuf_r(locale,convertedCharacter,output);\n      if (maxBytes == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **output = (byte)convertedCharacter;\n      buffer = *output;\nLAB_00083a04:\n      *output = buffer + 1;\n    }\n    if (result <= iteration + 1) {\n      return length;\n    }\n    convertedCharacter = (uint)stackBuffer[iteration];\n    iteration = iteration + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "convert_and_print_string_000839b4",
                "param_1": "locale",
                "param_2": "length",
                "param_3": "output",
                "iVar1": "maxBytes",
                "uVar2": "result",
                "uVar3": "convertedCharacter",
                "pbVar4": "buffer",
                "uVar5": "iteration",
                "local_1c": "character",
                "abStack_1b": "stackBuffer"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "_wcrtomb_r",
                "__locale_mb_cur_max",
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "malloc_deallocate_00083a74",
            "code": "\nundefined4 malloc_deallocate_00083a74(undefined4 lock_id,int size)\n\n{\n  int result;\n  uint ptr;\n  int new_size;\n  \n  __malloc_lock();\n  ptr = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  new_size = ((ptr - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < new_size) {\n    result = _sbrk_r(lock_id,0);\n    if (result == DAT_2007046c + ptr) {\n      result = _sbrk_r(lock_id,-new_size);\n      if (result != -1) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo - new_size;\n        *(uint *)(DAT_2007046c + 4) = ptr - new_size | 1;\n        __malloc_unlock(lock_id);\n        return 1;\n      }\n      new_size = _sbrk_r(lock_id,0);\n      if (0xf < new_size - DAT_2007046c) {\n        __malloc_current_mallinfo = new_size - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) = new_size - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock_id);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "malloc_deallocate_00083a74",
                "param_1": "lock_id",
                "param_2": "size",
                "iVar1": "result",
                "uVar2": "ptr",
                "iVar3": "new_size"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "deallocate_memory_00083b10",
            "code": "\nvoid deallocateMemory_00083b10(undefined4 param,int mem_address)\n\n{\n  undefined4 *ptr;\n  bool isDAT2007046c;\n  uint size;\n  int temp1;\n  int temp2;\n  undefined1 *ptr1;\n  uint temp3;\n  undefined1 *ptr2;\n  int temp4;\n  uint temp5;\n  \n  if (mem_address == 0) {\n    return;\n  }\n  __malloc_lock();\n  size = *(uint *)(mem_address + -4);\n  temp4 = mem_address + -8;\n  temp3 = size & 0xfffffffe;\n  temp2 = temp4 + temp3;\n  temp5 = *(uint *)(temp2 + 4) & 0xfffffffc;\n  if (DAT_2007046c == temp2) {\n    temp5 = temp5 + temp3;\n    if (-1 < (int)(size << 0x1f)) {\n      temp4 = temp4 - *(int *)(mem_address + -8);\n      temp1 = *(int *)(temp4 + 0xc);\n      temp2 = *(int *)(temp4 + 8);\n      temp5 = temp5 + *(int *)(mem_address + -8);\n      *(int *)(temp2 + 0xc) = temp1;\n      *(int *)(temp1 + 8) = temp2;\n    }\n    size = __malloc_trim_threshold;\n    *(uint *)(temp4 + 4) = temp5 | 1;\n    DAT_2007046c = temp4;\n    if (size <= temp5) {\n      _malloc_trim_r(param,__malloc_top_pad);\n    }\n  }\n  else {\n    *(uint *)(temp2 + 4) = temp5;\n    if ((size & 1) == 0) {\n      temp4 = temp4 - *(int *)(mem_address + -8);\n      ptr = *(undefined4 **)(temp4 + 8);\n      temp3 = temp3 + *(int *)(mem_address + -8);\n      if (ptr == &DAT_2007046c) {\n        isDAT2007046c = true;\n      }\n      else {\n        temp1 = *(int *)(temp4 + 0xc);\n        ptr[3] = temp1;\n        *(undefined4 **)(temp1 + 8) = ptr;\n        isDAT2007046c = false;\n      }\n    }\n    else {\n      isDAT2007046c = false;\n    }\n    if (-1 < *(int *)(temp2 + temp5 + 4) << 0x1f) {\n      temp3 = temp3 + temp5;\n      ptr = *(undefined4 **)(temp2 + 8);\n      if ((!isDAT2007046c) && (ptr == &DAT_2007046c)) {\n        DAT_20070474 = temp4;\n        DAT_20070478 = temp4;\n        *(int **)(temp4 + 0xc) = &DAT_2007046c;\n        *(int **)(temp4 + 8) = &DAT_2007046c;\n        *(uint *)(temp4 + 4) = temp3 | 1;\n        *(uint *)(temp4 + temp3) = temp3;\n        goto LAB_00083ba4;\n      }\n      temp2 = *(int *)(temp2 + 0xc);\n      ptr[3] = temp2;\n      *(undefined4 **)(temp2 + 8) = ptr;\n    }\n    *(uint *)(temp4 + 4) = temp3 | 1;\n    *(uint *)(temp4 + temp3) = temp3;\n    if (!isDAT2007046c) {\n      if (temp3 < 0x200) {\n        size = temp3 & 0xfffffff8;\n        temp2 = *(int *)((int)&DAT_2007046c + size);\n        DAT_20070468 = DAT_20070468 | 1 << ((int)(temp3 >> 3) >> 2 & 0xffU);\n        *(int *)(temp4 + 8) = temp2;\n        *(undefined1 **)(temp4 + 0xc) = &__malloc_av_ + size;\n        *(int *)((int)&DAT_2007046c + size) = temp4;\n        *(int *)(temp2 + 0xc) = temp4;\n        __malloc_unlock(param);\n        return;\n      }\n      size = temp3 >> 9;\n      if (size < 5) {\n        temp2 = (temp3 >> 6) + 0x38;\n        temp1 = temp2 * 2;\n      }\n      else if (size < 0x15) {\n        temp2 = size + 0x5b;\n        temp1 = temp2 * 2;\n      }\n      else if (size < 0x55) {\n        temp2 = (temp3 >> 0xc) + 0x6e;\n        temp1 = temp2 * 2;\n      }\n      else if (size < 0x155) {\n        temp2 = (temp3 >> 0xf) + 0x77;\n        temp1 = temp2 * 2;\n      }\n      else if (size < 0x555) {\n        temp2 = (temp3 >> 0x12) + 0x7c;\n        temp1 = temp2 * 2;\n      }\n      else {\n        temp1 = 0xfc;\n        temp2 = 0x7e;\n      }\n      ptr1 = (undefined1 *)(&DAT_2007046c)[temp1];\n      if (ptr1 == &__malloc_av_ + temp1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (temp2 >> 2 & 0xffU);\n        ptr2 = ptr1;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr1 + 4) & 0xfffffffc) <= temp3) break;\n          ptr1 = *(undefined1 **)(ptr1 + 8);\n        } while (&__malloc_av_ + temp1 * 4 != ptr1);\n        ptr2 = *(undefined1 **)(ptr1 + 0xc);\n      }\n      *(undefined1 **)(temp4 + 0xc) = ptr2;\n      *(undefined1 **)(temp4 + 8) = ptr1;\n      *(int *)(ptr2 + 8) = temp4;\n      *(int *)(ptr1 + 0xc) = temp4;\n    }\n  }\nLAB_00083ba4:\n  __malloc_unlock(param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "deallocate_memory_00083b10",
                "param_1": "param",
                "param_2": "mem_address",
                "puVar1": "ptr",
                "bVar2": "isDAT2007046c",
                "uVar3": "size",
                "iVar4": "temp1",
                "iVar5": "temp2",
                "puVar6": "ptr1",
                "uVar7": "temp3",
                "puVar8": "ptr2",
                "iVar9": "temp4",
                "uVar10": "temp5"
            },
            "calling": [
                "_malloc_r",
                "free",
                "__sflush_r",
                "__swsetup_r",
                "__sfvwrite_r",
                "_realloc_r",
                "_fclose_r"
            ],
            "called": [
                "_malloc_trim_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "reverse_and_improve_00083ca8",
            "code": "\nundefined4 reverseAndImprove_00083ca8(undefined4 *errorFlag,void **inputBuffer,undefined4 *inputLength)\n\n{\n  void **tempPointer1;\n  int errorCode;\n  void *sourceBuffer;\n  void *newBuffer;\n  void *bufferSize;\n  void *tempPointer2;\n  ushort flags;\n  uint flags;\n  int currentLength;\n  void **pointerArray;\n  void *ptr1;\n  void *ptr2;\n  void *tempPointer3;\n  size_t tempSize;\n  void *tempVar;\n  \n  if (inputLength[2] != 0) {\n    flags = *(ushort *)(inputBuffer + 3);\n    flags = (uint)flags;\n    if (((int)(flags << 0x1c) < 0) && (inputBuffer[4] != (void *)0x0)) {\n      pointerArray = (void **)*inputLength;\n    }\n    else {\n      errorCode = __swsetup_r(errorFlag,inputBuffer);\n      if (errorCode != 0) {\n        return 0xffffffff;\n      }\n      flags = *(ushort *)(inputBuffer + 3);\n      flags = (uint)flags;\n      pointerArray = (void **)*inputLength;\n    }\n    if ((flags & 2) == 0) {\n      bufferSize = (void *)(flags & 2);\n      ptr2 = bufferSize;\n      ptr1 = bufferSize;\n      tempVar = bufferSize;\n      if ((flags & 1) == 0) {\n        bufferSize = (void *)0x0;\n        ptr2 = (void *)0x0;\n        while( true ) {\n          while (bufferSize == (void *)0x0) {\n            ptr2 = *pointerArray;\n            tempPointer1 = pointerArray + 1;\n            pointerArray = pointerArray + 2;\n            bufferSize = *tempPointer1;\n          }\n          ptr1 = inputBuffer[2];\n          if ((int)(flags << 0x16) < 0) {\n            if (bufferSize < ptr1) {\n              sourceBuffer = *inputBuffer;\n              ptr1 = bufferSize;\n            }\n            else if ((flags & 0x480) == 0) {\n              sourceBuffer = *inputBuffer;\n            }\n            else {\n              tempSize = (int)*inputBuffer - (int)inputBuffer[4];\n              ptr1 = (void *)(tempSize + 1 + (int)bufferSize);\n              sourceBuffer = (void *)(((int)inputBuffer[5] * 3) / 2);\n              if (ptr1 <= sourceBuffer) {\n                ptr1 = sourceBuffer;\n              }\n              if ((int)(flags << 0x15) < 0) {\n                newBuffer = (void *)_malloc_r(errorFlag,ptr1);\n                if (newBuffer == (void *)0x0) {\n                  *errorFlag = 0xc;\n                  flags = *(ushort *)(inputBuffer + 3);\n                  goto LAB_00083da4;\n                }\n                memcpy(newBuffer,inputBuffer[4],tempSize);\n                *(ushort *)(inputBuffer + 3) = *(ushort *)(inputBuffer + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                newBuffer = (void *)_realloc_r(errorFlag);\n                if (newBuffer == (void *)0x0) {\n                  _free_r(errorFlag,inputBuffer[4]);\n                  flags = *(ushort *)(inputBuffer + 3) & 0xff7f;\n                  *errorFlag = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              sourceBuffer = (void *)((int)newBuffer + tempSize);\n              inputBuffer[4] = newBuffer;\n              inputBuffer[5] = ptr1;\n              *inputBuffer = sourceBuffer;\n              inputBuffer[2] = (void *)((int)ptr1 - tempSize);\n              ptr1 = bufferSize;\n            }\n            memmove(sourceBuffer,ptr2,(size_t)ptr1);\n            inputBuffer[2] = (void *)((int)inputBuffer[2] - (int)ptr1);\n            *inputBuffer = (void *)((int)*inputBuffer + (int)ptr1);\n            ptr1 = bufferSize;\n          }\n          else if ((inputBuffer[4] < *inputBuffer) || (sourceBuffer = inputBuffer[5], bufferSize < sourceBuffer)) {\n            if (bufferSize < ptr1) {\n              ptr1 = bufferSize;\n            }\n            memmove(*inputBuffer,ptr2,(size_t)ptr1);\n            sourceBuffer = inputBuffer[2];\n            inputBuffer[2] = (void *)((int)sourceBuffer - (int)ptr1);\n            *inputBuffer = (void *)((int)*inputBuffer + (int)ptr1);\n            if (((void *)((int)sourceBuffer - (int)ptr1) == (void *)0x0) &&\n               (errorCode = _fflush_r(errorFlag,inputBuffer), errorCode != 0)) goto LAB_00083da2;\n          }\n          else {\n            ptr1 = (void *)0x7fffffff;\n            if (bufferSize < (void *)0x7fffffff) {\n              ptr1 = bufferSize;\n            }\n            ptr1 = (void *)(*(code *)inputBuffer[9])\n                                        (errorFlag,inputBuffer[7],ptr2,\n                                         ((uint)ptr1 / (uint)sourceBuffer) * (int)sourceBuffer);\n            if ((int)ptr1 < 1) goto LAB_00083da2;\n          }\n          errorCode = inputLength[2];\n          ptr2 = (void *)((int)ptr2 + (int)ptr1);\n          bufferSize = (void *)((int)bufferSize - (int)ptr1);\n          inputLength[2] = errorCode - (int)ptr1;\n          if (errorCode - (int)ptr1 == 0) break;\n          flags = (uint)*(ushort *)(inputBuffer + 3);\n        }\n      }\n      else {\n        do {\n          while (bufferSize == (void *)0x0) {\n            ptr1 = *pointerArray;\n            bufferSize = pointerArray[1];\n            tempVar = (void *)0x0;\n            pointerArray = pointerArray + 2;\n          }\n          if (tempVar == (void *)0x0) {\n            ptr2 = memchr(ptr1,10,(size_t)bufferSize);\n            if (ptr2 == (void *)0x0) {\n              ptr2 = (void *)((int)bufferSize + 1);\n              tempVar = (void *)0x1;\n            }\n            else {\n              ptr2 = (void *)((int)ptr2 + (1 - (int)ptr1));\n              tempVar = (void *)0x1;\n            }\n          }\n          newBuffer = *inputBuffer;\n          sourceBuffer = ptr2;\n          if (bufferSize <= ptr2) {\n            sourceBuffer = bufferSize;\n          }\n          tempPointer2 = inputBuffer[5];\n          if ((inputBuffer[4] < newBuffer) &&\n             (tempPointer3 = (void *)((int)inputBuffer[2] + (int)tempPointer2), (int)tempPointer3 < (int)sourceBuffer)) {\n            memmove(newBuffer,ptr1,(size_t)tempPointer3);\n            *inputBuffer = (void *)((int)*inputBuffer + (int)tempPointer3);\n            errorCode = _fflush_r(errorFlag,inputBuffer);\n            if (errorCode != 0) goto LAB_00083da2;\n          }\n          else if ((int)sourceBuffer < (int)tempPointer2) {\n            memmove(newBuffer,ptr1,(size_t)sourceBuffer);\n            inputBuffer[2] = (void *)((int)inputBuffer[2] - (int)sourceBuffer);\n            *inputBuffer = (void *)((int)sourceBuffer + (int)*inputBuffer);\n            tempPointer3 = sourceBuffer;\n          }\n          else {\n            tempPointer3 = (void *)(*(code *)inputBuffer[9])(errorFlag,inputBuffer[7],ptr1,tempPointer2);\n            if ((int)tempPointer3 < 1) goto LAB_00083da2;\n          }\n          ptr2 = (void *)((int)ptr2 - (int)tempPointer3);\n          if (ptr2 == (void *)0x0) {\n            errorCode = _fflush_r(errorFlag,inputBuffer);\n            if (errorCode != 0) goto LAB_00083da2;\n            tempVar = (void *)0x0;\n          }\n          errorCode = inputLength[2];\n          ptr1 = (void *)((int)ptr1 + (int)tempPointer3);\n          bufferSize = (void *)((int)bufferSize - (int)tempPointer3);\n          inputLength[2] = errorCode - (int)tempPointer3;\n        } while (errorCode - (int)tempPointer3 != 0);\n      }\n    }\n    else {\n      ptr2 = (void *)0x0;\n      bufferSize = (void *)0x0;\n      do {\n        while( true ) {\n          ptr1 = bufferSize;\n          if ((void *)0x7ffffbff < bufferSize) {\n            ptr1 = (void *)0x7ffffc00;\n          }\n          if (bufferSize != (void *)0x0) break;\n          ptr2 = *pointerArray;\n          bufferSize = pointerArray[1];\n          pointerArray = pointerArray + 2;\n        }\n        errorCode = (*(code *)inputBuffer[9])(errorFlag,inputBuffer[7],ptr2,ptr1);\n        if (errorCode < 1) {\nLAB_00083da2:\n          flags = *(ushort *)(inputBuffer + 3);\nLAB_00083da4:\n          *(ushort *)(inputBuffer + 3) = flags | 0x40;\n          return 0xffffffff;\n        }\n        currentLength = inputLength[2];\n        ptr2 = (void *)((int)ptr2 + errorCode);\n        bufferSize = (void *)((int)bufferSize - errorCode);\n        inputLength[2] = currentLength - errorCode;\n      } while (currentLength - errorCode != 0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "reverse_and_improve_00083ca8",
                "param_1": "errorFlag",
                "param_2": "inputBuffer",
                "param_3": "inputLength",
                "ppvVar1": "tempPointer1",
                "iVar2": "errorCode",
                "pvVar3": "sourceBuffer",
                "pvVar4": "newBuffer",
                "pvVar5": "bufferSize",
                "pvVar6": "tempPointer2",
                "uVar7": "flags",
                "uVar8": "flags",
                "iVar9": "currentLength",
                "ppvVar10": "pointerArray",
                "pvVar11": "ptr1",
                "pvVar12": "ptr2",
                "__n": "tempPointer3",
                "__n_00": "tempSize",
                "local_2c": "tempVar"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "memchr",
                "memmove",
                "_malloc_r",
                "__swsetup_r",
                "_fflush_r",
                "_realloc_r",
                "memcpy",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083fbc": {
            "entrypoint": "0x00083fbc",
            "current_name": "process_data_00083fbc",
            "code": "\nuint processData_00083fbc(int inputPointer,code *functionPointer)\n\n{\n  uint result;\n  int blockPointer;\n  int count;\n  uint finalResult;\n  int *nextPointer;\n  \n  nextPointer = (int *)(inputPointer + 0x2e0);\n  if (nextPointer != (int *)0x0) {\n    finalResult = 0;\n    do {\n      blockPointer = nextPointer[2];\n      count = nextPointer[1] + -1;\n      if (-1 < count) {\n        do {\n          count = count + -1;\n          if ((1 < *(ushort *)(blockPointer + 0xc)) && (*(short *)(blockPointer + 0xe) != -1)) {\n            result = (*functionPointer)(blockPointer);\n            finalResult = finalResult | result;\n          }\n          blockPointer = blockPointer + 0x68;\n        } while (count != -1);\n      }\n      nextPointer = (int *)*nextPointer;\n    } while (nextPointer != (int *)0x0);\n    return finalResult;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083fbc": "process_data_00083fbc",
                "param_1": "inputPointer",
                "param_2": "functionPointer",
                "uVar1": "result",
                "iVar2": "blockPointer",
                "iVar3": "count",
                "uVar4": "finalResult",
                "piVar5": "nextPointer"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_charset_00084004",
            "code": "\nchar * getCharset_00084004(void)\n\n{\n  return charset;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_charset_00084004",
                "lc_ctype_charset": "charset"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_max_character_length_0008400c",
            "code": "\nundefined4 getMaxCharacterLength_0008400c(void)\n\n{\n  return maxCharacterLength;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_max_character_length_0008400c",
                "__mb_cur_max": "maxCharacterLength"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "process_file_00084018",
            "code": "\nvoid processFile_00084018(int fileDescriptor,int *fileInfo)\n\n{\n  ushort fileMode;\n  int fileStatus;\n  int allocatedMemory;\n  uint fileAttribute;\n  bool isConsole;\n  undefined statBuffer [4];\n  uint filePermission;\n  \n  fileMode = *(ushort *)(fileInfo + 3);\n  fileAttribute = (uint)fileMode;\n  if ((int)(fileAttribute << 0x1e) < 0) {\n    *fileInfo = (int)fileInfo + 0x43;\n    fileInfo[4] = (int)fileInfo + 0x43;\n    fileInfo[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)fileInfo + 0xe)) {\n    fileStatus = _fstat_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe),statBuffer);\n    if (-1 < fileStatus) {\n      isConsole = (filePermission & 0xf000) == 0x2000;\n      if (((filePermission & 0xf000) == 0x8000) && (fileInfo[10] == 0x8427d)) {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x400;\n        fileInfo[0x13] = 0x400;\n      }\n      else {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    fileMode = *(ushort *)(fileInfo + 3);\n    fileAttribute = (uint)fileMode;\n  }\n  *(ushort *)(fileInfo + 3) = fileMode | 0x800;\n  if ((fileAttribute & 0x80) == 0) {\n    fileStatus = 0x400;\n  }\n  else {\n    fileStatus = 0x40;\n  }\n  isConsole = false;\nLAB_00084074:\n  allocatedMemory = _malloc_r(fileDescriptor,fileStatus);\n  fileMode = *(ushort *)(fileInfo + 3);\n  if (allocatedMemory == 0) {\n    if (-1 < (int)((uint)fileMode << 0x16)) {\n      *(ushort *)(fileInfo + 3) = fileMode | 2;\n      *fileInfo = (int)fileInfo + 0x43;\n      fileInfo[4] = (int)fileInfo + 0x43;\n      fileInfo[5] = 1;\n    }\n  }\n  else {\n    *(undefined4 *)(fileDescriptor + 0x3c) = 0x8387d;\n    *(ushort *)(fileInfo + 3) = fileMode | 0x80;\n    *fileInfo = allocatedMemory;\n    fileInfo[4] = allocatedMemory;\n    fileInfo[5] = fileStatus;\n    if ((isConsole) && (fileStatus = _isatty_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe)), fileStatus != 0)) {\n      *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "process_file_00084018",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "uVar1": "fileMode",
                "iVar2": "fileStatus",
                "iVar3": "allocatedMemory",
                "uVar4": "fileAttribute",
                "bVar5": "isConsole",
                "auStack_54": "statBuffer",
                "local_50": "filePermission"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_fstat_r",
                "_isatty_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "find_first_occurrence_000840f8",
            "code": "\nvoid * findFirstOccurrence_000840f8(void *data,int character,size_t length)\n\n{\n  uint charMask;\n  uint tempVar;\n  int counter;\n  uint *dataPtr;\n  uint compareMask;\n  bool lastIteration;\n  \n  charMask = character & 0xff;\n  if (((uint)data & 3) == 0) {\nLAB_00084128:\n    if (3 < length) {\n      compareMask = charMask | charMask << 8;\n      dataPtr = (uint *)data;\n      do {\n        tempVar = *dataPtr ^ (compareMask | compareMask << 0x10);\n        data = dataPtr;\n        if ((tempVar + 0xfefefeff & ~tempVar & 0x80808080) != 0) break;\n        length = length - 4;\n        data = dataPtr + 1;\n        dataPtr = dataPtr + 1;\n      } while (3 < length);\n    }\n    if (length == 0) {\n      data = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*data != charMask) {\n        counter = 0;\n        do {\n          data = (void *)((int)data + 1);\n          lastIteration = counter == length - 1;\n          counter = counter + 1;\n          if (lastIteration) goto LAB_00084150;\n                    /* WARNING: Load size is inaccurate */\n        } while (*data != charMask);\n      }\n    }\n  }\n  else if (length == 0) {\nLAB_00084150:\n    data = (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*data != charMask) {\n      dataPtr = (uint *)((int)data + 1);\n      length = length - 1;\n      do {\n        data = dataPtr;\n        if (((uint)data & 3) == 0) goto LAB_00084128;\n        if (length == 0) goto LAB_00084150;\n                    /* WARNING: Load size is inaccurate */\n        dataPtr = (uint *)((int)data + 1);\n        length = length - 1;\n      } while (*data != charMask);\n    }\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "find_first_occurrence_000840f8",
                "__s": "data",
                "__c": "character",
                "__n": "length",
                "uVar1": "charMask",
                "uVar2": "tempVar",
                "iVar3": "counter",
                "puVar4": "dataPtr",
                "uVar5": "compareMask",
                "bVar6": "lastIteration"
            },
            "calling": [
                "_vfiprintf_r",
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008418c": {
            "entrypoint": "0x0008418c",
            "current_name": "process_signal_0008418c",
            "code": "\nundefined4 process_signal_0008418c(undefined4 *out_status,uint signal_num,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t process_id;\n  undefined4 result;\n  int function_ptr_offset;\n  code *function_ptr;\n  \n  if (0x1f < signal_num) {\n    *out_status = 0x16;\n    return 0xffffffff;\n  }\n  function_ptr_offset = out_status[0xb7];\n  if ((function_ptr_offset == 0) || (function_ptr = *(code **)(function_ptr_offset + signal_num * 4), function_ptr == (code *)0x0)) {\n    process_id = _getpid_r();\n    result = _kill_r(out_status,process_id,signal_num,param_4);\n    return result;\n  }\n  if (function_ptr == (code *)0x1) {\n    return 0;\n  }\n  if (function_ptr != (code *)0xffffffff) {\n    *(undefined4 *)(function_ptr_offset + signal_num * 4) = 0;\n    (*function_ptr)(signal_num);\n    return 0;\n  }\n  *out_status = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0008418c": "process_signal_0008418c",
                "param_1": "out_status",
                "param_2": "signal_num",
                "_Var1": "process_id",
                "uVar2": "result",
                "iVar3": "function_ptr_offset",
                "pcVar4": "function_ptr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "handle_signal_000841e4",
            "code": "\nint handle_signal_000841e4(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "handle_signal_000841e4",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841f4": {
            "entrypoint": "0x000841f4",
            "current_name": "kill_process_000841f4",
            "code": "\nvoid killProcess_000841f4(int *errorCode,int processID,int signal)\n\n{\n  error = 0;\n  _kill(processID,signal);\n  if ((processID == -1) && (error != 0)) {\n    *errorCode = error;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000841f4": "kill_process_000841f4",
                "param_1": "errorCode",
                "param_2": "processID",
                "param_3": "signal",
                "errno": "error"
            },
            "calling": [
                "kill",
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008421c": {
            "entrypoint": "0x0008421c",
            "current_name": "FUN_0008421c",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return -1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_data_00084220",
            "code": "\nvoid updateData_00084220(undefined4 fileDescriptor,int dataPointer)\n\n{\n  int bytesRead;\n  \n  bytesRead = _read_r(fileDescriptor,(int)*(short *)(dataPointer + 0xe));\n  if (-1 < bytesRead) {\n    *(int *)(dataPointer + 0x50) = *(int *)(dataPointer + 0x50) + bytesRead;\n    return;\n  }\n  *(ushort *)(dataPointer + 0xc) = *(ushort *)(dataPointer + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_data_00084220",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "iVar1": "bytesRead"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "process_data_00084244",
            "code": "\nvoid processData_00084244(undefined4 fileDescriptor,int dataPointer,undefined4 buffer,undefined4 size)\n\n{\n  ushort value;\n  \n  value = *(ushort *)(dataPointer + 0xc);\n  if ((int)((uint)value << 0x17) < 0) {\n    moveFilePointer(fileDescriptor,(int)*(short *)(dataPointer + 0xe),0,2);\n    value = *(ushort *)(dataPointer + 0xc);\n  }\n  *(ushort *)(dataPointer + 0xc) = value & 0xefff;\n  writeToFile(fileDescriptor,(int)*(short *)(dataPointer + 0xe),buffer,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "process_data_00084244",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "param_3": "buffer",
                "param_4": "size",
                "uVar1": "value",
                "_lseek_r": "moveFilePointer",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "update_file_pointer_0008427c",
            "code": "\nvoid updateFilePointer_0008427c(undefined4 fileDescriptor,int structPointer)\n\n{\n  int seekResult;\n  ushort controlBitmask;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structPointer + 0xe));\n  if (seekResult == -1) {\n    controlBitmask = *(ushort *)(structPointer + 0xc) & 0xefff;\n  }\n  else {\n    controlBitmask = *(ushort *)(structPointer + 0xc) | 0x1000;\n  }\n  if (seekResult != -1) {\n    *(int *)(structPointer + 0x50) = seekResult;\n  }\n  *(ushort *)(structPointer + 0xc) = controlBitmask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "update_file_pointer_0008427c",
                "param_1": "fileDescriptor",
                "param_2": "structPointer",
                "iVar1": "seekResult",
                "uVar2": "controlBitmask"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008429c": {
            "entrypoint": "0x0008429c",
            "current_name": "close_file_0008429c",
            "code": "\nvoid closeFile_0008429c(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008429c": "close_file_0008429c",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_input_000842a4",
            "code": "\nuint processInput_000842a4(int inputPointer,uint inputValue,undefined4 *inputArray,undefined4 inputFlag)\n\n{\n  ushort ushortValue;\n  uint uintValue;\n  undefined *undefinedPointer;\n  int counter;\n  \n  if ((inputPointer != 0) && (*(int *)(inputPointer + 0x38) == 0)) {\n    __sinit();\n  }\n  ushortValue = *(ushort *)(inputArray + 3);\n  uintValue = (uint)ushortValue;\n  inputArray[2] = inputArray[6];\n  if ((-1 < (int)(uintValue << 0x1c)) || (counter = inputArray[4], counter == 0)) {\n    counter = __swsetup_r(inputPointer,inputArray,ushortValue,uintValue,inputFlag);\n    if (counter != 0) {\n      return 0xffffffff;\n    }\n    ushortValue = *(ushort *)(inputArray + 3);\n    counter = inputArray[4];\n    uintValue = (uint)ushortValue;\n  }\n  inputValue = inputValue & 0xff;\n  if ((int)(uintValue << 0x12) < 0) {\n    undefinedPointer = (undefined *)*inputArray;\n    counter = (int)undefinedPointer - counter;\n    if (counter < (int)inputArray[5]) {\nLAB_000842d6:\n      counter = counter + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    inputArray[0x19] = inputArray[0x19] & 0xffffdfff;\n    undefinedPointer = (undefined *)*inputArray;\n    *(ushort *)(inputArray + 3) = ushortValue | 0x2000;\n    counter = (int)undefinedPointer - counter;\n    if (counter < (int)inputArray[5]) goto LAB_000842d6;\n  }\n  counter = _fflush_r(inputPointer,inputArray);\n  if (counter != 0) {\n    return 0xffffffff;\n  }\n  undefinedPointer = (undefined *)*inputArray;\n  counter = 1;\nLAB_000842d8:\n  inputArray[2] = inputArray[2] + -1;\n  *inputArray = undefinedPointer + 1;\n  *undefinedPointer = (char)inputValue;\n  if (((inputArray[5] == counter) ||\n      (((int)((uint)*(ushort *)(inputArray + 3) << 0x1f) < 0 && (inputValue == 10)))) &&\n     (counter = _fflush_r(inputPointer,inputArray), counter != 0)) {\n    return 0xffffffff;\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_input_000842a4",
                "param_1": "inputPointer",
                "param_2": "inputValue",
                "param_3": "inputArray",
                "param_4": "inputFlag",
                "uVar1": "ushortValue",
                "uVar2": "uintValue",
                "puVar3": "undefinedPointer",
                "iVar4": "counter"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__sinit",
                "__swsetup_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "convert_string_to_character_0008434c",
            "code": "\nvoid convertStringToCharacter_0008434c(undefined4 *outputString,int inputLength,undefined4 conversionType,undefined4 *errorFlag)\n\n{\n  code *conversionFunction;\n  undefined4 charset;\n  int result;\n  undefined conversionBuffer [12];\n  \n  conversionFunction = __wctomb;\n  if (inputLength == 0) {\n    charset = __locale_charset();\n    result = (*conversionFunction)(outputString,conversionBuffer,0,charset,errorFlag);\n  }\n  else {\n    charset = __locale_charset();\n    result = (*conversionFunction)(outputString,inputLength,conversionType,charset,errorFlag);\n  }\n  if (result == -1) {\n    *errorFlag = 0;\n    *outputString = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "convert_string_to_character_0008434c",
                "param_1": "outputString",
                "param_2": "inputLength",
                "param_3": "conversionType",
                "param_4": "errorFlag",
                "pcVar1": "conversionFunction",
                "uVar2": "charset",
                "iVar3": "result",
                "auStack_24": "conversionBuffer"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__ascii_wctomb",
                "__locale_charset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "convert_uint_to_char_0008439c",
            "code": "\nundefined4 convert_uint_to_char_0008439c(undefined4 *output_value,undefined *buffer,uint input_value)\n\n{\n  if (buffer == (undefined *)0x0) {\n    return 0;\n  }\n  if (input_value < 0x100) {\n    *buffer = (char)input_value;\n    return 1;\n  }\n  *output_value = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "convert_uint_to_char_0008439c",
                "param_1": "output_value",
                "param_2": "buffer",
                "param_3": "input_value"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000843b8": {
            "entrypoint": "0x000843b8",
            "current_name": "write_to_file_000843b8",
            "code": "\nvoid writeToFile_000843b8(int *errorCode,int fileDescriptor,char *data,int size)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _write(fileDescriptor,data,size);\n  if ((result == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000843b8": "write_to_file_000843b8",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000843e0": {
            "entrypoint": "0x000843e0",
            "current_name": "close_file_with_error_handling_000843e0",
            "code": "\nvoid closeFileWithErrorHandling_000843e0(int *errorPointer,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorPointer = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000843e0": "close_file_with_error_handling_000843e0",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084404": {
            "entrypoint": "0x00084404",
            "current_name": "flush_and_free_resources_00084404",
            "code": "\nundefined4 flushAndFreeResources_00084404(int fileDescriptor,int stream)\n\n{\n  undefined4 result;\n  int readResult;\n  \n  if (stream != 0) {\n    if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x38) == 0)) {\n      __sinit();\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      result = _fflush_r(fileDescriptor,stream);\n      if ((*(code **)(stream + 0x2c) != (code *)0x0) &&\n         (readResult = (**(code **)(stream + 0x2c))(fileDescriptor,*(undefined4 *)(stream + 0x1c)), readResult < 0)\n         ) {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x18) < 0) {\n        _free_r(fileDescriptor,*(undefined4 *)(stream + 0x10));\n      }\n      if (*(int *)(stream + 0x30) != 0) {\n        if (*(int *)(stream + 0x30) != stream + 0x40) {\n          _free_r(fileDescriptor);\n        }\n        *(undefined4 *)(stream + 0x30) = 0;\n      }\n      if (*(int *)(stream + 0x44) != 0) {\n        _free_r(fileDescriptor);\n        *(undefined4 *)(stream + 0x44) = 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(stream + 0xc) = 0;\n      __sfp_lock_release();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084404": "flush_and_free_resources_00084404",
                "param_1": "fileDescriptor",
                "param_2": "stream",
                "uVar1": "result",
                "iVar2": "readResult"
            },
            "calling": [
                "fclose"
            ],
            "called": [
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "_fflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "close_file_00084484",
            "code": "\nint closeFile_00084484(FILE *file)\n\n{\n  int result;\n  \n  result = _fclose_r(_impure_ptr,file);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00084484": "close_file_00084484",
                "__stream": "file",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_fclose_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "get_fstat_error_code_00084494",
            "code": "\nvoid getFstatErrorCode_00084494(int *errorCode,int fileDescriptor,stat *fileInfo)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(fileDescriptor,fileInfo);\n  if ((result == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "get_fstat_error_code_00084494",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "fileInfo",
                "iVar1": "result"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "check_terminal_status_000844bc",
            "code": "\nvoid checkTerminalStatus_000844bc(int *error,int terminalDescriptor)\n\n{\n  int isTerminal;\n  \n  errno = 0;\n  isTerminal = _isatty(terminalDescriptor);\n  if ((isTerminal == -1) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "check_terminal_status_000844bc",
                "param_1": "error",
                "param_2": "terminalDescriptor",
                "iVar1": "isTerminal"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "set_file_offset_000844e0",
            "code": "\nvoid setFileOffset_000844e0(int *errnoPtr,int fileDescriptor,__off_t offset,int whence)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,whence);\n  if ((result == -1) && (errno != 0)) {\n    *errnoPtr = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "set_file_offset_000844e0",
                "param_1": "errnoPtr",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "read_with_error_handling_00084508",
            "code": "\nvoid readWithErrorHandling_00084508(int *errorCode,int fileDescriptor,char *buffer,int count)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,count);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "read_with_error_handling_00084508",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "div_mod_function_00084530",
            "code": "\nvoid divModFunction_00084530(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend);\n    return;\n  }\n  __gnu_uldivmod_helper();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084530": "div_mod_function_00084530",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__gnu_uldivmod_helper",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "subtract_and_update_0008455c",
            "code": "\nvoid subtract_and_update_0008455c(uint input_value,int param_2,undefined4 concat44_param_1,undefined4 concat44_param_2,int *result_array)\n\n{\n  uint result;\n  longlong quotient;\n  \n  quotient = __divdi3();\n  quotient = quotient * CONCAT44(concat44_param_2,concat44_param_1);\n  result = (uint)quotient;\n  *result_array = input_value - result;\n  result_array[1] = (param_2 - (int)((ulonglong)quotient >> 0x20)) - (uint)(input_value < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "subtract_and_update_0008455c",
                "param_1": "input_value",
                "param_3": "concat44_param_1",
                "param_4": "concat44_param_2",
                "param_5": "result_array",
                "uVar1": "result",
                "lVar2": "quotient"
            },
            "calling": [],
            "called": [
                "__divdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "calculate_difference_0008458c",
            "code": "\nvoid calculateDifference_0008458c(uint inputValue,int param2,undefined4 param3,undefined4 param4,int *resultArray)\n\n{\n  uint calculatedValue;\n  longlong multiplicationResult;\n  \n  multiplicationResult = __udivdi3();\n  multiplicationResult = multiplicationResult * CONCAT44(param4,param3);\n  calculatedValue = (uint)multiplicationResult;\n  *resultArray = inputValue - calculatedValue;\n  resultArray[1] = (param2 - (int)((ulonglong)multiplicationResult >> 0x20)) - (uint)(inputValue < calculatedValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "calculate_difference_0008458c",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "resultArray",
                "uVar1": "calculatedValue",
                "lVar2": "multiplicationResult"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [
                "__udivdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845bc": {
            "entrypoint": "0x000845bc",
            "current_name": "FUNC_000845bc",
            "code": "\nvoid FUNC_000845bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000845bc": "FUNC_000845bc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "dividend_division_000845c0",
            "code": "\nundefined8 dividend_division_000845c0(uint dividend,uint divisor_high,uint divisor_low,uint remainder)\n\n{\n  longlong temp;\n  uint result_high;\n  uint result_low;\n  uint quotient_high;\n  uint quotient_low;\n  int shift_count;\n  uint temp_2;\n  uint temp_3;\n  uint is_negative_dividend;\n  uint quotient;\n  uint temp_4;\n  uint temp_5;\n  bool carry_flag;\n  \n  if ((int)divisor_high < 0) {\n    carry_flag = dividend != 0;\n    dividend = -dividend;\n    divisor_high = -divisor_high - (uint)carry_flag;\n    is_negative_dividend = 0xffffffff;\n  }\n  else {\n    is_negative_dividend = 0;\n  }\n  if ((int)remainder < 0) {\n    is_negative_dividend = ~is_negative_dividend;\n    carry_flag = divisor_low != 0;\n    divisor_low = -divisor_low;\n    remainder = -remainder - (uint)carry_flag;\n  }\n  if (remainder == 0) {\n    if (divisor_high < divisor_low) {\n      shift_count = LZCOUNT(divisor_low);\n      if (shift_count != 0) {\n        result_low = dividend >> (0x20U - shift_count & 0xff);\n        divisor_low = divisor_low << shift_count;\n        dividend = dividend << shift_count;\n        divisor_high = divisor_high << shift_count | result_low;\n      }\n      result_high = divisor_low >> 0x10;\n      quotient_high = divisor_high / result_high;\n      temp_2 = (divisor_low & 0xffff) * quotient_high;\n      quotient = dividend >> 0x10 | (divisor_high - result_high * quotient_high) * 0x10000;\n      result_low = quotient_high;\n      if (quotient <= temp_2 && temp_2 - quotient != 0) {\n        carry_flag = CARRY4(quotient,divisor_low);\n        quotient = quotient + divisor_low;\n        result_low = quotient_high - 1;\n        if ((carry_flag == false) && (quotient <= temp_2 && temp_2 - quotient != 0)) {\n          result_low = quotient_high - 2;\n          quotient = quotient + divisor_low;\n        }\n      }\n      temp_3 = (quotient - temp_2) / result_high;\n      quotient_high = (divisor_low & 0xffff) * temp_3;\n      temp_2 = dividend & 0xffff | ((quotient - temp_2) - result_high * temp_3) * 0x10000;\n      result_high = temp_3;\n      if (temp_2 <= quotient_high && quotient_high - temp_2 != 0) {\n        result_high = temp_3 - 1;\n        if ((CARRY4(temp_2,divisor_low) == false) &&\n           (temp_2 + divisor_low <= quotient_high && quotient_high - (temp_2 + divisor_low) != 0)) {\n          result_high = temp_3 - 2;\n        }\n      }\n      result_high = result_high | result_low << 0x10;\n      result_low = 0;\n    }\n    else {\n      if (divisor_low == 0) {\n        divisor_low = 1 / 0;\n      }\n      shift_count = LZCOUNT(divisor_low);\n      if (shift_count == 0) {\n        divisor_high = divisor_high - divisor_low;\n        quotient_high = divisor_low >> 0x10;\n        temp_5 = divisor_low & 0xffff;\n        result_low = 1;\n      }\n      else {\n        divisor_low = divisor_low << shift_count;\n        result_low = divisor_high >> (0x20U - shift_count & 0xff);\n        quotient_high = divisor_low >> 0x10;\n        quotient = result_low / quotient_high;\n        temp_5 = divisor_low & 0xffff;\n        temp_2 = temp_5 * quotient;\n        temp_3 = dividend >> (0x20U - shift_count & 0xff) | divisor_high << shift_count;\n        result_low = temp_3 >> 0x10 | (result_low - quotient_high * quotient) * 0x10000;\n        dividend = dividend << shift_count;\n        result_high = quotient;\n        if (result_low <= temp_2 && temp_2 - result_low != 0) {\n          carry_flag = CARRY4(result_low,divisor_low);\n          result_low = result_low + divisor_low;\n          result_high = quotient - 1;\n          if ((carry_flag == false) && (result_low <= temp_2 && temp_2 - result_low != 0)) {\n            result_high = quotient - 2;\n            result_low = result_low + divisor_low;\n          }\n        }\n        quotient_low = (result_low - temp_2) / quotient_high;\n        quotient = temp_5 * quotient_low;\n        divisor_high = temp_3 & 0xffff | ((result_low - temp_2) - quotient_high * quotient_low) * 0x10000;\n        result_low = quotient_low;\n        if (divisor_high <= quotient && quotient - divisor_high != 0) {\n          carry_flag = CARRY4(divisor_high,divisor_low);\n          divisor_high = divisor_high + divisor_low;\n          result_low = quotient_low - 1;\n          if ((carry_flag == false) && (divisor_high <= quotient && quotient - divisor_high != 0)) {\n            result_low = quotient_low - 2;\n            divisor_high = divisor_high + divisor_low;\n          }\n        }\n        divisor_high = divisor_high - quotient;\n        result_low = result_low | result_high << 0x10;\n      }\n      result_high = divisor_high / quotient_high;\n      quotient = temp_5 * result_high;\n      temp_3 = dividend >> 0x10 | (divisor_high - quotient_high * result_high) * 0x10000;\n      temp_2 = result_high;\n      if (temp_3 <= quotient && quotient - temp_3 != 0) {\n        carry_flag = CARRY4(temp_3,divisor_low);\n        temp_3 = temp_3 + divisor_low;\n        temp_2 = result_high - 1;\n        if ((carry_flag == false) && (temp_3 <= quotient && quotient - temp_3 != 0)) {\n          temp_2 = result_high - 2;\n          temp_3 = temp_3 + divisor_low;\n        }\n      }\n      quotient_low = (temp_3 - quotient) / quotient_high;\n      temp_5 = temp_5 * quotient_low;\n      quotient_high = dividend & 0xffff | ((temp_3 - quotient) - quotient_high * quotient_low) * 0x10000;\n      result_high = quotient_low;\n      if (quotient_high <= temp_5 && temp_5 - quotient_high != 0) {\n        result_high = quotient_low - 1;\n        if ((CARRY4(quotient_high,divisor_low) == false) &&\n           (quotient_high + divisor_low <= temp_5 && temp_5 - (quotient_high + divisor_low) != 0)) {\n          result_high = quotient_low - 2;\n        }\n      }\n      result_high = result_high | temp_2 << 0x10;\n    }\n  }\n  else if (divisor_high < remainder) {\n    result_low = 0;\n    result_high = 0;\n  }\n  else {\n    shift_count = LZCOUNT(remainder);\n    if (shift_count == 0) {\n      if ((remainder < divisor_high) || (divisor_low <= dividend)) {\n        result_low = 0;\n        result_high = 1;\n      }\n      else {\n        result_high = 0;\n        result_low = 0;\n      }\n    }\n    else {\n      result_low = 0x20 - shift_count;\n      quotient_high = divisor_high >> (result_low & 0xff);\n      temp_5 = divisor_low >> (result_low & 0xff) | remainder << shift_count;\n      quotient = temp_5 >> 0x10;\n      result_high = quotient_high / quotient;\n      temp_3 = (temp_5 & 0xffff) * result_high;\n      temp_2 = divisor_high << shift_count | dividend >> (result_low & 0xff);\n      quotient_high = temp_2 >> 0x10 | (quotient_high - quotient * result_high) * 0x10000;\n      result_low = result_high;\n      if (quotient_high <= temp_3 && temp_3 - quotient_high != 0) {\n        carry_flag = CARRY4(quotient_high,temp_5);\n        quotient_high = quotient_high + temp_5;\n        result_low = result_high - 1;\n        if ((carry_flag == false) && (quotient_high <= temp_3 && temp_3 - quotient_high != 0)) {\n          result_low = result_high - 2;\n          quotient_high = quotient_high + temp_5;\n        }\n      }\n      quotient_low = (quotient_high - temp_3) / quotient;\n      temp_4 = (temp_5 & 0xffff) * quotient_low;\n      quotient_high = temp_2 & 0xffff | ((quotient_high - temp_3) - quotient * quotient_low) * 0x10000;\n      result_high = quotient_low;\n      if (quotient_high <= temp_4 && temp_4 - quotient_high != 0) {\n        carry_flag = CARRY4(quotient_high,temp_5);\n        quotient_high = quotient_high + temp_5;\n        result_high = quotient_low - 1;\n        if ((carry_flag == false) && (quotient_high <= temp_4 && temp_4 - quotient_high != 0)) {\n          result_high = quotient_low - 2;\n          quotient_high = quotient_high + temp_5;\n        }\n      }\n      result_high = result_high | result_low << 0x10;\n      temp = (ulonglong)result_high * (ulonglong)(divisor_low << shift_count);\n      temp_2 = (uint)((ulonglong)temp >> 0x20);\n      result_low = 0;\n      if ((quotient_high - temp_4 < temp_2) ||\n         ((quotient_high - temp_4 == temp_2 && (dividend << shift_count < (uint)temp)))) {\n        result_high = result_high - 1;\n        result_low = 0;\n      }\n    }\n  }\n  if (is_negative_dividend != 0) {\n    carry_flag = result_high != 0;\n    result_high = -result_high;\n    result_low = -result_low - (uint)carry_flag;\n  }\n  return CONCAT44(result_low,result_high);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "dividend_division_000845c0",
                "param_1": "dividend",
                "param_2": "divisor_high",
                "param_3": "divisor_low",
                "param_4": "remainder",
                "lVar1": "temp",
                "uVar2": "result_high",
                "uVar3": "result_low",
                "uVar4": "quotient_high",
                "uVar5": "quotient_low",
                "iVar6": "shift_count",
                "uVar7": "temp_2",
                "uVar8": "temp_3",
                "uVar9": "is_negative_dividend",
                "uVar10": "quotient",
                "uVar11": "temp_4",
                "uVar12": "temp_5",
                "bVar13": "carry_flag"
            },
            "calling": [
                "__gnu_ldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "divide_and_overflow_check_00084860",
            "code": "\nulonglong divideAndOverflowCheck_00084860(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong result;\n  uint q1;\n  uint q2;\n  uint q3;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int lzc;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      lzc = LZCOUNT(quotient);\n      if (lzc == 0) {\n        divisor = divisor - quotient;\n        q2 = quotient >> 0x10;\n        temp1 = quotient & 0xffff;\n        q1 = 1;\n      }\n      else {\n        quotient = quotient << lzc;\n        temp4 = divisor >> (0x20U - lzc & 0xff);\n        q2 = quotient >> 0x10;\n        temp5 = temp4 / q2;\n        temp1 = quotient & 0xffff;\n        q1 = temp1 * temp5;\n        temp2 = dividend >> (0x20U - lzc & 0xff) | divisor << lzc;\n        q3 = temp2 >> 0x10 | (temp4 - q2 * temp5) * 0x10000;\n        dividend = dividend << lzc;\n        temp4 = temp5;\n        if (q3 <= q1 && q1 - q3 != 0) {\n          carryFlag = CARRY4(q3,quotient);\n          q3 = q3 + quotient;\n          temp4 = temp5 - 1;\n          if ((carryFlag == false) && (q3 <= q1 && q1 - q3 != 0)) {\n            temp4 = temp5 - 2;\n            q3 = q3 + quotient;\n          }\n        }\n        temp3 = (q3 - q1) / q2;\n        temp5 = temp1 * temp3;\n        divisor = temp2 & 0xffff | ((q3 - q1) - q2 * temp3) * 0x10000;\n        q1 = temp3;\n        if (divisor <= temp5 && temp5 - divisor != 0) {\n          carryFlag = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          q1 = temp3 - 1;\n          if ((carryFlag == false) && (divisor <= temp5 && temp5 - divisor != 0)) {\n            q1 = temp3 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - temp5;\n        q1 = q1 | temp4 << 0x10;\n      }\n      temp5 = divisor / q2;\n      q3 = temp1 * temp5;\n      temp2 = dividend >> 0x10 | (divisor - q2 * temp5) * 0x10000;\n      temp4 = temp5;\n      if (temp2 <= q3 && q3 - temp2 != 0) {\n        carryFlag = CARRY4(temp2,quotient);\n        temp2 = temp2 + quotient;\n        temp4 = temp5 - 1;\n        if ((carryFlag == false) && (temp2 <= q3 && q3 - temp2 != 0)) {\n          temp4 = temp5 - 2;\n          temp2 = temp2 + quotient;\n        }\n      }\n      temp5 = (temp2 - q3) / q2;\n      temp1 = temp1 * temp5;\n      temp2 = dividend & 0xffff | ((temp2 - q3) - q2 * temp5) * 0x10000;\n      q2 = temp5;\n      if (temp2 <= temp1 && temp1 - temp2 != 0) {\n        q2 = temp5 - 1;\n        if ((CARRY4(temp2,quotient) == false) &&\n           (temp2 + quotient <= temp1 && temp1 - (temp2 + quotient) != 0)) {\n          q2 = temp5 - 2;\n        }\n      }\n      return CONCAT44(q1,q2 | temp4 << 0x10);\n    }\n    lzc = LZCOUNT(quotient);\n    if (lzc != 0) {\n      temp4 = dividend >> (0x20U - lzc & 0xff);\n      quotient = quotient << lzc;\n      dividend = dividend << lzc;\n      divisor = temp4 | divisor << lzc;\n    }\n    q1 = quotient >> 0x10;\n    q2 = divisor / q1;\n    temp1 = (quotient & 0xffff) * q2;\n    temp5 = dividend >> 0x10 | (divisor - q1 * q2) * 0x10000;\n    temp4 = q2;\n    if (temp5 <= temp1 && temp1 - temp5 != 0) {\n      carryFlag = CARRY4(temp5,quotient);\n      temp5 = temp5 + quotient;\n      temp4 = q2 - 1;\n      if ((carryFlag == false) && (temp5 <= temp1 && temp1 - temp5 != 0)) {\n        temp4 = q2 - 2;\n        temp5 = temp5 + quotient;\n      }\n    }\n    temp2 = (temp5 - temp1) / q1;\n    q2 = (quotient & 0xffff) * temp2;\n    temp1 = dividend & 0xffff | ((temp5 - temp1) - q1 * temp2) * 0x10000;\n    q1 = temp2;\n    if (temp1 <= q2 && q2 - temp1 != 0) {\n      q1 = temp2 - 1;\n      if ((CARRY4(temp1,quotient) == false) &&\n         (temp1 + quotient <= q2 && q2 - (temp1 + quotient) != 0)) {\n        q1 = temp2 - 2;\n      }\n    }\n    q1 = q1 | temp4 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    lzc = LZCOUNT(remainder);\n    if (lzc == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      q1 = 0;\n    }\n    else {\n      q1 = 0x20 - lzc;\n      temp4 = divisor >> (q1 & 0xff);\n      q2 = remainder << lzc | quotient >> (q1 & 0xff);\n      temp1 = q2 >> 0x10;\n      q3 = temp4 / temp1;\n      temp5 = (q2 & 0xffff) * q3;\n      temp2 = dividend >> (q1 & 0xff) | divisor << lzc;\n      q1 = temp2 >> 0x10 | (temp4 - temp1 * q3) * 0x10000;\n      temp4 = q3;\n      if (q1 <= temp5 && temp5 - q1 != 0) {\n        carryFlag = CARRY4(q1,q2);\n        q1 = q1 + q2;\n        temp4 = q3 - 1;\n        if ((carryFlag == false) && (q1 <= temp5 && temp5 - q1 != 0)) {\n          temp4 = q3 - 2;\n          q1 = q1 + q2;\n        }\n      }\n      q3 = (q1 - temp5) / temp1;\n      temp3 = (q2 & 0xffff) * q3;\n      temp1 = temp2 & 0xffff | ((q1 - temp5) - temp1 * q3) * 0x10000;\n      q1 = q3;\n      if (temp1 <= temp3 && temp3 - temp1 != 0) {\n        carryFlag = CARRY4(temp1,q2);\n        temp1 = temp1 + q2;\n        q1 = q3 - 1;\n        if ((carryFlag == false) && (temp1 <= temp3 && temp3 - temp1 != 0)) {\n          q1 = q3 - 2;\n          temp1 = temp1 + q2;\n        }\n      }\n      q1 = q1 | temp4 << 0x10;\n      result = (ulonglong)q1 * (ulonglong)(quotient << lzc);\n      temp4 = (uint)((ulonglong)result >> 0x20);\n      if ((temp1 - temp3 < temp4) || ((temp1 - temp3 == temp4 && (dividend << lzc < (uint)result)))\n         ) {\n        q1 = q1 - 1;\n      }\n    }\n  }\n  return (ulonglong)q1;\n}\n\n",
            "renaming": {
                "FUN_00084860": "divide_and_overflow_check_00084860",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "result",
                "uVar2": "q1",
                "uVar3": "q2",
                "uVar4": "q3",
                "uVar5": "temp1",
                "uVar6": "temp2",
                "uVar7": "temp3",
                "uVar8": "temp4",
                "uVar9": "temp5",
                "iVar10": "lzc",
                "bVar11": "carryFlag"
            },
            "calling": [
                "__gnu_uldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00085860": {
            "entrypoint": "0x00085860",
            "current_name": "FUNC_00085860",
            "code": "\nvoid FUNC_00085860(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085860": "FUNC_00085860"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_20070000": {
            "entrypoint": "0x20070000",
            "current_name": "disable_irq_interrupts_20070000",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_irq_interrupts_20070000(void)\n\n{\n  disableIRQinterrupts();\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) = DAT_20070020;\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *DAT_20070028 = DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_20070000": "disable_irq_interrupts_20070000"
            },
            "calling": [
                "tickReset",
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 114446,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080148",
            "FUN_0008014c",
            "FUN_00080164",
            "FUN_00080184",
            "FUN_000801e0",
            "FUN_00080250",
            "FUN_000803fc",
            "FUN_0008044c",
            "FUN_00080558",
            "FUN_00080568",
            "FUN_00080578",
            "FUN_00080588",
            "FUN_00080598",
            "FUN_000805a8",
            "FUN_000805e8",
            "FUN_000806a0",
            "FUN_000806ac",
            "FUN_000806f8",
            "FUN_0008073c",
            "FUN_00080750",
            "FUN_0008075c",
            "FUN_00080768",
            "FUN_00080774",
            "FUN_0008089c",
            "FUN_00080970",
            "FUN_000809b4",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a30",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080aec",
            "FUN_00080b2c",
            "FUN_00080b64",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c20",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080d70",
            "FUN_00080d80",
            "FUN_00080db8",
            "FUN_00080df0",
            "FUN_00080e28",
            "FUN_00080e60",
            "FUN_00080e62",
            "FUN_00080e66",
            "FUN_00080e6a",
            "FUN_00080e80",
            "FUN_00080e84",
            "FUN_00080e88",
            "FUN_00080ea4",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080eec",
            "FUN_00080efe",
            "FUN_00080f04",
            "FUN_00080f0c",
            "FUN_00081014",
            "FUN_00081084",
            "FUN_000810a6",
            "FUN_000810c4",
            "FUN_000810cc",
            "FUN_000810d8",
            "FUN_000810e8",
            "FUN_000810fc",
            "FUN_0008113a",
            "FUN_00081176",
            "FUN_0008117a",
            "FUN_00081190",
            "FUN_000811b0",
            "FUN_000811ca",
            "FUN_000811e8",
            "FUN_00081214",
            "FUN_00081244",
            "FUN_00081248",
            "FUN_0008125a",
            "FUN_00081276",
            "FUN_000812a0",
            "FUN_000812b8",
            "FUN_0008130c",
            "FUN_00081348",
            "FUN_0008136c",
            "FUN_000813dc",
            "FUN_000813e4",
            "FUN_0008142e",
            "FUN_00081438",
            "FUN_0008145c",
            "FUN_00081472",
            "FUN_00081480",
            "FUN_00081496",
            "FUN_000814ae",
            "FUN_000814d0",
            "FUN_000814f6",
            "FUN_0008151c",
            "FUN_00081560",
            "FUN_00081570",
            "FUN_0008159e",
            "FUN_000815b8",
            "FUN_000815de",
            "FUN_000815ec",
            "FUN_00081618",
            "FUN_00081624",
            "FUN_00081684",
            "FUN_000816c8",
            "FUN_000816d8",
            "FUN_000816e4",
            "FUN_000816ec",
            "FUN_000816f8",
            "FUN_00081734",
            "FUN_0008173c",
            "FUN_00081750",
            "FUN_00081778",
            "FUN_000817c8",
            "FUN_000817f0",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00081f9c",
            "FUN_00081fac",
            "FUN_0008236c",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_000826e8",
            "FUN_000827fc",
            "FUN_00082814",
            "FUN_00082824",
            "FUN_0008289c",
            "FUN_000834f0",
            "FUN_0008356c",
            "FUN_00083630",
            "FUN_000836ec",
            "FUN_000836fc",
            "FUN_00083708",
            "FUN_00083850",
            "FUN_0008387c",
            "FUN_00083888",
            "FUN_00083984",
            "FUN_000839b4",
            "FUN_00083a74",
            "FUN_00083b10",
            "FUN_00083ca8",
            "FUN_00083fbc",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_00084018",
            "FUN_000840f8",
            "FUN_0008418c",
            "FUN_000841e4",
            "FUN_000841f4",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_0008429c",
            "FUN_000842a4",
            "FUN_0008434c",
            "FUN_0008439c",
            "FUN_000843b8",
            "FUN_000843e0",
            "FUN_00084404",
            "FUN_00084484",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_00084530",
            "FUN_0008455c",
            "FUN_0008458c",
            "FUN_000845c0",
            "FUN_00084860",
            "FUN_20070000"
        ]
    ],
    "locked_functions": []
}