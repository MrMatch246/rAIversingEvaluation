{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_flags_and_initialize_data_000026c0",
                "clear_flags_00002910": "clear_flags",
                "PTR_DAT_000026d4": "data_pointer"
            },
            "code": "void clear_flags_and_initialize_data_000026c0(void)\n{\n  clear_flags();\n  *(undefined4 *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clear_flags_and_initialize_data_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "out_size",
                "param_2": "size_to_allocate",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "current_ptr",
                "uVar2": "return_value",
                "puVar3": "previous_ptr",
                "iVar4": "new_block_size",
                "uVar5": "remaining_size",
                "puVar6": "current_ptr",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_00004bd0(uint *out_size, uint size_to_allocate, uint arg3, uint arg4)\n{\n  uint *current_ptr;\n  uint aligned_size;\n  uint remaining_size;\n  uint *previous_ptr;\n  uint new_block_size;\n  uint return_value;\n  \n  aligned_size = (size_to_allocate + 3) & 0xFFFFFFFC;\n  aligned_size += 8;\n  if (aligned_size < 12) {\n    aligned_size = 12;\n  }\n  if (aligned_size < 0 || aligned_size < size_to_allocate) {\n    *out_size = 12;\n  }\n  else {\n    do_nothing_with_pointer_00005790();\n    current_ptr = *(uint **)PTR_DAT_00004c7c;\n    previous_ptr = *(uint **)PTR_DAT_00004c7c;\n    while (current_ptr != NULL) {\n      remaining_size = *current_ptr - aligned_size;\n      if (remaining_size >= 0 && remaining_size <= 11) {\n        new_block_size = current_ptr[1];\n        if (current_ptr == previous_ptr) {\n          *(uint **)PTR_DAT_00004c7c = (uint *)(current_ptr[1]);\n        }\n        else {\n          previous_ptr[1] = current_ptr[1];\n        }\n        do_nothing_with_pointer_0000579c(out_size);\n        return_value = (uint)current_ptr + 11;\n        if (remaining_size != 0) {\n          *(uint *)((int)current_ptr + new_block_size + 4) = remaining_size;\n        }\n        return return_value;\n      }\n      previous_ptr = current_ptr;\n      current_ptr = (uint *)current_ptr[1];\n    }\n    if (*(int *)PTR_DAT_00004c80 == 0) {\n      return_value = get_local_value_00000428(out_size, 0, previous_ptr, 0, arg4);\n      *(uint *)PTR_DAT_00004c80 = return_value;\n    }\n    current_ptr = (uint *)get_local_value_00000428(out_size, aligned_size);\n    if (current_ptr != (uint *)0xFFFFFFFF) {\n      if (current_ptr == (uint *)((int)current_ptr + 3 & 0xFFFFFFFC))) {\n        do_nothing_with_pointer_0000579c(out_size);\n        return_value = (uint)current_ptr + 11;\n        if (aligned_size != 0) {\n          *(uint *)((int)current_ptr + aligned_size + 4) = 0;\n        }\n        return return_value;\n      }\n      else {\n        new_block_size = get_local_value_00000428(out_size, (int)((uint *)((int)current_ptr + 3 & 0xFFFFFFFC)) - (int)current_ptr);\n        if (new_block_size != -1) {\n          do_nothing_with_pointer_0000579c(out_size);\n          return_value = (uint)current_ptr + 11;\n          *(uint *)((int)current_ptr + aligned_size + 4) = (int)((uint *)((int)current_ptr + 3 & 0xFFFFFFFC)) - (int)current_ptr - 4;\n          return return_value;\n        }\n      }\n    }\n    *out_size = 12;\n    do_nothing_with_pointer_0000579c(out_size);\n  }\n  return 0;\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790",
                "FUN_00000428"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005700",
                "FUN_00004248",
                "FUN_00005100",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "update_linked_list_and_wait_00000794",
                "extraout_r1": "extraout_return",
                "iVar1": "list_offset",
                "puVar2": "aligned_list_pointer",
                "uVar3": "aligned_pointer",
                "iStack_1c": "i",
                "iStack_18": "i",
                "piStack_14": "result_pointer"
            },
            "code": "int update_linked_list_and_wait_00000794(void)\n{\n  int extraout_return;\n  int list_offset;\n  int list_length;\n  int *list_pointer;\n  uint32_t aligned_pointer;\n  uint32_t *aligned_list_pointer;\n  uint32_t *last_element_pointer;\n  int i;\n  int *result_pointer;\n  is_irq_interrupts_enabled();\n  *(uint32_t *)(0x7d0 + *psRam000007cc * 4) = 0;\n  *piRam000007d4 = *piRam000007d4 - 1;\n  update_linked_list_00000698(*puRam000007d8, 0);\n  list_pointer = puRam000007d8;\n  list_offset = 0;\n  *puRam000007d8 = 0;\n  run_software_interrupt_and_wait();\n  aligned_pointer = ((uint32_t)list_pointer + list_offset) & 0xfffffffc;\n  aligned_list_pointer = (uint32_t *)(aligned_pointer - 4);\n  *aligned_list_pointer = 0x77777777;\n  if (((uint)aligned_list_pointer & 7) != 0) {\n    aligned_list_pointer = (uint32_t *)(aligned_pointer - 8);\n    *aligned_list_pointer = 0x88888888;\n  }\n  last_element_pointer = aligned_list_pointer - 1;\n  *last_element_pointer = 0x1000000;\n  *(last_element_pointer - 1) = list_offset << 0xd;\n  *(last_element_pointer - 2) = DAT_000008b4;\n  result_pointer = last_element_pointer - 3;\n  *result_pointer = 0;\n  for (i = 3; i > 0; i--) {\n    result_pointer--;\n    *result_pointer = i;\n  }\n  result_pointer--;\n  *result_pointer = extraout_return;\n  for (i = 0xb; i > 3; i--) {\n    result_pointer--;\n    *result_pointer = i;\n  }\n  result_pointer--;\n  *result_pointer = -3;\n  return result_pointer;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "update_linked_list_and_wait_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "input",
                "param_2": "data",
                "param_3": "buffer",
                "param_4": "result",
                "puVar1": "ptr_data_65_68",
                "iVar2": "process_result",
                "iVar7": "total_processed_bytes",
                "ppbVar4": "next_buffer_ptr",
                "pbVar5": "remaining_bytes_ptr",
                "pbVar6": "current_byte",
                "unaff_r6": "current_byte",
                "uVar3": "temp_var",
                "*puVar1": "*ptr_data_65_68",
                "**param_3": "**buffer",
                "*(char *)(param_2[5] + (uint)**param_3)": "*(char *)(data[5] + (uint)**buffer)",
                "*unaff_r6": "*current_byte",
                "param_3[1]": "remaining_bytes_ptr",
                "*param_4": "*result",
                "param_2[2]": "remaining_bytes",
                "param_2[6]": "processing_mode",
                "param_2[5]": "data_offset",
                "*param_3": "*buffer",
                "param_2[3]": "bytes_processed",
                "param_2[4]": "total_bytes_processed",
                "*param_2": "*data",
                "PTR_DAT_00006568": "ptr_data_65_68",
                "int": "int",
                "uint": "uint",
                "undefined": "undefined",
                "byte": "byte",
                "if": "if",
                "else": "else",
                "return": "return",
                "while": "while",
                "do": "do",
                "true": "true",
                "NULL": "NULL",
                "0": "0",
                "1": "1",
                "0xffffffff": "0xffffffff",
                "&": "&",
                "<<": "<<",
                "(": "(",
                ")": ")",
                "++": "++",
                "+": "+",
                "-1": "-1",
                "<": "<",
                "&&": "&&",
                "!=": "!=",
                "*": "*",
                "=": "=",
                "current_byte_processed": "current_byte_processed",
                "output_byte": "output_byte",
                "total_processed_bytes": "total_processed_bytes",
                "current_byte_ptr": "current_byte_ptr",
                "remaining_bytes_ptr": "remaining_bytes_ptr",
                "next_buffer_ptr": "next_buffer_ptr",
                "data_ptr": "data_ptr",
                "buffer_ptr": "buffer_ptr",
                "remaining_bytes": "remaining_bytes",
                "processing_mode": "processing_mode",
                "data_offset": "data_offset",
                "bytes_processed": "bytes_processed",
                "total_bytes_processed": "total_bytes_processed",
                "temp_var": "temp_var"
            },
            "code": "int process_data_000064bc(int input, uint *data, byte **buffer, int *result)\\n{\\n  uint *data_ptr = data;\\n  byte **buffer_ptr = buffer;\\n  byte *current_byte = *buffer_ptr;\\n  byte *output_byte = NULL;\\n  int total_processed_bytes = 0;\\n  int current_byte_processed = 0;\\n\\n  if (data_ptr[2] == 0) {\\n    if (data_ptr[6] == 0) {\\n      data_ptr[2] = 1;\\n    }\\n    else {\\n      data_ptr[2] = 0xffffffff;\\n    }\\n  }\\n\\n  if (-1 < (int)(*data_ptr << 0x1b)) {\\n    byte **next_buffer_ptr = (byte **)*result;\\n    *result = next_buffer_ptr + 1;\\n    output_byte = *next_buffer_ptr;\\n  }\\n\\n  while (true) {\\n    uint remaining_bytes = data_ptr[2];\\n    if (remaining_bytes == 0 || (int)(*buffer_ptr[1] + -1) < 1) {\\n      if (current_byte_processed == 0) {\\n        return 1;\\n      }\\n      if (((*data_ptr & 0x10) == 0) && (data_ptr[3] = data_ptr[3] + 1, data_ptr[6] != 0)) {\\n        *output_byte = 0;\\n      }\\n      data_ptr[4] = current_byte_processed + data_ptr[4];\\n      return 0;\\n    }\\n\\n    if (remaining_bytes != 0 && (data_ptr[6] == 1 && *(char *)(data_ptr[5] + (uint)**buffer_ptr) == \"\\0\")) {\\n      if (current_byte_processed == 0) {\\n        return 1;\\n      }\\n      if (((*data_ptr & 0x10) == 0) && (data_ptr[3] = data_ptr[3] + 1, data_ptr[6] != 0)) {\\n        *output_byte = 0;\\n      }\\n      data_ptr[4] = current_byte_processed + data_ptr[4];\\n      return 0;\\n    }\\n\\n    if (remaining_bytes != 0 && (data_ptr[6] == 2 && ((int)((uint)(byte *)data_ptr[0x65] + **buffer_ptr) << 0x1c) < 0)) {\\n      if (current_byte_processed == 0) {\\n        return 1;\\n      }\\n      if (((*data_ptr & 0x10) == 0) && (data_ptr[3] = data_ptr[3] + 1, data_ptr[6] != 0)) {\\n        *output_byte = 0;\\n      }\\n      data_ptr[4] = current_byte_processed + data_ptr[4];\\n      return 0;\\n    }\\n\\n    if (-1 < (int)(*data_ptr << 0x1b)) {\\n      output_byte = output_byte + 1;\\n      *output_byte = **buffer_ptr;\\n    }\\n    current_byte = *buffer_ptr;\\n    *buffer_ptr = *buffer_ptr + 1;\\n    *buffer_ptr[1] = *buffer_ptr[1] + -1;\\n    current_byte_processed = current_byte_processed + 1;\\n    data_ptr[2] = remaining_bytes - 1;\\n  }\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "set_flag_in_data_section_00002970",
                "DAT_00002990": "data_section",
                "PTR_": "ptr_"
            },
            "code": "void set_flag_in_data_section_00002970(void)\n{\n    uint32_t *flag_ptr = (uint32_t *)(DAT_00002990 + 0x14);\n    *flag_ptr &= ~0x10;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "set_flag_in_data_section_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "process_interrupt_status_and_get_00000dc0",
                "process_and_get_interrupt_status_00000cc0": "process_and_get_interrupt_status"
            },
            "code": "void process_interrupt_status_and_get_00000dc0(void)\n{\n  process_and_get_interrupt_status_00000cc0();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "process_interrupt_status_and_get_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_IRQ_interrupts_if_privileged_00000d0c",
                "param_1": "privilege_level",
                "bVar1": "is_privileged_mode"
            },
            "code": "void enable_IRQ_interrupts_if_privileged_00000d0c(uint privilege_level) {\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    enableIRQinterrupts((privilege_level & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "enable_IRQ_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "<original_function_name>": "FUN_00003d94",
                "param_1": "input_parameter",
                "param_2": "second_parameter",
                "uVar1": "error_code",
                "FUN_00003d94": "error_code_on_failure_00003d94"
            },
            "code": "int error_code_on_failure_00003d94(int input_parameter, int second_parameter){\n                      int error_code;\n                      if (input_parameter == 0) {\n                        error_code = -19;\n                      }\n                      else {\n                        error_code = (**(code **)(*(int *)(input_parameter + 0xc) + 4))(*(int *)(input_parameter + 4),second_parameter);\n                      }\n                      return error_code;\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "error_code_on_failure_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_pointer_0000579c",
                "PTR_DAT_000057a4": "PTR_DATA",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "offset",
                "param_2": "source_address",
                "param_3": "size",
                "iVar1": "destination_address",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int offset, int source_address, uint32_t size)\n{\n  int destination_address = *(int *)(PTR_DAT_00001624 + offset * 0x20);\n  for (uint32_t i = 0; i < size; i++) {\n    do {\n    } while (*(char *)(destination_address + 4) >= 0);\n    *(undefined *)(destination_address + 7) = *(undefined *)(i + source_address);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "param_1": "data",
                "param_2": "data_size",
                "param_3": "start_index",
                "param_4": "end_index",
                "local_80": "buffer_start",
                "local_7c": "null_terminator_index",
                "local_74": "buffer_size",
                "local_72": "buffer_size_minus_one",
                "local_70": "current_data",
                "local_6c": "buffer_end",
                "local_5c": "null_terminator",
                "local_4c": "zero",
                "local_38": "unused",
                "uStack_8": "data_size",
                "uStack_4": "end_index"
            },
            "code": "void process_data_00005e68(undefined4 data, undefined4 data_size, undefined4 start_index, undefined4 end_index)\n{\n  undefined4 current_index;\n  undefined4 null_terminator_index;\n  undefined2 buffer_size = 0x204;\n  undefined2 buffer_size_minus_one = 0xffff;\n  undefined4 buffer_start = data;\n  undefined4 buffer_end = data + data_size - 1;\n  undefined4 current_data;\n  undefined *null_terminator = find_null_terminator_00005ecc();\n  undefined4 zero = 0;\n  undefined4 unused = 0;\n  null_terminator_index = null_terminator - data;\n  current_index = start_index;\n  current_data = buffer_start + current_index;\n  FUNC_000061cc(*DAT_00005eb8, &current_data, data_size, &end_index);\n  return;\n}\n",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_00000dcc",
                "DAT_00000df0": "data_ptr"
            },
            "code": "void set_data_00000dcc(void)\n{\n    int* DAT_00000df0 = DAT_00000df0;\n    *(DAT_00000df0 + 7) = 0xc520;\n    *(DAT_00000df0 + 8) = 0xd928;\n    *DAT_00000df0 = 0xd2;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_data_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_store_value_in_array_0000285c",
                "param_1": "value",
                "puVar1": "data_array_pointer",
                "DAT_00002890": "ARRAY_START_POINTER"
            },
            "code": "void set_flag_and_store_value_in_array_0000285c(int32_t value) {\n  int32_t *data_array_pointer;\n  data_array_pointer = DAT_00002890;\n  data_array_pointer[5] &= 0xffffffef;\n  *data_array_pointer = value;\n  data_array_pointer[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "set_flag_and_store_value_in_array_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "wait_for_interrupt_00000e58",
                "is_irq_interrupts_enabled_00000cd0": "is_irq_interrupts_enabled",
                "interrupts_enabled_00000cc8": "interrupts_enabled"
            },
            "code": "void wait_for_interrupt_00000e58(void)\n{\n  bool interrupts_enabled = is_irq_interrupts_enabled();\n  while(interrupts_enabled)\n  {\n    // Do nothing and wait for interrupt\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "wait_for_interrupt_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_memory_flag_00001778",
                "DAT_000017d0": "data_offset",
                "DAT_000017d8": "memory_offset",
                "clear_memory_at_offset_00001710": "clear_memory"
            },
            "code": "void set_memory_flag_00001778(void)\n{\n  byte* data_ptr = (byte*)(DAT_000017d0 + 1);\n  *data_ptr = (*data_ptr & 0xcf) | 0x20;\n  clear_memory(DAT_000017d8, 2);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_memory_flag_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "set_flag_and_return_000026d8",
                "set_flag_on_0000294c": "set_flag_on"
            },
            "code": "void set_flag_and_return_000026d8(void)\n{\n  set_flag_on_0000294c();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_flag_and_return_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "reverse_engineer_and_improve_00000566",
                "param_1": "input",
                "uVar5": "leading_zero_count",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "count_leading_zeroes": "count_leading_zeroes_of_4_bytes",
                "undefined4": "uint32_t",
                "byte": "uint8_t",
                "uint": "uint32_t"
            },
            "code": "uint32_t reverse_engineer_and_improve_00000566(uint32_t num) {\n  uint32_t bit_mask = 0x80000000;\n  uint8_t bit_count = 0;\n  for (int i = 0; i < 32; i++) {\n    if ((num & bit_mask) == 0) {\n      bit_count++;\n    } else {\n      break;\n    }\n    bit_mask >>= 1;\n  }\n  return bit_count;\n}\n\nuint32_t count_leading_zeroes_of_4_bytes(uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4) {\n  uint32_t num = (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;\n  return reverse_engineer_and_improve_00000566(num);\n}\n\nuint32_t reverse_engineer_and_improve_00000566(uint32_t input) {\n  uint8_t byte1 = (uint8_t) input;\n  uint8_t byte2 = (uint8_t) (input >> 8);\n  uint8_t byte3 = (uint8_t) (input >> 16);\n  uint8_t byte4 = (uint8_t) (input >> 24);\n  uint32_t leading_zero_count = count_leading_zeroes_of_4_bytes(byte1, byte2, byte3, byte4);\n  if (input == 0) {\n    leading_zero_count = 32;\n  }\n  return leading_zero_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "reverse_engineer_and_improve_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08",
                "param_1": "address",
                "param_2": "offset"
            },
            "code": "int calculate_offset_00001d08(uint32_t address, int offset) {\n    uint32_t upper_bits = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int final_offset = (offset * 4) + upper_bits + shifted_lower_bits + 0x2000000;\n    return final_offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_result_000031fc",
                "param_1": "input_val",
                "param_2": "num",
                "param_3": "sum",
                "bVar1": "byte_val",
                "iVar2": "num_copy",
                "input_copy": "input_copy",
                "temp": "temp"
            },
            "code": "int calculate_result_000031fc(int input_val, int num, int sum) {\n    int num_copy = num;\n    if (num < 3) {\n        num_copy = 1;\n    }\n    byte byte_val = (byte)num_copy;\n    if (num > 2) {\n        byte_val = 0;\n    }\n    input_val -= (uint)byte_val;\n    int input_copy = input_val;\n    if (input_val < 0) {\n        input_copy = input_val + 3;\n    }\n    int temp = (((input_copy >> 2) + input_val) - (int)((longlong)DAT_00003280 * (longlong)input_val >> 0x25)) + (int)((longlong)DAT_00003280 * (longlong)input_val >> 0x27) + *(int *)(DAT_00003284 + (num + -1) * 4) + sum;\n    return temp + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)temp) >> 0x20) + temp >> 2) - (temp >> 0x1f)) * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_result_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_offset_to_one_000016ec",
                "param_1": "base_address",
                "param_2": "offset_value",
                "puVar1": "offset_pointer",
                "*puVar1": "*offset_pointer",
                "calculate_offset_00001696": "calculate_offset"
            },
            "code": "void set_offset_to_one_000016ec(int base_address, char offset_value) {\n  char *offset_pointer = (char *)calculate_offset(base_address, offset_value);\n  *offset_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_00001a18",
                "FUN_00001778",
                "FUN_00001a3c",
                "FUN_0000182c",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "set_offset_to_one_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "FUNC_00005100"
            },
            "code": "\nvoid FUNC_00005100(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  int iVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  char cVar9;\n  char *pcVar10;\n  bool bVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort *puVar14;\n  int *piVar15;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  uVar4 = *DAT_00005108;\n  iVar5 = get_data_value_000056b0();\n  puVar1 = PTR_DAT_000053d8;\n  pcVar6 = (char *)find_key_value_pair_000056a0(uVar4,PTR_DAT_000053d4);\n  puVar2 = PTR_DAT_000053e0;\n  if (pcVar6 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    puVar3 = DAT_000053e8;\n    uVar4 = *(undefined4 *)puVar1;\n    *DAT_000053e8 = puVar2;\n    puVar3[1] = puVar2;\n    update_list_with_param_00005780(uVar4);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(int *)puVar1 == 0) || (iVar7 = compare_bytes_00004e52(), iVar7 != 0)) {\n    update_list_with_param_00005780(*(undefined4 *)puVar1);\n    iVar7 = find_null_terminator_00005ecc(pcVar6);\n    iVar7 = allocate_memory_00004bd0(uVar4,iVar7 + 1);\n    *(int *)puVar1 = iVar7;\n    if (iVar7 != 0) {\n      copy_string_00005ebc(iVar7,pcVar6);\n    }\n    if (*pcVar6 == ':') {\n      pcVar6 = pcVar6 + 1;\n    }\n    iVar7 = process_data_00005e68(pcVar6,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&local_30);\n    if (0 < iVar7) {\n      pcVar10 = pcVar6 + local_30;\n      if (pcVar6[local_30] == '-') {\n        pcVar10 = pcVar10 + 1;\n        iVar7 = -1;\n      }\n      else {\n        if (pcVar6[local_30] == '+') {\n          pcVar10 = pcVar10 + 1;\n        }\n        iVar7 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar12 = &local_3a;\n      piVar13 = &local_30;\n      puVar14 = &local_38;\n      piVar15 = &local_30;\n      iVar8 = process_data_00005e68(pcVar10,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                           &local_30,&local_38,&local_30);\n      puVar1 = PTR_DAT_00005400;\n      if (0 < iVar8) {\n        *(uint *)(iVar5 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n        puVar3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        pcVar10 = pcVar10 + local_30;\n        iVar7 = process_data_00005e68(pcVar10,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar12,piVar13,\n                             puVar14,piVar15);\n        if (iVar7 < 1) {\n          puVar3[1] = *puVar3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(iVar5 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          puVar3[1] = puVar1;\n          pcVar6 = pcVar10 + local_30;\n          if (pcVar10[local_30] == '-') {\n            pcVar6 = pcVar6 + 1;\n            iVar7 = -1;\n          }\n          else {\n            if (pcVar10[local_30] == '+') {\n              pcVar6 = pcVar6 + 1;\n            }\n            iVar7 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar8 = process_data_00005e68(pcVar6,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a\n                               ,&local_30,&local_38,&local_30);\n          if (iVar8 < 1) {\n            iVar7 = *(int *)(iVar5 + 0x28) + -0xe10;\n          }\n          else {\n            iVar7 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n          }\n          *(int *)(iVar5 + 0x50) = iVar7;\n          pcVar6 = pcVar6 + local_30;\n          bVar11 = false;\n          iVar7 = iVar5;\n          while( true ) {\n            if (*pcVar6 == ',') {\n              pcVar6 = pcVar6 + 1;\n            }\n            cVar9 = *pcVar6;\n            if (cVar9 == 'M') {\n              iVar8 = process_data_00005e68(pcVar6,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,\n                                   &local_34,&local_30,&local_32,&local_30);\n              if (iVar8 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar7 + 0xc) = (uint)local_36;\n              *(uint *)(iVar7 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar7 + 8) = 0x4d;\n              *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              pcVar10 = pcVar6 + local_30;\n            }\n            else {\n              if (cVar9 == 'J') {\n                pcVar6 = pcVar6 + 1;\n              }\n              else {\n                cVar9 = 'D';\n              }\n              local_32 = parse_integer_wrapper_00005fd8(pcVar6,local_2c,10);\n              pcVar10 = local_2c[0];\n              if (local_2c[0] == pcVar6) {\n                if (bVar11) {\n                  *(undefined *)(iVar5 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar5 + 0x38) = 1;\n                  *(undefined4 *)(iVar5 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar5 + 8) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0xc) = 3;\n                  *(undefined4 *)(iVar5 + 0x10) = 2;\n                  *(undefined4 *)(iVar5 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar7 + 8) = cVar9;\n                *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar10 == '/') {\n              process_data_00005e68(pcVar10,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,\n                           &local_38,&local_30);\n            }\n            *(uint *)(iVar7 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar7 = iVar7 + 0x28;\n            pcVar6 = pcVar10 + local_30;\n            if (bVar11) break;\n            bVar11 = true;\n          }\n          calculate_date_00004f98(*(undefined4 *)(iVar5 + 4));\n          iVar7 = *(int *)(iVar5 + 0x28);\n          *(int *)PTR_DAT_000053dc = iVar7;\n          iVar7 = *(int *)(iVar5 + 0x50) - iVar7;\n          if (iVar7 != 0) {\n            iVar7 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = iVar7;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005ecc",
                "FUN_00005e68",
                "FUN_00005ebc",
                "FUN_00004e52",
                "FUN_000056a0",
                "FUN_00005780",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_00004bd0",
                "FUN_00005fd8"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "calculate_quotient_and_remainder_00005584",
                "param_1": "result_array",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void calculate_quotient_and_remainder_00005584(uint *result_array, uint dividend, uint divisor)\n{\n  uint quotient = dividend / divisor;\n  uint remainder = dividend % divisor;\n  if ((int)dividend < 0) {\n    if (0 < (int)remainder) {\n      quotient--;\n      remainder += divisor;\n    }\n  }\n  else if ((int)remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  *result_array = quotient;\n  result_array[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "calculate_quotient_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_memory_00004248",
                "param_1": "memory_address",
                "param_2": "num_elements",
                "puVar1": "allocated_memory",
                "iVar2": "total_size"
            },
            "code": "undefined4* allocate_and_initialize_memory_00004248(undefined4 memory_address, int num_elements)\n{\n  int total_size = (num_elements - 1) * 0x68;\n  undefined4* allocated_memory = (undefined4*) allocate_memory_00004bd0(memory_address, total_size + 0x74);\n  if (allocated_memory != (undefined4*)0x0) {\n    *allocated_memory = 0;\n    allocated_memory[1] = num_elements;\n    allocated_memory[2] = allocated_memory + 3;\n    fill_memory_with_value_00004622(allocated_memory + 3, 0, total_size + 0x68);\n  }\n  return allocated_memory;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "extract_bits_from_right_00001da2",
                "param_1": "input_value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "ushort extract_bits_from_right_00001da2(ushort input_value) {\n    ushort shifted_value = input_value >> 6;\n    ushort extracted_bits = shifted_value & 7;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "extract_bits_from_right_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "update_data_with_bits_00001ec4",
                "param_1": "data",
                "param_2": "index",
                "uVar1": "extracted_bits",
                "extract_bits_from_uint_00001e0c": "extract_bits_from_uint",
                "update_data_at_index_00001e44": "update_data_at_index"
            },
            "code": "void update_data_with_bits_00001ec4(uint32_t data, uint32_t index) {\n  uint32_t extracted_bits = extract_bits_from_uint(data, index);\n  update_data_at_index(data, index, extracted_bits);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "update_data_with_bits_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_byte_00002744",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002790": "data_array_ptr",
                "DAT_00002794": "data_array_ptr_2"
            },
            "code": "void set_byte_00002744(byte data, uint value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002790 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002794 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_byte_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "process_date_00002624",
                "param_1": "date",
                "local_10": "first_different_value",
                "uStack_c": "result",
                "find_first_different_value_in_array_0000281c": "find_first_different_value_in_array",
                "calculate_date_0000443c": "calculate_date"
            },
            "code": "int process_date_00002624();\n\nint process_date_00002624(int param_1)\n{\n  int first_different_value = process_date_00002624();\n  int result = 0;\n  calculate_date(&first_different_value, param_1);\n  return result;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "process_date_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "extract_bits_from_uint_00001e0c",
                "param_1": "offset",
                "param_2": "data",
                "*PTR_DAT_00001e40": "ptr",
                "shifted_data": "shifted_data",
                "extracted_bits": "extracted_bits"
            },
            "code": "uint extract_bits_from_uint_00001e0c(int offset, uint data) {\n    uint* *PTR_DAT_00001e40 = (uint*)(PTR_DAT_00001e40 + (((int)data >> 3) + offset * 4) * 4);\n    uint shifted_data = (data & 7) << 2;\n    uint extracted_bits = **PTR_DAT_00001e40 >> shifted_data & 0xf;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "extract_bits_from_uint_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0_000041d0",
                "param_1": "input",
                "iVar2": "data_address",
                "piVar5": "next_data_address",
                "uVar7": "result",
                "puVar9": "pointer_to_data",
                "iVar8": "inner_data_length",
                "iVar6": "inner_data_address",
                "uVar3": "process_result"
            },
            "code": "uint process_data_000041d0_000041d0(int input, undefined4 param_2, undefined4 param_3)\n{\n  code *function_pointer = DAT_000041ec;\n  if (input == 0) {\n    int data_address = *(int *)PTR_DAT_000041e8;\n    int *next_data_address = (int *)(data_address + 0x48);\n    uint result = 0;\n    undefined *pointer_to_data = PTR_DAT_000041e8;\n    do {\n      int inner_data_address = next_data_address[1];\n      int inner_data_length = next_data_address[2];\n      while (inner_data_length = inner_data_length + -1, -1 < inner_data_length) {\n        if ((1 < *(ushort *)(inner_data_address + 0xc)) && (iVar4 = *(short *)(inner_data_address + 0xe) + 1, iVar4 != 0)) {\n          uint process_result = (*function_pointer)(data_address,inner_data_address,param_3,iVar4,pointer_to_data);\n          result = result | process_result;\n        }\n        inner_data_address = inner_data_address + 0x68;\n      }\n      next_data_address = (int *)*next_data_address;\n    } while (next_data_address != (int *)0x0);\n    return result;\n  }\n  uint process_result = process_data_00004158(*DAT_000041f0,input);\n  return process_result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "process_linked_list_and_increment_value_0000459c",
                "puVar1": "start_ptr",
                "puVar2": "end_ptr",
                "iVar3": "num_functions",
                "ppcVar4": "function_ptrs",
                "iVar5": "i"
            },
            "code": "void process_linked_list_and_increment_value_0000459c() {\n  undefined *start_ptr = PTR_DAT_000045d4;\n  undefined *end_ptr = PTR_DAT_000045e0;\n  int num_functions = (int)end_ptr - (int)start_ptr;\n  code **function_ptrs = (code **)start_ptr;\n  for (int i = 0; i < num_functions >> 2; i++) {\n    (**function_ptrs)();\n    function_ptrs++;\n  }\n  process_linked_list_and_increment_value_0000459c_00000410();\n  function_ptrs = (code **)PTR_DAT_000045dc;\n  num_functions = (int)PTR_DAT_000045e0 - (int)PTR_DAT_000045dc;\n  for (int i = 0; i < num_functions >> 2; i++) {\n    (**function_ptrs)();\n    function_ptrs++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "process_linked_list_and_increment_value_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_bit_at_position_000014c4",
                "param_1": "position",
                "param_2": "param_2",
                "pbVar1": "byte_ptr",
                "uVar2": "uint_value",
                "uVar3": "quotient"
            },
            "code": "void set_bit_at_position_000014c4(int position){\n    byte *byte_ptr = *(byte **)(PTR_DAT_000015cc + position * 0x20);\n    uint uint_value = *(uint *)(PTR_DAT_000015cc + position * 0x20 + 4);\n    byte_ptr[3] = byte_ptr[3] & 0xf3;\n    byte_ptr[2] = PTR_DAT_000015cc[position * 0x20 + 0x1d];\n    uint quotient = uint_value / (param_2 << 4);\n    *byte_ptr = (byte)(quotient >> 8) & 0x1f;\n    byte_ptr[1] = (byte)quotient;\n    byte_ptr[10] = (byte)((uint_value << 2) / param_2 + 1 >> 1) & 0x1f;\n    byte_ptr[0x10] = byte_ptr[0x10] | 0x88;\n    if ((byte_ptr[0x10] & 0x70) == 0) {\n        byte_ptr[0x13] = 0;\n    }\n    else {\n        byte_ptr[0x13] = (char)(2 << (byte_ptr[0x10] >> 4 & 7)) - 1;\n    }\n    byte_ptr[0x15] = 1;\n    byte_ptr[0x11] = 0xc0;\n    byte_ptr[3] = byte_ptr[3] | 0x2c;\n    set_bit_at_position_000014c4_00001318((int)(char)PTR_DAT_000015cc[position * 0x20 + 0x14]);\n    return;\n}",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "update_list_00004b34",
                "param_1": "list_start",
                "param_2": "list_size",
                "param_3": "new_element",
                "param_4": "element_size",
                "puVar1": "pointer_1",
                "piVar2": "pointer_2",
                "extraout_r1": "extra_output_1",
                "ppiVar3": "pointer_pointer_3",
                "ppiVar4": "pointer_pointer_4",
                "ppiVar5": "pointer_pointer_5",
                "ppiVar6": "pointer_pointer_6",
                "bVar7": "bool_1"
            },
            "code": "void update_list_00004b34(int *list_start, int list_size, int *new_element, int element_size)\n{\n  int **current_element;\n  int **previous_element;\n  int **start_of_list = *(int ***)PTR_DAT_00004bcc;\n  if (list_size == 0) {\n    return;\n  }\n  current_element = (int **)(list_size + -4);\n  if (*(int *)(list_size + -4) < 0) {\n    current_element = (int **)((int)current_element + *(int *)(list_size + -4));\n  }\n  do_nothing_with_pointer_00005790();\n  previous_element = *(int ***)PTR_DAT_00004bcc;\n  if (previous_element == (int **)0x0) {\n    current_element[1] = (int *)0x0;\n    *(int ***)PTR_DAT_00004bcc = current_element;\n    current_element = (int **)extraout_r1;\n    previous_element = (int **)PTR_DAT_00004bcc;\n  }\n  else if (current_element < previous_element) {\n    current_element[1] = (int *)previous_element;\n    previous_element = current_element;\n    *(int ***)PTR_DAT_00004bcc = current_element;\n  }\n  else {\n    do {\n      previous_element = current_element;\n      current_element = (int **)previous_element[1];\n      if (current_element == (int **)0x0) break;\n    } while (current_element <= current_element);\n    if ((int **)((int)previous_element + (int)*previous_element) == current_element) {\n      current_element = (int **)((int)current_element + (int)*current_element);\n      *previous_element = (int *)current_element;\n      if (current_element == (int **)((int)previous_element + (int)*previous_element)) {\n        current_element = (int **)*current_element;\n        previous_element[1] = current_element[1];\n        current_element = (int **)((int)current_element + (int)*new_element);\n        *previous_element = (int *)current_element;\n      }\n    }\n    else if (current_element < (int **)((int)previous_element + (int)*previous_element)) {\n      return;\n    }\n    else {\n      current_element[1] = (int *)previous_element[1];\n      previous_element[1] = (int *)current_element;\n    }\n  }\n  do_nothing_with_pointer_0000579c(list_start, current_element, previous_element, element_size);\n  return;\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_0000404c",
                "FUN_00005780",
                "FUN_000060cc",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_00006192"
            ],
            "imported": false,
            "current_name": "update_list_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_19_000004f2",
                "*param_1": "*param",
                "0x13": "19",
                "undefined4": "int"
            },
            "code": "int set_param_to_19_000004f2(int *param)\n{\n    *param = 19;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_bytes_00004e66",
                "param_1": "input1",
                "param_2": "input1_size",
                "param_3": "input2",
                "pbVar1": "current_byte1",
                "pbVar2": "current_byte2",
                "uVar3": "current_byte1_value"
            },
            "code": "int compare_bytes_00004e66(byte* input1, int input1_size, byte* input2)\n{\n    byte* current_byte1 = input1;\n    byte* current_byte2 = input2;\n    uint byte_difference = 0;\n    if (input1_size != 0) {\n        do {\n            uint current_byte1_value = (uint)*current_byte1;\n            current_byte2++;\n            if ((current_byte1_value != *current_byte2) || (current_byte1 + 1 == input1 + input1_size)) break;\n            current_byte1++;\n        } while (current_byte1_value != 0);\n        byte_difference = current_byte1_value - *current_byte2;\n    }\n    return byte_difference;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_null_terminator_00005ecc",
                "param_1": "str",
                "pcVar3": "current_char",
                "pcVar2": "next_char",
                "cVar1": "current_char_value"
            },
            "code": "char* find_null_terminator_00005ecc(char* str) {\n  char* current_char = str;\n  while (*current_char != '\\0') {\n    current_char++;\n  }\n  return current_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005e68",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_null_terminator_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "allocate_memory_for_param_0000129c",
                "param_1": "param_size",
                "allocate_memory_00002434": "allocate_memory"
            },
            "code": "void allocate_memory_for_param_0000129c(undefined4 param_size)\n{\n  allocate_memory(param_size, 1);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "allocate_memory_for_param_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_flag_and_call_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "data_address_pointer",
                "PTR_DAT_00001684": "function_address_pointer",
                "byte": "byte",
                "flag": "flag",
                "int": "int",
                "code": "code",
                "undefined4": "arg1",
                "undefined": "arg2",
                "check_and_set_flag_on_data_address_00001348": "check_and_set_flag_on_data_address_00001348"
            },
            "code": "void check_flag_and_call_function_00001628(int index)\n{\n    int* data_address = *(int*)(PTR_DAT_00001680 + index * 0x20);\n    int* function_address = *(int*)(PTR_DAT_00001684 + index * 8);\n    byte flag = *(byte*)(data_address + 4);\n    if ((flag & 0x20) && (function_address != 0))\n    {\n        code* function = *(code**)(function_address);\n        undefined4 arg1 = *(undefined4*)(function_address + 4);\n        undefined arg2 = *(undefined*)(data_address + 7);\n        function(arg1, arg2);\n    }\n    check_and_set_flag_on_data_address_00001348();\n    return;\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_flag_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "update_bitfield_00001748",
                "param_1": "new_value",
                "*(byte *)(DAT_00001774 + 3)": "current_value",
                "param_1 | *(byte *)(DAT_00001774 + 3) & 0x1f": "masked_new_value"
            },
            "code": "void update_bitfield_00001748(byte new_value) {\n    byte* bitfield = (byte*)(DAT_00001774 + 3);\n    byte *(byte *)(DAT_00001774 + 3) = *bitfield;\n    byte param_1 | *(byte *)(DAT_00001774 + 3) & 0x1f = new_value | (*(byte *)(DAT_00001774 + 3) & 0x1f);\n    *bitfield = param_1 | *(byte *)(DAT_00001774 + 3) & 0x1f;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_0000191c",
                "FUN_000018bc"
            ],
            "imported": false,
            "current_name": "update_bitfield_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_on_0000294c",
                "DAT_0000296c": "data_ptr"
            },
            "code": "void set_flag_on_0000294c(uint *DAT_0000296c)\n{\n  uint *flag_ptr = DAT_0000296c + 0x14;\n  *flag_ptr |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_valid_input_00000534",
                "*param_1": "*input",
                "param_2": "input_size",
                "uVar1": "is_valid"
            },
            "code": "int check_valid_input_00000534(int* input, int input_size) {\n    int is_valid = 0;\n    *input = 0;\n    if (input_size == 0 || input_size == 1 || input_size == 2) {\n        is_valid = 1;\n    }\n    return is_valid;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_calculated_offset_to_one_000017dc",
                "DAT_00001820": "ptr_data",
                "DAT_00001824": "ptr_data_2",
                "DAT_00001828": "ptr_data_3"
            },
            "code": "void set_calculated_offset_to_one_000017dc(uint32_t* DAT_00001820, uint32_t offset) {\n  set_calculated_offset_to_one_000017dc(DAT_00001820, offset);\n  if ((*(uint *)(DAT_00001820 + 0x10) & 0x100) == 0) {\n    *(uint *)(DAT_00001820 + 0x10) = 0x104;\n  }\n  *DAT_00001820 = *DAT_00001820 & 0xfff3ffff | 0x80000;\n  return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "set_calculated_offset_to_one_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "process_linked_list_and_increment_value_00000410",
                "PTR_00000df4": "PTR_00000df4",
                "DAT_00000df8": "DAT_00000df8"
            },
            "code": "void process_linked_list_and_increment_value_00000410(void)\n{\n  process_linked_list_and_increment_value_00000410_00000df4();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "process_linked_list_and_increment_value_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "get_value_from_ptr_000005ca",
                "param_1": "ptr_value",
                "puVar1": "value_ptr"
            },
            "code": "undefined4* get_value_from_ptr_000005ca(int* ptr_value) {\n  undefined4* value_ptr;\n  if (*ptr_value == 0) {\n    value_ptr = NULL;\n  }\n  else {\n    value_ptr = *(undefined4**)*ptr_value;\n    if (value_ptr == (undefined4*)*ptr_value) {\n      *ptr_value = 0;\n    }\n    else {\n      *(undefined4*)*ptr_value = *value_ptr;\n    }\n  }\n  return value_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "get_value_from_ptr_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "data",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005ff8(int* DAT_00006000){\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_at_position_00002714",
                "param_1": "bit_position",
                "DAT_00002740": "ptr_to_dat"
            },
            "code": "void set_bit_at_position_00002714(uint8_t bit_position) {\n    uint32_t* ptr = (uint32_t*)(DAT_00002740 + ((uint32_t)bit_position >> 5) * 4);\n    uint32_t bit_mask = 1 << (bit_position & 0x1f);\n    *ptr = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "extract_bits_and_call_function_000020e0",
                "DAT_000020f0": "data",
                "extract_bits_and_call_function_00002028": "extract_bits",
                "PTR_": "ptr_",
                "DAT_": "data_"
            },
            "code": "void extract_bits_and_call_function_000020e0(uint8_t* DAT_000020f0, uint8_t num_bits)\n{\n  extract_bits(DAT_000020f0, num_bits);\n  call_function();\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_with_data_pointer_00005fec",
                "DAT_00005ff4": "data_ptr",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_with_data_pointer_00005fec(void* DAT_00005ff4)\n{\n  do_nothing(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_pointer_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convert_string_to_uint_00004f84",
                "param_1": "string",
                "param_2": "end_ptr",
                "param_3": "base",
                "uVar1": "value",
                "uVar2": "digit",
                "uVar3": "flags",
                "uVar4": "digit_value",
                "uVar5": "sign",
                "uVar6": "max_value",
                "uVar7": "max_div",
                "iVar5": "last_error",
                "pbVar8": "current_char",
                "pbVar9": "next_char",
                "PTR_DAT_00004f7c": "DIGIT_FLAGS",
                "DAT_00004f94": "LAST_ERROR_PTR"
            },
            "code": "uint convert_string_to_uint_00004f84(byte *string, byte **end_ptr, uint base) {\n  uint value = 0;\n  int sign = 1;\n  byte *ptr = string;\n  while (isspace(*ptr)) {\n    ptr++;\n  }\n  if (*ptr == '-') {\n    sign = -1;\n    ptr++;\n  } else if (*ptr == '+') {\n    ptr++;\n  }\n  if (base == 0) {\n    if (*ptr == '0') {\n      base = 8;\n      ptr++;\n      if ((*ptr == 'x') || (*ptr == 'X')) {\n        base = 16;\n        ptr++;\n      }\n    } else {\n      base = 10;\n    }\n  } else if ((base != 16) || (*ptr != '0')) {\n    base = 10;\n  } else {\n    ptr++;\n  }\n  while (isalnum(*ptr)) {\n    uint digit = *ptr - '0';\n    if (digit > 9) {\n      digit = tolower(*ptr) - 'a' + 10;\n    }\n    if (digit >= base) {\n      break;\n    }\n    value = value * base + digit;\n    ptr++;\n  }\n  if (end_ptr != NULL) {\n    *end_ptr = ptr;\n  }\n  return sign * value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "convert_string_to_uint_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_dat_pointer_value_plus_one_000028f0",
                "DAT_0000290c": "PTR_DAT_0000290c"
            },
            "code": "int get_dat_pointer_value_plus_one_000028f0(void)\n{\n    int* data_pointer = (int*)(DAT_0000290c + 8);\n    int value = *data_pointer;\n    int result = value + 1;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "get_dat_pointer_value_plus_one_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_date_00004f98",
                "param_1": "year",
                "puVar1": "date_array",
                "uVar2": "return_value",
                "uVar3": "month",
                "iVar4": "is_leap",
                "puVar5": "current_date",
                "iVar6": "days_since_1900",
                "uVar7": "leap_year",
                "iVar8": "i",
                "iVar9": "days_since_sunday",
                "uVar10": "leading_zeroes"
            },
            "code": "undefined4 calculate_date_00004f98(uint year)\n{\n  uint *date_array = (uint *)get_data_value_000056b0();\n  if ((int)year < 0x7b2) {\n    return 0;\n  }\n  else {\n    uint leading_zeroes = count_leading_zeroes(year % 400);\n    int days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    date_array[1] = year;\n    uint *current_date = date_array;\n    do {\n      uint month = current_date[5];\n      if (*(char *)(current_date + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)month < 0x3c) {\n            days_since_1900 = 0;\n          }\n          else {\n            days_since_1900 = 1;\n          }\n        }\n        else {\n          days_since_1900 = 0;\n        }\n        days_since_1900 = days_since_1900 + days_since_1900 + month + -1;\n      }\n      else if (*(char *)(current_date + 2) == 'D') {\n        days_since_1900 = days_since_1900 + month;\n      }\n      else {\n        uint leap_year = leading_zeroes >> 5;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          leap_year = 1;\n        }\n        int i = 0;\n        int days_since_january = days_since_1900;\n        while (i < (int)current_date[3]) {\n          days_since_january += *(int *)(PTR_DAT_000050e4 + i * 4 + leap_year * 0x30 + -4);\n          i++;\n        }\n        int days_since_sunday = month - (days_since_january + 4U) % 7;\n        if (days_since_sunday < 0) {\n          days_since_sunday = days_since_sunday + 7;\n        }\n        for (days_since_sunday = (current_date[4] - 1) * 7 + days_since_sunday; *(int *)(PTR_DAT_000050e4 + i * 4 + leap_year * 0x30 + -4) <= days_since_sunday; days_since_sunday = days_since_sunday + -7) {\n        }\n        days_since_1900 = days_since_1900 + days_since_sunday;\n      }\n      uint days_since_1900_2 = current_date[10] + DAT_000050e0 * days_since_1900 + current_date[6];\n      current_date[8] = days_since_1900_2;\n      current_date[9] = (int)days_since_1900_2 >> 0x1f;\n      current_date = current_date + 10;\n    } while (date_array + 0x14 != current_date);\n    uint days_since_1900_3 = date_array[9];\n    uint days_since_1900_4 = date_array[0x13];\n    *date_array = (uint)((int)((days_since_1900_3 - days_since_1900_4) - (uint)(date_array[8] < date_array[0x12])) < 0 != (SBORROW4(days_since_1900_3,days_since_1900_4) != SBORROW4(days_since_1900_3 - days_since_1900_4,(uint)(date_array[8] < date_array[0x12]))));\n    return 1;\n  }\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_00005100",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "calculate_date_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "set_param_to_19_000004f2_if_negative_param_2_ushort_c_bitshifted_left_0x17_00004dee",
                "param_1": "param_1",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "ushort_c_shifted": "ushort_c_shifted",
                "*(ushort *)(param_2 + 0xc)": "ushort_c",
                "*(short *)(param_2 + 0xe)": "short_e",
                "set_param_to_19_000004f2": "set_param_to_19_000004f2",
                "result": "result"
            },
            "code": "undefined4 set_param_to_19_000004f2_if_negative_param_2_ushort_c_bitshifted_left_0x17_00004dee(int param_1, int param_2, undefined4 param_3, undefined4 param_4)\n{\n  int ushort_c_shifted = (uint)*(ushort *)(param_2 + 0xc) << 0x17;\n  if (ushort_c_shifted < 0) {\n    set_param_to_19_000004f2(param_1, (int)*(short *)(param_2 + 0xe), 0, 2);\n  }\n  *(ushort *)(param_2 + 0xc) = *(ushort *)(param_2 + 0xc) & 0xefff;\n  undefined4 result = copy_data_to_memory(param_3, param_4);\n  return result;\n}",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "set_param_to_19_000004f2_if_negative_param_2_ushort_c_bitshifted_left_0x17_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_array_00000fec",
                "param_1": "array",
                "param_2": "length",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION"
            },
            "code": "void initialize_array_00000fec(uint32_t *array, uint32_t length)\n{\n    if ((length & (length - 1)) != 0)\n    {\n        process_data(3, PTR_s_FAILED_ASSERTION__00001030);\n    }\n    array[0] = 0;\n    array[1] = 0;\n    array[2] = length - 1;\n    return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_array_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "get_local_value_00000428",
                "param_1": "result",
                "param_2": "param_2",
                "uVar1": "irq_enabled",
                "local_c": "local_value"
            },
            "code": "uint32_t get_local_value_00000428(uint32_t *result, uint32_t param_2)\n{\n  uint32_t irq_enabled = is_irq_interrupts_enabled_00000cd0();\n  uint32_t local_value = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (param_2 + *(int *)PTR_Elf32_Rel_ARRAY_00000484)) || ((param_2 + *(int *)PTR_Elf32_Rel_ARRAY_00000484) < DAT_0000048c)) {\n    *result = 0xc;\n    local_value = 0xffffffff;\n  }\n  else {\n    *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484 = param_2 + *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  }\n  enable_IRQ_interrupts_if_privileged_00000d0c(irq_enabled);\n  return local_value;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "get_local_value_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "get_pointer_for_char_000039e8",
                "param_1": "c",
                "puVar1": "result"
            },
            "code": "#include <stdbool.h>\n\n// Map of characters to corresponding pointers\nconst void* char_map[128] = {\n    [0 ... 31] = NULL,\n    [32] = DAT_00003cc0,\n    [33 ... 126] = NULL,\n    [127] = PTR_s_CLASS_UNKNOWN_00003d20,\n    ['@'] = DAT_00003cc4,\n    ['B'] = DAT_00003cc8,\n    ['C'] = PTR_s_ACT_SERVO_00003ccc,\n    ['D'] = PTR_s_ACT_MOTOR_00003cd0,\n    ['E'] = PTR_s_ACT_SWITCH_00003cd4,\n    ['F'] = PTR_s_ACT_DIMMER_00003cd8,\n    [-128] = PTR_s_SENSE_ANY_00003cdc,\n    [-127] = PTR_s_SENSE_BTN_00003ce0,\n    [-126] = PTR_s_SENSE_TEMP_00003ce4,\n    [-125] = PTR_s_SENSE_HUM_00003ce8,\n    [-124] = PTR_s_SENSE_LIGHT_00003cec,\n    [-123] = PTR_s_SENSE_ACCEL_00003cf0,\n    [-122] = PTR_s_SENSE_MAG_00003cf4,\n    [-121] = PTR_s_SENSE_GYRO_00003cf8,\n    [-120] = PTR_s_SENSE_COLOR_00003cfc,\n    [-119] = PTR_s_SENSE_PRESS_00003d00,\n    [-118] = PTR_s_SENSE_ANALOG_00003d04,\n    [-117] = PTR_s_SENSE_UV_00003d08,\n    [-116] = PTR_s_SENSE_OBJTEMP_00003d0c,\n    [-115] = PTR_s_SENSE_PULSE_COUNT_00003d10,\n    [-114] = PTR_s_SENSE_DISTANCE_00003d14,\n    [-113] = PTR_s_SENSE_CO2_00003d18\n};\n\n// Function to get the pointer corresponding to the given character\nvoid* get_pointer_for_char_000039e8(char c) {\n    void* result = PTR_s_CLASS_ANY_00003d1c;\n    if (c >= 0 && c <= 127) {\n        result = char_map[(int)c];\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "get_pointer_for_char_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "copy_data_to_memory": "copy_data_to_memory",
                "param_1": "destination_address",
                "param_2": "source_address",
                "copy_data_to_memory_000015d0": "memcpy",
                "return": "size",
                "FUN_00000e38": "copy_data_to_memory_00000e38"
            },
            "code": "int copy_data_to_memory_00000e38(int destination_address, int source_address, int size) {\n    copy_data_to_memory_000015d0(destination_address, source_address, size);\n    return size;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "check_if_difference_equals_third_parameter_00002294",
                "param_1": "ptr_param_1",
                "iVar2": "ptr_var_1",
                "bVar3": "is_equal"
            },
            "code": "int check_if_difference_equals_third_parameter_00002294(int ptr_param_1)\n{\n  int ptr_var_1;\n  bool is_equal;\n  \n  ptr_var_1 = *(int *)(ptr_param_1 + 4);\n  is_equal = *(int *)(ptr_param_1 + 0xc) - *(int *)(ptr_param_1 + 8) == ptr_var_1;\n  if (is_equal) {\n    ptr_var_1 = 1;\n  }\n  \n  return ptr_var_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "check_if_difference_equals_third_parameter_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "count_decimal_digits_and_sign_00003e9e",
                "param_1": "number",
                "param_2": "base",
                "param_3": "sign",
                "uVar1": "digit_count"
            },
            "code": "int count_decimal_digits_and_sign_00003e9e(int number, int base, int sign){\n  int digit_count = 0;\n  int num = abs(number);\n  if(sign || number < 0){\n    digit_count++;\n  }\n  while(num > 0){\n    digit_count++;\n    num /= base;\n  }\n  return digit_count;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "count_decimal_digits_and_sign_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "calculate_something_00003378",
                "*param_1": "*input_array",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "constant_array",
                "param_1[5]": "input_array[5]",
                "param_1[4]": "input_array[4]",
                "param_1[3]": "input_array[3]",
                "param_1[2]": "input_array[2]",
                "param_1[1]": "input_array[1]"
            },
            "code": "int calculate_something_00003378(int *input_array)\n{\n  int PTR_s__04i__02i__02i__02i__02i__02i_000033bc[] = {0x04, 0x02, 0x02, 0x02, 0x02, 0x02};\n  int sum = input_array[5] + 0x76c;\n  int var1 = input_array[4] + 1;\n  int var2 = input_array[3];\n  int var3 = input_array[2];\n  int var4 = input_array[1];\n  int var5 = *input_array;\n  calculate_result(PTR_s__04i__02i__02i__02i__02i__02i_000033bc, sum, var1, var2, var3, var4, var5);\n  return 0;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_00003444",
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "calculate_something_00003378",
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUNC_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,param_1[5] + 0x76c,param_1[4] + 1,\n               param_1[3],param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "calculate_result_00006768",
                "param_1": "input_buffer",
                "param_2": "output_buffer",
                "param_3": "buffer_size",
                "param_4": "flag",
                "uVar1": "flag_value",
                "iVar2": "result",
                "uVar3": "temp_value",
                "uVar4": "buffer_value",
                "uVar5": "buffer_value_uint"
            },
            "code": "undefined4 calculate_result_00006768(undefined4 *input_buffer, undefined4 *output_buffer, undefined4 buffer_size, undefined4 flag)\n{\n    undefined2 flag_value;\n    int result;\n    undefined4 temp_value;\n    ushort buffer_value;\n    uint buffer_value_uint;\n\n    if ((input_buffer != (undefined4 *)0x0) && (input_buffer[6] == 0)) {\n        initialize_pointers_if_null_000042a4();\n    }\n    if (output_buffer == (undefined4 *)PTR_DAT_00006868) {\n        output_buffer = (undefined4 *)input_buffer[1];\n    }\n    else if (output_buffer == (undefined4 *)PTR_DAT_0000686c) {\n        output_buffer = (undefined4 *)input_buffer[2];\n    }\n    else if (output_buffer == (undefined4 *)PTR_DAT_00006870) {\n        output_buffer = (undefined4 *)input_buffer[3];\n    }\n    buffer_value = *(ushort *)(output_buffer + 3);\n    output_buffer[1] = 0;\n    buffer_value_uint = (uint)*(ushort *)(output_buffer + 3);\n    if ((int)(buffer_value_uint << 0x1a) < 0) {\n        return 0xffffffff;\n    }\n    if ((int)(buffer_value_uint << 0x1d) < 0) {\n        if ((undefined4 *)output_buffer[0xd] != (undefined4 *)0x0) {\n            if ((undefined4 *)output_buffer[0xd] != output_buffer + 0x11) {\n                update_list_00004b34(input_buffer);\n            }\n            output_buffer[1] = output_buffer[0x10];\n            output_buffer[0xd] = 0;\n            if (output_buffer[0x10] != 0) {\n                *output_buffer = output_buffer[0xf];\n                return 0;\n            }\n        }\n    }\n    else {\n        if (-1 < (int)(buffer_value_uint << 0x1b)) {\n            *input_buffer = 9;\n            buffer_value = buffer_value | 0x40;\n            goto LAB_000067b8;\n        }\n        if ((int)(buffer_value_uint << 0x1c) < 0) {\n            result = process_data(input_buffer, output_buffer, buffer_value_uint << 0x1c, buffer_value_uint, flag);\n            if (result != 0) {\n                return 0xffffffff;\n            }\n            output_buffer[2] = 0;\n            *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) & 0xfff7;\n            output_buffer[6] = 0;\n        }\n        *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) | 4;\n    }\n    if (output_buffer[4] == 0) {\n        allocate_memory_and_set_flag(input_buffer, output_buffer);\n    }\n    buffer_value = *(ushort *)(output_buffer + 3);\n    flag_value = *(undefined2 *)(output_buffer + 3);\n    if ((buffer_value & 3) != 0) {\n        *(undefined2 *)(output_buffer + 3) = 1;\n        find_flag(*(undefined4 *)PTR_DAT_00006874, PTR_LAB_00006754_1_00006878);\n        *(undefined2 *)(output_buffer + 3) = flag_value;\n        if ((buffer_value & 9) == 9) {\n            process_data_0000404c(input_buffer, output_buffer);\n        }\n    }\n    temp_value = output_buffer[4];\n    *output_buffer = temp_value;\n    result = (*(code *)output_buffer[9])(input_buffer, output_buffer[8], temp_value, output_buffer[5]);\n    output_buffer[1] = result;\n    if (0 < result) {\n        return 0;\n    }\n    buffer_value = *(ushort *)(output_buffer + 3);\n    if (result != 0) {\n        temp_value = 0;\n    }\n    else {\n        buffer_value = buffer_value | 0x20;\n    }\n    if (result != 0) {\n        output_buffer[1] = temp_value;\n        buffer_value = buffer_value | 0x40;\n    }\nLAB_000067b8:\n    *(ushort *)(output_buffer + 3) = buffer_value;\n    return 0xffffffff;\n}\n",
            "called": [
                "FUN_0000404c",
                "FUN_00005700",
                "FUN_000043a0",
                "FUN_00004158",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "calculate_result_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "initialize_data_and_result_to_zero_00000db0",
                "set_data_00000dcc": "set_data",
                "clear_result_to_zero_00000d9c": "clear_result"
            },
            "code": "void initialize_data_and_result_to_zero_00000db0(void)\n{\n  set_data();\n  clear_result();\n  return;\n}",
            "called": [
                "FUN_00000dcc",
                "FUN_00000d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_data_and_result_to_zero_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_value_and_set_flag_00002600",
                "param_1": "value",
                "uVar1": "processed_value",
                "FUNC_000047e4": "process_value",
                "set_flag_and_store_value_in_array_0000285c": "set_flag_and_store_value"
            },
            "code": "int process_value_and_set_flag_00002600(int value) {\n  int processed_value = process_value(value);\n  set_flag_and_store_value(processed_value);\n  return 0;\n}",
            "called": [
                "FUN_0000285c",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_value_and_set_flag_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_label_for_param_value_00003810",
                "param_1": "param_value",
                "puVar1": "label_ptr"
            },
            "code": "undefined * get_label_for_param_value_00003810(undefined param_value) {\n  undefined *label_ptr;\n  switch(param_value) {\n    case 2:\n      label_ptr = PTR_LAB_000038cc;\n      break;\n    case 3:\n      label_ptr = PTR_LAB_000038d0;\n      break;\n    case 4:\n      label_ptr = PTR_LAB_000038d4;\n      break;\n    case 5:\n      label_ptr = PTR_LAB_000038d8;\n      break;\n    case 6:\n      label_ptr = PTR_LAB_000038dc;\n      break;\n    case 7:\n      label_ptr = PTR_LAB_000038e0;\n      break;\n    case 8:\n      label_ptr = PTR_LAB_000038e4;\n      break;\n    case 9:\n      label_ptr = PTR_LAB_000038e8;\n      break;\n    case 10:\n      label_ptr = PTR_LAB_000038ec;\n      break;\n    case 0xb:\n      label_ptr = PTR_LAB_000038f0;\n      break;\n    case 0xc:\n      label_ptr = PTR_LAB_000038f4;\n      break;\n    case 0xd:\n      label_ptr = PTR_LAB_000038f8;\n      break;\n    case 0xe:\n      label_ptr = PTR_LAB_000038fc;\n      break;\n    case 0xf:\n      label_ptr = PTR_LAB_00003900;\n      break;\n    case 0x10:\n      label_ptr = PTR_LAB_00003904;\n      break;\n    case 0x11:\n      label_ptr = PTR_LAB_0000390c;\n      break;\n    case 0x13:\n      label_ptr = PTR_LAB_00003910;\n      break;\n    case 0x15:\n      label_ptr = PTR_LAB_00003908;\n  }\n  return label_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_label_for_param_value_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "process_data_00000ed8",
                "in_lr": "current_LR",
                "FUNC_00004c84": "call_data_processing_function",
                "PTR_DAT_00000ef4": "PTR_DATA_ARRAY"
            },
            "code": "void process_data_00000ed8(void)\n{\n  undefined4 current_LR;\n  call_data_processing_function(PTR_DAT_00000ef4, current_LR);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "process_data_00000ed8",
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUNC_00004c84(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "play_alarm_sound_000031e0",
                "process_input": "trigger_alarm",
                "PTR_s_The_alarm_rang_000031f8": "alarm_message"
            },
            "code": "void play_alarm_sound_000031e0(void)\n{\n  trigger_alarm(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "play_alarm_sound_000031e0",
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  process_input(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "reverse_engineered_function_000020f4",
                "extract_bits_and_call_function_00002028": "extract_bits_and_call_function",
                "DAT_00002104": "data_ptr",
                "num_bits": "num_bits",
                "mask": "mask",
                "extracted_data": "extracted_data",
                "function_to_call": "function_to_call"
            },
            "code": "void reverse_engineered_function_000020f4(uint8_t* data, uint8_t num_bits);\n\nvoid reverse_engineered_function_000020f4(uint8_t* data, uint8_t num_bits)\n{\n  uint8_t mask = (1 << num_bits) - 1;\n  uint8_t extracted_data = (*data) & mask;\n  function_to_call(extracted_data);\n}\n\nvoid reverse_engineered_function_000020f4()\n{\n  uint8_t* DAT_00002104 = DAT_00002104;\n  uint8_t num_bits = 3;\n  reverse_engineered_function_000020f4(DAT_00002104, num_bits);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "reverse_engineered_function_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_toggle_bits_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "output",
                "uVar2": "range_end",
                "iVar3": "i",
                "uVar4": "first_byte",
                "uVar5": "current_byte",
                "uVar6": "range_end",
                "bVar7": "is_toggle"
            },
            "code": "byte * reverse_and_toggle_bits_0000687c(int length, byte *input) {\n  byte *output;\n  uint first_byte = (uint)*input;\n  bool is_toggle = first_byte == 0x5e;\n  if (is_toggle) {\n    first_byte = (uint)input[1];\n    input += 2;\n  }\n  else {\n    input++;\n  }\n  int i = length - 1;\n  do {\n    i++;\n    *(bool *)i = is_toggle;\n  } while (i != length + 0xff);\n  if (first_byte == 0) {\n    output = input - 1;\n  }\n  else {\n    do {\n      uint current_byte = first_byte;\n      *(bool *)(length + current_byte) = !is_toggle;\n      input++;\n      while (true) {\n        first_byte = (uint)input[-1];\n        if (first_byte != 0x2d) break;\n        uint range_end = (uint)*input;\n        if ((range_end == 0x5d) || ((int)range_end < (int)current_byte)) goto end_of_loop;\n        do {\n          current_byte++;\n          *(bool *)(length + current_byte) = !is_toggle;\n        } while ((int)current_byte < (int)range_end);\n        int range_length = ~current_byte + range_end;\n        if ((int)range_end <= (int)current_byte) {\n          range_length = 0;\n        }\n        current_byte = current_byte + 1 + range_length;\n        input += 2;\n      }\n      output = input - 1;\n    } while ((first_byte != 0x5d) && (output = input - 1, first_byte != 0));\n  }\n  end_of_loop:\n  return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "reverse_and_toggle_bits_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "parse_integer_00005edc",
                "param_1": "output",
                "param_2": "input",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char",
                "bVar3": "is_hex",
                "iVar4": "parse_error",
                "uVar5": "digit",
                "uVar6": "max_divisor",
                "pbVar7": "current_ptr",
                "pbVar8": "next_ptr",
                "*param_1": "*output",
                "*param_3": "*end_ptr",
                "PTR_DAT_00005fd0": "CHARACTER_PROPERTIES_TABLE"
            },
            "code": "uint parse_integer_00005edc(undefined4 *output, byte *input, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint max_divisor = 0xffffffff / base;\n  uint value = 0;\n  byte *current_ptr = input;\n  while ((PTR_DAT_00005fd0[*current_ptr] & 8) != 0) {\n    current_ptr++;\n  }\n  if (*current_ptr == '-') {\n    is_negative = 1;\n    current_ptr++;\n  }\n  else if (*current_ptr == '+') {\n    current_ptr++;\n  }\n  if (base == 0) {\n    if (*current_ptr != '0') {\n      base = 10;\n    }\n    else if ((*(current_ptr + 1) & 0xdf) == 'X') {\n      base = 16;\n      current_ptr += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  else if (base == 16 && *(current_ptr + 1) == 'X') {\n    current_ptr += 2;\n  }\n  while (1) {\n    digit_value = *current_ptr - '0';\n    if (digit_value > 9) {\n      digit_value = (*current_ptr & 0xdf) - 'A' + 10;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (value > max_divisor || (value == max_divisor && digit_value > 0xffffffff % base)) {\n      output = 0;\n      value = 0xffffffff;\n      if (end_ptr == 0) {\n        return 0xffffffff;\n      }\n      break;\n    }\n    value = value * base + digit_value;\n    current_ptr++;\n  }\n  if (is_negative) {\n    value = -value;\n  }\n  if (end_ptr == 0) {\n    return value;\n  }\n  if (output != 0 && value != 0) {\n    *output = value;\n  }\n  *end_ptr = current_ptr;\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "parse_integer_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "update_bits_in_data_00001eea",
                "param_1": "data",
                "param_2": "bits",
                "uVar1": "extracted_bits",
                "iVar2": "address",
                "iVar3": "output_index",
                "PTR_XXXXXXXX_0014": "data_address",
                "DAT_XXXXXXXX": "0x23",
                "DAT_XXXXXXXX_0001": "0x100"
            },
            "code": "int update_bits_in_data_00001eea(uint16_t data, uint8_t bits)\n{\n    uint8_t extracted_bits = extract_six_bits_from_data(data);\n    uint32_t address = convert_data_to_address(data);\n    uint32_t* PTR_XXXXXXXX_0014 = (uint32_t*)(address + 0x14);\n    if(bits < 0)\n    {\n        *PTR_XXXXXXXX_0014 |= 1 << (extracted_bits & 0xff);\n    }\n    else\n    {\n        *PTR_XXXXXXXX_0014 &= ~(1 << (extracted_bits & 0xff));\n    }\n    uint32_t output_address = convert_data_to_output(data);\n    uint8_t output_index = extract_six_bits_from_data(data);\n    *(uint32_t*)(output_address + output_index * 4) = bits & DAT_XXXXXXXX | DAT_XXXXXXXX_0001;\n    return 0;\n}",
            "called": [
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0",
                "FUN_00001d5e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "update_bits_in_data_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "process_interrupt_request_and_handle_000023a4",
                "auStack_88": "buffer",
                "process_input": "process_data",
                "process_input_and_data_00002e6c": "process_input"
            },
            "code": "undefined4 process_interrupt_request_and_handle_000023a4(void)\n{\n  undefined4 result;\n  undefined buffer[128];\n  handle_interrupt_request(0);\n  process_input(uRam000023c4);\n  result = process_input(0, buffer, 0x80);\n  software_interrupt(0x3f);\n  return result;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000023d0",
                "FUN_00002e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "process_interrupt_request_and_handle_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "get_next_element_0000240c",
                "param_1": "current_element_ptr",
                "puVar1": "next_element_ptr"
            },
            "code": "undefined4* get_next_element_0000240c(undefined4* current_element_ptr)\n{\n    undefined4* next_element_ptr = (undefined4*) *current_element_ptr;\n    if (next_element_ptr != (undefined4*) 0x0) {\n        *current_element_ptr = *next_element_ptr;\n    }\n    return next_element_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "get_next_element_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_with_data_00004280",
                "PTR_DAT_00004288": "PTR_DATA"
            },
            "code": "void do_nothing_with_data_00004280(void)\n{\n    do_nothing(PTR_DAT_00004288);\n    return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "update_data_if_bits_are_not_minus_one_00001448",
                "param_1": "data_index",
                "PTR_DAT_000014c0": "data_pointer",
                "first_bit": "first_data_bit",
                "second_bit": "second_data_bit"
            },
            "code": "void update_data_if_bits_are_not_minus_one_00001448(int data_index) {\n  short first_bit = *(short *)(PTR_DAT_000014c0 + data_index * 0x20 + 8);\n  short second_bit = *(short *)(PTR_DAT_000014c0 + data_index * 0x20 + 10);\n  if (first_bit != -1) {\n    update_data_with_bits_00001f80(*(undefined2 *)(PTR_DAT_000014c0 + data_index * 0x20 + 8), *(undefined4 *)(PTR_DAT_000014c0 + data_index * 0x20 + 0xc));\n  }\n  if (second_bit != -1) {\n    update_data_with_bits_00001f80(*(undefined2 *)(PTR_DAT_000014c0 + data_index * 0x20 + 10), *(undefined4 *)(PTR_DAT_000014c0 + data_index * 0x20 + 0x10));\n  }\n  return;\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "update_data_if_bits_are_not_minus_one_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "check_flag_and_call_function_00001688",
                "check_flag_and_call_function_00001628": "call_function",
                "0": "flag_value"
            },
            "code": "void check_flag_and_call_function_00001688(int flag_value)\n{\n  call_function(flag_value);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "check_flag_and_call_function_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_uint_00004042",
                "param_1": "string_to_convert",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void convert_string_to_uint_00004042(const char* string_to_convert, int start_index, int base)\n{\n  convert_string_to_uint_00004042_helper(string_to_convert, start_index, base);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "convert_string_to_uint_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "is_irq_interrupts_enabled_00000cf0",
                "uVar2": "is_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_irq_interrupts_enabled_00000cf0(void)\n{\n    bool is_privileged_mode = is_current_mode_privileged();\n    bool is_enabled = false;\n    if (is_privileged_mode)\n    {\n        is_enabled = (bool)is_IRQ_interrupts_enabled();\n    }\n    return is_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "is_irq_interrupts_enabled_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "initialize_data_structure_00000f8c",
                "puRam00000fd4": "ptr1",
                "uRam00000fd8": "ptr2",
                "uRam00000fdc": "data",
                "puRam00000fe0": "ptr3",
                "uRam00000fe4": "arg2",
                "uRam00000fe8": "arg3",
                "is_irq_interrupts_enabled_00000cd0": "is_irq_interrupts_enabled",
                "run_software_interrupt_and_wait_00000930": "run_software_interrupt_and_wait",
                "process_data_00000f04": "process_data"
            },
            "code": "void initialize_data_structure_00000f8c(uint8_t* data, uint32_t size, uint8_t arg2, uint8_t arg3)\\\n    {\\\n        is_irq_interrupts_enabled_00000cd0();\\\n        uint32_t* ptr1 = (uint32_t*)data;\\\n        uint32_t* ptr2 = ptr1 + 1;\\\n        uint32_t* ptr3 = ptr1 + 2;\\\n        *ptr1 = 0;\\\n        *ptr2 = 0;\\\n        *ptr3 = arg2 - 1;\\\n        uint32_t arg1 = run_software_interrupt_and_wait_00000930(0xfd3);\\\n        arg1 = arg1 >> 0x1e;\\\n        if ((arg1 & (arg1 - 1)) != 0)\\\n        {\\\n            process_data(3, \\\"FAILED_ASSERTION\\\");\\\n        }\\\n    }",
            "called": [
                "FUN_000010d4",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_bit_and_byte_at_position_00002894",
                "param_1": "position",
                "param_2": "byte_value",
                "param_3": "unused",
                "iVar1": "data_address",
                "DAT_000028e8": "data_address",
                "PTR_DAT_000028ec": "byte_value_pointer",
                "set_byte_00002744": "set_byte_at_position",
                "set_bit_at_position_00002714": "set_bit_at_position"
            },
            "code": "void set_bit_and_byte_at_position_00002894(int position, int byte_value)\n{\n  int DAT_000028e8 = DAT_000028e8;\n  int current_bitmask = *(uint *)(DAT_000028e8 + 0x1c);\n  current_bitmask = current_bitmask & 0xfffffffb;\n  *(int *)(DAT_000028e8 + 8) = position - 1;\n  *(int *)PTR_DAT_000028ec = byte_value;\n  *(int *)(PTR_DAT_000028ec + 4) = 0;\n  *(uint *)(DAT_000028e8 + 0x1c) = *(uint *)(DAT_000028e8 + 0x1c) | 4;\n  set_byte_00002744(position, byte_value);\n  set_bit_at_position_00002714(position);\n}\n",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "set_bit_and_byte_at_position_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "process_data_00004158",
                "param_1": "input_ptr",
                "param_2": "data_ptr",
                "uVar1": "result",
                "FUNC_000042a4": "call_function",
                "PTR_DAT_000041c4": "PTR_DAT_000041c4",
                "PTR_DAT_000041c8": "PTR_DAT_000041c8",
                "PTR_DAT_000041cc": "PTR_DAT_000041cc",
                "do_nothing_000045e8": "do_nothing_1",
                "process_data_0000404c": "process_data_2",
                "do_nothing_000045ec": "do_nothing_2"
            },
            "code": "int process_data_00004158(int input_ptr, undefined *data_ptr) {\n    int result;\n    if (*(int *)(data_ptr + 0x10) != 0) {\n        if ((input_ptr != 0) && (*(int *)(input_ptr + 0x18) == 0)) {\n            call_function();\n        }\n        if (data_ptr == PTR_DAT_000041c4) {\n            data_ptr = *(undefined **)(input_ptr + 4);\n        }\n        else if (data_ptr == PTR_DAT_000041c8) {\n            data_ptr = *(undefined **)(input_ptr + 8);\n        }\n        else if (data_ptr == PTR_DAT_000041cc) {\n            data_ptr = *(undefined **)(input_ptr + 0xc);\n        }\n        if (*(short *)(data_ptr + 0xc) != 0) {\n            if ((*(int *)(data_ptr + 100) >= 0) && (*(short *)(data_ptr + 0xc) >= 0)) {\n                do_nothing_1(*(undefined4 *)(data_ptr + 0x58));\n            }\n            result = process_data_00004158_2(input_ptr, data_ptr);\n            if (*(int *)(data_ptr + 100) < 0 || *(short *)(data_ptr + 0xc) < 0) {\n                return result;\n            }\n            do_nothing_2(*(undefined4 *)(data_ptr + 0x58));\n            return result;\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_00005404",
                "FUN_00006768",
                "FUN_000041d0"
            ],
            "imported": false,
            "current_name": "process_data_00004158",
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUNC_000042a4();\n    }\n    if (param_2 == PTR_DAT_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR_DAT_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR_DAT_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = process_data_0000404c(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "execute_function_with_bit_and_byte_position_00002654",
                "param_1": "input_value",
                "param_2": "pointer_to_value",
                "param_3": "bit_and_byte_position",
                "uVar1": "result",
                "PTR_DAT_00002688": "pointer_to_data_1",
                "PTR_execute_function_if_not_null_000026f0_1_0000268c": "pointer_to_function"
            },
            "code": "int execute_function_with_bit_and_byte_position_00002654(unsigned int param_1, unsigned int *param_2, unsigned int param_3)\n{\n  unsigned int result = FUNC_000047e4(param_1);\n  *(unsigned int *)PTR_DAT_00002688 = *param_2;\n  set_bit_and_byte_at_position_00002894(result, PTR_execute_function_if_not_null_000026f0_1_0000268c, param_3);\n  return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "execute_function_with_bit_and_byte_position_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_data_00002538",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002584": "data_table_ptr",
                "DAT_00002588": "data_table_ptr_2"
            },
            "code": "void set_data_00002538(byte data, uint value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002584 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002588 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "set_data_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "process_data_00004c84",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "iVar1": "ptr_i",
                "uVar2": "param_1",
                "uStack_c": "param_2",
                "uStack_8": "param_3",
                "uStack_4": "param_4"
            },
            "code": "void process_data_00004c84(undefined4 data_1, undefined4 data_2, undefined4 data_3, undefined4 data_4) {\n  int* ptr_i = *PTR_00004cb0;\n  undefined4 param_1 = data_1;\n  undefined4 param_2 = data_2;\n  undefined4 param_3 = data_3;\n  undefined4 param_4 = data_4;\n  if ((ptr_i != 0) && (*(int *)(ptr_i + 0x18) == 0)) {\n    initialize_pointers_if_null_000042a4(ptr_i);\n  }\n  FUNC_000057f8(ptr_i, *(undefined4 *)(ptr_i + 8), data_1, &data_2, data_1, &data_2);\n  return;\n}",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_00000f04",
                "FUN_00002ecc",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00003694",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_0000211c",
                "FUN_00000ed8"
            ],
            "imported": false,
            "current_name": "process_data_00004c84",
            "code_backup": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *DAT_00004cb0;\n  uVar2 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    FUNC_000042a4(iVar1);\n  }\n  FUNC_000057f8(iVar1,*(undefined4 *)(iVar1 + 8),param_1,&uStack_c,uVar2,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "process_device_data_0000305c",
                "param_1": "num_params",
                "param_2": "params",
                "auStack_20": "param_values",
                "local_18": "num_params_to_process",
                "local_14": "device_id",
                "local_10": "device_id_uint",
                "local_c": "i",
                "PTR_s_usage___s__s__device_id___value_0_00003154": "USAGE_MSG",
                "convert_string_to_uint_00004042": "convert_string_to_uint",
                "find_element_in_list_00003d24": "find_device_id",
                "process_input": "report_error",
                "fill_memory_with_value_00004622": "fill_memory_with_value",
                "PTR_s_Writing_to_device___i____s_0000315c": "WRITE_MSG",
                "display_data_object_00003694": "display_data_object",
                "error_code_on_failure_00003d94": "get_error_code_on_failure",
                "PTR_s_error__undefined_device_given_00003158": "UNDEFINED_DEVICE_ERROR",
                "PTR_s_error__device___i_is_not_writabl_00003160": "DEVICE_NOT_WRITABLE_ERROR",
                "PTR_s_error__failure_to_write_to_devic_00003164": "FAILURE_TO_WRITE_ERROR",
                "PTR_s_data_successfully_written_to_dev_00003168": "DATA_SUCCESSFULLY_WRITTEN_MSG"
            },
            "code": "void process_device_data_0000305c(int num_params, undefined4 *params)\n{\n  uint num_params_to_process;\n  int device_id;\n  uint error_code;\n  undefined2 param_values[4];\n\n  if (num_params < 4) {\n    process_data(PTR_s_usage___s__s__device_id___value_0_00003154, *params, params[1]);\n  }\n  else {\n    uint device_id_uint = convert_string_to_uint_00004042(params[2]);\n    device_id = find_element_in_list_00003d24(device_id_uint);\n    if (device_id == 0) {\n      process_input(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      num_params_to_process = num_params - 3;\n      if (num_params_to_process > 3) {\n        num_params_to_process = 3;\n      }\n      for (int i = 0; i < num_params_to_process; i++) {\n        param_values[i] = convert_string_to_uint_00004042(params[i + 3]);\n      }\n      fill_memory_with_value_00004622(param_values, 0, 8);\n      process_data(PTR_s_Writing_to_device___i____s_0000315c, device_id_uint, *(undefined4 *)(device_id + 8));\n      display_data_object_00003694(param_values, num_params_to_process & 0xff);\n      error_code = error_code_on_failure_00003d94(device_id, param_values);\n      if ((int)error_code < 1) {\n        if (error_code == -0x86) {\n          process_data(PTR_s_error__device___i_is_not_writabl_00003160, device_id_uint);\n        }\n        else {\n          process_data(PTR_s_error__failure_to_write_to_devic_00003164, device_id_uint);\n        }\n      }\n      else {\n        process_data(PTR_s_data_successfully_written_to_dev_00003168, device_id_uint);\n      }\n    }\n  }\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003d94",
                "FUN_00003d24",
                "FUN_00003694",
                "FUN_00004042",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_device_data_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "increment_value_and_process_linked_list_000012b4",
                "param_1": "head",
                "param_2": "value",
                "uVar1": "result",
                "check_and_increment_value_at_address_000022be_00002364": "check_and_increment_value_at_address",
                "process_linked_list_000024bc": "process_linked_list"
            },
            "code": "int increment_value_and_process_linked_list_000012b4(int address, char value) {\n    int result = *(int *)(address) + (int)value;\n    *(int *)(address) = result;\n    return result;\n}\n\nvoid process_linked_list(int head) {\n    int current_node = *(int *)(head);\n    while (current_node != 0) {\n        // do some processing on current_node\n        current_node = *(int *)(current_node);\n    }\n}\n\nint increment_value_and_process_linked_list_000012b4(int head, char value) {\n    int address = head + 4;\n    int result = increment_value_and_process_linked_list_000012b4(address, value);\n    process_linked_list(head);\n    return result;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "increment_value_and_process_linked_list_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  puVar7 = (undefined *)((int)param_2 + 0x43);\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    puVar7 = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    puVar7 = (undefined *)*puVar9;\n    iVar4 = find_byte_sequence_00006010(puVar7,0,param_2[1],puVar9,param_1,param_2,param_3);\n    if (iVar4 != 0) {\n      param_2[1] = iVar4 - (int)puVar7;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = puVar7;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)puVar7 - (int)puVar13;\n  puVar7 = puVar13;\nLAB_00005c84:\n  iVar4 = decode_data_00005a58(param_1,param_2,&local_24,param_3,param_4);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,puVar7,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar6 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "update_linked_list_0000058e",
                "param_1": "head_ptr",
                "param_2": "new_node_ptr",
                "*param_1": "*head_ptr",
                "*param_2": "*new_node_ptr"
            },
            "code": "void update_linked_list_0000058e(int *head_ptr, undefined4 *new_node_ptr)\n{\n  if (*head_ptr == 0) {\n    *new_node_ptr = new_node_ptr;\n  }\n  else {\n    *new_node_ptr = *(undefined4 *)*head_ptr;\n    *(undefined4 **)*head_ptr = new_node_ptr;\n  }\n  *head_ptr = (int)new_node_ptr;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "update_linked_list_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined4 local_34 [4];\n  \n  local_34[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  local_34[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar3 = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (param_2[6] != 3) {\n    pcVar3 = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  uVar6 = param_2[2];\n  uVar4 = uVar6 - 1;\n  if (0x15c < uVar4) {\n    unaff_r9 = uVar6 - 0x15d;\n    uVar6 = 0x15d;\n  }\n  if (0x15c < uVar4) {\n    param_2[2] = uVar6;\n  }\n  puVar10 = param_2 + 7;\n  if (uVar4 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar11 = 0;\n  puVar9 = puVar10;\n  do {\n    iVar1 = find_byte_sequence_00006010(local_34[iVar11],**param_3,2);\n    if (iVar1 != 0) {\n      if (iVar11 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar4 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar4;\n      }\n      else if (iVar11 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar4 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 = param_2[2];\n      param_2[2] = uVar4 - 1;\n      if (uVar4 != 0) {\n        pbVar5 = *param_3;\n        *param_3 = pbVar5 + 1;\n        puVar8 = (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 = *pbVar5;\n        pbVar5 = param_3[1];\n        param_3[1] = pbVar5 + -1;\n        puVar9 = puVar8;\n        if (((int)(pbVar5 + -1) < 1) &&\n           (iVar1 = (*(code *)param_2[0x60])(param_1,param_3), iVar1 != 0)) {\n          iVar11 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 = iVar11 + 1;\n  } while (iVar11 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  reverse_and_toggle_bits_0000687c(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar11 = 0;\n  while( true ) {\n    puVar8 = puVar9;\n    if (param_2[2] == 0) break;\n    pbVar5 = *param_3;\n    uVar4 = (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) == '\\0') break;\n    if ((uVar4 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar11 = iVar11 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar8 = (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 = *pbVar5;\n    }\n    pbVar5 = param_3[1];\n    param_3[1] = pbVar5 + -1;\n    if ((int)(pbVar5 + -1) < 1) {\n      iVar1 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar9 = puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar10 < puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 = (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 == puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar8 = 0;\n    uVar2 = (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 = (undefined4 *)*param_4;\n    uVar4 = *param_2;\n    *param_4 = puVar7 + 1;\n    puVar7 = (undefined4 *)*puVar7;\n    if ((uVar4 & 0x20) == 0) {\n      if ((int)(uVar4 << 0x1f) < 0) {\n        *(short *)puVar7 = (short)uVar2;\n      }\n      else {\n        *puVar7 = uVar2;\n      }\n    }\n    else {\n      *puVar7 = uVar2;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "set_flag_on_000025f4"
            },
            "code": "void set_flag_on_000025f4(void)\n{\n  set_flag_on_000025f4_0000294c_000027b0();\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "set_flag_on_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "extract_bits_and_set_calculated_offset_00001ddc",
                "param_1": "param",
                "cVar1": "extracted_bits",
                "set_calculated_offset_to_one_00001d3a": "set_calculated_offset_to_one",
                "DAT_00001e08": "DAT_00001e08"
            },
            "code": "void extract_bits_and_set_calculated_offset_00001ddc(uint16_t param)\n{\n  uint8_t extracted_bits = extract_bits_from_right(param);\n  uint8_t calculated_offset = extracted_bits + 10;\n  set_calculated_offset_to_one(DAT_00001e08, calculated_offset);\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "extract_bits_and_set_calculated_offset_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_00002ecc",
                "param_1": "device_address",
                "param_2": "data_length",
                "auStack_1c": "device_data",
                "local_14": "bytes_read"
            },
            "code": "void read_data_from_device_00002ecc(uint device_address, int data_length)\n{\n    uint bytes_read;\n    undefined4 device_data[2];\n    undefined4 device_address_pointer = *(undefined4 *)(device_address + 8);\n    undefined4 character_pointer = get_pointer_for_char(*(undefined *)(*(int *)(device_address + 0xc) + 8));\n    bytes_read = execute_device_read_function(data_length, device_data);\n\n    if ((int)bytes_read < 1)\n    {\n        process_data_error(PTR_s_error__failed_to_read_from_devic_00002f28, device_address_pointer);\n    }\n    else\n    {\n        process_data_reading(PTR_s_Reading_from___i___s__s__00002f2c, device_address_pointer, device_data[0], character_pointer);\n        display_data(device_data, bytes_read & 0xff);\n    }\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00003d64",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002fe0",
                "FUN_00002f30"
            ],
            "imported": false,
            "current_name": "read_data_from_device_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_result_to_zero_00000d76",
                "param_1": "input_value",
                "param_2": "input_flag",
                "puVar1": "result_ptr",
                "calculate_result_00000d44": "calculate_result"
            },
            "code": "void clear_result_to_zero_00000d76(int32_t input_value, uint8_t input_flag) {\n  int32_t *result_ptr;\n  result_ptr = (int32_t *)calculate_result(input_value, input_flag);\n  *result_ptr = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "clear_result_to_zero_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "process_input_000057a8",
                "param_1": "buffer_start",
                "param_2": "input_char",
                "param_3": "buffer_info",
                "iVar1": "buffer_size",
                "puVar2": "buffer_ptr"
            },
            "code": "int process_input_000057a8(undefined4 buffer_start, int input_char, undefined4 *buffer_info)\n{\n  int buffer_size = buffer_info[2] - 1;\n  buffer_info[2] = buffer_size;\n  if ((buffer_size < 0) && ((buffer_size < (int)buffer_info[6] || (input_char == 10)))) {\n    int error_code = get_error_code();\n    return error_code;\n  }\n  undefined *buffer_ptr = (undefined *)*buffer_info;\n  *buffer_info = buffer_ptr + 1;\n  *buffer_ptr = (char)input_char;\n  return input_char;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "process_input_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "param_1": "base_address",
                "param_2": "offset"
            },
            "code": "int calculate_offset_00001696(uint32_t base_address, int offset) {\n    uint32_t masked_base_address = base_address & 0xf0000000;\n    uint32_t lower_bits = base_address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int result = offset * 4 + masked_base_address + shifted_lower_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_000016ec",
                "FUN_000016c8",
                "FUN_00001710"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_Elf32_Rel_ARRAY_000008fc_000008b8",
                "local_c": "current_ptr"
            },
            "code": "int count_Elf32_Rel_ARRAY_000008fc_000008b8(void)\n{\n  int *current_ptr;\n  for (current_ptr = (int *)PTR_DAT_000008f4; (*current_ptr == DAT_000008f8 && (current_ptr < PTR_Elf32_Rel_ARRAY_000008fc)); current_ptr++)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)current_ptr) / sizeof(int);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_Elf32_Rel_ARRAY_000008fc_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "process_linked_list_000024bc",
                "param_1": "list_head",
                "uVar1": "exception_threshold",
                "uVar2": "interrupts_enabled",
                "iVar3": "next_element",
                "*param_1": "*list_head"
            },
            "code": "void process_linked_list_000024bc(int *list_head)\n{\n  bool interrupts_enabled;\n  int next_element;\n  char exception_threshold;\n  \n  interrupts_enabled = are_interrupts_enabled();\n  if (*list_head == 0) {\n    enable_interrupts_if_privileged(interrupts_enabled);\n  }\n  else if (*list_head == -1) {\n    *list_head = 0;\n    enable_interrupts_if_privileged(interrupts_enabled);\n  }\n  else {\n    next_element = get_next_element(list_head);\n    update_linked_list(next_element - 8, 10);\n    if (*list_head == 0) {\n      *list_head = -1;\n    }\n    exception_threshold = *(char *)(next_element - 3);\n    enable_interrupts_if_privileged(interrupts_enabled);\n    check_exception_threshold(exception_threshold);\n  }\n  return;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000240c",
                "FUN_00000cd0",
                "FUN_00000738"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "process_linked_list_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "count_different_values_00000490",
                "param_1": "start_index",
                "param_2": "end_index",
                "param_3": "array",
                "param_4": "array_length",
                "uVar1": "different_values_count"
            },
            "code": "int count_different_values_00000490(int start_index, int end_index, int *array, int array_length){\n    int different_values_count = 0;\n    for(int i = start_index; i < end_index; i++){\n        if(array[i] != array[i+1]){\n            different_values_count++;\n        }\n    }\n    return different_values_count;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "count_different_values_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_pointer_to_data_0000091c",
                "PTR_DAT_0000092c": "data_pointer"
            },
            "code": "const int* get_pointer_to_data_0000091c() {\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "update_data_with_bits_00001f80",
                "param_1": "input",
                "param_2": "data",
                "iVar1": "output",
                "iVar2": "six_bits",
                "uVar3": "bits",
                "uVar4": "six_bits",
                "uVar5": "original_data"
            },
            "code": "void update_data_with_bits_00001f80(uint16_t input, uint32_t data)\n{\n    uint32_t* output = convert_input_to_output(input);\n    uint8_t six_bits = extract_six_bits(input);\n    uint32_t original_data = *(output + six_bits);\n    *(output + six_bits) = data;\n    if((original_data & 0xf0000) != 0)\n    {\n        uint8_t bits = extract_bits_from_right(input);\n        uint8_t six_bits = extract_six_bits(input);\n        update_data_with_bits_00001f80(bits, six_bits);\n    }\n}",
            "called": [
                "FUN_00001dc0",
                "FUN_00001ddc",
                "FUN_00001ec4",
                "FUN_00001d5e",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001448",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "update_data_with_bits_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "update_data_bits_00000e64",
                "DAT_00000ed0": "data_address_offset",
                "DAT_00000ed4": "data_clear_address",
                "initialize_and_clear_memory_00001274": "initialize_and_clear_memory",
                "update_bits_in_data_00001eea": "update_bits_in_data",
                "set_bit_at_address_00001ff6": "set_bit_at_address"
            },
            "code": "void update_data_bits_00000e64(void)\n{\n    uint32_t *insert_address = find_and_insert_00001034 + DAT_00000ed0 + 4;\n    *insert_address |= 0x200;\n    uint32_t *clear_address = DAT_00000ed4 + 0x48;\n    *clear_address &= 0xfefff8ff;\n    initialize_and_clear_memory_00001274();\n    update_bits_in_data_00001eea(0x2056, 0x80);\n    update_bits_in_data_00001eea(0x511a, 0x80);\n    update_bits_in_data_00001eea(0x2055, 0x80);\n    set_bit_at_address_00001ff6(0x2056);\n    set_bit_at_address_00001ff6(0x511a);\n    set_bit_at_address_00001ff6(0x2055);\n}",
            "called": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001274"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "update_data_bits_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "set_flag_and_return_000026e4",
                "set_flag_in_data_section_00002970": "set_flag_in_data_section"
            },
            "code": "void set_flag_and_return_000026e4(void)\n{\n  set_flag_in_data_section();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_flag_and_return_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_result_00000d44",
                "param_1": "input_value",
                "param_2": "multiplier",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "int calculate_result_00000d44(uint32_t input_value, int multiplier) {\n    uint32_t masked_input = input_value & 0xf0000000;\n    uint32_t shifted_input = (input_value & 0xfffff) << 5;\n    int result = (multiplier * 4) + masked_input + shifted_input + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "calculate_result_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_linked_list_00000698",
                "param_1": "linked_list_index",
                "param_2": "new_value",
                "*(byte *)(param_1 + 4)": "current_value",
                "get_value_from_ptr_000005ca(PTR_DAT_00000730 + (uint)*(byte *)(param_1 + 5) * 4)": "get_value_from_linked_list",
                "*(int *)(PTR_DAT_00000730 + (uint)*(byte *)(param_1 + 5) * 4)": "value_at_linked_list_index",
                "*(uint *)PTR_DAT_00000734": "linked_list_mask",
                "*(sbyte *)(param_1 + 5)": "linked_list_mask_bit_index"
            },
            "code": "void update_linked_list_00000698(uint8_t linked_list_index, uint32_t new_value) {\n\tuint8_t current_value = *(uint8_t *)(linked_list_index + 4);\n\tif (current_value < 9) {\n\t\tuint32_t *linked_list_ptr = (uint32_t *)(PTR_DAT_00000730 + (uint32_t)*(uint8_t *)(linked_list_index + 5) * 4);\n\t\tif ((8 < current_value) && (get_value_from_ptr_000005ca(linked_list_ptr), *linked_list_ptr == 0)) {\n\t\t\t*(uint32_t *)PTR_DAT_00000734 = *(uint32_t *)PTR_DAT_00000734 & ~(1 << *(int8_t *)(linked_list_index + 5));\n\t\t}\n\t}\n\telse if (*(uint8_t *)(linked_list_index + 4) < 9) {\n\t\tupdate_linked_list_00000698_0000058e(PTR_DAT_00000730 + (uint32_t)*(uint8_t *)(linked_list_index + 5) * 4, linked_list_index + 8);\n\t\t*(uint32_t *)PTR_DAT_00000734 = *(uint32_t *)PTR_DAT_00000734 | 1 << *(int8_t *)(linked_list_index + 5);\n\t}\n\t*(uint8_t *)(linked_list_index + 4) = (uint8_t)new_value;\n\treturn;\n}",
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_000024bc",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_linked_list_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "is_irq_interrupts_enabled_00000cd0",
                "uVar2": "interrupts_enabled",
                "bVar1": "current_mode_privileged",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "isIRQinterruptsEnabled": "isIRQinterruptsEnabled",
                "disableIRQinterrupts": "disableIRQinterrupts"
            },
            "code": "bool is_irq_interrupts_enabled_00000cd0(void)\n{\n  bool current_mode_privileged = isCurrentModePrivileged();\n  bool interrupts_enabled = false;\n\n  if (current_mode_privileged) {\n    interrupts_enabled = isIRQinterruptsEnabled();\n  }\n\n  disableIRQinterrupts();\n\n  return interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_000010d4",
                "FUN_00000f8c",
                "FUN_00000794",
                "FUN_00000f04",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00000e58",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "is_irq_interrupts_enabled_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "process_and_get_interrupt_status_00000cc0",
                "uVar2": "interrupt_status",
                "bVar1": "is_privileged_mode",
                "PTR_00000ccc": "data_ptr"
            },
            "code": " \n\nuint32_t process_and_get_interrupt_status_00000cc0(void)\n{\n  uint32_t interrupt_status = 0;\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  \n  process_data(10, PTR_00000ccc);\n  \n  if (is_privileged_mode) {\n    interrupt_status = isIRQinterruptsEnabled();\n  }\n  \n  disableIRQinterrupts();\n  \n  return interrupt_status;\n}\n",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "process_and_get_interrupt_status_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "process_data_00002994",
                "DAT_000029f8": "data_address_start",
                "PTR_DAT_000029fc": "function_pointer_1",
                "PTR_DAT_000029fc + 4": "FUNCTION_POINTER_OFFSET_1",
                "PTR_DAT_000029fc + 8": "function_pointer_2",
                "PTR_DAT_000029fc + 0xc": "FUNCTION_POINTER_OFFSET_3",
                "check_and_set_data_flag_00002798": "check_and_set_data_flag",
                "iVar1": "data_address",
                "DATA_FLAG_OFFSET": "0x14",
                "DATA_FLAG_1": "4",
                "DATA_FLAG_2": "0x1c",
                "DATA_FLAG_3": "4",
                "DATA_FLAG_4": "2"
            },
            "code": "void process_data_00002994(void)\n{\n  int data_address = DAT_0000DATA_FLAG_DATA_FLAG_19f8;\n  if (((*(uint *)(DAT_0000DATA_FLAG_DATA_FLAG_19f8 + DATA_FLAG_OFFSET) & DATA_FLAG_1) != 0) && (*(int *)PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc != 0)) {\n    *(uint *)(DAT_0000DATA_FLAG_DATA_FLAG_19f8 + DATA_FLAG_DATA_FLAG_DATA_FLAG_1) = *(uint *)(DAT_0000DATA_FLAG_DATA_FLAG_19f8 + DATA_FLAG_DATA_FLAG_DATA_FLAG_1) & ~DATA_FLAG_3;\n    (**(code **)PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc)(*(undefinedDATA_FLAG_1 *)(PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc + PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc + DATA_FLAG_1));\n  }\n  if (((*(uint *)(data_address + DATA_FLAG_OFFSET) & DATA_FLAG_DATA_FLAG_1) != 0) && (*(int *)(PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc + 8 + FUNCTION_POINTER_OFFSET_DATA_FLAG_DATA_FLAG_1) != 0)) {\n    (**(code **)(PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc + 8 + FUNCTION_POINTER_OFFSET_DATA_FLAG_DATA_FLAG_1))(*(undefinedDATA_FLAG_1 *)(PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc + 8 + PTR_DAT_0000DATA_FLAG_DATA_FLAG_19fc + 0xc));\n  }\n  check_and_set_data_flag();\n  return;\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "process_data_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "bVar1": "is_privileged",
                "uVar2": "exception_number"
            },
            "code": "uint get_exception_number_00000d2a(void)\n{\n    bool is_privileged = (bool)isCurrentModePrivileged();\n    uint exception_number = 0;\n    if (is_privileged)\n    {\n        exception_number = getCurrentExceptionNumber() & 0x1f;\n    }\n    return exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_exception_number_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_bit_at_address_00001ff6",
                "param_1": "address",
                "uVar1": "bit_index",
                "iVar2": "address_to_set",
                "extract_six_bits_from_param_00001dc0": "extract_six_bits_from_param",
                "convert_param_to_address_00001d80": "convert_param_to_address"
            },
            "code": "void set_bit_at_address_00001ff6(int address)\n{\n  uint6_t bit_index = extract_six_bits_from_param(address);\n  int address_to_set = convert_param_to_address(address);\n  *(int *)(address_to_set + 4) = 1 << (bit_index & 0xff);\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_at_address_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "set_data_at_index_if_bits_not_minus_one_000013b8",
                "param_1": "index",
                "param_2": "bit_position",
                "param_3": "data_1",
                "param_4": "data_2",
                "uVar1": "result",
                "PTR_s_FAILED_ASSERTION__0000143c": "FAILED_ASSERTION_MSG",
                "PTR_DAT_00001440": "DATA_ARRAY_PTR",
                "update_data_if_bits_are_not_minus_one_00001448": "update_data_if_bits_not_minus_one",
                "set_result_to_one_if_calculated_result_not_null_00001392": "set_result_to_one_if_calculated_result_not_null",
                "PTR_DAT_00001444": "RESULT_ARRAY_PTR",
                "set_bit_at_position_000014c4": "set_bit_at_position"
            },
            "code": "int set_data_at_index_if_bits_not_minus_one_000013b8(int index, int bit_position, int data_1, int data_2) {\n  if (index != 0) {\n    process_data(3, PTR_s_FAILED_ASSERTION__0000143c);\n  }\n  *(int*)(PTR_DAT_00001440 + index * 8) = data_1;\n  *(int*)(PTR_DAT_00001440 + index * 8 + 4) = data_2;\n  update_data_if_bits_are_not_minus_one_00001448(index);\n  set_result_to_one_if_calculated_result_not_null_00001392(*(int*)(PTR_DAT_00001444 + index * 0x20 + 0x18), PTR_DAT_00001444[index * 0x20 + 0x1c]);\n  int result;\n  if (PTR_DAT_00001444[index * 0x20 + 0x1e] == 0) {\n    set_bit_at_position_000014c4(index, bit_position);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001392",
                "FUN_00000f04",
                "FUN_000014c4",
                "FUN_00001448"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "set_data_at_index_if_bits_not_minus_one_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "process_command_arguments_00002a88",
                "param_1": "command_arguments",
                "local_18": "arguments_pointer_array",
                "local_10": "index",
                "local_c": "current_argument",
                "FUNC_00004c84": "print_command_description",
                "PTR_s___20s__s_00002b04": "command_format_string",
                "PTR_s_Command_00002b00": "command_string",
                "PTR_s_Description_00002afc": "description_string",
                "process_input": "clear_screen",
                "PTR_s__________________________________00002b08": "clear_screen_format_string",
                "PTR_PTR_s_reboot_00002b0c": "reboot_string"
            },
            "code": "void process_command_arguments_00002a88(int *command_arguments)\n{\n    int *arguments_pointer_array[2];\n    uint32_t index = 0;\n    int *current_argument;\n    print_command_description(PTR_s___20s__s_00002b04, PTR_s_Command_00002b00, PTR_s_Description_00002afc);\n    clear_screen(PTR_s__________________________________00002b08);\n    arguments_pointer_array[0] = command_arguments;\n    arguments_pointer_array[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n    for (index = 0; index < 2; index = index + 1)\n    {\n        current_argument = arguments_pointer_array[index];\n        if (current_argument != (int *)0x0)\n        {\n            for (; *current_argument != 0; current_argument = current_argument + 3)\n            {\n                print_command_description(PTR_s___20s__s_00002b04, *current_argument, current_argument[1]);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "process_command_arguments_00002a88",
            "code_backup": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18 [2];\n  uint local_10;\n  int *local_c;\n  \n  FUNC_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  process_input(PTR_s__________________________________00002b08);\n  local_18[0] = param_1;\n  local_18[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    local_c = local_18[local_10];\n    if (local_c != (int *)0x0) {\n      for (; *local_c != 0; local_c = local_c + 3) {\n        FUNC_00004c84(PTR_s___20s__s_00002b04,*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "read_data_and_process_00002f30",
                "local_10": "device_count",
                "local_c": "device_data",
                "PTR_DAT_00002f6c": "device_data_ptr",
                "read_data_from_device_00002ecc": "read_data_from_device",
                "process_input": "process_data",
                "PTR_DAT_00002f70": "processing_data_ptr"
            },
            "code": "void read_data_and_process_00002f30(void)\n{\n  int device_count = 0;\n  undefined4 *device_data = *(undefined4 **)PTR_DAT_00002f6c;\n  while (device_data != (undefined4 *)0x0) {\n    read_data_from_device_00002ecc(device_count, device_data);\n    process_input(PTR_DAT_00002f70);\n    device_count++;\n    device_data = (undefined4 *)*device_data;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_data_and_process_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "update_data_at_index_00001e44",
                "param_1": "data_index",
                "param_2": "bit_offset",
                "param_3": "new_data",
                "iVar1": "byte_offset",
                "PTR_DAT_00001ec0": "data_ptr",
                "mask": "mask"
            },
            "code": "void update_data_at_index_00001e44(int data_index, uint bit_offset, int new_data) {\n  int byte_offset = (int)bit_offset >> 3;\n  uint* PTR_DAT_00001ec0 = (uint*)(PTR_DAT_00001ec0 + (byte_offset + data_index * 4) * 4);\n  uint mask = ~(0xf << ((bit_offset & 7) << 2));\n  *PTR_DAT_00001ec0 = (*PTR_DAT_00001ec0 & mask) | (new_data << ((bit_offset & 7) << 2));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "update_data_at_index_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_at_position_00001318",
                "param_1": "bit_position",
                "DAT_00001344": "DATA_START_ADDRESS",
                "*(int *)(DAT_00001344 + ((uint)(int)(char)param_1 >> 5) * 4)": "*data_pointer",
                "1 << (param_1 & 0x1f)": "bit_mask"
            },
            "code": "void set_bit_at_position_00001318(int bit_position)\n{\n    int* data_pointer = (int*)(DAT_00001344 + ((uint)(int)(char)bit_position >> 5) * 4);\n    int bit_mask = 1 << (bit_position & 0x1f);\n    *(int *)(DAT_00001344 + ((uint)(int)(char)param_1 >> 5) * 4) = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_sp"
            },
            "code": "uint32_t get_main_stack_pointer_00000900(void)\n{\n    uint32_t main_sp;\n    main_sp = getMainStackPointer();\n    return main_sp;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_with_pointer_00004274",
                "PTR_DAT_0000427c": "pointer_to_data",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_with_pointer_00004274(void* PTR_DAT_0000427c)\n{\n  do_nothing(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "process_data_00002fe0",
                "param_1": "num_params",
                "param_2": "params",
                "iVar1": "comparison_result",
                "uVar2": "device_id",
                "PTR_s_usage___s__s__device_id__all_00003050": "PTR_s_usage___s__s__device_id__all_00003050",
                "PTR_DAT_00003054": "PTR_DAT_00003054",
                "compare_bytes_00004e52": "compare_bytes",
                "read_data_and_process_00002f30": "read_and_process_data",
                "convert_string_to_uint_00004042": "convert_string_to_uint",
                "find_element_in_list_00003d24": "find_element_in_list",
                "process_input": "print_error",
                "PTR_s_error__undefined_device_id_given_00003058": "PTR_s_error__undefined_device_id_given_00003058",
                "read_data_from_device_00002ecc": "read_data_from_device"
            },
            "code": "void process_data_00002fe0(int num_params, undefined4 *params)\n{\n    int device_id;\n    undefined4 device_id_param = params[2];\n    if (num_params < 3) {\n        process_data_00002fe0_usage(PTR_s_usage___s__s__device_id__all_00003050, params[0], params[1]);\n    }\n    else {\n        int comparison_result = compare_bytes_00004e52(device_id_param, PTR_DAT_00003054);\n        if (comparison_result == 0) {\n            read_and_process_data_00002fe0();\n        }\n        else {\n            device_id = convert_string_to_uint_00004042(device_id_param);\n            int element_index = find_element_in_list_00003d24(device_id);\n            if (element_index == 0) {\n                process_input(PTR_s_error__undefined_device_id_given_00003058);\n            }\n            else {\n                read_data_from_device(device_id, element_index);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002ecc",
                "FUN_00002f30",
                "FUN_00003d24",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_data_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "extract_six_bits_from_param_00001dc0",
                "param_1": "input_param",
                "return": "extracted_bits"
            },
            "code": "ushort extract_six_bits_from_param_00001dc0(ushort input_param)\n{\n  ushort extracted_bits = input_param & 0x3f;\n  return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "extract_six_bits_from_param_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "process_linked_list_and_increment_value_00000df4",
                "PTR_increment_value_and_process_linked_list_000012b4_1_00000e10": "ptr_increment_value_and_process_linked_list",
                "DAT_00000e0c": "data",
                "set_data_at_index_if_bits_not_minus_one_000013b8": "set_data_at_index_if_bits_not_minus_one"
            },
            "code": "void process_linked_list_and_increment_value_00000df4(void)\n{\n    int index = 0;\n    int value = 0x1c200;\n    int* PTR_increment_value_and_process_linked_list_000012b4_1_00000e10 = &increment_value_and_process_linked_list_000012b4_1_00000e10;\n    int DAT_00000e0c = DAT_00000e0c;\n    set_DAT_00000e0c_at_index_if_bits_not_minus_one_000013b8(index, value, PTR_increment_value_and_process_linked_list_000012b4_1_00000e10, DAT_00000e0c);\n    return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "process_linked_list_and_increment_value_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "process_and_return_zero_from_pointers_00002eb4",
                "process_data_from_pointers_0000211c": "process_data_from_pointers"
            },
            "code": "int process_and_return_zero_from_pointers_00002eb4() {\n  process_data_from_pointers();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "process_and_return_zero_from_pointers_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "calculate_result_from_input_0000328c",
                "*param_1": "input_values",
                "*param_2": "output_values",
                "iVar1": "result",
                "local_10": "current_index",
                "local_a": "current_value"
            },
            "code": "int calculate_result_from_input_0000328c(uint32_t *input_values, int *output_values)\n{\n    int current_index = 0;\n    uint32_t current_value = convert_string_to_uint(input_values[current_index], &current_index, 10);\n    output_values[5] = current_value - 0x76c;\n    current_value = convert_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n    output_values[4] = current_value - 1;\n    current_value = convert_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n    output_values[3] = current_value;\n    current_value = convert_string_to_uint(input_values[1], &current_index, 10);\n    output_values[2] = current_value;\n    current_value = convert_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n    output_values[1] = current_value;\n    current_value = convert_string_to_uint(input_values[current_index] + 1, &current_index, 10);\n    output_values[0] = current_value;\n    int result = calculate_result(output_values[5] + 0x76c, output_values[4] + 1, output_values[3]);\n    output_values[6] = result;\n    output_values[8] = -1;\n    return 0;\n}",
            "called": [
                "FUN_00004f84",
                "FUN_000031fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_000033f4",
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "calculate_result_from_input_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "puVar1": "pointer_var",
                "fill_memory_with_value_00004622": "fill_memory_with_value"
            },
            "code": "void initialize_data_000041f4(undefined4 *data, undefined2 value1, undefined2 value2) {\n    data[0] = 0;\n    data[1] = 0;\n    data[2] = 0;\n    data[3] = value1;\n    data[4] = 0;\n    data[5] = 0;\n    data[6] = 0;\n    data[7] = 0;\n    data[8] = data;\n    data[9] = PTR_count_different_values_wrapper_00004dc8_1_0000422c;\n    data[10] = DAT_00004230;\n    data[11] = PTR_set_param_to_19_000004f2_wrapper_00004e26_1_00004234;\n    data[12] = PTR_LAB_00004e4a_1_00004238;\n}",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_data_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "process_device_data_if_write_0000316c",
                "param_1": "devices_count",
                "param_2": "device_info",
                "iVar1": "compare_result",
                "print_devices_info_00002f74": "print_devices_info",
                "compare_bytes_00004e52": "compare_bytes",
                "process_data_00002fe0": "process_data",
                "process_device_data_0000305c": "process_device_data",
                "process_data_00004c84": "process_data",
                "PTR_DAT_000031d4": "PTR_DAT_000031d4",
                "PTR_s_write_000031d8": "PTR_s_write_000031d8",
                "PTR_s_usage___s_read_write_000031dc": "PTR_s_usage___s_read_write_000031dc"
            },
            "code": "int process_device_data_if_write_0000316c(int devices_count, undefined4 *device_info)\n{\n    int compare_result = compare_bytes_00004e52(device_info[1],PTR_DAT_000031d4);\n    if (devices_count < 2)\n    {\n        print_devices_info_00002f74();\n    }\n    else\n    {\n        if (compare_result == 0)\n        {\n            process_data_00004c84(devices_count,device_info);\n        }\n        else\n        {\n            compare_result = compare_bytes_00004e52(device_info[1],PTR_s_write_000031d8);\n            if (compare_result == 0)\n            {\n                process_device_data(devices_count,device_info);\n            }\n            else\n            {\n                process_data(PTR_s_usage___s_read_write_000031dc,*device_info);\n            }\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00004e52",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "process_device_data_if_write_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "execute_function_if_not_null_000026f0",
                "param_1": "parameter",
                "PTR_DAT_00002710": "data_pointer",
                "*(int *)PTR_DAT_00002710": "*data_pointer",
                "code": "function_pointer",
                "**(code **)PTR_DAT_00002710": "*function_pointer",
                "(***(code **)PTR_DAT_00002710)(param_1)": "(*function_pointer)(parameter)"
            },
            "code": "void execute_function_if_not_null_000026f0(int parameter) {\n  int* PTR_DAT_00002710 = (int*)PTR_DAT_00002710;\n  if (*(int *)PTR_DAT_00002710 != 0) {\n    code* function_pointer = *(code**)PTR_DAT_00002710;\n    (***(code **)PTR_DAT_00002710)(param_1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_not_null_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_input_000057d2",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_string",
                "param_4": "string_length",
                "puVar2": "end_of_string",
                "iVar1": "result",
                "iVar3": "current_index"
            },
            "code": "int process_input_000057d2(int input_1, int input_2, char *input_string, int string_length) {\n  int current_index = 0;\n  char *end_of_string = input_string + string_length;\n  int result = 0;\n  while (current_index != string_length) {\n    if (input_string == end_of_string) {\n      return 0;\n    }\n    result = process_input_000057d2_000057a8(input_1, *input_string, input_2, string_length, current_index);\n    current_index = result + 1;\n    input_string++;\n  }\n  return result;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_input_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_param_and_set_flag_000056b8",
                "param_1": "param_1",
                "param_2": "param_2",
                "param_3": "flag_ptr",
                "param_4": "result_ptr",
                "iVar1": "stack_value",
                "uVar2": "local_flag",
                "auStack_68": "stack_value",
                "local_64": "local_flag"
            },
            "code": "int check_param_and_set_flag_000056b8(int param_1, int param_2, int *flag_ptr, unsigned int *result_ptr)\n{\n    int stack_value;\n    unsigned int local_flag;\n\n    if (*(short *)(param_2 + 0xE) < 0 || set_param_to_19_00000514(param_1, *(short *)(param_2 + 0xE), &stack_value) < 0)\n    {\n        *result_ptr = 0;\n        if ((int)((uint)*(ushort *)(param_2 + 0xC) << 0x18) < 0)\n        {\n            local_flag = 0x40;\n            goto LAB_000056f8;\n        }\n    }\n    else\n    {\n        *result_ptr = (unsigned int)((local_flag & 0xF000) == 0x2000);\n    }\n\n    local_flag = 0x400;\nLAB_000056f8:\n    *flag_ptr = local_flag;\n    return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_param_and_set_flag_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_offset_to_one_and_clear_six_bytes_00001a18",
                "DAT_00001a34": "DAT_buffer",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "clear_six_bytes_at_offset_00001710_00001734": "clear_six_bytes_at_offset",
                "PTR_DAT_00001a38": "PTR_result"
            },
            "code": "void set_offset_to_one_and_clear_six_bytes_00001a18(void)\n{\n  set_offset_to_one(DAT_00001a34, 1);\n  clear_six_bytes_at_offset();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_offset_to_one_and_clear_six_bytes_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_result_to_zero_00000d9c",
                "DAT_00000dac": "result",
                "clear_result_to_zero_00000d76": "clear_result_to_zero"
            },
            "code": "void clear_result_to_zero_00000d9c(void)\n{\n  clear_result_to_zero_00000d9c(DAT_00000dac, 0);\n  return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "clear_result_to_zero_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "reverse_and_fill_00003ff4",
                "param_1": "buffer_size",
                "param_2": "start_index",
                "param_3": "end_index",
                "param_4": "fill_value",
                "uVar1": "new_end_index",
                "reverse_copy_within_buffer_000045ee": "reverse_copy_within_buffer",
                "fill_memory_with_value_00004622": "fill_memory_with_value"
            },
            "code": "uint reverse_and_fill_00003ff4(uint buffer_size, uint start_index, uint end_index, undefined fill_value)\n{\n  uint new_end_index;\n  \n  new_end_index = end_index;\n  if ((start_index < end_index) && (buffer_size != 0)) {\n    reverse_copy_within_buffer((end_index - start_index) + buffer_size, start_index, end_index);\n    fill_memory_with_value(start_index, fill_value, end_index - start_index);\n  }\n  return new_end_index;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "reverse_and_fill_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    calculate_quotient_and_remainder_00005584(&local_20,*param_1,0x3c);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    calculate_quotient_and_remainder_00005584(&local_20,param_1[1],0x3c);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    calculate_quotient_and_remainder_00005584(&local_20,param_1[2],0x18);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    calculate_quotient_and_remainder_00005584(&local_20,param_1[4],0xc);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAT_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "convert_param_to_output_00001d5e",
                "param_1": "input_param",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint convert_param_to_output_00001d5e(ushort input_param) {\n    uint output = (input_param & 0x7000) | 0x40048000;\n    return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001f80",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "convert_param_to_output_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "set_memory_flag_and_wait_for_update_0000191c",
                "set_memory_flag_00001778": "set_memory_flag",
                "update_bitfield_00001748": "update_bitfield",
                "*DAT_00001958": "*memory_data",
                "*PTR_DAT_0000195c": "*memory_pointer"
            },
            "code": "void set_memory_flag_and_wait_for_update_0000191c(void)\n{\n  set_memory_flag();\n  update_bitfield(0x40);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((memory_data[6] & 0xc) != 0);\n  *PTR_DAT_0000195c = 1;\n  return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_memory_flag_and_wait_for_update_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_pointer_to_data_000050f4",
                "PTR_DAT_000050fc": "pointer_to_data"
            },
            "code": "char* get_pointer_to_data_000050f4() {\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "decode_data_00005a58",
                "param_1": "data",
                "param_2": "data_len",
                "param_3": "decoded_len",
                "param_4": "param_4",
                "param_5": "decoder",
                "iVar1": "i",
                "uVar2": "result",
                "uVar3": "max_len",
                "uVar4": "remaining_len",
                "bVar5": "has_offset",
                "offset": "offset",
                "j": "j"
            },
            "code": "undefined4 decode_data_00005a58(undefined4 data, uint *data_len, uint *decoded_len, undefined4 param_4, code *decoder) {\n  int i;\n  undefined4 result;\n  uint max_len = data_len[4];\n  if ((int)data_len[4] < (int)data_len[2]) {\n    max_len = data_len[2];\n  }\n  *decoded_len = max_len;\n  if (*(char *)((int)data_len + 0x43) != '\\0') {\n    *decoded_len = max_len + 1;\n  }\n  if ((int)(*data_len << 0x1a) < 0) {\n    *decoded_len += 2;\n  }\n  uint offset = *data_len & 6;\n  if (offset == 0) {\n    for (; (int)offset < (int)(data_len[3] - *decoded_len); offset++) {\n      i = (*decoder)(data, param_4, (int)data_len + 0x19, 1);\n      if (i == -1) goto LAB_00005afc;\n    }\n  }\n  offset = (uint)*(byte *)((int)data_len + 0x43);\n  if (offset != 0) {\n    offset = 1;\n  }\n  if ((int)(*data_len << 0x1a) < 0) {\n    *(undefined *)((int)data_len + offset + 0x43) = 0x30;\n    *(undefined *)((int)data_len + offset + 0x44) = *(undefined *)((int)data_len + 0x45);\n    offset += 2;\n  }\n  i = (*decoder)(data, param_4, (int)data_len + 0x43, offset);\n  if (i == -1) {\n    result = 0xffffffff;\n  }\n  else {\n    uint remaining_len = data_len[3];\n    bool has_offset = (*data_len & 6) == 4;\n    if (has_offset) {\n      remaining_len = remaining_len - *decoded_len;\n    }\n    if (has_offset) {\n      remaining_len &= ~((int)remaining_len >> 0x1f);\n    }\n    else {\n      remaining_len = 0;\n    }\n    if ((int)data_len[4] < (int)data_len[2]) {\n      remaining_len += (data_len[2] - data_len[4]);\n    }\n    for (uint j = 0; remaining_len != j; j++) {\n      i = (*decoder)(data, param_4, (int)data_len + 0x1a, 1);\n      if (i == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "decode_data_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_data_value_000056b0",
                "DAT_000056b4": "data_value"
            },
            "code": "int get_data_value_000056b0(void)\n{\n    return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_data_value_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "find_element_in_list_00003d24",
                "param_1": "list_length",
                "local_c": "current_element",
                "local_10": "current_index"
            },
            "code": "undefined4* find_element_in_list_00003d24(int list_length) {\n  undefined4* current_element = *(undefined4**)PTR_DAT_00003d60;\n  int current_index = 0;\n  while (current_index < list_length && current_element != (undefined4*)0x0) {\n    current_element = (undefined4*)*current_element;\n    current_index++;\n  }\n  return current_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "find_element_in_list_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_or_copy_data_000060cc",
                "param_1": "address",
                "param_2": "source_index",
                "param_3": "destination_index",
                "param_4": "data",
                "uVar1": "new_address",
                "uVar2": "new_index"
            },
            "code": "uint allocate_or_copy_data_000060cc(uint address, uint source_index, uint destination_index, uint data)\n{\n  uint new_address;\n  uint new_index;\n  \n  if (source_index != 0) {\n    if (destination_index == 0) {\n      update_list();\n      new_address = destination_index;\n    }\n    else {\n      new_index = calculate_new_index();\n      new_address = source_index;\n      if ((new_index < destination_index) && (new_address = allocate_memory(address, destination_index), new_address != 0)) {\n        copy_data_to_destination(new_address, source_index, destination_index);\n        update_list(address, source_index);\n      }\n    }\n    return new_address;\n  }\n  new_address = allocate_memory(address, destination_index, destination_index, data);\n  return new_address;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_00006964",
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "allocate_or_copy_data_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "count_digits_00003dc4",
                "param_1": "num",
                "param_2": "base",
                "local_20": "remainder",
                "local_14": "output",
                "local_10": "digit_count",
                "local_c": "count"
            },
            "code": "int count_digits_00003dc4(int num, uint base) {\n    uint remainder;\n    char *output;\n    uint digit_count;\n    int count = 1;\n    if (DAT_00003e50 < base) {\n        count = 10;\n    }\n    else {\n        for (digit_count = 10; digit_count <= base; digit_count = digit_count * 10) {\n            count++;\n        }\n    }\n    if (num != 0) {\n        output = (char *)(count + num);\n        remainder = base;\n        do {\n            output--;\n            *output = (char)remainder + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10 + '0';\n            remainder = (uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n        } while (remainder != 0);\n    }\n    return count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "count_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_set_value_at_address_000022be",
                "param_1": "data_ptr",
                "param_2": "value",
                "uVar1": "index",
                "PTR_": "data_ptr",
                "DAT_": "value"
            },
            "code": "void increment_and_set_value_at_address_000022be(int *PTR_, undefined DAT_){\n  uint index = PTR_[3];\n  PTR_[3] = index + 1;\n  uint address = (index & PTR_[1] - 1U) + *PTR_;\n  *(undefined *)(address) = DAT_;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_set_value_at_address_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "extract_bits_and_call_function_00002108",
                "DAT_00002118": "data",
                "extract_bits_and_call_function_00002028": "extract_bits_and_call_function",
                "4": "num_bits"
            },
            "code": "void extract_bits_and_call_function_00002108(uint8_t* DAT_00002118, uint8_t num_bits)\n{\n  extract_bits_and_call_function_00002108_00002028(DAT_00002118, num_bits);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "convert_param_to_address_00001d80",
                "param_1": "param"
            },
            "code": "uint convert_param_to_address_00001d80(ushort param) {\n    uint address = (param & 0x1c0) | 0x400ff000;\n    return address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "convert_param_to_address_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "check_alarm_was_set_000033c0",
                "iVar1": "date_plus_one_pointer_value",
                "auStack_2c": "alarm_info",
                "calculate_date_plus_one_pointer_value_00002690": "calculate_date_plus_one_pointer_value",
                "process_input": "print_error_message",
                "PTR_s_rtc__error_getting_alarm_000033f0": "error_message"
            },
            "code": "bool check_alarm_was_set_000033c0(void)\n{\n  int date_plus_one_pointer_value;\n  undefined alarm_info[36];\n  date_plus_one_pointer_value = calculate_date_plus_one_pointer_value(alarm_info);\n  if (date_plus_one_pointer_value != 0) {\n    process_input(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    calculate_something(alarm_info);\n  }\n  return date_plus_one_pointer_value != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_alarm_was_set_000033c0",
            "code_backup": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_date_plus_one_pointer_value_00002690(auStack_2c);\n  if (iVar1 != 0) {\n    process_input(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    calculate_something_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_command_line_args_00002b10",
                "param_1": "argc",
                "param_2": "argv",
                "local_48": "arg_list",
                "local_3c": "command_handler",
                "local_38": "current_arg",
                "local_34": "arg_count",
                "local_2d": "escape_char",
                "local_2c": "current_escape_char",
                "local_28": "current_char",
                "local_24": "arg_list_ptr",
                "local_20": "i",
                "local_1c": "escape_count",
                "local_18": "arg_count",
                "local_14": "current_char_ptr"
            },
            "code": "void parse_command_line_args_00002b10(uint32_t argc, char **argv) {\\n    int escape_count = 0;\\n    char *current_arg;\\n    char **arg_list;\\n    uint32_t arg_count = 0;\\n    char escape_char;\\n    code *command_handler;\\n\\n    arg_list = (char **) ((int) argv - ((argc + 1) * 4 + 7 & 0xFFFFFFF8));\\n    arg_list[argc] = NULL;\\n    current_arg = *argv;\\n\\n    while (*current_arg != 0) {\\n        if (*current_arg > 0x20) {\\n            if (*current_arg == \"\\\"\" || *current_arg == \"\\\"\") {\\n                escape_char = *current_arg;\\n                do {\\n                    current_arg++;\\n                    if (*current_arg == 0) {\\n                        print_error(\\\"Error: Unterminated string.\\\");\\n                        return;\\n                    }\\n                    if (*current_arg == \"\\\\\") {\\n                        escape_count++;\\n                        current_arg++;\\n                        if (*current_arg == 0) {\\n                            print_error(\\\"Error: Unterminated string.\\\");\\n                            return;\\n                        }\\n                    }\\n                } while (escape_char != *current_arg);\\n                if (current_arg[1] > 0x20) {\\n                    print_error(\\\"Error: Invalid argument.\\\");\\n                    return;\\n                }\\n            } else {\\n                do {\\n                    if (*current_arg == \"\\\\\") {\\n                        escape_count++;\\n                        current_arg++;\\n                        if (*current_arg == 0) {\\n                            print_error(\\\"Error: Unterminated string.\\\");\\n                            return;\\n                        }\\n                    }\\n                    current_arg++;\\n                    if (*current_arg == \"\\\"\") {\\n                        print_error(\\\"Error: Invalid argument.\\\");\\n                        return;\\n                    }\\n                } while (*current_arg > 0x20);\\n            }\\n            arg_count++;\\n        }\\n        *current_arg = 0;\\n        current_arg++;\\n    }\\n\\n    if (arg_count != 0) {\\n        command_handler = (code *) search_in_memory_00002a18(argc, arg_list);\\n        if (command_handler == NULL) {\\n            if (compare_bytes_00004e52(PTR_DAT_00002d8c, arg_list) == 0) {\\n                process_command_arguments_00002a88(argv[1]);\\n            } else {\\n                process_data_00004c84(PTR_s_shell__command_not_found___s_00002d90, arg_list);\\n            }\\n        } else {\\n            (*command_handler)(arg_count, arg_list);\\n        }\\n    }\\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002a88",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_command_line_args_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "perform_task_based_on_input_00001b10",
                "param_1": "input",
                "uVar1": "result",
                "PTR_DAT_00001bb4": "task_list",
                "PTR_DAT_00001bb0": "task_list_start"
            },
            "code": "uint32_t perform_task_based_on_input_00001b10(byte input) {\n  uint32_t result;\n  if (input < 8) {\n    do {\n      switch(PTR_DAT_00001bb4[(uint)input + (uint)(byte)*PTR_DAT_00001bb0 * 8]) {\n      case 0:\n        perform_task_000018bc();\n        break;\n      case 1:\n        set_memory_flag_and_wait_for_update_0000191c();\n        break;\n      case 2:\n        update_bitfield_and_clear_memory_00001960();\n        break;\n      case 3:\n        set_memory_flag_and_update_bitfield_000019c0();\n        break;\n      case 4:\n        set_offset_to_one_and_clear_six_bytes_00001a18();\n        break;\n      case 5:\n        main_function_00001a3c();\n        break;\n      case 6:\n        clear_memory_and_set_flag_00001a60();\n        break;\n      case 7:\n        clear_bits_and_wait_until_condition_met_00001ad4();\n        break;\n      default:\n        return 0xffffffff;\n      }\n    } while (input != *PTR_DAT_00001bb0);\n    result = 0;\n  }\n  else {\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001960",
                "FUN_00001ad4",
                "FUN_00001a3c",
                "FUN_0000191c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "perform_task_based_on_input_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUNC_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 = (int *)get_data_value_000056b0();\n  FUNC_00004634(param_1);\n  uVar12 = param_1[5];\n  iVar11 = param_1[3] + -1 + *(int *)(PTR_DAT_00004adc + param_1[4] * 4);\n  if (((1 < param_1[4]) && ((uVar12 & 3) == 0)) &&\n     ((uVar12 != (uVar12 / 100) * 100 || (uVar12 + 0x76c == ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 = iVar11 + 1;\n  }\n  param_1[7] = iVar11;\n  if (20000 < (int)&PTR_DAT_00002710 + uVar12) {\n    iVar7 = -1;\n    iVar5 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 < 0x47) {\n    if (uVar12 != 0x46) {\n      for (uVar9 = 0x45; (int)uVar12 < (int)uVar9; uVar9 = uVar9 - 1) {\n        if ((uVar9 & 3) == 0) {\n          if (uVar9 == (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 == 0) {\n              iVar7 = 0x16e;\n            }\n            else {\n              iVar7 = 0x16d;\n            }\n          }\n          else {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16d;\n        }\n        iVar11 = iVar11 - iVar7;\n      }\n      if ((uVar9 & 3) == 0) {\n        if (uVar12 == (uVar12 / 100) * 100) {\n          iVar7 = 0x16d;\n          if ((uVar12 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      iVar11 = iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 = 0x46;\n    do {\n      if ((uVar9 & 3) == 0) {\n        if (uVar9 % 100 == 0) {\n          if ((uVar9 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n          else {\n            iVar7 = 0x16d;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      uVar9 = uVar9 + 1;\n      iVar11 = iVar11 + iVar7;\n    } while (uVar12 != uVar9);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar11 +\n          (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1);\n  uVar15 = (uint)lVar1;\n  iVar7 = (int)((ulonglong)lVar1 >> 0x20);\n  get_data_pointer_000050e8();\n  FUNC_00005100();\n  uVar9 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    uVar12 = piVar3[10];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 = param_1[8];\n    uVar13 = uVar14;\n    if (0 < (int)uVar14) {\n      uVar13 = 1;\n    }\n    if ((piVar3[1] == param_1[5] + 0x76c) || (iVar5 = calculate_date_00004f98(), iVar5 != 0)) {\n      uVar10 = piVar3[0x14];\n      uVar4 = piVar3[0x12];\n      uVar8 = piVar3[10];\n      uVar9 = uVar4 - uVar8;\n      iVar5 = (piVar3[0x13] - ((int)uVar8 >> 0x1f)) - (uint)(uVar4 < uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n           (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9)))) &&\n         (iVar6 = (piVar3[0x13] - ((int)uVar10 >> 0x1f)) - (uint)(uVar4 < uVar10),\n         bVar16 = uVar15 < uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 = piVar3[8] - uVar10;\n      iVar6 = (piVar3[9] - ((int)uVar10 >> 0x1f)) - (uint)((uint)piVar3[8] < uVar10);\n      if (*piVar3 != 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 ==\n            (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 = 0;\n        if ((int)uVar14 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 = uVar13 ^ uVar9;\n        uVar13 = uVar9;\n        if (uVar15 == 1) {\n          if (uVar9 == 0) {\n            iVar7 = uVar10 - uVar8;\n          }\n          else {\n            iVar7 = uVar8 - uVar10;\n          }\n          iVar5 = param_1[3];\n          *param_1 = *param_1 + iVar7;\n          lVar2 = lVar1 + iVar7;\n          FUNC_00004634(param_1);\n          iVar5 = param_1[3] - iVar5;\n          lVar1 = lVar1 + iVar7;\n          if (iVar5 != 0) {\n            if (iVar5 < 2) {\n              if (iVar5 == -2 || iVar5 + 2 < 0 != SCARRY4(iVar5,2)) {\n                iVar5 = 1;\n              }\n            }\n            else {\n              iVar5 = -1;\n            }\n            iVar7 = iVar5 + param_1[7];\n            iVar11 = iVar11 + iVar5;\n            if (iVar7 < 0) {\n              uVar9 = uVar12 - 1;\n              if ((uVar9 & 3) == 0) {\n                if (uVar9 == (uVar9 / 100) * 100) {\n                  iVar7 = 0x16d;\n                  if ((uVar12 + 0x76b) % 400 != 0) {\n                    iVar7 = 0x16c;\n                  }\n                }\n                else {\n                  iVar7 = 0x16d;\n                }\n              }\n              else {\n                iVar7 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 & 3) == 0) {\n                if (uVar12 == (uVar12 / 100) * 100) {\n                  iVar5 = 0x16d;\n                  if ((uVar12 + 0x76c) % 400 == 0) {\n                    iVar5 = 0x16e;\n                  }\n                }\n                else {\n                  iVar5 = 0x16e;\n                }\n              }\n              else {\n                iVar5 = 0x16d;\n              }\n              if (iVar5 <= iVar7) {\n                iVar7 = iVar7 - iVar5;\n              }\n            }\n            param_1[7] = iVar7;\n            lVar1 = lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 !=\n          (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n            (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar14) {\n        uVar9 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 = uVar13;\n      if (uVar13 != 1) goto LAB_00004934;\n    }\n    uVar12 = piVar3[0x14];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 = 1;\n  }\n  get_pointer_to_data_000050f4();\n  param_1[8] = uVar9;\n  param_1[6] = (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
            "called": [
                "FUN_00004634",
                "FUN_000050e8",
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_000050f4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "send_software_interrupt_000023c8",
                "0x3f": "SWI_EXIT"
            },
            "code": "void send_software_interrupt_000023c8(void)\n{\n  software_interrupt(SWI_EXIT);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "send_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "process_input_and_data_00002e48",
                "*(undefined4 *)(*DAT_00002e68 + 8)": "data_ptr",
                "process_input_00002a00": "process_input",
                "process_data_000041d0_000041d0": "process_data",
                "0x3e": "input1",
                "0x20": "input2",
                "*DAT_00002e68": "data"
            },
            "code": "void process_input_and_data_00002e48(void)\n{\n  int input1 = 0x3e;\n  int input2 = 0x20;\n  int* *(undefined4 *)(*DAT_00002e68 + 8) = (int*)(*DAT_00002e68 + 8);\n  int *DAT_00002e68 = **(undefined4 *)(*DAT_00002e68 + 8);\n  process_input_00002a00(input1);\n  process_input_00002a00(input2);\n  process_*DAT_00002e68_000041d0_000041d0(*DAT_00002e68);\n  return;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_000041d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_and_data_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "run_software_interrupt_and_wait_00000930",
                "is_irq_interrupts_enabled_00000cf0": "is_irq_interrupts_enabled",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void run_software_interrupt_and_wait_00000930(void)\n{\n  bool interrupts_enabled = is_irq_interrupts_enabled();\n  software_interrupt(1);\n  while(true);\n}\n",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "run_software_interrupt_and_wait_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_and_set_flag_on_data_address_00001348",
                "PTR_DAT_0000135c": "data_address",
                "set_flag_on_data_address_0000093c": "set_flag_on_data_address"
            },
            "code": "void check_and_set_flag_on_data_address_00001348(void)\n{\n  int* PTR_DAT_0000135c = (int*)PTR_DAT_0000135c;\n  if (*PTR_DAT_0000135c != 0)\n  {\n    set_flag_on_PTR_DAT_0000135c_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "check_and_set_flag_on_data_address_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_calculated_offset_to_one_00001d3a",
                "param_1": "base_offset",
                "param_2": "offset_value",
                "puVar1": "offset_ptr",
                "*puVar1": "*offset_ptr",
                "calculate_offset_00001d08": "calculate_offset"
            },
            "code": "void set_calculated_offset_to_one_00001d3a(int base_offset, unsigned char offset_value)\n{\n  int *offset_ptr;\n  offset_ptr = (int *)calculate_offset(base_offset, offset_value);\n  *offset_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_calculated_offset_to_one_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "allocate_memory_00002434",
                "param_1": "memory_block",
                "param_2": "block_size",
                "uVar1": "irq_enabled",
                "iVar2": "linked_list_head"
            },
            "code": "int allocate_memory_00002434(int *memory_block, int block_size)\n{\n  int irq_enabled;\n  int linked_list_head;\n  irq_enabled = is_irq_interrupts_enabled_00000cd0();\n  if (*memory_block == 0) {\n    *memory_block = -1;\n    enable_IRQ_interrupts_if_privileged_00000d0c(irq_enabled);\n    irq_enabled = 1;\n  }\n  else if (block_size == 0) {\n    enable_IRQ_interrupts_if_privileged_00000d0c(irq_enabled);\n    irq_enabled = 0;\n  }\n  else {\n    linked_list_head = *(int *)PTR_DAT_000024b8;\n    update_linked_list_00000698(linked_list_head,2);\n    if (*memory_block == -1) {\n      *memory_block = linked_list_head + 8;\n      *(undefined4 *)*memory_block = 0;\n    }\n    else {\n      find_and_insert_00001034(memory_block,linked_list_head);\n    }\n    enable_IRQ_interrupts_if_privileged_00000d0c(irq_enabled);\n    set_flag_on_data_address_0000093c();\n    irq_enabled = 1;\n  }\n  return irq_enabled;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00001034",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "allocate_memory_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_memory_and_set_flag_00005700",
                "param_1": "base_address",
                "param_2": "input_values",
                "uVar1": "flag_value",
                "iVar2": "memory_size",
                "local_18": "new_base_address",
                "local_14": "local_input_values"
            },
            "code": "void allocate_memory_and_set_flag_00005700(int base_address, int *input_values)\n{\n  ushort flag_value;\n  int memory_size;\n  int new_base_address;\n  int *local_input_values;\n  \n  if ((int)((uint)*(ushort *)(input_values + 3) << 0x1e) >= 0)\n  {\n    local_input_values = input_values;\n    new_base_address = base_address;\n    flag_value = check_param_and_set_flag(new_base_address, input_values, &new_base_address, &local_input_values);\n    memory_size = allocate_memory(new_base_address, local_input_values);\n    if (memory_size != 0)\n    {\n      *(undefined **)(base_address + 0x28) = PTR_DAT_0000577c;\n      *input_values = memory_size;\n      *(ushort *)(input_values + 3) = *(ushort *)(input_values + 3) | 0x80;\n      input_values[5] = new_base_address;\n      input_values[4] = memory_size;\n      if ((local_input_values != (int *)0x0) && (check_valid_input(new_base_address, (int)*(short *)((int)input_values + 0xe)) != 0))\n      {\n        *(ushort *)(input_values + 3) = *(ushort *)(input_values + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(input_values + 3) = flag_value | *(ushort *)(input_values + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(input_values + 3) << 0x16 < 0)\n    {\n      return;\n    }\n    *(ushort *)(input_values + 3) = *(ushort *)(input_values + 3) & 0xfffc | 2;\n  }\n  *input_values = (int)input_values + 0x47;\n  input_values[4] = (int)input_values + 0x47;\n  input_values[5] = 1;\n  return;\n}",
            "called": [
                "FUN_00000534",
                "FUN_00004bd0",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "allocate_memory_and_set_flag_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_and_set_data_flag_00002798",
                "PTR_DAT_000027ac": "data_ptr",
                "set_flag_on_data_address_0000093c": "set_data_flag",
                "*PTR_DAT_000027ac": "*data_ptr"
            },
            "code": "void check_and_set_data_flag_00002798(void)\n{\n  int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0) {\n    set_flag_on_data_address_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "check_and_set_data_flag_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_commands_00003524",
                "param_1": "num_commands",
                "param_2": "command_array",
                "iVar1": "comparison_result",
                "uVar2": "return_value",
                "initialize_rtc_commands_000034c0": "initialize_rtc_commands",
                "compare_bytes_00004e66": "compare_bytes",
                "PTR_s_poweron_00003638": "PTR_s_poweron",
                "set_flag_and_return_000026d8": "set_flag_and_return",
                "PTR_s_poweroff_0000363c": "PTR_s_poweroff",
                "set_flag_and_return_000026e4": "set_flag_and_return",
                "PTR_s_clearalarm_00003640": "PTR_s_clearalarm",
                "clear_flags_and_initialize_data_000026c0": "clear_flags_and_initialize_data",
                "PTR_s_getalarm_00003644": "PTR_s_getalarm",
                "check_alarm_was_set_000033c0": "check_alarm_was_set",
                "PTR_s_setalarm_00003648": "PTR_s_setalarm",
                "calculate_result_and_execute_function_with_bit_and_byte_position_000033f4": "calculate_result_and_execute_function_with_bit_and_byte_position",
                "PTR_s_gettime_0000364c": "PTR_s_gettime",
                "check_date_validity_00003444": "check_date_validity",
                "PTR_s_settime_00003650": "PTR_s_settime",
                "process_data_00004c84": "process_data",
                "PTR_s_unknown_command_or_missing_param_00003654": "PTR_s_unknown_command_or_missing_param",
                "process_input_and_set_flag_00003478": "process_input_and_set_flag"
            },
            "code": "undefined4 process_rtc_commands_00003524(int num_commands, int command_array)\n{\n    int comparison_result;\n    undefined4 return_value;\n\n    if (num_commands < 2) {\n        initialize_rtc_commands();\n        return_value = 1;\n    }\n    else {\n        comparison_result = compare_bytes(command_array + 4, PTR_s_poweron_00003638, 7);\n        if (comparison_result == 0) {\n            set_flag_and_return();\n        }\n        else {\n            comparison_result = compare_bytes(command_array + 4, PTR_s_poweroff_0000363c, 8);\n            if (comparison_result == 0) {\n                set_flag_and_return();\n            }\n            else {\n                comparison_result = compare_bytes(command_array + 4, PTR_s_clearalarm_00003640, 8);\n                if (comparison_result == 0) {\n                    clear_flags_and_initialize_data();\n                }\n                else {\n                    comparison_result = compare_bytes(command_array + 4, PTR_s_getalarm_00003644, 8);\n                    if (comparison_result == 0) {\n                        check_alarm_was_set();\n                    }\n                    else {\n                        comparison_result = compare_bytes(command_array + 4, PTR_s_setalarm_00003648, 8);\n                        if ((comparison_result == 0) && (num_commands == 4)) {\n                            calculate_result_and_execute_function_with_bit_and_byte_position(command_array + 8);\n                        }\n                        else {\n                            comparison_result = compare_bytes(command_array + 4, PTR_s_gettime_0000364c, 7);\n                            if (comparison_result == 0) {\n                                check_date_validity();\n                            }\n                            else {\n                                comparison_result = compare_bytes(command_array + 4, PTR_s_settime_00003650, 7);\n                                if ((comparison_result != 0) || (num_commands != 4)) {\n                                    process_data(PTR_s_unknown_command_or_missing_param_00003654, *(undefined4 *)(command_array + 4));\n                                    initialize_rtc_commands();\n                                    return 1;\n                                }\n                                process_input_and_set_flag(command_array + 8);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return_value = 0;\n    }\n    return return_value;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000026c0",
                "FUN_00003478",
                "FUN_000033f4",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00004e66",
                "FUN_000034c0",
                "FUN_000033c0",
                "FUN_000026e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_commands_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "clear_memory_00001bb8",
                "DAT_00001c74": "memory",
                "DAT_00001c78": "offset_1",
                "DAT_00001c7c": "offset_2",
                "PTR_DAT_00001c80": "PTR_memory"
            },
            "code": "void clear_memory_00001bb8(int offset, int size)\n{\n  if ((DAT_00001c74[offset+1] & 2) != 0) {\n    clear_memory_00001bb8_at_offset(DAT_00001c74[offset+2], 1);\n  }\n  if ((DAT_00001c74[offset+5] & 0x40) != 0) {\n    if ((DAT_00001c74[offset] & 0xc0) == 0) {\n      DAT_00001c74[offset] = DAT_00001c74[offset] & 0x3f | 0x80;\n      while ((DAT_00001c74[offset+6] & 0xc) != 8);\n    }\n    clear_memory_00001bb8_at_offset(DAT_00001c74[offset+3], 6);\n    while ((DAT_00001c74[offset+6] & 0x20) != 0);\n  }\n  update_bitfield(0);\n  DAT_00001c74[offset] = DAT_00001c74[offset] & 0x3b | 4;\n  while ((DAT_00001c74[offset+6] & 0x10) == 0);\n  while ((DAT_00001c74[offset+6] & 0xc) != 0);\n  *PTR_DAT_00001c80 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_memory_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "do_nothing_with_data_pointer_0000428c",
                "DAT_00004294": "data_ptr",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_with_data_pointer_0000428c(void* DAT_00004294)\n{\n  do_nothing(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_pointer_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "info",
                "iVar1": "result",
                "piVar2": "ptr",
                "uVar3": "length",
                "uVar4": "flag",
                "iVar5": "start",
                "pcVar6": "function_ptr",
                "iVar7": "end",
                "uVar8": "temp_data",
                "bVar9": "is_step_zero",
                "offset": "offset",
                "step": "step",
                "count": "count",
                "flag2": "flag2",
                "flag3": "flag3"
            },
            "code": "int process_data_0000404c(uint *data, int *info)\n{\n  int result = 0;\n  int *ptr = NULL;\n  uint length = (uint)*(ushort *)(info + 3);\n  uint flag = length << 0x1c;\n  if ((int)flag < 0)\n  {\n    int offset = info[4];\n    if (offset != 0)\n    {\n      uint step = length << 0x1e;\n      bool is_step_zero = step == 0;\n      int start = *info;\n      int end = start - offset;\n      if (is_step_zero)\n      {\n        step = info[5];\n      }\n      *info = offset;\n      if (!is_step_zero)\n      {\n        step = 0;\n      }\n      info[2] = step;\n      while (end > 0)\n      {\n        int count = (*(code *)info[10])(data, info[8], offset, end);\n        if (count < 1)\n        {\n          *(ushort *)(info + 3) = *(ushort *)(info + 3) | 0x40;\n          return -1;\n        }\n        offset += count;\n        end -= count;\n      }\n    }\n  }\n  else\n  {\n    if ((info[1] < 1) && (info[16] < 1))\n    {\n      return 0;\n    }\n    code *function_ptr = (code *)info[0xb];\n    if (function_ptr == NULL)\n    {\n      return 0;\n    }\n    uint flag2 = length & 0x1000;\n    uint temp_data = *data;\n    *data = 0;\n    if (flag2 == 0)\n    {\n      int count = (*function_ptr)(data, info[8], length & 0x1000, 1);\n      if ((count == -1) && (*data != 0))\n      {\n        if ((*data == 0x1d) || (*data == 0x16))\n        {\n          *data = temp_data;\n          return 0;\n        }\n        uint flag3 = *(ushort *)(info + 3);\n        *(ushort *)(info + 3) = flag3 | 0x40;\n        return count;\n      }\n    }\n    else\n    {\n      int count = info[0x15];\n    }\n    if (((int)((uint)*(ushort *)(info + 3) << 0x1d) < 0) && (info[0xd] != 0))\n    {\n      int count = info[0x15] - info[1];\n      if (info[0xd] != (int *)0x0)\n      {\n        if (info[0xd] != info + 0x11)\n        {\n          update_list_00004b34(data);\n        }\n        info[0xd] = 0;\n        return 0;\n      }\n    }\n    int count = (*(code *)info[0xb])(data, info[8], count, 0);\n    uint flag3 = *(ushort *)(info + 3);\n    if ((count == -1) && ((0x1d < *data || (-1 < (int)((DAT_00004154 >> (*data & 0xff)) << 0x1f))))\n    {\n      *(ushort *)(info + 3) = flag3 | 0x40;\n      return count;\n    }\n    info[1] = 0;\n    *info = info[4];\n    if (((int)((uint)flag3 << 0x13) < 0) && ((count != -1 || (*data == 0))))\n    {\n      info[0x15] = count;\n    }\n    ptr = (int *)info[0xd];\n    *data = temp_data;\n    if (ptr != NULL)\n    {\n      if (ptr != info + 0x11)\n      {\n        update_list_00004b34(data);\n      }\n      info[0xd] = 0;\n      return 0;\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_devices_info_00002f74",
                "PTR_DAT_00002fd0": "device_info_ptr",
                "local_18": "device_count",
                "local_14": "current_device",
                "PTR_s_No_devices_found_00002fd8": "No devices found.",
                "PTR_s_ID_Class_Name_00002fd4": "ID, Class, Name",
                "get_pointer_for_char_000039e8": "get_device_id",
                "PTR_s___i__s__s_00002fdc": "device_info_format",
                "uVar1": "device_id",
                "device_char": "device_character",
                "device_class": "device_class",
                "device_id": "device_id"
            },
            "code": "void print_devices_info_00002f74(void)\n{\n    undefined4 PTR_DAT_00002fd0;\n    int device_count = 0;\n    undefined4 *current_device;\n\n    current_device = *(undefined4 **)PTR_DAT_00002fd0;\n    if (current_device == (undefined4 *)0x0) {\n        print_error_message(\"PTR_s_No_devices_found_00002fd8\");\n    }\n    else {\n        print_info_message(\"PTR_s_ID_Class_Name_00002fd4\");\n    }\n    for (; current_device != (undefined4 *)0x0; current_device = (undefined4 *)*current_device) {\n        char device_char = *(undefined *)(current_device[3] + 8);\n        undefined4 device_class = current_device[2];\n        undefined4 device_id = get_pointer_for_char_000039e8(device_char);\n        print_device_info(device_count, device_id, device_class);\n        device_count++;\n    }\n    return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_devices_info_00002f74",
            "code_backup": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 = *(undefined4 **)PTR_DAT_00002fd0;\n  local_18 = 0;\n  if (local_14 == (undefined4 *)0x0) {\n    process_input(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    process_input(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; local_14 != (undefined4 *)0x0; local_14 = (undefined4 *)*local_14) {\n    uVar1 = get_pointer_for_char_000039e8(*(undefined *)(local_14[3] + 8));\n    FUNC_00004c84(PTR_s___i__s__s_00002fdc,local_18,uVar1,local_14[2]);\n    local_18 = local_18 + 1;\n  }\n  return;\n}\n\n"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculate_offset_from_pointer_000010a0",
                "param_1": "ptr_to_array",
                "local_c": "current_element"
            },
            "code": "int calculate_offset_from_pointer_000010a0(int *ptr_to_array) {\n    int *current_element = ptr_to_array;\n    while ((int *)*current_element == current_element) {\n        current_element++;\n    }\n    return (int)current_element - (int)ptr_to_array;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "calculate_offset_from_pointer_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "count_different_values_000012e2",
                "param_1": "array_start",
                "param_2": "array_length",
                "param_3": "element_size",
                "iVar1": "different_values_count"
            },
            "code": "int count_different_values_000012e2(int array_start, int array_length, int element_size)\n{\n  int different_values_count;\n  while( true )\n  {\n    different_values_count = count_different_values_000012e2_0000231c(array_start + element_size, array_length, element_size);\n    if (different_values_count != 0) break;\n    allocate_memory_for_param(array_start);\n  }\n  return different_values_count;\n}",
            "called": [
                "FUN_0000129c",
                "FUN_0000231c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "count_different_values_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_key_value_pair_000056a0",
                "param_1": "key",
                "param_2": "value",
                "param_3": "key_ptr",
                "param_4": "param_4",
                "uStack_c": "value_ptr",
                "uStack_8": "N/A"
            },
            "code": "void find_key_value_pair_000056a0(int key, int value, int* key_ptr, int param_4, int key2) {\n  int value_ptr;\n  value_ptr = value;\n  *key_ptr = value;\n  find_key_value_pair_000056a0_0000562c(key, value, &value_ptr, param_4, key2);\n  return;\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_key_value_pair_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "count_different_values_0000231c",
                "param_1": "value",
                "param_2": "buffer",
                "param_3": "buffer_size",
                "uVar1": "new_value",
                "iVar2": "equal_value",
                "local_20": "current_buffer_position",
                "local_14": "count"
            },
            "code": "int count_different_values_0000231c(undefined4 value, undefined *buffer, int buffer_size) {\n  undefined new_value;\n  int count = buffer_size;\n  undefined *current_buffer_position = buffer;\n  while ((count != 0 && (check_if_equal(value) == 0))) {\n    new_value = increment_value_at_offset(value);\n    *current_buffer_position = new_value;\n    count--;\n    current_buffer_position++;\n  }\n  return buffer_size - count;\n}",
            "called": [
                "FUN_000022f0",
                "FUN_00002270"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "count_different_values_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = PTR_LAB_00006118_1_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar6 = (uint)*param_3;\n      if (uVar6 == 0) {\n        return local_1a0;\n      }\n      uVar4 = (byte)puVar1[uVar6] & 8;\n      pbVar5 = param_3 + 1;\n      if ((puVar1[uVar6] & 8) == 0) break;\n      while (((param_3 = pbVar5, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar6 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar6) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar5;\n  }\n  local_1a4 = uVar4;\n  local_1ac = uVar4;\n  if (param_3[1] == 0x2a) {\n    pbVar5 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar4 = (uint)*pbVar5;\n    if (9 < uVar4 - 0x30) break;\n    pbVar5 = pbVar5 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar4) - 0x30;\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_000064b4,uVar4,3);\n  if (iVar3 != 0) {\n    local_1ac = 1 << (iVar3 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar5 = pbVar5 + 1;\n  }\n  param_3 = pbVar5 + 1;\n  uVar4 = (uint)*pbVar5;\n  if (uVar4 < 0x79) {\n    if (0x57 < uVar4) {\n      switch(uVar4) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)reverse_and_toggle_bits_0000687c(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar4 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar5 = param_2[1];\n          param_2[1] = pbVar5 + -1;\n          if ((int)(pbVar5 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = process_data_000064bc(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = FUNC_0000656c(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar5 = param_3;\n    if (uVar4 == 0x25) goto LAB_00006352;\n    if (uVar4 < 0x26) {\n      if (uVar4 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar4 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_000064bc",
                "FUN_0000687c",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_00006192"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "calculate_date_plus_one_pointer_value_00002690",
                "param_1": "dat_pointer_value",
                "local_10": "pointer_value_plus_one",
                "uStack_c": "u_stack_c",
                "calculate_date_0000443c": "calculate_date"
            },
            "code": "int calculate_date_plus_one_pointer_value_00002690(int dat_pointer_value) {\n    int pointer_value_plus_one = get_dat_pointer_value_plus_one();\n    int uStack_c = 0;\n    calculate_date(&pointer_value_plus_one, dat_pointer_value);\n    return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "calculate_date_plus_one_pointer_value_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "data",
                "param_2": "length",
                "param_3": "byte_sequence",
                "bVar1": "byte_value",
                "cVar2": "bit_0",
                "cVar3": "bit_8",
                "cVar4": "bit_16",
                "cVar5": "bit_24",
                "pbVar6": "result_pointer",
                "puVar7": "data_pointer",
                "pbVar8": "result_pointer",
                "uVar9": "data_alignment",
                "uVar10": "length_aligned",
                "uVar11": "data_masked_1",
                "uVar12": "data_masked_2",
                "bVar13": "data_masked_2_bit_0",
                "bVar14": "data_masked_2_bit_8",
                "bVar15": "data_masked_2_bit_16",
                "bVar16": "data_masked_2_bit_24"
            },
            "code": "byte* find_byte_sequence_00006010(uint* data, uint length, uint byte_sequence) {\n    byte* result = NULL;\n    uint byte_mask = 0xFF;\n    byte_sequence &= byte_mask;\n    if (length < 0x10) {\n        while (length--) {\n            if (*data++ == byte_sequence) {\n                result = (byte*)(data - 1);\n                break;\n            }\n        }\n    } else {\n        uint data_alignment = (uint)data & 7;\n        if (data_alignment == 0) {\n            uint byte_mask_2 = byte_sequence | (byte_sequence << 8) | (byte_sequence << 16) | (byte_sequence << 24);\n            uint length_aligned = length & 0xFFFFFFF8;\n            while (length_aligned) {\n                length_aligned -= 8;\n                uint data_1 = *data++;\n                uint data_2 = *data++;\n                uint data_masked_1 = data_1 ^ byte_mask_2;\n                uint data_masked_2 = data_2 ^ byte_mask_2;\n                uint data_masked_combined = data_masked_1 | data_masked_2;\n                if (data_masked_combined != 0) {\n                    if ((data_masked_combined & 0xFF) == 0) {\n                        result = (byte*)(data - 4);\n                    } else if ((data_masked_combined & 0xFF00) == 0) {\n                        result = (byte*)(data - 3);\n                    } else if ((data_masked_combined & 0xFF0000) == 0) {\n                        result = (byte*)(data - 2);\n                    } else if ((data_masked_combined & 0xFF000000) == 0) {\n                        result = (byte*)(data - 1);\n                    }\n                    break;\n                }\n            }\n        }\n        while (!result && length--) {\n            if (*data++ == byte_sequence) {\n                result = (byte*)(data - 1);\n                break;\n            }\n        }\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_00005b34",
                "FUN_000057f8",
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_flag_status_00001cf0",
                "PTR_DAT_00001d04": "data_address",
                "set_flag_on_data_address_0000093c": "set_flag_on_data"
            },
            "code": "void check_flag_status_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0) {\n    set_flag_on_PTR_DAT_00001d04_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "check_flag_status_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "count_decimal_digits_and_sign_00003ec4",
                "param_1": "output_str",
                "param_2": "input_num",
                "param_3": "decimal_places",
                "iVar1": "digit_count",
                "uVar2": "unused",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "digit_count",
                "PTR_s_FAILED_ASSERTION__00003fec": "FAILED_ASSERTION",
                "PTR_DAT_00003ff0": "DAT_00003ff0",
                "count_digits_and_sign_00003e58": "count_digits_and_sign",
                "process_data_00000f04": "process_data",
                "fill_memory_with_value_00004622": "fill_memory_with_value",
                "reverse_and_fill_00003ff4": "reverse_and_fill"
            },
            "code": "int count_decimal_digits_and_sign_00003ec4(undefined *output_str, uint input_num, int decimal_places) {\n    int digit_count = 0;\n\n    if (decimal_places + 7 < 0 != SCARRY4(decimal_places,7)) {\n        process_data(3, PTR_s_FAILED_ASSERTION__00003fec);\n    }\n\n    if (decimal_places == 0) {\n        digit_count = count_digits_and_sign_00003e58(input_num, output_str);\n    }\n    else if (decimal_places < 1) {\n        uint divisor = *(uint *)(PTR_DAT_00003ff0 + decimal_places * -4);\n        uint quotient = input_num / divisor;\n        uint remainder = input_num - divisor * quotient;\n\n        if (remainder < 0) {\n            remainder = -remainder;\n        }\n\n        if (quotient == 0 && (int)input_num < 0) {\n            if (output_str != NULL) {\n                *output_str = '-';\n            }\n            digit_count = 1;\n        }\n        if (output_str == NULL) {\n            int quotient_digits = count_digits_and_sign_00003e58(quotient, NULL);\n            digit_count = quotient_digits + 1 + digit_count;\n        }\n        else {\n            int quotient_digits = count_digits_and_sign_00003e58(quotient, output_str + digit_count);\n            digit_count += quotient_digits;\n            output_str[digit_count] = '.';\n            digit_count += 1;\n            int remainder_digits = count_digits_and_sign_00003e58(remainder, output_str + digit_count);\n            reverse_and_fill_00003ff4(output_str + digit_count, remainder_digits, -decimal_places, '0');\n        }\n        digit_count = -decimal_places + digit_count;\n    }\n    else {\n        digit_count = count_digits_and_sign_00003e58(input_num, output_str);\n        if (output_str != NULL) {\n            fill_memory_with_value_00004622(output_str + digit_count, '0', decimal_places);\n        }\n        digit_count = decimal_places + digit_count;\n    }\n    return digit_count;\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00003e58",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "count_decimal_digits_and_sign_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_result_00001360",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_result_00001360(uint32_t input_value, int multiplier) {\n    uint32_t masked_input = input_value & 0xf0000000;\n    uint32_t lower_bits = input_value & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int result = (multiplier * 4) + masked_input + shifted_lower_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_result_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_value_00004622",
                "*param_1": "*memory",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "end_address"
            },
            "code": "void fill_memory_with_value_00004622(void *memory, char value, int size) {\n  void *end_address = memory + size;\n  for (; memory != end_address; memory++) {\n    *(char*)memory = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00003ec4",
                "FUN_0000305c",
                "FUN_00004248",
                "FUN_000041f4",
                "FUN_00003ff4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_data_address_0000093c",
                "DAT_00000954": "data_address"
            },
            "code": "void set_flag_on_data_address_0000093c(void)\n{\n  uint32_t *DAT_00000954 = (uint32_t *)(DAT_00000954 + 4);\n  uint32_t flag = 0x10000000;\n  *DAT_00000954 |= flag;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00001cf0",
                "FUN_00002434",
                "FUN_00001348",
                "FUN_00000738",
                "FUN_00002798"
            ],
            "imported": false,
            "current_name": "set_flag_on_data_address_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "perform_data_sync_00003658",
                "DAT_00003680": "data_start_address",
                "DAT_00003684": "data_value",
                "DataSynchronizationBarrier": "perform_sync_barrier",
                "PTR_": "ptr_"
            },
            "code": "void perform_data_sync_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n  *data_ptr = (DAT_00003684 | (*data_ptr & 0x700));\n  DataSynchronizationBarrier(0xf);\n  while(true)\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "perform_data_sync_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "set_memory_flag_and_update_bitfield_000019c0",
                "DAT_00001a0c": "DAT_memory",
                "DAT_00001a10": "DAT_bitfield",
                "PTR_DAT_00001a14": "PTR_counter",
                "set_memory_flag_00001778": "set_memory_flag",
                "update_bitfield_00001748": "update_bitfield",
                "clear_memory_at_offset_00001710": "clear_memory_at_offset",
                "clear_six_bytes_at_offset_00001710_00001734": "clear_six_bytes_at_offset"
            },
            "code": "void set_memory_flag_and_update_bitfield_000019c0(void)\n{\n  set_memory_flag();\n  update_bitfield(0x40);\n  clear_memory_at_offset(DAT_00001a0c,1);\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  do {\n  } while ((DAT_00001a10[6] & 0xc) != 8);\n  clear_six_bytes_at_offset();\n  *PTR_DAT_00001a14 = 3;\n  return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_memory_flag_and_update_bitfield_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_data_to_destination_000060b0",
                "param_1": "destination_start_index",
                "param_2": "source_data",
                "param_3": "data_length",
                "puVar1": "next_source_data",
                "puVar2": "source_data_end",
                "puVar3": "destination_data"
            },
            "code": "void copy_data_to_destination_000060b0(int destination_start_index, undefined *source_data, int data_length) {\n  undefined *source_data_end = source_data + data_length;\n  undefined *destination_data = (undefined *)(destination_start_index - 1);\n  if (source_data != source_data_end) {\n    do {\n      undefined *next_source_data = source_data + 1;\n      destination_data = destination_data + 1;\n      *destination_data = *source_data;\n      source_data = next_source_data;\n    } while (next_source_data != source_data_end);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_data_to_destination_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "handle_interrupt_request_000023d0",
                "param_1": "interrupt_number",
                "uVar1": "result",
                "PTR_DAT_000023fc": "interrupt_flag_ptr",
                "send_software_interrupt_000023c8": "send_interrupt"
            },
            "code": "int handle_interrupt_request_000023d0(int interrupt_number)\n{\n  int interrupt_flag = *(int *)PTR_DAT_000023fc;\n  if (interrupt_flag == 0) {\n    return send_software_interrupt_000023c8(1, interrupt_number, 0);\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "handle_interrupt_request_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "process_data_00000a30",
                "in_r3": "stack_var",
                "auStack_20": "stack_buffer",
                "process_data_00000f04": "process_data_internal",
                "uRam00000a3c": "data_buffer",
                "PTR_DAT_00000a60": "PTR_DATA_START"
            },
            "code": "char* process_data_00000a30(int data_size, char* data_buffer){\n                      int stack_var;\n                      char* stack_buffer[24];\n                      process_data_00000a30_internal(4, data_buffer);\n                      return stack_buffer + (-(int)PTR_DAT_00000a60 - *(int *)(stack_var + 0x4c));\n                      }",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "process_data_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "initialize_rtc_commands_000034c0",
                "process_input": "initialize_rtc_command"
            },
            "code": "int initialize_rtc_commands_000034c0(void)\n{\n  initialize_rtc_command(PTR_s_usage__rtc__command___arguments__00003500);\n  initialize_rtc_command(PTR_s_commands__00003504);\n  initialize_rtc_command(PTR_s__poweron_power_the_interface_on_00003508);\n  initialize_rtc_command(PTR_s__poweroff_power_the_interface_of_0000350c);\n  initialize_rtc_command(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  initialize_rtc_command(PTR_s__getalarm_print_the_currently_al_00003514);\n  initialize_rtc_command(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  initialize_rtc_command(PTR_s__gettime_print_the_current_time_0000351c);\n  initialize_rtc_command(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_rtc_commands_000034c0",
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  process_input(PTR_s_usage__rtc__command___arguments__00003500);\n  process_input(PTR_s_commands__00003504);\n  process_input(PTR_s__poweron_power_the_interface_on_00003508);\n  process_input(PTR_s__poweroff_power_the_interface_of_0000350c);\n  process_input(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  process_input(PTR_s__getalarm_print_the_currently_al_00003514);\n  process_input(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  process_input(PTR_s__gettime_print_the_current_time_0000351c);\n  process_input(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_data_pointer_000050e8",
                "PTR_DAT_000050f0": "data_pointer"
            },
            "code": "char* get_data_pointer_000050e8(void)\n{\n  return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_data_pointer_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_pointers_if_null_000042a4",
                "param_1": "data",
                "PTR_DAT_0000430c": "iVar2",
                "PTR_DAT_00004310": "PTR_1",
                "initialize_data_000041f4": "initialize_data",
                "allocate_and_initialize_memory_00004314": "allocate_and_initialize_memory",
                "DAT_000042a0": "DAT"
            },
            "code": "void initialize_pointers_if_null_000042a4(int data, int size, int value) {\n  memset(data, value, size);\n}\n\nvoid initialize_pointers(int* ptr1, int* ptr2, int* ptr3) {\n  *ptr1 = allocate_and_initialize_memory();\n  *ptr2 = allocate_and_initialize_memory();\n  *ptr3 = allocate_and_initialize_memory();\n  initialize_pointers_if_null_000042a4(*ptr1, 4, 0);\n  initialize_pointers_if_null_000042a4(*ptr2, 9, 1);\n  initialize_pointers_if_null_000042a4(*ptr3, 0x12, 2);\n}\n\nvoid initialize_pointers_if_null_000042a4(int* ptr1, int* ptr2, int* ptr3) {\n  if (*ptr1 == 0) {\n    *ptr1 = 0;\n    *ptr2 = 0;\n    *ptr3 = 0;\n    int* PTR_DAT_000042a0_0000430c = PTR_DAT_000042a0_0000430c;\n    *ptr1 = PTR_DAT_000042a0_00004310;\n    bool bVar3 = PTR_DAT_000042a0_0000430c == ptr1;\n    if (bVar3) {\n      PTR_DAT_000042a0_0000430c = 1;\n    }\n    if (bVar3) {\n      *ptr1 = PTR_DAT_000042a0_0000430c;\n    }\n    initialize_pointers(ptr1 + 4, ptr1 + 8, ptr1 + 0xc);\n    *ptr1 = 1;\n  }\n}\n\nvoid initialize_pointers_if_null_000042a4(int param_1)\n{\n  do_nothing_with_data_pointer_0000428c();\n  initialize_pointers_if_null_000042a4(param_1 + 4, param_1 + 8, param_1 + 0xc);\n  do_nothing_000045ec(DAT_000042a0_000042a0);\n  return;\n}",
            "called": [
                "FUN_0000428c",
                "FUN_000041f4",
                "FUN_000045ec",
                "FUN_00004314"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004c84",
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_00006768",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "initialize_pointers_if_null_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_param_to_19_00000514",
                "*param_1": "*param",
                "0x13": "19",
                "undefined4": "int"
            },
            "code": "int set_param_to_19_00000514(int *param){\n  *param = 19;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_param_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "perform_data_synchronization_00002e9c",
                "perform_data_sync_00003688": "synchronize_data"
            },
            "code": "void perform_data_synchronization_00002e9c(void)\n{\n  synchronize_data();\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "perform_data_synchronization_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "update_bitfield_and_clear_memory_00001960",
                "DAT_000019b4": "DAT_buffer",
                "*DAT_000019b8": "*flag_ptr",
                "PTR_DAT_000019bc": "*PTR_result"
            },
            "code": "void update_bitfield_and_clear_memory_00001960(void)\n{\n  update_bitfield(0xa0);\n  clear_memory(DAT_000019b4,1);\n  *DAT_000019b8 = *DAT_000019b8 & 0x3b | 0x44;\n  do {\n  } while ((flag_ptr[6] & 0xc) != 4);\n  do {\n  } while ((flag_ptr[6] & 0x10) == 0);\n  PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "update_bitfield_and_clear_memory_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "main_function_00001a3c",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "DAT_00001a58": "offset",
                "clear_six_bytes_at_offset_00001710_00001734": "clear_six_bytes_at_offset",
                "PTR_DAT_00001a5c": "ptr_dat"
            },
            "code": "void main_function_00001a3c(int* DAT_00001a58, int value){\n\t*DAT_00001a58 = value;\n}\n\nvoid clear_six_bytes_at_DAT_00001a58(){\n\tmemset(&DAT_00001710, 0, 6);\n}\n\nvoid update_PTR_DAT_00001a5c(){\n\t*PTR_DAT_00001a5c = 5;\n}\n\nvoid main_function_00001a3c(){\n\tint* DAT_00001a58 = &DAT_00001a58;\n\tmain_function_00001a3c(DAT_00001a58, 1);\n\tclear_six_bytes_at_DAT_00001a58();\n\tupdate_PTR_DAT_00001a5c();\n}\n",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "main_function_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_within_buffer_000045ee",
                "param_1": "buffer_start",
                "param_2": "buffer_end",
                "param_3": "buffer_length",
                "puVar1": "start_ptr",
                "puVar2": "end_ptr"
            },
            "code": "void reverse_copy_within_buffer_000045ee(unsigned char *buffer_start, unsigned char *buffer_end, size_t buffer_length) {\n  unsigned char *start_ptr;\n  unsigned char *end_ptr;\n\n  end_ptr = buffer_end + buffer_length;\n  if ((buffer_end < buffer_start) && (buffer_start < end_ptr)) {\n    start_ptr = buffer_start + buffer_length;\n    while (start_ptr != buffer_start) {\n      end_ptr = end_ptr - 1;\n      start_ptr = start_ptr - 1;\n      *start_ptr = *end_ptr;\n    }\n  }\n  else {\n    buffer_start = buffer_start - 1;\n    for (; buffer_end != end_ptr; buffer_end = buffer_end + 1) {\n      buffer_start = buffer_start + 1;\n      *buffer_start = *buffer_end;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_within_buffer_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "param_1": "input_length",
                "param_2": "input_char",
                "param_3": "input_ptr",
                "param_4": "update_flag",
                "iVar1": "offset",
                "uVar2": "shift",
                "puVar3": "input_char_ptr",
                "PTR_DAT_0000549c": "input_ptr_1",
                "PTR_DAT_000054a0": "input_ptr_2",
                "PTR_DAT_000054a4": "input_ptr_3",
                "FUN_00005404": "process_input_00005404"
            },
            "code": "uint process_input_00005404(int input_length, uint input_char, int *input_ptr, undefined4 update_flag) {\n  int offset = 0;\n  uint shift = 0;\n  if ((input_length != 0) && (*(int *)(input_length + 0x18) == 0)) {\n    initialize_pointers_if_null_000042a4();\n  }\n  if (input_ptr == (int *)PTR_DAT_0000549c) {\n    input_ptr = *(int **)(input_length + 4);\n  }\n  else if (input_ptr == (int *)PTR_DAT_000054a0) {\n    input_ptr = *(int **)(input_length + 8);\n  }\n  else if (input_ptr == (int *)PTR_DAT_000054a4) {\n    input_ptr = *(int **)(input_length + 0xc);\n  }\n  input_ptr[2] = input_ptr[6];\n  uint input_char_shifted = (uint)*(ushort *)(input_ptr + 3);\n  offset = input_char_shifted << 0x1c;\n  if (((offset < 0) && (input_char_shifted = input_ptr[4], input_char_shifted != 0)) ||\n     (offset = update_list_000054a8(input_length, input_ptr, offset, input_char_shifted, update_flag), offset == 0)) {\n    offset = *input_ptr - input_ptr[4];\n    input_char = input_char & 0xff;\n    if ((offset < input_ptr[5]) || (offset = process_data_00004158(input_length, input_ptr), offset == 0)) {\n      input_ptr[2] = input_ptr[2] + -1;\n      undefined *input_char_ptr = (undefined *)*input_ptr;\n      *input_ptr = (int)(input_char_ptr + 1);\n      *input_char_ptr = (char)input_char;\n      if (input_ptr[5] != offset + 1) {\n        if (-1 < (int)((uint)*(ushort *)(input_ptr + 3) << 0x1f)) {\n          return input_char;\n        }\n        if (input_char != 10) {\n          return input_char;\n        }\n      }\n      offset = process_data_00004158(input_length, input_ptr);\n      if (offset == 0) {\n        return input_char;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_000057a8",
                "FUN_00004db8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "process_input_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "calculate_result_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "sign",
                "iVar1": "quotient",
                "uVar2": "result"
            },
            "code": "undefined8 calculate_result_00006974(int dividend, int divisor, int remainder, int sign){\n  int quotient;\n  undefined8 result;\n  undefined local_8 [8];\n  \n  if ((sign == 0) && (remainder == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    return CONCAT44(divisor, dividend);\n  }\n  if (divisor < 0) {\n    quotient = -divisor - (uint)(dividend != 0);\n    if (sign < 0) {\n      result = FUNC_00006a14(-dividend, quotient, -remainder, -sign - (uint)(remainder != 0), local_8);\n      return result;\n    }\n    result = FUNC_00006a14(-dividend, quotient, remainder, sign, local_8);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  if (sign < 0) {\n    result = FUNC_00006a14(dividend, divisor, -remainder, -sign - (uint)(remainder != 0), local_8);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  result = FUNC_00006a14();\n  return result;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "calculate_result_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "allocate_and_initialize_memory_00004314",
                "param_1": "error_code",
                "piVar1": "current_block_size",
                "piVar2": "current_block_data",
                "iVar3": "memory_blocks_list_ptr",
                "ppiVar4": "memory_blocks_list",
                "*ppiVar4": "current_memory_block",
                "*piVar2": "current_block_data_value",
                "DAT_0000439c": "default_value",
                "do_nothing_with_pointer_00004274": "do_nothing_with_pointer",
                "FUNC_000042a4": "initialize_memory_block",
                "do_nothing_000045e4": "do_nothing",
                "do_nothing_with_data_00004280": "do_nothing_with_data",
                "fill_memory_with_value_00004622": "fill_memory_with_value"
            },
            "code": "int* allocate_and_initialize_memory_00004314(undefined4* error_code) {\n  int* allocated_memory;\n  int* current_memory_block;\n  int memory_block_index;\n  int** memory_blocks_list = (int**)PTR_DAT_00004398;\n  do_nothing_with_pointer_00004274();\n  int memory_blocks_list_ptr = *(int*)memory_blocks_list;\n  if (*(int*)(memory_blocks_list_ptr + 0x18) == 0) {\n    initialize_pointers_if_null_000042a4(memory_blocks_list_ptr);\n  }\n  current_memory_block = (int*)(memory_blocks_list_ptr + 0x48);\n  while (true) {\n    int* current_block_data = current_memory_block[2];\n    int current_block_size = current_memory_block[1];\n    while (current_block_size-- > 0) {\n      if (*(short*)(current_block_data + 3) == 0) {\n        current_block_data[3] = DAT_0000439c;\n        current_block_data[0x19] = 0;\n        do_nothing_000045e4(current_block_data + 0x16);\n        do_nothing_with_data_00004280();\n        current_block_data[1] = 0;\n        current_block_data[2] = 0;\n        current_block_data[4] = 0;\n        current_block_data[5] = 0;\n        *current_block_data = 0;\n        current_block_data[6] = 0;\n        fill_memory_with_value_00004622(current_block_data + 0x17, 0, 8);\n        current_block_data[0xd] = 0;\n        current_block_data[0xe] = 0;\n        current_block_data[0x12] = 0;\n        current_block_data[0x13] = 0;\n        return current_block_data;\n      }\n      current_block_data += 0x1a;\n    }\n    if (*memory_blocks_list == (int*)0x0) {\n      allocated_memory = (int*)allocate_and_initialize_memory_00004314_00004248(error_code, 4);\n      *memory_blocks_list = allocated_memory;\n      if (allocated_memory == (int*)0x0) {\n        do_nothing_with_data_00004280();\n        *error_code = 0xc;\n        return (int*)0x0;\n      }\n    }\n    memory_blocks_list = (int**)*memory_blocks_list;\n    current_memory_block = *memory_blocks_list;\n  }\n}",
            "called": [
                "FUN_000045e4",
                "FUN_00004274",
                "FUN_00004248",
                "FUN_00004280",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_00004314",
            "code_backup": "\nint * FUN_00004314(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  do_nothing_with_pointer_00004274();\n  iVar3 = *(int *)PTR_DAT_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUNC_000042a4(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        do_nothing_000045e4(piVar2 + 0x16);\n        do_nothing_with_data_00004280();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        fill_memory_with_value_00004622(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_memory_00004248(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        do_nothing_with_data_00004280();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "count_different_values_wrapper_00004dc8",
                "param_1": "data",
                "param_2": "data_pointer",
                "iVar1": "different_values_count",
                "uVar2": "updated_value",
                "bVar3": "has_different_values"
            },
            "code": "void count_different_values_wrapper_00004dc8(undefined4 data, int data_pointer) {\n  int different_values_count = count_different_values(data, *(short *)(data_pointer + 0xe));\n  bool has_different_values = different_values_count >= 0;\n  if (has_different_values) {\n    uint updated_value = *(int *)(data_pointer + 0x54) + different_values_count;\n    *(uint *)(data_pointer + 0x54) = updated_value;\n  }\n  else {\n    uint updated_value = *(ushort *)(data_pointer + 0xc) & 0xffffefff;\n    *(short *)(data_pointer + 0xc) = (short)updated_value;\n  }\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "count_different_values_wrapper_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "parse_integer_wrapper_00005fd8",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "*DAT_00005fe8": "int_ptr",
                "parse_integer_00005edc": "parse_integer"
            },
            "code": "void parse_integer_wrapper_00005fd8(const int* *DAT_00005fe8, int first_param, int second_param, int third_param){\n  parse_integer(**DAT_00005fe8, first_param, second_param, third_param);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "parse_integer_wrapper_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "decode_data_00005e10",
                "param_1": "data_ptr",
                "param_2": "decoded_data_ptr",
                "iVar1": "result",
                "pbVar3": "byte_ptr",
                "PTR_DAT_00005e5c": "ptr_1",
                "PTR_DAT_00005e60": "ptr_2",
                "PTR_DAT_00005e64": "ptr_3"
            },
            "code": "uint decode_data_00005e10(int data_ptr, byte **decoded_data_ptr)\n{\n  int null_check = *(int *)(data_ptr + 0x18);\n  if ((data_ptr != 0) && (null_check == 0)) {\n    initialize_pointers_if_null();\n  }\n  if (decoded_data_ptr == (byte **)PTR_DAT_00005e5c) {\n    decoded_data_ptr = *(byte ***)(data_ptr + 4);\n  }\n  else if (decoded_data_ptr == (byte **)PTR_DAT_00005e60) {\n    decoded_data_ptr = *(byte ***)(data_ptr + 8);\n  }\n  else if (decoded_data_ptr == (byte **)PTR_DAT_00005e64) {\n    decoded_data_ptr = *(byte ***)(data_ptr + 0xc);\n  }\n  int result = calculate_result(data_ptr, decoded_data_ptr);\n  if (result == 0) {\n    decoded_data_ptr[1] = decoded_data_ptr[1] - 1;\n    byte *byte_ptr = *decoded_data_ptr;\n    *decoded_data_ptr = byte_ptr + 1;\n    uint decoded_byte = (uint)*byte_ptr;\n    return decoded_byte;\n  }\n  else {\n    return 0xffffffff;\n  }\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "decode_data_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "calculate_result_and_execute_function_with_bit_and_byte_position_000033f4",
                "param_1": "input_value",
                "iVar1": "result",
                "auStack_2c": "stack_variable",
                "execute_function_with_bit_and_byte_position_00002654": "execute_function_with_bit_and_byte_position_00002654",
                "PTR_FUN_000031e0_1_0000343c": "PTR_FUN_000031e0_1_0000343c",
                "process_input": "process_input",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_s_rtc__error_setting_alarm_00003440"
            },
            "code": "int calculate_result_and_execute_function_with_bit_and_byte_position_000033f4(int input_value) {\n  int result = 0;\n  undefined4 stack_variable[9];\n  result = calculate_result_from_input_0000328c(input_value, stack_variable);\n  if (result == 0) {\n    int function_result = execute_function_with_bit_and_byte_position_00002654(stack_variable, PTR_FUN_000031e0_1_0000343c, 0);\n    if (function_result == -1) {\n      process_input(PTR_s_rtc__error_setting_alarm_00003440);\n      return 1;\n    }\n  }\n  else {\n    return 1;\n  }\n  return 0;\n}\n",
            "called": [
                "FUN_00002654",
                "FUN_00004db8",
                "FUN_0000328c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_result_and_execute_function_with_bit_and_byte_position_000033f4",
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_result_from_input_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = execute_function_with_bit_and_byte_position_00002654(auStack_2c,PTR_FUN_000031e0_1_0000343c,0);\n    if (iVar1 == -1) {\n      process_input(PTR_s_rtc__error_setting_alarm_00003440);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "calculate_date_0000443c",
                "param_1": "date_in",
                "param_2": "date_out",
                "iVar1": "days_since_new_year",
                "uVar2": "days_since_1900_plus_offset",
                "uVar3": "days_since_1900",
                "uVar4": "leap_years",
                "uVar5": "non_leap_years",
                "uVar6": "year",
                "uVar7": "month",
                "uVar8": "days_since_1600",
                "bVar9": "is_negative"
            },
            "code": "uint * calculate_date_0000443c(uint32_t *date_in,uint32_t *date_out)\n{\n    uint32_t year = *date_in;\n    uint32_t month = date_in[1];\n    int days_since_1900 = calculate_days_since_1900(year, month, DAT_0000458c, 0);\n    bool is_negative = (int)DAT_0000458c < 0;\n    if (is_negative)\n    {\n        DAT_0000458c += 0x15180;\n    }\n    uint32_t days_since_1900_plus_offset = is_negative ? days_since_1900 + 0xafa6b : days_since_1900 + 0xafa6c;\n    date_out[2] = days_since_1900 / 0xe10;\n    date_out[1] = (days_since_1900 % 0xe10) / 0x3c;\n    *date_out = (days_since_1900 % 0xe10) % 0x3c;\n    date_out[6] = (days_since_1900_plus_offset + 3) % 7;\n    uint32_t days_since_1900_minus_offset = (int)days_since_1900_plus_offset < 0 ? days_since_1900_plus_offset - 0x23ab0 : days_since_1900_plus_offset;\n    uint32_t days_since_1600 = DAT_00004594 * (days_since_1900_minus_offset / DAT_00004590) + days_since_1900_plus_offset;\n    uint32_t leap_years = days_since_1600 / 0x8eac - days_since_1600 / 0x5b4 + days_since_1600 / DAT_00004598;\n    uint32_t non_leap_years = (days_since_1600 / 0x5b4) - (leap_years / 100) + (leap_years / 400) + 1;\n    uint32_t is_leap_year = month < 3 ? ((year & 3) == 0 && (year % 100 != 0 || year % 400 == 0)) : ((year + 1) & 3) == 0 && ((year + 1) % 100 != 0 || (year + 1) % 400 == 0);\n    uint32_t days_since_new_year = is_leap_year ? days_since_1900_minus_offset + 0x3b + count_leading_zeroes(leap_years % 400) / 32 : days_since_1900_minus_offset - 0x132;\n    date_out[7] = days_since_new_year;\n    date_out[3] = (days_since_1900_plus_offset + 1) - ((leap_years * 99 + non_leap_years * 303) / 100 + 2) / 5;\n    date_out[4] = (leap_years < 2) ? non_leap_years : non_leap_years + 1;\n    date_out[5] = year - 0x76c;\n    date_out[8] = 0;\n    return date_out;\n}\n",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "calculate_date_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "set_flag_on_0000294c_000027b0",
                "puVar1": "flag_ptr",
                "DAT_00002814": "flag_ptr",
                "DAT_00002818": "data_ptr"
            },
            "code": "void set_flag_on_0000294c_000027b0(void)\n{\n  uint32_t* DAT_00002814 = DAT_00002814;\n  uint32_t* DAT_00002818 = DAT_00002818;\n  DAT_00002818[0x103c/4] |= 0x20000000;\n  DAT_00002814[4] = 1;\n  DAT_00002814[4] = 0;\n  if ((DAT_00002814[5] & 1) != 0) {\n    *DAT_00002814 = 0;\n  }\n  DAT_00002814[4] = 0x104;\n  DAT_00002814[2] = 0xffffff42;\n  DAT_00002814[7] = 0;\n  set_flag_on_0000294c_000027b0();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000294c_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source)\n{\n  char current_char;\n  do {\n    current_char = *source;\n    *destination = current_char;\n    source++;\n    destination++;\n  } while (current_char != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "update_list_00004b34_00006192",
                "param_1": "param_1",
                "param_2": "list",
                "PTR_": "",
                "DAT_": "",
                "list[13]": "list[13]",
                "NULL": "NULL",
                "list + 17": "list + 17",
                "list[1]": "list[1]",
                "list[16]": "list[16]",
                "list[16] != 0": "list[16] != 0",
                "*list": "*list",
                "list[15]": "list[15]",
                "list[4]": "list[4]",
                "unsigned short": "unsigned short"
            },
            "code": "int update_list_00004b34_00006192(int param_1, int *list)\n{\n    int *ptr_1 = (int *)list[13];\n    if (ptr_1 != NULL)\n    {\n        if (ptr_1 != list + 17)\n        {\n            update_list_00004b34_00006192();\n        }\n        list[1] = list[16];\n        list[13] = NULL;\n        if (list[16] != 0)\n        {\n            *list = list[15];\n            return 0;\n        }\n    }\n    *list = list[4];\n    list[1] = 0;\n    *(unsigned short *)(list + 6) |= 0x20;\n    return -1;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "update_list_00004b34_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_six_bytes_at_offset_00001710_00001734",
                "DAT_00001744": "ptr",
                "clear_memory_at_offset_00001710": "memset"
            },
            "code": "void clear_six_bytes_at_offset_00001710_00001734(void* DAT_00001744, int size)\n{\n    memset(DAT_00001744, 0, size);\n    return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_000019c0",
                "FUN_00001a18",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "clear_six_bytes_at_offset_00001710_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "count_different_values_wrapper_00000e14",
                "param_1": "param1",
                "param_2": "param2",
                "uVar1": "result",
                "DAT_00000e34": "data"
            },
            "code": "int count_different_values_wrapper_00000e14(void* DAT_00000e34, int param1, int param2) {\n  int result = count_different_values(DAT_00000e34, param1, param2);\n  return result;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "count_different_values_wrapper_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_different_value_in_array_0000281c",
                "local_10": "index",
                "local_c": "value"
            },
            "code": "int find_first_different_value_in_array_0000281c(void)\n{\n  int index = 0;\n  int value = *DAT_00002858;\n  while (index < 3 && value == *DAT_00002858)\n  {\n    index++;\n  }\n  return *DAT_00002858;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_different_value_in_array_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "check_if_equal_00002270",
                "param_1": "input_param",
                "iVar2": "value_at_offset_c",
                "bVar3": "is_offset_8_equal_to_c"
            },
            "code": "int check_if_equal_00002270(int input_param) {\n  int value_at_offset_c = *(int *)(input_param + 0xc);\n  bool is_offset_8_equal_to_c = *(int *)(input_param + 8) == value_at_offset_c;\n  if (is_offset_8_equal_to_c) {\n    value_at_offset_c = 1;\n  }\n  else {\n    value_at_offset_c = 0;\n  }\n  return value_at_offset_c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "check_if_equal_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "update_list_with_param_00005780",
                "param_1": "parameter",
                "*DAT_0000578c": "list",
                "update_list_00004b34": "update_list"
            },
            "code": "void update_list_with_param_00005780(void **DAT_0000578c, int parameter) {\n  update_*DAT_0000578c(*DAT_0000578c, parameter);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "update_list_with_param_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "extract_bits_and_call_function_000020cc",
                "DAT_000020dc": "data",
                "extract_bits_and_call_function_00002028": "extract_bits_and_call_function",
                "1": "bit_position"
            },
            "code": "void extract_bits_and_call_function_000020cc(uint8_t* DAT_000020dc, int bit_position)\n{\n  extract_bits_and_call_function_000020cc(DAT_000020dc, bit_position);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUNC_00002396": "set_flag_and_return",
                "PTR_": "PTR_",
                "DAT_": "DAT_",
                "FUN_00002396": "set_flag_and_return_00002396"
            },
            "code": "void set_flag_and_return_00002396(void)\n{\n    set_flag_on_000025f4();\n    return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "set_flag_and_return_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "process_input_00004cb4",
                "param_1": "input_byte",
                "puVar1": "ptr",
                "puVar3": "data_ptr",
                "unaff_r4": "data_start_ptr",
                "iVar4": "data",
                "unaff_r5": "data_end_ptr"
            },
            "code": "uint process_input_00004cb4(uint input_byte){\n  uint result = input_byte;\n  int data = *data_ptr;\n  if ((data != 0) && (*(int *)(data + 0x18) == 0)) {\n    initialize_pointers_if_null(data);\n  }\n  uint *ptr = *(uint **)(data + 8);\n  if ((data != 0) && (*(int *)(data + 0x18) == 0)) {\n    initialize_pointers_if_null(data);\n  }\n  if (ptr == (uint *)data_end_ptr) {\n    ptr = *(uint **)(data + 4);\n  }\n  else if (ptr == (uint *)data_mid_ptr) {\n    ptr = *(uint **)(data + 8);\n  }\n  else if (ptr == (uint *)data_start_ptr) {\n    ptr = *(uint **)(data + 0xc);\n  }\n  if ((-1 < (int)(ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(ptr + 3) << 0x16))) {\n    do_nothing(ptr[0x16]);\n  }\n  uint index = ptr[2] - 1;\n  ptr[2] = index;\n  if (((int)index < 0) && (((int)index < (int)ptr[6] || (index = input_byte & 0xff, index == 10))))\n  {\n    result = process_data(data, input_byte, ptr, index, data_start_ptr, data_end_ptr);\n  }\n  else {\n    uint *data_ptr = (uint *)*ptr;\n    *ptr = data_ptr + 1;\n    *(char *)data_ptr = (char)input_byte;\n    result = input_byte & 0xff;\n  }\n  if ((-1 < (int)(ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(ptr + 3) << 0x16))) {\n    do_nothing(ptr[0x16]);\n  }\n  return result;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "process_input_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "process_input_and_set_flag_00003478",
                "param_1": "input",
                "iVar1": "result",
                "uVar2": "flag",
                "auStack_2c": "stack_buffer",
                "calculate_result_from_input_0000328c": "calculate_result_from_input",
                "process_value_and_set_flag_00002600": "process_value_and_set_flag"
            },
            "code": "undefined4 process_input_and_set_flag_00003478(undefined4 input)\n{\n  int result;\n  undefined4 flag;\n  undefined stack_buffer[36];\n  result = calculate_result_from_input(input, stack_buffer);\n  if (result == 0) {\n    result = process_value_and_set_flag(stack_buffer);\n    if (result == -1) {\n      process_input(PTR_s_rtc__error_setting_time_000034bc);\n      flag = 1;\n    }\n    else {\n      flag = 0;\n    }\n  }\n  else {\n    flag = 1;\n  }\n  return flag;\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00002600",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "process_input_and_set_flag_00003478",
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_result_from_input_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = process_value_and_set_flag_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      process_input(PTR_s_rtc__error_setting_time_000034bc);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "extract_bits_and_call_function_00002028",
                "param_1": "input_param",
                "param_2": "flag",
                "iVar1": "index",
                "uVar2": "flag_bits",
                "local_c": "bit_position"
            },
            "code": "void extract_bits_and_call_function_00002028(int input_param, unsigned int flag) {\n    int index;\n    uint flag_bits;\n    uint bit_position;\n    flag_bits = *(uint *)(input_param + 0xa0);\n    for (bit_position = 0; (int)bit_position < 0x20; bit_position++) {\n        if (((flag_bits & 1 << (bit_position & 0xff)) != 0) && ((*(uint *)(input_param + bit_position * 4) & 0xf0000) != 0)) {\n            *(int *)(input_param + 0xa0) = 1 << (bit_position & 0xff);\n            index = extract_bits_from_uint_00001e0c(flag, bit_position);\n            (**(code **)(PTR_DAT_000020b4 + index * 0xc))(*(undefined4 *)(PTR_DAT_000020b4 + index * 0xc + 4));\n        }\n    }\n    check_flag_status_00001cf0();\n    return;\n}",
            "called": [
                "FUN_00001cf0",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020f4",
                "FUN_000020e0",
                "FUN_000020b8",
                "FUN_000020cc",
                "FUN_00002108"
            ],
            "imported": false,
            "current_name": "extract_bits_and_call_function_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_calculated_offset_to_one_000016c8",
                "param_1": "offset",
                "param_2": "param",
                "puVar1": "offset_pointer",
                "*puVar1": "*offset_pointer",
                "calculate_offset_00001696": "calculate_offset"
            },
            "code": "void set_calculated_offset_to_one_000016c8(int offset, char param)\n{\n  int* offset_pointer;\n  offset_pointer = (int*)calculate_offset(offset, param);\n  *offset_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_calculated_offset_to_one_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "clear_memory_and_set_flag_00001a60",
                "DAT_00001ac4": "data_pointer_1",
                "DAT_00001ac8": "data_pointer_2",
                "DAT_00001acc": "offset_pointer",
                "PTR_DAT_00001ad0": "flag_pointer",
                "clear_memory_at_offset_00001710": "clear_memory",
                "set_offset_to_one_000016ec": "set_offset_to_one"
            },
            "code": "void clear_memory_and_set_flag_00001a60(void)\n{\n    int* DAT_00001ac4 = DAT_00001ac4;\n    int* DAT_00001ac8 = DAT_00001ac8;\n    clear_memory_at_offset_00001710(DAT_00001ac4, 1);\n    *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n    while ((DAT_00001ac8[6] & 0xc) != 8);\n    set_offset_to_one_000016ec(DAT_00001acc, 6);\n    while ((DAT_00001ac8[6] & 0x20) == 0);\n    while ((DAT_00001ac8[6] & 0x40) == 0);\n    *PTR_DAT_00001ad0 = 6;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "clear_memory_and_set_flag_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_program_data_0000099c",
                "local_14": "stack_ptr",
                "local_10": "data_ptr",
                "local_c": "rel_array_ptr",
                "uStack_18": "zero_data",
                "initialize_data_and_result_to_zero_00000db0": "initialize_data_and_result_to_zero",
                "PTR_Elf32_Rel_ARRAY_00000a20": "rel_array_start",
                "PTR_DAT_00000a14": "program_data_start",
                "DAT_00000a1c": "zero_data",
                "PTR_DAT_00000a18": "program_data_start",
                "DAT_00000a2c": "bss_end",
                "PTR_DAT_00000a24": "program_data_end",
                "PTR_DAT_00000a28": "bss_start",
                "do_nothing_00000990": "do_nothing",
                "update_data_bits_00000e64": "update_data_bits",
                "process_linked_list_and_increment_value_0000459c": "process_linked_list_and_increment_value",
                "initialize_data_structure_00000f8c": "initialize_data_structure"
            },
            "code": "void initialize_program_data_0000099c(void)\n{\n  undefined4 DAT_00000a1c = 0;\n  undefined4 *stack_ptr = &DAT_00000a1c;\n  undefined4 *data_ptr = PTR_DAT_00000a14;\n  initialize_data_and_result_to_zero_00000db0();\n  undefined4 *rel_array_ptr = (undefined4 *)PTR_Elf32_Rel_ARRAY_00000a20;\n  while (rel_array_ptr < PTR_DAT_00000a24) {\n    *rel_array_ptr = *data_ptr;\n    data_ptr++;\n    rel_array_ptr++;\n  }\n  undefined4 *bss_ptr = (undefined4 *)PTR_DAT_00000a28;\n  while(bss_ptr < DAT_00000a2c) {\n    *bss_ptr = 0;\n    bss_ptr++;\n  }\n  do_nothing_00000990();\n  update_data_bits();\n  process_linked_list_and_increment_value();\n  initialize_data_structure();\n  return;\n}\n",
            "called": [
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000db0",
                "FUN_0000459c",
                "FUN_00000990"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_program_data_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "decode_input_data_00002d94",
                "param_1": "input_buffer",
                "param_2": "buffer_size",
                "iVar1": "input_char",
                "bVar2": "is_buffer_empty",
                "bVar3": "is_buffer_empty",
                "local_c": "current_input_char"
            },
            "code": "uint decode_input_data_00002d94(undefined *input_buffer, int buffer_size)\n{\n  int input_char;\n  byte is_buffer_empty;\n  undefined *current_input_char;\n\n  current_input_char = input_buffer;\n  while( true ) {\n    if (buffer_size + -1 <= (int)current_input_char - (int)input_buffer) {\n      return 0xffffffff;\n    }\n    input_char = decode_data_00004418_00004418();\n    if (input_char < 0) break;\n    if ((input_char == 0xd) || (input_char == 10)) {\n      *current_input_char = 0;\n      process_input_00002a00(0xd);\n      process_input_00002a00(10);\n      is_buffer_empty = current_input_char == input_buffer;\n      if (is_buffer_empty) {\n        input_buffer = (undefined *)0x1;\n      }\n      is_buffer_empty = (byte)input_buffer;\n      if (!is_buffer_empty) {\n        is_buffer_empty = 0;\n      }\n      return (uint)is_buffer_empty;\n    }\n    if ((input_char == 8) || (input_char == 0x7f)) {\n      if (current_input_char != input_buffer) {\n        current_input_char = current_input_char - 1;\n        *current_input_char = 0;\n        process_input_00002a00(8);\n        process_input_00002a00(0x20);\n        process_input_00002a00(8);\n      }\n    }\n    else {\n      *current_input_char = (char)input_char;\n      process_input_00002a00(input_char);\n      current_input_char = current_input_char + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_00004418"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "decode_input_data_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "map_input_to_output_00003918",
                "param_1": "input",
                "uVar1": "output"
            },
            "code": "uint8_t map_input_to_output_00003918(uint8_t input) {\n    uint8_t output;\n    switch(input) {\n        case 0x02:\n            output = 0x68;\n            break;\n        case 0x03:\n            output = 0x6b;\n            break;\n        case 0x06:\n            output = 0x4d;\n            break;\n        case 0x09:\n            output = 0x47;\n            break;\n        case 0x0c:\n            output = 0x54;\n            break;\n        case 0x0f:\n            output = 0x50;\n            break;\n        case 0xf1:\n            output = 0x66;\n            break;\n        case 0xf4:\n            output = 0x70;\n            break;\n        case 0xf7:\n            output = 0x6e;\n            break;\n        case 0xfa:\n            output = 0x75;\n            break;\n        case 0xfd:\n            output = 0x6d;\n            break;\n        default:\n            output = 0;\n            break;\n    }\n    return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "map_input_to_output_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_ptr",
                "param_2": "arg",
                "uVar1": "result"
            },
            "code": "int32_t execute_function_00003d64(int32_t function_ptr, int32_t arg) {\n  int32_t result;\n  if (function_ptr == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(function_ptr + 0xc))(*(int32_t *)(function_ptr + 4), arg);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_bytes_00004e52",
                "*param_1": "*first_byte",
                "*param_2": "*second_byte",
                "uVar2": "first_byte_val",
                "bVar1": "second_byte_val",
                "bVar3": "are_bytes_equal"
            },
            "code": "int compare_bytes_00004e52(byte *first_byte, byte *second_byte)\n{\n  byte first_byte_val;\n  byte second_byte_val;\n  bool are_bytes_equal;\n  do {\n    first_byte_val = *first_byte;\n    second_byte_val = *second_byte;\n    are_bytes_equal = first_byte_val == 1;\n    if (first_byte_val != 0) {\n      are_bytes_equal = first_byte_val == second_byte_val;\n    }\n    first_byte++;\n    second_byte++;\n  } while (are_bytes_equal);\n  return first_byte_val - second_byte_val;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002b10",
                "FUN_00004e52",
                "FUN_00005100",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002a18"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "initialize_data_structure_000010d4",
                "param_1": "start_address",
                "param_2": "size",
                "param_3": "flags",
                "param_4": "arg_3",
                "param_5": "arg_4",
                "param_6": "arg_5",
                "param_7": "arg_6",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "iVar3": "return_value",
                "uVar4": "temp_3",
                "puVar5": "ptr_1",
                "local_30": "temp_4",
                "local_2c": "temp_5",
                "local_10": "temp_6",
                "local_c": "index_1",
                "local_a": "index_2"
            },
            "code": "int initialize_data_structure_000010d4(uint start_address, int size, byte flags, uint arg_3, undefined4 arg_4, undefined4 arg_5, undefined4 arg_6)\n{\n  undefined4 temp_1;\n  undefined4 temp_2;\n  int return_value;\n  uint temp_3;\n  undefined4 *ptr_1;\n  int temp_4;\n  uint temp_5;\n  uint temp_6;\n  short index_1 = 0;\n  short index_2 = 0;\n  \n  if (flags < 0x10) {\n    temp_4 = size;\n    temp_5 = start_address;\n    if ((start_address & 3) != 0) {\n      temp_4 = 4 - (start_address & 3);\n      temp_5 = temp_4 + start_address;\n      temp_4 = size - temp_4;\n    }\n    temp_3 = temp_4 - 0x30U & 0xfffffffc;\n    ptr_1 = (undefined4 *)(temp_3 + temp_5);\n    if ((arg_3 & 8) == 0) {\n      *(uint *)temp_5 = temp_5;\n    }\n    else {\n      for (temp_6 = temp_5; temp_6 < temp_3 + temp_5; temp_6 = temp_6 + 4) {\n        *(uint *)temp_6 = temp_6;\n      }\n    }\n    temp_1 = is_irq_interrupts_enabled_00000cd0();\n    for (index_1 = 1; index_1 < 0x21; index_1 = index_1 + 1) {\n      if (*(int *)(PTR_DAT_0000126c + index_1 * 4) == 0) {\n        index_2 = index_1;\n        break;\n      }\n    }\n    if (index_2 == 0) {\n      enable_IRQ_interrupts_if_privileged_00000d0c(temp_1);\n      return_value = -0x8b;\n    }\n    else {\n      *(undefined4 **)(PTR_DAT_0000126c + index_2 * 4) = ptr_1;\n      *(short *)((int)ptr_1 + 6) = index_2;\n      temp_2 = initialize_array_000007dc(arg_4, arg_5, temp_5, temp_3);\n      *ptr_1 = temp_2;\n      ptr_1[9] = temp_5;\n      ptr_1[0xb] = size;\n      ptr_1[10] = arg_6;\n      *(byte *)((int)ptr_1 + 5) = flags;\n      *(undefined *)(ptr_1 + 1) = 0;\n      ptr_1[2] = 0;\n      ptr_1[3] = 0;\n      ptr_1[4] = 0;\n      initialize_array_00000fec(ptr_1 + 5,0);\n      ptr_1[8] = 0;\n      *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n      if ((arg_3 & 1) == 0) {\n        update_linked_list_00000698(ptr_1,10);\n        if ((arg_3 & 4) == 0) {\n          enable_IRQ_interrupts_if_privileged_00000d0c(temp_1);\n          check_exception_threshold_00000738(flags);\n          return (int)index_2;\n        }\n      }\n      else {\n        update_linked_list_00000698(ptr_1,1);\n      }\n      enable_IRQ_interrupts_if_privileged_00000d0c(temp_1);\n      return_value = (int)index_2;\n    }\n  }\n  else {\n    return_value = -0x16;\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000fec",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000738",
                "FUN_000007dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_exception_threshold_00000738",
                "param_1": "exception_count",
                "iVar1": "exception_number",
                "data_address": "PTR_DAT_0000078c",
                "exception_threshold": "*(byte*)(data_address + 4)",
                "minimum_exception_count": "*(byte*)(data_address + 5)"
            },
            "code": "void check_exception_threshold_00000738(ushort exception_count) {\n  int exception_number;\n  int* data_address = *(int*)PTR_DAT_0000078c;\n  int exception_threshold = *(byte*)(data_address + 4);\n  int minimum_exception_count = *(byte*)(data_address + 5);\n  if (exception_threshold < 9 || exception_count < minimum_exception_count) {\n    exception_number = get_exception_number_00000d2a();\n    if (exception_number == 0) {\n      set_flag_on_data_address_0000093c();\n    }\n    else {\n      *(undefined4*)PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "check_exception_threshold_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "count_digits_and_sign_00003e58",
                "param_1": "number",
                "param_2": "length",
                "local_18": "num_length",
                "local_14": "num_ptr",
                "iVar1": "digit_count"
            },
            "code": "int count_digits_and_sign_00003e58(int *number, int length) {\n  int digit_count;\n  int is_negative = length >> 0x1f;\n  int *number_ptr = number;\n  if (is_negative != 0) {\n    if (number != NULL) {\n      number_ptr = number + 1;\n      *number = '-';\n    }\n    length = -length;\n  }\n  digit_count = count_digits(number_ptr, length);\n  return is_negative + digit_count;\n}\n",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "count_digits_and_sign_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "set_param_to_19_000004f2_wrapper_00004e26",
                "param_1": "device_handle",
                "param_2": "buffer_address",
                "iVar1": "set_param_result",
                "uVar2": "buffer_value",
                "bVar3": "set_param_failed"
            },
            "code": "void set_param_to_19_000004f2_wrapper_00004e26(undefined4 device_handle, int buffer_address)\n{\n  int set_param_result;\n  ushort buffer_value;\n  bool set_param_failed;\n  \n  set_param_result = set_param_to_19_000004f2(device_handle,(int)*(short *)(buffer_address + 0xe));\n  set_param_failed = set_param_result == -1;\n  if (set_param_failed) {\n    buffer_value = *(ushort *)(buffer_address + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(buffer_address + 0x54) = set_param_result;\n    buffer_value = *(ushort *)(buffer_address + 0xc) | 0x1000;\n  }\n  if (set_param_failed) {\n    *(ushort *)(buffer_address + 0xc) = buffer_value;\n  }\n  if (!set_param_failed) {\n    *(ushort *)(buffer_address + 0xc) = buffer_value;\n  }\n  return;\n}",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "set_param_to_19_000004f2_wrapper_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_00004db8",
                "FUN_00005790",
                "FUN_00004274",
                "FUN_0000428c",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  bool bVar6;\n  byte *pbVar7;\n  int unaff_r7;\n  byte *pbVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_pointers_if_null_000042a4();\n  }\n  if (param_2 == PTR_DAT_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar3 = update_list_000054a8(param_1,param_2), iVar3 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar1 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar7 = pbVar8;\n  if (*pbVar7 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar8 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar3 = (int)pbVar7 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = process_input_000057d2(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar7 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar7 + 1;\n  while( true ) {\n    pbVar7 = pbVar8 + 1;\n    iVar3 = find_byte_sequence_00006010(PTR_s___0__00005a44,*pbVar8,5);\n    puVar2 = PTR_DAT_00005a54;\n    if (iVar3 == 0) break;\n    local_88 = 1 << (iVar3 - (int)puVar1 & 0xffU) | local_88;\n    pbVar8 = pbVar7;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar5 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar5;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar6 = false;\n    iVar3 = local_7c;\n    pbVar7 = pbVar8;\n    while( true ) {\n      if (9 < *pbVar7 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n      bVar6 = true;\n      pbVar7 = pbVar7 + 1;\n    }\n    if (bVar6) {\n      local_7c = iVar3;\n    }\n  }\n  if (*pbVar7 == 0x2e) {\n    if (pbVar7[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar7 = pbVar7 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar6 = false;\n      local_84 = 0;\n      iVar3 = 0;\n      while( true ) {\n        pbVar7 = pbVar7 + 1;\n        if (9 < *pbVar7 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n        bVar6 = true;\n      }\n      if (bVar6) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_00005a54,*pbVar7,3);\n  if (iVar3 != 0) {\n    local_88 = local_88 | 0x40 << (iVar3 - (int)puVar2 & 0xffU);\n    pbVar7 = pbVar7 + 1;\n  }\n  param_3 = pbVar7 + 1;\n  local_70 = *pbVar7;\n  iVar3 = find_byte_sequence_00006010(PTR_s_efgEFG_00005a48,local_70,6);\n  if (iVar3 == 0) {\n    iVar3 = FUNC_00005b34(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar3 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar3 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar3 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar3;\n  pbVar8 = param_3;\n  unaff_r7 = iVar3;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00005b34",
                "FUN_00006010",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4",
                "FUN_000057d2"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "perform_task_000018bc",
                "update_bitfield_00001748": "update_bitfield",
                "*DAT_00001910": "*data_pointer_1",
                "clear_memory_at_offset_00001710": "clear_memory",
                "DAT_00001914": "data_pointer_2"
            },
            "code": "void perform_task_000018bc(int bit_value); // declare function\n\nvoid perform_task_000018bc(void)\n{\n  perform_task_000018bc(0xa0);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4; // update data pointer\n  clear_memory(DAT_00001914,1);\n  do {\n  } while ((data_pointer_1[6] & 0x10) == 0); // wait for bit to set\n  do {\n  } while ((data_pointer_1[6] & 0xc) != 0); // wait for bits to clear\n  *PTR_DAT_00001918 = 0; // set pointer to zero\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "perform_task_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "process_data_00000f04",
                "param_1": "data",
                "param_2": "param",
                "*piRam00000f4c": "is_initialized",
                "local_10": "param",
                "local_9": "data",
                "process_data_00000ed8": "process_data_1",
                "process_data_00004c84": "process_data_2",
                "process_data_from_pointers_0000211c": "process_data_3",
                "is_irq_interrupts_enabled_00000cd0": "is_irq_interrupts_enabled",
                "do_nothing_00000ef8": "do_nothing",
                "wait_for_interrupt_00000e58": "wait_for_interrupt",
                "uStack_18": "stack_var",
                "process_data_00004c84(PTR_s_main____This_is_RIOT___Version__2_00000f7c)": "process_data_4",
                "process_interrupt_request_and_handle_000023a4": "process_interrupt_request_and_handle",
                "UNRECOVERED_JUMPTABLE": "unrecovered_jumptable"
            },
            "code": "void process_data_00000f04(char data, uint32_t param)\n{\n    static bool is_initialized = false;\n    static uint32_t *ptr_1 = (uint32_t *)0x0f50;\n    static uint32_t *ptr_2 = (uint32_t *)0x0f54;\n    static uint32_t *ptr_3 = (uint32_t *)0x0f58;\n    uint32_t stack_var = (uint32_t)&stack_var + 1;\n\n    if (!is_initialized) {\n        is_initialized = true;\n        if (data == 0x03) {\n            process_data_00000f04_00000ed8();\n        }\n        process_data_00000f04_00004c84(*ptr_1, param);\n        process_data_00000f04_from_pointers_0000211c();\n        process_data_00000f04_00004c84(*ptr_2);\n        process_data_00000f04_00004c84(*ptr_3);\n    }\n\n    if (is_irq_interrupts_enabled_00000cd0()) {\n        do_nothing_00000ef8();\n        wait_for_interrupt_00000e58();\n        process_data_00000f04_00004c84(PTR_s_main____This_is_RIOT___Version__2_00000f7c)(\"s_main____This_is_RIOT___Version__2\");\n        process_interrupt_request_and_handle();\n        ((void(*)())0xf4d)();\n    }\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_0000211c",
                "FUN_00002400",
                "FUN_00000ed8",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_000023a4",
                "FUN_00000e58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000fec",
                "FUN_00001034",
                "FUN_00000a30"
            ],
            "imported": false,
            "current_name": "process_data_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "check_if_match_found_00000610",
                "iVar1": "current_item_index",
                "iVar2": "target_item_index",
                "uVar3": "match_found",
                "g_ptr_dat_00000684": "ptr_data_1",
                "g_ptr_dat_00000688": "ptr_data_2",
                "g_ptr_dat_0000068c": "ptr_data_3",
                "g_ptr_dat_00000690": "ptr_data_4"
            },
            "code": "int check_if_match_found_00000610(void)\n{\n  int current_item_index;\n  int target_item_index;\n  int match_found = 0;\n  \n  *(undefined4 *)g_ptr_dat_00000684 = 0;\n  target_item_index = *(int *)g_ptr_dat_00000688;\n  current_item_index = reverse_engineer_and_improve_00000566(*(undefined4 *)g_ptr_dat_0000068c);\n  current_item_index = **(int **)(g_ptr_dat_00000690 + current_item_index * 4);\n  if (target_item_index == current_item_index + -8) {\n    match_found = 1;\n  }\n  else {\n    if ((target_item_index != 0) && (*(char *)(target_item_index + 4) == '\t')) {\n      *(undefined *)(target_item_index + 4) = 10;\n    }\n    *(undefined *)(current_item_index + -4) = 9;\n    *(undefined2 *)g_ptr_dat_00000694 = *(undefined2 *)(current_item_index + -2);\n    *(int *)g_ptr_dat_00000688 = current_item_index + -8;\n    match_found = 1;\n  }\n  return match_found;\n}",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "check_if_match_found_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "data_object_address",
                "param_2": "number_of_bytes_to_display",
                "uVar1": "label_value",
                "cVar2": "is_bit_set",
                "uVar3": "bit_mask",
                "bVar4": "is_bit_set_bool",
                "auStack_18": "stack_buffer",
                "local_10": "buffer_index",
                "local_a": "mapped_input_char",
                "local_9": "current_byte",
                "PTR_s_Unable_to_display_data_object_000037e4": "Unable to display data object.",
                "process_data_00004c84": "process_data",
                "PTR_s_Data__000037e8": "Data:",
                "PTR_LAB_000037f0": "[",
                "PTR_s__000037f8": " ",
                "PTR_s___u__000037f4": " [",
                "PTR_LAB_00003800": "hex: ",
                "PTR_LAB_00003804": "decimal: ",
                "PTR_s__iE_i_00003808": "int: ",
                "PTR_s__6d__c_000037fc": "char: ",
                "PTR_LAB_0000380c": " ["
            },
            "code": "display_data_object_00003694(intPTR_s__000037f8data_object_address,PTR_s__000037f8intPTR_s__000037f8number_of_bytes_to_display)PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8undefined4PTR_s__000037f8uVar1;\nPTR_s__000037f8PTR_s__000037f8charPTR_s__000037f8is_bit_set;\nPTR_s__000037f8PTR_s__000037f8uintPTR_s__000037f8bit_mask;\nPTR_s__000037f8PTR_s__000037f8boolPTR_s__000037f8is_bit_set_bool;\nPTR_s__000037f8PTR_s__000037f8undefinedPTR_s__000037f8stack_bufferPTR_LAB_000037f08];\nPTR_s__000037f8PTR_s__000037f8intPTR_s__000037f8buffer_index;\nPTR_s__000037f8PTR_s__000037f8charPTR_s__000037f8mapped_input_char;\nPTR_s__000037f8PTR_s__000037f8bytePTR_s__000037f8current_byte;\nPTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8((data_object_addressPTR_s__000037f8==PTR_s__000037f80)PTR_s__000037f8||PTR_s__000037f8(number_of_bytes_to_displayPTR_s__000037f8>PTR_s__000037f83))PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8display_error_message(\"PTR_s_Unable_to_display_data_object_00003694_000037e4\");\nPTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8elsePTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_s_Data__000037e8\");\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8forPTR_s__000037f8(current_bytePTR_s__000037f8=PTR_s__000037f80;PTR_s__000037f8current_bytePTR_s__000037f8<PTR_s__000037f8number_of_bytes_to_display;PTR_s__000037f8current_bytePTR_s__000037f8=PTR_s__000037f8current_bytePTR_s__000037f8+PTR_s__000037f81)PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(*(bytePTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f86)PTR_s__000037f8<PTR_s__000037f80x14)PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8bit_maskPTR_s__000037f8=PTR_s__000037f81PTR_s__000037f8<<PTR_s__000037f8(uint)*(bytePTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f86);\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8is_bit_set_boolPTR_s__000037f8=PTR_s__000037f8bit_maskPTR_s__000037f8!=PTR_s__000037f80;\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(is_bit_set_bool)PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8bit_maskPTR_s__000037f8=PTR_s__000037f81;\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8is_bit_setPTR_s__000037f8=PTR_s__000037f8(char)bit_mask;\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(!is_bit_set_bool)PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8is_bit_setPTR_s__000037f8=PTR_s__000037f8'\\0';\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(is_bit_setPTR_s__000037f8==PTR_s__000037f8'\\0')PTR_s__000037f8gotoPTR_s__000037f8skip_current_byte;\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8mapped_input_charPTR_s__000037f8=PTR_s__000037f8'\\0';\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8elsePTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8skip_current_byte:\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8mapped_input_charPTR_s__000037f8=PTR_s__000037f8map_input_to_output((int)*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87));\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_LAB_000037f0\",PTR_s__000037f8current_byte,PTR_s__000037f8\"]\");\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(number_of_bytes_to_displayPTR_s__000037f8<PTR_s__000037f82)PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_s__000037f8\");\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8elsePTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_s___u__000037f4\",PTR_s__000037f8current_byte,PTR_s__000037f8\"]PTR_s__000037f8\");\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(mapped_input_charPTR_s__000037f8==PTR_s__000037f8'\\0')PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8ifPTR_s__000037f8(*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87)PTR_s__000037f8==PTR_s__000037f8'\\0')PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_LAB_00003800\",PTR_s__000037f8(int)*(shortPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f8(uint)current_bytePTR_s__000037f8*PTR_s__000037f82));\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8elsePTR_s__000037f8ifPTR_s__000037f8((*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87)PTR_s__000037f8+PTR_s__000037f84PTR_s__000037f8<PTR_s__000037f80PTR_s__000037f8==PTR_s__000037f8SCARRY4((int)*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87),4))PTR_s__000037f8&&PTR_s__000037f8(*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87)PTR_s__000037f8<PTR_s__000037f8'\\0'))PTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8buffer_indexPTR_s__000037f8=PTR_s__000037f8count_decimal_digits_and_sign(stack_buffer,PTR_s__000037f8(int)*(shortPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f8(uint)current_bytePTR_s__000037f8*PTR_s__000037f82),PTR_s__000037f8(int)*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87));\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8stack_bufferPTR_LAB_000037f0buffer_index]PTR_s__000037f8=PTR_s__000037f80;\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_LAB_00003804\",PTR_s__000037f8stack_buffer);\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8elsePTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_s__iE_i_00003808\",PTR_s__000037f8(int)*(shortPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f8(uint)current_bytePTR_s__000037f8*PTR_s__000037f82),PTR_s__000037f8(int)*(charPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f87));\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8elsePTR_s__000037f8{\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_s__6d__c_000037fc\",PTR_s__000037f8(int)*(shortPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f8(uint)current_bytePTR_s__000037f8*PTR_s__000037f82),PTR_s__000037f8mapped_input_char);\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8uVar1PTR_s__000037f8=PTR_s__000037f8get_label_for_param_value(*(undefinedPTR_s__000037f8*)(data_object_addressPTR_s__000037f8+PTR_s__000037f86));\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8process_data_00004c84(\"PTR_s___u__000037f4\",PTR_s__000037f8uVar1,PTR_s__000037f8\"]\");\nPTR_s__000037f8PTR_s__000037f8PTR_s__000037f8PTR_s__000037f8}\nPTR_s__000037f8PTR_s__000037f8}\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003e9e",
                "FUN_00003918",
                "FUN_00003810"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_0000305c",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_and_increment_value_at_address_000022be_00002364",
                "param_1": "address",
                "param_2": "value",
                "iVar1": "difference",
                "uVar2": "return_value"
            },
            "code": "int check_and_increment_value_at_address_000022be_00002364(int *address, int value){\n  int difference = check_if_difference_equals_third_parameter_00002294(address);\n  if (difference == 0) {\n    increment_and_set_value_at_address_000022be(address, value);\n    return 0;\n  }\n  else {\n    return -1;\n  }\n}",
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_and_increment_value_at_address_000022be_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "clear_bits_and_wait_until_condition_met_00001ad4",
                "DAT_00001b08": "data_ptr",
                "PTR_DAT_00001b0c": "PTR_clear_bits_and_wait_until_condition_met"
            },
            "code": "void clear_bits_and_wait_until_condition_met_00001ad4(void)\n{\n  int* DAT_00001b08 = DAT_00001b08;\n  *DAT_00001b08 &= 0x3f;\n  while ((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "clear_bits_and_wait_until_condition_met_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_and_clear_memory_00001274",
                "initialize_data_0000258c": "initialize_data",
                "*DAT_00001298": "*data_pointer",
                "clear_and_initialize_memory_00001c84": "clear_and_initialize_memory",
                "FUNC_00002396": "execute_function"
            },
            "code": "void initialize_and_clear_memory_00001274(void)\n{\n  initialize_data();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  clear_and_initialize_memory();\n  execute_function();\n  return;\n}",
            "called": [
                "FUN_0000258c",
                "FUN_00001c84",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "initialize_and_clear_memory_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "process_input_and_data_00002e6c",
                "param_1": "PTR_param_1",
                "param_2": "PTR_param_2",
                "param_3": "PTR_param_3",
                "iVar1": "input_decoded",
                "decode_input_data_00002d94": "decode_input_data",
                "parse_command_line_args_00002b10": "parse_command_line_args"
            },
            "code": "void process_input_and_data_00002e6c(){\n    int input_decoded;\n    process_input_and_data_00002e6c();\n    do {\n        input_decoded = decode_input_data(PTR_param_2, PTR_param_3);\n        if (input_decoded == 0) {\n            parse_command_line_args_00002b10(PTR_param_1, PTR_param_2);\n        }\n        process_input_and_data_00002e6c();\n    } while(true);\n}",
            "called": [
                "FUN_00002d94",
                "FUN_00002b10",
                "FUN_00002e48"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "process_input_and_data_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "check_date_validity_00003444",
                "iVar1": "date_processing_result",
                "auStack_2c": "date_buffer",
                "process_date_00002624": "process_date",
                "process_input": "report_error",
                "calculate_something_00003378": "calculate_something"
            },
            "code": "bool check_date_validity_00003444(void)\n{\n    int date_processing_result;\n    undefined date_buffer[36];\n    date_processing_result = process_date(date_buffer);\n    if (date_processing_result != 0)\n    {\n        report_error(PTR_s_rtc__error_getting_time_00003474);\n    }\n    else\n    {\n        calculate_something(date_buffer);\n    }\n    return date_processing_result != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002624"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_date_validity_00003444",
            "code_backup": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = process_date_00002624(auStack_2c);\n  if (iVar1 != 0) {\n    process_input(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    calculate_something_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "perform_data_sync_00003688",
                "perform_data_sync_00003658": "perform_data_sync_helper"
            },
            "code": "void perform_data_sync_00003688(void)\n{\n  perform_data_sync_00003688_helper();\n  return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "perform_data_sync_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_result_to_one_if_calculated_result_not_null_00001392",
                "param_1": "num1",
                "param_2": "letter",
                "puVar1": "result_ptr",
                "calculate_result_00001360": "calculate_result"
            },
            "code": "void set_result_to_one_if_calculated_result_not_null_00001392(int num1, char letter) {\n  undefined4 *result_ptr;\n  result_ptr = (undefined4 *)calculate_result(num1, letter);\n  if (result_ptr != NULL) {\n    *result_ptr = 1;\n  }\n  return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_result_to_one_if_calculated_result_not_null_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_flags_00002910",
                "DAT_00002944": "DATA_ADDRESS",
                "PTR_DAT_00002948": "DATA_POINTER",
                "iVar1": "data_address",
                "*(uint *)(DAT_00002944 + 0x1c)": "*flags_address",
                "*(undefined4 *)(iVar1 + 8)": "*(undefined4 *)(data_address + 8)"
            },
            "code": "void clear_flags_00002910(void)\n{\n  int data_address = DAT_00002944;\n  uint* flags_address = (uint*)(data_address + 0x1c);\n  *(uint *)(DAT_00002944 + 0x1c) &= 0xfffffffb;\n  *(undefined4 *)(data_address + 8) = 0;\n  *(undefined4 *)PTR_DAT_00002948 = 0;\n  *(undefined4 *)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "clear_flags_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "decode_data_00004418_00004418",
                "ppbVar2": "data_pointers",
                "pbVar3": "data_pointer",
                "iVar4": "data_pointer_address"
            },
            "code": "uint decode_data_00004418_00004418(void)\n{\n  uint result;\n  byte **data_pointers;\n  byte *data_pointer;\n  int data_pointer_address;\n  \n  data_pointer_address = *data_address_00004438;\n  if ((data_pointer_address != 0) && (*(int *)(data_pointer_address + 0x18) == 0)) {\n    initialize_pointers_if_null_000042a4(data_pointer_address);\n  }\n  data_pointers = *(byte ***)(data_pointer_address + 4);\n  if ((data_pointer_address != 0) && (*(int *)(data_pointer_address + 0x18) == 0)) {\n    initialize_pointers_if_null_000042a4();\n  }\n  if (data_pointers == (byte **)data_pointer_00005620) {\n    data_pointers = *(byte ***)(data_pointer_address + 4);\n  }\n  else if (data_pointers == (byte **)data_pointer_00005624) {\n    data_pointers = *(byte ***)(data_pointer_address + 8);\n  }\n  else if (data_pointers == (byte **)data_pointer_00005628) {\n    data_pointers = *(byte ***)(data_pointer_address + 0xc);\n  }\n  if ((-1 < (int)data_pointers[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(data_pointers + 3) << 0x16))) {\n    do_nothing_000045e8(data_pointers[0x16]);\n  }\n  data_pointer = data_pointers[1];\n  data_pointers[1] = data_pointer - 1;\n  if ((int)(data_pointer - 1) < 0) {\n    result = decode_data_00005e10(data_pointer_address,data_pointers);\n  }\n  else {\n    data_pointer = *data_pointers;\n    *data_pointers = data_pointer + 1;\n    result = (uint)*data_pointer;\n  }\n  if ((-1 < (int)data_pointers[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(data_pointers + 3) << 0x16))) {\n    do_nothing_000045ec(data_pointers[0x16]);\n  }\n  return result;\n}\n",
            "called": [
                "FUN_000045e8",
                "FUN_00005e10",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "decode_data_00004418_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_data_0000258c",
                "local_c": "data_ptr",
                "set_data_00002538": "set_data",
                "DAT_000025ec": "data_start",
                "DAT_000025f0": "data_value"
            },
            "code": "void initialize_data_0000258c(void)\n{\n  uint32_t data_ptr;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  set_data(0xfffffffe, 1);\n  set_data(0xfffffffb, 1);\n  for (data_ptr = 0; data_ptr < 0x66; data_ptr++) {\n    set_data((int32_t)(char)data_ptr, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_data_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "process_input_00002a00",
                "param_1": "input"
            },
            "code": "void process_input_00002a00(undefined4 input){\n  process_input_00002a00_00004cb4(input);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002d94",
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_input_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "find_flag_000043a0",
                "param_1": "base_address",
                "param_2": "callback",
                "piVar2": "ptr",
                "uVar4": "flag",
                "iVar5": "count",
                "iVar3": "item",
                "uVar1": "result"
            },
            "code": "uint find_flag_000043a0(int base_address, code *callback)\n{\n  uint flag = 0;\n  int *ptr = (int *)(base_address + 0x48);\n  do {\n    int count = ptr[1];\n    int item = ptr[2];\n    while (count = count - 1, -1 < count) {\n      if ((1 < *(ushort *)(item + 0xc)) && (*(short *)(item + 0xe) != -1)) {\n        uint result = (*callback)(item);\n        flag = flag | result;\n      }\n      item = item + 0x68;\n    }\n    ptr = (int *)*ptr;\n  } while (ptr != (int *)0x0);\n  return flag;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "find_flag_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "process_data_from_pointers_0000211c",
                "local_40": "local_data_buffer",
                "local_3c": "data_size",
                "local_38": "data_offset",
                "local_34": "data_value",
                "local_30": "data_index",
                "local_2c": "data_pointer",
                "local_28": "stack_pointer",
                "local_24": "data_pointer_array",
                "local_20": "count",
                "local_1a": "i",
                "local_18": "total_size",
                "local_14": "total_offset"
            },
            "code": "void process_data_from_pointers_0000211c(void)\n{\n  int total_offset = 0;\n  int total_size = 0;\n  uint8_t local_data_buffer[33];\n  uint32_t count = count_relocation_entries();\n  uint32_t *data_pointer_array = get_relocation_data_pointer_array();\n  uint32_t *stack_pointer = get_main_stack_pointer();\n  if (count > 0) {\n    total_size = count + total_size;\n  }\n  for (uint8_t i = 1; i < 0x21; i++) {\n    uint32_t *data_pointer = *(uint32_t **)(data_pointer_array + i * 4);\n    if (data_pointer != (uint32_t *)0x0) {\n      uint8_t data_index = (uint8_t)*(uint8_t *)(data_pointer + 1);\n      uint32_t data_value = *(uint32_t *)(data_pointer_array + data_index * 4);\n      uint32_t data_offset = (int)&local_data_buffer + (uint8_t)(8 < data_index);\n      uint32_t data_size = data_pointer[0xb];\n      total_offset = data_size + total_offset;\n      int offset_from_pointer = calculate_offset_from_pointer(data_pointer[9]);\n      data_size = data_size - offset_from_pointer;\n      total_size = data_size + total_size;\n      process_data(data_pointer, (int)*(uint16_t *)((int)data_pointer + 6),data_pointer[10],data_value,data_offset,\n                   *(uint8_t *)((int)data_pointer + 5),data_pointer[0xb],data_size,data_pointer[9],*data_pointer);\n    }\n  }\n  process_result(PTR_s___5s___21s__13s_6s__6i___5i___0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,total_offset,total_size);\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000008b8",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_0000091c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "process_data_from_pointers_0000211c",
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  undefined4 local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUNC_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248\n              );\n  local_20 = count_Elf32_Rel_ARRAY_000008fc_000008b8();\n  local_24 = get_pointer_to_data_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUNC_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(PTR_DAT_00002258 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = *(undefined4 *)(DAT_0000225c + local_30 * 4);\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = calculate_offset_from_pointer_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUNC_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUNC_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_key_value_pair_0000562c",
                "param_1": "param",
                "param_2": "key_value_str",
                "param_3": "index_of_key_value_pair",
                "cVar1": "current_char",
                "ppiVar2": "key_value_pairs",
                "piVar3": "current_key_value_pair",
                "iVar4": "compare_result",
                "pcVar5": "current_char_ptr",
                "piVar6": "current_key_value_pair_ptr",
                "iVar7": "key_value_str_len"
            },
            "code": "int find_key_value_pair_0000562c(undefined4 param_1, char *key_value_str, int *index_of_key_value_pair) {\n  char current_char;\n  int **key_value_pairs = DAT_0000569c;\n  char *current_char_ptr = key_value_str;\n  if (*DAT_0000569c != (int *)0x0) {\n    do {\n      current_char = *current_char_ptr;\n      if (current_char == '\\0') {\n        int key_value_str_len = (int)current_char_ptr - (int)key_value_str;\n        int *current_key_value_pair = *DAT_0000569c;\n        while (true) {\n          int *current_key_value_pair_ptr = current_key_value_pair;\n          if (*current_key_value_pair_ptr == 0) break;\n          int compare_result = compare_bytes(*current_key_value_pair_ptr, key_value_str, key_value_str_len);\n          current_key_value_pair = current_key_value_pair_ptr + 1;\n          if ((compare_result == 0) && (compare_result = *current_key_value_pair_ptr, *(char *)(compare_result + key_value_str_len) == '=')) {\n            *index_of_key_value_pair = (int)current_key_value_pair_ptr - (int)*key_value_pairs >> 2;\n            do_nothing_with_data(param_1);\n            return compare_result + key_value_str_len + 1;\n          }\n        }\n        break;\n      }\n      current_char_ptr++;\n    } while (current_char != '=');\n  }\n  do_nothing_with_data(param_1);\n  return 0;\n}",
            "called": [
                "FUN_00005fec",
                "FUN_00005ff8",
                "FUN_00004e66"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_key_value_pair_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "extract_bits_and_call_function_000020b8",
                "DAT_000020c8": "data",
                "PTR_": "start_bit"
            },
            "code": "void extract_bits_and_call_function_000020b8(unsigned char* DAT_000020c8, int PTR_){\n  extract_bits_and_call_function_000020b8(DAT_000020c8, PTR_);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "extract_bits_and_call_function_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "search_in_memory_00002a18",
                "param_1": "memory_blocks",
                "param_2": "search_value",
                "local_18": "block_pointers",
                "local_10": "block_index",
                "local_c": "block_pointer",
                "PTR_PTR_s_reboot_00002a84": "reboot_block_pointer"
            },
            "code": "int search_in_memory_00002a18(int* memory_blocks, int search_value) {\n  int* block_pointer;\n  int block_index = 0;\n  int* PTR_PTR_s_reboot_00002a84 = (int*)PTR_PTR_s_reboot_00002a84;\n  while (block_index < 2) {\n    block_pointer = memory_blocks[block_index];\n    if (block_pointer != NULL) {\n      while (*block_pointer != 0) {\n        int comparison_result = compare_bytes_00004e52(*block_pointer, search_value);\n        if (comparison_result == 0) {\n          return block_pointer[2];\n        }\n        block_pointer += 3;\n      }\n    }\n    block_index++;\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "search_in_memory_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "update_list_000054a8",
                "*param_1": "*output",
                "*param_2": "*input",
                "uVar1": "list_item_flags_2",
                "uVar2": "func_var2",
                "uVar3": "list_item_flags_2_uint",
                "uVar4": "func_var1",
                "iVar5": "list_head",
                "DAT_00005574": "list_head_ptr",
                "PTR_DAT_00005578": "list_1_ptr",
                "PTR_DAT_0000557c": "list_2_ptr",
                "PTR_DAT_00005580": "list_3_ptr"
            },
            "code": "uint update_list_000054a8(uint32_t* output, uint32_t* input)\n{\n  uint32_t func_var1;\n  uint32_t func_var2;\n  uint32_t allocated_memory;\n  int32_t list_head;\n  \n  list_head = *DAT_00005574;\n  if ((list_head != 0) && (*(int32_t *)(list_head + 0x18) == 0)) {\n    clear_list(list_head);\n  }\n  if (input == PTR_DAT_00005578) {\n    input = *(uint32_t **)(list_head + 4);\n  }\n  else if (input == PTR_DAT_0000557c) {\n    input = *(uint32_t **)(list_head + 8);\n  }\n  else if (input == PTR_DAT_00005580) {\n    input = *(uint32_t **)(list_head + 0xc);\n  }\n  \n  uint32_t list_item_flags = *(uint16_t *)(input + 3);\n  func_var2 = *(uint16_t *)(input + 3);\n  \n  if (-1 < (int32_t)(list_item_flags << 0x1c)) {\n    if (-1 < (int32_t)(list_item_flags << 0x1b)) {\n      *output = 9;\n      goto LAB_000054d8;\n    }\n    if ((uint32_t *)(input[0xd]) != (uint32_t *)0x0) {\n      if ((uint32_t *)(input[0xd]) != input + 0x11) {\n        update_list_000054a8(output);\n      }\n      input[0xd] = 0;\n    }\n    *(uint16_t *)(input + 3) = *(uint16_t *)(input + 3) & 0xffdb;\n    input[1] = 0;\n    *input = input[4];\n  }\n  *(uint16_t *)(input + 3) = *(uint16_t *)(input + 3) | 8;\n  \n  if ((input[4] == 0) && ((*(uint16_t *)(input + 3) & 0x280) != 0x200)) {\n    allocate_memory_and_set_flag(output, input);\n  }\n  \n  uint16_t list_item_flags_2 = *(uint16_t *)(input + 3);\n  uint32_t list_item_flags_2_uint = (uint32_t)list_item_flags_2;\n  func_var1 = list_item_flags_2_uint & 1;\n  if ((list_item_flags_2 & 1) == 0) {\n    if (-1 < (int32_t)(list_item_flags_2_uint << 0x1e)) {\n      func_var1 = input[5];\n    }\n    input[2] = func_var1;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((list_item_flags_2 & 0x80) == 0) {\n    return list_item_flags_2_uint & 0x80;\n  }\n  \nLAB_000054d8:\n  *(uint16_t *)(input + 3) = func_var2 | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "update_list_000054a8",
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *DAT_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    FUNC_000042a4(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          update_list_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    allocate_memory_and_set_flag_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "initialize_array_000007dc",
                "param_1": "data",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "aligned_size",
                "local_14": "i",
                "local_10": "i",
                "local_c": "array_ptr"
            },
            "code": "int* initialize_array_000007dc(uint32_t data, int param_2, int param_3, int param_4) {\n  uint32_t aligned_size = (param_4 + param_3) & 0xfffffffc;\n  int* array_ptr = (int*)(aligned_size - 4);\n  *array_ptr = 0x77777777;\n  if (((uint)array_ptr & 7) != 0) {\n    array_ptr = (int*)(aligned_size - 8);\n    *array_ptr = 0x88888888;\n  }\n  array_ptr[-1] = 0x1000000;\n  array_ptr[-2] = data;\n  array_ptr[-3] = DAT_000008b4;\n  array_ptr--;\n  *array_ptr = 0;\n  for (int i = 3; i > 0; i--) {\n    array_ptr--;\n    *array_ptr = i;\n  }\n  array_ptr--;\n  *array_ptr = param_2;\n  for (int i = 0xb; i > 3; i--) {\n    array_ptr--;\n    *array_ptr = i;\n  }\n  array_ptr[-1] = -3;\n  return array_ptr - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_array_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_memory_at_offset_00001710",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "memory_address"
            },
            "code": "void clear_memory_at_offset_00001710(void* base_address, size_t offset) {\n  undefined* memory_address = (undefined*)calculate_offset(base_address, offset);\n  *memory_address = 0;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_00001778",
                "FUN_00001734",
                "FUN_0000182c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "clear_memory_at_offset_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_0000579c",
                "FUN_00004158",
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "find_and_insert_00001034",
                "param_1": "data_array",
                "param_2": "data_to_insert",
                "local_1c": "current_data",
                "PTR_s_FAILED_ASSERTION__0000109c": "FAILED_ASSERTION"
            },
            "code": "void find_and_insert_00001034(int **data_array, int data_to_insert){\n\tint **current_data;\n\tint max_data_size = *(byte *)(data_to_insert + 4);\n\tif (max_data_size > 8) {\n\t\tprocess_data(3, PTR_s_FAILED_ASSERTION__0000109c);\n\t}\n\tfor (current_data = data_array; (*current_data != (int *)0x0 && (*(byte *)((int)*current_data + -3) <= *(byte *)(data_to_insert + 5))); current_data = (int **)*current_data) {\n\t}\n\t*(int **)(data_to_insert + 8) = *current_data;\n\t*current_data = (int *)(int **)(data_to_insert + 8);\n\treturn;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "find_and_insert_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_new_index_00006964",
                "param_1": "array_ptr",
                "param_2": "current_index",
                "iVar1": "new_index"
            },
            "code": "int calculate_new_index_00006964(int array_ptr, int current_index){\n  int new_index = *(int *)(array_ptr + current_index - 4) - 4;\n  if (*(int *)(array_ptr + current_index - 4) < 0) {\n    new_index = new_index + *(int *)(array_ptr + new_index);\n  }\n  return new_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_new_index_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_memory_and_set_offset_to_one_0000182c",
                "DAT_000018b4": "data_ptr",
                "DAT_000018b8": "offset_ptr",
                "set_offset_to_one_000016ec": "set_offset_to_one",
                "clear_memory_at_offset_00001710": "clear_memory_at_offset"
            },
            "code": "void clear_memory_and_set_offset_to_one_0000182c(void)\n{\n  byte* DAT_000018b4 = (byte *)(DAT_000018b4 + 8);\n  *DAT_000018b4 = *DAT_000018b4 & 0xd0;\n  set_offset_to_one_000016ec(DAT_000018b8, 0);\n  clear_memory_at_offset_00001710(DAT_000018b4, 1);\n  clear_memory_at_offset_00001710(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_memory_and_set_offset_to_one_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "process_input": "process_input",
                "param_1": "input",
                "cVar1": "current_char",
                "iVar2": "result",
                "iVar3": "data",
                "pcVar4": "string_ptr",
                "pcVar7": "input_ptr",
                "ppcVar5": "pointer_array",
                "PTR_DAT_00004dac": "data_pointer_1",
                "PTR_DAT_00004db0": "data_pointer_2",
                "PTR_DAT_00004db4": "data_pointer_3",
                "uVar6": "return_value",
                "FUN_00004db8": "process_input_00004db8"
            },
            "code": "int process_input_00004db8(int input) {\n  int data = *data_pointer;\n  if ((data != 0) && (*(int *)(data + 0x18) == 0)) {\n    initialize_pointers_if_null();\n  }\n  char **pointer_array = *(char ***)(data + 8);\n  if (*(int *)(data + 0x18) == 0) {\n    initialize_pointers_if_null(data);\n  }\n  if (pointer_array == PTR_DAT_00004dac) {\n    pointer_array = *(char ***)(data + 4);\n  }\n  else if (pointer_array == PTR_DAT_00004db0) {\n    pointer_array = *(char ***)(data + 8);\n  }\n  else if (pointer_array == PTR_DAT_00004db4) {\n    pointer_array = *(char ***)(data + 0xc);\n  }\n  if ((-1 < (int)pointer_array[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(pointer_array + 3) << 0x16))) {\n    do_nothing(pointer_array[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(pointer_array + 3) << 0x1c) < 0) && (pointer_array[4] != (char *)0x0)) || (update_list(data, pointer_array) == 0)) {\n    char *input_ptr = (char *)(input - 1);\n    do {\n      while (true) {\n        input_ptr = input_ptr + 1;\n        char current_char = *input_ptr;\n        char *string_ptr = pointer_array[2] + -1;\n        pointer_array[2] = string_ptr;\n        if (current_char == '\\0') {\n          if (-1 < (int)string_ptr) {\n            input_ptr = *pointer_array;\n            int return_value = 10;\n            *pointer_array = input_ptr + 1;\n            *input_ptr = '\\n';\n            goto LAB_00004d64;\n          }\n          int result = write_to_list(data, 10, pointer_array);\n          if (result != -1) {\n            int return_value = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)string_ptr < 0) && (((int)string_ptr < (int)pointer_array[6] || (current_char == '\\n')))) {\n          break;\n        }\n        string_ptr = *pointer_array;\n        *pointer_array = string_ptr + 1;\n        *string_ptr = current_char;\n      }\n    } while (write_to_list(data, current_char, pointer_array) != -1);\n  }\nLAB_00004d60:\n  int return_value = -1;\nLAB_00004d64:\n  if ((-1 < (int)pointer_array[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(pointer_array + 3) << 0x16))) {\n    do_nothing(pointer_array[0x16]);\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_000031e0",
                "FUN_000033f4",
                "FUN_00002fe0",
                "FUN_00002f30",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000033c0",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003478",
                "FUN_000023a4",
                "FUN_000034c0"
            ],
            "imported": false,
            "current_name": "process_input_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "increment_value_at_offset_000022f0",
                "param_1": "ptr_arr",
                "uVar1": "offset"
            },
            "code": "undefined increment_value_at_offset_000022f0(int *ptr_arr){\n  uint offset = ptr_arr[2];\n  ptr_arr[2] = offset + 1;\n  return *(undefined *)((offset & ptr_arr[1] - 1U) + *ptr_arr);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_value_at_offset_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "clear_and_initialize_memory_00001c84",
                "uVar1": "interrupts_enabled",
                "is_irq_interrupts_enabled_00000cd0": "are_interrupts_enabled",
                "clear_memory_00001bb8": "clear_memory",
                "DAT_00001ce8": "g_data",
                "DAT_00001cec": "g_data",
                "enable_IRQ_interrupts_if_privileged_00000d0c": "enable_interrupts_if_privileged",
                "clear_memory_and_set_offset_to_one_0000182c": "clear_memory_and_set_offset_to_one",
                "set_calculated_offset_to_one_000017dc": "set_calculated_offset_to_one",
                "perform_task_based_on_input_00001b10": "perform_task_based_on_input"
            },
            "code": "void clear_and_initialize_memory_00001c84(void)\n{\n  bool interrupts_enabled = are_interrupts_enabled();\n  clear_memory();\n  *(unsigned int *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001ce8[0xc] = 0;\n  *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n  DAT_00001ce8[4] = 0x13;\n  DAT_00001ce8[5] = 0;\n  clear_memory_and_set_offset_to_one();\n  set_calculated_offset_to_one();\n  perform_task_based_on_input(7);\n  enable_interrupts_if_privileged(interrupts_enabled);\n}",
            "called": [
                "FUN_00001bb8",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_0000182c",
                "FUN_00001b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "clear_and_initialize_memory_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "resize_or_copy_data_000068f0",
                "param_1": "param1",
                "param_2": "data_ptr",
                "iVar1": "new_ptr",
                "iVar2": "old_size",
                "PTR_000060cc": "allocate_or_copy_data",
                "PTR_00004bd0": "allocate_memory",
                "DAT_0000000d": "data_ptr[1]",
                "DAT_0000000e": "data_ptr[0]",
                "*param_2": "data_ptr[0]",
                "*(undefined *)(iVar1 + 0x3ff)": "new_ptr[new_size - 1]",
                "*(undefined *)(iVar1 + 0x3fe)": "new_ptr[new_size - 2]",
                "*(undefined *)(iVar1 + 0x3fd)": "data_ptr[17]",
                "*(undefined *)((int)param_2 + 0x46)": "data_ptr[70]",
                "*(undefined *)((int)param_2 + 0x45)": "data_ptr[69]",
                "*(undefined *)(param_2 + 0x11)": "data_ptr[17]",
                "param_2[0xd]": "data_ptr[1]",
                "param_2 + 0x11": "data_ptr + 17",
                "param_2[0xe]": "data_ptr[0]"
            },
            "code": "int resize_or_copy_data_000068f0(int param1, int* source_ptr, int new_size)\n{\n    int old_size = source_ptr[0];\n    int* new_ptr = PTR_00004bd0(param1, new_size);\n    if (new_ptr != NULL) {\n        copy_data_to_destination(new_ptr, source_ptr, old_size);\n        source_ptr = new_ptr;\n        source_ptr[0] = new_size;\n        return new_ptr + old_size;\n    }\n    return -1;\n}\n\nint resize_or_copy_data_000068f0(int param1, int* data_ptr)\n{\n    int* old_ptr = (int*)(DAT_0000000e);\n    int old_size = old_ptr[0];\n    int new_size = old_size << 1;\n    int* new_ptr = resize_or_copy_data_000068f0(param1, old_ptr, new_size);\n    if (new_ptr != -1) {\n        DAT_0000000e = (int)new_ptr;\n        DAT_0000000d = new_size;\n        return new_ptr + old_size;\n    }\n    return -1;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_000060cc",
                "FUN_00004bd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "resize_or_copy_data_000068f0"
        }
    },
    "used_tokens": 191114,
    "layers": [
        [
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_00005584",
            "FUN_00001da2",
            "FUN_00002744",
            "FUN_00001e0c",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_000039e8",
            "FUN_00002294",
            "FUN_00003810",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00000cf0",
            "FUN_00002538",
            "FUN_0000058e",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_0000091c",
            "FUN_00000d44",
            "FUN_00000cd0",
            "FUN_00000d2a",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00001dc0",
            "FUN_000026f0",
            "FUN_00001d5e",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00001d80",
            "FUN_000023c8",
            "FUN_0000428c",
            "FUN_000010a0",
            "FUN_00006010",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000060b0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_000045ee",
            "FUN_00006974",
            "FUN_00005ebc",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_00001ad4",
            "FUN_00002910",
            "FUN_000043a0",
            "FUN_000007dc",
            "FUN_00006964",
            "FUN_000022f0"
        ],
        [
            "FUN_000026c0",
            "FUN_00005e68",
            "FUN_00000e58",
            "FUN_000026d8",
            "FUN_000016ec",
            "FUN_00001ec4",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_00004f98",
            "FUN_00000428",
            "FUN_00000e38",
            "FUN_00002600",
            "FUN_00004042",
            "FUN_00002894",
            "FUN_00000d76",
            "FUN_000026e4",
            "FUN_00000698",
            "FUN_00001ff6",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_000056b8",
            "FUN_00003ff4",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002798",
            "FUN_0000231c",
            "FUN_00001cf0",
            "FUN_000023d0",
            "FUN_00005fd8",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_000016c8",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000610",
            "FUN_00002364",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_0000258c",
            "FUN_0000562c",
            "FUN_00002a18",
            "FUN_00001710"
        ],
        [
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_00001778",
            "FUN_00002624",
            "FUN_00001628",
            "FUN_000017dc",
            "FUN_00004dee",
            "FUN_00002654",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_000024bc",
            "FUN_00002994",
            "FUN_00000d9c",
            "FUN_00001bb8",
            "FUN_0000404c",
            "FUN_000056a0",
            "FUN_00002690",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00005780",
            "FUN_00002028",
            "FUN_00001a60",
            "FUN_000018bc",
            "FUN_0000182c"
        ],
        [
            "FUN_00004248",
            "FUN_000020e0",
            "FUN_00000db0",
            "FUN_000020f4",
            "FUN_00001688",
            "FUN_000012b4",
            "FUN_00001f80",
            "FUN_00001a18",
            "FUN_0000191c",
            "FUN_000060cc",
            "FUN_00002108",
            "FUN_00005700",
            "FUN_000019c0",
            "FUN_00001a3c",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_000020b8"
        ],
        [
            "FUN_00001eea",
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84"
        ],
        [
            "FUN_00001274"
        ],
        [
            "FUN_000031e0",
            "FUN_000034c0",
            "FUN_000033f4",
            "FUN_00003478"
        ],
        [
            "FUN_00003378",
            "FUN_00000ed8",
            "FUN_0000211c"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00002a88",
            "FUN_000033c0",
            "FUN_00002f74",
            "FUN_00003444"
        ],
        [
            "FUN_00004158",
            "FUN_00004c84",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_00002b10",
            "FUN_00003524",
            "FUN_000042a4"
        ],
        [
            "FUN_00006768",
            "FUN_00005404"
        ],
        [
            "FUN_000057a8",
            "FUN_00005e10",
            "FUN_00004cb4"
        ],
        [
            "FUN_000057d2",
            "FUN_00002e48",
            "FUN_00002d94"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000fec",
            "FUN_00000cc0",
            "FUN_000013b8",
            "FUN_00003ec4",
            "FUN_00000a30",
            "FUN_00001034"
        ],
        [
            "FUN_00000dc0",
            "FUN_00003e9e",
            "FUN_00000e64",
            "FUN_00000df4",
            "FUN_00002434",
            "FUN_000010d4"
        ],
        [
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_00003694"
        ],
        [
            "FUN_0000459c",
            "FUN_0000305c",
            "FUN_00002ecc",
            "FUN_000012e2"
        ],
        [
            "FUN_00002f30",
            "FUN_00000e14",
            "FUN_0000099c"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ],
        [
            "FUN_00000e38",
            "FUN_00005404",
            "FUN_00002396",
            "FUN_00004db8"
        ]
    ],
    "locked_functions": []
}