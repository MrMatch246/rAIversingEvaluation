{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_rtc_alarm_callback_000026c0",
                "PTR_rtc_callback_000026d4": "rtc_callback_ptr"
            },
            "code": "void clear_rtc_alarm_callback_000026c0(void)\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4 = 0;\n  return;\n}",
            "called": [
                "rtt_clear_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "clear_rtc_alarm_callback_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent_ptr",
                "param_2": "size",
                "puVar1": "heap_start",
                "pvVar2": "heap_end",
                "puVar3": "free_list_head",
                "iVar4": "remaining_space",
                "uVar5": "free_block_size",
                "puVar6": "free_block",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_00004bd0(_reent *reent_ptr, uint size)\n{\n  uint aligned_size = (size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < size)) {\n    reent_ptr->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void *heap_start = PTR___malloc_sbrk_start_00004c80;\n    uint *free_list_head = *(uint **)PTR___malloc_free_list_00004c7c;\n    for (uint *free_block = *(uint **)PTR___malloc_free_list_00004c7c; free_block != (uint *)0x0; free_block = (uint *)free_block[1]) {\n      uint free_block_size = *free_block - aligned_size;\n      if (-1 < (int)free_block_size) {\n        if (0xb < free_block_size) {\n          *free_block = free_block_size;\n          free_block = (uint *)((int)free_block + free_block_size);\n          goto LAB_00004c34;\n        }\n        uint next_free_block = free_block[1];\n        if (free_list_head == free_block) {\n          *(uint *)PTR___malloc_free_list_00004c7c = next_free_block;\n        }\n        if (free_list_head != free_block) {\n          free_list_head[1] = next_free_block;\n        }\n        goto LAB_00004c42;\n      }\n      free_list_head = free_block;\n    }\n    if (*(int *)PTR___malloc_sbrk_start_00004c80 == 0) {\n      void *new_heap_start = _sbrk_r(reent_ptr,0);\n      *(void **)heap_start = new_heap_start;\n    }\n    uint *new_free_block = (uint *)_sbrk_r(reent_ptr,aligned_size);\n    if ((new_free_block != (uint *)0xffffffff) &&\n       ((free_block = (uint *)((int)new_free_block + 3U & 0xfffffffc), new_free_block == free_block ||\n        (heap_start = _sbrk_r(reent_ptr,(int)free_block - (int)new_free_block), heap_start != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *free_block = aligned_size;\nLAB_00004c42:\n      __malloc_unlock(reent_ptr);\n      uint block_end = (int)free_block + 0xbU & 0xfffffff8;\n      int remaining_space = block_end - (int)(free_block + 1);\n      if (remaining_space == 0) {\n        return block_end;\n      }\n      *(uint *)((int)free_block + remaining_space) = (int)(free_block + 1) - block_end;\n      return block_end;\n    }\n    reent_ptr->_errno = 0xc;\n    __malloc_unlock(reent_ptr);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "_tzset_unlocked_r",
                "__submore",
                "_realloc_r",
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "set_thread_inactive_00000794",
                "PTR_sched_threads_000007d0": "unchanged",
                "PTR_sched_active_pid_000007cc": "unchanged",
                "PTR_sched_num_threads_000007d4": "num_threads",
                "PTR_sched_active_thread_000007d8": "active_thread"
            },
            "code": "void set_thread_inactive_00000794(void)\n{\n  irq_disable();\n  int* PTR_sched_num_threads_000007d4 = (int*) PTR_sched_PTR_sched_num_threads_000007d4_000007d4;\n  *PTR_sched_num_threads_000007d4 -= 1;\n  thread_t** PTR_sched_active_thread_000007d8 = (thread_t**) PTR_sched_PTR_sched_active_thread_000007d8_000007d8;\n  sched_set_status(*PTR_sched_active_thread_000007d8, 0);\n  *PTR_sched_active_thread_000007d8 = NULL;\n  cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "set_thread_inactive_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "decode_data_000064bc",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "PTR_DAT_00006568",
                "iVar2": "bits_to_shift",
                "iVar7": "iterations",
                "uVar3": "remaining_bits",
                "ppbVar4": "current_param",
                "pbVar5": "next_byte",
                "pbVar6": "current_byte",
                "unaff_r6": "current_output_byte",
                "*ppbVar4": "*current_param",
                "**param_3": "*current_byte",
                "*(char *)(param_2[5] + (uint)**param_3)": "current_param_value",
                "param_2[2]": "remaining_bits",
                "param_2[6]": "current_param_type",
                "param_2[5]": "current_param_data",
                "param_2[3]": "bytes_read",
                "param_2[4]": "total_bytes_read",
                "param_2[0x60]": "decode_function"
            },
            "code": "uint32_t decode_data_000064bc(uint32_t param1, uint32_t* param2, byte** param3, uint32_t* param4) {\n  byte* current_byte;\n  uint32_t remaining_bits;\n  uint32_t* current_param;\n  byte* current_output_byte;\n  uint32_t bits_to_shift;\n  uint32_t current_param_value;\n  uint32_t result = 0;\n\n  if (param2[2] == 0) {\n    if (param2[6] == 0) {\n      remaining_bits = 1;\n    } else {\n      remaining_bits = 0xffffffff;\n    }\n    param2[2] = remaining_bits;\n  }\n\n  current_param = param4;\n  if (-1 < (int)(*param2 << 0x1b)) {\n    current_param = param4 + 1;\n    current_byte = *current_param;\n  }\n\n  uint32_t iterations = 0;\n  do {\n    remaining_bits = param2[6];\n    if (remaining_bits != 0) {\n      if (remaining_bits == 1) {\n        current_param_value = *(char *)(param2[5] + (uint)**param3);\n        if (current_param_value == 0) {\n          if (iterations == 0) {\n            return 1;\n          }\n          if (((*param2 & 0x10) == 0) && (param2[3] = param2[3] + 1, param2[6] != 0)) {\n            *current_output_byte = 0;\n          }\n          param2[4] = iterations + param2[4];\n          return 0;\n        }\n      }\n      else if ((remaining_bits != 2) || ((int)((uint)(byte)PTR_DAT_00006568[**param3] << 0x1c) < 0))\n        goto LAB_0000654a;\n    }\n\n    current_output_byte = current_byte;\n    if (-1 < (int)(*param2 << 0x1b)) {\n      current_output_byte = current_byte + 1;\n      *current_byte = **param3;\n    }\n\n    byte* next_byte = param3[1];\n    *param3 = *param3 + 1;\n    remaining_bits = param2[2] - 1;\n    param3[1] = next_byte + -1;\n    iterations = iterations + 1;\n    param2[2] = remaining_bits;\n    current_byte = current_output_byte;\n    if ((remaining_bits == 0) || (((int)(next_byte + -1) < 1 &&\n        (bits_to_shift = (*(code *)param2[0x60])(param1, param3, remaining_bits, (code *)param2[0x60], current_param), bits_to_shift != 0))))\n      goto LAB_0000654a;\n  } while(true);\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "decode_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "update_rtc_type_registers_00002970",
                "rtt": "rtc_type_ptr",
                "DAT_00002990": "register_data_address",
                "register_ptr": "register_pointer",
                "register_value": "register_value"
            },
            "code": "void update_rtc_type_registers_00002970(void)\n{\n  RTC_Type *rtc_type_ptr;\n  uint32_t *register_ptr = (uint32_t *)(DAT_00002990 + 0x14);\n  uint32_t register_value = *register_ptr;\n  register_value &= 0xffffffef;\n  *register_ptr = register_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "rtc_poweroff"
            ],
            "imported": false,
            "current_name": "update_rtc_type_registers_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "execute_default_function_00000dc0"
            },
            "code": "void execute_default_function_00000dc0(void)\n{\n  execute_default_function_00000dc0();\n  return;\n}",
            "called": [
                "dummy_handler_default"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "execute_default_function_00000dc0"
        },
        "FUN_00000ca0": {
            "renaming": {
                "FUN_00000ca0": "usage_fault_handler_00000ca0",
                "PTR_s_USAGE_FAULT_HANDLER_00000cac": "usage_fault_handler"
            },
            "code": "void usage_fault_handler_00000ca0(void)\n{\n    core_panic(PANIC_USAGE_FAULT, usage_fault_handler_00000ca0);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ca0",
            "calling": [],
            "imported": false,
            "current_name": "usage_fault_handler_00000ca0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_interrupt_if_privileged_00000d0c",
                "state": "interrupt_state",
                "bVar1": "is_privileged_mode"
            },
            "code": "void enable_interrupt_if_privileged_00000d0c(uint state)\n{\n  bool is_privileged_mode;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    enableIRQinterrupts((state & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "enable_interrupt_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "write_data_to_device_00003d94",
                "dev": "device",
                "data": "data",
                "iVar1": "error_code",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int write_data_to_device_00003d94(saul_reg_t *device, phydat_t *data) {\n  int error_code;\n  if (device == NULL) {\n    error_code = -19;\n  }\n  else {\n    error_code = (*device->driver->write)(device->dev, data);\n  }\n  return error_code;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "write_data_to_device_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "release_recursive_lock_for_malloc_0000579c",
                "PTR___lock___malloc_recursive_mutex_000057a4": "PTR_recursive_lock_for_malloc"
            },
            "code": "void release_recursive_lock_for_malloc_0000579c()\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "release_recursive_lock_for_malloc_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "send_data_over_uart_000015d0",
                "uart": "uart_port",
                "data": "data_to_send",
                "len": "data_length",
                "iVar1": "uart_config_ptr_offset",
                "dev": "uart_device",
                "i": "index"
            },
            "code": "void send_data_over_uart_000015d0(uart_t uart, uint8_t *data, size_t len)\n{\n    int uart_config_ptr_offset = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n    UART_Type *uart_device = (UART_Type *)uart_config_ptr_offset;\n\n    for (size_t i = 0; i < len; i++) {\n        while (uart_device->status_reg < 0) {}\n        uart_device->data_reg = data[i];\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "uart_stdio_write"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_000015d0"
        },
        "FUN_00004cdc": {
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "file_descriptor",
                "param_2": "string",
                "cVar1": "current_char",
                "iVar2": "setup_result",
                "pcVar3": "buffer_end",
                "ppcVar4": "file",
                "uVar5": "return_value",
                "pcVar6": "buffer_start"
            },
            "code": "undefined4 print_string_00004cdc(int file_descriptor, char* string)\n{\n    char current_char;\n    int setup_result;\n    char* buffer_start;\n    char** file;\n    undefined4 return_value;\n    \n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n        __sinit();\n    }\n    file = *(char ***)(file_descriptor + 8);\n    if (*(int *)(file_descriptor + 0x18) == 0) {\n        __sinit(file_descriptor);\n    }\n    if (file == (char **)PTR___sf_fake_stdin_00004dac) {\n        file = *(char ***)(file_descriptor + 4);\n    }\n    else if (file == (char **)PTR___sf_fake_stdout_00004db0) {\n        file = *(char ***)(file_descriptor + 8);\n    }\n    else if (file == (char **)PTR___sf_fake_stderr_00004db4) {\n        file = *(char ***)(file_descriptor + 0xc);\n    }\n    if ((-1 < (int)file[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file + 3) << 0x16))) {\n        __retarget_lock_acquire_recursive(file[0x16]);\n    }\n    if ((((int)((uint)*(ushort *)(file + 3) << 0x1c) < 0) && (file[4] != (char *)0x0)) || (setup_result = __swsetup_r(file_descriptor, file), setup_result == 0)) {\n        buffer_start = (char *)(string + -1);\n        do {\n            while (true) {\n                buffer_start = buffer_start + 1;\n                current_char = *buffer_start;\n                char* buffer_end = file[2] + -1;\n                file[2] = buffer_end;\n                if (current_char == '\\0') {\n                    if (-1 < (int)buffer_end) {\n                        buffer_start = *file;\n                        return_value = 10;\n                        *file = buffer_start + 1;\n                        *buffer_start = '\\n';\n                        goto LAB_00004d64;\n                    }\n                    setup_result = __swbuf_r(file_descriptor, 10, file);\n                    if (setup_result != -1) {\n                        return_value = 10;\n                        goto LAB_00004d64;\n                    }\n                    goto LAB_00004d60;\n                }\n                if (((int)buffer_end < 0) && (((int)buffer_end < (int)file[6] || (current_char == '\\n')))) {\n                    break;\n                }\n                buffer_end = *file;\n                *file = buffer_end + 1;\n                *buffer_end = current_char;\n            }\n            setup_result = __swbuf_r(file_descriptor, current_char, file);\n        } while (setup_result != -1);\n    }\nLAB_00004d60:\n    return_value = 0xffffffff;\nLAB_00004d64:\n    if ((-1 < (int)file[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file + 3) << 0x16))) {\n        __retarget_lock_release_recursive(file[0x16]);\n    }\n    return return_value;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__swsetup_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cdc",
            "calling": [
                "puts"
            ],
            "imported": false,
            "current_name": "print_string_00004cdc"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "scan_formatted_input_00005e68",
                "__s": "input_string",
                "__format": "format_string",
                "iVar1": "num_of_scanned_items",
                "local_80": "input_string_copy",
                "local_7c": "input_string_length",
                "local_74": "field_width",
                "local_72": "max_field_width",
                "local_70": "input_string_copy",
                "local_6c": "input_string_copy_length",
                "uStack_8": "arg_1",
                "uStack_4": "arg_2",
                "local_5c": "impure_ptr",
                "local_4c": "arg_3",
                "local_38": "arg_4"
            },
            "code": "int scan_formatted_input_00005e68(char* input_string, char* format_string, ...) {\n  int num_of_scanned_items;\n  char* input_string_copy;\n  size_t input_string_length;\n  undefined2 field_width = 0x204;\n  undefined2 max_field_width = 0xffff;\n  size_t input_string_copy_length;\n  undefined4 arg_1;\n  undefined4 arg_2;\n  undefined4 arg_3;\n  undefined4 arg_4;\n  undefined4 impure_ptr = *(undefined4*)PTR__impure_ptr_00005eb8;\n  \n  input_string_copy = input_string;\n  input_string_copy_length = strlen(input_string);\n  arg_1 = DAT_00005eb4;\n  arg_2 = 0;\n  arg_3 = 0;\n  arg_4 = 0;\n  num_of_scanned_items = __ssvfiscanf_r(impure_ptr, &input_string_copy, format_string, &arg_1);\n  \n  return num_of_scanned_items;\n}",
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "scan_formatted_input_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_to_memory_00000dcc",
                "DAT_00000df0": "data_ptr"
            },
            "code": "void set_data_to_memory_00000dcc(void)\n{\n  int* DAT_00000df0 = DAT_00000df0;\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "set_data_to_memory_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_rtc_counter_0000285c",
                "counter": "rtc_counter",
                "puVar1": "counter_ptr",
                "rtt": "rtc_ptr"
            },
            "code": "void set_rtc_counter_0000285c(uint32_t counter)\n{\n  uint32_t *counter_ptr;\n  RTC_Type *rtc_ptr;\n  counter_ptr = DAT_00002890;\n  DAT_00002890[5] &= 0xffffffef;\n  *counter_ptr = counter;\n  counter_ptr[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "rtc_set_time"
            ],
            "imported": false,
            "current_name": "set_rtc_counter_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "do_nothing_loop_00000e58",
                "PTR_": "PTR_ (no change)",
                "DAT_": "DAT_ (no change)"
            },
            "code": "void do_nothing_loop_00000e58(void)\n{\n  irq_disable();\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "irq_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_loop_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_and_clear_bit_00001778",
                "DAT_000017d0": "data_pointer_1",
                "DAT_000017d8": "data_pointer_2"
            },
            "code": "void set_bit_and_clear_bit_00001778(void)\n{\n  byte* ptr_data_1 = (byte*)(DAT_000017d0 + 1);\n  byte* ptr_data_2 = (byte*)DAT_000017d8;\n  *ptr_data_1 = (*ptr_data_1 & 0xcf) | 0x20;\n  bit_clear8(*ptr_data_2, 2);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_bit_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "power_on_rtt_000026d8"
            },
            "code": "void power_on_rtt_000026d8(void)\n{\n    rtt_poweron();\n    return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_on_rtt_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zeroes_in_uint_00000566",
                "v": "number",
                "bVar1": "first_byte",
                "bVar2": "second_byte",
                "bVar3": "third_byte",
                "bVar4": "fourth_byte",
                "uVar5": "bit_pattern"
            },
            "code": "uint count_leading_zeroes_in_uint_00000566(uint number) {\n  byte first_byte = (byte)number;\n  byte second_byte = (byte)(number >> 8);\n  byte third_byte = (byte)(number >> 16);\n  byte fourth_byte = (byte)(number >> 24);\n  uint bit_pattern = (uint)(byte)((((((((first_byte & 1) << 1 | first_byte >> 1 & 1) << 1 | first_byte >> 2 & 1) <<\n                                    1 | first_byte >> 3 & 1) << 1 | first_byte >> 4 & 1) << 1 |\n                                 first_byte >> 5 & 1) << 1 | first_byte >> 6 & 1) << 1 | first_byte >> 7) << 24\n                     | (uint)(byte)((((((((second_byte & 1) << 1 | second_byte >> 1 & 1) << 1 | second_byte >> 2 & 1)\n                                        << 1 | second_byte >> 3 & 1) << 1 | second_byte >> 4 & 1) << 1 |\n                                     second_byte >> 5 & 1) << 1 | second_byte >> 6 & 1) << 1 | second_byte >> 7) <<\n                       16 | (uint)(byte)((((((((third_byte & 1) << 1 | third_byte >> 1 & 1) << 1 |\n                                               third_byte >> 2 & 1) << 1 | third_byte >> 3 & 1) << 1 |\n                                             third_byte >> 4 & 1) << 1 | third_byte >> 5 & 1) << 1 |\n                                           third_byte >> 6 & 1) << 1 | third_byte >> 7) << 8 |\n                     (uint)(byte)((((((((fourth_byte & 1) << 1 | fourth_byte >> 1 & 1) << 1 |\n                                               fourth_byte >> 2 & 1) << 1 | fourth_byte >> 3 & 1) << 1 |\n                                             fourth_byte >> 4 & 1) << 1 | fourth_byte >> 5 & 1) << 1 |\n                                           fourth_byte >> 6 & 1) << 1 | fourth_byte >> 7));\n  if (number == 0) {\n    bit_pattern = 0xffffffff;\n  }\n  return bit_pattern;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "sched_run"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_in_uint_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_address_from_bit_and_ptr_00001d08",
                "ptr": "ptr",
                "bit": "bit",
                "(uint)ptr": "(uintptr_t) ptr",
                "bit * 4": "bit_shifted_by_two",
                "(uint)ptr & 0xf0000000": "high_bits",
                "(uint)ptr & 0xfffff": "low_bits",
                "(low_bits << 5)": "low_bits_shifted_by_five",
                "0x2000000": "offset_constant",
                "(void *)": "(void *)"
            },
            "code": "void * calculate_address_from_bit_and_ptr_00001d08(void *ptr, uintptr_t bit) {\n    uintptr_t high_bits = ((uintptr_t) ptr) & 0xf0000000;\n    uintptr_t low_bits = ((uintptr_t) ptr) & 0xfffff;\n    uintptr_t offset = bit * 4 + high_bits + (low_bits << 5) + 0x2000000;\n    return (void *) offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_bit_and_ptr_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_weekday_000031fc",
                "year": "year",
                "month": "month",
                "day": "day",
                "bVar1": "adjusted_month",
                "iVar2": "year_in_century",
                "iVar3": "year_adjustment",
                "DAT_00003280": "leap_year_factor",
                "PTR_t_00003284": "month_offset_array",
                "weekday": "weekday"
            },
            "code": "int calculate_weekday_000031fc(int year, int month, int day) {\n    int adjusted_month = month;\n    if (month < 3) {\n        adjusted_month = 1;\n    }\n    else if (month > 2) {\n        adjusted_month = 0;\n    }\n    int year_adjustment = year - adjusted_month;\n    if (year_adjustment < 0) {\n        year_adjustment = year_adjustment + 3;\n    }\n    int century = year_adjustment >> 2;\n    int year_in_century = year_adjustment - (century << 2);\n    int leap_year_adjustment = (year_adjustment >> 6) - (year_adjustment >> 11);\n    int month_offset = *(int *)(PTR_t_00003284 + (month + -1) * 4);\n    int weekday = year_in_century + century + month_offset + day + leap_year_adjustment;\n    return weekday % 7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "_parse_time"
            ],
            "imported": false,
            "current_name": "calculate_weekday_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_bit_in_byte_000016ec",
                "ptr": "byte_ptr",
                "bit": "bit_index",
                "puVar1": "bitband_addr_ptr"
            },
            "code": "void set_bit_in_byte_000016ec(uint8_t *byte_ptr, uint8_t bit_index)\n{\n  uint32_t *bitband_addr_ptr = bitband_addr(byte_ptr, (uint32_t)bit_index);\n  *bitband_addr_ptr = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "set_bit_in_byte_000016ec"
        },
        "FUN_00004e8c": {
            "renaming": {
                "_strtol_l_isra_0": "convert_string_to_long",
                "param_1": "out_result",
                "param_2": "input_string",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "current_char",
                "uVar2": "current_char",
                "uVar3": "is_hex",
                "uVar4": "digit_value",
                "iVar5": "conversion_success",
                "uVar6": "overflow_guard",
                "uVar7": "max_quotient",
                "pbVar8": "last_char",
                "pbVar9": "current_position",
                "FUN_00004e8c": "convert_string_to_long_00004e8c"
            },
            "code": "uint convert_string_to_long_00004e8c(undefined4 *out_result, byte *input_string, byte **endptr, uint base) {\n  uint current_char;\n  uint is_negative = 0;\n  uint overflow_guard = 0x7fffffff;\n  uint result = 0;\n  int digit_value = 0;\n  uint max_digit_value = base - 1;\n  uint max_base_for_hex = 0x10;\n\n  byte *current_position = input_string;\n\n  // Skip leading whitespace\n  do {\n    current_char = (uint)*current_position;\n    current_position++;\n  } while (isspace(current_char));\n\n  // Check for sign\n  if (current_char == '-') {\n    is_negative = 1;\n    current_char = (uint)*current_position;\n    current_position++;\n  }\n  else if (current_char == '+') {\n    current_char = (uint)*current_position;\n    current_position++;\n  }\n\n  // Determine base if not specified\n  if (base == 0) {\n    if (current_char != '0') {\n      base = 10;\n    }\n    else {\n      base = max_base_for_hex;\n      current_char = (uint)*current_position;\n      current_position++;\n    }\n  }\n  else if ((base != max_base_for_hex) || (current_char != '0')) {\n    // Invalid base for hex\n    base = 10;\n  }\n\n  uint max_quotient = overflow_guard / base;\n\n  // Convert digits to integer\n  while (true) {\n    if (isdigit(current_char)) {\n      digit_value = current_char - '0';\n    }\n    else if (isalpha(current_char) && (toupper(current_char) <= 'F')) {\n      digit_value = toupper(current_char) - 'A' + 10;\n    }\n    else {\n      break;\n    }\n\n    if (digit_value > max_digit_value) {\n      break;\n    }\n\n    if (result > max_quotient) {\n      out_result = 0;\n      result = overflow_guard;\n      if (endptr == NULL) {\n        return overflow_guard;\n      }\n      else {\n        break;\n      }\n    }\n\n    result = result * base + digit_value;\n    current_char = (uint)*current_position;\n    current_position++;\n  }\n\n  if (out_result != NULL) {\n    if (is_negative) {\n      result = -result;\n    }\n    *out_result = result;\n  }\n\n  if (endptr != NULL) {\n    if (digit_value == 0) {\n      current_position--;\n    }\n    *endptr = current_position;\n  }\n\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e8c",
            "calling": [
                "_strtol_r",
                "strtol"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004e8c"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "process_impure_ptr_00005100",
                "FUN_00005100_r": "process_impure_ptr_r"
            },
            "code": "void process_impure_ptr_00005100(void)\n{\n  process_impure_ptr_00005100_r(*(undefined4 *)PTR__impure_ptr_00005108);\n  return;\n}",
            "called": [
                "_tzset_unlocked_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "process_impure_ptr_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584_t": "DivisionResult",
                "FUN_00005584": "divide_00005584",
                "__numer": "dividend",
                "__denom": "divisor",
                "in_r2": "positive_divisor",
                "iVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "typedef struct {\n    uint32_t quotient;\n    int32_t remainder;\n} DivisionResult;\n\nDivisionResult divide_00005584(int32_t divide_00005584nd, int32_t divisor) {\n    uint32_t positive_divide_00005584nd = (divide_00005584nd < 0) ? -divide_00005584nd : divide_00005584nd;\n    uint32_t positive_divisor = (divisor < 0) ? -divisor : divisor;\n    uint32_t quotient = 0;\n    int32_t remainder = positive_divide_00005584nd;\n    while (remainder >= positive_divisor) {\n        remainder -= positive_divisor;\n        quotient++;\n    }\n    if (divide_00005584nd < 0) {\n        quotient = -quotient;\n    }\n    if (divisor < 0) {\n        remainder = -remainder;\n    }\n    return (DivisionResult){ quotient, remainder };\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "validate_structure"
            ],
            "imported": false,
            "current_name": "divide_00005584"
        },
        "FUN_00000cb0": {
            "renaming": {
                "FUN_00000cb0": "handle_debug_monitor_00000cb0",
                "PTR_s_DEBUG_MON_HANDLER_00000cbc": "debug_monitor_handler"
            },
            "code": "void handle_debug_monitor_00000cb0(void)\n{\n    core_panic(PANIC_DEBUG_MON, PTR_s_DEBUG_MON_HANDLER_00000cbc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cb0",
            "calling": [],
            "imported": false,
            "current_name": "handle_debug_monitor_00000cb0"
        },
        "FUN_00004248": {
            "renaming": {
                "allocate_memory": "allocate_memory",
                "param_1": "size_of_struct",
                "param_2": "num_of_structs",
                "puVar1": "struct_ptr",
                "iVar2": "total_size",
                "FUN_00004248": "allocate_memory_00004248"
            },
            "code": "undefined4* allocate_memory_00004248(int size_of_struct, int num_of_structs)\n{\n  undefined4* struct_ptr;\n  int total_size = (num_of_structs - 1) * sizeof(my_struct);\n  struct_ptr = (undefined4*) _malloc_r(size_of_struct, total_size + sizeof(int) + sizeof(undefined4*) + sizeof(my_struct));\n  if (struct_ptr != NULL)\n  {\n    *struct_ptr = 0;\n    struct_ptr[1] = num_of_structs;\n    struct_ptr[2] = struct_ptr + 3;\n    memset(struct_ptr + 3, 0, total_size + sizeof(my_struct));\n  }\n  return struct_ptr;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004248"
        },
        "FUN_00000f5c": {
            "renaming": {
                "FUN_00000f5c": "initialize_and_execute_00000f5c",
                "auto_init": "auto_initialize"
            },
            "code": "void * initialize_and_execute_00000f5c(void *arg)\n{\n  auto_initialize();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return (void *)0x0;\n}",
            "called": [
                "iprintf",
                "main",
                "auto_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f5c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_execute_00000f5c"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "extract_bits_from_gpio_00001da2",
                "pin": "gpio_pin"
            },
            "code": "int extract_bits_from_gpio_00001da2(gpio_t gpio_pin) {\n    int bit_position = 6;\n    int bit_mask = 7;\n    int shifted_pin = gpio_pin >> bit_position;\n    int extracted_bits = shifted_pin & bit_mask;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "clk_en",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "extract_bits_from_gpio_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "port_num",
                "pin": "pin_num",
                "ctx_00": "context_pointer",
                "ctx": "context",
                "get_ctx": "get_context_pointer",
                "write_map": "write_to_map"
            },
            "code": "void write_context_to_map_00001ec4(int port_num, int pin_num)\n{\n  int context;\n  int context_pointer;\n  context_pointer = get_context_pointer(port_num, pin_num);\n  write_to_map(port_num, pin_num, context_pointer);\n  return;\n}",
            "called": [
                "write_map",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "write_context_to_map_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_irq_priority_00002744",
                "IRQn": "irq",
                "priority": "priority",
                "DAT_00002790": "ptr_irq_priority_low",
                "DMA0_IRQn": "DMA0_irq",
                "DAT_00002794": "ptr_irq_priority_high"
            },
            "code": "void set_irq_priority_00002744(IRQn_Type irq, uint32_t priority)\n{\n  if (irq < DMA0_IRQn) {\n    *(char *)(((byte)irq & 0xf) + DAT_00002790 + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(irq + DAT_00002794) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_irq_priority_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_rtt_counter_to_tm_00002624",
                "time": "time_struct",
                "t": "rtt_counter"
            },
            "code": "int convert_rtt_counter_to_tm_00002624(tm *time_struct)\n{\n  time_t rtt_counter;\n  rtt_counter._0_4_ = rtt_get_counter();\n  rtt_counter._4_4_ = 0;\n  gmtime_r((time_t *)&rtt_counter, time_struct);\n  return 0;\n}",
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "convert_rtt_counter_to_tm_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "read_pin_value_00001e0c",
                "port": "port_num",
                "pin": "pin_num",
                "PTR_isr_map_00001e40": "PTR_isr_map",
                "uint": "uint32_t",
                "pin_offset": "pin_offset",
                "pin_map_ptr": "pin_map_ptr",
                "pin_value": "pin_value"
            },
            "code": "uint32_t read_pin_value_00001e0c(uint32_t port_num, uint32_t pin_num) {\n    uint32_t pin_offset = (pin_num >> 3) + port_num * 4;\n    uint32_t* pin_map_ptr = (uint32_t*)(PTR_isr_map_00001e40_00001e40 + pin_offset * 4);\n    uint32_t pin_value = (*pin_map_ptr) >> ((pin_num & 7U) << 2) & 0xf;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "imported": false,
            "current_name": "read_pin_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "walk_file_stream_000041d0",
                "__stream": "__stream",
                "iVar1": "status",
                "PTR__global_impure_ptr_000041e8": "global_impure_ptr",
                "DAT_000041ec": "DAT",
                "_FUN_000041d0_r": "_walk_file_stream_r",
                "PTR__impure_ptr_000041f0": "impure_ptr"
            },
            "code": "int walk_file_stream_000041d0(FILE *__stream)\n{\n  int status;\n  if (__stream == NULL) {\n    status = _fwalk_reent(*PTR__global_PTR__impure_ptr_000041f0_000041e8,DAT_000041ec);\n    return status;\n  }\n  status = _walk_file_stream_000041d0_r(*PTR__impure_ptr_000041f0, __stream);\n  return status;\n}",
            "called": [
                "_fflush_r",
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "print_prompt",
                "lflush"
            ],
            "imported": false,
            "current_name": "walk_file_stream_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "execute_fini_functions_0000459c",
                "param_1": "pkey_ctx",
                "puVar1": "ptr_1",
                "puVar2": "ptr_2",
                "iVar3": "num_functions",
                "ppcVar4": "function_ptrs",
                "iVar5": "i"
            },
            "code": "void execute_fini_functions_0000459c(EVP_PKEY_CTX *pkey_ctx) {\n    int num_functions = (int)fini_array_end - (int)fini_array_start;\n    code **function_ptrs = (code **)fini_array_start;\n    for (int i = 0; i < num_functions; i++) {\n        pkey_ctx = (EVP_PKEY_CTX *)(*function_ptrs)();\n        function_ptrs++;\n    }\n    _init(pkey_ctx);\n    function_ptrs = (code **)fini_array_start;\n    for (int i = 0; i < (int)fini_array_end - (int)fini_array_start >> 2; i++) {\n        (**function_ptrs)();\n        function_ptrs++;\n    }\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "execute_fini_functions_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uart_number",
                "baudrate": "baud_rate",
                "pbVar1": "uart_config",
                "uVar2": "uart_config_size",
                "uVar3": "ubd",
                "txfifo_size": "unused_txfifo_size",
                "brfa": "brfa_value",
                "ubd": "ubd_value",
                "clk": "unused_clk",
                "dev": "unused_dev"
            },
            "code": "void configure_uart_000014c4(uart_t uart, uint32_t baudrate) {\n  byte *uart_config = *(byte **)(PTR_uart_config_000015cc + uart * 0x20);\n  uint uart_config_size = *(uint *)(PTR_uart_config_000015cc + uart * 0x20 + 4);\n  uart_config[3] = uart_config[3] & 0xf3;\n  uart_config[2] = PTR_uart_config_000015cc[uart * 0x20 + 0x1d];\n  uint ubd = uart_config_size / (baudrate << 4);\n  uart_config[0] = (byte)(ubd >> 8) & 0x1f;\n  uart_config[1] = (byte)ubd;\n  uint8_t brfa = (uart_config_size << 2) / baudrate + 1 >> 1 & 0x1f;\n  uart_config[0x10] = uart_config[0x10] | 0x88;\n  if ((uart_config[0x10] & 0x70) == 0) {\n    uart_config[0x13] = 0;\n  }\n  else {\n    uart_config[0x13] = (char)(2 << (uart_config[0x10] >> 4 & 7)) - 1;\n  }\n  uart_config[0x15] = 1;\n  uart_config[0x11] = 0xc0;\n  uart_config[3] = uart_config[3] | 0x2c;\n  NVIC_EnableIRQ(PTR_uart_config_000015cc[uart * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_uart_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "allocate_memory_block_00004b34",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "param_3",
                "param_4": "param_4",
                "puVar1": "free_list_ptr",
                "piVar2": "block_size",
                "extraout_r1": "extraout_r1",
                "ppiVar3": "next_ptr",
                "ppiVar4": "prev_ptr",
                "ppiVar5": "free_list_ptr",
                "ppiVar6": "prev_ptr",
                "bVar7": "is_last_block"
            },
            "code": "void allocate_memory_block_00004b34(undefined4 *error_code, int size, undefined4 param_3, undefined4 param_4)\n{\n    int **free_list_ptr = *(int ***)PTR___malloc_free_list_00004bcc;\n    int **prev_ptr = (int **)(size + -4);\n    int **next_ptr;\n    bool is_last_block;\n\n    if (size == 0) {\n        return;\n    }\n\n    if (*prev_ptr < 0) {\n        prev_ptr = (int **)((int)prev_ptr + **prev_ptr);\n    }\n\n    __malloc_lock();\n\n    if (free_list_ptr == (int **)0x0) {\n        prev_ptr[1] = (int *)0x0;\n        *(int ***)PTR___malloc_free_list_00004bcc = prev_ptr;\n        next_ptr = (int **)extraout_r1;\n        prev_ptr = (int **)PTR___malloc_free_list_00004bcc;\n    }\n    else if (prev_ptr < free_list_ptr) {\n        next_ptr = (int **)*prev_ptr;\n        prev_ptr = (int **)((int)prev_ptr + (int)next_ptr);\n        is_last_block = free_list_ptr == prev_ptr;\n        if (is_last_block) {\n            prev_ptr = (int **)*free_list_ptr;\n            free_list_ptr = (int **)free_list_ptr[1];\n        }\n        prev_ptr[1] = (int *)free_list_ptr;\n        if (is_last_block) {\n            prev_ptr = (int **)((int)prev_ptr + (int)next_ptr);\n            *prev_ptr = (int *)prev_ptr;\n        }\n        *(int ***)PTR___malloc_free_list_00004bcc = prev_ptr;\n    }\n    else {\n        do {\n            next_ptr = free_list_ptr;\n            free_list_ptr = (int **)next_ptr[1];\n            if (free_list_ptr == (int **)0x0) break;\n        } while (free_list_ptr <= prev_ptr);\n        prev_ptr = (int **)*next_ptr;\n        if ((int **)((int)next_ptr + (int)prev_ptr) == prev_ptr) {\n            prev_ptr = (int **)((int)prev_ptr + (int)*prev_ptr);\n            *next_ptr = (int *)prev_ptr;\n            if (free_list_ptr == (int **)((int)next_ptr + (int)prev_ptr)) {\n                int *block_size = *free_list_ptr;\n                next_ptr[1] = free_list_ptr[1];\n                prev_ptr = (int **)((int)prev_ptr + (int)block_size);\n                *next_ptr = (int *)prev_ptr;\n            }\n        }\n        else if (prev_ptr < (int **)((int)next_ptr + (int)prev_ptr)) {\n            *error_code = 0xc;\n        }\n        else {\n            prev_ptr = (int **)((int)prev_ptr + (int)*prev_ptr);\n            is_last_block = free_list_ptr == prev_ptr;\n            if (is_last_block) {\n                prev_ptr = (int **)*free_list_ptr;\n                free_list_ptr = (int **)free_list_ptr[1];\n            }\n            prev_ptr[1] = (int *)free_list_ptr;\n            if (is_last_block) {\n                prev_ptr = (int **)((int)prev_ptr + (int)*prev_ptr);\n                *prev_ptr = (int *)prev_ptr;\n            }\n            next_ptr[1] = (int *)prev_ptr;\n        }\n    }\n    __malloc_unlock(error_code, prev_ptr, next_ptr, param_4);\n    return;\n}\n",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "__ssrefill_r",
                "_realloc_r",
                "__srefill_r",
                "__sflush_r",
                "free",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "file_position_000004f2",
                "r": "reent",
                "fd": "file_descriptor",
                "pos": "position",
                "dir": "direction"
            },
            "code": "_off_t file_position_000004f2(_reent *reent, int file_descriptor, _off_t position, int direction) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "file_position_000004f2"
        },
        "FUN_0000423c": {
            "renaming": {
                "FUN_0000423c": "walk_reentrantly_0000423c",
                "param_1": "reent_ptr",
                "DAT_00004244": "global_reent"
            },
            "code": "void walk_reentrantly_0000423c(void* reent_ptr)\n{\n  _fwalk_reent(reent_ptr, DAT_00004244);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000423c",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrantly_0000423c"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "str1",
                "__s2": "str2",
                "__n": "n",
                "pbVar1": "ptr1",
                "pbVar2": "ptr2",
                "uVar3": "char1"
            },
            "code": "int compare_strings_00004e66(char* str1, char* str2, size_t n)\n{\n    byte *ptr2;\n    byte *ptr1;\n    uint char1;\n\n    if (n == 0)\n    {\n        return 0;\n    }\n\n    ptr2 = (byte *)(str2 + n - 1);\n    ptr1 = (byte *)str1;\n\n    do\n    {\n        char1 = (uint)*ptr1;\n        ptr2++;\n        if ((char1 != *ptr2) || (ptr1 + 1 == (byte *)(str1 + n)))\n        {\n            break;\n        }\n\n        ptr1++;\n    } while (char1 != 0);\n\n    n = char1 - *ptr2;\n    return n;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "calculate_string_length_00005ecc",
                "__s": "input_string",
                "pcVar3": "current_char_ptr",
                "pcVar2": "next_char_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t calculate_string_length_00005ecc(char* input_string) {\n  char current_char;\n  char* current_char_ptr = input_string;\n  while (current_char = *current_char_ptr) {\n    current_char_ptr++;\n  }\n  return (size_t)(current_char_ptr - input_string);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "_tzset_unlocked_r",
                "siscanf"
            ],
            "imported": false,
            "current_name": "calculate_string_length_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "_FUN_0000129c": "acquire_mutex",
                "mutex": "mutex",
                "FUN_0000129c": "acquire_mutex_0000129c"
            },
            "code": "void acquire_mutex_0000129c(mutex_t *mutex)\n{\n  lock_mutex(mutex);\n  return;\n}",
            "called": [
                "_mutex_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "acquire_mutex_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "process_uart_data_00001628",
                "uart": "uart_num",
                "data": "data_byte",
                "dev": "uart_ptr",
                "PTR_uart_config_00001680": "uart_config_ptr",
                "PTR_config_00001684": "config_ptr"
            },
            "code": "void process_uart_data_00001628(uart_t uart) {\n  uint8_t data;\n  UART_Type *uart_ptr = (UART_Type *)(PTR_uart_config_00001680 + uart * 0x20);\n  void (*callback)(uint32_t, uint8_t) = (void (*)(uint32_t, uint8_t))(*(int *)(PTR_config_00001684 + uart * 8));\n  uint8_t status = (*(byte *)(uart_ptr + 4) & 0x20);\n  uint32_t config = *(int *)(PTR_config_00001684 + uart * 8 + 4);\n\n  if (status != 0 && callback != 0) {\n    callback(config, *(undefined *)(uart_ptr + 7));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "imported": false,
            "current_name": "process_uart_data_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_kinetis_mcg_fll_factor_00001748",
                "factor": "new_factor",
                "DAT_00001774": "PTR_DAT_00001774",
                "KINETIS_MCG_FLL_FACTOR_2929": "CONST_KINETIS_MCG_FLL_FACTOR_2929",
                "kinetis_mcg_fll_t": "fll_t",
                "fll_ptr": "fll_t_ptr",
                "current_fll_factor": "current_factor",
                "new_fll_factor": "new_factor"
            },
            "code": "void set_kinetis_mcg_fll_factor_00001748(kinetis_mcg_fll_t factor) {\n    kinetis_mcg_fll_t* fll_ptr = (kinetis_mcg_fll_t*)(DAT_00001774 + 3);\n    kinetis_mcg_fll_t current_fll_factor = *fll_ptr;\n    kinetis_mcg_fll_t new_fll_factor = factor | (current_fll_factor & ~KINETIS_MCG_FLL_FACTOR_2929);\n    *fll_ptr = new_fll_factor;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_fll_factor_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_rtc_alarm_enabled_flag_0000294c",
                "rtt": "rtc_instance",
                "DAT_0000296c": "DAT_RTC_CTRL",
                "uint": "uint32_t",
                "*": "*",
                "|": "|"
            },
            "code": "void set_rtc_alarm_enabled_flag_0000294c(void)\n{\n  RTC_Type *rtc_instance = PTR_RTC;\n  uint32_t *rtc_ctrl = &(DAT_0000296c);\n  *rtc_ctrl |= (1 << 4);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "rtt_init",
                "rtc_poweron"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_enabled_flag_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "acquire_recursive_lock_for_malloc_00005790",
                "PTR___lock___malloc_recursive_mutex_00005798": "PTR_recursive_lock_for_malloc"
            },
            "code": "void acquire_recursive_lock_for_malloc_00005790(void)\n{\n    __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_for_malloc_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_standard_input_output_error_00000534",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "is_standard_input_output_error"
            },
            "code": "int check_standard_input_output_error_00000534(_reent *reent, int file_descriptor) {\n  int is_standard_input_output_error;\n  reent->_errno = 0;\n  if (((file_descriptor == 0) || (file_descriptor == 1)) || (file_descriptor == 2)) {\n    is_standard_input_output_error = 1;\n  }\n  else {\n    is_standard_input_output_error = 0;\n  }\n  return is_standard_input_output_error;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_standard_input_output_error_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_flag_000017dc",
                "DAT_00001820": "flag_ptr",
                "DAT_00001824": "data_ptr",
                "DAT_00001828": "result_ptr"
            },
            "code": "void set_bit_and_check_flag_000017dc(uint32_t* DAT_00001824, uint32_t* DAT_00001820, uint32_t flag_bit){\n  bit_set32(*DAT_00001820, flag_bit);\n  if ((*DAT_00001824 & 0x100) == 0) {\n    *DAT_00001824 = 0x104;\n  }\n  *DAT_00001824 = (*DAT_00001824 & 0xfff3ffff) | 0x80000;\n  return;\n}",
            "called": [
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_bit_and_check_flag_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initialize_EVP_PKEY_context_00000410",
                "ctx": "context",
                "uart_stdioFUN_00000410": "uart_stdio_initialize"
            },
            "code": "int initialize_EVP_PKEY_context_00000410(EVP_PKEY_CTX *context) {\n  uart_stdio_initialize();\n  return (int)context;\n}",
            "called": [
                "uart_stdio_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_context_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_second_node_000005ca",
                "list": "node_list",
                "plVar1": "second_node",
                "first": "first_node"
            },
            "code": "clist_node_t remove_second_node_000005ca(clist_node_t *node_list) {\n  list_node *second_node;\n  clist_node_t *first_node;\n  if (node_list->next == (list_node *)0x0) {\n    second_node = (list_node *)0x0;\n  }\n  else {\n    second_node = node_list->next->next;\n    if (second_node == node_list->next) {\n      node_list->next = (list_node *)0x0;\n    }\n    else {\n      node_list->next->next = second_node->next;\n    }\n  }\n  return second_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "remove_second_node_000005ca"
        },
        "FUN_000043da": {
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "data_ptr",
                "param_2": "callback_func",
                "param_3": "param_3",
                "param_4": "param_4",
                "piVar3": "current_data_ptr",
                "uVar5": "result",
                "iVar6": "data_ptr_2",
                "iVar4": "data_ptr_3",
                "uVar1": "callback_result"
            },
            "code": "uint process_data_000043da(int data_ptr, code *callback_func, undefined4 param_3, undefined4 param_4)\n{\n  uint result = 0;\n  int *current_data_ptr = (int *)(data_ptr + 0x48);\n  do {\n    int data_ptr_2 = current_data_ptr[1];\n    int data_ptr_3 = current_data_ptr[2];\n    while (data_ptr_2 = data_ptr_2 + -1, -1 < data_ptr_2) {\n      if ((1 < *(ushort *)(data_ptr_3 + 0xc)) && (iVar2 = *(short *)(data_ptr_3 + 0xe) + 1, iVar2 != 0)) {\n        uint callback_result = (*callback_func)(data_ptr, data_ptr_3, param_3, iVar2, param_4);\n        result = result | callback_result;\n      }\n      data_ptr_3 = data_ptr_3 + 0x68;\n    }\n    current_data_ptr = (int *)*current_data_ptr;\n  } while (current_data_ptr != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043da",
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "process_data_000043da"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "release_recursive_lock_00005ff8",
                "PTR___lock___env_recursive_mutex_00006000": "env_recursive_mutex"
            },
            "code": "void release_recursive_lock_00005ff8(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "release_recursive_lock_00005ff8"
        },
        "FUN_00006754": {
            "renaming": {
                "FUN_00006754": "flush_file_stream_00006754",
                "param_1": "file_stream",
                "iVar1": "flush_result",
                "_IO_read_base": "_IO_read_base",
                "ushort": "unsigned short"
            },
            "code": "int flush_file_stream_00006754(FILE *file_stream) {\n  int flush_result;\n  if ((*(unsigned short *)&file_stream->_IO_read_base & 9) == 9) {\n    flush_result = fflush(file_stream);\n    return flush_result;\n  }\n  return 0;\n}",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006754",
            "calling": [],
            "imported": false,
            "current_name": "flush_file_stream_00006754"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_interrupt_priority_00002714",
                "IRQn": "interrupt_number",
                "DAT_00002740": "interrupt_register_base_address"
            },
            "code": "void set_interrupt_priority_00002714(IRQn_Type interrupt_number)\n{\n  int* interrupt_register = (int*)(DAT_00002740 + ((uint)(int)interrupt_number >> 5) * 4);\n  int bit_position = interrupt_number & 0x1fU;\n  int interrupt_bitmask = 1 << bit_position;\n  *interrupt_register = interrupt_bitmask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "handle_interrupt_000020e0",
                "DAT_000020f0": "interrupt_data"
            },
            "code": "void handle_interrupt_000020e0(void)\n{\n  irq_handler(DAT_000020f0, 2);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020e0"
        },
        "FUN_00004f80": {
            "renaming": {
                "FUN_00004f80": "parse_unsigned_integer_00004f80",
                "param_1": "output",
                "param_2": "input",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char",
                "uVar3": "prefix_flags",
                "uVar4": "parsed_value",
                "iVar5": "parse_error",
                "uVar6": "max_value",
                "uVar7": "divisor",
                "pbVar8": "previous_char",
                "pbVar9": "current",
                "PTR_DAT_00004f7c": "digit_values"
            },
            "code": "uint parse_unsigned_integer_00004f80(undefined4 *output, byte *input, byte **endptr, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint has_prefix = 0;\n  uint value = 0;\n  uint max_value;\n  byte *current = input;\n  byte *prefix_end;\n\n  // Skip leading whitespace\n  while (isspace(*current)) {\n    current++;\n  }\n\n  // Check for sign\n  if (*current == '-') {\n    is_negative = 1;\n    current++;\n  } else if (*current == '+') {\n    current++;\n  }\n\n  // Check for prefix\n  if (base == 0) {\n    if (*current == '0') {\n      has_prefix = 1;\n      current++;\n      if ((*current == 'x') || (*current == 'X')) {\n        base = 16;\n        current++;\n      } else if ((*current == 'o') || (*current == 'O')) {\n        base = 8;\n        current++;\n      } else if ((*current == 'b') || (*current == 'B')) {\n        base = 2;\n        current++;\n      } else {\n        base = 10;\n      }\n    } else {\n      base = 10;\n    }\n  } else if (base == 16) {\n    if ((*current == '0') && ((*(current + 1) == 'x') || (*(current + 1) == 'X'))) {\n      has_prefix = 1;\n      current += 2;\n    }\n  }\n\n  // Calculate max value for overflow check\n  max_value = (UINT_MAX / base);\n\n  // Parse digits\n  while (*current != '\\0') {\n    digit_value = *current;\n    if (isdigit(digit_value)) {\n      digit_value -= '0';\n    } else if (isupper(digit_value)) {\n      digit_value -= ('A' - 10);\n    } else if (islower(digit_value)) {\n      digit_value -= ('a' - 10);\n    } else {\n      break;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (value > max_value) {\n      output = 0;\n      if (endptr == NULL) {\n        return UINT_MAX;\n      }\n      break;\n    }\n    value = (value * base) + digit_value;\n    current++;\n  }\n\n  // Set endptr\n  if (endptr != NULL) {\n    if (has_prefix) {\n      prefix_end = current - 1;\n      if (is_negative) {\n        prefix_end--;\n      }\n      *endptr = prefix_end;\n    } else {\n      *endptr = current;\n    }\n  }\n\n  // Set output\n  if (output != NULL) {\n    if (is_negative) {\n      *output = 0;\n      return -value;\n    } else {\n      *output = value;\n      return value;\n    }\n  } else {\n    return value;\n  }\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f80",
            "calling": [],
            "imported": false,
            "current_name": "parse_unsigned_integer_00004f80"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_env_mutex_00005fec",
                "PTR___lock___env_recursive_mutex_00005ff4": "PTR_env_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_env_mutex_00005fec(void)\n{\n    __retarget_lock_acquire_recursive(PTR___lock___env_recursive_mutex_00005ff4);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_env_mutex_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convert_string_to_long_00004f84",
                "__nptr": "input_string",
                "__endptr": "end_ptr",
                "__base": "base",
                "lVar1": "result",
                "_FUN_00004f84_l_isra_0": "strtol"
            },
            "code": "long convert_string_to_long_00004f84(char* input_string, char** end_ptr, int base) {\n  long result = strtol(input_string, end_ptr, base);\n  return result;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "atoi",
                "_parse_time"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_rtc_type_value_plus_one_000028f0",
                "rtt": "rtc_type_ptr",
                "*rtt": "*rtc_type_ptr",
                "value": "rtc_type_value_plus_one"
            },
            "code": "uint32_t get_rtc_type_value_plus_one_000028f0(void)\n{\n  RTC_Type *rtc_type_ptr;\n  uint32_t value = *(int *)(DAT_0000290c + 8) + 1;\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "rtc_get_alarm"
            ],
            "imported": false,
            "current_name": "get_rtc_type_value_plus_one_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "timezone_info",
                "uVar2": "result",
                "uVar3": "month_days",
                "iVar4": "is_february",
                "puVar5": "month_info",
                "iVar6": "days_since_1900",
                "uVar7": "is_leap_year",
                "iVar8": "month_index",
                "iVar9": "day_of_week",
                "uVar10": "num_leading_zeros"
            },
            "code": "undefined4 calculate_day_of_week_00004f98(uint year)\n{\n    uint *timezone_info = (uint *)__gettzinfo();\n    if ((int)year < 0x7b2) {\n        return 0;\n    }\n    else {\n        uint num_leading_zeros = count_leading_zeroes(year % 400);\n        int days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n        timezone_info[1] = year;\n        uint *month_info = timezone_info;\n        do {\n            uint month_days = month_info[5];\n            if (*(char *)(month_info + 2) == 'J') {\n                if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n                    days_since_1900 += (int)month_days < 0x3c ? 0 : 1;\n                }\n            }\n            else if (*(char *)(month_info + 2) == 'D') {\n                days_since_1900 += (int)month_days;\n            }\n            else {\n                uint is_leap_year = num_leading_zeros >> 5;\n                if (((year & 3) == 0) && (year % 100 != 0)) {\n                    is_leap_year = 1;\n                }\n                int month_index = 0;\n                while (month_index < (int)month_info[3]) {\n                    days_since_1900 += *(int *)(PTR___month_lengths_000050e4 + month_index * 4 + is_leap_year * 0x30 + -4);\n                    month_index++;\n                }\n                int day_of_week = month_days - (days_since_1900 + 4U) % 7;\n                if (day_of_week < 0) {\n                    day_of_week += 7;\n                }\n                for (day_of_week = (month_info[4] - 1) * 7 + day_of_week; *(int *)(PTR___month_lengths_000050e4 + month_index * 4 + is_leap_year * 0x30 + -4) <= day_of_week; day_of_week -= 7) {}\n                days_since_1900 += day_of_week;\n            }\n            month_days = month_info[10] + DAT_000050e0 * days_since_1900 + month_info[6];\n            month_info[8] = month_days;\n            month_info[9] = (int)month_days >> 0x1f;\n            month_info += 10;\n        } while (timezone_info + 0x14 != month_info);\n        uint days_since_epoch = timezone_info[9];\n        uint days_since_1900 = timezone_info[0x13];\n        *timezone_info = (uint)((int)((days_since_epoch - days_since_1900) - (uint)(timezone_info[8] < timezone_info[0x12])) < 0 != (SBORROW4(days_since_epoch,days_since_1900) != SBORROW4(days_since_epoch - days_since_1900,(uint)(timezone_info[8] < timezone_info[0x12]))));\n        return 1;\n    }\n}",
            "called": [
                "__gettzinfo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "write_to_file_00004dee",
                "param_1": "reent_ptr",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "*(ushort *)(param_2 + 0xc)": "flag",
                "*(ushort *)(param_2 + 0xe)": "offset"
            },
            "code": "void write_to_file_00004dee(_reent *reent_ptr, int file_descriptor, void *buffer, size_t buffer_size)\n{\n    uint16_t flag = *(uint16_t *)(file_descriptor + 0xc);\n    if ((int)(flag << 0x17) < 0) {\n        int offset = *(int16_t *)(file_descriptor + 0xe);\n        _lseek_r(reent_ptr, offset, 0, 2);\n    }\n    *(uint16_t *)(file_descriptor + 0xc) = flag & 0xefff;\n    _write_r(reent_ptr, *(int16_t *)(file_descriptor + 0xe), buffer, buffer_size);\n    return;\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "circular_buffer_t",
                "c": "temp_buffer",
                "size": "size",
                "PTR_assert_crash_message_00001030": "PTR_assert_crash_message_00001030"
            },
            "code": "void initialize_circular_buffer_00000fec(circular_buffer_t *buffer, uint32_t size)\n{\n  circular_buffer_t temp_buffer;\n  if ((size & (size - 1)) != 0) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00001030);\n  }\n  buffer->read_count = 0;\n  buffer->write_count = 0;\n  buffer->mask = size - 1;\n  return;\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "allocate_memory_00000428",
                "r": "reent_ptr",
                "incr": "increment",
                "state_00": "irq_state_1",
                "state": "irq_state_2",
                "res": "result_ptr"
            },
            "code": "void * allocate_memory_00000428(_reent *reent_ptr, ptrdiff_t increment) {\n  uint irq_state_1;\n  uint irq_state_2;\n  void *result_ptr;\n  irq_state_1 = irq_disable();\n  result_ptr = *(void **)PTR_heap_top_00000484;\n  if ((PTR__eram_00000488 < (undefined *)(increment + *(int *)PTR_heap_top_00000484)) || ((undefined *)(increment + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) {\n    reent_ptr->_errno = 0xc;\n    result_ptr = (void *)0xffffffff;\n  }\n  else {\n    *(ptrdiff_t *)PTR_heap_top_00000484 = increment + *(int *)PTR_heap_top_00000484;\n  }\n  irq_state_2 = irq_restore(irq_state_1);\n  return result_ptr;\n}",
            "called": [
                "irq_disable",
                "irq_restore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "get_class_name_000039e8",
                "class_id": "class_id",
                "pcVar1": "class_name"
            },
            "code": "char * get_class_name_000039e8(uint8_t class_id)\n{\n  char *class_name;\n  class_name = PTR_s_CLASS_UNKNOWN_00003d20;\n  switch(class_id) {\n    case '\\0':\n      class_name = PTR_s_CLASS_UNDEF_00003cc0;\n      break;\n    case '@':\n      class_name = PTR_s_ACT_ANY_00003cc4;\n      break;\n    case 'B':\n      class_name = PTR_s_ACT_LED_RGB_00003cc8;\n      break;\n    case 'C':\n      class_name = PTR_s_ACT_SERVO_00003ccc;\n      break;\n    case 'D':\n      class_name = PTR_s_ACT_MOTOR_00003cd0;\n      break;\n    case 'E':\n      class_name = PTR_s_ACT_SWITCH_00003cd4;\n      break;\n    case 'F':\n      class_name = PTR_s_ACT_DIMMER_00003cd8;\n      break;\n    case 0x80:\n      class_name = PTR_s_SENSE_ANY_00003cdc;\n      break;\n    case 0x81:\n      class_name = PTR_s_SENSE_BTN_00003ce0;\n      break;\n    case 0x82:\n      class_name = PTR_s_SENSE_TEMP_00003ce4;\n      break;\n    case 0x83:\n      class_name = PTR_s_SENSE_HUM_00003ce8;\n      break;\n    case 0x84:\n      class_name = PTR_s_SENSE_LIGHT_00003cec;\n      break;\n    case 0x85:\n      class_name = PTR_s_SENSE_ACCEL_00003cf0;\n      break;\n    case 0x86:\n      class_name = PTR_s_SENSE_MAG_00003cf4;\n      break;\n    case 0x87:\n      class_name = PTR_s_SENSE_GYRO_00003cf8;\n      break;\n    case 0x88:\n      class_name = PTR_s_SENSE_COLOR_00003cfc;\n      break;\n    case 0x89:\n      class_name = PTR_s_SENSE_PRESS_00003d00;\n      break;\n    case 0x8a:\n      class_name = PTR_s_SENSE_ANALOG_00003d04;\n      break;\n    case 0x8b:\n      class_name = PTR_s_SENSE_UV_00003d08;\n      break;\n    case 0x8c:\n      class_name = PTR_s_SENSE_OBJTEMP_00003d0c;\n      break;\n    case 0x8d:\n      class_name = PTR_s_SENSE_PULSE_COUNT_00003d10;\n      break;\n    case 0x8e:\n      class_name = PTR_s_SENSE_DISTANCE_00003d14;\n      break;\n    case 0x8f:\n      class_name = PTR_s_SENSE_CO2_00003d18;\n      break;\n    case 0xff:\n      return PTR_s_CLASS_ANY_00003d1c;\n    default:\n      break;\n  }\n  return class_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "probe",
                "list"
            ],
            "imported": false,
            "current_name": "get_class_name_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "send_buffer_to_uart_00000e38",
                "buffer": "buffer_to_send",
                "len": "buffer_len"
            },
            "code": "int send_buffer_to_uart_00000e38(char *buffer_to_send, int buffer_len)\n{\n  uart_write(0, (uint8_t *)buffer_to_send, buffer_len);\n  return buffer_len;\n}",
            "called": [
                "uart_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_buffer_to_uart_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_ring_buffer_full_00002294",
                "rb": "ring_buffer",
                "bVar1": "buffer_full_byte",
                "uVar2": "buffer_size",
                "bVar3": "buffer_full"
            },
            "code": "bool is_ring_buffer_full_00002294(tsrb_t *ring_buffer) {\n  uint32_t buffer_size = ring_buffer->size;\n  bool buffer_full = (ring_buffer->writes - ring_buffer->reads == buffer_size);\n  if (buffer_full) {\n    buffer_size = 1;\n  }\n  uint8_t buffer_full_byte = (uint8_t)buffer_size;\n  if (!buffer_full) {\n    buffer_full_byte = 0;\n  }\n  return (bool)buffer_full_byte;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "is_ring_buffer_full_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "format_integer_as_decimal_fixed_point_00003e9e",
                "out": "output_buffer",
                "val": "input_value",
                "fp_digits": "fixed_point_digits",
                "sVar1": "formatted_length"
            },
            "code": "size_t format_integer_as_decimal_fixed_point_00003e9e(char *output_buffer, int16_t input_value, int fixed_point_digits) {\n  size_t formatted_length = fmt_s32_dfp(output_buffer, (int)input_value, fixed_point_digits);\n  return formatted_length;\n}",
            "called": [
                "fmt_s32_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "format_integer_as_decimal_fixed_point_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "print_time_00003378",
                "time": "time_struct",
                "time->tm_year": "year",
                "time->tm_mon": "month",
                "time->tm_mday": "day",
                "time->tm_hour": "hour",
                "time->tm_min": "minute",
                "time->tm_sec": "second"
            },
            "code": "int print_time_00003378(tm *time_struct)\n{\n  int year = time_struct->tm_year + 1900;\n  int month = time_struct->tm_mon + 1;\n  int day = time_struct->tm_mday;\n  int hour = time_struct->tm_hour;\n  int minute = time_struct->tm_min;\n  int second = time_struct->tm_sec;\n  iprintf(PTR_s__04i__02i__02i__02i__02i__02i_000033bc, year, month, day, hour, minute, second);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "print_time_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_input_output_00006768",
                "param_1": "input_stream",
                "param_2": "output_stream",
                "param_3": "stream_mode",
                "param_4": "param_4",
                "uVar1": "stream_flags",
                "iVar2": "flush_result",
                "uVar3": "stream_buffer_size",
                "uVar4": "stream_flags",
                "uVar5": "stream_length"
            },
            "code": "undefined4 process_input_output_00006768(undefined4 *input_stream, undefined4 *output_stream, undefined4 stream_mode, undefined4 param_4)\n{\n  ushort stream_flags;\n  uint stream_length;\n  if ((input_stream != (undefined4 *)0x0) && (input_stream[6] == 0)) {\n    __sinit();\n  }\n  if (output_stream == (undefined4 *)PTR___sf_fake_stdin_00006868) {\n    output_stream = (undefined4 *)input_stream[1];\n  }\n  else if (output_stream == (undefined4 *)PTR___sf_fake_stdout_0000686c) {\n    output_stream = (undefined4 *)input_stream[2];\n  }\n  else if (output_stream == (undefined4 *)PTR___sf_fake_stderr_00006870) {\n    output_stream = (undefined4 *)input_stream[3];\n  }\n  stream_flags = *(ushort *)(output_stream + 3);\n  output_stream[1] = 0;\n  stream_length = (uint)*(ushort *)(output_stream + 3);\n  if ((int)(stream_length << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(stream_length << 0x1d) < 0) {\n    if ((undefined4 *)output_stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)output_stream[0xd] != output_stream + 0x11) {\n        _free_r(input_stream);\n      }\n      output_stream[1] = output_stream[0x10];\n      output_stream[0xd] = 0;\n      if (output_stream[0x10] != 0) {\n        *output_stream = output_stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(stream_length << 0x1b)) {\n      *input_stream = 9;\n      stream_flags = stream_flags | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(stream_length << 0x1c) < 0) {\n      int flush_result = _fflush_r(input_stream, output_stream, stream_length << 0x1c, stream_length, param_4);\n      if (flush_result != 0) {\n        return 0xffffffff;\n      }\n      output_stream[2] = 0;\n      *(ushort *)(output_stream + 3) = *(ushort *)(output_stream + 3) & 0xfff7;\n      output_stream[6] = 0;\n    }\n    *(ushort *)(output_stream + 3) = *(ushort *)(output_stream + 3) | 4;\n  }\n  if (output_stream[4] == 0) {\n    __smakebuf_r(input_stream, output_stream);\n  }\n  stream_flags = *(ushort *)(output_stream + 3);\n  ushort old_stream_flags = *(ushort *)(output_stream + 3);\n  if ((stream_flags & 3) != 0) {\n    *(ushort *)(output_stream + 3) = 1;\n    _fwalk(*(undefined4 *)PTR__global_impure_ptr_00006874, DAT_00006878);\n    *(ushort *)(output_stream + 3) = old_stream_flags;\n    if ((stream_flags & 9) == 9) {\n      __sflush_r(input_stream, output_stream);\n    }\n  }\n  undefined4 stream_buffer_size = output_stream[4];\n  *output_stream = stream_buffer_size;\n  int result = (*(code *)output_stream[9])(input_stream, output_stream[8], stream_buffer_size, output_stream[5]);\n  output_stream[1] = result;\n  if (0 < result) {\n    return 0;\n  }\n  stream_flags = *(ushort *)(output_stream + 3);\n  if (result != 0) {\n    stream_buffer_size = 0;\n  }\n  else {\n    stream_flags = stream_flags | 0x20;\n  }\n  if (result != 0) {\n    output_stream[1] = stream_buffer_size;\n    stream_flags = stream_flags | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(output_stream + 3) = stream_flags;\n  return 0xffffffff;\n}",
            "called": [
                "_fwalk",
                "__sflush_r",
                "_free_r",
                "_fflush_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "__srget_r"
            ],
            "imported": false,
            "current_name": "process_input_output_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "code": "void disable_watchdog_and_fix_cpu_errata_00000db0(void)\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}",
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "set_rtt_counter_from_time_00002600",
                "time": "time_in_seconds",
                "counter": "counter_from_time_struct"
            },
            "code": "int set_rtt_counter_from_time_00002600(tm *time_struct)\n{\n  uint32_t counter_from_time_struct;\n  time_t time;\n  \n  time = mktime((tm *)time_struct);\n  rtt_set_counter(counter_from_time_struct);\n  return 0;\n}",
            "called": [
                "rtt_set_counter",
                "mktime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "set_rtt_counter_from_time_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_unit_string_00003810",
                "unit": "unit",
                "pcVar1": "unit_string",
                "PTR_DAT_00003914": "PTR_UNIT_STRING_DEFAULT",
                "PTR_DAT_000038cc": "PTR_UNIT_STRING_02",
                "PTR_DAT_000038d0": "PTR_UNIT_STRING_03",
                "PTR_DAT_000038d4": "PTR_UNIT_STRING_04",
                "PTR_PTR_s_R_000038d8": "PTR_UNIT_STRING_05",
                "PTR_DAT_000038dc": "PTR_UNIT_STRING_06",
                "PTR_DAT_000038e0": "PTR_UNIT_STRING_07",
                "PTR_DAT_000038e4": "PTR_UNIT_STRING_08",
                "PTR_DAT_000038e8": "PTR_UNIT_STRING_09",
                "PTR_DAT_000038ec": "PTR_UNIT_STRING_0A",
                "PTR_DAT_000038f0": "PTR_UNIT_STRING_0B",
                "PTR_DAT_000038f4": "PTR_UNIT_STRING_0C",
                "PTR_DAT_000038f8": "PTR_UNIT_STRING_0D",
                "PTR_DAT_000038fc": "PTR_UNIT_STRING_0E",
                "PTR_DAT_00003900": "PTR_UNIT_STRING_0F",
                "PTR_DAT_00003904": "PTR_UNIT_STRING_10",
                "PTR_DAT_0000390c": "PTR_UNIT_STRING_11",
                "PTR_DAT_00003910": "PTR_UNIT_STRING_13"
            },
            "code": "char* get_unit_string_00003810(uint8_t unit) {\n    char* unit_string;\n    switch(unit) {\n        case 0x02:\n            unit_string = PTR_DAT_000038cc;\n            break;\n        case 0x03:\n            unit_string = PTR_DAT_000038d0;\n            break;\n        case 0x04:\n            unit_string = PTR_DAT_000038d4;\n            break;\n        case 0x05:\n            unit_string = PTR_PTR_s_R_000038d8;\n            break;\n        case 0x06:\n            unit_string = PTR_DAT_000038dc;\n            break;\n        case 0x07:\n            unit_string = PTR_DAT_000038e0;\n            break;\n        case 0x08:\n            unit_string = PTR_DAT_000038e4;\n            break;\n        case 0x09:\n            unit_string = PTR_DAT_000038e8;\n            break;\n        case 0x0a:\n            unit_string = PTR_DAT_000038ec;\n            break;\n        case 0x0b:\n            unit_string = PTR_DAT_000038f0;\n            break;\n        case 0x0c:\n            unit_string = PTR_DAT_000038f4;\n            break;\n        case 0x0d:\n            unit_string = PTR_DAT_000038f8;\n            break;\n        case 0x0e:\n            unit_string = PTR_DAT_000038fc;\n            break;\n        case 0x0f:\n            unit_string = PTR_DAT_00003900;\n            break;\n        case 0x10:\n            unit_string = PTR_DAT_00003904;\n            break;\n        case 0x11:\n            unit_string = PTR_DAT_0000390c;\n            break;\n        case 0x12:\n            unit_string = PTR_UNIT_STRING_12;\n            break;\n        case 0x13:\n            unit_string = PTR_DAT_00003910;\n            break;\n        case 0x14:\n            unit_string = PTR_UNIT_STRING_14;\n            break;\n        case 0x15:\n            unit_string = PTR_UNIT_STRING_15;\n            break;\n        default:\n            unit_string = PTR_DAT_00003914;\n            break;\n    }\n    return unit_string;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_unit_string_00003810"
        },
        "FUN_0000041c": {
            "renaming": {
                "FUN_0000041c": "do_nothing_0000041c"
            },
            "code": "\nvoid do_nothing_0000041c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000041c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0000041c"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "print_lr_address_00000ed8",
                "in_lr": "unused",
                "lr_ptr": "lr_address_ptr",
                "PTR_DAT_00000ef4": "PTR_DAT_00000ef4",
                "uint32_t": "uint32_t"
            },
            "code": "void print_lr_address_00000ed8(void)\n{\n  uint32_t *lr_address_ptr;\n  lr_address_ptr = __builtin_return_address(0);\n  iprintf(PTR_DAT_00000ef4, (uint32_t)lr_address_ptr);\n  return;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_lr_address_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "print_alarm_message_000031e0",
                "arg": "alarm_message",
                "PTR_s_The_alarm_rang_000031f8": "alarm_message"
            },
            "code": "void print_alarm_message_000031e0(void *PTR_s_The_alarm_rang_000031f8){\n  puts(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "print_alarm_message_000031e0"
        },
        "FUN_000004d4": {
            "renaming": {
                "FUN_000004d4": "set_errno_to_0x13_000004d4",
                "r": "reent",
                "fd": "file_descriptor",
                "_errno": "_error_number"
            },
            "code": "int set_errno_to_0x13_000004d4(_reent *reent, int file_descriptor) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004d4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "set_errno_to_0x13_000004d4"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "handle_irq_000020f4",
                "DAT_00002104": "interrupt_number"
            },
            "code": "void handle_irq_000020f4(void)\n{\n  irq_handler(DAT_00002104, 3);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_expand_0000687c",
                "param_1": "size",
                "param_2": "input",
                "pbVar1": "output_pointer",
                "uVar2": "output_index",
                "iVar3": "output_index",
                "uVar4": "current_char",
                "uVar5": "current_range_end",
                "uVar6": "current_range_start",
                "bVar7": "is_range"
            },
            "code": "byte* reverse_and_expand_0000687c(int size, byte* input)\n{\n  byte* output_pointer;\n  uint current_char;\n  int output_index;\n  uint current_range_end;\n  uint current_range_start;\n  bool is_range;\n  bool is_inverted = false;\n  current_char = (uint)*input;\n  is_range = current_char == 0x5e;\n  if (is_range) {\n    current_char = (uint)input[1];\n    input = input + 2;\n  }\n  else {\n    input = input + 1;\n  }\n  output_index = size - 1;\n  do {\n    output_index = output_index + 1;\n    *(bool*)output_index = is_range;\n  } while (output_index != size + 0xff);\n  if (current_char == 0) {\n    output_pointer = input - 1;\n  }\n  else {\n    do {\n      current_range_end = current_char;\n      *(bool*)(size + current_range_end) = !is_range;\n      input = input + 1;\n      while (true) {\n        current_char = (uint)input[-1];\n        if (current_char != 0x2d) break;\n        current_range_start = (uint)*input;\n        if ((current_range_start == 0x5d) || ((int)current_range_start < (int)current_range_end)) goto LAB_000068aa;\n        do {\n          current_range_end = current_range_end + 1;\n          *(bool*)(size + current_range_end) = !is_range;\n        } while ((int)current_range_end < (int)current_range_start);\n        output_index = ~current_char + current_range_start;\n        if ((int)current_range_start <= (int)current_char) {\n          output_index = 0;\n        }\n        current_char = current_range_end + 1 + output_index;\n        input = input + 2;\n      }\n      output_pointer = input + -1;\n    } while ((current_char != 0x5d) && (output_pointer = input + -1, current_char != 0));\n  }\n  return output_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reverse_and_expand_0000687c"
        },
        "FUN_00004dea": {
            "renaming": {
                "FUN_00004dea": "return_zero_00004dea"
            },
            "code": "int return_zero_00004dea() {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dea",
            "calling": [],
            "imported": false,
            "current_name": "return_zero_00004dea"
        },
        "FUN_00005edc": {
            "renaming": {
                "_strtoul_l_isra_0": "convert_string_to_unsigned_long_int",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "end_pointer",
                "param_4": "base",
                "uVar1": "result",
                "uVar2": "current_char_code",
                "bVar3": "is_hex",
                "iVar4": "valid_digit_found",
                "uVar5": "current_digit_value",
                "uVar6": "max_digit_value",
                "pbVar7": "current_char_pointer",
                "pbVar8": "next_char_pointer",
                "FUN_00005edc": "convert_string_to_unsigned_long_int_00005edc"
            },
            "code": "uint convert_string_to_unsigned_long_int_00005edc(undefined4 *output, byte *input_string, byte **end_pointer, uint base) {\n  uint current_char_code;\n  uint is_negative = 0;\n  uint is_hex = 0;\n  uint max_digit_value = 0xffffffff / base;\n  uint result = 0;\n  int valid_digit_found = 0;\n  byte *current_char_pointer = input_string;\n  \n  while ((current_char_code = (uint)*current_char_pointer) != 0) {\n    if ((PTR_DAT_00005fd0[current_char_code] & 8) == 0) {\n      break;\n    }\n    current_char_pointer++;\n  }\n  \n  if (current_char_code == 0x2d) {\n    is_negative = 1;\n    current_char_code = (uint)*++current_char_pointer;\n  }\n  else if (current_char_code == 0x2b) {\n    current_char_code = (uint)*++current_char_pointer;\n  }\n  \n  if (base == 0) {\n    if (current_char_code != 0x30) {\n      base = 10;\n    }\n  }\n  else if (base == 16 && current_char_code == 0x30 && ((*++current_char_pointer) & 0xdf) == 0x58) {\n    is_hex = 1;\n    current_char_code = (uint)*++current_char_pointer;\n  }\n  else if (current_char_code == 0x30) {\n    base = 8;\n  }\n  \n  while (current_char_code != 0) {\n    uint current_digit_value = current_char_code - 0x30;\n    if (current_digit_value > 9) {\n      if (current_char_code - 0x41 < 0x1a) {\n        current_digit_value = current_char_code - 0x37;\n      }\n      else if (current_char_code - 0x61 < 0x1a) {\n        current_digit_value = current_char_code - 0x57;\n      }\n      else {\n        break;\n      }\n    }\n    if (current_digit_value >= base) {\n      break;\n    }\n    if (result > max_digit_value || (result == max_digit_value && current_digit_value > 0xffffffff % base)) {\n      valid_digit_found = -1;\n    }\n    else {\n      valid_digit_found = 1;\n      result = result * base + current_digit_value;\n    }\n    current_char_code = (uint)*++current_char_pointer;\n  }\n  \n  if (valid_digit_found < 0) {\n    *output = 0x22;\n    result = 0xffffffff;\n    if (end_pointer == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      result = -result;\n    }\n    if (end_pointer == (byte **)0x0) {\n      return result;\n    }\n    if (valid_digit_found == 0) {\n      current_char_pointer--;\n    }\n  }\n  *end_pointer = current_char_pointer;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "imported": false,
            "current_name": "convert_string_to_unsigned_long_int_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "configure_gpio_pin_00001eea",
                "pin": "gpio_pin",
                "mode": "gpio_mode",
                "uVar1": "pin_number",
                "pGVar2": "gpio_pointer",
                "pPVar3": "port_pointer",
                "iVar4": "return_value",
                "FUN_00001eea_port": "configure_gpio_pin_port",
                "GPIO_Type": "GPIO_Type",
                "PORT_Type": "PORT_Type",
                "GPIO_IN": "GPIO_IN",
                "pin_num": "get_pin_number",
                "gpio": "get_gpio_pointer",
                "PDDR": "PDDR",
                "port": "get_port_pointer",
                "PCR": "PCR",
                "byte": "byte"
            },
            "code": "int configure_gpio_pin_00001eea(gpio_t pin, gpio_mode_t mode) {\n  uint8_t pin_number;\n  GPIO_Type *gpio_pointer;\n  PORT_Type *port_pointer;\n  int return_value = 0;\n  configure_gpio_pin_00001eea_port(pin, 0);\n  if (mode < GPIO_IN) {\n    pin_number = get_pin_number(pin);\n    gpio_pointer = get_gpio_pointer(pin);\n    gpio_pointer->PDDR |= 1 << (pin_number & 0xff);\n  }\n  else {\n    pin_number = get_pin_number(pin);\n    gpio_pointer = get_gpio_pointer(pin);\n    gpio_pointer->PDDR &= ~(1 << (pin_number & 0xff));\n  }\n  port_pointer = get_port_pointer(pin);\n  pin_number = get_pin_number(pin);\n  port_pointer->PCR[pin_number] = (byte)mode & 0x23 | 0x100;\n  return return_value;\n}\n",
            "called": [
                "port",
                "gpio",
                "gpio_init_port",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "command_line",
                "PTR_s_Welcome_to_RIOT__000023c4": "welcome_message",
                "shell_run": "shell_run",
                "(shell_command_t *)0x0": "(shell_command_t *)0x0",
                "0x80": "0x80",
                "startForkserver": "start_fork_server"
            },
            "code": "void run_shell_command_000023a4(void)\n{\n  char command_line[128];\n  start_fork_server(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n  shell_run((shell_command_t *)0x0, command_line, 0x80);\n}\n",
            "called": [
                "shell_run",
                "puts",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "run_shell_command_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "remove_next_node_0000240c",
                "list": "current_node",
                "plVar1": "next_node",
                "head": "N/A"
            },
            "code": "list_node_t* remove_next_node_0000240c(list_node_t* current_node)\n{\n  list_node_t* next_node = current_node->next;\n  if (next_node != (list_node_t*)0x0) {\n    current_node->next = next_node->next;\n  }\n  return next_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "remove_next_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "release_recursive_mutex_00004280"
            },
            "code": "void release_recursive_mutex_00004280(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "initialize_uart_gpio_00001448",
                "uart": "uart_num",
                "PTR_uart_config_000014c0": "uart_config",
                "gpio_init_port": "initialize_gpio_port",
                "short": "short_num",
                "gpio_t": "gpio",
                "uint32_t": "uint32_num"
            },
            "code": "void initialize_uart_gpio_00001448(uart_t uart) {\n    short* PTR_uart_config_000014c0 = PTR_PTR_uart_config_000014c0_000014c0 + uart * 0x20;\n    if (*(PTR_uart_config_000014c0 + 4) != -1) {\n        gpio_t tx_gpio = *(gpio_t *)(PTR_uart_config_000014c0 + 2);\n        uint32_t tx_pin = *(PTR_uart_config_000014c0 + 3);\n        gpio_init_port(tx_gpio, tx_pin);\n    }\n    if (*(PTR_uart_config_000014c0 + 5) != -1) {\n        gpio_t rx_gpio = *(gpio_t *)(PTR_uart_config_000014c0 + 2);\n        uint32_t rx_pin = *(PTR_uart_config_000014c0 + 4);\n        gpio_init_port(rx_gpio, rx_pin);\n    }\n    return;\n}",
            "called": [
                "gpio_init_port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_gpio_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "handle_uart_interrupt_00001688"
            },
            "code": "void handle_uart_interrupt_00001688(void)\n{\n  irq_handler_uart(0);\n  return;\n}",
            "called": [
                "irq_handler_uart"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "string_to_convert",
                "lVar1": "converted_value"
            },
            "code": "long convert_string_to_long_00004042(char* string_to_convert) {\n  long converted_value = strtol(string_to_convert, (char**)0x0, 10);\n  return converted_value;\n}",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "get_irq_interrupts_enabled_status_00000cf0",
                "bVar1": "is_privileged_mode",
                "uVar2": "irq_interrupts_enabled_status",
                "result": "N/A"
            },
            "code": "uint get_irq_interrupts_enabled_status_00000cf0(void)\n{\n  bool is_privileged_mode;\n  uint irq_interrupts_enabled_status;\n  enable_irq_interrupts();\n  irq_interrupts_enabled_status = 0;\n  is_privileged_mode = (bool)is_current_mode_privileged();\n  if (is_privileged_mode) {\n    irq_interrupts_enabled_status = is_irq_interrupts_enabled();\n  }\n  return irq_interrupts_enabled_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "cpu_switch_context_exit"
            ],
            "imported": false,
            "current_name": "get_irq_interrupts_enabled_status_00000cf0"
        },
        "FUN_00006cd4": {
            "renaming": {
                "FUN_00006cd4": "do_nothing_00006cd4"
            },
            "code": "\nvoid do_nothing_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006cd4",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_00006cd4"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "create_idle_and_main_threads_00000f8c",
                "PTR_idle_stack_00000fdc": "idle_stack",
                "PTR_main_stack_00000fe8": "main_stack",
                "DAT_00000fd8": "idle_priority",
                "PTR_idle_name_00000fd4": "idle_name",
                "DAT_00000fe4": "main_priority",
                "PTR_main_name_00000fe0": "main_name"
            },
            "code": "void create_idle_and_main_threads_00000f8c(void)\\n{\\n  irq_disable();\\n  thread_create(PTR_idle_stack_00000fdc, 0x100, \"\\x0f\", 0xc, DAT_00000fd8, NULL, PTR_idle_name_00000fd4);\\n  thread_create(PTR_main_stack_00000fe8, 0x600, \"\\a\", 0xc, DAT_00000fe4, NULL, PTR_main_name_00000fe0);\\n  cpu_switch_context_exit();\\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "thread_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "create_idle_and_main_threads_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_rtc_alarm_00002894",
                "alarm": "alarm_time",
                "cb": "callback",
                "arg": "callback_arg",
                "iVar1": "rtt_base_address",
                "DAT_000028e8": "rtt_base_address",
                "control_register": "control_register",
                "alarm_register": "alarm_register",
                "PTR_rtt_callback_000028ec": "PTR_rtt_callback_000028ec"
            },
            "code": "void set_rtc_alarm_00002894(uint32_t alarm_time, rtt_callback_t callback, void *callback_arg)\n{\n  int DAT_000028e8 = DAT_000028e8;\n  uint32_t *control_register = (uint32_t *)(DAT_000028e8 + 0x1c);\n  *control_register &= 0xfffffffb;\n  uint32_t *alarm_register = (uint32_t *)(DAT_000028e8 + 8);\n  *alarm_register = alarm_time - 1;\n  *(rtt_callback_t *)PTR_rtt_callback_000028ec = callback;\n  *(void **)(PTR_rtt_callback_000028ec + 4) = callback_arg;\n  *control_register |= 4;\n  NVIC_SetPriority(RTC_IRQn, 10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}",
            "called": [
                "NVIC_SetPriority",
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "flush_stream_if_not_null_00004158",
                "param_1": "stream_pointer",
                "param_2": "stream",
                "uVar1": "return_value"
            },
            "code": "int flush_stream_if_not_null_00004158(int stream_pointer, void *stream) {\n  int return_value;\n\n  if (*(int *)(stream + 0x10) != 0) {\n    if ((stream_pointer != 0) && (*(int *)(stream_pointer + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == PTR___sf_fake_stdin_000041c4) {\n      stream = *(void **)(stream_pointer + 4);\n    }\n    else if (stream == PTR___sf_fake_stdout_000041c8) {\n      stream = *(void **)(stream_pointer + 8);\n    }\n    else if (stream == PTR___sf_fake_stderr_000041cc) {\n      stream = *(void **)(stream_pointer + 0xc);\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      if ((-1 < *(int *)(stream + 100) << 0x1f) && (-1 < (int)*(short *)(stream + 0xc) << 0x16)) {\n        __retarget_lock_acquire_recursive(*(int *)(stream + 0x58));\n      }\n      return_value = __sflush_r(stream_pointer, stream);\n      if (*(int *)(stream + 100) << 0x1f < 0) {\n        return return_value;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x16) < 0) {\n        return return_value;\n      }\n      __retarget_lock_release_recursive(*(int *)(stream + 0x58));\n      return return_value;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "flush_stream_if_not_null_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "alarm_time",
                "cb": "callback",
                "arg": "argument"
            },
            "code": "int set_rtc_alarm_00002654(tm *time, rtc_alarm_cb_t callback, void *argument) {\n  uint32_t alarm_time = mktime((tm *)time);\n  *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = callback;\n  rtt_set_alarm(alarm_time, DAT_0000268c, argument);\n  return 0;\n}",
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "_rtc_setalarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002654"
        },
        "FUN_00000aa8": {
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "corrupted_stack",
                "exc_return": "exc_return",
                "r4_to_r11_stack": "r4_to_r11_stack",
                "iVar1": "stack_size_left",
                "psr": "psr",
                "lr": "lr",
                "r12": "r12",
                "r3": "r3",
                "r2": "r2",
                "r1": "r1",
                "r0": "r0",
                "afsr": "afsr",
                "dfsr": "dfsr",
                "hfsr": "hfsr",
                "cfsr": "cfsr",
                "mmfar": "mmfar",
                "bfar": "bfar",
                "orig_sp": "original_sp",
                "pc": "pc",
                "uVar2": "bfar_value",
                "uVar3": "mmfar_value",
                "uVar4": "cfsr_value",
                "uVar5": "hfsr_value",
                "uVar6": "dfsr_value",
                "uVar7": "afsr_value"
            },
            "code": "void handle_hard_fault_00000aa8(uint32_t *stack_pointer, uint32_t corrupted_stack, uint32_t exc_return, uint32_t *r4_to_r11_stack)\n{\n  int stack_size_left;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *original_sp;\n  uint32_t pc;\n  \n  uint32_t cfsr_value = *(uint *)(DAT_00000c24 + 0x28);\n  uint32_t hfsr_value = *(uint *)(DAT_00000c24 + 0x2c);\n  uint32_t dfsr_value = *(uint *)(DAT_00000c24 + 0x30);\n  uint32_t afsr_value = *(uint *)(DAT_00000c24 + 0x3c);\n  uint32_t bfar_value = *(uint *)(DAT_00000c24 + 0x38);\n  uint32_t mmfar_value = *(uint *)(DAT_00000c24 + 0x34);\n  \n  pc = 0;\n  if (*(int *)PTR_isr_stack_00000c28 != DAT_00000c2c) {\n    puts(PTR_s__ISR_stack_overflowed_00000c30);\n  }\n  if (corrupted_stack == 0) {\n    r0 = *stack_pointer;\n    r1 = stack_pointer[1];\n    r2 = stack_pointer[2];\n    r3 = stack_pointer[4];\n    r12 = stack_pointer[5];\n    pc = stack_pointer[6];\n    puts(PTR_s__Context_before_hardfault__00000c38);\n    iprintf(PTR_s__r0__0x_08lx_r1__0x_08lx_r2__0x__00000c3c,r0,r1,r2);\n    iprintf(PTR_s__r12__0x_08lx_lr__0x_08lx_pc__0x_00000c40,r3,r12,pc);\n  }\n  else {\n    puts(PTR_s_Stack_pointer_corrupted__reset_t_00000c34);\n  }\n  puts(PTR_s_FSR_FAR__00000c44);\n  iprintf(PTR_s__CFSR__0x_08lx_00000c48,cfsr_value);\n  iprintf(PTR_s__HFSR__0x_08lx_00000c4c,hfsr_value);\n  iprintf(PTR_s__DFSR__0x_08lx_00000c50,dfsr_value);\n  iprintf(PTR_s__AFSR__0x_08lx_00000c54,afsr_value);\n  if ((cfsr_value & *(uint *)PTR_BFARVALID_MASK_00000c58) != 0) {\n    iprintf(PTR_s__BFAR__0x_08lx_00000c5c,bfar_value);\n  }\n  if ((cfsr_value & *(uint *)PTR_MMARVALID_MASK_00000c60) != 0) {\n    iprintf(PTR_s_MMFAR__0x_08lx_00000c64,mmfar_value);\n  }\n  puts(PTR_DAT_00000c68);\n  iprintf(PTR_s_EXC_RET__0x_08lx_00000c6c,exc_return);\n  if (corrupted_stack == 0) {\n    puts(PTR_s_Attempting_to_reconstruct_state_f_00000c70);\n    iprintf(PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74,pc);\n    stack_size_left = _stack_size_left(0x158);\n    if (stack_size_left < 0) {\n      iprintf(PTR_s__ISR_stack_overflowed_by_at_leas_00000c78,-stack_size_left);\n    }\n  }\n  software_bkpt(1);\n  core_panic(PANIC_HARD_FAULT,PTR_s_HARD_FAULT_HANDLER_00000c7c);\n}",
            "called": [
                "iprintf",
                "puts",
                "core_panic",
                "_stack_size_left"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000aa8",
            "calling": [
                "hard_fault_default"
            ],
            "imported": false,
            "current_name": "handle_hard_fault_00000aa8"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_irq_priority_00002538",
                "IRQn": "irq",
                "priority": "priority",
                "DAT_00002584": "irq_priority_base_address",
                "DAT_00002588": "irq_priority_base_address_dma_offset"
            },
            "code": "void set_irq_priority_00002538(IRQn_Type irq, uint32_t priority) {\n  if (irq < DMA0_IRQn) {\n    *(char *)(((byte)irq & 0xf) + DAT_00002584 + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(irq + DAT_00002588) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "cortexm_init"
            ],
            "imported": false,
            "current_name": "set_irq_priority_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "file_descriptor",
                "pcVar2": "string",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int print_formatted_string_00004c84(char *format, ...)\n{\n  int file_descriptor = *(int *)PTR__impure_ptr_00004cb0;\n  char *string = format;\n  undefined4 arg1 = 0;\n  undefined4 arg2 = 0;\n  undefined4 arg3 = 0;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit(file_descriptor);\n  }\n  int result = _vfprintf_r(file_descriptor, *(undefined4 *)(file_descriptor + 8), format, &arg1, string, &arg1);\n  return result;\n}",
            "called": [
                "_vfprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "phydat_dump",
                "_print_time",
                "ps",
                "write",
                "cpu_print_last_instruction",
                "list",
                "main_trampoline",
                "read",
                "print_help",
                "hard_fault_handler",
                "_rtc_handler",
                "core_panic",
                "_saul",
                "handle_input_line",
                "probe"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "index",
                "data": "data_to_write",
                "dim": "dimension",
                "dev": "device",
                "num": "device_number",
                "i": "index"
            },
            "code": "void write_data_to_device_0000305c(int argc, char **argv)\n{\n  int index;\n  phydat_t data_to_write;\n  int dimension;\n  saul_reg_t *device;\n  int device_number;\n  int i;\n  \n  if (argc < 4) {\n    iprintf(PTR_s_usage___s__s__device_id___value_0_00003154,*argv,argv[1]);\n  }\n  else {\n    device_number = atoi(argv[2]);\n    device = saul_reg_find_nth(device_number);\n    if (device == (saul_reg_t *)0x0) {\n      puts(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(&data_to_write, 0, 8);\n      if (argc > 5) {\n        argc = 6;\n      }\n      dimension = argc - 3;\n      for (i = 0; i < dimension; i++) {\n        index = atoi(argv[i + 3]);\n        data_to_write.val[i] = (int16_t)index;\n      }\n      iprintf(PTR_s_Writing_to_device___i____s_0000315c,device_number,device->name);\n      phydat_dump(&data_to_write, (uint8_t)dimension);\n      index = saul_reg_write(device, &data_to_write);\n      if (index < 1) {\n        if (index == -0x86) {\n          iprintf(PTR_s_error__device___i_is_not_writabl_00003160, device_number);\n        }\n        else {\n          iprintf(PTR_s_error__failure_to_write_data_to_device_0000305c_to_devic_00003164, device_number);\n        }\n      }\n      else {\n        iprintf(PTR_s_data_successfully_written_to_dev_00003168, device_number);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "saul_reg_write",
                "memset",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "add_one_to_tsrb_and_unlock_mutex_000012b4",
                "isrpipe": "input_stream_read_pipe",
                "c": "character",
                "iVar1": "add_result",
                "res": "result"
            },
            "code": "int add_one_to_tsrb_and_unlock_mutex_000012b4(isrpipe_t *isrpipe,char character) {\n  int add_result;\n  int result;\n  \n  add_result = tsrb_add_one(&isrpipe->tsrb, character);\n  mutex_unlock(&isrpipe->mutex);\n  return add_result;\n}",
            "called": [
                "tsrb_add_one",
                "mutex_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "add_one_to_tsrb_and_unlock_mutex_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  undefined *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  uint *puVar14;\n  undefined4 uVar15;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  puVar14 = param_2;\n  uVar15 = param_3;\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    __s = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    __s = (undefined *)*puVar9;\n    pvVar6 = memchr(__s,0,param_2[1]);\n    if (pvVar6 != (void *)0x0) {\n      param_2[1] = (int)pvVar6 - (int)__s;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = __s;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)__s - (int)puVar13;\n  __s = puVar13;\nLAB_00005c84:\n  iVar4 = _printf_common(param_1,param_2,&local_24,param_3,param_4,puVar14,uVar15);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar7 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "insert_node_at_end": "insert_node_at_end",
                "list": "head",
                "new_node": "new_node",
                "list->next": "head->next",
                "list_node": "clist_node_t",
                "(list_node *)0x0": "NULL",
                "FUN_0000058e": "insert_node_at_end_0000058e"
            },
            "code": "void insert_node_at_end_0000058e(clist_node_t *head, clist_node_t *new_node) {\n    if (head->next == NULL) {\n        new_node->next = new_node;\n    }\n    else {\n        new_node->next = head->next->next;\n        head->next->next = new_node;\n    }\n    head->next = new_node;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  void *local_34 [4];\n  \n  local_34[0] = *(void **)PTR_PTR_DAT_00006744;\n  local_34[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar4 = DAT_0000674c;\n  if (param_2[6] != 3) {\n    pcVar4 = DAT_00006748;\n  }\n  uVar7 = param_2[2];\n  uVar5 = uVar7 - 1;\n  if (0x15c < uVar5) {\n    unaff_r9 = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < uVar5) {\n    param_2[2] = uVar7;\n  }\n  puVar11 = param_2 + 7;\n  if (uVar5 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar12 = 0;\n  puVar10 = puVar11;\n  do {\n    pvVar1 = memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar1 != (void *)0x0) {\n      if (iVar12 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar5 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar5;\n      }\n      else if (iVar12 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar5 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 = param_2[2];\n      param_2[2] = uVar5 - 1;\n      if (uVar5 != 0) {\n        pbVar6 = *param_3;\n        *param_3 = pbVar6 + 1;\n        puVar9 = (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 = *pbVar6;\n        pbVar6 = param_3[1];\n        param_3[1] = pbVar6 + -1;\n        puVar10 = puVar9;\n        if (((int)(pbVar6 + -1) < 1) &&\n           (iVar2 = (*(code *)param_2[0x60])(param_1,param_3), iVar2 != 0)) {\n          iVar12 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 = iVar12 + 1;\n  } while (iVar12 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  __sccl(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar12 = 0;\n  while( true ) {\n    puVar9 = puVar10;\n    if (param_2[2] == 0) break;\n    pbVar6 = *param_3;\n    uVar5 = (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) == '\\0') break;\n    if ((uVar5 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar12 = iVar12 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar9 = (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 = *pbVar6;\n    }\n    pbVar6 = param_3[1];\n    param_3[1] = pbVar6 + -1;\n    if ((int)(pbVar6 + -1) < 1) {\n      iVar2 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar2 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar10 = puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar11 < puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 = (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 == puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar9 = 0;\n    uVar3 = (*pcVar4)(param_1,puVar11,0,param_2[1]);\n    puVar8 = (undefined4 *)*param_4;\n    uVar5 = *param_2;\n    *param_4 = puVar8 + 1;\n    puVar8 = (undefined4 *)*puVar8;\n    if ((uVar5 & 0x20) == 0) {\n      if ((int)(uVar5 << 0x1f) < 0) {\n        *(short *)puVar8 = (short)uVar3;\n      }\n      else {\n        *puVar8 = uVar3;\n      }\n    }\n    else {\n      *puVar8 = uVar3;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n",
            "called": [
                "__sccl",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_real_time_transfers_000025f4",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void initialize_real_time_transfers_000025f4(void)\n{\n  rtt_init();\n  return;\n}",
            "called": [
                "rtt_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "periph_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_transfers_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_00001ddc",
                "pin": "gpio_pin",
                "iVar1": "port_number",
                "DAT_00001e08": "gpio_data",
                "bit_set32": "set_bit_32"
            },
            "code": "void set_gpio_pin_00001ddc(gpio_t pin)\n{\n  int port_number = port_num(pin);\n  int bit_position = port_number + 9;\n  bit_set32(DAT_00001e08, (char)bit_position);\n  return;\n}",
            "called": [
                "port_num",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_00002ecc",
                "num": "sensor_num",
                "dev": "sensor_device",
                "iVar1": "read_result",
                "pcVar2": "sensor_name",
                "pcVar3": "sensor_type",
                "res": "sensor_data",
                "dim": "data_dim"
            },
            "code": "void read_sensor_data_00002ecc(int sensor_num, saul_reg_t *sensor_device) {\n    int read_result;\n    char *sensor_name;\n    char *sensor_type;\n    phydat_t sensor_data;\n    int data_dim;\n    \n    read_result = saul_reg_read(sensor_device, &sensor_data);\n    if (read_result < 1) {\n        iprintf(PTR_s_error__failed_to_read_from_devic_00002f28, sensor_num);\n    }\n    else {\n        sensor_name = sensor_device->name;\n        sensor_type = saul_class_to_str(sensor_device->driver->type);\n        iprintf(PTR_s_Reading_from___i___s__s__00002f2c, sensor_num, sensor_name, sensor_type);\n        phydat_dump(&sensor_data, (uint8_t)read_result);\n    }\n    return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_read",
                "iprintf",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "read",
                "probe_all"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_bit_in_uint32_00000d76",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bit_pointer"
            },
            "code": "void clear_bit_in_uint32_00000d76(uint32_t *data, uint8_t bit_position) {\n  undefined4 *bit_pointer;\n  bit_pointer = (undefined4 *)bitband_addr(data, (uint)bit_position);\n  *bit_pointer = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "cpu_errata_fixes"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint32_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "decrement_and_write_char_to_buffer_000057a8",
                "param_1": "buffer_start",
                "param_2": "char_to_write",
                "param_3": "buffer_info",
                "iVar1": "buffer_size",
                "puVar2": "buffer_ptr"
            },
            "code": "int decrement_and_write_char_to_buffer_000057a8(undefined4 buffer_start, int char_to_write, undefined4 *buffer_info) {\n  int buffer_size = buffer_info[2] - 1;\n  buffer_info[2] = buffer_size;\n  if ((buffer_size < 0) && ((buffer_size < (int)buffer_info[6] || (char_to_write == 10)))) {\n    int result = __swbuf_r();\n    return result;\n  }\n  undefined *buffer_ptr = (undefined *)*buffer_info;\n  *buffer_info = buffer_ptr + 1;\n  *buffer_ptr = (char)char_to_write;\n  return char_to_write;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "decrement_and_write_char_to_buffer_000057a8"
        },
        "FUN_00004298": {
            "renaming": {
                "FUN_00004298": "release_recursive_lock_00004298",
                "PTR___lock___sinit_recursive_mutex_000042a0": "PTR_recursive_lock"
            },
            "code": "void release_recursive_lock_00004298(void)\n{\n    __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n    return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004298",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "release_recursive_lock_00004298"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_new_address_00001696",
                "ptr": "ptr",
                "bit": "bit",
                "(uint)ptr": "ptr_uint",
                "0xf0000000": "upper_bits",
                "0xfffff": "lower_bits",
                "lower_bits << 5": "shifted_lower_bits",
                "0x2000000": "offset",
                "(void *)(bit * 4 + offset)": "new_address"
            },
            "code": "void calculate_new_address_00001696(void *ptr, uintptr_t bit) {\n    uint ptr_uint = (uint)ptr;\n    uint upper_bits = ptr_uint & 0xf0000000;\n    uint lower_bits = ptr_uint & 0xfffff;\n    uint shifted_lower_bits = lower_bits << 5;\n    uint offset = upper_bits | shifted_lower_bits | 0x2000000;\n    void *new_address = (void *)(bit * 4 + offset);\n    return new_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "bit_set8",
                "bit_clear8",
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_new_address_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_used_words_000008b8",
                "num_used_words": "used_words",
                "ptr": "stack_ptr"
            },
            "code": "int count_used_words_000008b8(void)\n{\n  ptrdiff_t used_words;\n  uint32_t *stack_ptr;\n  \n  for (stack_ptr = (uint32_t *)PTR_isr_stack_000008f4;\n      (*stack_ptr == DAT_000008f8 && (stack_ptr < PTR_heap_top_000008fc)); stack_ptr++) {\n  }\n  return ((int)PTR_heap_top_000008fc - (int)stack_ptr) & ~3;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "count_used_words_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "acquire_mutex_000024bc",
                "mutex": "mutex",
                "state": "irq_state",
                "plVar2": "front_node",
                "process_priority": "front_thread_priority",
                "irqstate": "irq_state",
                "__m____": "",
                "next": "",
                "process": "front_thread",
                "bVar1": "is_mutex_empty"
            },
            "code": "void acquire_mutex_000024bc(mutex_t *mutex)\n{\n    bool is_mutex_empty;\n    bool is_mutex_invalid;\n    list_node_t *front_node;\n    thread_t *front_thread;\n    uint16_t front_thread_priority;\n    uint irq_state;\n\n    irq_state = irq_disable();\n    is_mutex_empty = (mutex->queue).next == NULL;\n    is_mutex_invalid = (mutex->queue).next == (list_node *)0xffffffff;\n\n    if (is_mutex_empty)\n    {\n        irq_restore(irq_state);\n    }\n    else if (is_mutex_invalid)\n    {\n        (mutex->queue).next = NULL;\n        irq_restore(irq_state);\n    }\n    else\n    {\n        front_node = list_remove_head(&mutex->queue);\n        front_thread = (thread_t *)(front_node - 2);\n        front_thread_priority = front_node->next;\n        sched_set_status(front_thread, 10);\n\n        if ((mutex->queue).next == NULL)\n        {\n            (mutex->queue).next = (list_node *)0xffffffff;\n        }\n\n        irq_restore(irq_state);\n        sched_switch(front_thread_priority);\n    }\n}",
            "called": [
                "irq_disable",
                "irq_restore",
                "sched_set_status",
                "list_remove_head",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "acquire_mutex_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent_ptr",
                "fd": "fd",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "bytes_read"
            },
            "code": "_ssize_t read_from_uart_00000490(_reent *reent_ptr, int fd, void *buffer, size_t count) {\n  int bytes_read = uart_stdio_read((char *)buffer, count);\n  return bytes_read;\n}",
            "called": [
                "uart_stdio_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_from_uart_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "PTR_isr_stack_0000092c": "isr_stack_pointer"
            },
            "code": "void* get_isr_stack_pointer_0000091c(void)\n{\n  return PTR_isr_stack_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_isr_stack_pointer_0000091c"
        },
        "FUN_00005d80": {
            "renaming": {
                "FUN_00005d80": "write_character_00005d80",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "stream",
                "iVar1": "buffer_size",
                "puVar2": "buffer"
            },
            "code": "uint write_character_00005d80(int file_descriptor, uint character, undefined4 *stream)\n{\n    int buffer_size = stream[2] - 1;\n    if(buffer_size < 0 && (buffer_size < (int)stream[6] || ((character & 0xff) == 10)))\n    {\n        character = __swbuf_r(file_descriptor, character, stream);\n    }\n    else\n    {\n        undefined *buffer = (undefined *)*stream;\n        *stream = buffer + 1;\n        *buffer = (char)character;\n        character = character & 0xff;\n    }\n    if((-1 < (int)(stream[25] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 6) << 0x16)))\n    {\n        __retarget_lock_release_recursive(stream[22]);\n    }\n    return character;\n}\n",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005d80",
            "calling": [
                "putchar"
            ],
            "imported": false,
            "current_name": "write_character_00005d80"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "set_pin_control_register_00001f80",
                "pin": "gpio_pin",
                "pcr": "pin_control_register",
                "pPVar1": "port",
                "iVar2": "pin_num",
                "uVar3": "old_pcr",
                "isr_state": "isr_state",
                "clk_en": "enable_pin_clock",
                "port": "get_port",
                "ctx_clear": "clear_interrupt_context",
                "pin_00": "pin_num"
            },
            "code": "void set_pin_control_register_00001f80(gpio_t pin, uint32_t pcr)\n{\n  PORT_Type *port;\n  int pin_num;\n  uint32_t old_pcr;\n  uint32_t isr_state;\n  \n  enable_pin_clock(pin);\n  port = get_port(pin);\n  pin_num = get_pin_num(pin);\n  old_pcr = port->PCR[pin_num];\n  port->PCR[pin_num] = pcr;\n  if ((old_pcr & 0xf0000) != 0) {\n    int port_num = get_port_num(pin);\n    int pin_num = get_pin_num(pin);\n    clear_interrupt_context(port_num, pin_num);\n  }\n  return;\n}",
            "called": [
                "ctx_clear",
                "clk_en",
                "port",
                "port_num",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "gpio_init",
                "uart_init_pins"
            ],
            "imported": false,
            "current_name": "set_pin_control_register_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_cpu_and_gpio_pins_00000e64",
                "PTR_thread_add_to_list": "thread_list_add",
                "PTR_DAT_00000ed0": "data_add",
                "PTR_DAT_00000ed4": "data_add_2"
            },
            "code": "void initialize_cpu_and_gpio_pins_00000e64(void)\n{\n  uint32_t* PTR_thread_add_to_list = PTR_thread_add_to_list;\n  uint32_t* PTR_DAT_00000ed0 = PTR_DAT_00000ed0;\n  uint32_t* PTR_DAT_00000ed4 = PTR_DAT_00000ed4;\n  *(uint32_t *)(PTR_thread_add_to_list + *PTR_DAT_00000ed0 + 4) |= 0x200;\n  *(uint32_t *)(PTR_DAT_00000ed4 + 0x48) &= 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056, GPIO_OUT);\n  gpio_init(0x511a, GPIO_OUT);\n  gpio_init(0x2055, GPIO_OUT);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}",
            "called": [
                "gpio_set",
                "gpio_init",
                "cpu_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_cpu_and_gpio_pins_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "turn_off_rtt_000026e4"
            },
            "code": "void turn_off_rtt_000026e4(void)\n{\n  rtt_poweroff();\n  return;\n}",
            "called": [
                "rtt_poweroff"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "turn_off_rtt_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "ptr": "ptr",
                "bit": "bit",
                "DAT_00000d48": "upper_bits",
                "DAT_00000d4c": "lower_bits",
                "DAT_00000d50": "offset"
            },
            "code": "void * calculate_offset_00000d44(void *ptr, uintptr_t bit)\n{\n    uintptr_t DAT_00000d48 = (uintptr_t)ptr & 0xf0000000;\n    uintptr_t DAT_00000d4c = (uintptr_t)ptr & 0xfffff;\n    uintptr_t DAT_00000d50 = DAT_00000d48 | (DAT_00000d4c << 5) | 0x2000000;\n    return (void *)(bit * 4 + DAT_00000d50);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "bit_clear32"
            ],
            "imported": false,
            "current_name": "calculate_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "process_thread",
                "status": "new_status",
                "PTR_sched_runqueues_00000730": "sched_runqueues_ptr",
                "priority": "process_priority",
                "PTR_runqueue_bitcache_00000734": "runqueue_bitcache_ptr",
                "uint": "unsigned_int",
                "clist_node_t": "list_node_t",
                "rq_entry": "runqueue_entry"
            },
            "code": "void update_process_status_00000698(thread_t *process, uint new_status) {\n  if (new_status < 9) {\n    if ((process->status > 8) &&\n       (clist_lpop((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4)),\n       *(int *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4) == 0)) {\n      *(uint *)PTR_runqueue_bitcache_00000734 &= ~(1 << process->priority);\n    }\n  }\n  else if (process->status < 9) {\n    clist_rpush((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4),\n                &process->rq_entry);\n    *(uint *)PTR_runqueue_bitcache_00000734 |= 1 << process->priority;\n  }\n  process->status = (uint8_t)new_status;\n  return;\n}",
            "called": [
                "clist_lpop",
                "clist_rpush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "update_process_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "get_irq_interrupts_enabled_status_00000cd0",
                "uVar2": "interrupts_enabled_status",
                "bVar1": "is_privileged_mode",
                "mask": "mask",
                "result": "result"
            },
            "code": "uint32_t get_irq_interrupts_enabled_status_00000cd0(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint32_t interrupts_enabled_status = 0;\n  if (is_privileged_mode) {\n    interrupts_enabled_status = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interrupts_enabled_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "kinetis_mcg_init",
                "pm_off",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock",
                "core_panic",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "get_irq_interrupts_enabled_status_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "panic_on_dummy_handler_00000cc0",
                "PTR_s_DUMMY_HANDLER_00000ccc": "dummy_handler"
            },
            "code": "void panic_on_dummy_handler_00000cc0(void)\n{\n  /* WARNING: Subroutine does not return */\n  core_panic(PANIC_DUMMY_HANDLER, PTR_s_DUMMY_HANDLER_00000ccc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "dummy_handler"
            ],
            "imported": false,
            "current_name": "panic_on_dummy_handler_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_rtt_interrupt_and_call_callbacks_00002994",
                "iVar1": "data"
            },
            "code": "void check_rtt_interrupt_and_call_callbacks_00002994(void)\n{\n  int data = DAT_000029f8;\n  if (((*(uint *)(data + 0x14) & 4) != 0) && (*(int *)PTR_rtt_callback_000029fc != 0)) \n  {\n    *(uint *)(data + 0x1c) = *(uint *)(data + 0x1c) & 0xfffffffb;\n    (**(code **)PTR_rtt_callback_000029fc)(*(undefined4 *)(PTR_rtt_callback_000029fc + 4));\n  }\n  if (((*(uint *)(data + 0x14) & 2) != 0) && (*(int *)(PTR_rtt_callback_000029fc + 8) != 0))\n  {\n    (**(code **)(PTR_rtt_callback_000029fc + 8))(*(undefined4 *)(PTR_rtt_callback_000029fc + 0xc));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_rtt_interrupt_and_call_callbacks_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_exception_number_if_privileged_mode_00000d2a",
                "uVar2": "exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint32_t get_exception_number_if_privileged_mode_00000d2a(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  uint32_t exception_number = 0;\n  if (is_privileged_mode) {\n    exception_number = getCurrentExceptionNumber() & 0x1f;\n  }\n  return exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "sched_switch"
            ],
            "imported": false,
            "current_name": "get_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_gpio_pin_high_00001ff6",
                "pin": "gpio_pin",
                "uVar1": "pin_number",
                "pGVar2": "gpio_port",
                "pin_num": "get_pin_number",
                "gpio": "get_gpio_port",
                "PSOR": "set_output_register"
            },
            "code": "void set_gpio_pin_high_00001ff6(gpio_t pin)\n{\n  uint32_t pin_number;\n  GPIO_Type *gpio_port;\n  pin_number = get_pin_number(pin);\n  gpio_port = get_gpio_port(pin);\n  gpio_port->PSOR = 1 << (pin_number & 0xff);\n  return;\n}",
            "called": [
                "gpio",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_high_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "configure_uart_000013b8",
                "uart": "uart_num",
                "baudrate": "baud_rate",
                "rx_cb": "rx_callback",
                "arg": "callback_arg",
                "PTR_config_00001440": "config",
                "FUN_000013b8_pins": "configure_pins",
                "PTR_uart_config_00001444": "uart_config",
                "iVar1": "status"
            },
            "code": "int configure_uart_000013b8(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_callback, void *callback_arg) {\\n  int status = 0;\\n  if (uart != 0) {\\n    core_panic(PANIC_ASSERT_FAIL, assert_crash_message);\\n  }\\n  PTR_config_00001440.rx_callback = rx_callback;\\n  PTR_config_00001440.callback_arg = callback_arg;\\n  PTR_config_00001440ure_pins(0);\\n  bit_set32(*(uint32_t **)PTR_uart_PTR_config_00001440_00001444[0x18], PTR_uart_PTR_config_00001440_00001444[0x1c]);\\n  if (PTR_uart_PTR_config_00001440_00001444[0x1e] == \"\\0\") {\\n    configure_uart_000013b8(0, baudrate);\\n  } else {\\n    status = -1;\\n  }\\n  return status;\\n}",
            "called": [
                "uart_init_pins",
                "uart_init_uart",
                "core_panic",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "uart_stdio_init"
            ],
            "imported": false,
            "current_name": "configure_uart_000013b8"
        },
        "FUN_00000f80": {
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg"
            },
            "code": "void infinite_loop_00000f80(void *arg)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f80",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_00000f80"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_shell_commands_00002a88",
                "*command_list": "*shell_commands",
                "i": "command_index",
                "*entry": "*shell_command_entry"
            },
            "code": "void print_shell_commands_00002a88(shell_command_t *command_list)\n{\n  shell_command_t *command_lists[2];\n  uint32_t command_index;\n  shell_command_t *entry;\n  \n  iprintf(\"%s\\t%s\\n\", \"Command\", \"Description\");\n  puts(\"-----------------------------------------------------\");\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002b0c;\n  for (command_index = 0; command_index < 2; command_index++) {\n    entry = command_lists[command_index];\n    if (entry != (shell_command_t *)0x0) {\n      for (; entry->name != (char *)0x0; entry++) {\n        iprintf(\"%s\\t%s\\n\", entry->name, entry->desc);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "print_shell_commands_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_count",
                "dev": "current_device",
                "probe": "probe_device"
            },
            "code": "void print_saul_devices_00002f30(void)\n{\n    int device_count = 0;\n    saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n    while (current_device != (saul_reg_t *)0x0) {\n        probe_device(device_count, current_device);\n        puts(PTR_DAT_00002f70);\n        device_count++;\n        current_device = current_device->next;\n    }\n    return;\n}",
            "called": [
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_pin_value_00001e44",
                "port": "port_num",
                "pin": "pin_num",
                "ctx": "value",
                "iVar1": "pin_offset",
                "PTR_isr_map_00001ec0": "isr_map",
                "uint": "uint32_t"
            },
            "code": "void set_pin_value_00001e44(int port_num, int pin_num, int value) {\n  int pin_offset = pin_num >> 3;\n  uint32_t* pin_register = (uint32_t*)(PTR_PTR_isr_map_00001ec0_00001ec0 + (pin_offset + port_num * 4) * 4);\n  uint32_t mask = ~(0xf << ((pin_num & 7U) << 2));\n  uint32_t new_value = value << ((pin_num & 7U) << 2);\n  *pin_register = (*pin_register & mask) | new_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "set_pin_value_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_interrupt_priority_bit_00001318",
                "IRQn": "irq_num",
                "DAT_00001344": "interrupt_priority_register"
            },
            "code": "void set_interrupt_priority_bit_00001318(IRQn_Type irq_num)\n{\n    uint32_t* DAT_00001344 = (uint32_t*)(DAT_00001344 + ((uint32_t)irq_num >> 5) * 4);\n    uint32_t interrupt_priority_bit = 1 << (irq_num & 0x1fU);\n    *DAT_00001344 = interrupt_priority_bit;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "uart_init_uart"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_bit_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "N/A",
                "msp": "N/A"
            },
            "code": "void* get_main_stack_pointer_00000900()\n{\n    void* main_stack_pointer;\n    main_stack_pointer = (void*)getMainStackPointer();\n    return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "PTR___lock___sfp_recursive_mutex_0000427c": "PTR_recursive_lock"
            },
            "code": "void acquire_recursive_lock_00004274(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "print_device_info_00002fe0",
                "argc": "num_of_args",
                "argv": "args",
                "iVar1": "device_index",
                "dev_00": "device_list",
                "dev": "device",
                "num": "num",
                "PTR_s_usage___s__s__device_id__all_00003050": "usage_message",
                "PTR_DAT_00003054": "all_devices",
                "atoi": "convert_to_integer",
                "saul_reg_find_nth": "find_nth_device",
                "PTR_s_error__undefined_device_id_given_00003058": "undefined_device_error",
                "probe_all": "print_all_device_info",
                "probe": "print_device_info_for_device"
            },
            "code": "void print_device_info_00002fe0(int num_of_args, char **args) {\n    int device_index;\n    saul_reg_t *device;\n    saul_reg_t *device_list;\n\n    if (num_of_args < 3) {\n        iprintf(PTR_s_usage___s__s__device_id__all_00003050, *args, args[1]);\n    }\n    else {\n        if (strcmp(args[2], PTR_DAT_00003054) == 0) {\n            probe_all();\n        }\n        else {\n            device_index = atoi(args[2]);\n            device_list = saul_reg_find_nth(device_index);\n            if (device_list == (saul_reg_t *)0x0) {\n                puts(PTR_s_error__undefined_device_id_given_00003058);\n            }\n            else {\n                probe(device_index, device_list);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "probe_all",
                "strcmp",
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_device_info_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "extract_pin_number_00001dc0",
                "pin": "gpio_pin",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int extract_pin_number_00001dc0(gpio_t pin)\n{\n  const int PIN_MASK = 0x3F;\n  return pin & PIN_MASK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "gpio_set",
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "extract_pin_number_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "PTR_uart_stdio_isrpipe_00000e0c": "isr_pipe",
                "DAT_00000e10": "data"
            },
            "code": "void initialize_uart_00000df4(void)\n{\n  int baud_rate = 115200;\n  int uart_config = 0x1c200;\n  int PTR_uart_stdio_isrpipe_00000e0c = PTR_uart_stdio_isrpipe_00000e0c;\n  int DAT_00000e10 = DAT_00000e10;\n  uart_init(uart_config, baud_rate, DAT_00000e10, PTR_uart_stdio_isrpipe_00000e0c);\n  return;\n}",
            "called": [
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_string_and_return_zero_00002eb4",
                "argc": "argument_count",
                "argv": "arguments",
                "ps": "print_string"
            },
            "code": "int print_string_and_return_zero_00002eb4(int argument_count, char **arguments){\n  print_string();\n  return 0;\n}",
            "called": [
                "ps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_string_and_return_zero_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_date_args_0000328c",
                "**argv": "**args",
                "*time": "*time_info",
                "lVar1": "arg_long",
                "iVar2": "arg_int",
                "end": "end_ptr",
                "i": "short_i",
                "dow": "get_day_of_week"
            },
            "code": "int parse_date_args_0000328c(char **args, tm *time_info)\n{\n    long arg_long;\n    int arg_int;\n    char *end_ptr;\n    short i;\n\n    arg_long = strtol(*args, &end_ptr, 10);\n    i = (short) arg_long;\n    time_info->tm_year = i - 1900;\n\n    arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n    i = (short) arg_long;\n    time_info->tm_mon = i - 1;\n\n    arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n    i = (short) arg_long;\n    time_info->tm_mday = (int) i;\n\n    arg_long = strtol(args[1], &end_ptr, 10);\n    arg_int = (int) arg_long;\n    time_info->tm_hour = arg_int;\n\n    arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n    arg_int = (int) arg_long;\n    time_info->tm_min = arg_int;\n\n    arg_long = strtol(end_ptr + 1, &end_ptr, 10);\n    arg_int = (int) arg_long;\n    time_info->tm_sec = arg_int;\n\n    int day_of_week = get_day_of_week(time_info->tm_year + 1900, time_info->tm_mon + 1, time_info->tm_mday);\n    time_info->tm_wday = day_of_week;\n    time_info->tm_isdst = -1;\n    return 0;\n}",
            "called": [
                "dow",
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "_rtc_setalarm",
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "parse_date_args_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "*param_1": "data[0]",
                "param_1[1]": "data[1]",
                "param_1[2]": "data[2]",
                "*(undefined2 *)(param_1 + 3)": "data[3]",
                "param_1[4]": "data[4]",
                "param_1[5]": "data[5]",
                "param_1[6]": "data[6]",
                "memset(param_1 + 0x17,0,8)": "memset(data + 7, 0, 8)",
                "param_1[9]": "data[9]",
                "param_1[10]": "data[10]",
                "param_1[0xb]": "data[11]",
                "param_1[8]": "data[8]",
                "param_1[0xc]": "data[12]"
            },
            "code": "void initialize_data_000041f4(undefined4 *data, undefined2 value1, undefined2 value2)\n{\n  data[0] = 0;\n  data[1] = 0;\n  data[2] = 0;\n  data[3] = value1;\n  data[4] = 0;\n  data[5] = value2;\n  data[6] = 0;\n  memset(data + 7, 0, 8);\n  data[9] = DAT_0000422c;\n  data[10] = DAT_00004230;\n  data[11] = DAT_00004234;\n  data[8] = data;\n  data[12] = DAT_00004238;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "execute_command_0000316c",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "comparison_result",
                "PTR_DAT_000031d4": "file_read_pointer",
                "PTR_s_write_000031d8": "file_write_pointer",
                "PTR_s_usage___s_read_write_000031dc": "usage_string",
                "list": "list_commands",
                "read": "read_file",
                "write": "write_file",
                "*argv": "argument_zero"
            },
            "code": "int execute_command_0000316c(int argc, char **argv)\n{\n    int comparison_result;\n\n    if (argc < 2)\n    {\n        list_commands();\n    }\n    else\n    {\n        comparison_result = strcmp(argv[1], PTR_DAT_000031d4);\n        if (comparison_result == 0)\n        {\n            read_file(argc, argv);\n        }\n        else\n        {\n            comparison_result = strcmp(argv[1], PTR_s_write_000031d8);\n            if (comparison_result == 0)\n            {\n                write_file(argc, argv);\n            }\n            else\n            {\n                print_usage_and_exit(PTR_s_usage___s_read_write_000031dc, *argv);\n            }\n        }\n    }\n\n    return 0;\n}",
            "called": [
                "read",
                "iprintf",
                "strcmp",
                "write",
                "list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "execute_command_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "call_rtc_callback_000026f0",
                "arg": "arg",
                "PTR_rtc_callback_00002710": "PTR_rtc_callback_00002710",
                "rtc_callback_ptr": "rtc_callback_ptr",
                "rtc_callback": "rtc_callback"
            },
            "code": "void call_rtc_callback_000026f0(void *arg)\n{\n  int *rtc_callback_ptr = (int *)PTR_rtc_callback_00002710;\n  if (*rtc_callback_ptr != 0) {\n    code *rtc_callback = *(code **)rtc_callback_ptr;\n    (*rtc_callback)(arg);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "call_rtc_callback_000026f0"
        },
        "FUN_0000510c": {
            "renaming": {
                "FUN_0000510c": "FUNC_0000510c"
            },
            "code": "\nvoid FUNC_0000510c(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  char *pcVar5;\n  void *__ptr;\n  size_t sVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  char cVar11;\n  bool bVar12;\n  ushort *puVar13;\n  int *piVar14;\n  ushort *puVar15;\n  int *piVar16;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar4 = __gettzinfo();\n  puVar1 = PTR_prev_tzenv_000053d8;\n  pcVar5 = (char *)_getenv_r(param_1,PTR_DAT_000053d4);\n  puVar2 = PTR_LAB_00007a5e_1_000053e0;\n  if (pcVar5 == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    puVar3 = PTR__tzname_000053e8;\n    __ptr = *(void **)puVar1;\n    *(undefined **)PTR__tzname_000053e8 = puVar2;\n    *(undefined **)(puVar3 + 4) = puVar2;\n    free(__ptr);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(char **)puVar1 == (char *)0x0) ||\n          (iVar8 = strcmp(pcVar5,*(char **)puVar1), iVar8 != 0)) {\n    free(*(void **)puVar1);\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)_malloc_r(param_1,sVar6 + 1);\n    *(char **)puVar1 = pcVar7;\n    if (pcVar7 != (char *)0x0) {\n      strcpy(pcVar7,pcVar5);\n    }\n    if (*pcVar5 == ':') {\n      pcVar5 = pcVar5 + 1;\n    }\n    iVar8 = siscanf(pcVar5,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&local_30);\n    if (0 < iVar8) {\n      pcVar7 = pcVar5 + local_30;\n      if (pcVar5[local_30] == '-') {\n        pcVar7 = pcVar7 + 1;\n        iVar8 = -1;\n      }\n      else {\n        if (pcVar5[local_30] == '+') {\n          pcVar7 = pcVar7 + 1;\n        }\n        iVar8 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar13 = &local_3a;\n      piVar14 = &local_30;\n      puVar15 = &local_38;\n      piVar16 = &local_30;\n      iVar9 = siscanf(pcVar7,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                      &local_30,&local_38,&local_30);\n      puVar1 = PTR___tzname_dst_00005400;\n      if (0 < iVar9) {\n        *(uint *)(iVar4 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n        puVar2 = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        pcVar7 = pcVar7 + local_30;\n        iVar8 = siscanf(pcVar7,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar13,piVar14,\n                        puVar15,piVar16);\n        if (iVar8 < 1) {\n          *(undefined4 *)(puVar2 + 4) = *(undefined4 *)puVar2;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(iVar4 + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(puVar2 + 4) = puVar1;\n          pcVar5 = pcVar7 + local_30;\n          if (pcVar7[local_30] == '-') {\n            pcVar5 = pcVar5 + 1;\n            iVar8 = -1;\n          }\n          else {\n            if (pcVar7[local_30] == '+') {\n              pcVar5 = pcVar5 + 1;\n            }\n            iVar8 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar9 = siscanf(pcVar5,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                          &local_30,&local_38,&local_30);\n          if (iVar9 < 1) {\n            iVar8 = *(int *)(iVar4 + 0x28) + -0xe10;\n          }\n          else {\n            iVar8 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n          }\n          *(int *)(iVar4 + 0x50) = iVar8;\n          pcVar5 = pcVar5 + local_30;\n          bVar12 = false;\n          iVar8 = iVar4;\n          while( true ) {\n            if (*pcVar5 == ',') {\n              pcVar5 = pcVar5 + 1;\n            }\n            cVar11 = *pcVar5;\n            if (cVar11 == 'M') {\n              iVar9 = siscanf(pcVar5,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,&local_34\n                              ,&local_30,&local_32,&local_30);\n              if (iVar9 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar8 + 0xc) = (uint)local_36;\n              *(uint *)(iVar8 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar8 + 8) = 0x4d;\n              *(uint *)(iVar8 + 0x14) = (uint)local_32;\n              pcVar7 = pcVar5 + local_30;\n            }\n            else {\n              if (cVar11 == 'J') {\n                pcVar5 = pcVar5 + 1;\n              }\n              else {\n                cVar11 = 'D';\n              }\n              uVar10 = strtoul(pcVar5,local_2c,10);\n              local_32 = (ushort)uVar10;\n              pcVar7 = local_2c[0];\n              if (local_2c[0] == pcVar5) {\n                if (bVar12) {\n                  *(undefined *)(iVar4 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar4 + 0x38) = 1;\n                  *(undefined4 *)(iVar4 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar4 + 8) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0xc) = 3;\n                  *(undefined4 *)(iVar4 + 0x10) = 2;\n                  *(undefined4 *)(iVar4 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar8 + 8) = cVar11;\n                *(ulong *)(iVar8 + 0x14) = uVar10 & 0xffff;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar7 == '/') {\n              siscanf(pcVar7,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,&local_38,\n                      &local_30);\n            }\n            *(uint *)(iVar8 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar8 = iVar8 + 0x28;\n            pcVar5 = pcVar7 + local_30;\n            if (bVar12) break;\n            bVar12 = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar4 + 4));\n          iVar8 = *(int *)(iVar4 + 0x28);\n          *(int *)PTR__timezone_000053dc = iVar8;\n          iVar8 = *(int *)(iVar4 + 0x50) - iVar8;\n          if (iVar8 != 0) {\n            iVar8 = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = iVar8;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tzcalc_limits",
                "_getenv_r",
                "strcpy",
                "siscanf",
                "strlen",
                "strcmp",
                "free",
                "_malloc_r",
                "strtoul"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000510c",
            "calling": [
                "_tzset_unlocked"
            ],
            "imported": false,
            "current_name": "FUNC_0000510c"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "write_string_to_stream_000057d2",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "string",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end_of_string",
                "iVar3": "current_length"
            },
            "code": "int write_string_to_stream_000057d2(int stream, int character, void *string, int length) {\n  int result;\n  void *end_of_string;\n  int current_length;\n  end_of_string = string + length;\n  current_length = length;\n  do {\n    if (string == end_of_string) {\n      return 0;\n    }\n    result = __sfputc_r(stream, *string, character, length, current_length);\n    length = result + 1;\n    string = string + 1;\n  } while (length != 0);\n  return result;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "write_string_to_stream_000057d2"
        },
        "FUN_00000958": {
            "renaming": {
                "FUN_00000958": "run_task_00000958",
                "bVar1": "is_privileged_mode",
                "iVar2": "process_stack_pointer",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "unaff_r4": "arg4",
                "unaff_r5": "arg5",
                "unaff_r6": "arg6",
                "unaff_r7": "arg7",
                "unaff_r8": "arg8",
                "unaff_r9": "arg9",
                "unaff_r10": "arg10",
                "unaff_r11": "arg11",
                "in_lr": "in_lr",
                "ppcVar3": "active_thread_pointer"
            },
            "code": "void run_task_00000958(void)\n{\n    bool is_privileged_mode;\n    int process_stack_pointer;\n    code *jump_table;\n    code **active_thread_pointer;\n    undefined4 arg4;\n    undefined4 arg5;\n    undefined4 arg6;\n    undefined4 arg7;\n    undefined4 arg8;\n    undefined4 arg9;\n    undefined4 arg10;\n    undefined4 arg11;\n    undefined4 in_lr;\n\n    process_stack_pointer = getProcessStackPointer();\n    *(undefined4 *)(process_stack_pointer + -4) = arg11;\n    *(undefined4 *)(process_stack_pointer + -8) = arg10;\n    *(undefined4 *)(process_stack_pointer + -0xc) = arg9;\n    *(undefined4 *)(process_stack_pointer + -0x10) = arg8;\n    *(undefined4 *)(process_stack_pointer + -0x14) = arg7;\n    *(undefined4 *)(process_stack_pointer + -0x18) = arg6;\n    *(undefined4 *)(process_stack_pointer + -0x1c) = arg5;\n    *(undefined4 *)(process_stack_pointer + -0x20) = arg4;\n    *(undefined4 *)(process_stack_pointer + -0x24) = in_lr;\n    **(int **)PTR_sched_active_thread_00000970 = (int)(undefined4 *)(process_stack_pointer + -0x24);\n\n    isr_svc();\n    sched_run();\n\n    jump_table = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n    active_thread_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n    is_privileged_mode = (bool)isCurrentModePrivileged();\n    if (is_privileged_mode) {\n        setProcessStackPointer(active_thread_pointer);\n    }\n\n    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n    /* WARNING: Treating indirect jump as call */\n    (*jump_table)(jump_table,active_thread_pointer);\n    return;\n}",
            "called": [
                "isr_svc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000958",
            "calling": [],
            "imported": false,
            "current_name": "run_task_00000958"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_file_type_000056b8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "file_type",
                "param_4": "error_code",
                "iVar1": "status",
                "uVar2": "type",
                "sStack_68": "file_stats"
            },
            "code": "int check_file_type_000056b8(_reent *reent, int file_descriptor, uint32_t *file_type, uint32_t *error_code) {\n  int status;\n  uint32_t type;\n  struct stat file_stats;\n\n  if (*(short *)(file_descriptor + 0xe) < 0 || _fstat_r(reent, (int)*(short *)(file_descriptor + 0xe), &file_stats) < 0) {\n    *error_code = 0;\n    if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x18) < 0) {\n      type = 0x40;\n      goto exit;\n    }\n  } else {\n    type = (uint32_t)((file_stats.st_mode & 0xf000) == 0x2000);\n  }\n\n  type = 0x400;\n\nexit:\n  *file_type = type;\n  return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_type_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_bit_and_disable_pll_00001a18",
                "DAT_00001a34": "bitfield",
                "kinetis_mcg_disable_pll": "disable_pll",
                "PTR_current_mode_00001a38": "current_mode"
            },
            "code": "void set_bit_and_disable_pll_00001a18(void)\n{\n  set_bit(DAT_00001a34, 0x01);\n  disable_pll();\n  *PTR_current_mode_00001a38 = 4;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_bit_and_disable_pll_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_null_terminator_00000d9c",
                "DAT_00000dac": "data_ptr"
            },
            "code": "void clear_null_terminator_00000d9c(void)\n{\n  bit_clear32(DAT_00000dac, '\\0');\n  return;\n}",
            "called": [
                "bit_clear32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "clear_null_terminator_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "desired_length",
                "pad_char": "padding_character",
                "sVar1": "padded_length",
                "n": "not_used"
            },
            "code": "size_t pad_string_00003ff4(char* output, size_t input_length, size_t desired_length, char padding_character)\n{\n  size_t padded_length;\n  if ((input_length < desired_length) && (output != (char*)0x0)) {\n    memmove(output + (desired_length - input_length), output, input_length);\n    memset(output, (uint)(byte)padding_character, desired_length - input_length);\n  }\n  padded_length = input_length;\n  return padded_length;\n}",
            "called": [
                "memset",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "pad_string_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    div((int)&local_20,*param_1);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    div((int)&local_20,param_1[1]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    div((int)&local_20,param_1[2]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    div((int)&local_20,param_1[4]);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAYS_IN_MONTH_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "div"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_port_type_00001d5e",
                "pin": "gpio_t pin",
                "PTR_PORT_Type": "PORT_Type*",
                "DAT_00000008": "const int PIN_OFFSET",
                "DAT_0000000c": "const int PIN_MASK"
            },
            "code": "PTR_PORT_Type get_port_type_00001d5e(gpio_t pin) {\n    DAT_00000008 = 0x40048000;\n    DAT_0000000c = 0x7000;\n    return (PTR_PORT_Type)((pin & PIN_MASK) | PIN_OFFSET);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_port_type_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "initialize_clock_0000191c",
                "DAT_00001958": "clock_gate_control_register",
                "PTR_current_mode_0000195c": "current_mode_pointer"
            },
            "code": "void initialize_clock_0000191c(void)\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((DAT_00001958[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c = 1;\n  return;\n}",
            "called": [
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_clock_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "release_time_zone_mutex_000050f4"
            },
            "code": "void release_time_zone_mutex_000050f4(void)\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}",
            "called": [
                "__retarget_lock_release"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "release_time_zone_mutex_000050f4"
        },
        "FUN_00000c80": {
            "renaming": {
                "FUN_00000c80": "handle_memory_management_error_00000c80",
                "PANIC_MEM_MANAGE": "panic_memory_management",
                "PTR_s_MEM_MANAGE_HANDLER_00000c8c": "mem_manage_handler"
            },
            "code": "void handle_memory_management_error_00000c80(void)\n{\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_MEM_MANAGE, PTR_s_MEM_MANAGE_HANDLER_00000c8c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c80",
            "calling": [],
            "imported": false,
            "current_name": "handle_memory_management_error_00000c80"
        },
        "FUN_00000a40": {
            "renaming": {
                "FUN_00000a40": "calculate_required_stack_size_00000a40",
                "required": "required_size",
                "auStack_18": "stack_buffer",
                "sp": "stack_pointer"
            },
            "code": "int calculate_required_stack_size_00000a40(uint32_t required_size)\n{\n  undefined stack_buffer[12];\n  uint32_t *stack_pointer;\n  \n  stack_pointer = &stack_buffer;\n  return (int)(stack_pointer + (-(int)PTR_isr_stack_00000a60 - required_size));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a40",
            "calling": [
                "hard_fault_handler"
            ],
            "imported": false,
            "current_name": "calculate_required_stack_size_00000a40"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "process_data_00005a58",
                "param_1": "data_start",
                "param_2": "data",
                "param_3": "data_end",
                "param_4": "data_len",
                "param_5": "callback",
                "iVar1": "callback_res",
                "uVar2": "result",
                "uVar3": "max_data_len",
                "uVar4": "data_len_remaining",
                "bVar5": "is_offset_4",
                "data_offset": "data_offset",
                "LAB_00005afc": "error_handling",
                "byte": "byte_value",
                "undefined": "undefined_value"
            },
            "code": "undefined4 process_data_00005a58(undefined4 data_start, uint *data, uint *data_end, undefined4 data_len, code *callback)\n{\n  int callback_res;\n  undefined4 result;\n  uint max_data_len = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    max_data_len = data[2];\n  }\n  *data_end = max_data_len;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *data_end = max_data_len + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *data_end = *data_end + 2;\n  }\n  uint data_offset = *data & 6;\n  if (data_offset == 0) {\n    for (; (int)data_offset < (int)(data[3] - *data_end); data_offset++) {\n      callback_res = (*callback)(data_start, data_len, (int)data + 0x19, 1);\n      if (callback_res == -1) goto LAB_00005afc;\n    }\n  }\n  data_offset = (uint)*(byte *)((int)data + 0x43);\n  if (data_offset != 0) {\n    data_offset = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + data_offset + 0x43) = 0x30;\n    *(undefined *)((int)data + data_offset + 0x44) = *(undefined *)((int)data + 0x45);\n    data_offset += 2;\n  }\n  callback_res = (*callback)(data_start, data_len, (int)data + 0x43, data_offset);\n  if (callback_res == -1) {\n    result = 0xffffffff;\n  }\n  else {\n    uint data_len_remaining = data[3];\n    bool is_offset_4 = (*data & 6) == 4;\n    if (is_offset_4) {\n      data_len_remaining = data_len_remaining - *data_end;\n    }\n    if (is_offset_4) {\n      data_len_remaining = data_len_remaining & ~((int)data_len_remaining >> 0x1f);\n    }\n    else {\n      data_len_remaining = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      data_len_remaining += (data[2] - data[4]);\n    }\n    for (uint i = 0; data_len_remaining != i; i++) {\n      callback_res = (*callback)(data_start, data_len, (int)data + 0x1a, 1);\n      if (callback_res == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "process_data_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_timezone_info_000056b0",
                "PTR_tzinfo_000056b4": "timezone_info_ptr"
            },
            "code": "char* get_timezone_info_000056b0() {\n  return PTR_tzinfo_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "get_timezone_info_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "i": "current_position",
                "tmp": "current_saul_reg"
            },
            "code": "saul_reg_t* get_saul_reg_at_position_00003d24(int position)\n{\n    int current_position = 0;\n    saul_reg_t* current_saul_reg = *(saul_reg_t**)PTR_saul_reg_00003d60;\n    \n    while (current_position < position && current_saul_reg != (saul_reg_t*)0x0)\n    {\n        current_saul_reg = current_saul_reg->next;\n        current_position++;\n    }\n    \n    return current_saul_reg;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "get_saul_reg_at_position_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_memory_block_000060cc",
                "param_1": "block_size",
                "param_2": "existing_block",
                "param_3": "existing_block_size",
                "param_4": "zero_block",
                "pvVar1": "new_block",
                "pvVar2": "usable_memory_size"
            },
            "code": "void * allocate_memory_block_000060cc(size_t block_size, void *existing_block, size_t existing_block_size, int zero_block)\n{\n  void *new_block;\n  void *usable_memory_size;\n  if (existing_block != NULL) {\n    if (existing_block_size == 0) {\n      free(existing_block);\n      new_block = NULL;\n    }\n    else {\n      usable_memory_size = malloc_usable_size(existing_block);\n      new_block = existing_block;\n      if ((usable_memory_size < existing_block_size) && (new_block = malloc(block_size), new_block != NULL)) {\n        memcpy(new_block, existing_block, existing_block_size);\n        free(existing_block);\n      }\n    }\n    return new_block;\n  }\n  new_block = malloc(block_size);\n  if (zero_block) {\n    memset(new_block, 0, block_size);\n  }\n  return new_block;\n}",
            "called": [
                "_free_r",
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "__submore"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_000060cc"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ring_buffer",
                "c": "data",
                "uVar1": "writes"
            },
            "code": "void write_to_ring_buffer_000022be(tsrb_t *ring_buffer, char data) {\n  uint32_t writes = ring_buffer->writes;\n  ring_buffer->writes = writes + 1;\n  ring_buffer->buf[writes & (ring_buffer->size - 1)] = data;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "write_to_ring_buffer_000022be"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_num_digits_00003dc4",
                "out": "output",
                "val": "value",
                "local_20": "temp_value",
                "ptr": "output_ptr",
                "tmp": "temp_value",
                "len": "num_digits"
            },
            "code": "size_t calculate_num_digits_00003dc4(char *output, uint32_t value) {\n    uint32_t temp_value;\n    char *output_ptr;\n    size_t num_digits;\n    num_digits = 1;\n    if (DAT_00003e50 < value) {\n        num_digits = 10;\n    } else {\n        for (temp_value = 10; temp_value <= value; temp_value = temp_value * 10) {\n            num_digits = num_digits + 1;\n        }\n    }\n    if (output != (char *)0x0) {\n        output_ptr = output + num_digits;\n        temp_value = value;\n        do {\n            output_ptr = output_ptr + -1;\n            *output_ptr = (char)temp_value + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)temp_value >> 0x23) * -10 + '0';\n            temp_value = (uint32_t)((ulonglong)DAT_00003e54 * (ulonglong)temp_value >> 0x23);\n        } while (temp_value != 0);\n    }\n    return num_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "fmt_s32_dec"
            ],
            "imported": false,
            "current_name": "calculate_num_digits_00003dc4"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "handle_interrupt_00002108",
                "DAT_00002118": "interrupt_data_ptr"
            },
            "code": "void handle_interrupt_00002108(void)\n{\n  irq_handler(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_00002108"
        },
        "FUN_00000c90": {
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PTR_s_BUS_FAULT_HANDLER_00000c9c": "bus_fault_handler"
            },
            "code": "void handle_bus_fault_00000c90(void)\n{\n    core_panic(PANIC_BUS_FAULT, PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c90",
            "calling": [],
            "imported": false,
            "current_name": "handle_bus_fault_00000c90"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "get_GPIO_type_from_pin_00001d80",
                "pin": "GPIO_pin_t",
                "PTR_00000014": "GPIO_Type*",
                "DAT_00000018": "uint32_t",
                "DAT_0000001c": "uint32_t",
                "DAT_00000020": "uint32_t",
                "masked_pin": "uint32_t",
                "address": "uint32_t"
            },
            "code": "PTR_00000014 get_GPIO_type_from_pin_00001d80(GPIO_pin_t pin) {\n    DAT_00000018 mask = 0x1C0;\n    DAT_00000018 offset = 0x400FF000;\n    DAT_00000018 masked_pin = pin & mask;\n    DAT_00000018 address = masked_pin | offset;\n    return (PTR_00000014) address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_type_from_pin_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "get_rtc_alarm_status_000033c0",
                "iVar1": "status",
                "t": "current_time",
                "rtc_get_alarm": "get_alarm_from_rtc",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_alarm_status_000033c0(void)\n{\n    int status;\n    tm current_time;\n\n    status = rtc_get_alarm(&current_time);\n    if (status != 0) {\n        puts(PTR_s_rtc__error_getting_alarm_000033f0);\n    }\n    else {\n        print_current_time(&current_time);\n    }\n    return (uint)(status != 0);\n}",
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "parse_shell_command": "parse_shell_command",
                "command_list": "command_list",
                "line": "command_line",
                "local_48": "arg_pos",
                "local_44": "command",
                "handler": "handler",
                "argv": "args",
                "local_34": "arg_count",
                "quote_char": "quote_char",
                "d": "d",
                "c": "c",
                "arg": "arg",
                "i": "i",
                "contains_esc_seq": "contains_esc_seq",
                "argc": "arg_count",
                "pos": "arg_pos",
                "FUN_00002b10": "parse_shell_command_00002b10"
            },
            "code": "void parse_shell_command_00002b10(shell_command_t *command_list, char *command_line) {\n  int arg_count = 0;\n  char *arg_pos = command_line;\n  char quote_char;\n  int contains_esc_seq = 0;\n  char **args;\n  shell_command_t *command;\n  shell_command_handler_t handler;\n  uint i;\n\n  while (*arg_pos != \"\\0\") {\n    if (*arg_pos > 0x20) {\n      if ((*arg_pos == \"\\\"\") || (*arg_pos == \"\\\"\")) {\n        quote_char = *arg_pos;\n        do {\n          arg_pos++;\n          if (*arg_pos == \"\\0\") {\n            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n            return;\n          }\n          if (*arg_pos == \"\\\") {\n            contains_esc_seq++;\n            arg_pos++;\n            if (*arg_pos == \"\\0\") {\n              puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n              return;\n            }\n          }\n        } while (quote_char != *arg_pos);\n        if (*(arg_pos + 1) > 0x20) {\n          puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n          return;\n        }\n      }\n      else {\n        do {\n          if (*arg_pos == \"\\\") {\n            contains_esc_seq++;\n            arg_pos++;\n            if (*arg_pos == \"\\0\") {\n              puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n              return;\n            }\n          }\n          arg_pos++;\n          if (*arg_pos == 0x22) {\n            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n            return;\n          }\n        } while (*arg_pos > 0x20);\n      }\n      arg_count++;\n    }\n    *arg_pos = \"\\0\";\n    arg_pos++;\n  }\n\n  if (arg_count != 0) {\n    args = (char **)malloc((arg_count + 1) * sizeof(char *));\n    args[arg_count] = NULL;\n    arg_pos = command_line;\n    for (i = 0; i < arg_count; i++) {\n      while (*arg_pos == \"\\0\") {\n        arg_pos++;\n      }\n      if ((*arg_pos == \"\\\"\") || (*arg_pos == \"\\\"\")) {\n        arg_pos++;\n      }\n      args[i] = arg_pos;\n      while (*arg_pos != \"\\0\") {\n        arg_pos++;\n      }\n    }\n\n    for (char **arg = args; (contains_esc_seq != 0 && (*arg != NULL)); arg++) {\n      for (char *c = *arg; *c != \"\\0\"; c++) {\n        if (*c == \"\\\") {\n          for (char *d = c; *d != \"\\0\"; d++) {\n            *d = *(d + 1);\n          }\n          contains_esc_seq--;\n          if (contains_esc_seq == 0) break;\n        }\n      }\n    }\n\n    command = command_list;\n    handler = find_handler(command_list, args[0]);\n    if (handler == NULL) {\n      if (strcmp(PTR_DAT_00002d8c, args[0]) == 0) {\n        print_help(command_list);\n      } else {\n        iprintf(PTR_s_shell__command_not_found___s_00002d90, args[0]);\n      }\n    } else {\n      (*handler)(arg_count, args);\n    }\n\n    free(args);\n  }\n}",
            "called": [
                "iprintf",
                "find_handler",
                "print_help",
                "strcmp",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "parse_shell_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "set_kinetis_mcg_mode_00001b10",
                "mode": "requested_mode",
                "*PTR_current_mode_00001bb0": "current_mode_ptr",
                "PTR_mcg_mode_routing_00001bb4": "mcg_mode_routing_ptr",
                "KINETIS_MCG_MODE_NUMOF": "NUM_KINETIS_MCG_MODES",
                "DAT_00001bb8": "result"
            },
            "code": "int set_kinetis_mcg_mode_00001b10(kinetis_mcg_mode_t mode) {\n  int DAT_00001bb8 = -1;\n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      uint8_t index = (uint)mode + (uint)(**PTR_current_mode_00001bb0) * 8;\n      switch(PTR_mcg_mode_routing_00001bb4[index])\n      {\n        case KINETIS_MCG_MODE_FEI:\n          kinetis_mcg_set_fei();\n          break;\n        case KINETIS_MCG_MODE_FEE:\n          kinetis_mcg_set_fee();\n          break;\n        case KINETIS_MCG_MODE_FBI:\n          kinetis_mcg_set_fbi();\n          break;\n        case KINETIS_MCG_MODE_FBE:\n          kinetis_mcg_set_fbe();\n          break;\n        case KINETIS_MCG_MODE_BLPI:\n          kinetis_mcg_set_blpi();\n          break;\n        case KINETIS_MCG_MODE_BLPE:\n          kinetis_mcg_set_blpe();\n          break;\n        case KINETIS_MCG_MODE_PBE:\n          kinetis_mcg_set_pbe();\n          break;\n        case KINETIS_MCG_MODE_PEE:\n          kinetis_mcg_set_pee();\n          break;\n        default:\n          return -1;\n      }\n    } while (mode != **PTR_current_mode_00001bb0);\n    DAT_00001bb8 = 0;\n  }\n  return DAT_00001bb8;\n}",
            "called": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_mode_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t FUNC_000047e4(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 = (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 = __tp->tm_year;\n  iVar10 = __tp->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + __tp->tm_mon * 4);\n  if (((1 < __tp->tm_mon) && ((uVar11 & 3) == 0)) &&\n     ((uVar11 != (uVar11 / 100) * 100 || (uVar11 + 0x76c == ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 = iVar10 + 1;\n  }\n  __tp->tm_yday = iVar10;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 < 0x47) {\n    if (uVar11 != 0x46) {\n      for (uVar8 = 0x45; (int)uVar11 < (int)uVar8; uVar8 = uVar8 - 1) {\n        if ((uVar8 & 3) == 0) {\n          if (uVar8 == (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 == 0) {\n              iVar6 = 0x16e;\n            }\n            else {\n              iVar6 = 0x16d;\n            }\n          }\n          else {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16d;\n        }\n        iVar10 = iVar10 - iVar6;\n      }\n      if ((uVar8 & 3) == 0) {\n        if (uVar11 == (uVar11 / 100) * 100) {\n          iVar6 = 0x16d;\n          if ((uVar11 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      iVar10 = iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 = 0x46;\n    do {\n      if ((uVar8 & 3) == 0) {\n        if (uVar8 % 100 == 0) {\n          if ((uVar8 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n          else {\n            iVar6 = 0x16d;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      uVar8 = uVar8 + 1;\n      iVar10 = iVar10 + iVar6;\n    } while (uVar11 != uVar8);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar10 +\n          (longlong)(__tp->tm_hour * 0xe10 + __tp->tm_min * 0x3c + __tp->tm_sec);\n  uVar14 = (uint)lVar1;\n  iVar6 = (int)((ulonglong)lVar1 >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 = __tp->tm_isdst;\n    uVar12 = uVar13;\n    if (0 < (int)uVar13) {\n      uVar12 = 1;\n    }\n    if ((piVar2[1] == __tp->tm_year + 0x76c) || (iVar4 = __tzcalc_limits(), iVar4 != 0)) {\n      uVar9 = piVar2[0x14];\n      uVar3 = piVar2[0x12];\n      uVar7 = piVar2[10];\n      uVar8 = uVar3 - uVar7;\n      iVar4 = (piVar2[0x13] - ((int)uVar7 >> 0x1f)) - (uint)(uVar3 < uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n           (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8)))) &&\n         (iVar5 = (piVar2[0x13] - ((int)uVar9 >> 0x1f)) - (uint)(uVar3 < uVar9),\n         bVar16 = uVar14 < uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 = piVar2[8] - uVar9;\n      iVar5 = (piVar2[9] - ((int)uVar9 >> 0x1f)) - (uint)((uint)piVar2[8] < uVar9);\n      if (*piVar2 != 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 ==\n            (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 = 0;\n        if ((int)uVar13 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 = uVar12 ^ uVar8;\n        uVar12 = uVar8;\n        if (uVar13 == 1) {\n          if (uVar8 == 0) {\n            iVar6 = uVar9 - uVar7;\n          }\n          else {\n            iVar6 = uVar7 - uVar9;\n          }\n          iVar4 = __tp->tm_mday;\n          uVar14 = uVar14 + iVar6;\n          __tp->tm_sec = __tp->tm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 = __tp->tm_mday - iVar4;\n          if (iVar4 != 0) {\n            if (iVar4 < 2) {\n              if (iVar4 == -2 || iVar4 + 2 < 0 != SCARRY4(iVar4,2)) {\n                iVar4 = 1;\n              }\n            }\n            else {\n              iVar4 = -1;\n            }\n            iVar6 = iVar4 + __tp->tm_yday;\n            iVar10 = iVar10 + iVar4;\n            if (iVar6 < 0) {\n              uVar8 = uVar11 - 1;\n              if ((uVar8 & 3) == 0) {\n                if (uVar8 == (uVar8 / 100) * 100) {\n                  iVar6 = 0x16d;\n                  if ((uVar11 + 0x76b) % 400 != 0) {\n                    iVar6 = 0x16c;\n                  }\n                }\n                else {\n                  iVar6 = 0x16d;\n                }\n              }\n              else {\n                iVar6 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 & 3) == 0) {\n                if (uVar11 == (uVar11 / 100) * 100) {\n                  iVar4 = 0x16d;\n                  if ((uVar11 + 0x76c) % 400 == 0) {\n                    iVar4 = 0x16e;\n                  }\n                }\n                else {\n                  iVar4 = 0x16e;\n                }\n              }\n              else {\n                iVar4 = 0x16d;\n              }\n              if (iVar4 <= iVar6) {\n                iVar6 = iVar6 - iVar4;\n              }\n            }\n            __tp->tm_yday = iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 !=\n          (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n            (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar13) {\n        uVar8 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 = uVar12;\n      if (uVar12 != 1) goto LAB_00004934;\n    }\n    tVar15 = uVar14 + piVar2[0x14];\n    uVar8 = 1;\n  }\n  __tz_unlock();\n  __tp->tm_isdst = uVar8;\n  __tp->tm_wday = (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits",
                "validate_structure",
                "__tz_lock",
                "_tzset_unlocked"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "rtc_set_time",
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "software_interrupt_handler_000023c8",
                "a0": "interrupt_num",
                "a1": "return_value",
                "a2": "error_code"
            },
            "code": "uint32_t software_interrupt_handler_000023c8(uint32_t interrupt_num, uint32_t return_value, int32_t error_code)\n{\n  software_interrupt(interrupt_num);\n  return return_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "software_interrupt_handler_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_greater_than_space_00002e48",
                "PTR__impure_ptr_00002e68": "PTR__impure_ptr",
                "DAT_00000004": "greater_than",
                "DAT_00000005": "space"
            },
            "code": "void print_greater_than_space_00002e48(void)\n{\n  char DAT_00000004 = '>';\n  char DAT_00000005 = ' ';\n  FILE** impure_ptr = *(FILE **)(*(int *)PTR__impure_ptr_00002e68_00002e68 + 8);\n  _putchar(DAT_00000004);\n  _putchar(DAT_00000005);\n  fflush(impure_ptr);\n  return;\n}",
            "called": [
                "_putchar",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "print_greater_than_space_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "enable_interrupt_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_irq",
                "software_interrupt": "trigger_software_interrupt"
            },
            "code": "void enable_interrupt_and_trigger_software_interrupt_00000930(void)\n{\n  enable_irq();\n  trigger_software_interrupt(1);\n  while( true ) {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "irq_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "sched_task_exit",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "enable_interrupt_and_trigger_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_for_context_switch_request_00001348",
                "PTR_sched_context_switch_request_0000135c": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00001348(void)\n{\n  int* PTR_sched_context_switch_request_0000135c = (int*) PTR_sched_PTR_sched_context_switch_request_0000135c_0000135c;\n  if (*PTR_sched_context_switch_request_0000135c != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "irq_handler_uart"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001348"
        },
        "FUN_00006118": {
            "renaming": {
                "FUN_00006118": "FUNC_00006118"
            },
            "code": "\nuint FUNC_00006118(undefined4 param_1,uint param_2,uint *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  if (param_2 == 0xffffffff) {\nLAB_00006120:\n    param_2 = 0xffffffff;\n  }\n  else {\n    *(ushort *)(param_3 + 3) = *(ushort *)(param_3 + 3) & 0xffdf;\n    uVar2 = param_3[1];\n    param_2 = param_2 & 0xff;\n    if (param_3[0xd] == 0) {\n      uVar3 = *param_3;\n      if (((param_3[4] != 0) && (param_3[4] < uVar3)) && (*(byte *)(uVar3 - 1) == param_2)) {\n        *param_3 = uVar3 - 1;\n        param_3[1] = uVar2 + 1;\n        return param_2;\n      }\n      param_3[0xf] = uVar3;\n      param_3[0x10] = uVar2;\n      param_3[0xd] = (uint)(param_3 + 0x11);\n      param_3[0xe] = 3;\n      *(undefined *)((int)param_3 + 0x46) = (char)param_2;\n      *param_3 = (uint)(undefined *)((int)param_3 + 0x46);\n      uVar2 = 1;\n    }\n    else {\n      if (((int)param_3[0xe] <= (int)uVar2) &&\n         (iVar1 = __submore(param_1,param_3,uVar2,param_3[0xe],param_4), iVar1 != 0))\n      goto LAB_00006120;\n      uVar2 = *param_3;\n      *param_3 = uVar2 - 1;\n      *(char *)(uVar2 - 1) = (char)param_2;\n      uVar2 = param_3[1] + 1;\n    }\n    param_3[1] = uVar2;\n  }\n  return param_2;\n}\n\n",
            "called": [
                "__submore"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006118",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00006118"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_bit_in_uint32_array_00001d3a",
                "*ptr": "*array",
                "bit": "bit_index",
                "puVar1": "*bit_address"
            },
            "code": "void set_bit_in_uint32_array_00001d3a(uint32_t *array, uint8_t bit_index) {\n    uint32_t *bit_address = (uint32_t *)(0x42000000 + ((uint32_t)array - 0x20000000) * 32 + bit_index * 4);\n    *bit_address = 1;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "clk_en"
            ],
            "imported": false,
            "current_name": "set_bit_in_uint32_array_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "mutex": "mutex",
                "blocking": "blocking",
                "state": "flags",
                "iVar1": "success",
                "process": "current_thread",
                "irqstate": "irq_flags",
                "me": "me",
                "(mutex->queue).next": "mutex->wait_queue.next",
                "(list_node *)0x0": "NULL",
                "(list_node *)0xffffffff": "LIST_POISON1",
                "&process->rq_entry": "&current_thread->rq_entry",
                "thread_add_to_list": "list_add_thread"
            },
            "code": "int acquire_mutex_00002434(mutex_t *mutex, int blocking)\n{\n    uint32_t flags;\n    int success;\n    thread_t *current_thread;\n    uint32_t irq_flags;\n    thread_t *me;\n    \n    flags = disable_interrupts();\n    if (mutex->wait_queue.next == NULL)\n    {\n        mutex->wait_queue.next = (list_node_t *)LIST_POISON1;\n        enable_interrupts(flags);\n        success = 1;\n    }\n    else if (blocking == 0)\n    {\n        enable_interrupts(flags);\n        success = 0;\n    }\n    else\n    {\n        current_thread = *(thread_t **)PTR_sched_active_thread_000024b8;\n        sched_set_status(current_thread, THREAD_STATUS_BLOCKED);\n        if (mutex->wait_queue.next == (list_node_t *)LIST_POISON1)\n        {\n            mutex->wait_queue.next = &current_thread->rq_entry;\n            mutex->wait_queue.next->next = NULL;\n        }\n        else\n        {\n            thread_add_to_list(&mutex->wait_queue, current_thread);\n        }\n        enable_interrupts(flags);\n        thread_yield_higher();\n        success = 1;\n    }\n    return success;\n}",
            "called": [
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable",
                "irq_restore",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "mutex_lock"
            ],
            "imported": false,
            "current_name": "acquire_mutex_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_memory_00005700",
                "param_1": "reent",
                "param_2": "pointer",
                "uVar1": "flag",
                "iVar2": "temp_var",
                "local_18": "local_reent",
                "local_14": "local_pointer"
            },
            "code": "void allocate_memory_00005700(_reent *reent, int *pointer)\n{\n  ushort flag;\n  int temp_var;\n  _reent *local_reent;\n  int *local_pointer;\n  \n  if (-1 < (int)((uint)*(ushort *)(pointer + 3) << 0x1e)) {\n    local_reent = reent;\n    local_pointer = pointer;\n    flag = __swhatbuf_r(reent,pointer,&local_reent,&local_pointer);\n    temp_var = _malloc_r(reent,local_reent);\n    if (temp_var != 0) {\n      reent->__cleanup = cleanup;\n      *pointer = temp_var;\n      *(ushort *)(pointer + 3) = *(ushort *)(pointer + 3) | 0x80;\n      pointer[5] = (int)local_reent;\n      pointer[4] = temp_var;\n      if ((local_pointer != (int *)0x0) &&\n         (temp_var = _isatty_r(reent,(int)*(short *)((int)pointer + 0xe)), temp_var != 0)) {\n        *(ushort *)(pointer + 3) = *(ushort *)(pointer + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(pointer + 3) = flag | *(ushort *)(pointer + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(pointer + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(pointer + 3) = *(ushort *)(pointer + 3) & 0xfffc | 2;\n  }\n  *pointer = (int)pointer + 0x47;\n  pointer[4] = (int)pointer + 0x47;\n  pointer[5] = 1;\n  return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_for_context_switch_request_00002798",
                "PTR_sched_context_switch_request_000027ac": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00002798(void)\n{\n    int* PTR_sched_context_switch_request_000027ac = (int*)PTR_sched_PTR_sched_context_switch_request_000027ac_000027ac;\n    if (*PTR_sched_context_switch_request_000027ac != 0) {\n        thread_yield_higher();\n    }\n    return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "isr_rtc"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "handle_rtc_command_00003524",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "result",
                "_rtc_usage": "print_rtc_usage",
                "PTR_s_poweron_00003638": "power_on_string",
                "strncmp": "compare_strings",
                "rtc_poweron": "turn_on_rtc",
                "PTR_s_poweroff_0000363c": "power_off_string",
                "rtc_poweroff": "turn_off_rtc",
                "PTR_s_clearalarm_00003640": "clear_alarm_string",
                "rtc_clear_alarm": "clear_rtc_alarm",
                "PTR_s_getalarm_00003644": "get_alarm_string",
                "_rtc_getalarm": "get_rtc_alarm",
                "PTR_s_setalarm_00003648": "set_alarm_string",
                "_rtc_setalarm": "set_rtc_alarm",
                "PTR_s_gettime_0000364c": "get_time_string",
                "_rtc_gettime": "get_rtc_time",
                "PTR_s_settime_00003650": "set_time_string",
                "_rtc_settime": "set_rtc_time",
                "iprintf": "print_formatted_string"
            },
            "code": "int handle_rtc_command_00003524(int argc, char **argv)\n{\n  int result;\n  if (argc < 2) {\n    print_rtc_usage();\n    result = 1;\n  }\n  else {\n    int comparison_result = strncmp(argv[1], PTR_s_poweron_00003638, 7);\n    if (comparison_result == 0) {\n      rtc_poweron();\n    }\n    else {\n      comparison_result = strncmp(argv[1], PTR_s_poweroff_0000363c, 8);\n      if (comparison_result == 0) {\n        rtc_poweroff();\n      }\n      else {\n        comparison_result = strncmp(argv[1], PTR_s_clearalarm_00003640, 8);\n        if (comparison_result == 0) {\n          rtc_clear_alarm();\n        }\n        else {\n          comparison_result = strncmp(argv[1], PTR_s_getalarm_00003644, 8);\n          if (comparison_result == 0) {\n            get_rtc_alarm();\n          }\n          else {\n            comparison_result = strncmp(argv[1], PTR_s_setalarm_00003648, 8);\n            if ((comparison_result == 0) && (argc == 4)) {\n              set_rtc_alarm(argv + 2);\n            }\n            else {\n              comparison_result = strncmp(argv[1], PTR_s_gettime_0000364c, 7);\n              if (comparison_result == 0) {\n                get_rtc_time();\n              }\n              else {\n                comparison_result = strncmp(argv[1], PTR_s_settime_00003650, 7);\n                if ((comparison_result != 0) || (argc != 4)) {\n                  iprintf(PTR_s_unknown_command_or_missing_param_00003654, argv[1]);\n                  print_rtc_usage();\n                  return 1;\n                }\n                set_rtc_time(argv + 2);\n              }\n            }\n          }\n        }\n      }\n      result = 0;\n    }\n  }\n  return result;\n}",
            "called": [
                "_rtc_setalarm",
                "rtc_poweroff",
                "_rtc_usage",
                "rtc_clear_alarm",
                "iprintf",
                "_rtc_settime",
                "strncmp",
                "_rtc_getalarm",
                "_rtc_gettime",
                "rtc_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "handle_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "update_current_mode_if_needed_00001bb8",
                "DAT_00001c74": "status_flags",
                "DAT_00001c78": "control_flags",
                "DAT_00001c7c": "unused_control_flags",
                "PTR_current_mode_00001c80": "current_mode"
            },
            "code": "void update_current_mode_if_needed_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_bit_in_byte(DAT_00001c78, 0x01);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      do {\n      } while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_bit_in_byte(DAT_00001c78, 0x06);\n    do {\n    } while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  do {\n  } while ((DAT_00001c74[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_current_mode_00001c80 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "update_current_mode_if_needed_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "__lock___sinit_recursive_mutex_00004294": "__lock_sinit_recursive_mutex",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock"
            },
            "code": "void acquire_recursive_lock_0000428c(void)\n{\n    __retarget_lock_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "decode_data_0000404c",
                "param_1": "data_buffer",
                "param_2": "decode_info",
                "iVar1": "decoded_data_length",
                "piVar2": "decode_param_ptr",
                "uVar3": "data_length",
                "uVar4": "decode_flags",
                "iVar5": "decode_step",
                "pcVar6": "decode_function_ptr",
                "iVar7": "decode_offset",
                "uVar8": "decode_result",
                "bVar9": "decode_flag_set"
            },
            "code": "int decode_data_0000404c(uint *data_buffer, int *decode_info) {\n  int decoded_data_length;\n  int *decode_param_ptr;\n  uint data_length;\n  ushort decode_flags;\n  int decode_step;\n  code *decode_function_ptr;\n  int decode_result;\n  uint decode_flag_mask = 0x40;\n  bool decode_flag_set;\n  decode_flags = *(ushort *)(decode_info + 3);\n  data_length = (uint)decode_flags;\n  if ((int)(data_length << 0x1c) < 0) {\n    decode_step = decode_info[4];\n    if (decode_step != 0) {\n      int decode_remaining_length = data_length << 0x1e;\n      decode_flag_set = decode_remaining_length == 0;\n      int decode_offset = *decode_info;\n      if (decode_flag_set) {\n        decode_remaining_length = decode_info[5];\n      }\n      *decode_info = decode_step;\n      if (!decode_flag_set) {\n        decode_remaining_length = 0;\n      }\n      decode_info[2] = decode_remaining_length;\n      for (decode_offset = decode_offset - decode_step; decode_offset > 0; decode_offset = decode_offset - decode_remaining_length) {\n        decoded_data_length = (*(code *)decode_info[10])(data_buffer,decode_info[8],decode_step,decode_offset);\n        if (decoded_data_length < 1) {\n          *(ushort *)(decode_info + 3) = decode_flags | decode_flag_mask;\n          return -1;\n        }\n        decode_step = decode_step + decoded_data_length;\n      }\n    }\n  }\n  else {\n    if ((decode_info[1] < 1) && (decode_info[16] < 1)) {\n      return 0;\n    }\n    decode_function_ptr = (code *)decode_info[0xb];\n    if (decode_function_ptr == (code *)0x0) {\n      return 0;\n    }\n    uint data_offset = *data_buffer;\n    *data_buffer = 0;\n    if ((decode_flags & 0x1000) == 0) {\n      decode_result = (*decode_function_ptr)(data_buffer,decode_info[8],data_length & 0x1000,1);\n      if ((decode_result == -1) && (*data_buffer != 0)) {\n        if ((*data_buffer == 0x1d) || (*data_buffer == 0x16)) {\n          *data_buffer = data_offset;\n          return 0;\n        }\n        decode_flags = *(ushort *)(decode_info + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      decode_result = decode_info[0x15];\n    }\n    if (((int)((uint)*(ushort *)(decode_info + 3) << 0x1d) < 0) && (decode_result = decode_result - decode_info[1], decode_info[0xd] != 0)) {\n      decode_result = decode_result - decode_info[0x10];\n    }\n    decode_result = (*(code *)decode_info[0xb])(data_buffer,decode_info[8],decode_result,0);\n    decode_flags = *(ushort *)(decode_info + 3);\n    if ((decode_result == -1) && ((0x1d < *data_buffer || (-1 < (int)((decode_flag_mask >> (*data_buffer & 0xff)) << 0x1f)))) {\n      *(ushort *)(decode_info + 3) = decode_flags | decode_flag_mask;\n      return decode_result;\n    }\n    decode_info[1] = 0;\n    *decode_info = decode_info[4];\n    if (((int)((uint)decode_flags << 0x13) < 0) && ((decode_result != -1 || (*data_buffer == 0)))) {\n      decode_info[0x15] = decode_result;\n    }\n    decode_param_ptr = (int *)decode_info[0xd];\n    *data_buffer = data_offset;\n    if (decode_param_ptr != (int *)0x0) {\n      if (decode_param_ptr != decode_info + 0x11) {\n        _free_r(data_buffer);\n      }\n      decode_info[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "__srefill_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "decode_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_saul_devices_00002f74",
                "dev": "device_pointer",
                "i": "device_count",
                "pcVar1": "class_name",
                "PTR_saul_reg_00002fd0": "PTR_device_pointer_00002fd0",
                "saul_reg_t": "saul_device_t",
                "PTR_s_No_devices_found_00002fd8": "PTR_no_devices_found_00002fd8",
                "PTR_s_ID_Class_Name_00002fd4": "PTR_id_class_name_00002fd4",
                "saul_class_to_str": "saul_class_to_string",
                "PTR_s___i__s__s_00002fdc": "PTR_device_info_00002fdc",
                "dev->driver->type": "device_pointer->saul_device_t->type",
                "dev->name": "device_pointer->name"
            },
            "code": "void print_saul_devices_00002f74(void)\n{\n  char *class_name;\n  int device_count = 0;\n  saul_reg_t *device_pointer;\n  \n  device_pointer = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  if (device_pointer == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; device_pointer != (saul_reg_t *)0x0; device_pointer = device_pointer->next) {\n    class_name = saul_class_to_str(device_pointer->driver->type);\n    iprintf(PTR_s___i__s__s_00002fdc,device_count,class_name,device_pointer->name);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculate_stack_size_000010a0",
                "stack": "stack_pointer",
                "space_free": "free_space",
                "stackp": "stack_address"
            },
            "code": "uintptr_t calculate_stack_size_000010a0(char *stack_pointer)\n{\n  uintptr_t free_space;\n  uintptr_t *stack_address;\n  for (stack_address = (uintptr_t *)stack_pointer; (uintptr_t *)*stack_address == stack_address; stack_address = stack_address + 1) {\n  }\n  return (uintptr_t)stack_address - (uintptr_t)stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "calculate_stack_size_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "read_from_isrpipe_000012e2",
                "isrpipe_t": "isrpipe",
                "buffer": "output_buffer",
                "count": "output_count",
                "iVar1": "read_result",
                "res": "unused",
                "tsrb": "input_buffer",
                "mutex": "input_mutex"
            },
            "code": "int read_from_isrpipe_000012e2(isrpipe_t *isrpipe, char *buffer, size_t count) {\n  int read_result;\n  int mutex_locked = 0;\n  while (true) {\n    read_result = tsrb_get(&isrpipe->tsrb, buffer, count);\n    if (read_result != 0) {\n      break;\n    }\n    if (!mutex_locked) {\n      mutex_lock(&isrpipe->mutex);\n      mutex_locked = 1;\n    }\n  }\n  return read_result;\n}",
            "called": [
                "mutex_lock",
                "tsrb_get"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "uart_stdio_read"
            ],
            "imported": false,
            "current_name": "read_from_isrpipe_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "env_var_name",
                "param_2": "env_var_value",
                "param_3": "env_var_value_size",
                "param_4": "env_var_found",
                "uStack_c": "env_var_ptr"
            },
            "code": "void find_environment_variable_000056a0(const char* env_var_name, char* env_var_value, size_t env_var_value_size, int* env_var_found){\n  char* env_var_ptr = NULL;\n  env_var_ptr = getenv(env_var_name);\n  if(env_var_ptr){\n    *env_var_found = 1;\n    strncpy(env_var_value, env_var_ptr, env_var_value_size);\n    env_var_value[env_var_value_size - 1] = '\\0';\n  }\n  else{\n    *env_var_found = 0;\n  }\n  return;\n}",
            "called": [
                "_findenv_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_from_tsrb_0000231c",
                "rb": "ring_buffer",
                "dst": "destination",
                "n": "max_copy_length",
                "cVar1": "character",
                "iVar2": "is_buffer_empty",
                "local_20": "destination_ptr",
                "tmp": "bytes_left_to_copy",
                "_pop": "tsrb_pop"
            },
            "code": "int copy_from_tsrb_0000231c(tsrb_t *ring_buffer, char *destination, size_t max_copy_length) {\n  char character;\n  int is_buffer_empty;\n  char *destination_ptr;\n  size_t bytes_left_to_copy;\n  \n  destination_ptr = destination;\n  bytes_left_to_copy = max_copy_length;\n  while ((bytes_left_to_copy != 0 && (is_buffer_empty = tsrb_empty(ring_buffer), is_buffer_empty == 0))) {\n    character = tsrb_pop(ring_buffer);\n    *destination_ptr = character;\n    bytes_left_to_copy--;\n    destination_ptr++;\n  }\n  return max_copy_length - bytes_left_to_copy;\n}",
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "copy_from_tsrb_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = DAT_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar7 = (uint)*param_3;\n      if (uVar7 == 0) {\n        return local_1a0;\n      }\n      uVar5 = (byte)puVar1[uVar7] & 8;\n      pbVar6 = param_3 + 1;\n      if ((puVar1[uVar7] & 8) == 0) break;\n      while (((param_3 = pbVar6, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar7 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar7) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar6;\n  }\n  local_1a4 = uVar5;\n  local_1ac = uVar5;\n  if (param_3[1] == 0x2a) {\n    pbVar6 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar5 = (uint)*pbVar6;\n    if (9 < uVar5 - 0x30) break;\n    pbVar6 = pbVar6 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar5) - 0x30;\n  }\n  pvVar4 = memchr(PTR_DAT_000064b4,uVar5,3);\n  if (pvVar4 != (void *)0x0) {\n    local_1ac = 1 << ((int)pvVar4 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar6 = pbVar6 + 1;\n  }\n  param_3 = pbVar6 + 1;\n  uVar5 = (uint)*pbVar6;\n  if (uVar5 < 0x79) {\n    if (0x57 < uVar5) {\n      switch(uVar5) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar5 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar6 = param_2[1];\n          param_2[1] = pbVar6 + -1;\n          if ((int)(pbVar6 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = _scanf_chars(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = _scanf_i(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar6 = param_3;\n    if (uVar5 == 0x25) goto LAB_00006352;\n    if (uVar5 < 0x26) {\n      if (uVar5 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar5 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "_scanf_i",
                "__ssrefill_r",
                "__sccl",
                "_scanf_chars",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "siscanf"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_rtt_alarm_to_tm_00002690",
                "time": "time_struct",
                "t": "alarm_time"
            },
            "code": "int convert_rtt_alarm_to_tm_00002690(tm *time)\n{\n  time_t alarm_time;\n  alarm_time._0_4_ = rtt_get_alarm();\n  alarm_time._4_4_ = 0;\n  gmtime_r((time_t *)&alarm_time, (tm *)time);\n  return 0;\n}",
            "called": [
                "gmtime_r",
                "rtt_get_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "convert_rtt_alarm_to_tm_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_in_memory_00006010",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "size_memory",
                "bVar1": "byte1",
                "cVar2": "byte2",
                "cVar3": "byte3",
                "cVar4": "byte4",
                "cVar5": "byte5",
                "pbVar6": "byte_pointer1",
                "puVar7": "uint_pointer1",
                "pbVar8": "byte_pointer2",
                "uVar9": "byte_mask",
                "uVar10": "uint1",
                "uVar11": "uint2",
                "uVar12": "uint3",
                "uVar13": "uint4",
                "bVar14": "byte1_bool",
                "bVar15": "byte2_bool",
                "bVar16": "byte3_bool",
                "bVar17": "byte4_bool"
            },
            "code": "void * find_byte_in_memory_00006010(void *memory, int byte_to_find, size_t size_memory) {\n  uint byte_mask;\n  char *byte_pointer;\n  uint *uint_pointer;\n  uint uint1;\n  uint uint2;\n  uint uint3;\n  uint uint4;\n  uint uint5;\n  bool byte1_bool;\n  bool byte2_bool;\n  bool byte3_bool;\n  bool byte4_bool;\n  byte_mask = byte_to_find & 0xff;\n  if ((int)size_memory < 0x10) {\n    while (true) {\n      if (size_memory == 0) {\n        return NULL;\n      }\n      byte_pointer = (char *)memory + 1;\n      if (*memory == byte_mask) {\n        break;\n      }\n      size_memory--;\n      memory = byte_pointer;\n      if (size_memory == 0) {\n        return NULL;\n      }\n    }\n  }\n  else {\n    uint1 = (uint)memory & 7;\n    while (true) {\n      if (uint1 == 0) {\n        byte_mask = byte_mask | byte_mask << 8;\n        byte_mask = byte_mask | byte_mask << 0x10;\n        uint2 = size_memory & 0xfffffff8;\n        do {\n          uint_pointer = (uint *)((int)memory + 8);\n          uint2 = uint2 - 8;\n          uint3 = * (uint *)memory ^ byte_mask;\n          uint4 = * (uint *)((int)memory + 4) ^ byte_mask;\n          byte1_bool = (char)uint3 != 0;\n          byte2_bool = (char)(uint3 >> 8) != 0;\n          byte3_bool = (char)(uint3 >> 0x10) != 0;\n          byte4_bool = (char)(uint3 >> 0x18) != 0;\n          uint3 = CONCAT13(byte4_bool, CONCAT12(byte3_bool, CONCAT11(byte2_bool, byte1_bool)));\n          byte1_bool = (char)uint4 != 0;\n          byte2_bool = (char)(uint4 >> 8) != 0;\n          byte3_bool = (char)(uint4 >> 0x10) != 0;\n          byte4_bool = (char)(uint4 >> 0x18) != 0;\n          uint4 = CONCAT13(byte4_bool, CONCAT12(byte3_bool, CONCAT11(byte2_bool, byte1_bool)));\n          if (uint4 | uint3) {\n            if (uint3 == 0) {\n              byte_pointer = (char *)memory + 5;\n              uint3 = uint4;\n            }\n            else {\n              byte_pointer = (char *)memory + 1;\n            }\n            if ((uint3 & 1) == 0) {\n              byte1_bool = (uint3 & 0x100) == 0;\n              byte_pointer = byte1_bool ? (char *)memory + 2 : byte_pointer;\n              byte_pointer = (byte3_bool = (uint3 & 0x18000) == 0) ? byte_pointer + 1 : byte_pointer;\n            }\n            return byte_pointer - 1;\n          }\n          memory = (void *)uint_pointer;\n        } while (uint2 != 0);\n        size_memory = size_memory & 7;\n        while (true) {\n          if (size_memory == 0) {\n            return NULL;\n          }\n          byte_pointer = (char *)memory + 1;\n          if (*memory == byte_mask) {\n            break;\n          }\n          size_memory--;\n          memory = byte_pointer;\n          if (size_memory == 0) {\n            return NULL;\n          }\n        }\n      }\n      byte_pointer = (char *)memory + 1;\n      size_memory--;\n      if (*memory == byte_mask) {\n        break;\n      }\n      uint1 = (uint)byte_pointer & 7;\n      memory = byte_pointer;\n      if (size_memory == 0) {\n        return NULL;\n      }\n    }\n  }\n  return (void *)((int)memory - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_in_memory_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_for_context_switch_request_00001cf0",
                "PTR_sched_context_switch_request_00001d04": "sched_context_switch_request"
            },
            "code": "void check_for_context_switch_request_00001cf0(void)\n{\n    int* PTR_sched_context_switch_request_00001d04 = (int*)PTR_PTR_sched_context_switch_request_00001d04_00001d04;\n    if (*PTR_sched_context_switch_request_00001d04 != 0)\n    {\n        thread_yield_higher();\n    }\n    return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "irq_handler"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_float_00003ec4",
                "out": "output",
                "val": "value",
                "fp_digits": "fractional_digits",
                "sVar1": "length",
                "val_00": "absolute_value",
                "iVar2": "divisor_length",
                "div_len": "divisor_length",
                "abs": "absolute_value",
                "e": "decimal_part",
                "div": "integer_part",
                "pos": "position"
            },
            "code": "size_t format_float_00003ec4(char *output, int32_t value, int fractional_digits) {\n  size_t length = 0;\n  uint32_t absolute_value;\n  uint32_t divisor_length;\n  uint32_t decimal_part;\n  uint32_t integer_part;\n  uint32_t position = 0;\n  if (fractional_digits + 7 < 0 != SCARRY4(fractional_digits,7)) {\n    core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_00003fec);\n  }\n  if (fractional_digits == 0) {\n    length = format_signed_decimal(output, value);\n  }\n  else if (fractional_digits < 1) {\n    divisor_length = *(uint32_t *)(PTR__tenmap_00003ff0 + fractional_digits * -4);\n    integer_part = value / divisor_length;\n    decimal_part = value - divisor_length * integer_part;\n    if (decimal_part < 0) {\n      decimal_part = -decimal_part;\n    }\n    if ((integer_part == 0) && (value < 0)) {\n      if (output != (char *)0x0) {\n        *output = '-';\n      }\n      position = 1;\n    }\n    if (output == (char *)0x0) {\n      length = format_signed_decimal((char *)0x0, integer_part);\n      position = length + 1 + position;\n    }\n    else {\n      length = format_signed_decimal(output + position, integer_part);\n      position += length;\n      output[position] = '.';\n      ++position;\n      length = format_unsigned_decimal(output + position, decimal_part);\n      format_left_pad(output + position, length, -fractional_digits, '0');\n    }\n    position = -fractional_digits + position;\n  }\n  else {\n    length = format_signed_decimal(output, value);\n    if (output != (char *)0x0) {\n      memset(output + length, '0', fractional_digits);\n    }\n    position = fractional_digits + length;\n  }\n  return position;\n}",
            "called": [
                "fmt_s32_dec",
                "fmt_lpad",
                "memset",
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "fmt_s16_dfp"
            ],
            "imported": false,
            "current_name": "format_float_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_memory_address_00001360",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void * calculate_memory_address_00001360(void *ptr, uintptr_t bit) {\n    uintptr_t high_bits = (uintptr_t)ptr & 0xf0000000;\n    uintptr_t low_bits = (uintptr_t)ptr & 0xfffff;\n    uintptr_t offset = (low_bits << 5) + 0x2000000;\n    return (void *)(bit * 4 + high_bits + offset);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_character_00004622",
                "__s": "memory_start",
                "__c": "character",
                "__n": "size",
                "puVar1": "memory_ptr"
            },
            "code": "void * fill_memory_with_character_00004622(void *memory_start, int character, size_t size) {\n  unsigned char *memory_ptr;\n  for (memory_ptr = (unsigned char *)memory_start; memory_ptr != (unsigned char *)(size + (int)memory_start); memory_ptr++) {\n    *memory_ptr = (unsigned char)character;\n  }\n  return memory_start;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "std",
                "__sfmoreglue",
                "fmt_s32_dfp",
                "fmt_lpad",
                "__sfp",
                "write"
            ],
            "imported": false,
            "current_name": "fill_memory_with_character_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_register_0000093c",
                "DAT_00000954": "register_address"
            },
            "code": "void set_flag_on_register_0000093c(void)\n{\n  uint32_t* DAT_00000954 = (uint32_t*)(DAT_00000954 + 4);\n  uint32_t flag_value = 0x10000000;\n  *DAT_00000954 |= flag_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "cortexm_isr_end",
                "_mutex_lock",
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end"
            ],
            "imported": false,
            "current_name": "set_flag_on_register_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "wait_for_data_sync_00003658",
                "PTR_DAT_00003680": "data_address",
                "DAT_00003684": "new_data"
            },
            "code": "void wait_for_data_sync_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* data_addr = (uint *)(DAT_00003680 + 0xc);\n  uint current_data = *data_addr;\n  uint mask = current_data & 0x700;\n  uint DAT_00003684 = DAT_00003684 | mask;\n  *data_addr = DAT_00003684;\n  DataSynchronizationBarrier(0xf);\n  while(true){\n    // Wait for data sync\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "pm_reboot"
            ],
            "imported": false,
            "current_name": "wait_for_data_sync_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "initialize_system_000019c0",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR_1920",
                "bit_clear8": "clear_bit",
                "DAT_00001a0c": "register_A",
                "DAT_00001a10": "register_B",
                "PTR_current_mode_00001a14": "current_mode",
                "SYSTEM_INITIALIZED": "3"
            },
            "code": "void initialize_system_000019c0(void)\n{\n  enable_oscillator();\n  set_fll_factor(FLL_FACTOR_1920);\n  clear_bit(DAT_00001a0c, 0x01);\n  *DAT_00001a10 = (*DAT_00001a10 & 0x3b) | 0x80;\n  while((DAT_00001a10[6] & 0xc) != 8);\n  disable_pll();\n  *PTR_PTR_current_mode_00001a14_00001a14 = SYSTEM_INITIALIZED;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "reverse_copy_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "src_ptr",
                "puVar2": "end_of_copy",
                "puVar3": "dest_ptr"
            },
            "code": "void* reverse_copy_000060b0(void* destination, void* source, size_t num_bytes){\n    unsigned char* src_ptr = (unsigned char*)source;\n    unsigned char* dest_ptr = (unsigned char*)destination + num_bytes - 1;\n    if(source != dest_ptr + 1){\n        do{\n            *dest_ptr-- = *src_ptr++;\n        } while(src_ptr != (unsigned char*)destination + num_bytes);\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "get_afl_call_result_000023d0",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_000023fc": "PTR_noHyperCall_000023fc",
                "aflCall": "aflCall"
            },
            "code": "uint32_t get_afl_call_result_000023d0(int ticks)\n{\n  uint32_t result;\n  if (*(int *)PTR_noHyperCall_000023fc == 0) {\n    result = aflCall(1, ticks, 0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "get_afl_call_result_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "nmi_handler_00000a30",
                "PTR_s_NMI_HANDLER_00000a3c": "nmi_handler_ptr"
            },
            "code": "void nmi_handler_00000a30(void)\n{\n    core_panic(PANIC_NMI_HANDLER, PTR_s_NMI_HANDLER_00000a3c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "nmi_handler_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "rtc_usage_command_arguments",
                "PTR_s_commands__00003504": "rtc_commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int print_rtc_commands_000034c0(void)\n{\n  puts(PTR_s_usage__rtc__command___arguments__00003500);\n  puts(PTR_s_commands__00003504);\n  puts(PTR_s__poweron_power_the_interface_on_00003508);\n  puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n  puts(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  puts(PTR_s__getalarm_print_the_currently_al_00003514);\n  puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  puts(PTR_s__gettime_print_the_current_time_0000351c);\n  puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "print_rtc_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "acquire_time_zone_lock_000050e8",
                "PTR___lock___tz_mutex_000050f0": "time_zone_mutex"
            },
            "code": "void acquire_time_zone_lock_000050e8(void)\n{\n    __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n    return;\n}",
            "called": [
                "__retarget_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "acquire_time_zone_lock_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_device_000042a4",
                "param_1": "device_id",
                "uVar1": "temp1",
                "iVar2": "temp2",
                "bVar3": "is_device_initialized"
            },
            "code": "void initialize_device_000042a4(int device_id)\n{\n    undefined4 temp1;\n    int temp2;\n    bool is_device_initialized = false;\n\n    acquire_device_lock();\n    if (*(int *)(device_id + 0x18) == 0) {\n        *(undefined4 *)(device_id + 0x48) = 0;\n        *(undefined4 *)(device_id + 0x4c) = 0;\n        *(undefined4 *)(device_id + 0x50) = 0;\n        temp2 = *(int *)global_impure_ptr;\n        *(undefined4 *)(device_id + 0x28) = global_data;\n        is_device_initialized = temp2 == device_id;\n        if (is_device_initialized) {\n            temp2 = 1;\n        }\n        if (is_device_initialized) {\n            *(int *)(device_id + 0x18) = temp2;\n        }\n        temp1 = __sfp(device_id);\n        *(undefined4 *)(device_id + 4) = temp1;\n        temp1 = __sfp(device_id);\n        *(undefined4 *)(device_id + 8) = temp1;\n        temp1 = __sfp(device_id);\n        *(undefined4 *)(device_id + 0xc) = temp1;\n        std(*(undefined4 *)(device_id + 4), 4, 0);\n        std(*(undefined4 *)(device_id + 8), 9, 1);\n        std(*(undefined4 *)(device_id + 0xc), 0x12, 2);\n        *(undefined4 *)(device_id + 0x18) = 1;\n    }\n    release_device_lock();\n    return;\n}",
            "called": [
                "__sinit_lock_acquire",
                "__sinit_lock_release",
                "std",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "_fflush_r",
                "__sfp",
                "_puts_r",
                "getchar",
                "iprintf",
                "putchar",
                "__swsetup_r",
                "_vfprintf_r",
                "__srget_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "initialize_device_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_errno_to_0x13_00000514",
                "r": "reent_ptr",
                "fd": "file_descriptor",
                "st": "file_stat",
                "_errno": "_error_number"
            },
            "code": "int set_errno_to_0x13_00000514(_reent *reent_ptr, int file_descriptor, stat *file_stat){\n  reent_ptr->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_0x13_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "argc",
                "argv": "argv"
            },
            "code": "void reboot_system_00002e9c() {\n  pm_reboot();\n}\n",
            "called": [
                "pm_reboot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "reboot_system_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "set_fll_factor_and_mode_00001960",
                "DAT_000019b4": "bit_array",
                "DAT_000019b8": "register_array",
                "PTR_current_mode_000019bc": "current_mode_pointer",
                "KINETIS_MCG_FLL_FACTOR_1464": "fll_factor_value"
            },
            "code": "void set_fll_factor_and_mode_00001960(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  clear_bit(DAT_000019b4, 1);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_current_mode_000019bc = 2;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_fll_factor_and_mode_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_bit_and_disable_pll_00001a3c",
                "DAT_00001a58": "DAT_current_mode",
                "PTR_current_mode_00001a5c": "PTR_current_mode",
                "bit_set8": "set_bit",
                "kinetis_mcg_disable_pll": "disable_pll"
            },
            "code": "void set_bit_and_disable_pll_00001a3c(void)\n{\n  set_bit(DAT_00001a58, 0x01);\n  disable_pll();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_bit_and_disable_pll_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_memcpy_000045ee",
                "__dest": "dest",
                "__src": "src",
                "__n": "n",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "code": "void * reverse_memcpy_000045ee(void *dest, const void *src, size_t n)\n{\n  unsigned char *src_ptr = (unsigned char *)src + n;\n  if ((src < dest) && (dest < src_ptr)) {\n    unsigned char *dest_ptr = (unsigned char *)dest + n;\n    while (dest_ptr != (unsigned char *)dest) {\n      src_ptr--;\n      dest_ptr--;\n      *dest_ptr = *src_ptr;\n    }\n  }\n  else {\n    unsigned char *dest_ptr = (unsigned char *)dest - 1;\n    for (; src != src_ptr; src_ptr++) {\n      dest_ptr++;\n      *dest_ptr = *(unsigned char *)src_ptr;\n    }\n  }\n  return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "reverse_memcpy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "send_char_to_stream_00005404",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "flags",
                "iVar1": "status",
                "uVar2": "ushort_val",
                "puVar3": "byte_ptr"
            },
            "code": "uint send_char_to_stream_00005404(int stream, uint character, int *buffer, undefined4 flags) {\n  int status;\n  uint uVar2;\n  undefined *byte_ptr;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (buffer == (int *)PTR___sf_fake_stdin_0000549c) {\n    buffer = *(int **)(stream + 4);\n  }\n  else if (buffer == (int *)PTR___sf_fake_stdout_000054a0) {\n    buffer = *(int **)(stream + 8);\n  }\n  else if (buffer == (int *)PTR___sf_fake_stderr_000054a4) {\n    buffer = *(int **)(stream + 0xc);\n  }\n  buffer[2] = buffer[6];\n  uVar2 = (uint)*(ushort *)(buffer + 3);\n  status = uVar2 << 0x1c;\n  if (((status < 0) && (uVar2 = buffer[4], uVar2 != 0)) ||\n     (status = __swsetup_r(stream, buffer, status, uVar2, flags), status == 0)) {\n    status = *buffer - buffer[4];\n    character = character & 0xff;\n    if ((status < buffer[5]) || (status = _fflush_r(stream, buffer), status == 0)) {\n      buffer[2] = buffer[2] + -1;\n      byte_ptr = (undefined *)*buffer;\n      *buffer = (int)(byte_ptr + 1);\n      *byte_ptr = (char)character;\n      if (buffer[5] != status + 1) {\n        if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      status = _fflush_r(stream, buffer);\n      if (status == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "_puts_r",
                "__sfputc_r",
                "_putc_r"
            ],
            "imported": false,
            "current_name": "send_char_to_stream_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "divide_or_negate_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "negative_dividend",
                "param_4": "negative_divisor",
                "iVar1": "quotient",
                "local_8": "local_array"
            },
            "code": "int divide_or_negate_00006974(int dividend, int divisor, int negative_dividend, int negative_divisor)\n{\n  int quotient;\n  undefined local_array[8];\n  \n  if ((negative_divisor == 0) && (negative_dividend == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    quotient = __aeabi_idiv0(dividend, divisor);\n    return quotient;\n  }\n  if (divisor < 0) {\n    quotient = -divisor - (uint)(dividend != 0);\n    if (negative_divisor < 0) {\n      quotient = __udivmoddi4(-dividend, quotient, -negative_dividend, -negative_divisor - (uint)(negative_dividend != 0), local_array);\n      return quotient;\n    }\n    quotient = __udivmoddi4(-dividend, quotient, negative_dividend, negative_divisor, local_array);\n    return -quotient;\n  }\n  if (negative_divisor < 0) {\n    quotient = __udivmoddi4(dividend, divisor, -negative_dividend, -negative_divisor - (uint)(negative_dividend != 0), local_array);\n    return -quotient;\n  }\n  quotient = __udivmoddi4(dividend, divisor, negative_dividend, negative_divisor, local_array);\n  return quotient;\n}\n",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "gmtime_r"
            ],
            "imported": false,
            "current_name": "divide_or_negate_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "allocate_memory_for_stream_00004314",
                "param_1": "stream",
                "piVar1": "current_buffer_pointer",
                "piVar2": "next_buffer_pointer",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "stream_buffer_list",
                "PTR__global_impure_ptr_00004398": "PTR_global_impure_ptr",
                "DAT_0000439c": "DAT_0000439c",
                "__sinit": "sinit",
                "__retarget_lock_init_recursive": "retarget_lock_init_recursive",
                "memset": "memset",
                "__sfmoreglue": "sfmoreglue"
            },
            "code": "int allocate_memory_for_stream_00004314(FILE *stream)\n{\n    int *stream_buffer;\n    int *stream_buffer_next;\n    int global_impure_ptr = *PTR__global_impure_ptr_00004398;\n    if (*(int *)(global_impure_ptr + 0x18) == 0)\n    {\n        __sinit(global_impure_ptr);\n    }\n    int **stream_buffer_list = (int **)(global_impure_ptr + 0x48);\n    while (true)\n    {\n        stream_buffer_next = stream_buffer_list[1];\n        stream_buffer = stream_buffer_list[2];\n        while (stream_buffer = (int *)((int)stream_buffer + -1), -1 < (int)stream_buffer)\n        {\n            if (*(short *)(stream_buffer + 3) == 0)\n            {\n                stream_buffer[3] = DAT_0000439c;\n                stream_buffer[0x19] = 0;\n                __retarget_lock_init_recursive(stream_buffer + 0x16);\n                allocate_memory_for_stream_00004314_lock_release();\n                stream_buffer[1] = 0;\n                stream_buffer[2] = 0;\n                stream_buffer[4] = 0;\n                stream_buffer[5] = 0;\n                *stream_buffer = 0;\n                stream_buffer[6] = 0;\n                memset(stream_buffer + 0x17, 0, 8);\n                stream_buffer[0xd] = 0;\n                stream_buffer[0xe] = 0;\n                stream_buffer[0x12] = 0;\n                stream_buffer[0x13] = 0;\n                return stream_buffer;\n            }\n            stream_buffer = stream_buffer + 0x1a;\n        }\n        if (*stream_buffer_list == (int *)0x0)\n        {\n            stream_buffer_next = (int *)__sfmoreglue(stream, 4);\n            *stream_buffer_list = stream_buffer_next;\n            if (stream_buffer_next == (int *)0x0)\n            {\n                allocate_memory_for_stream_00004314_lock_release();\n                return (int *)0x0;\n            }\n        }\n        stream_buffer_list = (int **)*stream_buffer_list;\n    }\n}",
            "called": [
                "__sfmoreglue",
                "memset",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "__sfp_lock_acquire",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "allocate_memory_for_stream_00004314"
        },
        "FUN_00005fd4": {
            "renaming": {
                "FUN_00005fd4": "parse_number_00005fd4",
                "param_1": "out",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "num",
                "uVar2": "digit",
                "bVar3": "neg",
                "iVar4": "result",
                "uVar5": "temp",
                "uVar6": "max_num",
                "pbVar7": "ptr",
                "pbVar8": "start"
            },
            "code": "uint parse_number_00005fd4(undefined4 *out, byte *str, byte **endptr, uint base) {\n  uint num = 0;\n  uint max_num = UINT_MAX / base;\n  int neg = 0;\n  byte *ptr = str;\n\n  // Skip leading whitespace\n  while (isspace(*ptr)) {\n    ptr++;\n  }\n\n  // Check for sign\n  if (*ptr == '+') {\n    ptr++;\n  } else if (*ptr == '-') {\n    neg = 1;\n    ptr++;\n  }\n\n  // Determine base\n  if (base == 0) {\n    if (*ptr == '0') {\n      base = 8;\n      ptr++;\n      if (toupper(*ptr) == 'X') {\n        base = 16;\n        ptr++;\n      }\n    } else {\n      base = 10;\n    }\n  } else if (base == 16 && *ptr == '0' && toupper(*(ptr + 1)) == 'X') {\n    ptr += 2;\n  }\n\n  // Parse number\n  while (1) {\n    uint digit = 0;\n    if (isdigit(*ptr)) {\n      digit = *ptr - '0';\n    } else if (isalpha(*ptr)) {\n      digit = toupper(*ptr) - 'A' + 10;\n    } else {\n      break;\n    }\n    if (digit >= base) {\n      break;\n    }\n    if (num > max_num || (num == max_num && digit > UINT_MAX % base)) {\n      *out = neg ? 0 : UINT_MAX;\n      if (endptr == NULL) {\n        return UINT_MAX;\n      } else {\n        *endptr = str;\n        return UINT_MAX;\n      }\n    }\n    num = num * base + digit;\n    ptr++;\n  }\n\n  if (endptr != NULL) {\n    *endptr = ptr;\n  }\n  *out = neg ? -num : num;\n  return num;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd4",
            "calling": [],
            "imported": false,
            "current_name": "parse_number_00005fd4"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "read_from_file_00004dc8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "_Var1": "bytes_read",
                "uVar2": "bytes_processed",
                "bVar3": "success",
                "*(int *)(param_2 + 0x54)": "*(uint *)(file_descriptor + 0x54)",
                "*(ushort *)(param_2 + 0xc)": "*(ushort *)(file_descriptor + 0xc)"
            },
            "code": "void read_from_file_00004dc8(_reent *reent, int file_descriptor, void *buffer, size_t buffer_size) {\n  _ssize_t bytes_read = _read_r(reent, (int)*(short *)(file_descriptor + 0xe), buffer, buffer_size);\n  bool success = bytes_read >= 0;\n  if (success) {\n    uint bytes_processed = *(int *)(file_descriptor + 0x54) + bytes_read;\n    *(uint *)(file_descriptor + 0x54) = bytes_processed;\n  }\n  else {\n    uint error_flag = *(ushort *)(file_descriptor + 0xc) & 0xffffefff;\n    *(short *)(file_descriptor + 0xc) = (short)error_flag;\n  }\n}\n",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "read_from_file_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "convert_string_to_ulong_00005fd8",
                "__nptr": "string",
                "__endptr": "endptr",
                "__base": "base",
                "uVar1": "result"
            },
            "code": "unsigned long convert_string_to_ulong_00005fd8(char *string, char **endptr, int base) {\n  unsigned long result = strtoul(string, endptr, base);\n  return result;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "convert_string_to_ulong_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_00005e10",
                "param_1": "file_descriptor",
                "param_2": "buffer_ptr",
                "iVar1": "refill_result",
                "uVar2": "byte_read",
                "pbVar3": "current_byte"
            },
            "code": "uint read_byte_00005e10(int file_descriptor, byte **buffer_ptr)\n{\n    int refill_result;\n    uint byte_read;\n    byte *current_byte;\n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n        __sinit();\n    }\n    if (buffer_ptr == (byte **)PTR___sf_fake_stdin_00005e5c) {\n        buffer_ptr = *(byte ***)(file_descriptor + 4);\n    }\n    else if (buffer_ptr == (byte **)PTR___sf_fake_stdout_00005e60) {\n        buffer_ptr = *(byte ***)(file_descriptor + 8);\n    }\n    else if (buffer_ptr == (byte **)PTR___sf_fake_stderr_00005e64) {\n        buffer_ptr = *(byte ***)(file_descriptor + 0xc);\n    }\n    refill_result = __srefill_r(file_descriptor, buffer_ptr);\n    if (refill_result == 0) {\n        buffer_ptr[1] = buffer_ptr[1] + -1;\n        current_byte = *buffer_ptr;\n        *buffer_ptr = current_byte + 1;\n        byte_read = (uint)*current_byte;\n    }\n    else {\n        byte_read = 0xffffffff;\n    }\n    return byte_read;\n}",
            "called": [
                "__srefill_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "_getc_r"
            ],
            "imported": false,
            "current_name": "read_byte_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_alarm_if_valid_time_000033f4",
                "argv": "time_str",
                "now": "parsed_time",
                "iVar1": "parse_result",
                "DAT_0000343c": "ALARM_INTERVAL"
            },
            "code": "int set_alarm_if_valid_time_000033f4(char **time_str){\n  int parse_result;\n  tm parsed_time;\n  parse_result = parse_time(time_str, &parsed_time);\n  if (parse_result == 0) {\n    int alarm_set_result = rtc_set_alarm(&parsed_time, DAT_0000343c, (void *)0x0);\n    if (alarm_set_result == -1) {\n      puts(PTR_s_rtc__error_setting_alarm_00003440);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_alarm_if_valid_time_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_time_to_tm_0000443c",
                "__timer": "__seconds",
                "__tp": "__time_struct",
                "iVar1": "__quotient",
                "uVar2": "__remainder",
                "uVar3": "__days_since_epoch",
                "uVar4": "__weekday",
                "iVar5": "__hours",
                "uVar6": "__minutes",
                "uVar9": "__seconds",
                "tVar7": "__seconds_since_epoch",
                "tVar8": "__seconds_since_midnight",
                "bVar10": "__is_negative",
                "DAT_0000458c": "SECONDS_IN_DAY",
                "DAT_00004594": "DAYS_IN_YEAR",
                "DAT_00004590": "DAYS_IN_100_YEARS",
                "DAT_00004598": "DAYS_IN_400_YEARS",
                "count_leading_zeroes": "count_leading_zeroes",
                "tm": "tm",
                "bool": "bool",
                "int": "int",
                "uint": "unsigned int",
                "time_t": "time_t",
                "SECONDS_IN_DAY": "86400",
                "SECONDS_IN_HOUR": "3600",
                "SECONDS_IN_MINUTE": "60",
                "DAYS_IN_WEEK": "7",
                "WEEKDAY_OFFSET": "3",
                "DAYS_IN_YEAR": "365",
                "DAYS_IN_4_YEARS": "1461",
                "DAYS_IN_100_YEARS": "36524",
                "DAYS_IN_400_YEARS": "146097",
                "YEAR_OFFSET": "1900",
                "MONTHS_IN_YEAR": "12",
                "DAYS_IN_MONTH": "{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}"
            },
            "code": "tm * convert_time_to_tm_0000443c(time_t *__timer, tm *__tp)\n{\n    int quotient;\n    uint remainder;\n    uint days_since_epoch;\n    uint weekday;\n    uint year;\n    uint month;\n    uint day;\n    uint hours;\n    uint minutes;\n    uint seconds;\n    time_t seconds_since_midnight;\n    time_t seconds_since_epoch;\n    bool is_negative;\n\n    seconds_since_epoch = *__timer;\n    seconds_since_midnight = __timer[1];\n    quotient = seconds_since_epoch / DAT_0000458c;\n    remainder = seconds_since_epoch % DAT_0000458c;\n    is_negative = (int)quotient < 0;\n    if (is_negative) {\n        quotient += DAT_00004594;\n    }\n    weekday = (quotient + WEEKDAY_OFFSET) % DAYS_IN_WEEK;\n    days_since_epoch = quotient;\n    if ((int)quotient < 0) {\n        days_since_epoch -= DAT_00004598;\n    }\n    year = YEAR_OFFSET + (days_since_epoch / DAT_00004598) * 400;\n    quotient = days_since_epoch % DAT_00004598;\n    if (quotient < 0) {\n        quotient += DAT_00004598;\n    }\n    year += (quotient / DAT_00004590) * 100;\n    quotient %= DAT_00004590;\n    if (quotient < 0) {\n        quotient += DAT_00004590;\n    }\n    year += (quotient / DAYS_IN_4_YEARS) * 4;\n    quotient %= DAYS_IN_4_YEARS;\n    if (quotient < 0) {\n        quotient += DAYS_IN_4_YEARS;\n    }\n    if (quotient == 1461) {\n        year += 3;\n        quotient = 365;\n    } else {\n        year += quotient / DAT_00004594;\n        quotient %= DAT_00004594;\n    }\n    day = quotient + 1;\n    month = 0;\n    while (month < MONTHS_IN_YEAR && DAYS_IN_MONTH[month] <= quotient) {\n        quotient -= DAYS_IN_MONTH[month];\n        month++;\n    }\n    month++;\n    hours = remainder / SECONDS_IN_HOUR;\n    remainder %= SECONDS_IN_HOUR;\n    minutes = remainder / SECONDS_IN_MINUTE;\n    seconds = remainder % SECONDS_IN_MINUTE;\n    __tp->tm_year = year - YEAR_OFFSET;\n    __tp->tm_mon = month;\n    __tp->tm_mday = day;\n    __tp->tm_wday = weekday;\n    __tp->tm_hour = hours;\n    __tp->tm_min = minutes;\n    __tp->tm_sec = seconds;\n    __tp->tm_isdst = 0;\n    return __tp;\n}\n",
            "called": [
                "__aeabi_ldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "convert_time_to_tm_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "power_on_rtt_clock_000027b0",
                "puVar1": "rtt_data",
                "rtt": "rtt_instance"
            },
            "code": "void power_on_rtt_clock_000027b0(void)\n{\n  uint32_t *rtt_data = DAT_00002814;\n  RTC_Type *rtt_instance = DAT_00002818;\n  rtt_instance->MODE2_CTRL.reg |= RTC_MODE2_CTRL_ENABLE_Msk;\n  rtt_data[4] = 1;\n  rtt_data[4] = 0;\n  if ((rtt_data[5] & 1) != 0) {\n    *rtt_data = 0;\n  }\n  rtt_data[4] = 0x104;\n  rtt_data[2] = 0xffffff42;\n  rtt_data[7] = 0;\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "rtc_init"
            ],
            "imported": false,
            "current_name": "power_on_rtt_clock_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "pcVar2": "destination_ptr"
            },
            "code": "char* copy_string_00005ebc(char* destination, char* source)\n{\n  char current_char;\n  char* destination_ptr = destination;\n  do {\n    current_char = *source;\n    *destination_ptr = current_char;\n    source++;\n    destination_ptr++;\n  } while (current_char != '\\0');\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "free_memory_if_not_null_00006192",
                "param_1": "memory_address",
                "param_2": "memory_block",
                "undefined4": "unsigned int",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "undefined4 free_memory_if_not_null_00006192(undefined4 memory_address, undefined4 *memory_block) {\n    if ((undefined4 *)memory_block[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)memory_block[0xd] != memory_block + 0x11) {\n            _free_r();\n        }\n        memory_block[1] = memory_block[0x10];\n        memory_block[0xd] = 0;\n        if (memory_block[0x10] != 0) {\n            *memory_block = memory_block[0xf];\n            return 0;\n        }\n    }\n    *memory_block = memory_block[4];\n    memory_block[1] = 0;\n    *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) | 0x20;\n    return 0xffffffff;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "free_memory_if_not_null_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_bit_6_in_data_00001734",
                "DAT_00001744": "data_register"
            },
            "code": "void clear_bit_6_in_data_00001734(void)\n{\n  bit_clear8(DAT_00001744, 0x06);\n  return;\n}",
            "called": [
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "clear_bit_6_in_data_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "read_from_uart_isrpipe_00000e14",
                "buffer": "input_buffer",
                "count": "input_count",
                "iVar1": "read_count"
            },
            "code": "int read_from_uart_isrpipe_00000e14(char *buffer, int count)\n{\n  int read_count = isrpipe_read((isrpipe_t *)PTR_uart_stdio_isrpipe_00000e34, buffer, count);\n  return read_count;\n}",
            "called": [
                "isrpipe_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "read_from_uart_isrpipe_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_rtc_type_0000281c",
                "rtt": "rtc_type_ptr",
                "i": "loop_counter",
                "t": "rtc_type_value"
            },
            "code": "uint32_t find_rtc_type_0000281c(void)\n{\n  RTC_Type *rtc_type_ptr;\n  int i = 0;\n  uint32_t t;\n  while ((i < 3 && (t = *DAT_00002858, t != *DAT_00002858))) {\n    i++;\n  }\n  return t;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "find_rtc_type_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_rb_empty_00002270",
                "rb": "ring_buffer",
                "bVar1": "is_empty",
                "uVar2": "num_writes",
                "bVar3": "is_full"
            },
            "code": "uint8_t is_rb_empty_00002270(tsrb_t *ring_buffer)\n{\n    uint32_t num_writes = ring_buffer->writes;\n    bool is_full = ring_buffer->reads == num_writes;\n    uint8_t is_empty = is_full ? 1 : 0;\n    if (!is_full)\n    {\n        is_empty = 0;\n    }\n    return is_empty;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "is_rb_empty_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "call_function_with_pointer_arg_00005780",
                "__ptr": "ptr_arg",
                "_FUN_00005780_r": "function_with_pointer_arg"
            },
            "code": "void call_function_with_pointer_arg_00005780(void *ptr_arg)\n{\n  function_with_pointer_arg(* (undefined4 *) PTR__impure_ptr_0000578c, ptr_arg);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "call_function_with_pointer_arg_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "handle_interrupt_000020cc",
                "DAT_000020dc": "data"
            },
            "code": "void handle_interrupt_000020cc(void)\n{\n  irq_handler(DAT_000020dc, 1);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_real_time_clock_00002396",
                "rtc_init": "rtc_initialize"
            },
            "code": "void initialize_real_time_clock_00002396(void)\n{\n    rtc_init();\n    return;\n}",
            "called": [
                "rtc_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_clock_00002396"
        },
        "FUN_00004e4a": {
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reent",
                "param_2": "file_descriptor"
            },
            "code": "void close_file_00004e4a(_reent *reent, int file_descriptor) {\n  _close_r(reent, (int)*(short *)(file_descriptor + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e4a",
            "calling": [],
            "imported": false,
            "current_name": "close_file_00004e4a"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "put_char_00004cb4",
                "__c": "character",
                "in_r3": "in_register_3",
                "iVar1": "impure_ptr",
                "PTR__impure_ptr_00004cd8": "PTR__impure_ptr_00004cd8",
                "__sinit": "__sinit",
                "_putc_r": "_putc_r"
            },
            "code": "int put_char_00004cb4(int character) {\n    undefined4 in_register_3;\n    int impure_ptr = *(int *)PTR__impure_ptr_00004cd8;\n    if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n        __sinit(impure_ptr);\n    }\n    int result = _putc_r(impure_ptr, character, *(undefined4 *)(impure_ptr + 8), in_register_3);\n    return result;\n}",
            "called": [
                "_putc_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "_putchar"
            ],
            "imported": false,
            "current_name": "put_char_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_rtc_time_00003478",
                "argv": "time_arg",
                "iVar1": "error_code",
                "now": "current_time",
                "_parse_time": "parse_time",
                "rtc_set_time": "rtc_set_time"
            },
            "code": "int set_rtc_time_00003478(char **time_arg)\n{\n    int error_code;\n    tm current_time;\n    error_code = parse_time(time_arg, &current_time);\n    if (error_code == 0) {\n        error_code = rtc_set_time(&current_time);\n        if (error_code == -1) {\n            puts(PTR_s_rtc__error_setting_time_000034bc);\n            error_code = 1;\n        }\n        else {\n            error_code = 0;\n        }\n    }\n    else {\n        error_code = 1;\n    }\n    return error_code;\n}",
            "called": [
                "rtc_set_time",
                "_parse_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_time_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "process_port_interrupt_00002028",
                "port_num": "port_number",
                "iVar1": "context_index",
                "uVar2": "interrupt_status",
                "status": "interrupt_status",
                "PTR_isr_ctx_000020b4": "isr_context_ptr"
            },
            "code": "void process_port_interrupt_00002028(PORT_Type *port, int port_number) {\n  int context_index;\n  uint32_t interrupt_status;\n  uint32_t bit_mask;\n  int i;\n  interrupt_status = port->ISFR;\n  for (i = 0; i < 32; i++) {\n    bit_mask = 1 << i;\n    if (((interrupt_status & bit_mask) != 0) && ((port->PCR[i] & 0xf0000) != 0)) {\n      port->ISFR = bit_mask;\n      context_index = get_context_index(port_number, i);\n      (**(code **)(PTR_isr_ctx_000020b4 + context_index * 0xc))(*(undefined4 *)(PTR_isr_ctx_000020b4 + context_index * 0xc + 4));\n    }\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "isr_porte",
                "isr_portd",
                "isr_portb",
                "isr_portc",
                "isr_porta"
            ],
            "imported": false,
            "current_name": "process_port_interrupt_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_bit_at_position_000016c8",
                "ptr": "memory_address",
                "bit": "bit_position",
                "puVar1": "bit_band_address"
            },
            "code": "void set_bit_at_position_000016c8(uint32_t *memory_address, uint8_t bit_position) {\n    undefined4 *bit_band_address = (undefined4 *)bitband_addr(memory_address, (uint)bit_position);\n    *bit_band_address = 1;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "clear_bit_and_set_bit_until_condition_is_met_00001a60",
                "DAT_00001ac4": "bitfield_A",
                "DAT_00001ac8": "bitfield_B",
                "DAT_00001acc": "bitfield_C",
                "PTR_current_mode_00001ad0": "current_mode"
            },
            "code": "void clear_bit_and_set_bit_until_condition_is_met_00001a60(void)\n{\n  clear_bit(DAT_00001ac4, 0x01);\n  *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_bit(DAT_00001acc, 0x06);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_PTR_current_mode_00001ad0_00001ad0 = 6;\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "clear_bit_and_set_bit_until_condition_is_met_00001a60"
        },
        "FUN_000004b2": {
            "renaming": {
                "FUN_000004b2": "write_data_to_uart_000004b2",
                "r": "reent",
                "fd": "fd",
                "data": "data_buffer",
                "count": "data_length",
                "iVar1": "bytes_written"
            },
            "code": "_ssize_t write_data_to_uart_000004b2(_reent *reent, int fd, void *data_buffer, size_t data_length) {\n\tint bytes_written = uart_stdio_write((char *)data_buffer, data_length);\n\treturn bytes_written;\n}",
            "called": [
                "uart_stdio_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004b2",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_data_to_uart_000004b2"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_kernel_and_board_0000099c",
                "uStack_18": "stack_top",
                "top": "stack_top",
                "src": "etext",
                "PTR__etext_00000a14": "etext",
                "pre_startup": "pre_startup",
                "dst": "isr_stack",
                "PTR_isr_stack_00000a18": "isr_stack",
                "DAT_00000a1c": "isr_stack_init_val",
                "PTR_heap_top_00000a20": "heap_top",
                "PTR_sched_num_threads_00000a24": "sched_num_threads",
                "PTR_sched_num_threads_00000a28": "sched_num_threads",
                "PTR__sheap_00000a2c": "sheap",
                "post_startup": "post_startup",
                "board_init": "board_initialize",
                "__libc_init_array": "__libc_init_array",
                "kernel_init": "kernel_initialize"
            },
            "code": "void initialize_kernel_and_board_0000099c(void)\n{\n  uint32_t *stack_top = &stack_top;\n  uint32_t *src = (uint32_t *)PTR__etext_00000a14;\n  pre_startup();\n  uint32_t *dst = (uint32_t *)PTR_isr_stack_00000a18;\n  while (dst < &stack_top) {\n    *dst = DAT_00000a1c;\n    dst++;\n  }\n  dst = (uint32_t *)PTR_heap_top_00000a20;\n  while (dst < PTR_PTR_sched_num_threads_00000a28_00000a24) {\n    *dst = *src;\n    src++;\n    dst++;\n  }\n  dst = (uint32_t *)PTR_PTR_sched_num_threads_00000a28_00000a24;\n  while (dst < PTR__sheap_00000a2c) {\n    *dst = 0;\n    dst++;\n  }\n  post_startup();\n  board_initialize();\n  __libc_init_array();\n  kernel_initialize();\n  return;\n}",
            "called": [
                "pre_startup",
                "board_init",
                "post_startup",
                "kernel_init",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_kernel_and_board_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "read_line_00002d94",
                "buf": "buffer",
                "size": "size",
                "c_00": "input_char",
                "bVar1": "is_buffer_empty",
                "bVar2": "is_first_char",
                "c": "c",
                "line_buf_ptr": "buffer_ptr"
            },
            "code": "int read_line_00002d94(char *buffer, size_t size)\n{\n    int input_char;\n    byte is_buffer_empty;\n    bool is_first_char;\n    char *buffer_ptr;\n    \n    buffer_ptr = buffer;\n    while(true)\n    {\n        if ((int)(size - 1) <= (int)buffer_ptr - (int)buffer)\n        {\n            return -1;\n        }\n        input_char = getchar();\n        if (input_char < 0)\n        {\n            break;\n        }\n        if ((input_char == 0xd) || (input_char == 10))\n        {\n            *buffer_ptr = '\\0';\n            _putchar(0xd);\n            _putchar(10);\n            is_first_char = buffer_ptr == buffer;\n            if (is_first_char)\n            {\n                buffer = (char *)0x1;\n            }\n            is_buffer_empty = (byte)buffer;\n            if (!is_first_char)\n            {\n                is_buffer_empty = 0;\n            }\n            return (uint)is_buffer_empty;\n        }\n        if ((input_char == 8) || (input_char == 0x7f))\n        {\n            if (buffer_ptr != buffer)\n            {\n                buffer_ptr = buffer_ptr + -1;\n                *buffer_ptr = '\\0';\n                _putchar(8);\n                _putchar(0x20);\n                _putchar(8);\n            }\n        }\n        else\n        {\n            *buffer_ptr = (char)input_char;\n            _putchar(input_char);\n            buffer_ptr = buffer_ptr + 1;\n        }\n    }\n    return 1;\n}",
            "called": [
                "getchar",
                "_putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "read_line_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_prefix_char_00003918",
                "scale": "scale",
                "cVar1": "prefix_char"
            },
            "code": "char get_prefix_char_00003918(int8_t scale) {\n    char prefix_char;\n    switch(scale) {\n        case 2:\n            prefix_char = 'h';\n            break;\n        case 3:\n            prefix_char = 'k';\n            break;\n        case 6:\n            prefix_char = 'M';\n            break;\n        case 9:\n            prefix_char = 'G';\n            break;\n        case 12:\n            prefix_char = 'T';\n            break;\n        case 15:\n            prefix_char = 'P';\n            break;\n        case -15:\n            prefix_char = 'f';\n            break;\n        case -12:\n            prefix_char = 'p';\n            break;\n        case -9:\n            prefix_char = 'n';\n            break;\n        case -6:\n            prefix_char = 'u';\n            break;\n        case -3:\n            prefix_char = 'm';\n            break;\n        default:\n            prefix_char = '\\0';\n            break;\n    }\n    return prefix_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_prefix_char_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "data",
                "iVar1": "result"
            },
            "code": "int read_sensor_data_00003d64(saul_reg_t *sensor, phydat_t *data) {\n  int result;\n  if (sensor == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "probe"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "str1",
                "__s2": "str2",
                "bVar1": "current_char_str2",
                "uVar2": "current_char_str1",
                "bVar3": "strings_match"
            },
            "code": "int compare_strings_00004e52(char* str1, char* str2) {\n    uint8_t current_char_str1;\n    uint8_t current_char_str2;\n    bool strings_match = true;\n    do {\n        current_char_str1 = (uint8_t)*str1;\n        current_char_str2 = *str2;\n        if (current_char_str1 != 0) {\n            strings_match = current_char_str1 == current_char_str2;\n        }\n        str1++;\n        str2++;\n    } while (strings_match);\n    return current_char_str1 - current_char_str2;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "_tzset_unlocked_r",
                "read",
                "find_handler",
                "strcmp",
                "_saul",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stacksize": "stack_size",
                "state_00": "state",
                "process": "thread",
                "local_30": "remaining_stack_size",
                "local_2c": "stack_ptr",
                "stack_size": "aligned_stack_size",
                "cb": "existing_thread",
                "total_stacksize": "total_stack_size",
                "stackp": "stack_ptr",
                "i": "pid",
                "PTR_sched_threads_0000126c": "PTR_sched_threads",
                "PTR_sched_num_threads_00001270": "PTR_sched_num_threads",
                "flags": "flags",
                "priority": "priority",
                "name": "name",
                "function": "function",
                "arg": "arg"
            },
            "code": "kernel_pid_t create_thread_000010d4(char *stack, int stack_size, char priority, int flags, thread_task_func_t function, void *arg, char *name)\n{\n  uint state;\n  char *stack_aligned;\n  uint aligned_stack_size;\n  thread_t *thread;\n  int remaining_stack_size;\n  uintptr_t *stack_ptr;\n  uintptr_t *stack_max;\n  thread_t *existing_thread;\n  uintptr_t misalignment;\n  int total_stack_size;\n  kernel_pid_t pid = -1;\n  \n  if (priority < 0x10) {\n    stack_aligned = stack;\n    if (((uint)stack & 3) != 0) {\n      misalignment = 4 - ((uint)stack & 3);\n      stack_aligned = stack + misalignment;\n      remaining_stack_size = stack_size - misalignment;\n    }\n    else {\n      remaining_stack_size = stack_size;\n    }\n    aligned_stack_size = remaining_stack_size - 0x30 & 0xfffffffc;\n    thread = (thread_t *)(aligned_stack_size + (int)stack_aligned);\n    if ((flags & 8U) == 0) {\n      *stack_aligned = (uintptr_t)stack_aligned;\n    }\n    else {\n      for (stack_ptr = stack_aligned; stack_ptr < (uintptr_t *)(aligned_stack_size + (int)stack_aligned); stack_ptr++) {\n        *stack_ptr = (uintptr_t)stack_ptr;\n      }\n    }\n    state = irq_disable();\n    for (pid = 1; pid < 0x21; pid++) {\n      existing_thread = *(thread_t **)(PTR_sched_threads_0000126c_0000126c + pid * 4);\n      if (existing_thread == NULL) {\n        *(thread_t **)(PTR_sched_threads_0000126c_0000126c + pid * 4) = thread;\n        thread->pid = pid;\n        thread_stack_init(function, arg, stack_aligned, aligned_stack_size);\n        thread->stack_start = (char *)stack_aligned;\n        thread->stack_size = stack_size;\n        thread->name = name;\n        thread->priority = priority;\n        thread->status = THREAD_STATUS_PENDING;\n        (thread->rq_entry).next = NULL;\n        thread->wait_data = NULL;\n        (thread->msg_waiters).next = NULL;\n        cib_init(&thread->msg_queue,0);\n        *(int *)PTR_sched_num_threads_00001270_00001270 = *(int *)PTR_sched_num_threads_00001270_00001270 + 1;\n        if ((flags & 1U) == 0) {\n          sched_set_status(thread, THREAD_STATUS_READY);\n          if ((flags & 4U) == 0) {\n            irq_restore(state);\n            sched_switch(priority);\n            return pid;\n          }\n        }\n        else {\n          sched_set_status(thread, THREAD_STATUS_SUSPENDED);\n        }\n        irq_restore(state);\n        break;\n      }\n    }\n    if (pid == 0x21) {\n      irq_restore(state);\n      pid = -THREAD_ERRNO_NOMEM;\n    }\n  }\n  else {\n    pid = -THREAD_ERRNO_PRIORITY;\n  }\n  return pid;\n}",
            "called": [
                "irq_disable",
                "thread_stack_init",
                "cib_init",
                "irq_restore",
                "sched_set_status",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "kernel_init"
            ],
            "imported": false,
            "current_name": "create_thread_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_thread_priority_00000738",
                "other_prio": "other_priority",
                "iVar1": "irq_flag",
                "current_prio": "current_priority",
                "active_thread": "active_thread",
                "on_runqueue": "on_runqueue"
            },
            "code": "void check_thread_priority_00000738(uint16_t other_priority) {\n  int irq_flag;\n  uint16_t current_priority;\n  thread_t *active_thread;\n  int on_runqueue;\n  \n  active_thread = *(thread_t **)PTR_sched_active_thread_0000078c;\n  current_priority = *(uint8_t *)(active_thread + 4);\n  \n  if (current_priority < 9 || other_priority < *(uint8_t *)(active_thread + 5)) {\n    irq_flag = irq_is_in();\n    if (irq_flag == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(uint32_t *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "thread_create",
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "check_thread_priority_00000738"
        },
        "FUN_000045e6": {
            "renaming": {
                "FUN_000045e6": "do_nothing_000045e6"
            },
            "code": "\nvoid do_nothing_000045e6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e6",
            "calling": [
                "__tz_lock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e6"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "convert_int_to_string_00003e58",
                "out": "output_str",
                "val": "value",
                "local_18": "abs_value",
                "local_14": "str_ptr",
                "negative": "is_negative",
                "sVar1": "str_len"
            },
            "code": "size_t convert_int_to_string_00003e58(char *output_str, int32_t value) {\n    size_t str_len = 0;\n    uint32_t abs_value = value;\n    char *str_ptr = output_str;\n    uint is_negative = 0;\n    \n    if (value < 0) {\n        if (output_str != NULL) {\n            *str_ptr = '-';\n            str_ptr++;\n        }\n        abs_value = -value;\n        is_negative = 1;\n    }\n    \n    str_len = fmt_u32_dec(str_ptr, abs_value);\n    \n    if (is_negative) {\n        str_len++;\n    }\n    \n    return str_len;\n}",
            "called": [
                "fmt_u32_dec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "convert_int_to_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "seek_file_00004e26",
                "param_1": "reent_ptr",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seek_result",
                "uVar2": "status_flags",
                "bVar3": "seek_failed"
            },
            "code": "void seek_file_00004e26(_reent *reent_ptr, int file_descriptor, _off_t offset, int whence) {\n  _off_t seek_result;\n  ushort status_flags;\n  bool seek_failed;\n\n  seek_result = _lseek_r(reent_ptr, (int)*(short *)(file_descriptor + 0xe), offset, whence);\n  seek_failed = seek_result == -1;\n  if (seek_failed) {\n    status_flags = *(ushort *)(file_descriptor + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(file_descriptor + 0x54) = seek_result;\n    status_flags = *(ushort *)(file_descriptor + 0xc) | 0x1000;\n  }\n  if (seek_failed) {\n    *(ushort *)(file_descriptor + 0xc) = status_flags;\n  }\n  if (!seek_failed) {\n    *(ushort *)(file_descriptor + 0xc) = status_flags;\n  }\n  return;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "seek_file_00004e26"
        },
        "FUN_00000978": {
            "renaming": {
                "FUN_00000978": "execute_active_thread_00000978",
                "bVar1": "is_privileged_mode",
                "UNRECOVERED_JUMPTABLE": "active_thread_function",
                "ppcVar2": "active_thread_stack_ptr",
                "PTR_sched_active_thread_0000098c": "active_thread_ptr"
            },
            "code": "void execute_active_thread_00000978(void) {\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  code *active_thread_function = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  code **active_thread_stack_ptr = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  if (is_privileged_mode) {\n    setProcessStackPointer(active_thread_stack_ptr);\n  }\n  (*active_thread_function)(active_thread_function, active_thread_stack_ptr);\n  return;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000978",
            "calling": [],
            "imported": false,
            "current_name": "execute_active_thread_00000978"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "_puts_r",
                "__sinit_lock_acquire",
                "_fflush_r",
                "_vfprintf_r",
                "__sfp_lock_acquire",
                "_putc_r",
                "__malloc_lock",
                "__env_lock",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  void *pvVar6;\n  int *piVar7;\n  byte *pbVar8;\n  int unaff_r7;\n  byte *pbVar9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar4 = __swsetup_r(param_1,param_2), iVar4 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar2 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar9 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar8 = pbVar9;\n  if (*pbVar8 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar9 = pbVar8 + 1;\n  if (*pbVar8 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar4 = (int)pbVar8 - (int)param_3;\n  if (iVar4 != 0) {\n    iVar5 = __sfputs_r(param_1,param_2,param_3,iVar4);\n    if (iVar5 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar4;\n  }\n  if (*pbVar8 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar9 = pbVar8 + 1;\n  while( true ) {\n    pbVar8 = pbVar9 + 1;\n    pvVar6 = memchr(PTR_s___0__00005a44,(uint)*pbVar9,5);\n    puVar3 = PTR_DAT_00005a54;\n    if (pvVar6 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar6 - (int)puVar2 & 0xffU) | local_88;\n    pbVar9 = pbVar8;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar9 == 0x2a) {\n    piVar7 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar7;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar1 = false;\n    iVar4 = local_7c;\n    pbVar8 = pbVar9;\n    while( true ) {\n      if (9 < *pbVar8 - 0x30) break;\n      iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n      bVar1 = true;\n      pbVar8 = pbVar8 + 1;\n    }\n    if (bVar1) {\n      local_7c = iVar4;\n    }\n  }\n  if (*pbVar8 == 0x2e) {\n    if (pbVar8[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar8 = pbVar8 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar4 = 0;\n      while( true ) {\n        pbVar8 = pbVar8 + 1;\n        if (9 < *pbVar8 - 0x30) break;\n        iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar4;\n      }\n    }\n  }\n  pvVar6 = memchr(PTR_DAT_00005a54,(uint)*pbVar8,3);\n  if (pvVar6 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar6 - (int)puVar3 & 0xffU);\n    pbVar8 = pbVar8 + 1;\n  }\n  param_3 = pbVar8 + 1;\n  local_70 = *pbVar8;\n  pvVar6 = memchr(PTR_s_efgEFG_00005a48,(uint)local_70,6);\n  if (pvVar6 == (void *)0x0) {\n    iVar4 = _printf_i(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar4 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar4 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar4 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar4;\n  pbVar9 = param_3;\n  unaff_r7 = iVar4;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "__sfputs_r",
                "__retarget_lock_acquire_recursive",
                "__swsetup_r",
                "memchr",
                "__retarget_lock_release_recursive",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "set_fll_factor_and_clear_bits_000018bc",
                "DAT_00001910": "mode_register",
                "DAT_00001914": "status_register",
                "PTR_current_mode_00001918": "current_mode_ptr"
            },
            "code": "void set_fll_factor_and_clear_bits_000018bc(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = *DAT_00001910 & 0x3b | 4;\n  bit_clear8(DAT_00001914, 1);\n  do {\n  } while ((DAT_00001910[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001910[6] & 0xc) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_fll_factor_and_clear_bits_000018bc"
        },
        "FUN_00000974": {
            "renaming": {
                "FUN_00000974": "run_active_thread_00000974",
                "bVar1": "is_privileged_mode",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "ppcVar2": "process_stack_pointer"
            },
            "code": "void run_active_thread_00000974() {\n  bool is_privileged_mode;\n  code *jump_table;\n  code **process_stack_pointer;\n  \n  sched_run();\n  jump_table = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  process_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(process_stack_pointer);\n  }\n  (*jump_table)(jump_table, process_stack_pointer);\n  return;\n}",
            "called": [
                "sched_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000974",
            "calling": [
                "isr_pendsv"
            ],
            "imported": false,
            "current_name": "run_active_thread_00000974"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "kernel_panic_00000f04",
                "crash_code": "code",
                "message": "error_message",
                "local_10": "message",
                "local_9": "code",
                "PTR_crashed_00000f4c": "PTR_crashed_flag",
                "PANIC_ASSERT_FAIL": "PANIC_ASSERT",
                "cpu_print_last_instruction": "print_last_instruction",
                "PTR_s_____RIOT_kernel_panic___s_00000f50": "PTR_error_message",
                "ps": "print_status",
                "PTR_DAT_00000f54": "PTR_message",
                "PTR_s_____halted__00000f58": "PTR_halted_message",
                "irq_disable": "disable_interrupts",
                "panic_arch": "architecture_panic",
                "uStack_14": "zero",
                "pm_off": "turn_off_pm",
                "uStack_18": "flag",
                "auto_init": "initialize",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "PTR_main_message",
                "main": "start_main"
            },
            "code": "void kernel_panic_00000f04(kernel_panic_00000f04_t crash_code, char *error_message) {\n  undefined4 flag;\n  undefined4 zero;\n  char *message;\n  kernel_panic_00000f04_t code;\n  message = error_message;\n  code = crash_code;\n  if (*(int *)PTR_crashed_00000f4c == 0) {\n    *(undefined4 *)PTR_crashed_00000f4c = 1;\n    if (crash_code == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(PTR_s_____RIOT_kernel_panic_00000f04___s_00000f50, message);\n    ps();\n    iprintf(PTR_DAT_00000f54);\n    iprintf(PTR_s_____halted__00000f58);\n  }\n  irq_disable();\n  panic_arch();\n  zero = 0xf4d;\n  pm_off();\n  flag = (int)&flag + 1;\n  auto_init();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return;\n}",
            "called": [
                "irq_disable",
                "ps",
                "iprintf",
                "pm_off",
                "panic_arch",
                "cpu_print_last_instruction"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "thread_add_to_list",
                "bus_fault_default",
                "cib_init",
                "fmt_s32_dfp",
                "uart_init",
                "mem_manage_default",
                "debug_mon_default",
                "hard_fault_handler",
                "dummy_handler_default",
                "nmi_default",
                "usage_fault_default"
            ],
            "imported": false,
            "current_name": "kernel_panic_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "get_next_thread_to_run_00000610",
                "uVar1": "bit_index",
                "iVar2": "active_thread_id",
                "iVar3": "next_thread_id",
                "active_thread": "active_thread",
                "nextrq": "nextrq",
                "__m____": "current_node",
                "next_thread": "next_thread"
            },
            "code": "int get_next_thread_to_run_00000610(void)\n{\n    uint bit_index;\n    int active_thread_id;\n    int next_thread_id;\n    thread_t *active_thread;\n    int nextrq;\n    clist_node_t *current_node;\n    thread_t *next_thread;\n\n    *(undefined4 *)PTR_sched_context_switch_request_00000684 = 0;\n    active_thread_id = *(int *)PTR_sched_active_thread_00000688;\n    bit_index = bitarithm_lsb(*(uint *)PTR_runqueue_bitcache_0000068c);\n    next_thread_id = **(int **)(PTR_get_next_thread_to_run_00000610queues_00000690 + bit_index * 4);\n    if (active_thread_id == next_thread_id + -8) {\n        active_thread_id = 0;\n    }\n    else {\n        if ((active_thread_id != 0) && (*(char *)(active_thread_id + 4) == '\t')) {\n            *(undefined *)(active_thread_id + 4) = 10;\n        }\n        *(undefined *)(next_thread_id + -4) = 9;\n        *(undefined2 *)PTR_sched_active_pid_00000694 = *(undefined2 *)(next_thread_id + -2);\n        *(int *)PTR_sched_active_thread_00000688 = next_thread_id + -8;\n        active_thread_id = 1;\n    }\n    return active_thread_id;\n}",
            "called": [
                "bitarithm_lsb"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [
                "isr_svc"
            ],
            "imported": false,
            "current_name": "get_next_thread_to_run_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_phydat_00003694",
                "data": "phydat",
                "dim": "num_dimensions",
                "sVar1": "length",
                "pcVar2": "unit_str",
                "cVar3": "has_prefix",
                "uVar4": "bitmask",
                "bVar5": "has_prefix",
                "num": "num_str",
                "len": "length",
                "scale_prefix": "scale_prefix",
                "i": "i"
            },
            "code": "void display_phydat_00003694(phydat_t *phydat, uint8_t num_dimensions) {\n    size_t length;\n    char *unit_str;\n    char scale_prefix;\n    uint8_t i;\n    \n    if ((phydat == NULL) || (num_dimensions > 3)) {\n        puts(\"Unable to display data object.\");\n    }\n    else {\n        iprintf(\"Data:\\n\");\n        for (i = 0; i < num_dimensions; i++) {\n            if (phydat->unit < 20) {\n                uint bitmask = 1 << phydat->unit;\n                bool has_prefix = bitmask & PHYDAT_UNIT_PREFIXES;\n                if (has_prefix) {\n                    scale_prefix = 0;\n                }\n                else {\n                    scale_prefix = phydat_prefix_from_scale(phydat->scale);\n                }\n            }\n            else {\n                scale_prefix = phydat_prefix_from_scale(phydat->scale);\n            }\n            iprintf(\"%s\", PHYDAT_VALUE_LABEL);\n            if (num_dimensions < 2) {\n                iprintf(\" \");\n            }\n            else {\n                iprintf(\"_%u \", i);\n            }\n            if (scale_prefix == 0) {\n                if (phydat->scale == 0) {\n                    iprintf(\"%d\", phydat->val[i]);\n                }\n                else if ((phydat->scale + 4 < 0 == SCARRY4((int)phydat->scale, 4)) && (phydat->scale < 0)) {\n                    length = fmt_s16_dfp(num, phydat->val[i], phydat->scale);\n                    num[length] = '\\0';\n                    iprintf(\"%s\", num);\n                }\n                else {\n                    iprintf(\"%dE%d\", phydat->val[i], phydat->scale);\n                }\n            }\n            else {\n                iprintf(\"%dm%c\", phydat->val[i], scale_prefix);\n            }\n            unit_str = phydat_unit_to_str(phydat->unit);\n            iprintf(\" %s\\n\", unit_str);\n            phydat++;\n        }\n    }\n}\n",
            "called": [
                "fmt_s16_dfp",
                "phydat_unit_to_str",
                "phydat_prefix_from_scale",
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "write",
                "probe"
            ],
            "imported": false,
            "current_name": "display_phydat_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_and_push_to_tsrb_00002364",
                "rb": "ring_buffer",
                "c": "data",
                "iVar1": "is_full"
            },
            "code": "int check_and_push_to_tsrb_00002364(tsrb_t *ring_buffer, char data){\n  int is_full = tsrb_full(ring_buffer);\n  if (is_full == 0) {\n    _push(ring_buffer, data);\n    return 0;\n  } else {\n    return -1;\n  }\n}",
            "called": [
                "tsrb_full",
                "_push"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "check_and_push_to_tsrb_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "clear_bits_and_wait_until_condition_met_00001ad4",
                "*DAT_00001b08": "data_pointer",
                "*PTR_current_mode_00001b0c": "PTR_current_mode"
            },
            "code": "void clear_bits_and_wait_until_condition_met_00001ad4(void)\n{\n  unsigned char **DAT_00001b08 = DAT_00001b08;\n  **DAT_00001b08 &= 0x3f;\n  while ((*DAT_00001b08[6] & 0xc) != 0xc);\n  **PTR_current_mode_00001b0c_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "clear_bits_and_wait_until_condition_met_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripheral"
            },
            "code": "void initialize_system_00001274(void)\n{\n  initialize_cortexm();\n  *DAT_00001298 |= 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripheral();\n  return;\n}",
            "called": [
                "cortexm_init",
                "kinetis_mcg_init",
                "periph_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "initialize_system_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "read_shell_commands_00002e6c",
                "shell_commands": "shell_commands",
                "line_buf": "line_buffer",
                "len": "buffer_len",
                "print_prompt": "print_shell_prompt",
                "iVar1": "readline_result",
                "res": "handle_input_result",
                "handle_input_line": "handle_input_line"
            },
            "code": "void read_shell_commands_00002e6c(shell_command_t *shell_commands,char *line_buffer,int buffer_len)\n{\n  int readline_result;\n  int handle_input_result;\n  print_shell_prompt();\n  do {\n    readline_result = readline(line_buffer,buffer_len);\n    if (readline_result == 0) {\n      handle_input_result = handle_input_line(shell_commands,line_buffer);\n    }\n    print_shell_prompt();\n  } while( true );\n}",
            "called": [
                "readline",
                "print_prompt",
                "handle_input_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "read_shell_commands_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_rtc_time_or_print_error_00003444",
                "iVar1": "rtc_get_time_result",
                "t": "current_time",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_time_or_print_error_00003444(void)\n{\n  int rtc_get_time_result;\n  tm current_time;\n  rtc_get_time_result = rtc_get_time(&current_time);\n  if (rtc_get_time_result != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(rtc_get_time_result != 0);\n}",
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_time_or_print_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "code": "void reset_system_00003688(void)\n{\n    NVIC_SystemReset();\n    return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "_reboot_handler"
            ],
            "imported": false,
            "current_name": "reset_system_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_bit_at_position_00001392",
                "ptr": "memory_address",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_at_position_00001392(uint32_t *memory_address, uint8_t bit_position)\n{\n    undefined4 *bit_address = (undefined4 *)bitband_addr(memory_address, (uint)bit_position);\n    *bit_address = 1;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "reset_rtc_callback_00002910",
                "DAT_00002944": "initial_dat_value",
                "PTR_rtt_callback_00002948": "PTR_rtt_callback",
                "iVar1": "initial_dat_value",
                "rtt": "not_used",
                "dat_1c": "dat_1c"
            },
            "code": "void reset_rtc_callback_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  uint* dat_1c = (uint*)(DAT_00002944 + 0x1c);\n  *dat_1c &= 0xfffffffb;\n  *(undefined4 *)(DAT_00002944 + 8) = 0;\n  *(undefined4 *)PTR_rtt_callback_00002948_00002948 = 0;\n  *(undefined4 *)(PTR_rtt_callback_00002948_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "rtc_clear_alarm"
            ],
            "imported": false,
            "current_name": "reset_rtc_callback_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "read_character_00004418",
                "iVar1": "impure_ptr_value",
                "_getc_r": "read_character_from_stream"
            },
            "code": "int read_character_00004418(void)\n{\n  int impure_ptr_value;\n  impure_ptr_value = *(int *)PTR__impure_ptr_00004438;\n  if ((impure_ptr_value != 0) && (*(int *)(impure_ptr_value + 0x18) == 0)) {\n    __sinit(impure_ptr_value);\n  }\n  int character = _getc_r(impure_ptr_value,*(undefined4 *)(impure_ptr_value + 4));\n  return character;\n}\n",
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "readline"
            ],
            "imported": false,
            "current_name": "read_character_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "set_priorities_and_flags_0000258c",
                "i": "index"
            },
            "code": "void set_priorities_and_flags_0000258c(void)\n{\n  uint32_t index;\n\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  NVIC_SetPriority(PendSV_IRQn, 1);\n  NVIC_SetPriority(SVCall_IRQn, 1);\n  for (index = 0; index < 0x66; index++) {\n    NVIC_SetPriority((IRQn_Type)index, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "set_priorities_and_flags_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c": "character_to_print"
            },
            "code": "void print_character_00002a00(int character_to_print)\n{\n  putchar(character_to_print);\n  return;\n}",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "readline",
                "print_prompt"
            ],
            "imported": false,
            "current_name": "print_character_00002a00"
        },
        "FUN_00000a64": {
            "renaming": {
                "FUN_00000a64": "handle_hard_fault_exception_00000a64",
                "sp": "stack_ptr",
                "corrupted": "is_corrupted_stack",
                "unaff_r4": "register4",
                "unaff_r5": "register5",
                "unaff_r6": "register6",
                "unaff_r7": "register7",
                "unaff_r8": "register8",
                "unaff_r9": "register9",
                "unaff_r10": "register10",
                "unaff_r11": "register11",
                "in_lr": "link_register",
                "PTR__eram_00000aa0": "PTR_eram",
                "&stack0x00000000": "stack0",
                "DAT_00000a9c": "DAT_a9c",
                "PTR_heap_top_00000aa4": "PTR_heap_top"
            },
            "code": "void handle_hard_fault_exception_00000a64(uint32_t *main_stack_ptr, uint32_t corrupted_stack, uint32_t link_register, uint32_t *heap_top_ptr) {\n  uint32_t *stack_ptr;\n  uint32_t is_corrupted_stack = 0;\n  if ((PTR__eram_00000aa0 < &stack0x00000000) || (&stack0x00000000 <= DAT_00000a9c)) {\n    is_corrupted_stack = 1;\n    heap_top_ptr = (BADSPACEBASE *)PTR_heap_top_00000aa4_00000aa4;\n  }\n  stack_ptr = ((link_register & 4) == 0) ? main_stack_ptr : (uint32_t *)getProcessStackPointer();\n  *(heap_top_ptr - 1) = unaff_r11;\n  *(heap_top_ptr - 2) = unaff_r10;\n  *(heap_top_ptr - 3) = unaff_r9;\n  *(heap_top_ptr - 4) = unaff_r8;\n  *(heap_top_ptr - 5) = unaff_r7;\n  *(heap_top_ptr - 6) = unaff_r6;\n  *(heap_top_ptr - 7) = unaff_r5;\n  *(heap_top_ptr - 8) = unaff_r4;\n  hard_fault_handler(stack_ptr, is_corrupted_stack, link_register, heap_top_ptr - 8);\n}",
            "called": [
                "hard_fault_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a64",
            "calling": [],
            "imported": false,
            "current_name": "handle_hard_fault_exception_00000a64"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "process_items_000043a0",
                "param_1": "starting_address",
                "param_2": "callback_func",
                "piVar2": "current_item",
                "uVar4": "result",
                "iVar5": "item_count",
                "iVar3": "item_data",
                "uVar1": "callback_result"
            },
            "code": "uint process_items_000043a0(int starting_address, code *callback_func) {\n  uint result = 0;\n  int *current_item = (int *)(starting_address + 0x48);\n  do {\n    int item_count = current_item[1];\n    int item_data = current_item[2];\n    while (item_count > 0) {\n      if ((*(ushort *)(item_data + 0xc) > 1) && (*(short *)(item_data + 0xe) != -1)) {\n        uint callback_result = (*callback_func)(item_data);\n        result |= callback_result;\n      }\n      item_data += 0x68;\n      item_count--;\n    }\n    current_item = (int *)*current_item;\n  } while (current_item != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "__srefill_r"
            ],
            "imported": false,
            "current_name": "process_items_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_thread_information_0000211c",
                "queued_name": "queued_name",
                "overall_used": "overall_used",
                "overall_stacksz": "overall_stacksz",
                "PTR_s__pid_____21s____9sQ___pri___stac_00002250": "\"PID\\tSTATE\\tPRI\\tSTACK\\n\"",
                "PTR_DAT_0000224c": "PTR_DAT_0000224c",
                "PTR_s_state_00002248": "PTR_s_state_00002248",
                "thread_isr_stack_usage": "thread_isr_stack_usage",
                "thread_isr_stack_start": "thread_isr_stack_start",
                "thread_isr_stack_pointer": "thread_isr_stack_pointer",
                "PTR_s______isr_stack______________6i___00002254": "\"ISR_STACK\\t%d\\t0x%p\\t0x%p\\n\"",
                "PTR_sched_threads_00002258": "PTR_sched_threads_00002258",
                "NULL": "NULL",
                "byte": "byte",
                "state_names": "state_names",
                "thread_t": "thread_t",
                "stack_size": "stack_size",
                "PTR_state_names_0000225c": "PTR_state_names_0000225c",
                "thread_measure_stack_free": "thread_measure_stack_free",
                "stack_used": "stack_used",
                "PTR_s___3hi_____20s_____8s___1s____3i___00002260": "\"%d\\t%s\\t%d\\t%d\\n\"",
                "PTR_s___5s___21s__13s_6s__6i___5i__0000226c": "\"OVERALL_STACK\\t%d\\t%d\\n\"",
                "i": "i",
                "state": "state",
                "queued": "queued",
                "sname": "sname",
                "p": "p",
                "isr_sp": "isr_sp",
                "isr_start": "isr_start",
                "isr_usage": "isr_usage"
            },
            "code": "void print_thread_information_0000211c(void)\n{\n  char queued_name[2] = {0x51, 0x5f};\n  int overall_used = 0;\n  int overall_stacksz = 0x200;\n  iprintf(PTR_s__pid_____21s____9sQ___pri___stac_00002250);\n  int isr_stack_usage = thread_isr_stack_usage();\n  void *isr_stack_start = thread_isr_stack_start();\n  void *isr_stack_pointer = thread_isr_stack_pointer();\n  iprintf(PTR_s______isr_stack______________6i___00002254, 0x200, isr_stack_usage, isr_stack_start, isr_stack_pointer);\n  for (int i = 1; i < 0x21; i++) {\n    thread_t *thread = *(thread_t **)(PTR_sched_threads_00002258 + i * 4);\n    if (thread != NULL) {\n      byte state = *(byte *)(thread + 1);\n      char *state_name = (char *)(PTR_state_names_0000225c + state * 4);\n      int stack_size = thread[0xb];\n      overall_stacksz += stack_size;\n      uintptr_t stack_free = thread_measure_stack_free((char *)thread[9]);\n      int stack_used = stack_size - stack_free;\n      overall_used += stack_used;\n      iprintf(PTR_s___3hi_____20s_____8s___1s____3i___00002260, *(short *)((int)thread + 6), state_name, thread[10], queued_name + (state > 8), state, stack_size, stack_used, thread[9], *thread);\n    }\n  }\n  iprintf(PTR_s___5s___21s__13s_6s__6i___5i__0000226c, overall_stacksz, overall_used);\n}",
            "called": [
                "thread_isr_stack_pointer",
                "thread_isr_stack_start",
                "iprintf",
                "thread_isr_stack_usage",
                "thread_measure_stack_free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "_ps_handler",
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_thread_information_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "lock",
                "param_2": "name",
                "param_3": "index",
                "puVar2": "env_var_ptr",
                "ppcVar3": "env_ptr_iter",
                "iVar4": "compare_result",
                "pcVar5": "env_value",
                "ppcVar6": "env_ptr_iter_next",
                "__n": "name_length",
                "cVar1": "current_char"
            },
            "code": "char* find_environment_variable_0000562c(int lock, char* name, int* index) {\n  char current_char;\n  char** env_ptr;\n  int name_length;\n  char* env_value;\n  char** env_ptr_iter;\n  size_t ptr_diff;\n\n  __env_lock();\n  env_ptr = PTR_environ_0000569c;\n  if (*env_ptr != NULL) {\n    do {\n      current_char = *name;\n      if (current_char == '\\0') {\n        name_length = (int)name - (int)env_value;\n        env_ptr_iter = *env_ptr;\n        while (*env_ptr_iter != NULL) {\n          if (strncmp(*env_ptr_iter, env_value, name_length) == 0) {\n            if ((*env_ptr_iter)[name_length] == '=') {\n              ptr_diff = (int)env_ptr_iter - *(int*)env_ptr;\n              *index = ptr_diff >> 2;\n              __env_unlock(lock);\n              return *env_ptr_iter + name_length + 1;\n            }\n          }\n          env_ptr_iter++;\n        }\n        break;\n      }\n      name++;\n    } while (current_char != '=');\n  }\n  __env_unlock(lock);\n  return NULL;\n}",
            "called": [
                "__env_unlock",
                "strncmp",
                "__env_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "_getenv_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "handle_irq_000020b8",
                "DAT_000020c8": "data_ptr"
            },
            "code": "void handle_irq_000020b8(void)\n{\n  irq_handler(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "handle_shell_command_00002a18",
                "command_list": "command_list",
                "command": "command",
                "iVar1": "comparison_result",
                "command_lists": "command_lists",
                "i": "i",
                "entry": "current_entry"
            },
            "code": "shell_command_handler_t handle_shell_command_00002a18(shell_command_t *command_list, char *command) {\n  int comparison_result;\n  shell_command_t *command_lists[2];\n  uint i = 0;\n  shell_command_t *current_entry;\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002a84;\n  while (i < 2) {\n    current_entry = command_lists[i];\n    if (current_entry != NULL) {\n      while (current_entry->name != NULL) {\n        comparison_result = strcmp(current_entry->name, command);\n        if (comparison_result == 0) {\n          return current_entry->handler;\n        }\n        current_entry++;\n      }\n    }\n    i++;\n  }\n  return NULL;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "handle_shell_command_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "process_input_and_return_status_code_000054a8",
                "param_1": "output_status",
                "param_2": "input_stream",
                "uVar1": "flags",
                "uVar2": "temp_flags",
                "uVar3": "status_code",
                "uVar4": "temp_status_code",
                "iVar5": "impure_ptr"
            },
            "code": "uint process_input_and_return_status_code_000054a8(undefined4 *output_status, undefined4 *input_stream) {\n  ushort flags;\n  uint status_code;\n  uint temp_status_code;\n  int impure_ptr = *(int *)PTR__impure_ptr_00005574;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (input_stream == (undefined4 *)PTR___sf_fake_stdin_00005578) {\n    input_stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (input_stream == (undefined4 *)PTR___sf_fake_stdout_0000557c) {\n    input_stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (input_stream == (undefined4 *)PTR___sf_fake_stderr_00005580) {\n    input_stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  status_code = (uint)*(ushort *)(input_stream + 3);\n  flags = *(ushort *)(input_stream + 3);\n  if (-1 < (int)(status_code << 0x1c)) {\n    if (-1 < (int)(status_code << 0x1b)) {\n      *output_status = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(status_code << 0x1d) < 0) {\n      if ((undefined4 *)input_stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_stream[0xd] != input_stream + 0x11) {\n          _free_r(output_status);\n        }\n        input_stream[0xd] = 0;\n      }\n      *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) & 0xffdb;\n      input_stream[1] = 0;\n      *input_stream = input_stream[4];\n    }\n    *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) | 8;\n  }\n  if ((input_stream[4] == 0) && ((*(ushort *)(input_stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_status, input_stream);\n  }\n  temp_status_code = (uint)flags;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)(temp_status_code << 0x1e)) {\n      temp_status_code = input_stream[5];\n    }\n    input_stream[2] = temp_status_code;\n  }\n  else {\n    input_stream[2] = 0;\n    input_stream[6] = -input_stream[5];\n  }\n  if (input_stream[4] != 0) {\n    return 0;\n  }\n  if ((flags & 0x80) == 0) {\n    return temp_status_code & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(input_stream + 3) = flags | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "_puts_r",
                "__swbuf_r",
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "process_input_and_return_status_code_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "create_thread_stack_000007dc",
                "task_func": "thread_task_func",
                "arg": "thread_arg",
                "stack_start": "thread_stack_start",
                "stack_size": "thread_stack_size",
                "uVar1": "stack_alignment",
                "stk": "stack_top",
                "i_1": "loop_counter_1",
                "i": "loop_counter_2"
            },
            "code": "char * create_thread_stack_000007dc(thread_task_func_t task_func, void *arg, void *stack_start, int stack_size) {\n  uint32_t *stack_top;\n  uint32_t *stack_ptr;\n  uint32_t stack_alignment = ((uint32_t)stack_start + stack_size) & 0xfffffffc;\n  stack_top = (uint32_t *)(stack_alignment - sizeof(uint32_t));\n  *stack_top = 0x77777777;\n  if (((uint32_t)stack_top & 7) != 0) {\n    stack_top--;\n    *stack_top = 0x88888888;\n  }\n  stack_top--;\n  *stack_top = 0x1000000;\n  stack_top--;\n  *stack_top = (uint32_t)task_func;\n  stack_top--;\n  *stack_top = DAT_000008b4;\n  stack_ptr = stack_top - 1;\n  *stack_ptr = 0;\n  for (int i = 3; i > 0; i--) {\n    stack_ptr--;\n    *stack_ptr = i;\n  }\n  stack_ptr--;\n  *stack_ptr = (uint32_t)arg;\n  for (int i = 0xb; i > 3; i--) {\n    stack_ptr--;\n    *stack_ptr = i;\n  }\n  stack_top--;\n  *stack_top = 0xfffffffd;\n  return (char *)stack_top;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "create_thread_stack_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_bit_at_position_00001710",
                "ptr": "data_ptr",
                "bit": "bit_position",
                "puVar1": "bit_memory_address"
            },
            "code": "void clear_bit_at_position_00001710(uint8_t *data_ptr, uint8_t bit_position)\n{\n  undefined *bit_memory_address = (undefined *)bitband_addr(data_ptr, (uint)bit_position);\n  *bit_memory_address = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_00001710"
        },
        "FUN_000045ea": {
            "renaming": {
                "FUN_000045ea": "do_nothing_000045ea"
            },
            "code": "\nvoid do_nothing_000045ea(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ea",
            "calling": [
                "__tz_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ea"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "_puts_r",
                "__sinit_lock_release",
                "__env_unlock",
                "__malloc_unlock",
                "_fflush_r",
                "__sfp_lock_release",
                "_vfprintf_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list_entry": "current_thread",
                "__m____": "new_node",
                "local_1c": "current_node",
                "my_prio": "thread_priority"
            },
            "code": "void insert_thread_into_list_00001034(list_node_t *list, thread_t *thread) {\n  list_node_t *current_node;\n  thread_t *current_thread;\n  list_node_t *new_node;\n  uint16_t thread_priority;\n\n  if (thread->status < 9) {\n    current_node = list;\n    while ((current_node->next != NULL && current_node->next->priority <= thread->priority)) {\n      current_node = current_node->next;\n    }\n    thread->rq_entry.next = current_node->next;\n    current_node->next = &thread->rq_entry;\n    return;\n  }\n\n  core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000109c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "insert_thread_into_list_00001034"
        },
        "FUN_000055ac": {
            "renaming": {
                "FUN_000055ac": "read_byte_000055ac",
                "param_1": "stream_id",
                "param_2": "stream",
                "uVar1": "byte_read",
                "pbVar2": "current_byte"
            },
            "code": "uint read_byte_000055ac(int stream_id, byte **stream){\n  uint byte_read;\n  byte *current_byte;\n  if ((stream_id != 0) && (*(int *)(stream_id + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (byte **)PTR___sf_fake_stdin_00005620) {\n    stream = *(byte ***)(stream_id + 4);\n  }\n  else if (stream == (byte **)PTR___sf_fake_stdout_00005624) {\n    stream = *(byte ***)(stream_id + 8);\n  }\n  else if (stream == (byte **)PTR___sf_fake_stderr_00005628) {\n    stream = *(byte ***)(stream_id + 0xc);\n  }\n  if ((-1 < (int)stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  current_byte = stream[1];\n  stream[1] = current_byte - 1;\n  if ((int)(current_byte - 1) < 0) {\n    byte_read = __srget_r(stream_id, stream);\n  }\n  else {\n    current_byte = *stream;\n    *stream = current_byte + 1;\n    byte_read = (uint)*current_byte;\n  }\n  if ((-1 < (int)stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream[0x16]);\n  }\n  return byte_read;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__srget_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000055ac",
            "calling": [
                "getchar"
            ],
            "imported": false,
            "current_name": "read_byte_000055ac"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_new_value_00006964",
                "param_1": "initial_value",
                "param_2": "pointer_offset",
                "iVar1": "new_value"
            },
            "code": "int calculate_new_value_00006964(undefined4 initial_value,int pointer_offset)\n{\n  int new_value;\n  \n  new_value = *(int *)(pointer_offset + -4) + -4;\n  if (*(int *)(pointer_offset + -4) < 0) {\n    new_value = new_value + *(int *)(pointer_offset + new_value);\n  }\n  return new_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_new_value_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_bits_and_set_flag_0000182c",
                "tmp": "flag",
                "DAT_000018b4": "data_ptr",
                "DAT_000018b8": "flag_ptr"
            },
            "code": "void clear_bits_and_set_flag_0000182c(void)\n{\n  uint8_t flag = 0x01;\n  uint8_t* DAT_000018b4 = DAT_000018b4;\n  uint8_t* DAT_000018b8 = DAT_000018b8;\n  DAT_000018b4[8] &= 0xd0;\n  *DAT_000018b8 |= flag;\n  bit_clear8(DAT_000018b4, flag);\n  bit_clear8(DAT_000018b4, 0x00);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "clear_bits_and_set_flag_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "calculate_length_00004db8",
                "__s": "input_string",
                "iVar1": "length",
                "_FUN_00004db8_r": "calculate_length_recursive"
            },
            "code": "int calculate_length_00004db8(char* input_string)\n{\n  int length;\n  length = calculate_length_00004db8_recursive(*(undefined4 *)PTR__impure_ptr_00004dc4, input_string);\n  return length;\n}",
            "called": [
                "_puts_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "phydat_dump",
                "_rtc_setalarm",
                "_rtc_usage",
                "write",
                "list",
                "main",
                "read",
                "print_help",
                "_rtc_settime",
                "probe_all",
                "_rtc_getalarm",
                "_rtc_gettime",
                "hard_fault_handler",
                "_alarm_handler",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "calculate_length_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "read_next_byte_000022f0",
                "rb": "ring_buffer",
                "uVar1": "current_read_position",
                "PTR_read": "ring_buffer->buf",
                "DAT_0000232c": "buffer_index",
                "reads": "ring_buffer->reads",
                "size": "ring_buffer->size"
            },
            "code": "char read_next_byte_000022f0(tsrb_t *ring_buffer)\n{\n    uint32_t current_read_position = ring_buffer->reads;\n    ring_buffer->reads = current_read_position + 1;\n    uint32_t DAT_0000232c = current_read_position & (ring_buffer->size - 1);\n    return PTR_read[DAT_0000232c];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "read_next_byte_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "set_up_clocks_00001c84",
                "irq_disable": "disable_interrupts",
                "kinetis_mcg_set_safe_mode": "set_safe_mode",
                "DAT_00001ce8": "PTR_CLOCK_SETUP",
                "uint": "unsigned int",
                "DAT_00001cec": "PTR_CLOCK_SETUP_2",
                "set_up_mcgirclk": "set_up_mcgirclk",
                "set_up_erclk32k": "set_up_erclk32k",
                "kinetis_mcg_set_mode": "set_up_mode",
                "KINETIS_MCG_MODE_PEE": "MODE_PEE",
                "irq_restore": "restore_interrupts"
            },
            "code": "void set_up_clocks_00001c84(void)\n{\n  uint state;\n  uint mask;\n  state = disable_interrupts();\n  set_safe_mode();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[0xc] = 0;\n  *DAT_00001cec = *DAT_00001cec & 199 | 0x38;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  set_up_mcgirclk();\n  set_up_erclk32k();\n  set_up_mode(KINETIS_MCG_MODE_PEE);\n  restore_interrupts(state);\n  return;\n}",
            "called": [
                "kinetis_mcg_init_erclk32k",
                "irq_disable",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "set_up_clocks_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_flash_config_buffer_000068f0",
                "param_1": "size",
                "param_2": "buffer",
                "pvVar1": "new_buffer",
                "__n": "field_ptr",
                "PTR_FLASH_CONFIGURATION_FIELD": "flash_configuration_field",
                "DAT_00000046": "field_data_1",
                "DAT_00000045": "field_data_2",
                "DAT_00000011": "field_data_3",
                "PTR_DAT_0000004c": "flash_config_buffer",
                "DAT_0000004c": "old_buffer",
                "DAT_00000050": "old_size"
            },
            "code": "undefined4 allocate_flash_config_buffer_000068f0(size_t size, void **buffer)\n{\n  void *new_buffer;\n  void *DAT_0000004c;\n  void *field_ptr;\n  size_t DAT_00000050;\n  \n  if ((void **)buffer[13] == buffer + 17) {\n    new_buffer = (void *)malloc(size, 0x400);\n    if (new_buffer != (void *)0x0) {\n      field_ptr = PTR_FLASH_CONFIGURATION_FIELD;\n      DAT_0000004c = buffer[13];\n      *(undefined *)((int)new_buffer + 0x3ff) = *(undefined *)((int)buffer + 0x46);\n      *(undefined *)((int)new_buffer + 0x3fe) = *(undefined *)((int)buffer + 0x45);\n      *(undefined *)((int)new_buffer + 0x3fd) = *(undefined *)(buffer + 0x11);\n      buffer[14] = field_ptr;\n      buffer[13] = new_buffer;\n      *buffer = (void *)((int)new_buffer + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    DAT_00000050 = (size_t)buffer[14];\n    DAT_0000004c = buffer[13];\n    new_buffer = (void *)realloc(size, DAT_0000004c, (void *)((int)DAT_00000050 << 1));\n    if (new_buffer != (void *)0x0) {\n      memcpy((void *)((int)new_buffer + (int)DAT_00000050), DAT_0000004c, DAT_00000050);\n      buffer[13] = new_buffer;\n      buffer[14] = (void *)((int)DAT_00000050 << 1);\n      *buffer = (void *)((int)new_buffer + (int)DAT_00000050);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_realloc_r",
                "memcpy",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [
                "_sungetc_r"
            ],
            "imported": false,
            "current_name": "allocate_flash_config_buffer_000068f0"
        }
    },
    "used_tokens": 210539,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000ca0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00004cdc",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00004e8c",
            "FUN_00005584",
            "FUN_00000cb0",
            "FUN_00004248",
            "FUN_00000f5c",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_0000423c",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_000005ca",
            "FUN_000043da",
            "FUN_00005ff8",
            "FUN_00006754",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00004f80",
            "FUN_00005fec",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000004d4",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00004dea",
            "FUN_00005edc",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00000aa8",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00004298",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00005d80",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_00000f80",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_00000958",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00000c80",
            "FUN_00000a40",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_000022be",
            "FUN_00003dc4",
            "FUN_00002108",
            "FUN_00000c90",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00006118",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00005fd4",
            "FUN_00004dc8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004e4a",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_000004b2",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000978",
            "FUN_000018bc",
            "FUN_00000974",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_00000a64",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_000055ac",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_000022f0",
            "FUN_000068f0"
        ],
        [
            "FUN_00000dc0",
            "FUN_00005100",
            "FUN_000041d0",
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00004f84",
            "FUN_00001eea",
            "FUN_0000305c",
            "FUN_000013b8",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_00005fd8",
            "FUN_00005780",
            "FUN_00000f04",
            "FUN_00004db8",
            "FUN_00001c84"
        ],
        [
            "FUN_0000058e"
        ],
        [
            "FUN_00004248",
            "FUN_00002b10",
            "FUN_00006118"
        ],
        [
            "FUN_00006118"
        ]
    ],
    "locked_functions": []
}