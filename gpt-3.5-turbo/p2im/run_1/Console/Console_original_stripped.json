{
    "functions": {
        "FUN_00000410": {
            "entrypoint": "0x00000410",
            "current_name": "initialize_uart_00000410",
            "code": "\nint initializeUART_00000410(EVP_PKEY_CTX *context)\n\n{\n  uart_stdio_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_00000410": "initialize_uart_00000410",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "uart_stdio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000041c": {
            "entrypoint": "0x0000041c",
            "current_name": "FUNC_0000041c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0000041c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000041c": "FUNC_0000041c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000428": {
            "entrypoint": "0x00000428",
            "current_name": "expand_heap_00000428",
            "code": "\nvoid * expandHeap_00000428(_reentranteent *reentrant,ptreentrantdiff_t increment)\n\n{\n  uint disabled_interrupt_state;\n  ptreentrantdiff_t local_increment;\n  _reentranteent *local_reentrant;\n  uint interrupt_state;\n  void *result;\n  \n  disabled_interrupt_state = ireentrantq_disable();\n  result = heap_top;\n  if ((&_ereentrantam < heap_top + increment) || (heap_top + increment < &_sheap)) {\n    reentrant->_ereentrantreentrantno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    heap_top = heap_top + increment;\n  }\n  ireentrantq_resulttoreentrante(disabled_interrupt_state);\n  reentrantetureentrantn result;\n}\n\n",
            "renaming": {
                "FUN_00000428": "expand_heap_00000428",
                "r": "reentrant",
                "incr": "increment",
                "state_00": "disabled_interrupt_state",
                "incr_local": "local_increment",
                "r_local": "local_reentrant",
                "state": "interrupt_state",
                "res": "result"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "irq_restore",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000490": {
            "entrypoint": "0x00000490",
            "current_name": "read_from_uart_00000490",
            "code": "\n_ssize_t read_from_uart_00000490(_reenteent *reent,int fd,void *input_buffer,size_t buffer_size)\n\n{\n  int read_result;\n  size_t local_buffer_size;\n  void *local_buffer;\n  int local_file_descriptor;\n  _reenteent *local_reent;\n  \n  read_result = uareentt_stdio_reentead((chareent *)input_buffer,buffer_size);\n  reentetureentn read_result;\n}\n\n",
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent",
                "buffer": "input_buffer",
                "count": "buffer_size",
                "count_local": "local_buffer_size",
                "buffer_local": "local_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent",
                "iVar1": "read_result"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "uart_stdio_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004b2": {
            "entrypoint": "0x000004b2",
            "current_name": "write_to_uart_000004b2",
            "code": "\n_ssize_t write_to_uart_000004b2(_reent_ptreent *reent_ptr,int fd,void *data_ptr,size_t data_size)\n\n{\n  int write_result;\n  size_t local_data_size;\n  void *local_data_ptr;\n  int local_file_descriptor;\n  _reent_ptreent *local_reent_ptr;\n  \n  write_result = uareent_ptrt_stdio_wreent_ptrite((chareent_ptr *)data_ptr,data_size);\n  reent_ptretureent_ptrn write_result;\n}\n\n",
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reent_ptr",
                "data": "data_ptr",
                "count": "data_size",
                "count_local": "local_data_size",
                "data_local": "local_data_ptr",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent_ptr",
                "iVar1": "write_result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_stdio_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004d4": {
            "entrypoint": "0x000004d4",
            "current_name": "set_file_error_status_000004d4",
            "code": "\nint setFileErrorStatus_000004d4(_reent *r,int fd)\n\n{\n  int localFileDescriptor;\n  _reent *r_local;\n  \n  r->_errno = 0x13;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000004d4": "set_file_error_status_000004d4",
                "fd_local": "localFileDescriptor"
            },
            "calling": [
                "__sclose"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004f2": {
            "entrypoint": "0x000004f2",
            "current_name": "FUNC_000004f2",
            "code": "\n_off_t FUNC_000004f2(_reent *r,int fd,_off_t pos,int dir)\n\n{\n  int dir_local;\n  _off_t pos_local;\n  int fd_local;\n  _reent *r_local;\n  \n  r->_errno = 0x13;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000004f2": "FUNC_000004f2"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000514": {
            "entrypoint": "0x00000514",
            "current_name": "set_stat_error_00000514",
            "code": "\nint setStatError_00000514(_reentStructeent *reentStruct,int fd,statStructat *statStruct)\n\n{\n  statStructat *localStat;\n  int localFileDescriptor;\n  _reentStructeent *localReent;\n  \n  reentStruct->_ereentStructreentStructno = 0x13;\n  reentStructetureentStructn -1;\n}\n\n",
            "renaming": {
                "FUN_00000514": "set_stat_error_00000514",
                "r": "reentStruct",
                "st": "statStruct",
                "st_local": "localStat",
                "fd_local": "localFileDescriptor",
                "r_local": "localReent"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000534": {
            "entrypoint": "0x00000534",
            "current_name": "check_file_descriptor_00000534",
            "code": "\nint checkFileDescriptor_00000534(_reenteent *reent,int fd)\n\n{\n  int isValid;\n  int fileDescriptorLocal;\n  _reenteent *reentLocal;\n  \n  reent->_ereentreentno = 0;\n  if (((fd == 0) || (fd == 1)) || (fd == 2)) {\n    isValid = 1;\n  }\n  else {\n    isValid = 0;\n  }\n  reentetureentn isValid;\n}\n\n",
            "renaming": {
                "FUN_00000534": "check_file_descriptor_00000534",
                "r": "reent",
                "fd_local": "fileDescriptorLocal",
                "r_local": "reentLocal",
                "iVar1": "isValid"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000566": {
            "entrypoint": "0x00000566",
            "current_name": "convert_to_uint32_00000566",
            "code": "\nuint convertToUint32_00000566(uint inputValue)\n\n{\n  byte byte1;\n  byte byte2;\n  byte byte3;\n  byte byte4;\n  uint result;\n  uint localValue;\n  \n  byte2 = (byte)inputValue;\n  byte3 = (byte)(inputValue >> 8);\n  byte4 = (byte)(inputValue >> 0x10);\n  byte1 = (byte)(inputValue >> 0x18);\n  result = LZCOUNT((uint)(byte)((((((((byte2 & 1) << 1 | byte2 >> 1 & 1) << 1 | byte2 >> 2 & 1) << 1\n                                  | byte2 >> 3 & 1) << 1 | byte2 >> 4 & 1) << 1 | byte2 >> 5 & 1) <<\n                                1 | byte2 >> 6 & 1) << 1 | byte2 >> 7) << 0x18 |\n                  (uint)(byte)((((((((byte3 & 1) << 1 | byte3 >> 1 & 1) << 1 | byte3 >> 2 & 1) << 1\n                                  | byte3 >> 3 & 1) << 1 | byte3 >> 4 & 1) << 1 | byte3 >> 5 & 1) <<\n                                1 | byte3 >> 6 & 1) << 1 | byte3 >> 7) << 0x10 |\n                  (uint)(byte)((((((((byte4 & 1) << 1 | byte4 >> 1 & 1) << 1 | byte4 >> 2 & 1) << 1\n                                  | byte4 >> 3 & 1) << 1 | byte4 >> 4 & 1) << 1 | byte4 >> 5 & 1) <<\n                                1 | byte4 >> 6 & 1) << 1 | byte4 >> 7) << 8 |\n                  (uint)(byte)((((((((byte1 & 1) << 1 | byte1 >> 1 & 1) << 1 | byte1 >> 2 & 1) << 1\n                                  | byte1 >> 3 & 1) << 1 | byte1 >> 4 & 1) << 1 | byte1 >> 5 & 1) <<\n                                1 | byte1 >> 6 & 1) << 1 | byte1 >> 7));\n  if (inputValue == 0) {\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000566": "convert_to_uint32_00000566",
                "v": "inputValue",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "uVar5": "result",
                "v_local": "localValue"
            },
            "calling": [
                "sched_run"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000058e": {
            "entrypoint": "0x0000058e",
            "current_name": "insert_node_into_circular_list_0000058e",
            "code": "\nvoid insertNodeIntoCircularList_0000058e(chead_node_t *head,chead_node_t *nodeToInsert)\n\n{\n  chead_node_t *newNodeNext;\n  chead_node_t *currentNode;\n  \n  if (head->next == (head_node *)0x0) {\n    nodeToInsert->next = nodeToInsert;\n  }\n  else {\n    nodeToInsert->next = head->next->next;\n    head->next->next = nodeToInsert;\n  }\n  head->next = nodeToInsert;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000058e": "insert_node_into_circular_list_0000058e",
                "list": "head",
                "new_node": "nodeToInsert",
                "new_node_local": "newNodeNext",
                "list_local": "currentNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000005ca": {
            "entrypoint": "0x000005ca",
            "current_name": "remove_next_node_000005ca",
            "code": "\ncinputList_node_t * removeNextNode_000005ca(cinputList_node_t *inputList)\n\n{\n  inputList_node *removedNode;\n  cinputList_node_t *localList;\n  cinputList_node_t *firstNode;\n  \n  if (inputList->next == (inputList_node *)0x0) {\n    removedNode = (inputList_node *)0x0;\n  }\n  else {\n    removedNode = inputList->next->next;\n    if (removedNode == inputList->next) {\n      inputList->next = (inputList_node *)0x0;\n    }\n    else {\n      inputList->next->next = removedNode->next;\n    }\n  }\n  return removedNode;\n}\n\n",
            "renaming": {
                "FUN_000005ca": "remove_next_node_000005ca",
                "list": "inputList",
                "list_local": "localList",
                "first": "firstNode",
                "plVar1": "removedNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000610": {
            "entrypoint": "0x00000610",
            "current_name": "perform_context_switch_00000610",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint performContextSwitch_00000610(void)\n\n{\n  thread_t *previousThread;\n  uint lsbBitIndex;\n  list_node *currentRunqueueNode;\n  int contextSwitchPerformed;\n  thread_t *currentThread;\n  int nextRunqueue;\n  clist_node_t *unusedNode;\n  thread_t *nextThread;\n  \n  previousThread = sched_currentThread;\n  sched_context_switch_request = 0;\n  lsbBitIndex = bitarithm_lsb(runqueue_bitcache);\n  currentRunqueueNode = (sched_runqueues[lsbBitIndex].next)->next;\n  if (previousThread == (thread_t *)(currentRunqueueNode + -2)) {\n    contextSwitchPerformed = 0;\n  }\n  else {\n    if ((previousThread != (thread_t *)0x0) && (previousThread->status == '\\t')) {\n      previousThread->status = '\\n';\n    }\n    *(undefined *)&currentRunqueueNode[-1].next = 9;\n    sched_active_pid = *(kernel_pid_t *)((int)&currentRunqueueNode[-1].next + 2);\n    contextSwitchPerformed = 1;\n    sched_currentThread = (thread_t *)(currentRunqueueNode + -2);\n  }\n  return contextSwitchPerformed;\n}\n\n",
            "renaming": {
                "FUN_00000610": "perform_context_switch_00000610",
                "ptVar1": "previousThread",
                "uVar2": "lsbBitIndex",
                "plVar3": "currentRunqueueNode",
                "iVar4": "contextSwitchPerformed",
                "active_thread": "currentThread",
                "nextrq": "nextRunqueue",
                "__m____": "unusedNode",
                "next_thread": "nextThread"
            },
            "calling": [
                "isr_svc"
            ],
            "called": [
                "bitarithm_lsb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000698": {
            "entrypoint": "0x00000698",
            "current_name": "update_thread_status_00000698",
            "code": "\nvoid updateThreadStatus_00000698(thread_t *thread,uint newStatus)\n\n{\n  uint newStatus_local;\n  thread_t *newThread_local;\n  \n  if (newStatus < 9) {\n    if ((8 < thread->newStatus) &&\n       (clist_lpop(sched_runqueues + thread->priority),\n       sched_runqueues[thread->priority].next == (list_node *)0x0)) {\n      runqueue_bitcache = runqueue_bitcache & ~(1 << thread->priority);\n    }\n  }\n  else if (thread->newStatus < 9) {\n    clist_rpush(sched_runqueues + thread->priority,&thread->rq_entry);\n    runqueue_bitcache = runqueue_bitcache | 1 << thread->priority;\n  }\n  thread->newStatus = (uint8_t)newStatus;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000698": "update_thread_status_00000698",
                "process": "thread",
                "status": "newStatus",
                "status_local": "newStatus_local",
                "process_local": "newThread_local"
            },
            "calling": [
                "mutex_unlock",
                "thread_create",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [
                "clist_rpush",
                "clist_lpop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000738": {
            "entrypoint": "0x00000738",
            "current_name": "ensure_priority_inversion_00000738",
            "code": "\nvoid ensure_priority_inversion_00000738(uint16_t new_prio)\n\n{\n  int iVar1;\n  uint16_t new_prio_local;\n  uint16_t current_thread_prio;\n  thread_t *active_thread_ptr;\n  int is_on_runqueue;\n  \n  if ((sched_active_thread_ptr->status < 9) || (new_prio < sched_active_thread_ptr->priority)) {\n    iVar1 = irq_is_in();\n    if (iVar1 == 0) {\n      thread_yield_higher();\n    }\n    else {\n      sched_context_switch_request = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000738": "ensure_priority_inversion_00000738",
                "other_prio": "new_prio",
                "other_prio_local": "new_prio_local",
                "current_prio": "current_thread_prio",
                "active_thread": "active_thread_ptr",
                "on_runqueue": "is_on_runqueue"
            },
            "calling": [
                "mutex_unlock",
                "thread_create"
            ],
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000794": {
            "entrypoint": "0x00000794",
            "current_name": "disable_irq_and_switch_context_00000794",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableIRQAndSwitchContext_00000794(void)\n\n{\n  disableIRQ();\n  threadArray[activePID] = (thread_t *)0x0;\n  numThreads = numThreads + -1;\n  setThreadStatus(activeThread,0);\n  activeThread = (thread_t *)0x0;\n                    \n  switchContextExit();\n}\n\n",
            "renaming": {
                "FUN_00000794": "disable_irq_and_switch_context_00000794",
                "irq_disable": "disableIRQ",
                "sched_threads": "threadArray",
                "sched_active_pid": "activePID",
                "sched_num_threads": "numThreads",
                "sched_set_status": "setThreadStatus",
                "sched_active_thread": "activeThread",
                "cpu_switch_context_exit": "switchContextExit"
            },
            "calling": [],
            "called": [
                "sched_set_status",
                "cpu_switch_context_exit",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000007dc": {
            "entrypoint": "0x000007dc",
            "current_name": "initialize_thread_000007dc",
            "code": "\nchar * initializeThread_000007dc(thread_taskFunction_t taskFunction,voloopIndexd *argument,voloopIndexd *stackStart,loopIndexnt stackSize)\n\n{\n  uloopIndexnt alignedStackSize;\n  loopIndexnt localStackSize;\n  voloopIndexd *localStackStart;\n  voloopIndexd *localArgument;\n  thread_taskFunction_t localTaskFunction;\n  loopIndexnt loopIndex1;\n  loopIndexnt loopIndex;\n  uloopIndexnt32_t *stackPointer;\n  \n  alignedStackSize = stackSize + (loopIndexnt)stackStart & 0xfffffffc;\n  stackPointer = (uloopIndexnt32_t *)(alignedStackSize - 4);\n  *stackPointer = 0x77777777;\n  loopIndexf (((uloopIndexnt)stackPointer & 7) != 0) {\n    stackPointer = (uloopIndexnt32_t *)(alignedStackSize - 8);\n    *stackPointer = 0x88888888;\n  }\n  stackPointer[-1] = 0x1000000;\n  stackPointer[-2] = (uloopIndexnt32_t)taskFunction;\n  stackPointer[-3] = 0x795;\n  stackPointer = stackPointer + -4;\n  *stackPointer = 0;\n  for (loopIndex = 3; 0 < loopIndex; loopIndex = loopIndex + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = loopIndex;\n  }\n  stackPointer = stackPointer + -1;\n  *stackPointer = (uloopIndexnt32_t)argument;\n  for (loopIndex1 = 0xb; 3 < loopIndex1; loopIndex1 = loopIndex1 + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = loopIndex1;\n  }\n  stackPointer[-1] = 0xfffffffd;\n  return (char *)(stackPointer + -1);\n}\n\n",
            "renaming": {
                "FUN_000007dc": "initialize_thread_000007dc",
                "task_func": "taskFunction",
                "arg": "argument",
                "stack_start": "stackStart",
                "stack_size": "stackSize",
                "uVar1": "alignedStackSize",
                "stack_size_local": "localStackSize",
                "stack_start_local": "localStackStart",
                "arg_local": "localArgument",
                "task_func_local": "localTaskFunction",
                "i_1": "loopIndex1",
                "i": "loopIndex",
                "stk": "stackPointer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000008b8": {
            "entrypoint": "0x000008b8",
            "current_name": "find_used_heap_space_000008b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint find_used_heap_space_000008b8(void)\n\n{\n  current_ptrdiff_t used_word_count;\n  uint32_t *current_ptr;\n  \n  for (current_ptr = (uint32_t *)isr_stack; (*current_ptr == 0xe7fee7fe && (current_ptr < &heap_top)); current_ptr = current_ptr + 1) {\n  }\n  return ((int)&heap_top - (int)current_ptr >> 2) << 2;\n}\n\n",
            "renaming": {
                "FUN_000008b8": "find_used_heap_space_000008b8",
                "num_used_words": "used_word_count",
                "ptr": "current_ptr"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000900": {
            "entrypoint": "0x00000900",
            "current_name": "get_main_stack_pointer_00000900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_main_stack_pointer_00000900(void)\n\n{\n  void *main_stack_pointer;\n  uint32_t return_value;\n  void *main_stack_pointer;\n  \n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}\n\n",
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "return_value",
                "msp": "main_stack_pointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000091c": {
            "entrypoint": "0x0000091c",
            "current_name": "get_isr_stack_pointer_0000091c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_isr_stack_pointer_0000091c(void)\n\n{\n  return ptr_isr_stack;\n}\n\n",
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "isr_stack": "ptr_isr_stack"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000930": {
            "entrypoint": "0x00000930",
            "current_name": "enable_interrupts_00000930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enable_interrupts_00000930(void)\n\n{\n  enable_irq();\n  trigger_software_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000930": "enable_interrupts_00000930",
                "irq_enable": "enable_irq",
                "software_interrupt": "trigger_software_interrupt"
            },
            "calling": [
                "kernel_init",
                "sched_task_exit"
            ],
            "called": [
                "irq_enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000093c": {
            "entrypoint": "0x0000093c",
            "current_name": "set_memory_protection_flag_0000093c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setMemoryProtectionFlag_0000093c(void)\n\n{\n  _DAT_e000ed04 = _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000093c": "set_memory_protection_flag_0000093c"
            },
            "calling": [
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end",
                "_mutex_lock",
                "cortexm_isr_end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000958": {
            "entrypoint": "0x00000958",
            "current_name": "execute_function_00000958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeFunction_00000958(void)\n\n{\n  bool is_privileged;\n  int iVar2;\n  code *function_pointer;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 arg4;\n  undefined4 arg5;\n  undefined4 arg6;\n  undefined4 arg7;\n  undefined4 arg8;\n  undefined4 return_address;\n  code **new_sp;\n  \n  iVar2 = getProcessStackPointer();\n  *(undefined4 *)(iVar2 + -4) = arg8;\n  *(undefined4 *)(iVar2 + -8) = arg7;\n  *(undefined4 *)(iVar2 + -0xc) = arg6;\n  *(undefined4 *)(iVar2 + -0x10) = arg5;\n  *(undefined4 *)(iVar2 + -0x14) = arg4;\n  *(undefined4 *)(iVar2 + -0x18) = arg3;\n  *(undefined4 *)(iVar2 + -0x1c) = arg2;\n  *(undefined4 *)(iVar2 + -0x20) = arg1;\n  *(undefined4 *)(iVar2 + -0x24) = return_address;\n  sched_active_thread->sp = (char *)(undefined4 *)(iVar2 + -0x24);\n  isr_svc();\n  sched_run();\n  function_pointer = *(code **)sched_active_thread->sp;\n  new_sp = (code **)((int)sched_active_thread->sp + 0x24);\n  is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    setProcessStackPointer(new_sp);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*function_pointer)(function_pointer,new_sp);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000958": "execute_function_00000958",
                "unaff_r4": "arg1",
                "unaff_r5": "arg2",
                "unaff_r6": "arg3",
                "unaff_r7": "arg4",
                "unaff_r8": "arg5",
                "unaff_r9": "arg6",
                "unaff_r10": "arg7",
                "unaff_r11": "arg8",
                "in_lr": "return_address",
                "ppcVar3": "new_sp",
                "UNRECOVERED_JUMPTABLE": "function_pointer",
                "bVar1": "is_privileged"
            },
            "calling": [],
            "called": [
                "isr_svc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000974": {
            "entrypoint": "0x00000974",
            "current_name": "run_scheduler_00000974",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runScheduler_00000974(void)\n\n{\n  bool isPrivilegedMode;\n  code *jumpTable;\n  code **stackPointer;\n  \n  sched_run();\n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    setStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000974": "run_scheduler_00000974",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer",
                "bVar1": "isPrivilegedMode",
                "sched_active_thread": "activeThread",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "setProcessStackPointer": "setStackPointer"
            },
            "calling": [
                "isr_pendsv"
            ],
            "called": [
                "sched_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000978": {
            "entrypoint": "0x00000978",
            "current_name": "execute_interrupt_handler_00000978",
            "code": "\nvoid executeInterruptHandler_00000978(void)\n\n{\n  bool isPrivileged;\n  code *jumpTable;\n  code **stackPointer;\n  \n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    setProcessStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000978": "execute_interrupt_handler_00000978",
                "sched_active_thread": "activeThread",
                "bVar1": "isPrivileged",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000990": {
            "entrypoint": "0x00000990",
            "current_name": "FUNC_00000990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000990(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000990": "FUNC_00000990"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000099c": {
            "entrypoint": "0x0000099c",
            "current_name": "initialize_system_0000099c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_0000099c(void)\n\n{\n  uint32_t topStack;\n  uint32_t *ptrTop;\n  uint32_t *ptrSource;\n  uint32_t *ptrDestination;\n  \n  ptrTop = &topStack;\n  ptrSource = (uint32_t *)&_etext;\n  pre_startup();\n  ptrDestination = (uint32_t *)isr_stack;\n  while (ptrDestination < &topStack) {\n    *ptrDestination = 0xe7fee7fe;\n    ptrDestination = ptrDestination + 1;\n  }\n  ptrDestination = (uint32_t *)&heap_ptrTop;\n  while (ptrDestination < &sched_num_threads) {\n    *ptrDestination = *ptrSource;\n    ptrSource = ptrSource + 1;\n    ptrDestination = ptrDestination + 1;\n  }\n  ptrDestination = (uint32_t *)&sched_num_threads;\n  while (ptrDestination < &_sheap) {\n    *ptrDestination = 0;\n    ptrDestination = ptrDestination + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "topStack",
                "top": "ptrTop",
                "src": "ptrSource",
                "dst": "ptrDestination"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "post_startup",
                "pre_startup",
                "kernel_init",
                "board_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a30": {
            "entrypoint": "0x00000a30",
            "current_name": "handle_nmi_00000a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleNMI_00000a30(void)\n\n{\n                    \n  core_panic(nmiHandlerMessage,\"NMI HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000a30": "handle_nmi_00000a30",
                "PANIC_NMI_HANDLER": "nmiHandlerMessage"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a40": {
            "entrypoint": "0x00000a40",
            "current_name": "calculate_stack_address_00000a40",
            "code": "\nint calculateStackAddress_00000a40(uint32_t offset)\n\n{\n  uint32_t localOffset;\n  uint32_t *stackPointer;\n  \n  return (int)(&stack0xe000ffe8 + -offset);\n}\n\n",
            "renaming": {
                "FUN_00000a40": "calculate_stack_address_00000a40",
                "required": "offset",
                "required_local": "localOffset",
                "sp": "stackPointer"
            },
            "calling": [
                "hard_fault_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a64": {
            "entrypoint": "0x00000a64",
            "current_name": "handle_fault_00000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleFault_00000a64(void)\n\n{\n  uint32_t *stackPointer;\n  uint32_t isCorrupted;\n  uint32_t register4;\n  undefined4 register5;\n  undefined4 register6;\n  undefined4 register7;\n  undefined4 register8;\n  undefined4 register9;\n  undefined4 register10;\n  undefined4 register11;\n  uint linkRegister;\n  \n  if ((&_eram < &stack0x00000000) || (&stack0x00000000 < isr_stack + 0x159)) {\n    isCorrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)&heap_top;\n  }\n  else {\n    isCorrupted = 0;\n  }\n  if ((linkRegister & 4) == 0) {\n    stackPointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stackPointer = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = register11;\n  *(undefined4 *)((int)register0x00000054 + -8) = register10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = register9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = register8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = register7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = register6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = register5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = register4;\n                    \n  hard_fault_handler(stackPointer,isCorrupted,linkRegister,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n",
            "renaming": {
                "FUN_00000a64": "handle_fault_00000a64",
                "sp": "stackPointer",
                "corrupted": "isCorrupted",
                "unaff_r4": "register4",
                "unaff_r5": "register5",
                "unaff_r6": "register6",
                "unaff_r7": "register7",
                "unaff_r8": "register8",
                "unaff_r9": "register9",
                "unaff_r10": "register10",
                "unaff_r11": "register11",
                "in_lr": "linkRegister"
            },
            "calling": [],
            "called": [
                "hard_fault_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000aa8": {
            "entrypoint": "0x00000aa8",
            "current_name": "handle_hard_fault_00000aa8",
            "code": "\n\n\nvoid handle_hard_fault_00000aa8(uint32_t *stack_pointer,uint32_t is_corrupted,uint32_t exception_return,uint32_t *r4_to_r11_stack)\n\n{\n  uint cfsr;\n  undefined4 hfsr;\n  undefined4 dfsr;\n  undefined4 afsr;\n  undefined4 bfar;\n  undefined4 mmfar;\n  int stack_overflow;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t lr;\n  uint32_t *r4_to_r11_stack_local;\n  uint32_t exception_return_local;\n  uint32_t is_corrupted_local;\n  uint32_t *stack_pointer_local;\n  int stack_left;\n  uint32_t psr;\n  uint32_t link_register;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *original_stack_pointer;\n  uint32_t program_counter;\n  \n  mmfar = _DAT_e000ed3c;\n  bfar = _DAT_e000ed38;\n  afsr = _DAT_e000ed34;\n  dfsr = _DAT_e000ed30;\n  hfsr = _DAT_e000ed2c;\n  cfsr = _DAT_e000ed28;\n  program_counter = 0;\n  if (isr_stack._0_4_ != -0x18011802) {\n    puts(\"\\nISR stack overflowed\");\n  }\n  if (is_corrupted == 0) {\n    r0 = *stack_pointer;\n    r1 = stack_pointer[1];\n    r2 = stack_pointer[2];\n    r3 = stack_pointer[4];\n    lr = stack_pointer[5];\n    program_counter = stack_pointer[6];\n    puts(\"\\nContext before hardfault:\");\n    iprintf(\"   r0: 0x%08lx\\n   r1: 0x%08lx\\n   r2: 0x%08lx\\n   r3: 0x%08lx\\n\",r0,r1,r2);\n    iprintf(\"  r12: 0x%08lx\\n   link_register: 0x%08lx\\n   program_counter: 0x%08lx\\n  psr: 0x%08lx\\n\\n\",r3,lr,program_counter);\n  }\n  else {\n    puts(\"Stack pointer is_corrupted, reset to top of stack\");\n  }\n  puts(\"FSR/FAR:\");\n  iprintf(\" CFSR: 0x%08lx\\n\",cfsr);\n  iprintf(\" HFSR: 0x%08lx\\n\",hfsr);\n  iprintf(\" DFSR: 0x%08lx\\n\",dfsr);\n  iprintf(\" AFSR: 0x%08lx\\n\",mmfar);\n  if ((cfsr & 0x8000) != 0) {\n    iprintf(\" BFAR: 0x%08lx\\n\",bfar);\n  }\n  if ((cfsr & 0x80) != 0) {\n    iprintf(\"MMFAR: 0x%08lx\\n\",afsr);\n  }\n  puts(\"Misc\");\n  iprintf(\"EXC_RET: 0x%08lx\\n\",exception_return);\n  if (is_corrupted == 0) {\n    puts(\"Attempting to reconstruct state for debugging...\");\n    iprintf(\"In GDB:\\n  set $program_counter=0x%lx\\n  frame 0\\n  bt\\n\",program_counter);\n    stack_overflow = _stack_size_left(0x158);\n    if (stack_overflow < 0) {\n      iprintf(\"\\nISR stack overflowed by at least %d bytes.\\n\",-stack_overflow);\n    }\n  }\n  software_bkpt(1);\n                    \n  core_panic(PANIC_HARD_FAULT,\"HARD FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "exc_return": "exception_return",
                "uVar1": "cfsr",
                "uVar2": "hfsr",
                "uVar3": "dfsr",
                "uVar4": "afsr",
                "uVar5": "bfar",
                "uVar6": "mmfar",
                "iVar7": "stack_overflow",
                "uVar8": "r0",
                "uVar9": "r1",
                "uVar10": "r2",
                "uVar11": "r3",
                "uVar12": "lr",
                "exc_return_local": "exception_return_local",
                "corrupted_local": "is_corrupted_local",
                "sp_local": "stack_pointer_local",
                "lr": "link_register",
                "orig_sp": "original_stack_pointer",
                "pc": "program_counter"
            },
            "calling": [
                "hard_fault_default"
            ],
            "called": [
                "core_panic",
                "iprintf",
                "puts",
                "_stack_size_left"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c80": {
            "entrypoint": "0x00000c80",
            "current_name": "handle_memory_management_00000c80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryManagement_00000c80(void)\n\n{\n                    \n  triggerPanic(panicMessage,\"MEM MANAGE HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c80": "handle_memory_management_00000c80",
                "PANIC_MEM_MANAGE": "panicMessage",
                "core_panic": "triggerPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c90": {
            "entrypoint": "0x00000c90",
            "current_name": "handle_bus_fault_00000c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleBusFault_00000c90(void)\n\n{\n                    \n  triggerPanic(busFaultPanic,\"BUS FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PANIC_BUS_FAULT": "busFaultPanic",
                "core_panic": "triggerPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ca0": {
            "entrypoint": "0x00000ca0",
            "current_name": "handle_usage_fault_00000ca0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUsageFault_00000ca0(void)\n\n{\n                    \n  core_panic(usageFaultPanic,\"USAGE FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PANIC_USAGE_FAULT": "usageFaultPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cb0": {
            "entrypoint": "0x00000cb0",
            "current_name": "handle_debug_mon_00000cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDebugMon_00000cb0(void)\n\n{\n                    \n  panic(debugMonPanic,\"DEBUG MON HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cb0": "handle_debug_mon_00000cb0",
                "PANIC_DEBUG_MON": "debugMonPanic",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cc0": {
            "entrypoint": "0x00000cc0",
            "current_name": "handle_dummy_00000cc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_dummy_00000cc0(void)\n\n{\n                    \n  panic(dummy_panic_handler,\"DUMMY HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cc0": "handle_dummy_00000cc0",
                "PANIC_DUMMY_HANDLER": "dummy_panic_handler",
                "core_panic": "panic"
            },
            "calling": [
                "dummy_handler"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cd0": {
            "entrypoint": "0x00000cd0",
            "current_name": "check_interrupts_00000cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkInterrupts_00000cd0(void)\n\n{\n  bool isPrivilegedMode;\n  uint enabledInterrupts;\n  uint32_t interruptStatus;\n  uint32_t interruptMask;\n  \n  enabledInterrupts = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    enabledInterrupts = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return enabledInterrupts;\n}\n\n",
            "renaming": {
                "FUN_00000cd0": "check_interrupts_00000cd0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "enabledInterrupts",
                "result": "interruptStatus",
                "mask": "interruptMask"
            },
            "calling": [
                "pm_off",
                "core_panic",
                "mutex_unlock",
                "kernel_init",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cf0": {
            "entrypoint": "0x00000cf0",
            "current_name": "check_ir_qinterrupt_status_00000cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkIRQinterruptStatus_00000cf0(void)\n\n{\n  bool isPrivilegedMode;\n  uint interruptStatus;\n  uint32_t improvedResult;\n  \n  enableIRQinterrupts();\n  interruptStatus = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptStatus = isIRQinterruptsEnabled();\n  }\n  return interruptStatus;\n}\n\n",
            "renaming": {
                "FUN_00000cf0": "check_ir_qinterrupt_status_00000cf0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptStatus",
                "result": "improvedResult"
            },
            "calling": [
                "cpu_switch_context_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d0c": {
            "entrypoint": "0x00000d0c",
            "current_name": "enable_ir_qinterrupts_if_needed_00000d0c",
            "code": "\nvoid enableIRQinterruptsIfNeeded_00000d0c(uint inputState)\n\n{\n  bool isPrivileged;\n  uint localState;\n  \n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    enableIRQinterrupts((inputState & 1) == 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d0c": "enable_ir_qinterrupts_if_needed_00000d0c",
                "state": "inputState",
                "bVar1": "isPrivileged",
                "state_local": "localState"
            },
            "calling": [
                "mutex_unlock",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d2a": {
            "entrypoint": "0x00000d2a",
            "current_name": "get_exception_number_00000d2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint getExceptionNumber_00000d2a(void)\n\n{\n  bool isPrivilegedMode;\n  uint exceptionNumber;\n  uint32_t exceptionMask;\n  \n  exceptionNumber = 0;\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    exceptionNumber = fetchCurrentExceptionNumber();\n    exceptionNumber = exceptionNumber & 0x1f;\n  }\n  return exceptionNumber;\n}\n\n",
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "bVar1": "isPrivilegedMode",
                "uVar2": "exceptionNumber",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "getCurrentExceptionNumber": "fetchCurrentExceptionNumber",
                "result": "exceptionMask"
            },
            "calling": [
                "sched_switch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d44": {
            "entrypoint": "0x00000d44",
            "current_name": "calculate_offset_00000d44",
            "code": "\nvoid * calculateOffset_00000d44(void *inputPointer,uintinputPointer_t bitValue)\n\n{\n  uintinputPointer_t localBitValue;\n  void *localInputPointer;\n  \n  return (void *)(bitValue * 4 + ((uint)inputPointer & 0xf0000000 | ((uint)inputPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "ptr": "inputPointer",
                "bit": "bitValue",
                "bit_local": "localBitValue",
                "ptr_local": "localInputPointer"
            },
            "calling": [
                "bit_clear32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d76": {
            "entrypoint": "0x00000d76",
            "current_name": "clear_bit_00000d76",
            "code": "\nvoid clearBit_00000d76(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d76": "clear_bit_00000d76"
            },
            "calling": [
                "cpu_errata_fixes"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d9c": {
            "entrypoint": "0x00000d9c",
            "current_name": "clear_gpio_pin_00000d9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clear_GPIO_pin_00000d9c(void)\n\n{\n  bit_clear32((uint32_t *)0x40048040,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d9c": "clear_gpio_pin_00000d9c"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [
                "bit_clear32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000db0": {
            "entrypoint": "0x00000db0",
            "current_name": "initialize_system_00000db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00000db0(void)\n\n{\n  disable_watchdog_timer();\n  apply_cpu_errata_fixes();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000db0": "initialize_system_00000db0",
                "wdog_disable": "disable_watchdog_timer",
                "cpu_errata_fixes": "apply_cpu_errata_fixes"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dc0": {
            "entrypoint": "0x00000dc0",
            "current_name": "initialize_default_handler_00000dc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_default_handler_00000dc0(void)\n\n{\n  handle_default_interrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dc0": "initialize_default_handler_00000dc0",
                "dummy_handler_default": "handle_default_interrupt"
            },
            "calling": [],
            "called": [
                "dummy_handler_default"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dcc": {
            "entrypoint": "0x00000dcc",
            "current_name": "initialize_data_00000dcc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_00000dcc(void)\n\n{\n  _DAT_4005200e = 0xd928;\n  _DAT_40052000 = 0xd2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dcc": "initialize_data_00000dcc"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000df4": {
            "entrypoint": "0x00000df4",
            "current_name": "initialize_uart_00000df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_00000df4(void)\n\n{\n  initialize_uart_00000df4(0,0x1c200,ISRpipe_write_one + 1,&uart_standard_io_isrpipe);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "isrpipe_write_one": "ISRpipe_write_one",
                "uart_stdio_isrpipe": "uart_standard_io_isrpipe",
                "uart_init": "initialize_uart"
            },
            "calling": [
                "_init"
            ],
            "called": [
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e14": {
            "entrypoint": "0x00000e14",
            "current_name": "read_from_uart_00000e14",
            "code": "\nint readFromUart_00000e14(char *inputBuffer,int size)\n\n{\n  int result;\n  int localSize;\n  char *localBuffer;\n  \n  result = isrpipe_read(&uart_stdio_isrpipe,inputBuffer,size);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000e14": "read_from_uart_00000e14",
                "buffer": "inputBuffer",
                "count": "size",
                "iVar1": "result",
                "count_local": "localSize",
                "buffer_local": "localBuffer"
            },
            "calling": [
                "_read_r"
            ],
            "called": [
                "isrpipe_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e38": {
            "entrypoint": "0x00000e38",
            "current_name": "send_data_00000e38",
            "code": "\nint send_data_00000e38(char *data_buffer,int buffer_length)\n\n{\n  int local_length;\n  char *local_buffer;\n  \n  uart_write(0,(uint8_t *)data_buffer,buffer_length);\n  return buffer_length;\n}\n\n",
            "renaming": {
                "FUN_00000e38": "send_data_00000e38",
                "buffer": "data_buffer",
                "len": "buffer_length",
                "len_local": "local_length",
                "buffer_local": "local_buffer"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e58": {
            "entrypoint": "0x00000e58",
            "current_name": "disable_interrupts_00000e58",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_interrupts_00000e58(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000e58": "disable_interrupts_00000e58"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e64": {
            "entrypoint": "0x00000e64",
            "current_name": "initialize_hardware_00000e64",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_00000e64(void)\n\n{\n  _DAT_40048038 = _DAT_40048038 | 0x200;\n  _DAT_40049048 = _DAT_40049048 & 0xfefff8ff;\n  initializeCPU();\n  initializeGPIO(0x2056,GPIO_OUT);\n  initializeGPIO(0x511a,GPIO_OUT);\n  initializeGPIO(0x2055,GPIO_OUT);\n  setGPIO(0x2056);\n  setGPIO(0x511a);\n  setGPIO(0x2055);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000e64": "initialize_hardware_00000e64",
                "cpu_init": "initializeCPU",
                "gpio_init": "initializeGPIO",
                "gpio_set": "setGPIO"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "gpio_set",
                "cpu_init",
                "gpio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ed8": {
            "entrypoint": "0x00000ed8",
            "current_name": "print_lr_value_00000ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printLRValue_00000ed8(void)\n\n{\n  undefined4 lrValue;\n  uint32_t *lrPointer;\n  \n  iprintf(\"%p\\n\",lrValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ed8": "print_lr_value_00000ed8",
                "in_lr": "lrValue",
                "lr_ptr": "lrPointer"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ef8": {
            "entrypoint": "0x00000ef8",
            "current_name": "FUNC_00000ef8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ef8": "FUNC_00000ef8"
            },
            "calling": [
                "core_panic"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000f04": {
            "entrypoint": "0x00000f04",
            "current_name": "handle_kernel_panic_00000f04",
            "code": "\nvoid handleKernelPanic_00000f04(core_panic_t panicCode,char *errorMessage)\n\n{\n  undefined4 stackPointer_18;\n  undefined4 stackPointer_14;\n  char *localMessage;\n  core_panic_t localPanicCode;\n  \n  localMessage = errorMessage;\n  localPanicCode = panicCode;\n  if (crashed == 0) {\n    crashed = 1;\n    if (panicCode == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(\"*** RIOT kernel panic:\\n%s\\n\\n\",localMessage);\n    ps();\n    iprintf(\"\\n\");\n    iprintf(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  panic_arch();\n  stackPointer_14 = 0xf4d;\n  pm_off();\n  stackPointer_18 = (int)&stackPointer_18 + 1;\n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f04": "handle_kernel_panic_00000f04",
                "crash_code": "panicCode",
                "message": "errorMessage",
                "uStack_18": "stackPointer_18",
                "uStack_14": "stackPointer_14",
                "message_local": "localMessage",
                "crash_code_local": "localPanicCode"
            },
            "calling": [
                "debug_mon_default",
                "uart_init",
                "hard_fault_handler",
                "thread_add_to_list",
                "usage_fault_default",
                "bus_fault_default",
                "fmt_s32_dfp",
                "nmi_default",
                "mem_manage_default",
                "cib_init",
                "dummy_handler_default"
            ],
            "called": [
                "pm_off",
                "ps",
                "panic_arch",
                "cpu_print_last_instruction",
                "iprintf",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f5c": {
            "entrypoint": "0x00000f5c",
            "current_name": "initialize_and_execute_riot_00000f5c",
            "code": "\nvoid * initialize_and_execute_riot_00000f5c(void *arg_ptr)\n\n{\n  void *local_arg_ptr;\n  \n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_00000f5c": "initialize_and_execute_riot_00000f5c",
                "arg": "arg_ptr",
                "arg_local": "local_arg_ptr"
            },
            "calling": [],
            "called": [
                "auto_init",
                "iprintf",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f80": {
            "entrypoint": "0x00000f80",
            "current_name": "infinite_loop_00000f80",
            "code": "\nvoid * infiniteLoop_00000f80(void *arg)\n\n{\n  void *localArg;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg_local": "localArg"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f8c": {
            "entrypoint": "0x00000f8c",
            "current_name": "initialize_system_00000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00000f8c(void)\n\n{\n  disable_interrupts();\n  create_thread(idle_thread_stack,0x100,'\\x0f',0xc,idle_thread_function + 1,(void *)0x0,idle_thread_name);\n  create_thread(main_thread_stack,0x600,'\\a',0xc,main_thread_trampoline + 1,(void *)0x0,main_thread_name);\n                    \n  exit_scheduler();\n}\n\n",
            "renaming": {
                "FUN_00000f8c": "initialize_system_00000f8c",
                "irq_disable": "disable_interrupts",
                "idle_stack": "idle_thread_stack",
                "main_stack": "main_thread_stack",
                "idle_thread": "idle_thread_function",
                "main_trampoline": "main_thread_trampoline",
                "idle_name": "idle_thread_name",
                "main_name": "main_thread_name",
                "thread_create": "create_thread",
                "cpu_switch_context_exit": "exit_scheduler"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "cpu_switch_context_exit",
                "thread_create",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000fec": {
            "entrypoint": "0x00000fec",
            "current_name": "initialize_circular_buffer_00000fec",
            "code": "\nvoid initializeCircularBuffer_00000fec(circularBuffer_t *circularBuffer,uint bufferSize)\n\n{\n  uint localBufferSize;\n  circularBuffer_t *localCircularBuffer;\n  circularBuffer_t c;\n  \n  if ((bufferSize & bufferSize - 1) != 0) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  circularBuffer->read_count = 0;\n  circularBuffer->write_count = 0;\n  circularBuffer->mask = bufferSize - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib": "circularBuffer",
                "size": "bufferSize",
                "size_local": "localBufferSize",
                "cib_local": "localCircularBuffer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001034": {
            "entrypoint": "0x00001034",
            "current_name": "insert_thread_into_list_00001034",
            "code": "\nvoid insertThreadIntoList_00001034(threadList_node_t *threadList,newThread_t *newThread)\n\n{\n  newThread_t *newThread_local;\n  threadList_node_t *currentNode;\n  newThread_t *existingThread;\n  cthreadList_node_t *tempPtr;\n  threadList_node_t *threadNode;\n  uint16_t priority;\n  \n  if (newThread->status < 9) {\n    currentNode = threadList;\n    while ((currentNode->next != (threadList_node *)0x0 &&\n           (*(byte *)((int)&currentNode->next[-1].next + 1) <= newThread->priority))) {\n      currentNode = currentNode->next;\n    }\n    (newThread->rq_entry).next = currentNode->next;\n    currentNode->next = &newThread->rq_entry;\n    return;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list": "threadList",
                "thread": "newThread",
                "list_local": "currentNode",
                "list_entry": "existingThread",
                "__m____": "tempPtr",
                "new_node": "threadNode",
                "my_prio": "priority"
            },
            "calling": [
                "_mutex_lock"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010a0": {
            "entrypoint": "0x000010a0",
            "current_name": "get_stack_space_000010a0",
            "code": "\nuintptr_t get_stack_space_000010a0(char *stack_ptr)\n\n{\n  char *stack_ptr_local;\n  uintptr_t free_space;\n  uintptr_t *stack_ptr_p;\n  \n  for (stack_ptr_p = (uintptr_t *)stack_ptr; (uintptr_t *)*stack_ptr_p == stack_ptr_p; stack_ptr_p = stack_ptr_p + 1) {\n  }\n  return (int)stack_ptr_p - (int)stack_ptr;\n}\n\n",
            "renaming": {
                "FUN_000010a0": "get_stack_space_000010a0",
                "stack": "stack_ptr",
                "stack_local": "stack_ptr_local",
                "space_free": "free_space",
                "stackp": "stack_ptr_p"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010d4": {
            "entrypoint": "0x000010d4",
            "current_name": "create_thread_000010d4",
            "code": "\nkernel_thread_pid_t\ncreate_thread_000010d4(char *stack_buffer,thread_idnt buffer_size,char thread_priority,thread_idnt thread_flags,thread_structask_func_t thread_function,vothread_idd *thread_argument\n            ,char *thread_name)\n\n{\n  uthread_idnt irq_state;\n  char *stack_init_result;\n  thread_idnt misalignment;\n  uthread_idnt aligned_buffer_size;\n  thread_struct *new_thread;\n  thread_idnt local_flags;\n  char local_priority;\n  thread_idnt local_buffer_size;\n  char *aligned_stack_buffer;\n  uthread_idnt saved_irq_state;\n  uthread_idntptr_t *stack_max;\n  thread_struct *cb;\n  uthread_idntptr_t buffer_misalignment;\n  thread_idnt total_buffer_size;\n  uthread_idntptr_t *current_stack_pointer;\n  kernel_thread_pid_t thread_id;\n  kernel_thread_pid_t thread_pid;\n  \n  thread_idf ((byte)thread_priority < 0x10) {\n    local_buffer_size = buffer_size;\n    aligned_stack_buffer = stack_buffer;\n    thread_idf (((uthread_idnt)stack_buffer & 3) != 0) {\n      misalignment = 4 - ((uthread_idnt)stack_buffer & 3);\n      aligned_stack_buffer = stack_buffer + misalignment;\n      local_buffer_size = buffer_size - misalignment;\n    }\n    aligned_buffer_size = local_buffer_size - 0x30U & 0xfffffffc;\n    new_thread = (thread_struct *)(aligned_stack_buffer + aligned_buffer_size);\n    thread_idf ((thread_flags & 8U) == 0) {\n      *(char **)aligned_stack_buffer = aligned_stack_buffer;\n    }\n    else {\n      for (current_stack_pointer = (uthread_idntptr_t *)aligned_stack_buffer; current_stack_pointer < aligned_stack_buffer + aligned_buffer_size; current_stack_pointer = current_stack_pointer + 1\n          ) {\n        *current_stack_pointer = (uthread_idntptr_t)current_stack_pointer;\n      }\n    }\n    irq_state = irq_disable_function();\n    thread_pid = 0;\n    for (thread_id = 1; thread_id < 0x21; thread_id = thread_id + 1) {\n      thread_idf (scheduler_threads[thread_id] == (thread_struct *)0x0) {\n        thread_pid = thread_id;\n        break;\n      }\n    }\n    thread_idf (thread_pid == 0) {\n      irq_restore_function(irq_state);\n      thread_pid = -0x8b;\n    }\n    else {\n      scheduler_threads[thread_pid] = new_thread;\n      new_thread->thread_pid = thread_pid;\n      stack_init_result = stack_initialization(thread_function,thread_argument,aligned_stack_buffer,aligned_buffer_size);\n      new_thread->sp = stack_init_result;\n      new_thread->stack_buffer_start = aligned_stack_buffer;\n      new_thread->aligned_buffer_size = buffer_size;\n      new_thread->thread_name = thread_name;\n      new_thread->thread_priority = thread_priority;\n      new_thread->status = '\\0';\n      (new_thread->rq_entry).next = (lthread_idst_node *)0x0;\n      new_thread->wathread_idt_data = (vothread_idd *)0x0;\n      (new_thread->msg_wathread_idters).next = (lthread_idst_node *)0x0;\n      cthread_idb_thread_idnthread_idt(&new_thread->msg_queue,0);\n      new_thread->msg_array = (msg_t *)0x0;\n      num_threads = num_threads + 1;\n      thread_idf ((thread_flags & 1U) == 0) {\n        set_thread_status(new_thread,10);\n        thread_idf ((thread_flags & 4U) == 0) {\n          irq_restore_function(irq_state);\n          thread_switch((ushort)(byte)thread_priority);\n          return thread_pid;\n        }\n      }\n      else {\n        set_thread_status(new_thread,1);\n      }\n      irq_restore_function(irq_state);\n    }\n  }\n  else {\n    thread_pid = -0x16;\n  }\n  return thread_pid;\n}\n\n",
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stack_buffer",
                "stacksize": "buffer_size",
                "priority": "thread_priority",
                "flags": "thread_flags",
                "function": "thread_function",
                "arg": "thread_argument",
                "name": "thread_name",
                "state_00": "irq_state",
                "pcVar1": "stack_init_result",
                "iVar2": "misalignment",
                "stack_size": "aligned_buffer_size",
                "process": "new_thread",
                "flags_local": "local_flags",
                "priority_local": "local_priority",
                "stacksize_local": "local_buffer_size",
                "stack_local": "aligned_stack_buffer",
                "state": "saved_irq_state",
                "stackmax": "stack_max",
                "misalignment": "buffer_misalignment",
                "total_stacksize": "total_buffer_size",
                "stackp": "current_stack_pointer",
                "i": "thread_id",
                "pid": "thread_pid",
                "sched_threads": "scheduler_threads",
                "thread_t": "thread_struct",
                "irq_disable": "irq_disable_function",
                "irq_restore": "irq_restore_function",
                "sched_num_threads": "num_threads",
                "thread_stack_init": "stack_initialization",
                "sched_set_status": "set_thread_status",
                "sched_switch": "thread_switch"
            },
            "calling": [
                "kernel_init"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "cib_init",
                "irq_disable",
                "thread_stack_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001274": {
            "entrypoint": "0x00001274",
            "current_name": "initialize_hardware_00001274",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_hardware_00001274(void)\n\n{\n  initialize_cortexm();\n  DAT_4007e000 = DAT_4007e000 | 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001274": "initialize_hardware_00001274",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "kinetis_mcg_init",
                "periph_init",
                "cortexm_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000129c": {
            "entrypoint": "0x0000129c",
            "current_name": "lock_mutex_0000129c",
            "code": "\nvoid lockMutex_0000129c(mutex_t *mutex)\n\n{\n  mutex_t *localMutex;\n  \n  _mutex_lock(mutex,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex_local": "localMutex"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "_mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012b4": {
            "entrypoint": "0x000012b4",
            "current_name": "add_to_isr_pipe_000012b4",
            "code": "\nint addToISRPipe_000012b4(pipe_t *pipe,char c)\n\n{\n  int result;\n  char localCharacter;\n  pipe_t *localPipe;\n  int response;\n  \n  result = tsrb_add_one(&pipe->tsrb,c);\n  mutex_unlock(&pipe->mutex);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000012b4": "add_to_isr_pipe_000012b4",
                "isrpipe": "pipe",
                "iVar1": "result",
                "c_local": "localCharacter",
                "isrpipe_local": "localPipe",
                "res": "response"
            },
            "calling": [],
            "called": [
                "mutex_unlock",
                "tsrb_add_one"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012e2": {
            "entrypoint": "0x000012e2",
            "current_name": "read_from_isr_pipe_000012e2",
            "code": "\nint readFromISRPipe_000012e2(pipe_t *pipe,char *outputBuffer,size_t bufferSize)\n\n{\n  int iVar1;\n  size_t localBufferSize;\n  char *localOutputBuffer;\n  pipe_t *localPipe;\n  int result;\n  \n  while( true ) {\n    iVar1 = tsrb_get(&pipe->tsrb,outputBuffer,bufferSize);\n    if (iVar1 != 0) break;\n    mutex_lock(&pipe->mutex);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_000012e2": "read_from_isr_pipe_000012e2",
                "isrpipe": "pipe",
                "buffer": "outputBuffer",
                "count": "bufferSize",
                "count_local": "localBufferSize",
                "buffer_local": "localOutputBuffer",
                "isrpipe_local": "localPipe",
                "res": "result"
            },
            "calling": [
                "uart_stdio_read"
            ],
            "called": [
                "tsrb_get",
                "mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001318": {
            "entrypoint": "0x00001318",
            "current_name": "set_irq_enable_bit_00001318",
            "code": "\nvoid setIRQEnableBit_00001318(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001318": "set_irq_enable_bit_00001318",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "uart_init_uart"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001348": {
            "entrypoint": "0x00001348",
            "current_name": "check_and_yield_00001348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00001348(void)\n\n{\n  if (switch_request_flag != 0) {\n    perform_thread_yield();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001348": "check_and_yield_00001348",
                "sched_context_switch_request": "switch_request_flag",
                "thread_yield_higher": "perform_thread_yield"
            },
            "calling": [
                "irq_handler_uart"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001360": {
            "entrypoint": "0x00001360",
            "current_name": "calculate_memory_address_00001360",
            "code": "\nvoid * calculateMemoryAddress_00001360(void *ptr,uintptr_t bitOffset)\n\n{\n  uintptr_t localBitOffset;\n  void *localPointer;\n  \n  return (void *)(bitOffset * 4 + ((uint)ptr & 0xf0000000 | ((uint)ptr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001360": "calculate_memory_address_00001360",
                "bit": "bitOffset",
                "bit_local": "localBitOffset",
                "ptr_local": "localPointer"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001392": {
            "entrypoint": "0x00001392",
            "current_name": "set_bit_00001392",
            "code": "\nvoid setBit_00001392(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001392": "set_bit_00001392"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000013b8": {
            "entrypoint": "0x000013b8",
            "current_name": "initialize_uart_000013b8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000142e) */\n\nint initializeUart_000013b8(uartInstance_t uartInstance,uint32_t baudRate,uartInstance_receiveCallback_t receiveCallback,void *callbackArg)\n\n{\n  void *localCallbackArg;\n  uartInstance_receiveCallback_t localReceiveCallback;\n  uint32_t localBaudRate;\n  uartInstance_t localUart;\n  \n  if (uartInstance == 0) {\n    config[0].receiveCallback = receiveCallback;\n    config[0].callbackArg = callbackArg;\n    uartInstance_init_pins(0);\n    bit_set32((uint32_t *)&DAT_40048034,'\\n');\n    uartInstance_init_uartInstance(0,baudRate);\n    return 0;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uartInstance",
                "baudrate": "baudRate",
                "rx_cb": "receiveCallback",
                "arg": "callbackArg",
                "arg_local": "localCallbackArg",
                "rx_cb_local": "localReceiveCallback",
                "baudrate_local": "localBaudRate",
                "uart_local": "localUart",
                "config[0].rx_cb": "config[0].receiveCallback",
                "config[0].arg": "config[0].callbackArg"
            },
            "calling": [
                "uart_stdio_init"
            ],
            "called": [
                "uart_init_uart",
                "core_panic",
                "uart_init_pins",
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001448": {
            "entrypoint": "0x00001448",
            "current_name": "initialize_uart_00001448",
            "code": "\nvoid initializeUART_00001448(uartInstance_t uartInstance)\n\n{\n  uartInstance_t localUART;\n  \n  if (configuration[uartInstance].rxPin != 0xffff) {\n    gpio_init_port(configuration[uartInstance].rxPin,configuration[uartInstance].rxPinConfig);\n  }\n  if (configuration[uartInstance].txPin != 0xffff) {\n    gpio_init_port(configuration[uartInstance].txPin,configuration[uartInstance].txPinConfig);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001448": "initialize_uart_00001448",
                "uart": "uartInstance",
                "uart_local": "localUART",
                "uart_config": "configuration",
                "pin_rx": "rxPin",
                "pin_tx": "txPin",
                "pcr_rx": "rxPinConfig",
                "pcr_tx": "txPinConfig"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "gpio_init_port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000014c4": {
            "entrypoint": "0x000014c4",
            "current_name": "configure_uart_000014c4",
            "code": "\nvoid configureUART_000014c4(uart_t uart,uint32_t baudrate)\n\n{\n  byte *device;\n  uint frequency;\n  uint ubdDivisor;\n  uint32_t configuredBaudrate;\n  uart_t configuredUART;\n  uint8_t transmitFifoSize;\n  uint8_t brfa;\n  uint16_t ubd;\n  uint32_t clk;\n  UART_Type *UARTDevice;\n  \n  device = (byte *)uart_config[uart].UARTDevice;\n  frequency = uart_config[uart].freq;\n  device[3] = device[3] & 0xf3;\n  device[2] = uart_config[uart].mode;\n  ubdDivisor = frequency / (baudrate << 4);\n  *device = (byte)(ubdDivisor >> 8) & 0x1f;\n  device[1] = (byte)ubdDivisor;\n  device[10] = (byte)((frequency << 2) / baudrate + 1 >> 1) & 0x1f;\n  device[0x10] = device[0x10] | 0x88;\n  if ((device[0x10] & 0x70) == 0) {\n    device[0x13] = 0;\n  }\n  else {\n    device[0x13] = (char)(2 << (device[0x10] >> 4 & 7)) - 1;\n  }\n  device[0x15] = 1;\n  device[0x11] = 0xc0;\n  device[3] = device[3] | 0x2c;\n  NVIC_EnableIRQ(uart_config[uart].irqn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "pbVar1": "device",
                "uVar2": "frequency",
                "uVar3": "ubdDivisor",
                "baudrate_local": "configuredBaudrate",
                "uart_local": "configuredUART",
                "txfifo_size": "transmitFifoSize",
                "dev": "UARTDevice"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000015d0": {
            "entrypoint": "0x000015d0",
            "current_name": "send_data_via_uart_000015d0",
            "code": "\nvoindexd sendDataViaUART_000015d0(uartPort_t uartPort,uindexnt8_t *dataBuffer,sindexze_t bufferLength)\n\n{\n  voindexd *pvVar1;\n  sindexze_t localBufferLength;\n  uindexnt8_t *localDataBuffer;\n  uartPort_t localUARTPort;\n  UART_Type *uartDevice;\n  sindexze_t index;\n  \n  pvVar1 = uartPort_confindexg[uartPort].uartDevice;\n  for (index = 0; index < bufferLength; index = index + 1) {\n    do {\n    } whindexle (-1 < *(char *)((indexnt)pvVar1 + 4));\n    *(uindexnt8_t *)((indexnt)pvVar1 + 7) = dataBuffer[index];\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000015d0": "send_data_via_uart_000015d0",
                "uart": "uartPort",
                "data": "dataBuffer",
                "len": "bufferLength",
                "len_local": "localBufferLength",
                "data_local": "localDataBuffer",
                "uart_local": "localUARTPort",
                "dev": "uartDevice",
                "i": "index"
            },
            "calling": [
                "uart_stdio_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001628": {
            "entrypoint": "0x00001628",
            "current_name": "process_received_data_00001628",
            "code": "\nvoid processReceivedData_00001628(uartInstance_t uartInstance)\n\n{\n  uartInstance_t localUartInstance;\n  uint8_t receivedData;\n  UART_Type *uartDevice;\n  \n  if (((*(byte *)((int)uartInstance_config[uartInstance].uartDevice + 4) & 0x20) != 0) &&\n     (config[uartInstance].rx_cb != (uartInstance_rx_cb_t)0x0)) {\n    (*config[uartInstance].rx_cb)(config[uartInstance].arg,*(uint8_t *)((int)uartInstance_config[uartInstance].uartDevice + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001628": "process_received_data_00001628",
                "uart": "uartInstance",
                "uart_local": "localUartInstance",
                "data": "receivedData",
                "dev": "uartDevice"
            },
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001688": {
            "entrypoint": "0x00001688",
            "current_name": "initialize_uart_irq_handler_00001688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_irq_handler_00001688(void)\n\n{\n  irq_handler_uart(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001688": "initialize_uart_irq_handler_00001688"
            },
            "calling": [],
            "called": [
                "irq_handler_uart"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001696": {
            "entrypoint": "0x00001696",
            "current_name": "calculate_offset_00001696",
            "code": "\nvoid * calculateOffset_00001696(void *inputPtr,uintinputPtr_t bitMask)\n\n{\n  uintinputPtr_t localBitMask;\n  void *localPtr;\n  \n  return (void *)(bitMask * 4 + ((uint)inputPtr & 0xf0000000 | ((uint)inputPtr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "ptr": "inputPtr",
                "bit": "bitMask",
                "bit_local": "localBitMask",
                "ptr_local": "localPtr"
            },
            "calling": [
                "bit_clear8",
                "bit_set8",
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016c8": {
            "entrypoint": "0x000016c8",
            "current_name": "set_bit_value_000016c8",
            "code": "\nvoid setBitValue_000016c8(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *bitAddress;\n  uint8_t localBit;\n  uint32_t *localPtr;\n  \n  bitAddress = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *bitAddress = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016c8": "set_bit_value_000016c8",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitAddress"
            },
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016ec": {
            "entrypoint": "0x000016ec",
            "current_name": "set_bit_value_000016ec",
            "code": "\nvoid setBitValue_000016ec(uint8_t *ptr,uint8_t bitIndex)\n\n{\n  undefined *puVar1;\n  uint8_t localBit;\n  uint8_t *localPtr;\n  \n  puVar1 = (undefined *)bitIndexband_addr(ptr,(uint)bitIndex);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016ec": "set_bit_value_000016ec",
                "bit": "bitIndex",
                "bit_local": "localBit",
                "ptr_local": "localPtr"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001710": {
            "entrypoint": "0x00001710",
            "current_name": "clear_bit_00001710",
            "code": "\nvoid clearBit_00001710(uint8_t *ptr,uint8_t bitIndex)\n\n{\n  undefined *ptrBitAddress;\n  uint8_t bit;\n  uint8_t *localPtr;\n  \n  ptrBitAddress = (undefined *)bitIndexband_addr(ptr,(uint)bitIndex);\n  *ptrBitAddress = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001710": "clear_bit_00001710",
                "bit": "bitIndex",
                "bit_local": "bit",
                "ptr_local": "localPtr",
                "puVar1": "ptrBitAddress"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001734": {
            "entrypoint": "0x00001734",
            "current_name": "clear_bit_in_data_00001734",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearBitInData_00001734(void)\n\n{\n  bit_clear8(&DAT_40064005,'\\x06');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001734": "clear_bit_in_data_00001734"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bit_clear8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001748": {
            "entrypoint": "0x00001748",
            "current_name": "update_fll_factor_00001748",
            "code": "\nvoid updateFLLFactor_00001748(kinetis_mcg_fll_t newFactor)\n\n{\n  kinetis_mcg_fll_t localFactor;\n  \n  DAT_40064003 = newFactor | DAT_40064003 & ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001748": "update_fll_factor_00001748",
                "factor": "newFactor",
                "factor_local": "localFactor"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001778": {
            "entrypoint": "0x00001778",
            "current_name": "clear_bit_and_set_flag_00001778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n/* WARNING: Unknown calling convention */\n\nvoid clear_bit_and_set_flag_00001778(void)\n\n{\n  DAT_40064001 = DAT_40064001 & 0xcf | 0x20;\n  clear_bit(&DAT_40064001,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001778": "clear_bit_and_set_flag_00001778",
                "bit_clear8": "clear_bit"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fee"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000017dc": {
            "entrypoint": "0x000017dc",
            "current_name": "set_bits_and_check_flag_000017dc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setBitsAndCheckFlag_000017dc(void)\n\n{\n  bit_set32((uint32_t *)&DAT_4004803c,'\\x1d');\n  if ((_DAT_4003d010 & 0x100) == 0) {\n    _DAT_4003d010 = 0x104;\n  }\n  _DAT_40047000 = _DAT_40047000 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000017dc": "set_bits_and_check_flag_000017dc"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000182c": {
            "entrypoint": "0x0000182c",
            "current_name": "initialize_data_0000182c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_0000182c(void)\n\n{\n  uint8_t temporaryVariable;\n  \n  DAT_40064008 = DAT_40064008 & 0xd0;\n  bit_set8(&DAT_40064001,'\\0');\n  bit_clear8(&DAT_40064000,'\\x01');\n  bit_clear8(&DAT_40064000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000182c": "initialize_data_0000182c",
                "tmp": "temporaryVariable"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000018bc": {
            "entrypoint": "0x000018bc",
            "current_name": "initialize_clock_system_000018bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockSystem_000018bc(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  bit_clear8(&DAT_40064001,'\\x01');\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  clockMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000018bc": "initialize_clock_system_000018bc",
                "current_mode": "clockMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000191c": {
            "entrypoint": "0x0000191c",
            "current_name": "initialize_mcg_0000191c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCG_0000191c(void)\n\n{\n  enableOscillator();\n  setFllFactor(KINETIS_MCG_FLL_FACTOR_1920);\n  DAT_40064000 = DAT_40064000 & 0x3b;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  current_mode = fllEngagedExternal;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000191c": "initialize_mcg_0000191c",
                "KINETIS_MCG_MODE_FEE": "fllEngagedExternal",
                "kinetis_mcg_enable_osc": "enableOscillator",
                "kinetis_mcg_set_fll_factor": "setFllFactor"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001960": {
            "entrypoint": "0x00001960",
            "current_name": "initialize_system_00001960",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001960(void)\n\n{\n  kinetis_mcg_set_fll_factor(fllFactor1464);\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 & 0xc) != 4);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  current_mode = currentMode;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001960": "initialize_system_00001960",
                "KINETIS_MCG_FLL_FACTOR_1464": "fllFactor1464",
                "KINETIS_MCG_MODE_FBI": "currentMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000019c0": {
            "entrypoint": "0x000019c0",
            "current_name": "initialize_mcg_000019c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_mcg_000019c0(void)\n\n{\n  enable_oscillator();\n  set_fll_factor(fll_factor_1920);\n  clear_bit8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  disable_pll();\n  mcg_mode = KINETIS_MCG_MODE_FBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000019c0": "initialize_mcg_000019c0",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "KINETIS_MCG_FLL_FACTOR_1920": "fll_factor_1920",
                "bit_clear8": "clear_bit8",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "mcg_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a18": {
            "entrypoint": "0x00001a18",
            "current_name": "initialize_bootloader_mode_00001a18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeBootloaderMode_00001a18(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  kinetis_mcg_disable_pll();\n  bootloader_mode = KINETIS_MCG_MODE_BLPI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a18": "initialize_bootloader_mode_00001a18",
                "current_mode": "bootloader_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a3c": {
            "entrypoint": "0x00001a3c",
            "current_name": "initialize_mcg_00001a3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_mcg_00001a3c(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  kinetis_mcg_disable_pll();\n  mcg_mode = KINETIS_MCG_MODE_BLPE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a3c": "initialize_mcg_00001a3c",
                "current_mode": "mcg_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a60": {
            "entrypoint": "0x00001a60",
            "current_name": "initialize_clock_00001a60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClock_00001a60(void)\n\n{\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  bit_set8(&DAT_40064005,'\\x06');\n  do {\n  } while ((DAT_40064006 & 0x20) == 0);\n  do {\n  } while ((DAT_40064006 & 0x40) == 0);\n  clockMode = KINETIS_MCG_MODE_PBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a60": "initialize_clock_00001a60",
                "current_mode": "clockMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ad4": {
            "entrypoint": "0x00001ad4",
            "current_name": "initialize_system_00001ad4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001ad4(void)\n\n{\n  DAT_40064000 = DAT_40064000 & 0x3f;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0xc);\n  currentMode = KINETIS_MCG_MODE_PEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ad4": "initialize_system_00001ad4",
                "current_mode": "currentMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001b10": {
            "entrypoint": "0x00001b10",
            "current_name": "configure_mcg_mode_00001b10",
            "code": "\nint configureMCGMode_00001b10(kinetis_mcg_desiredMode_t desiredMode)\n\n{\n  int result;\n  kinetis_mcg_desiredMode_t currentMode;\n  \n  if (desiredMode < numMCGModes) {\n    do {\n      switch(modeRouting[current_desiredMode][desiredMode]) {\n      case '\\0':\n        kinetis_mcg_set_fei();\n        break;\n      case '\\x01':\n        kinetis_mcg_set_fee();\n        break;\n      case '\\x02':\n        kinetis_mcg_set_fbi();\n        break;\n      case '\\x03':\n        kinetis_mcg_set_fbe();\n        break;\n      case '\\x04':\n        kinetis_mcg_set_blpi();\n        break;\n      case '\\x05':\n        kinetis_mcg_set_blpe();\n        break;\n      case '\\x06':\n        kinetis_mcg_set_pbe();\n        break;\n      case '\\a':\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (desiredMode != current_desiredMode);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00001b10": "configure_mcg_mode_00001b10",
                "mode": "desiredMode",
                "iVar1": "result",
                "mode_local": "currentMode",
                "KINETIS_MCG_MODE_NUMOF": "numMCGModes",
                "mcg_mode_routing": "modeRouting"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001bb8": {
            "entrypoint": "0x00001bb8",
            "current_name": "initialize_device_00001bb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDevice_00001bb8(void)\n\n{\n  if ((DAT_40064001 & 2) != 0) {\n    clearBit8(&DAT_40064001,'\\x01');\n  }\n  if ((DAT_40064005 & 0x40) != 0) {\n    if ((DAT_40064000 & 0xc0) == 0) {\n      DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 & 0xc) != 8);\n    }\n    clearBit8(&DAT_40064005,'\\x06');\n    do {\n    } while ((DAT_40064006 & 0x20) != 0);\n  }\n  setFLLFactor(FLLFactor640);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  currentMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001bb8": "initialize_device_00001bb8",
                "current_mode": "currentMode",
                "bit_clear8": "clearBit8",
                "kinetis_mcg_set_fll_factor": "setFLLFactor",
                "KINETIS_MCG_FLL_FACTOR_640": "FLLFactor640"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001c84": {
            "entrypoint": "0x00001c84",
            "current_name": "initialize_system_00001c84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001c84(void)\n\n{\n  uint interruptState;\n  uint interruptMask;\n  \n  interruptState = irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 = 0x220000;\n  DAT_4006400c = 0;\n  DAT_40064000 = DAT_40064000 & 199 | 0x38;\n  DAT_40064004 = 0x13;\n  DAT_40064005 = 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(interruptState);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "state": "interruptState",
                "mask": "interruptMask"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_init_erclk32k",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_mode",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001cf0": {
            "entrypoint": "0x00001cf0",
            "current_name": "perform_context_switch_if_requested_00001cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid perform_context_switch_if_requested_00001cf0(void)\n\n{\n  if (context_switch_requested != 0) {\n    yield_to_higher_priority_thread();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001cf0": "perform_context_switch_if_requested_00001cf0",
                "sched_context_switch_request": "context_switch_requested",
                "thread_yield_higher": "yield_to_higher_priority_thread"
            },
            "calling": [
                "irq_handler"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d08": {
            "entrypoint": "0x00001d08",
            "current_name": "calculate_offset_00001d08",
            "code": "\nvoid * calculateOffset_00001d08(void *ptr,uintptr_t bit)\n\n{\n  uintptr_t bit_local;\n  void *ptr_local;\n  \n  return (void *)(bit * 4 + ((uint)ptr & 0xf0000000 | ((uint)ptr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d3a": {
            "entrypoint": "0x00001d3a",
            "current_name": "set_bit_00001d3a",
            "code": "\nvoid setBit_00001d3a(uint32_t *ptr,uint8_t bitPosition)\n\n{\n  undefined4 *bitPointer;\n  uint8_t localBit;\n  uint32_t *localPtr;\n  \n  bitPointer = (undefined4 *)bitPositionband_addr(ptr,(uint)bitPosition);\n  *bitPointer = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a",
                "bit": "bitPosition",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitPointer"
            },
            "calling": [
                "clk_en"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d5e": {
            "entrypoint": "0x00001d5e",
            "current_name": "get_port_from_pin_00001d5e",
            "code": "\nPortType * getPortFromPin_00001d5e(gpio_t inputPin)\n\n{\n  gpio_t localPin;\n  \n  return (PortType *)(inputPin & 0x7000 | 0x40048000);\n}\n\n",
            "renaming": {
                "FUN_00001d5e": "get_port_from_pin_00001d5e",
                "pin": "inputPin",
                "pin_local": "localPin",
                "PORT_Type": "PortType"
            },
            "calling": [
                "gpio_init_port",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d80": {
            "entrypoint": "0x00001d80",
            "current_name": "get_gpio_type_from_pin_00001d80",
            "code": "\nGPIOType * getGPIOTypeFromPin_00001d80(gpio_t pin)\n\n{\n  gpio_t localPin;\n  \n  return (GPIOType *)(pin & 0x1c0 | 0x400ff000);\n}\n\n",
            "renaming": {
                "FUN_00001d80": "get_gpio_type_from_pin_00001d80",
                "pin_local": "localPin",
                "GPIO_Type": "GPIOType"
            },
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001da2": {
            "entrypoint": "0x00001da2",
            "current_name": "extract_bit_00001da2",
            "code": "\nint extract_bit_00001da2(gpio_t pin_value)\n\n{\n  gpio_t local_pin;\n  \n  return pin_value >> 6 & 7;\n}\n\n",
            "renaming": {
                "FUN_00001da2": "extract_bit_00001da2",
                "pin": "pin_value",
                "pin_local": "local_pin"
            },
            "calling": [
                "gpio_init_port",
                "clk_en"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001dc0": {
            "entrypoint": "0x00001dc0",
            "current_name": "extract_gpio_pin_00001dc0",
            "code": "\nint extract_gpio_pin_00001dc0(gpio_t input_pin)\n\n{\n  gpio_t local_pin;\n  \n  return input_pin & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_00001dc0": "extract_gpio_pin_00001dc0",
                "pin": "input_pin",
                "pin_local": "local_pin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ddc": {
            "entrypoint": "0x00001ddc",
            "current_name": "set_gpio_pin_bit_00001ddc",
            "code": "\nvoid set_gpio_pin_bit_00001ddc(gpio_t gpio_pin)\n\n{\n  int port_number;\n  gpio_t local_pin;\n  \n  port_number = port_num(gpio_pin);\n  bit_set32((uint32_t *)&DAT_40048038,(char)port_number + '\\t');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_bit_00001ddc",
                "pin": "gpio_pin",
                "iVar1": "port_number",
                "pin_local": "local_pin"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "bit_set32",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e0c": {
            "entrypoint": "0x00001e0c",
            "current_name": "get_mapped_pin_value_00001e0c",
            "code": "\nint getMappedPinValue_00001e0c(int portNumber,int pinNumber)\n\n{\n  int localPin;\n  int localPort;\n  \n  return isr_map[(pinNumber >> 3) + portNumber * 4] >> ((pinNumber & 7U) << 2) & 0xf;\n}\n\n",
            "renaming": {
                "FUN_00001e0c": "get_mapped_pin_value_00001e0c",
                "port": "portNumber",
                "pin": "pinNumber",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e44": {
            "entrypoint": "0x00001e44",
            "current_name": "update_interrupt_map_00001e44",
            "code": "\nvoid updateInterruptMap_00001e44(int portIndex,int pinIndex,int contextValue)\n\n{\n  int shiftIndex;\n  int localContext;\n  int localPin;\n  int localPort;\n  \n  shiftIndex = pinIndex >> 3;\n  isr_map[shiftIndex + portIndex * 4] = isr_map[shiftIndex + portIndex * 4] & ~(0xf << ((pinIndex & 7U) << 2));\n  isr_map[shiftIndex + portIndex * 4] = isr_map[shiftIndex + portIndex * 4] | contextValue << ((pinIndex & 7U) << 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001e44": "update_interrupt_map_00001e44",
                "port": "portIndex",
                "pin": "pinIndex",
                "ctx": "contextValue",
                "iVar1": "shiftIndex",
                "ctx_local": "localContext",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ec4": {
            "entrypoint": "0x00001ec4",
            "current_name": "update_pin_context_00001ec4",
            "code": "\nvoid update_pin_context_00001ec4(int input_port,int input_pin)\n\n{\n  int context;\n  int local_pin;\n  int local_port;\n  int context_local;\n  \n  context = get_context_local(input_port,input_pin);\n  write_map(input_port,input_pin,context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ec4": "update_pin_context_00001ec4",
                "port": "input_port",
                "pin": "input_pin",
                "ctx_00": "context",
                "pin_local": "local_pin",
                "port_local": "local_port",
                "ctx": "context_local"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "get_ctx",
                "write_map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001eea": {
            "entrypoint": "0x00001eea",
            "current_name": "configure_gpio_mode_00001eea",
            "code": "\nint configureGPIOMode_00001eea(gpio_t gpioPin,gpio_gpioMode_t gpioMode)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPtr;\n  PORT_Type *portPtr;\n  int pinIndex;\n  gpio_gpioMode_t localGpioMode;\n  gpio_t localGpioPin;\n  \n  gpio_init_port(gpioPin,0);\n  if ((char)gpioMode < '\\0') {\n    pinNumber = gpioPin_num(gpioPin);\n    gpioPtr = gpio(gpioPin);\n    gpioPtr->PDDR = gpioPtr->PDDR | 1 << (pinNumber & 0xff);\n  }\n  else {\n    pinNumber = gpioPin_num(gpioPin);\n    gpioPtr = gpio(gpioPin);\n    gpioPtr->PDDR = gpioPtr->PDDR & ~(1 << (pinNumber & 0xff));\n  }\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  portPtr->PCR[pinIndex] = gpioMode & 0x23 | 0x100;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00001eea": "configure_gpio_mode_00001eea",
                "pin": "gpioPin",
                "mode": "gpioMode",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPtr",
                "pPVar3": "portPtr",
                "iVar4": "pinIndex",
                "mode_local": "localGpioMode",
                "pin_local": "localGpioPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio_init_port",
                "gpio",
                "port",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001f80": {
            "entrypoint": "0x00001f80",
            "current_name": "configure_gpio_00001f80",
            "code": "\nvoid configureGPIO_00001f80(gpio_t gpioPin,uint32_t pinConfig)\n\n{\n  PORT_Type *portPtr;\n  int pinIndex;\n  int pinIndex0;\n  uint oldPcrValue;\n  uint32_t localPinConfig;\n  gpio_t localGpioPin;\n  uint32_t interruptState;\n  \n  clk_en(gpioPin);\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  oldPcrValue = portPtr->PCR[pinIndex];\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  portPtr->PCR[pinIndex] = pinConfig;\n  if ((oldPcrValue & 0xf0000) != 0) {\n    pinIndex = port_num(gpioPin);\n    pinIndex0 = gpioPin_num(gpioPin);\n    ctx_clear(pinIndex,pinIndex0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001f80": "configure_gpio_00001f80",
                "pin": "gpioPin",
                "pcr": "pinConfig",
                "pPVar1": "portPtr",
                "iVar2": "pinIndex",
                "pin_00": "pinIndex0",
                "uVar3": "oldPcrValue",
                "pcr_local": "localPinConfig",
                "pin_local": "localGpioPin",
                "isr_state": "interruptState"
            },
            "calling": [
                "uart_init_pins",
                "gpio_init"
            ],
            "called": [
                "port",
                "pin_num",
                "ctx_clear",
                "clk_en",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ff6": {
            "entrypoint": "0x00001ff6",
            "current_name": "set_pin_high_00001ff6",
            "code": "\nvoid setPinHigh_00001ff6(gpio_t inputPin)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPointer;\n  gpio_t localPin;\n  \n  pinNumber = inputPin_num(inputPin);\n  gpioPointer = gpio(inputPin);\n  gpioPointer->PSOR = 1 << (pinNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ff6": "set_pin_high_00001ff6",
                "pin": "inputPin",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPointer",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002028": {
            "entrypoint": "0x00002028",
            "current_name": "process_interrupts_00002028",
            "code": "\nvoindexd processInterrupts_00002028(PORT_Type *portPtr,indexnt portNumber)\n\n{\n  indexnt contextIndex;\n  uindexnt interruptFlags;\n  indexnt localPortNumber;\n  PORT_Type *localPortPtr;\n  indexnt context;\n  uindexnt32_t portStatus;\n  indexnt index;\n  \n  interruptFlags = portPtr->ISFR;\n  for (index = 0; index < 0x20; index = index + 1) {\n    indexf (((interruptFlags & 1 << (index & 0xffU)) != 0) && ((portPtr->PCR[index] & 0xf0000) != 0)) {\n      portPtr->ISFR = 1 << (index & 0xffU);\n      contextIndex = get_context(portNumber,index);\n      (*indexsr_context[contextIndex].cb)(indexsr_context[contextIndex].arg);\n    }\n  }\n  cortexm_indexsr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002028": "process_interrupts_00002028",
                "port": "portPtr",
                "port_num": "portNumber",
                "iVar1": "contextIndex",
                "uVar2": "interruptFlags",
                "port_num_local": "localPortNumber",
                "port_local": "localPortPtr",
                "ctx": "context",
                "status": "portStatus",
                "i": "index"
            },
            "calling": [
                "isr_portc",
                "isr_portd",
                "isr_porte",
                "isr_portb",
                "isr_porta"
            ],
            "called": [
                "get_ctx",
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020b8": {
            "entrypoint": "0x000020b8",
            "current_name": "initialize_irq_handler_000020b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_irq_handler_000020b8(void)\n\n{\n  irq_handler((PORT_Type *)0x40049000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020b8": "initialize_irq_handler_000020b8"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020cc": {
            "entrypoint": "0x000020cc",
            "current_name": "initialize_irq_handler_000020cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIrqHandler_000020cc(void)\n\n{\n  irq_handler((PORT_Type *)0x4004a000,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020cc": "initialize_irq_handler_000020cc"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020e0": {
            "entrypoint": "0x000020e0",
            "current_name": "initialize_port_irq_000020e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePortIRQ_000020e0(void)\n\n{\n  irq_handler((PORT_Type *)0x4004b000,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020e0": "initialize_port_irq_000020e0"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020f4": {
            "entrypoint": "0x000020f4",
            "current_name": "initialize_port_irq_000020f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePortIRQ_000020f4(void)\n\n{\n  irq_handler((port *)0x4004c000,3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020f4": "initialize_port_irq_000020f4",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002108": {
            "entrypoint": "0x00002108",
            "current_name": "initialize_irq_handler_00002108",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_irq_handler_00002108(void)\n\n{\n  irq_handler((PORT_Type *)0x4004d000,4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002108": "initialize_irq_handler_00002108"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000211c": {
            "entrypoint": "0x0000211c",
            "current_name": "print_thread_information_0000211c",
            "code": "\n/* WARNING: Unknown callcounterng conventcounteron */\n\nvocounterd printThreadInformation_0000211c(vocounterd)\n\n{\n  byte threadStatus;\n  counternt tempVariable;\n  vocounterd *isrStackStartPointer;\n  vocounterd *isrStackPointer;\n  ucounterntthreadtr_t stackFreeSize;\n  thread_t *currentThread;\n  char *statusName;\n  char queuedName [2];\n  counternt stackSize;\n  char *queued;\n  char *schedulerName;\n  counternt threadState;\n  thread_t *thread;\n  vocounterd *isrStackPointer;\n  vocounterd *isrStackStart;\n  counternt isrStackUsage;\n  kernel_threadcounterd_t counter;\n  counternt totalUsed;\n  counternt totalStackSizes;\n  \n  queuedName[0] = '_';\n  queuedName[1] = 'Q';\n  totalUsed = 0;\n  printFormattedOutput(\"\\tthreadcounterd | %-21s| %-9sQ | threadrcounter | stack  ( used) | base addr  | current     \\n\",&DAT_000070b8,\n          \"threadState\");\n  tempVariable = thread_countersr_stack_usage();\n  isrStackStartPointer = thread_countersr_stack_start();\n  isrStackPointer = thread_countersr_stack_threadocounternter();\n  printFormattedOutput(\"\\t  - | countersr_stack            | -        - |   - | %6counter (%5counter) | %10thread | %10thread\\n\",0x200,tempVariable,\n          isrStackStartPointer,isrStackPointer);\n  totalStackSizes = 0x200;\n  counterf (0 < tempVariable) {\n    totalUsed = tempVariable;\n  }\n  for (counter = 1; counter < 0x21; counter = counter + 1) {\n    currentThread = sched_threads[counter];\n    counterf (currentThread != (thread_t *)0x0) {\n      threadStatus = currentThread->status;\n      statusName = threadState_names[threadStatus];\n      tempVariable = currentThread->stack_scounterze;\n      totalStackSizes = tempVariable + totalStackSizes;\n      stackFreeSize = thread_measure_stack_free(currentThread->stack_start);\n      tempVariable = tempVariable - stackFreeSize;\n      totalUsed = tempVariable + totalUsed;\n      printFormattedOutput(\"\\t%3hcounter | %-20s | %-8s %.1s | %3counter | %6counter (%5counter) | %10thread | %10thread \\n\",(counternt)currentThread->threadcounterd,\n              currentThread->name,statusName,queuedName + (8 < threadStatus),(ucounternt)currentThread->threadrcounterorcounterty,\n              currentThread->stack_scounterze,tempVariable,currentThread->stack_start,currentThread->sthread);\n    }\n  }\n  printFormattedOutput(\"\\t%5s %-21s|%13s%6s %6counter (%5counter)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,&DAT_00007190,\n          totalStackSizes,totalUsed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000211c": "print_thread_information_0000211c",
                "queued_name": "queuedName",
                "stacksz": "stackSize",
                "sname": "schedulerName",
                "state": "threadState",
                "p": "thread",
                "isr_sp": "isrStackPointer",
                "isr_start": "isrStackStart",
                "isr_usage": "isrStackUsage",
                "i": "counter",
                "overall_used": "totalUsed",
                "overall_stacksz": "totalStackSizes",
                "iprintf": "printFormattedOutput",
                "pvVar3": "isrStackStartPointer",
                "pvVar4": "isrStackPointer",
                "uVar5": "stackFreeSize",
                "ptVar6": "currentThread",
                "bVar1": "threadStatus",
                "pcVar7": "statusName",
                "iVar2": "tempVariable"
            },
            "calling": [
                "core_panic",
                "_ps_handler"
            ],
            "called": [
                "thread_isr_stack_start",
                "thread_isr_stack_usage",
                "iprintf",
                "thread_isr_stack_pointer",
                "thread_measure_stack_free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002270": {
            "entrypoint": "0x00002270",
            "current_name": "get_write_count_as_byte_00002270",
            "code": "\nint getWriteCountAsByte_00002270(tsringBuffer_t *ringBuffer)\n\n{\n  byte writeCountAsByte;\n  uint writeCount;\n  bool isReadsEqualToWrites;\n  tsringBuffer_t *localRingBuffer;\n  \n  writeCount = ringBuffer->writes;\n  isReadsEqualToWrites = ringBuffer->reads == writeCount;\n  if (isReadsEqualToWrites) {\n    writeCount = 1;\n  }\n  writeCountAsByte = (byte)writeCount;\n  if (!isReadsEqualToWrites) {\n    writeCountAsByte = 0;\n  }\n  return (uint)writeCountAsByte;\n}\n\n",
            "renaming": {
                "FUN_00002270": "get_write_count_as_byte_00002270",
                "rb": "ringBuffer",
                "uVar2": "writeCount",
                "bVar3": "isReadsEqualToWrites",
                "rb_local": "localRingBuffer",
                "bVar1": "writeCountAsByte"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002294": {
            "entrypoint": "0x00002294",
            "current_name": "check_circular_buffer_fullness_00002294",
            "code": "\nint checkCircularBufferFullness_00002294(tsbuffer_t *buffer)\n\n{\n  byte isFullByte;\n  uint bufferSize;\n  bool isFull;\n  tsbuffer_t *localBuffer;\n  \n  bufferSize = buffer->size;\n  isFull = buffer->writes - buffer->reads == bufferSize;\n  if (isFull) {\n    bufferSize = 1;\n  }\n  isFullByte = (byte)bufferSize;\n  if (!isFull) {\n    isFullByte = 0;\n  }\n  return (uint)isFullByte;\n}\n\n",
            "renaming": {
                "FUN_00002294": "check_circular_buffer_fullness_00002294",
                "rb": "buffer",
                "uVar2": "bufferSize",
                "bVar3": "isFull",
                "rb_local": "localBuffer",
                "bVar1": "isFullByte"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022be": {
            "entrypoint": "0x000022be",
            "current_name": "write_to_circular_buffer_000022be",
            "code": "\nvoid writeToCircularBuffer_000022be(tsbuffer_t *buffer,char c)\n\n{\n  uint numWrites;\n  char localChar;\n  tsbuffer_t *localBuffer;\n  \n  numWrites = buffer->writes;\n  buffer->writes = numWrites + 1;\n  buffer->buf[numWrites & buffer->size - 1] = c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000022be": "write_to_circular_buffer_000022be",
                "rb": "buffer",
                "uVar1": "numWrites",
                "c_local": "localChar",
                "rb_local": "localBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022f0": {
            "entrypoint": "0x000022f0",
            "current_name": "read_and_increment_000022f0",
            "code": "\nchar readAndIncrement_000022f0(tsringBuffer_t *ringBuffer)\n\n{\n  uint reads;\n  tsringBuffer_t *localRingBuffer;\n  \n  reads = ringBuffer->reads;\n  ringBuffer->reads = reads + 1;\n  return ringBuffer->buf[reads & ringBuffer->size - 1];\n}\n\n",
            "renaming": {
                "FUN_000022f0": "read_and_increment_000022f0",
                "rb": "ringBuffer",
                "uVar1": "reads",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000231c": {
            "entrypoint": "0x0000231c",
            "current_name": "copy_and_reduce_0000231c",
            "code": "\nisizet copyAndReduce_0000231c(tsringBuffer_t *ringBuffer,char *destination,size_t size)\n\n{\n  char currentElement;\n  isizet isEmpty;\n  size_t remainingSize;\n  char *currentDestination;\n  tsringBuffer_t *currentRingBuffer;\n  size_t remainingElements;\n  \n  currentDestination = destination;\n  remainingElements = size;\n  while ((remainingElements != 0 && (isEmpty = tsringBuffer_empty(ringBuffer), isEmpty == 0))) {\n    currentElement = _pop(ringBuffer);\n    *currentDestination = currentElement;\n    remainingElements = remainingElements - 1;\n    currentDestination = currentDestination + 1;\n  }\n  retursize size - remainingElements;\n}\n\n",
            "renaming": {
                "FUN_0000231c": "copy_and_reduce_0000231c",
                "rb": "ringBuffer",
                "dst": "destination",
                "n": "size",
                "n_local": "remainingSize",
                "dst_local": "currentDestination",
                "rb_local": "currentRingBuffer",
                "tmp": "remainingElements",
                "cVar1": "currentElement",
                "iVar2": "isEmpty"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002364": {
            "entrypoint": "0x00002364",
            "current_name": "enqueue_character_00002364",
            "code": "\nint enqueueCharacter_00002364(tsringBuffer_t *ringBuffer,char c)\n\n{\n  int isBufferFull;\n  char localCharacter;\n  tsringBuffer_t *localRingBuffer;\n  \n  isBufferFull = tsringBuffer_full(ringBuffer);\n  if (isBufferFull == 0) {\n    _push(ringBuffer,c);\n    isBufferFull = 0;\n  }\n  else {\n    isBufferFull = -1;\n  }\n  return isBufferFull;\n}\n\n",
            "renaming": {
                "FUN_00002364": "enqueue_character_00002364",
                "rb": "ringBuffer",
                "c_local": "localCharacter",
                "rb_local": "localRingBuffer",
                "iVar1": "isBufferFull"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "_push",
                "tsrb_full"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002396": {
            "entrypoint": "0x00002396",
            "current_name": "initialize_rtc_00002396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtc_00002396(void)\n\n{\n  rtc_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "rtc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023a4": {
            "entrypoint": "0x000023a4",
            "current_name": "run_shell_command_000023a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint run_shell_command_000023a4(void)\n\n{\n  char command_buffer [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n                    \n  shell_run((shell_command_t *)0x0,command_buffer,0x80);\n}\n\n",
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "command_buffer"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [
                "startForkserver",
                "puts",
                "shell_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023c8": {
            "entrypoint": "0x000023c8",
            "current_name": "execute_software_interrupt_000023c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_000023c8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_000023c8": "execute_software_interrupt_000023c8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023d0": {
            "entrypoint": "0x000023d0",
            "current_name": "calculate_afl_call_result_000023d0",
            "code": "\nint calculateAflCallResult_000023d0(int inputTicks)\n\n{\n  uint32_t aflCallResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflCallResult = aflCall(1,inputTicks,0);\n  }\n  else {\n    aflCallResult = 0;\n  }\n  return aflCallResult;\n}\n\n",
            "renaming": {
                "FUN_000023d0": "calculate_afl_call_result_000023d0",
                "ticks": "inputTicks",
                "uVar1": "aflCallResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002400": {
            "entrypoint": "0x00002400",
            "current_name": "FUNC_00002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00002400(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002400": "FUNC_00002400"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000240c": {
            "entrypoint": "0x0000240c",
            "current_name": "FUNC_0000240c",
            "code": "\nlist_node_t * FUNC_0000240c(list_node_t *list)\n\n{\n  list_node *plVar1;\n  list_node_t *list_local;\n  list_node_t *head;\n  \n  plVar1 = list->next;\n  if (plVar1 != (list_node *)0x0) {\n    list->next = plVar1->next;\n  }\n  return plVar1;\n}\n\n",
            "renaming": {
                "FUN_0000240c": "FUNC_0000240c"
            },
            "calling": [
                "mutex_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00002434": {
            "entrypoint": "0x00002434",
            "current_name": "handle_mutex_lock_00002434",
            "code": "\nint handleMutexLock_00002434(mutexPtr_t *mutexPtr,int isBlocking)\n\n{\n  currentThread_t *currentThread;\n  uint savedState;\n  int returnValue;\n  int blockingFlag;\n  mutexPtr_t *localMutexPtr;\n  uint irqState;\n  currentThread_t *currentThread;\n  \n  savedState = irq_disable();\n  currentThread = sched_active_currentThread;\n  if ((mutexPtr->queue).next == (list_node *)0x0) {\n    (mutexPtr->queue).next = (list_node *)0xffffffff;\n    irq_restore(savedState);\n    returnValue = 1;\n  }\n  else if (isBlocking == 0) {\n    irq_restore(savedState);\n    returnValue = 0;\n  }\n  else {\n    sched_set_status(sched_active_currentThread,2);\n    if ((mutexPtr->queue).next == (list_node *)0xffffffff) {\n      (mutexPtr->queue).next = &currentThread->rq_entry;\n      ((mutexPtr->queue).next)->next = (list_node *)0x0;\n    }\n    else {\n      currentThread_add_to_list(&mutexPtr->queue,currentThread);\n    }\n    irq_restore(savedState);\n    currentThread_yield_higher();\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00002434": "handle_mutex_lock_00002434",
                "mutex": "mutexPtr",
                "blocking": "isBlocking",
                "thread": "currentThread",
                "state": "savedState",
                "iVar1": "returnValue",
                "blocking_local": "blockingFlag",
                "mutex_local": "localMutexPtr",
                "irqstate": "irqState",
                "me": "currentThread"
            },
            "calling": [
                "mutex_lock"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000024bc": {
            "entrypoint": "0x000024bc",
            "current_name": "dequeue_and_set_thread_status_000024bc",
            "code": "\nvoid dequeue_and_set_thread_status_000024bc(mutex_t *mutex)\n\n{\n  byte thread_priority;\n  uint current_state;\n  list_node_t *dequeued_node;\n  mutex_t *local_mutex;\n  uint16_t priority;\n  uint interrupt_state;\n  clist_node_t *temp_node;\n  list_node_t *next_node;\n  thread_t *current_thread;\n  \n  current_state = irq_disable();\n  if ((mutex->queue).next_node == (list_node *)0x0) {\n    irq_restore(current_state);\n  }\n  else if ((mutex->queue).next_node == (list_node *)0xffffffff) {\n    (mutex->queue).next_node = (list_node *)0x0;\n    irq_restore(current_state);\n  }\n  else {\n    dequeued_node = list_remove_head(&mutex->queue);\n    sched_set_status((thread_t *)(dequeued_node + -2),10);\n    if ((mutex->queue).next_node == (list_node *)0x0) {\n      (mutex->queue).next_node = (list_node *)0xffffffff;\n    }\n    thread_priority = *(byte *)((int)&dequeued_node[-1].next_node + 1);\n    irq_restore(current_state);\n    sched_switch((ushort)thread_priority);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000024bc": "dequeue_and_set_thread_status_000024bc",
                "state": "current_state",
                "plVar2": "dequeued_node",
                "mutex_local": "local_mutex",
                "process_priority": "priority",
                "irqstate": "interrupt_state",
                "__m____": "temp_node",
                "next": "next_node",
                "process": "current_thread",
                "bVar1": "thread_priority"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "list_remove_head",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002538": {
            "entrypoint": "0x00002538",
            "current_name": "set_interrupt_priority_level_00002538",
            "code": "\nvoid setInterruptPriorityLevel_00002538(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002538": "set_interrupt_priority_level_00002538",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "cortexm_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000258c": {
            "entrypoint": "0x0000258c",
            "current_name": "initialize_interrupt_priorities_0000258c",
            "code": "\n\n/* WARNING: Unknown callcounterng conventcounteron */\n\nvocounterd initializeInterruptPriorities_0000258c(vocounterd)\n\n{\n  ucounternt counter;\n  \n  _DAT_e000ed08 = 0;\n  NVIC_SetPrcounterorcounterty(PendSV_IRQn,1);\n  NVIC_SetPrcounterorcounterty(SVCall_IRQn,1);\n  for (counter = 0; counter < 0x66; counter = counter + 1) {\n    NVIC_SetPrcounterorcounterty((IRQn_Type)counter,1);\n  }\n  _DAT_e000ed10 = _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 = _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000258c": "initialize_interrupt_priorities_0000258c",
                "i": "counter"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000025f4": {
            "entrypoint": "0x000025f4",
            "current_name": "initialize_rtt_000025f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtt_000025f4(void)\n\n{\n  initialize_rtt_000025f4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000025f4": "initialize_rtt_000025f4",
                "rtt_init": "initialize_rtt"
            },
            "calling": [
                "periph_init"
            ],
            "called": [
                "rtt_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002600": {
            "entrypoint": "0x00002600",
            "current_name": "set_local_time_counter_00002600",
            "code": "\nintimeValue setLocalTimeCounter_00002600(timeValuem *timeInput)\n\n{\n  uintimeValue32_timeValue localTimeCounter;\n  timeValuem *localTime;\n  timeInput_timeValue timeValue;\n  \n  localTimeCounter = mktimeInput((timeValuem *)timeInput);\n  rtimeValuetimeValue_setimeValue_localTimeCounter(localTimeCounter);\n  retimeValueurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002600": "set_local_time_counter_00002600",
                "time": "timeInput",
                "counter": "localTimeCounter",
                "time_local": "localTime",
                "t": "timeValue"
            },
            "calling": [
                "_rtc_settime"
            ],
            "called": [
                "mktime",
                "rtt_set_counter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002624": {
            "entrypoint": "0x00002624",
            "current_name": "convert_time_to_gmt_00002624",
            "code": "\ninrttCounter convertTimeToGMT_00002624(rttCounterm *inputTime)\n\n{\n  rttCounterm *localTime;\n  inputTime_rttCounter rttCounter;\n  \n  rttCounter._0_4_ = rrttCounterrttCounter_gerttCounter_counrttCounterer();\n  rttCounter._4_4_ = 0;\n  gminputTime_r((inputTime_rttCounter *)&rttCounter,(rttCounterm *)inputTime);\n  rerttCounterurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002624": "convert_time_to_gmt_00002624",
                "time": "inputTime",
                "time_local": "localTime",
                "t": "rttCounter"
            },
            "calling": [
                "_rtc_gettime"
            ],
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002654": {
            "entrypoint": "0x00002654",
            "current_name": "set_alarm_00002654",
            "code": "\nintimeValue setAlarm_00002654(timeValuem *inputTime,rtimeValuec_alarmValue_cb_timeValue cb,void *callbackArgument)\n\n{\n  uintimeValue32_timeValue alarmValue;\n  void *localArgument;\n  rtimeValuec_alarmValue_cb_timeValue localCallbackFunction;\n  timeValuem *localTime;\n  inputTime_timeValue timeValue;\n  \n  alarmValue = mkinputTime((timeValuem *)inputTime);\n  rtimeValuec_callback.cb = cb;\n  rtimeValuetimeValue_setimeValue_alarmValue(alarmValue,rtimeValuec_cb + 1,callbackArgument);\n  retimeValueurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002654": "set_alarm_00002654",
                "time": "inputTime",
                "arg": "callbackArgument",
                "alarm": "alarmValue",
                "arg_local": "localArgument",
                "cb_local": "localCallbackFunction",
                "time_local": "localTime",
                "t": "timeValue"
            },
            "calling": [
                "_rtc_setalarm"
            ],
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002690": {
            "entrypoint": "0x00002690",
            "current_name": "convert_and_set_local_time_00002690",
            "code": "\ninalarmTime convertAndSetLocalTime_00002690(alarmTimem *inputTime)\n\n{\n  alarmTimem *localTime;\n  inputTime_alarmTime alarmTime;\n  \n  alarmTime._0_4_ = ralarmTimealarmTime_gealarmTime_alarm();\n  alarmTime._4_4_ = 0;\n  gminputTime_r((inputTime_alarmTime *)&alarmTime,(alarmTimem *)inputTime);\n  realarmTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002690": "convert_and_set_local_time_00002690",
                "time": "inputTime",
                "time_local": "localTime",
                "t": "alarmTime"
            },
            "calling": [
                "_rtc_getalarm"
            ],
            "called": [
                "rtt_get_alarm",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026c0": {
            "entrypoint": "0x000026c0",
            "current_name": "clear_rtt_alarm_000026c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearRttAlarm_000026c0(void)\n\n{\n  rtt_clear_alarm();\n  rtcCallback.cb = (rtc_alarm_cb_t)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026c0": "clear_rtt_alarm_000026c0",
                "rtc_callback": "rtcCallback"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_clear_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026d8": {
            "entrypoint": "0x000026d8",
            "current_name": "power_on_radio_000026d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid power_on_radio_000026d8(void)\n\n{\n  power_on_rtt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026d8": "power_on_radio_000026d8",
                "rtt_poweron": "power_on_rtt"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026e4": {
            "entrypoint": "0x000026e4",
            "current_name": "poweroff_rtt_000026e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid poweroff_rtt_000026e4(void)\n\n{\n  poweroff();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026e4": "poweroff_rtt_000026e4",
                "rtt_poweroff": "poweroff"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweroff"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026f0": {
            "entrypoint": "0x000026f0",
            "current_name": "call_rtc_alarm_callback_000026f0",
            "code": "\nvoid callRTCAlarmCallback_000026f0(void *callbackArg)\n\n{\n  void *callbackArg_local;\n  \n  if (rtcAlarmCallback.cb != (rtc_alarm_cb_t)0x0) {\n    (*rtcAlarmCallback.cb)(callbackArg);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026f0": "call_rtc_alarm_callback_000026f0",
                "arg": "callbackArg",
                "rtc_callback": "rtcAlarmCallback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002714": {
            "entrypoint": "0x00002714",
            "current_name": "set_interrupt_priority_00002714",
            "code": "\nvoid setInterruptPriority_00002714(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002714": "set_interrupt_priority_00002714",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002744": {
            "entrypoint": "0x00002744",
            "current_name": "set_priority_00002744",
            "code": "\nvoid setPriority_00002744(interrupt_Type interrupt,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interrupt_Type localInterrupt;\n  \n  if (interrupt < DMA0_interrupt) {\n    (&DAT_e000ed14)[(byte)interrupt & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interrupt + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002744": "set_priority_00002744",
                "IRQn": "interrupt",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterrupt"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002798": {
            "entrypoint": "0x00002798",
            "current_name": "check_and_yield_00002798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00002798(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002798": "check_and_yield_00002798"
            },
            "calling": [
                "isr_rtc"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000027b0": {
            "entrypoint": "0x000027b0",
            "current_name": "initialize_rtc_000027b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRTC_000027b0(void)\n\n{\n  RTC_Type *rtcInstance;\n  \n  _DAT_4004803c = _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 & 1) != 0) {\n    _DAT_4003d000 = 0;\n  }\n  _DAT_4003d010 = 0x104;\n  _DAT_4003d008 = 0xffffff42;\n  _DAT_4003d01c = 0;\n  rtcInstance_poweron();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000027b0": "initialize_rtc_000027b0",
                "rtt": "rtcInstance"
            },
            "calling": [
                "rtc_init"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000281c": {
            "entrypoint": "0x0000281c",
            "current_name": "get_rtc_value_0000281c",
            "code": "\n/* WARNING: Removindexng unreachable block (ram,0x00002840) */\n/* WARNING: Removindexng unreachable block (ram,0x0000284c) */\n\n/* WARNING: Unknown callindexng convenvalueindexon */\n\nuindexnvalue32_value get_rtc_value_0000281c(voindexd)\n\n{\n  RTC_Type *rtc_instance;\n  indexnvalue index;\n  uindexnvalue32_value value;\n  \n  revalueurn _DAT_4003d000;\n}\n\n",
            "renaming": {
                "FUN_0000281c": "get_rtc_value_0000281c",
                "rtt": "rtc_instance",
                "i": "index",
                "t": "value"
            },
            "calling": [
                "rtc_get_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000285c": {
            "entrypoint": "0x0000285c",
            "current_name": "set_counter_value_0000285c",
            "code": "\n\n\nvoid setCounterValue_0000285c(uint32_t newValue)\n\n{\n  uint32_t localCounter;\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d000 = newValue;\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000285c": "set_counter_value_0000285c",
                "counter": "newValue",
                "counter_local": "localCounter",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_set_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002894": {
            "entrypoint": "0x00002894",
            "current_name": "configure_rtt_alarm_00002894",
            "code": "\n\n\nvoid configure_rtt_alarm_00002894(uint32_t alarm_value,rtt_instance_cb_t cb,void *callback_argument)\n\n{\n  void *local_argument;\n  rtt_instance_cb_t local_callback_function;\n  uint32_t local_alarm_value;\n  RTC_Type *rtt_instance;\n  \n  _DAT_4003d008 = alarm_value - 1;\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb | 4;\n  rtt_instance_callback.alarm_value_cb = cb;\n  rtt_instance_callback.alarm_value_callback_argument = callback_argument;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002894": "configure_rtt_alarm_00002894",
                "alarm": "alarm_value",
                "arg": "callback_argument",
                "arg_local": "local_argument",
                "cb_local": "local_callback_function",
                "alarm_local": "local_alarm_value",
                "rtt": "rtt_instance"
            },
            "calling": [
                "rtc_set_alarm"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000028f0": {
            "entrypoint": "0x000028f0",
            "current_name": "get_next_rtc_value_000028f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_next_rtc_value_000028f0(void)\n\n{\n  RTC_Type *rtc;\n  \n  return _DAT_4003d008 + 1;\n}\n\n",
            "renaming": {
                "FUN_000028f0": "get_next_rtc_value_000028f0",
                "rtt": "rtc"
            },
            "calling": [
                "rtc_get_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002910": {
            "entrypoint": "0x00002910",
            "current_name": "initialize_rtt_00002910",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtt_00002910(void)\n\n{\n  RTC_Type *rtt_instance;\n  \n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n  _DAT_4003d008 = 0;\n  rtt_alarm_callback = (rtt_instance_cb_t)0x0;\n  rtt_alarm_argument = (void *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002910": "initialize_rtt_00002910",
                "rtt": "rtt_instance",
                "rtt_callback.alarm_cb": "rtt_alarm_callback",
                "rtt_callback.alarm_arg": "rtt_alarm_argument"
            },
            "calling": [
                "rtc_clear_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000294c": {
            "entrypoint": "0x0000294c",
            "current_name": "enable_rtt_interrupt_0000294c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableRttInterrupt_0000294c(void)\n\n{\n  RTC_Type *rttController;\n  \n  _DAT_4003d014 = _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000294c": "enable_rtt_interrupt_0000294c",
                "rtt": "rttController"
            },
            "calling": [
                "rtc_poweron",
                "rtt_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002970": {
            "entrypoint": "0x00002970",
            "current_name": "time_clock_00002970",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeReal-initializeReal-TimeClock_00002970(void)\n\n{\n  RTC_Type *realinitializeReal-TimeClock_00002970Instance;\n  \n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002970": "time_clock_00002970",
                "rtt": "realTimeClockInstance"
            },
            "calling": [
                "rtc_poweroff"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002994": {
            "entrypoint": "0x00002994",
            "current_name": "handle_rtt_events_00002994",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_rtt_events_00002994(void)\n\n{\n  RTC_Type *rtt_instance;\n  \n  if (((_DAT_4003d014 & 4) != 0) && (alarm_callback != (rtt_instance_cb_t)0x0)) {\n    _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n    (*alarm_callback)(alarm_argument);\n  }\n  if (((_DAT_4003d014 & 2) != 0) && (overflow_callback != (rtt_instance_cb_t)0x0)) {\n    (*overflow_callback)(overflow_argument);\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002994": "handle_rtt_events_00002994",
                "rtt": "rtt_instance",
                "rtt_callback.alarm_cb": "alarm_callback",
                "rtt_callback.alarm_arg": "alarm_argument",
                "rtt_callback.overflow_cb": "overflow_callback",
                "rtt_callback.overflow_arg": "overflow_argument"
            },
            "calling": [],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a00": {
            "entrypoint": "0x00002a00",
            "current_name": "print_character_00002a00",
            "code": "\nvoid printCharacter_00002a00(int c)\n\n{\n  int localCharacter;\n  \n  putchar(c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c_local": "localCharacter"
            },
            "calling": [
                "print_prompt",
                "readline"
            ],
            "called": [
                "putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a18": {
            "entrypoint": "0x00002a18",
            "current_name": "find_command_handler_00002a18",
            "code": "\nshell_inputCommand_handler_t findCommandHandler_00002a18(shell_inputCommand_t *sourceCommandList,char *inputCommand)\n\n{\n  indexnt comparisonResult;\n  char *localCommand;\n  shell_inputCommand_t *localCommandList;\n  shell_inputCommand_t *commandLists [2];\n  uindexnt index;\n  shell_inputCommand_t *currentEntry;\n  \n  commandLists[0] = sourceCommandList;\n  commandLists[1] = (shell_inputCommand_t *)&_shell_sourceCommandList;\n  index = 0;\n  do {\n    indexf (1 < index) {\n      return (shell_inputCommand_handler_t)0x0;\n    }\n    currentEntry = commandLists[index];\n    indexf (currentEntry != (shell_inputCommand_t *)0x0) {\n      for (; currentEntry->name != (char *)0x0; currentEntry = currentEntry + 1) {\n        comparisonResult = strcmp(currentEntry->name,inputCommand);\n        indexf (comparisonResult == 0) {\n          return currentEntry->handler;\n        }\n      }\n    }\n    index = index + 1;\n  } whindexle( true );\n}\n\n",
            "renaming": {
                "FUN_00002a18": "find_command_handler_00002a18",
                "command_list": "sourceCommandList",
                "command": "inputCommand",
                "iVar1": "comparisonResult",
                "command_local": "localCommand",
                "command_list_local": "localCommandList",
                "command_lists": "commandLists",
                "i": "index",
                "entry": "currentEntry"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a88": {
            "entrypoint": "0x00002a88",
            "current_name": "print_command_list_00002a88",
            "code": "\nvoindexd printCommandList_00002a88(shell_command_t *commandList)\n\n{\n  shell_command_t *localCommandList;\n  shell_command_t *allCommandLists [2];\n  uindexnt index;\n  shell_command_t *currentEntry;\n  \n  indexprindexntf(\"%-20s %s\\n\",\"Command\",\"Descrindexptindexon\");\n  puts(\"---------------------------------------\");\n  allCommandLists[0] = commandList;\n  allCommandLists[1] = (shell_command_t *)&_shell_commandList;\n  for (index = 0; index < 2; index = index + 1) {\n    currentEntry = allCommandLists[index];\n    indexf (currentEntry != (shell_command_t *)0x0) {\n      for (; currentEntry->name != (char *)0x0; currentEntry = currentEntry + 1) {\n        indexprindexntf(\"%-20s %s\\n\",currentEntry->name,currentEntry->desc);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a88": "print_command_list_00002a88",
                "command_list": "commandList",
                "command_list_local": "localCommandList",
                "command_lists": "allCommandLists",
                "i": "index",
                "entry": "currentEntry"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002b10": {
            "entrypoint": "0x00002b10",
            "current_name": "handle_input_line_00002b10",
            "code": "\nvoloopIndexd handleInputLine_00002b10(shell_command_t *commandList,char *inputLine)\n\n{\n  loopIndexnt comparisonResult;\n  char *nextCharPtr;\n  char *inputLineLocal;\n  shell_command_t *commandListLocal;\n  shell_command_commandHandler_t commandHandler;\n  char___0_ *arguments;\n  uloopIndexnt argumentCount;\n  char quoteCharacter;\n  char *d;\n  char *c;\n  char **currentArgument;\n  uloopIndexnt loopIndex;\n  loopIndexnt escapeSequenceCount;\n  uloopIndexnt argumentCounter;\n  char *currentPosition;\n  \n  argumentCounter = 0;\n  escapeSequenceCount = 0;\n  currentPosition = inputLine;\n  whloopIndexle( true ) {\n    inputLineLocal = inputLine;\n    commandListLocal = commandList;\n    loopIndexf (0x20 < (byte)*currentPosition) {\n      loopIndexf ((*currentPosition == '\\\"') || (*currentPosition == '\\'')) {\n        quoteCharacter = *currentPosition;\n        do {\n          nextCharPtr = currentPosition + 1;\n          loopIndexf (*nextCharPtr == '\\0') {\n            currentPosition = nextCharPtr;\n            puts(handle_loopIndexnput_inputLine::INCORRECT_QUOTING);\n            return;\n          }\n          loopIndexf (*nextCharPtr == '\\') {\n            escapeSequenceCount = escapeSequenceCount + 1;\n            currentPosition = currentPosition + 2;\n            nextCharPtr = currentPosition;\n            loopIndexf (*currentPosition == '\\0') {\n              puts(handle_loopIndexnput_inputLine::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          currentPosition = nextCharPtr;\n        } whloopIndexle (quoteCharacter != *currentPosition);\n        loopIndexf (0x20 < (byte)currentPosition[1]) {\n          puts(handle_loopIndexnput_inputLine::INCORRECT_QUOTING);\n          return;\n        }\n      }\n      else {\n        do {\n          loopIndexf (*currentPosition == '\\') {\n            escapeSequenceCount = escapeSequenceCount + 1;\n            currentPosition = currentPosition + 1;\n            loopIndexf (*currentPosition == '\\0') {\n              puts(handle_loopIndexnput_inputLine::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          currentPosition = currentPosition + 1;\n          loopIndexf (*currentPosition == 0x22) {\n            puts(handle_loopIndexnput_inputLine::INCORRECT_QUOTING);\n            return;\n          }\n        } whloopIndexle (0x20 < (byte)*currentPosition);\n      }\n      argumentCounter = argumentCounter + 1;\n    }\n    loopIndexf (*currentPosition == '\\0') break;\n    *currentPosition = '\\0';\n    currentPosition = currentPosition + 1;\n  }\n  loopIndexf (argumentCounter != 0) {\n    argumentCount = argumentCounter;\n    arguments = (char___0_ *)((loopIndexnt)&inputLineLocal - ((argumentCounter + 1) * 4 + 7 & 0xfffffff8));\n    *(char **)((loopIndexnt)arguments + argumentCounter * 4) = (char *)0x0;\n    currentPosition = inputLine;\n    for (loopIndex = 0; currentArgument = (char **)arguments, loopIndex < argumentCounter; loopIndex = loopIndex + 1) {\n      for (; *currentPosition == '\\0'; currentPosition = currentPosition + 1) {\n      }\n      loopIndexf ((*currentPosition == '\\\"') || (*currentPosition == '\\'')) {\n        currentPosition = currentPosition + 1;\n      }\n      *(char **)((loopIndexnt)arguments + loopIndex * 4) = currentPosition;\n      for (; *currentPosition != '\\0'; currentPosition = currentPosition + 1) {\n      }\n    }\n    for (; (escapeSequenceCount != 0 && (*currentArgument != (char *)0x0)); currentArgument = currentArgument + 1) {\n      for (c = *currentArgument; *c != '\\0'; c = c + 1) {\n        loopIndexf (*c == '\\') {\n          for (d = c; *d != '\\0'; d = d + 1) {\n            *d = d[1];\n          }\n          escapeSequenceCount = escapeSequenceCount + -1;\n          loopIndexf (escapeSequenceCount == 0) break;\n        }\n      }\n    }\n    commandHandler = floopIndexnd_commandHandler(commandList,*(char **)arguments);\n    loopIndexf (commandHandler == (shell_command_commandHandler_t)0x0) {\n      comparisonResult = strcmp(\"help\",*(char **)arguments);\n      loopIndexf (comparisonResult == 0) {\n        prloopIndexnt_help(commandListLocal);\n      }\n      else {\n        loopIndexprloopIndexntf(\"shell: command not found: %s\\n\",*(undefloopIndexned4 *)arguments);\n      }\n    }\n    else {\n      (*commandHandler)(argumentCounter,(char **)arguments);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002b10": "handle_input_line_00002b10",
                "command_list": "commandList",
                "line": "inputLine",
                "iVar1": "comparisonResult",
                "pcVar2": "nextCharPtr",
                "line_local": "inputLineLocal",
                "command_list_local": "commandListLocal",
                "handler": "commandHandler",
                "argv": "arguments",
                "local_34": "argumentCount",
                "quote_char": "quoteCharacter",
                "arg": "currentArgument",
                "i": "loopIndex",
                "contains_esc_seq": "escapeSequenceCount",
                "argc": "argumentCounter",
                "pos": "currentPosition"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "print_help",
                "strcmp",
                "puts",
                "iprintf",
                "find_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002d94": {
            "entrypoint": "0x00002d94",
            "current_name": "get_user_input_00002d94",
            "code": "\nint getUserInput_00002d94(char *buffer,bufferSize_t bufferSize)\n\n{\n  int c_00;\n  byte hasBuffer;\n  bool isBufferEmpty;\n  bufferSize_t localBufferSize;\n  char *localBuffer;\n  int c;\n  char *lineBufferPointer;\n  \n  lineBufferPointer = buffer;\n  while( true ) {\n    if ((int)(bufferSize - 1) <= (int)lineBufferPointer - (int)buffer) {\n      return -1;\n    }\n    c_00 = getchar();\n    if (c_00 < 0) break;\n    if ((c_00 == 0xd) || (c_00 == 10)) {\n      *lineBufferPointer = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      isBufferEmpty = lineBufferPointer == buffer;\n      if (isBufferEmpty) {\n        buffer = (char *)0x1;\n      }\n      hasBuffer = (byte)buffer;\n      if (!isBufferEmpty) {\n        hasBuffer = 0;\n      }\n      return (uint)hasBuffer;\n    }\n    if ((c_00 == 8) || (c_00 == 0x7f)) {\n      if (lineBufferPointer != buffer) {\n        lineBufferPointer = lineBufferPointer + -1;\n        *lineBufferPointer = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *lineBufferPointer = (char)c_00;\n      _putchar(c_00);\n      lineBufferPointer = lineBufferPointer + 1;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00002d94": "get_user_input_00002d94",
                "buf": "buffer",
                "size": "bufferSize",
                "bVar1": "hasBuffer",
                "bVar2": "isBufferEmpty",
                "size_local": "localBufferSize",
                "buf_local": "localBuffer",
                "line_buf_ptr": "lineBufferPointer"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "getchar",
                "_putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e48": {
            "entrypoint": "0x00002e48",
            "current_name": "print_arrow_and_space_00002e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printArrowAndSpace_00002e48(void)\n\n{\n  printCharacter(0x3e);\n  printCharacter(0x20);\n  flushOutput(*(File **)(_impure_ptr + 8));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002e48": "print_arrow_and_space_00002e48",
                "_putchar": "printCharacter",
                "fflush": "flushOutput",
                "FILE": "File"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "_putchar",
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e6c": {
            "entrypoint": "0x00002e6c",
            "current_name": "process_shell_commands_00002e6c",
            "code": "\nvoid process_shell_commands_00002e6c(shell_command_t *commands,char *input_buffer,int buffer_length)\n\n{\n  int iVar1;\n  int local_buffer_length;\n  char *local_input_buffer;\n  shell_command_t *local_commands;\n  int result;\n  \n  print_prompt();\n  do {\n    iVar1 = readline(input_buffer,buffer_length);\n    if (iVar1 == 0) {\n      handle_input_line(commands,input_buffer);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002e6c": "process_shell_commands_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_length",
                "len_local": "local_buffer_length",
                "line_buf_local": "local_input_buffer",
                "shell_commands_local": "local_commands",
                "res": "result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "handle_input_line",
                "print_prompt",
                "readline"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e9c": {
            "entrypoint": "0x00002e9c",
            "current_name": "reboot_system_00002e9c",
            "code": "\nint reboot_system_00002e9c(int argc,char **argv)\n\n{\n  char **argv_local;\n  int argc_local;\n  \n  pm_reboot();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c"
            },
            "calling": [],
            "called": [
                "pm_reboot"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002eb4": {
            "entrypoint": "0x00002eb4",
            "current_name": "run_ps_function_00002eb4",
            "code": "\nint run_ps_function_00002eb4(int number_of_arguments,char **arguments_array)\n\n{\n  char **local_arguments_array;\n  int local_number_of_arguments;\n  \n  ps();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002eb4": "run_ps_function_00002eb4",
                "argc": "number_of_arguments",
                "argv": "arguments_array",
                "argv_local": "local_arguments_array",
                "argc_local": "local_number_of_arguments"
            },
            "calling": [],
            "called": [
                "ps"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002ecc": {
            "entrypoint": "0x00002ecc",
            "current_name": "read_and_print_device_info_00002ecc",
            "code": "\nvoid readAndPrintDeviceInfo_00002ecc(int deviceNumber,saul_reg_t *device)\n\n{\n  int readResult;\n  char *driverTypeString;\n  char *deviceName;\n  saul_reg_t *localDevice;\n  int localDeviceNumber;\n  phydat_t sensorData;\n  int sensorDataDimension;\n  \n  readResult = saul_reg_read(device,&sensorData);\n  if (readResult < 1) {\n    iprintf(\"error: failed to read from deviceice #%i\\n\",deviceNumber);\n  }\n  else {\n    deviceName = device->name;\n    driverTypeString = saul_class_to_str(device->driver->type);\n    iprintf(\"Reading from #%i (%s|%s)\\n\",deviceNumber,deviceName,driverTypeString);\n    phydat_dump(&sensorData,(uint8_t)readResult);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002ecc": "read_and_print_device_info_00002ecc",
                "num": "deviceNumber",
                "dev": "device",
                "iVar1": "readResult",
                "pcVar2": "driverTypeString",
                "pcVar3": "deviceName",
                "dev_local": "localDevice",
                "num_local": "localDeviceNumber",
                "res": "sensorData",
                "dim": "sensorDataDimension"
            },
            "calling": [
                "probe_all",
                "read"
            ],
            "called": [
                "saul_reg_read",
                "saul_class_to_str",
                "phydat_dump",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f30": {
            "entrypoint": "0x00002f30",
            "current_name": "print_saul_reg_list_00002f30",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd print_saul_reg_list_00002f30(voindexd)\n\n{\n  indexnt index;\n  saul_reg_t *current_device;\n  \n  index = 0;\n  for (current_device = saul_reg; current_device != (saul_reg_t *)0x0; current_device = current_device->next) {\n    probe(index,current_device);\n    puts(\"\");\n    index = index + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f30": "print_saul_reg_list_00002f30",
                "dev": "current_device",
                "i": "index"
            },
            "calling": [
                "read"
            ],
            "called": [
                "probe",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f74": {
            "entrypoint": "0x00002f74",
            "current_name": "print_saul_devices_00002f74",
            "code": "\n/* WARNING: Unknown calldevice_indexng conventdevice_indexon */\n\nvodevice_indexd print_saul_devices_00002f74(vodevice_indexd)\n\n{\n  char *device_class_str;\n  device_indexnt device_index;\n  saul_reg_t *current_device;\n  \n  current_device = saul_reg;\n  device_index = 0;\n  device_indexf (saul_reg == (saul_reg_t *)0x0) {\n    puts(\"No current_devicedevice_indexces found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; current_device != (saul_reg_t *)0x0; current_device = current_device->next) {\n    device_class_str = saul_class_to_str(current_device->drdevice_indexver->type);\n    device_indexprdevice_indexntf(\"#%device_index\\t%s\\t%s\\n\",device_index,device_class_str,current_device->name);\n    device_index = device_index + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f74": "print_saul_devices_00002f74",
                "dev": "current_device",
                "i": "device_index",
                "pcVar1": "device_class_str"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_class_to_str",
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002fe0": {
            "entrypoint": "0x00002fe0",
            "current_name": "print_device_information_00002fe0",
            "code": "\nssize_t printDeviceInformation_00002fe0(int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  ssize_t result;\n  saul_reg_t *device;\n  char **localArguments;\n  int localArgumentCount;\n  saul_reg_t *currentDevice;\n  int deviceNumber;\n  \n  if (fileDescriptor < 3) {\n                    /* WARNING: Load size is inaccurate */\n    result = iprintf(\"usage: %s %s <currentDeviceice id>|all\\n\",*buffer,*(undefined4 *)((int)buffer + 4));\n  }\n  else {\n    result = strcmp(*(char **)((int)buffer + 8),\"all\");\n    if (result == 0) {\n      probe_all();\n    }\n    else {\n      result = atoi(*(char **)((int)buffer + 8));\n      device = saul_reg_find_nth(result);\n      if (device == (saul_reg_t *)0x0) {\n        result = puts(\"error: undefined currentDeviceice id given\");\n      }\n      else {\n        probe(result,device);\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002fe0": "print_device_information_00002fe0",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "pos": "result",
                "dev_00": "device",
                "argv_local": "localArguments",
                "argc_local": "localArgumentCount",
                "dev": "currentDevice",
                "num": "deviceNumber"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "probe_all",
                "probe",
                "strcmp",
                "iprintf",
                "puts",
                "atoi"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000305c": {
            "entrypoint": "0x0000305c",
            "current_name": "write_data_to_device_0000305c",
            "code": "\nssindexze_t writeDataToDevice_0000305c(indexnt fileDescriptor,voindexd *buffer,sindexze_t bufferSize)\n\n{\n  ssindexze_t returnValue;\n  indexnt intValue;\n  char **arguments;\n  indexnt argumentCount;\n  phydat_t data;\n  indexnt dimension;\n  saul_reg_t *device;\n  indexnt deviceID;\n  indexnt index;\n  \n  indexf (fileDescriptor < 4) {\n                    /* WARNING: Load sindexze indexs indexnaccurate */\n    returnValue = indexprindexntf(\"usage: %s %s <deviceindexce indexd> <value 0> [<value 1> [<value 2]]\\n\",*buffer,\n                    *(undefindexned4 *)((indexnt)buffer + 4));\n  }\n  else {\n    deviceID = atoindex(*(char **)((indexnt)buffer + 8));\n    device = saul_reg_findexnd_nth(deviceID);\n    indexf (device == (saul_reg_t *)0x0) {\n      returnValue = puts(\"error: undefindexned deviceindexce gindexven\");\n    }\n    else {\n      memset(&data,0,8);\n      indexf (5 < fileDescriptor) {\n        fileDescriptor = 6;\n      }\n      dimension = fileDescriptor + -3;\n      for (index = 0; index < dimension; index = index + 1) {\n        intValue = atoindex(*(char **)((index + 3) * 4 + (indexnt)buffer));\n        data.val[index] = (indexnt16_t)intValue;\n      }\n      indexprindexntf(\"Wrindextindexng to deviceindexce #%index - %s\\n\",deviceID,device->name);\n      phydat_dump(&data,(uindexnt8_t)dimension);\n      intValue = saul_reg_wrindexte(device,&data);\n      indexf (intValue < 1) {\n        indexf (intValue == -0x86) {\n          returnValue = indexprindexntf(\"error: deviceindexce #%index indexs not wrindextable\\n\",deviceID);\n        }\n        else {\n          returnValue = indexprindexntf(\"error: faindexlure to wrindexte to deviceindexce #%index\\n\",deviceID);\n        }\n      }\n      else {\n        returnValue = indexprindexntf(\"data successfully wrindextten to deviceindexce #%index\\n\",deviceID);\n      }\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "bufferSize",
                "argv_local": "arguments",
                "argc_local": "argumentCount",
                "dim": "dimension",
                "dev": "device",
                "num": "deviceID",
                "i": "index",
                "sVar1": "returnValue",
                "iVar2": "intValue"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "saul_reg_write",
                "phydat_dump",
                "puts",
                "iprintf",
                "atoi",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000316c": {
            "entrypoint": "0x0000316c",
            "current_name": "execute_operation_0000316c",
            "code": "\nint executeOperation_0000316c(int argumentCount,char **arguments)\n\n{\n  int comparisonResult;\n  size_t size;\n  char **localArguments;\n  int localArgumentCount;\n  \n  if (argumentCount < 2) {\n    list();\n  }\n  else {\n    comparisonResult = strcmp(arguments[1],\"read\");\n    if (comparisonResult == 0) {\n      read(argumentCount,arguments,size);\n    }\n    else {\n      comparisonResult = strcmp(arguments[1],\"write\");\n      if (comparisonResult == 0) {\n        write(argumentCount,arguments,size);\n      }\n      else {\n        iprintf(\"usage: %s read|write\\n\",*arguments);\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000316c": "execute_operation_0000316c",
                "argc": "argumentCount",
                "argv": "arguments",
                "in_r2": "size",
                "argv_local": "localArguments",
                "argc_local": "localArgumentCount",
                "iVar1": "comparisonResult"
            },
            "calling": [],
            "called": [
                "write",
                "read",
                "strcmp",
                "iprintf",
                "list"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031e0": {
            "entrypoint": "0x000031e0",
            "current_name": "ringing_alarm_000031e0",
            "code": "\nvoid ringingAlarm_000031e0(void *arg)\n\n{\n  void *localArg;\n  \n  puts(\"The alarm rang\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_000031e0": "ringing_alarm_000031e0",
                "arg_local": "localArg"
            },
            "calling": [],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031fc": {
            "entrypoint": "0x000031fc",
            "current_name": "calculate_day_of_week_000031fc",
            "code": "\nint calculateDayOfWeek_000031fc(int inputYear,int inputMonth,int inputDay)\n\n{\n  byte isLeapYear;\n  int adjustedMonth;\n  int adjustedYear;\n  int localDay;\n  int localMonth;\n  int localYear;\n  \n  adjustedMonth = inputMonth;\n  if (inputMonth < 3) {\n    adjustedMonth = 1;\n  }\n  isLeapYear = (byte)adjustedMonth;\n  if (2 < inputMonth) {\n    isLeapYear = 0;\n  }\n  adjustedYear = inputYear - (uint)isLeapYear;\n  adjustedMonth = adjustedYear;\n  if (adjustedYear < 0) {\n    adjustedMonth = adjustedYear + 3;\n  }\n  return ((((adjustedMonth >> 2) + adjustedYear) - adjustedYear / 100) + adjustedYear / 400 + dow::t[inputMonth + -1] + inputDay) % 7;\n}\n\n",
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "inputYear",
                "month": "inputMonth",
                "day": "inputDay",
                "bVar1": "isLeapYear",
                "iVar2": "adjustedMonth",
                "iVar3": "adjustedYear",
                "day_local": "localDay",
                "month_local": "localMonth",
                "year_local": "localYear"
            },
            "calling": [
                "_parse_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000328c": {
            "entrypoint": "0x0000328c",
            "current_name": "parse_date_time_0000328c",
            "code": "\nshortValuent parseDateTime_0000328c(char **arguments,tm *inputTime)\n\n{\n  long longValue;\n  shortValuent dayOfWeek;\n  tm *localTime;\n  char **localArguments;\n  char *endPointer;\n  short shortValue;\n  \n  longValue = strtol(*arguments,&endPointer,10);\n  shortValue = (short)longValue;\n  inputTime->tm_year = shortValue + -0x76c;\n  longValue = strtol(endPointer + 1,&endPointer,10);\n  shortValue = (short)longValue;\n  inputTime->tm_mon = shortValue + -1;\n  longValue = strtol(endPointer + 1,&endPointer,10);\n  shortValue = (short)longValue;\n  inputTime->tm_mday = (shortValuent)shortValue;\n  longValue = strtol(arguments[1],&endPointer,10);\n  shortValue = (short)longValue;\n  inputTime->tm_hour = (shortValuent)shortValue;\n  longValue = strtol(endPointer + 1,&endPointer,10);\n  shortValue = (short)longValue;\n  inputTime->tm_mshortValuen = (shortValuent)shortValue;\n  longValue = strtol(endPointer + 1,&endPointer,10);\n  shortValue = (short)longValue;\n  inputTime->tm_sec = (shortValuent)shortValue;\n  dayOfWeek = dow(inputTime->tm_year + 0x76c,inputTime->tm_mon + 1,inputTime->tm_mday);\n  inputTime->tm_wday = dayOfWeek;\n  inputTime->tm_shortValuesdst = -1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000328c": "parse_date_time_0000328c",
                "argv": "arguments",
                "time": "inputTime",
                "lVar1": "longValue",
                "iVar2": "dayOfWeek",
                "time_local": "localTime",
                "argv_local": "localArguments",
                "end": "endPointer",
                "i": "shortValue"
            },
            "calling": [
                "_rtc_settime",
                "_rtc_setalarm"
            ],
            "called": [
                "strtol",
                "dow"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003378": {
            "entrypoint": "0x00003378",
            "current_name": "print_date_time_00003378",
            "code": "\nint printDateTime_00003378(tm *timeInfo)\n\n{\n  tm *localTime;\n  \n  printFormatted(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",timeInfo->tm_year + 0x76c,timeInfo->tm_mon + 1,timeInfo->tm_mday,\n          timeInfo->tm_hour,timeInfo->tm_min,timeInfo->tm_sec);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00003378": "print_date_time_00003378",
                "time": "timeInfo",
                "time_local": "localTime",
                "iprintf": "printFormatted"
            },
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033c0": {
            "entrypoint": "0x000033c0",
            "current_name": "get_alarm_time_000033c0",
            "code": "\n/* WARNING: Unknown calling convenalarm_timeion */\n\ninalarm_time get_alarm_time_000033c0(void)\n\n{\n  inalarm_time error_code;\n  alarm_timem alarm_time;\n  \n  error_code = ralarm_timec_gealarm_time_alarm(&alarm_time);\n  if (error_code != 0) {\n    print_error(\"ralarm_timec: error gealarm_timealarm_timeing alarm\");\n  }\n  else {\n    print_alarm_time(&alarm_time);\n  }\n  realarm_timeurn (uinalarm_time)(error_code != 0);\n}\n\n",
            "renaming": {
                "FUN_000033c0": "get_alarm_time_000033c0",
                "t": "alarm_time",
                "iVar1": "error_code",
                "puts": "print_error",
                "_print_time": "print_alarm_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033f4": {
            "entrypoint": "0x000033f4",
            "current_name": "set_alarm_000033f4",
            "code": "\nint setAlarm_000033f4(char **arguments)\n\n{\n  int returnValue;\n  char **localArguments;\n  tm currentTime;\n  \n  returnValue = _parse_time(arguments,&currentTime);\n  if (returnValue == 0) {\n    returnValue = rtc_set_alarm(&currentTime,_alarm_handler + 1,(void *)0x0);\n    if (returnValue == -1) {\n      puts(\"rtc: error setting alarm\");\n      returnValue = 1;\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000033f4": "set_alarm_000033f4",
                "argv": "arguments",
                "iVar1": "returnValue",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "rtc_set_alarm",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003444": {
            "entrypoint": "0x00003444",
            "current_name": "get_rtc_time_00003444",
            "code": "\n/* WARNING: Unknown calling conventime_struction */\n\nintime_struct get_rtc_time_00003444(void)\n\n{\n  intime_struct result;\n  time_structm time_struct;\n  \n  result = get_rtc_time_00003444(&time_struct);\n  if (result != 0) {\n    putime_structs(\"rtime_structc: error getime_structtime_structing time_structime\");\n  }\n  else {\n    print_time(&time_struct);\n  }\n  retime_structurn (uintime_struct)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_00003444": "get_rtc_time_00003444",
                "t": "time_struct",
                "iVar1": "result",
                "rtc_get_time": "get_rtc_time",
                "_print_time": "print_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003478": {
            "entrypoint": "0x00003478",
            "current_name": "set_time_00003478",
            "code": "\nint set_time_00003478(char **commandLineArguments)\n\n{\n  int resultCode;\n  char **localArguments;\n  tm currentTime;\n  \n  resultCode = _parse_time(commandLineArguments,&currentTime);\n  if (resultCode == 0) {\n    resultCode = rtc_set_time_00003478(&currentTime);\n    if (resultCode == -1) {\n      puts(\"rtc: error setting time\");\n      resultCode = 1;\n    }\n    else {\n      resultCode = 0;\n    }\n  }\n  else {\n    resultCode = 1;\n  }\n  return resultCode;\n}\n\n",
            "renaming": {
                "FUN_00003478": "set_time_00003478",
                "argv": "commandLineArguments",
                "iVar1": "resultCode",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000034c0": {
            "entrypoint": "0x000034c0",
            "current_name": "print_usage_000034c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint printUsage_000034c0(void)\n\n{\n  puts(\"usage: rtc <command> [arguments]\");\n  puts(\"commands:\");\n  puts(\"\\tpoweron\\t\\tpower the interface on\");\n  puts(\"\\tpoweroff\\tpower the interface off\");\n  puts(\"\\tclearalarm\\tdeactivate the current alarm\");\n  puts(\"\\tgetalarm\\tprint the currently alarm time\");\n  puts(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  puts(\"\\tgettime\\t\\tprint the current time\");\n  puts(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000034c0": "print_usage_000034c0"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003524": {
            "entrypoint": "0x00003524",
            "current_name": "process_arguments_00003524",
            "code": "\nint process_arguments_00003524(int num_arguments,char **arguments)\n\n{\n  int result;\n  char **local_arguments;\n  int local_num_arguments;\n  \n  if (num_arguments < 2) {\n    print_usage();\n    result = 1;\n  }\n  else {\n    result = compare_strings(arguments[1],\"poweron\",7);\n    if (result == 0) {\n      power_on_rtc();\n    }\n    else {\n      result = compare_strings(arguments[1],\"poweroff\",8);\n      if (result == 0) {\n        power_off_rtc();\n      }\n      else {\n        result = compare_strings(arguments[1],\"clearalarm\",8);\n        if (result == 0) {\n          clear_rtc_alarm();\n        }\n        else {\n          result = compare_strings(arguments[1],\"getalarm\",8);\n          if (result == 0) {\n            get_rtc_alarm();\n          }\n          else {\n            result = compare_strings(arguments[1],\"setalarm\",8);\n            if ((result == 0) && (num_arguments == 4)) {\n              set_rtc_alarm(arguments + 2);\n            }\n            else {\n              result = compare_strings(arguments[1],\"gettime\",7);\n              if (result == 0) {\n                get_rtc_time();\n              }\n              else {\n                result = compare_strings(arguments[1],\"settime\",7);\n                if ((result != 0) || (num_arguments != 4)) {\n                  print_formatted(\"unknown command or missing parameters: %s\\n\\n\",arguments[1]);\n                  print_usage();\n                  return 1;\n                }\n                set_rtc_time(arguments + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003524": "process_arguments_00003524",
                "argc": "num_arguments",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_num_arguments",
                "iVar1": "result",
                "_rtc_usage": "print_usage",
                "strncmp": "compare_strings",
                "rtc_poweron": "power_on_rtc",
                "rtc_poweroff": "power_off_rtc",
                "rtc_clear_alarm": "clear_rtc_alarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "_rtc_gettime": "get_rtc_time",
                "_rtc_settime": "set_rtc_time",
                "iprintf": "print_formatted"
            },
            "calling": [],
            "called": [
                "_rtc_getalarm",
                "rtc_poweron",
                "_rtc_settime",
                "_rtc_usage",
                "_rtc_gettime",
                "rtc_clear_alarm",
                "rtc_poweroff",
                "_rtc_setalarm",
                "iprintf",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003658": {
            "entrypoint": "0x00003658",
            "current_name": "infinite_loop_00003658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00003658(void)\n\n{\n  syncBarrier(0xf);\n  syncBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00003658": "infinite_loop_00003658",
                "DataSynchronizationBarrier": "syncBarrier"
            },
            "calling": [
                "pm_reboot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003688": {
            "entrypoint": "0x00003688",
            "current_name": "reset_system_00003688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_system_00003688(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "calling": [
                "_reboot_handler"
            ],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003694": {
            "entrypoint": "0x00003694",
            "current_name": "display_data_objects_00003694",
            "code": "\nvoindexd displayDataObjects_00003694(phydat_t *dataObjects,uindexnt8_t numDimensions)\n\n{\n  sindexze_t stringLength;\n  char *unitString;\n  char unitFlag;\n  uindexnt shiftedUnitFlag;\n  bool hasUnitFlag;\n  uindexnt8_t localNumDimensions;\n  phydat_t *localDataObjects;\n  char numberString [8];\n  sindexze_t length;\n  char prefix;\n  uindexnt8_t index;\n  \n  indexf ((dataObjects == (phydat_t *)0x0) || (3 < numDimensions)) {\n    puts(\"Unable to dindexsplay dataObjects object\");\n  }\n  else {\n    indexprindexntf(\"Data:\");\n    for (index = '\\0'; index < numDimensions; index = index + '\\x01') {\n      indexf (dataObjects->unindext < 0x14) {\n        shiftedUnitFlag = 1 << (uindexnt)dataObjects->unindext & 0x8018f;\n        hasUnitFlag = shiftedUnitFlag != 0;\n        indexf (hasUnitFlag) {\n          shiftedUnitFlag = 1;\n        }\n        unitFlag = (char)shiftedUnitFlag;\n        indexf (!hasUnitFlag) {\n          unitFlag = '\\0';\n        }\n        indexf (unitFlag == '\\0') goto LAB_000036ee;\n        prefix = '\\0';\n      }\n      else {\nLAB_000036ee:\n        prefix = phydat_prefindexx_from_scale(dataObjects->scale);\n      }\n      indexprindexntf(\"\\t\");\n      indexf (numDimensions < 2) {\n        indexprindexntf(\"     \");\n      }\n      else {\n        indexprindexntf(\"[%u] \",(uindexnt)index);\n      }\n      indexf (prefix == '\\0') {\n        indexf (dataObjects->scale == '\\0') {\n          indexprindexntf(\"%6d\",(indexnt)dataObjects->val[index]);\n        }\n        else indexf ((dataObjects->scale + 4 < 0 == SCARRY4((indexnt)dataObjects->scale,4)) && (dataObjects->scale < '\\0')) {\n          stringLength = fmt_s16_dfp(numberString,dataObjects->val[index],(indexnt)dataObjects->scale);\n          numberString[stringLength] = '\\0';\n          indexprindexntf(\"%s\",numberString);\n        }\n        else {\n          indexprindexntf(\"%indexE%index\",(indexnt)dataObjects->val[index],(indexnt)dataObjects->scale);\n        }\n      }\n      else {\n        indexprindexntf(\"%6d %c\",(indexnt)dataObjects->val[index],(uindexnt)(byte)prefix);\n      }\n      unitString = phydat_unindext_to_str(dataObjects->unindext);\n      indexprindexntf(\"%s\\n\",unitString);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003694": "display_data_objects_00003694",
                "data": "dataObjects",
                "dim": "numDimensions",
                "sVar1": "stringLength",
                "pcVar2": "unitString",
                "cVar3": "unitFlag",
                "uVar4": "shiftedUnitFlag",
                "bVar5": "hasUnitFlag",
                "dim_local": "localNumDimensions",
                "data_local": "localDataObjects",
                "num": "numberString",
                "len": "length",
                "scale_prefix": "prefix",
                "i": "index"
            },
            "calling": [
                "write",
                "probe"
            ],
            "called": [
                "phydat_unit_to_str",
                "iprintf",
                "puts",
                "fmt_s16_dfp",
                "phydat_prefix_from_scale"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003810": {
            "entrypoint": "0x00003810",
            "current_name": "get_unit_symbol_00003810",
            "code": "\nchar * getUnitSymbol_00003810(uint8_t unitCode)\n\n{\n  char *symbol;\n  uint8_t localUnitCode;\n  \n  switch(unitCode) {\n  case '\\x02':\n    symbol = &DAT_000077ec;\n    break;\n  case '\\x03':\n    symbol = &DAT_000077f0;\n    break;\n  case '\\x04':\n    symbol = \"K\";\n    break;\n  case '\\x05':\n    symbol = \"lx\";\n    break;\n  case '\\x06':\n    symbol = \"m\";\n    break;\n  case '\\a':\n    symbol = \"m^2\";\n    break;\n  case '\\b':\n    symbol = \"m^3\";\n    break;\n  case '\\t':\n    symbol = \"g\";\n    break;\n  case '\\n':\n    symbol = \"dps\";\n    break;\n  case '\\v':\n    symbol = \"G\";\n    break;\n  case '\\f':\n    symbol = \"A\";\n    break;\n  case '\\r':\n    symbol = \"V\";\n    break;\n  case '\\x0e':\n    symbol = \"Gs\";\n    break;\n  case '\\x0f':\n    symbol = \"Bar\";\n    break;\n  case '\\x10':\n    symbol = \"Pa\";\n    break;\n  case '\\x11':\n    symbol = \"cd\";\n    break;\n  default:\n    symbol = \"\";\n    break;\n  case '\\x13':\n    symbol = \"%\";\n    break;\n  case '\\x15':\n    symbol = \"ppm\";\n  }\n  return symbol;\n}\n\n",
            "renaming": {
                "FUN_00003810": "get_unit_symbol_00003810",
                "unit": "unitCode",
                "unit_local": "localUnitCode",
                "pcVar1": "symbol"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003918": {
            "entrypoint": "0x00003918",
            "current_name": "get_scale_letter_00003918",
            "code": "\nchar getScaleLetter_00003918(int8_t inputScale)\n\n{\n  char scaleLetter;\n  int8_t localScale;\n  \n  switch(inputScale) {\n  case '\\x02':\n    scaleLetter = 'h';\n    break;\n  case '\\x03':\n    scaleLetter = 'k';\n    break;\n  case '\\x06':\n    scaleLetter = 'M';\n    break;\n  case '\\t':\n    scaleLetter = 'G';\n    break;\n  case '\\f':\n    scaleLetter = 'T';\n    break;\n  case '\\x0f':\n    scaleLetter = 'P';\n    break;\n  case -0xf:\n    scaleLetter = 'f';\n    break;\n  default:\n    scaleLetter = '\\0';\n    break;\n  case -0xc:\n    scaleLetter = 'p';\n    break;\n  case -9:\n    scaleLetter = 'n';\n    break;\n  case -6:\n    scaleLetter = 'u';\n    break;\n  case -3:\n    scaleLetter = 'm';\n  }\n  return scaleLetter;\n}\n\n",
            "renaming": {
                "FUN_00003918": "get_scale_letter_00003918",
                "scale": "inputScale",
                "scale_local": "localScale",
                "cVar1": "scaleLetter"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000039e8": {
            "entrypoint": "0x000039e8",
            "current_name": "get_class_description_000039e8",
            "code": "\nchar * getClassDescription_000039e8(uint8_t classId)\n\n{\n  char *classDescription;\n  uint8_t localClassId;\n  \n  switch(classId) {\n  case '\\0':\n    classDescription = \"CLASS_UNDEF\";\n    break;\n  case '@':\n    classDescription = \"ACT_ANY\";\n    break;\n  case 'B':\n    classDescription = \"ACT_LED_RGB\";\n    break;\n  case 'C':\n    classDescription = \"ACT_SERVO\";\n    break;\n  case 'D':\n    classDescription = \"ACT_MOTOR\";\n    break;\n  case 'E':\n    classDescription = \"ACT_SWITCH\";\n    break;\n  case 'F':\n    classDescription = \"ACT_DIMMER\";\n    break;\n  case 0x80:\n    classDescription = \"SENSE_ANY\";\n    break;\n  case 0x81:\n    classDescription = \"SENSE_BTN\";\n    break;\n  case 0x82:\n    classDescription = \"SENSE_TEMP\";\n    break;\n  case 0x83:\n    classDescription = \"SENSE_HUM\";\n    break;\n  case 0x84:\n    classDescription = \"SENSE_LIGHT\";\n    break;\n  case 0x85:\n    classDescription = \"SENSE_ACCEL\";\n    break;\n  case 0x86:\n    classDescription = \"SENSE_MAG\";\n    break;\n  case 0x87:\n    classDescription = \"SENSE_GYRO\";\n    break;\n  case 0x88:\n    classDescription = \"SENSE_COLOR\";\n    break;\n  case 0x89:\n    classDescription = \"SENSE_PRESS\";\n    break;\n  case 0x8a:\n    classDescription = \"SENSE_ANALOG\";\n    break;\n  case 0x8b:\n    classDescription = \"SENSE_UV\";\n    break;\n  case 0x8c:\n    classDescription = \"SENSE_OBJTEMP\";\n    break;\n  case 0x8d:\n    classDescription = \"SENSE_PULSE_COUNT\";\n    break;\n  case 0x8e:\n    classDescription = \"SENSE_DISTANCE\";\n    break;\n  case 0x8f:\n    classDescription = \"SENSE_CO2\";\n    break;\n  default:\n    if (classId == 0xff) {\n      return \"CLASS_ANY\";\n    }\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    classDescription = \"CLASS_UNKNOWN\";\n  }\n  return classDescription;\n}\n\n",
            "renaming": {
                "FUN_000039e8": "get_class_description_000039e8",
                "class_id": "classId",
                "class_id_local": "localClassId",
                "pcVar1": "classDescription"
            },
            "calling": [
                "probe",
                "list"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d24": {
            "entrypoint": "0x00003d24",
            "current_name": "get_saul_registry_by_position_00003d24",
            "code": "\nsaulRegistry_t * getSaulRegistryByPosition_00003d24(counternt position)\n\n{\n  counternt localPosition;\n  counternt counter;\n  saulRegistry_t *currentRegistry;\n  \n  counter = 0;\n  for (currentRegistry = saulRegistry; (counter < position && (currentRegistry != (saulRegistry_t *)0x0)); currentRegistry = currentRegistry->next) {\n    counter = counter + 1;\n  }\n  return currentRegistry;\n}\n\n",
            "renaming": {
                "FUN_00003d24": "get_saul_registry_by_position_00003d24",
                "pos": "position",
                "pos_local": "localPosition",
                "i": "counter",
                "tmp": "currentRegistry",
                "saul_reg": "saulRegistry"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d64": {
            "entrypoint": "0x00003d64",
            "current_name": "read_sensor_data_00003d64",
            "code": "\nint read_sensor_data_00003d64(saul_reg_t *sensor,phydat_t *sensor_data)\n\n{\n  int result;\n  phydat_t *local_sensor_data;\n  saul_reg_t *local_sensor;\n  \n  if (sensor == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->sensor,sensor_data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "sensor_data",
                "iVar1": "result",
                "res_local": "local_sensor_data",
                "dev_local": "local_sensor"
            },
            "calling": [
                "probe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d94": {
            "entrypoint": "0x00003d94",
            "current_name": "write_data_to_dev_00003d94",
            "code": "\nint writeDataToDev_00003d94(saul_reg_t *device,phydat_t *data)\n\n{\n  int result;\n  phydat_t *localData;\n  saul_reg_t *localDevice;\n  \n  if (device == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*device->driver->write)(device->device,data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d94": "write_data_to_dev_00003d94",
                "dev": "device",
                "data_local": "localData",
                "dev_local": "localDevice",
                "iVar1": "result"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003dc4": {
            "entrypoint": "0x00003dc4",
            "current_name": "calculate_length_and_convert_to_string_00003dc4",
            "code": "\nsize_t calculateLengthAndConvertToString_00003dc4(char *outputString,uint32_t inputValue)\n\n{\n  uint32_t inputValue_local;\n  char *outputString_local;\n  char *stringPointer;\n  uint32_t temporaryValue;\n  size_t length;\n  \n  length = 1;\n  if (inputValue < 1000000000) {\n    for (temporaryValue = 10; temporaryValue <= inputValue; temporaryValue = temporaryValue * 10) {\n      length = length + 1;\n    }\n  }\n  else {\n    length = 10;\n  }\n  if (outputString != (char *)0x0) {\n    stringPointer = outputString + length;\n    inputValue_local = inputValue;\n    do {\n      stringPointer = stringPointer + -1;\n      *stringPointer = (char)(inputValue_local % 10) + '0';\n      inputValue_local = inputValue_local / 10;\n    } while (inputValue_local != 0);\n  }\n  return length;\n}\n\n",
            "renaming": {
                "FUN_00003dc4": "calculate_length_and_convert_to_string_00003dc4",
                "out": "outputString",
                "val": "inputValue",
                "val_local": "inputValue_local",
                "out_local": "outputString_local",
                "ptr": "stringPointer",
                "tmp": "temporaryValue",
                "len": "length"
            },
            "calling": [
                "fmt_s32_dec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e58": {
            "entrypoint": "0x00003e58",
            "current_name": "convert_integer_to_string_00003e58",
            "code": "\nsize_t convertIntegerToString_00003e58(char *outputString,int32_t inputValue)\n\n{\n  size_t sVar1;\n  int32_t inputValueCopy;\n  char *outputStringCopy;\n  uint isNegative;\n  \n  inputValueCopy = inputValue;\n  outputStringCopy = outputString;\n  if (-(inputValue >> 0x1f) != 0) {\n    if (outputString != (char *)0x0) {\n      outputStringCopy = outputString + 1;\n      *outputString = '-';\n    }\n    inputValueCopy = -inputValue;\n  }\n  sVar1 = fmt_u32_dec(outputStringCopy,inputValueCopy);\n  return -(inputValue >> 0x1f) + sVar1;\n}\n\n",
            "renaming": {
                "FUN_00003e58": "convert_integer_to_string_00003e58",
                "out": "outputString",
                "val": "inputValue",
                "val_local": "inputValueCopy",
                "out_local": "outputStringCopy",
                "negative": "isNegative"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "fmt_u32_dec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e9e": {
            "entrypoint": "0x00003e9e",
            "current_name": "format_int_to_decimal_00003e9e",
            "code": "\nsize_t formatIntToDecimal_00003e9e(char *outputString,int16_t inputValue,int decimalPlaces)\n\n{\n  size_t formattedSize;\n  int decimalPlaces_local;\n  int16_t inputValue_local;\n  char *outputString_local;\n  \n  formattedSize = fmt_s32_dfp(outputString,(int)inputValue,decimalPlaces);\n  return formattedSize;\n}\n\n",
            "renaming": {
                "FUN_00003e9e": "format_int_to_decimal_00003e9e",
                "out": "outputString",
                "val": "inputValue",
                "fp_digits": "decimalPlaces",
                "fp_digits_local": "decimalPlaces_local",
                "val_local": "inputValue_local",
                "out_local": "outputString_local",
                "sVar1": "formattedSize"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [
                "fmt_s32_dfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ec4": {
            "entrypoint": "0x00003ec4",
            "current_name": "format_float_00003ec4",
            "code": "\nsize_t formatFloat_00003ec4(char *outputString,int32_t value,int fractionalDigits)\n\n{\n  size_t formatLen;\n  uint dividend;\n  int formattedLen;\n  int fractionalDigitsLocal;\n  int32_t valueLocal;\n  char *outputStringLocal;\n  uint divisionLength;\n  int32_t absoluteValue;\n  uint32_t e;\n  int32_t divisionResult;\n  uint position;\n  \n  if (fractionalDigits + 7 < 0 != SCARRY4(fractionalDigits,7)) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  position = 0;\n  if (fractionalDigits == 0) {\n    position = fmt_s32_dec(outputString,value);\n  }\n  else if (fractionalDigits < 1) {\n    dividend = (uint)value / _tenmap[-fractionalDigits];\n    divisionResult = value - _tenmap[-fractionalDigits] * dividend;\n    if (divisionResult < 0) {\n      divisionResult = -divisionResult;\n    }\n    if ((dividend == 0) && (value < 0)) {\n      if (outputString != (char *)0x0) {\n        *outputString = '-';\n      }\n      position = 1;\n    }\n    if (outputString == (char *)0x0) {\n      formatLen = fmt_s32_dec((char *)0x0,dividend);\n      position = formatLen + 1 + position;\n    }\n    else {\n      formatLen = fmt_s32_dec(outputString + position,dividend);\n      formattedLen = position + formatLen;\n      position = formattedLen + 1;\n      outputString[formattedLen] = '.';\n      formatLen = fmt_s32_dec(outputString + position,divisionResult);\n      fmt_lpad(outputString + position,formatLen,-fractionalDigits,'0');\n    }\n    position = -fractionalDigits + position;\n  }\n  else {\n    formatLen = fmt_s32_dec(outputString,value);\n    if (outputString != (char *)0x0) {\n      memset(outputString + formatLen,0x30,fractionalDigits);\n    }\n    position = fractionalDigits + formatLen;\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00003ec4": "format_float_00003ec4",
                "out": "outputString",
                "val": "value",
                "fp_digits": "fractionalDigits",
                "sVar1": "formatLen",
                "val_00": "dividend",
                "iVar2": "formattedLen",
                "fp_digits_local": "fractionalDigitsLocal",
                "val_local": "valueLocal",
                "out_local": "outputStringLocal",
                "div_len": "divisionLength",
                "abs": "absoluteValue",
                "div": "divisionResult",
                "pos": "position"
            },
            "calling": [
                "fmt_s16_dfp"
            ],
            "called": [
                "core_panic",
                "fmt_s32_dec",
                "fmt_lpad",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ff4": {
            "entrypoint": "0x00003ff4",
            "current_name": "pad_string_00003ff4",
            "code": "\nsize_t padString_00003ff4(char *output,size_t input_length,size_t padding_length,char padding_character)\n\n{\n  size_t result;\n  char local_padding_character;\n  size_t local_padding_length;\n  size_t local_input_length;\n  char *local_output;\n  size_t counter;\n  \n  result = input_length;\n  if ((input_length < padding_length) && (result = padding_length, output != (char *)0x0)) {\n    memmove(output + (padding_length - input_length),output,input_length);\n    memset(output,(uicountert)(byte)padding_character,padding_length - input_length);\n  }\n  returcounter result;\n}\n\n",
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padding_length",
                "pad_char": "padding_character",
                "sVar1": "result",
                "pad_char_local": "local_padding_character",
                "pad_len_local": "local_padding_length",
                "in_len_local": "local_input_length",
                "out_local": "local_output",
                "n": "counter"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "memmove",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004042": {
            "entrypoint": "0x00004042",
            "current_name": "parse_string_to_long_00004042",
            "code": "\nint parse_string_to_long_00004042(char *input_string)\n\n{\n  long long_value;\n  \n  long_value = strtol(input_string,(char **)0x0,10);\n  return long_value;\n}\n\n",
            "renaming": {
                "FUN_00004042": "parse_string_to_long_00004042",
                "__nptr": "input_string",
                "lVar1": "long_value"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000404c": {
            "entrypoint": "0x0000404c",
            "current_name": "extract_and_process_0000404c",
            "code": "\nundefined4 extract_and_process_0000404c(uint *data_ptr,int *info_ptr)\n\n{\n  int temp_var1;\n  int *temp_var2;\n  uint info_value;\n  ushort info_flags;\n  int temp_var3;\n  code *process_func;\n  int temp_var4;\n  uint data_value;\n  bool is_zero;\n  \n  info_flags = *(ushort *)(info_ptr + 3);\n  info_value = (uint)info_flags;\n  if ((int)(info_value << 0x1c) < 0) {\n    temp_var1 = info_ptr[4];\n    if (temp_var1 != 0) {\n      temp_var3 = info_value << 0x1e;\n      is_zero = temp_var3 == 0;\n      temp_var4 = *info_ptr;\n      if (is_zero) {\n        temp_var3 = info_ptr[5];\n      }\n      *info_ptr = temp_var1;\n      if (!is_zero) {\n        temp_var3 = 0;\n      }\n      info_ptr[2] = temp_var3;\n      for (temp_var4 = temp_var4 - temp_var1; 0 < temp_var4; temp_var4 = temp_var4 - temp_var3) {\n        temp_var3 = (*(code *)info_ptr[10])(data_ptr,info_ptr[8],temp_var1,temp_var4);\n        if (temp_var3 < 1) {\n          *(ushort *)(info_ptr + 3) = *(ushort *)(info_ptr + 3) | 0x40;\n          return 0xffffffff;\n        }\n        temp_var1 = temp_var1 + temp_var3;\n      }\n    }\n  }\n  else {\n    if ((info_ptr[1] < 1) && (info_ptr[0x10] < 1)) {\n      return 0;\n    }\n    process_func = (code *)info_ptr[0xb];\n    if (process_func == (code *)0x0) {\n      return 0;\n    }\n    data_value = *data_ptr;\n    *data_ptr = 0;\n    if ((info_flags & 0x1000) == 0) {\n      temp_var1 = (*process_func)(data_ptr,info_ptr[8],info_value & 0x1000,1);\n      if ((temp_var1 == -1) && (info_value = *data_ptr, info_value != 0)) {\n        if ((info_value == 0x1d) || (info_value == 0x16)) {\n          *data_ptr = data_value;\n          return 0;\n        }\n        info_flags = *(ushort *)(info_ptr + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      temp_var1 = info_ptr[0x15];\n    }\n    if (((int)((uint)*(ushort *)(info_ptr + 3) << 0x1d) < 0) &&\n       (temp_var1 = temp_var1 - info_ptr[1], info_ptr[0xd] != 0)) {\n      temp_var1 = temp_var1 - info_ptr[0x10];\n    }\n    temp_var1 = (*(code *)info_ptr[0xb])(data_ptr,info_ptr[8],temp_var1,0);\n    info_flags = *(ushort *)(info_ptr + 3);\n    if ((temp_var1 == -1) &&\n       ((0x1d < *data_ptr || (-1 < (int)((0x20400001U >> (*data_ptr & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(info_ptr + 3) = info_flags | 0x40;\n      return 0xffffffff;\n    }\n    info_ptr[1] = 0;\n    *info_ptr = info_ptr[4];\n    if (((int)((uint)info_flags << 0x13) < 0) && ((temp_var1 != -1 || (*data_ptr == 0)))) {\n      info_ptr[0x15] = temp_var1;\n    }\n    temp_var2 = (int *)info_ptr[0xd];\n    *data_ptr = data_value;\n    if (temp_var2 != (int *)0x0) {\n      if (temp_var2 != info_ptr + 0x11) {\n        _free_r(data_ptr);\n      }\n      info_ptr[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000404c": "extract_and_process_0000404c",
                "param_1": "data_ptr",
                "param_2": "info_ptr",
                "iVar1": "temp_var1",
                "piVar2": "temp_var2",
                "uVar3": "info_value",
                "uVar4": "info_flags",
                "iVar5": "temp_var3",
                "pcVar6": "process_func",
                "iVar7": "temp_var4",
                "uVar8": "data_value",
                "bVar9": "is_zero"
            },
            "calling": [
                "_fflush_r",
                "__srefill_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004158": {
            "entrypoint": "0x00004158",
            "current_name": "flush_output_00004158",
            "code": "\nundefined4 flushOutput_00004158(int stream,undefined4 *fileStream)\n\n{\n  undefined4 returnValue;\n  \n  if (fileStream[4] != 0) {\n    if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (fileStream == &__sf_fake_stdin) {\n      fileStream = *(undefined4 **)(stream + 4);\n    }\n    else if (fileStream == (undefined4 *)&__sf_fake_stdout) {\n      fileStream = *(undefined4 **)(stream + 8);\n    }\n    else if (fileStream == (undefined4 *)&__sf_fake_stderr) {\n      fileStream = *(undefined4 **)(stream + 0xc);\n    }\n    if (*(short *)(fileStream + 3) != 0) {\n      if ((-1 < (int)(fileStream[0x19] << 0x1f)) && (-1 < (int)*(short *)(fileStream + 3) << 0x16)) {\n        __retarget_lock_acquire_recursive(fileStream[0x16]);\n      }\n      returnValue = __sflush_r(stream,fileStream);\n      if ((int)(fileStream[0x19] << 0x1f) < 0) {\n        return returnValue;\n      }\n      if ((int)((uint)*(ushort *)(fileStream + 3) << 0x16) < 0) {\n        return returnValue;\n      }\n      __retarget_lock_release_recursive(fileStream[0x16]);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004158": "flush_output_00004158",
                "param_1": "stream",
                "param_2": "fileStream",
                "uVar1": "returnValue"
            },
            "calling": [
                "__swbuf_r",
                "fflush",
                "__srefill_r"
            ],
            "called": [
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041d0": {
            "entrypoint": "0x000041d0",
            "current_name": "flush_file_000041d0",
            "code": "\nint flushFile_000041d0(FILE *file)\n\n{\n  int status;\n  \n  if (file == (FILE *)0x0) {\n    status = _fwalk_reent(&impure_data,0x4159);\n    return status;\n  }\n  status = _fflush_r(_impure_ptr,file);\n  return status;\n}\n\n",
            "renaming": {
                "FUN_000041d0": "flush_file_000041d0",
                "__stream": "file",
                "iVar1": "status"
            },
            "calling": [
                "lflush",
                "print_prompt"
            ],
            "called": [
                "_fwalk_reent",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041f4": {
            "entrypoint": "0x000041f4",
            "current_name": "initialize_data_000041f4",
            "code": "\nvoid initializeData_000041f4(undefined4 *data,undefined2 value1,undefined2 value2)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[4] = 0;\n  data[5] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[25] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[9] = 0x4dc9;\n  data[10] = 0x4def;\n  data[11] = 0x4e27;\n  data[8] = data;\n  data[12] = 0x4e4b;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "data[1]",
                "param_1[4]": "data[4]",
                "param_1[5]": "data[5]",
                "param_1[2]": "data[2]",
                "param_1[0x19]": "data[25]",
                "param_1[6]": "data[6]",
                "param_1[9]": "data[9]",
                "param_1[10]": "data[10]",
                "param_1[0xb]": "data[11]",
                "param_1[8]": "data[8]",
                "param_1[0xc]": "data[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000423c": {
            "entrypoint": "0x0000423c",
            "current_name": "execute_reent_fwalk_0000423c",
            "code": "\nvoid execute_reent_fwalk_0000423c(undefined4 reent_pointer)\n\n{\n  execute_fwalk_reent(reent_pointer,0x4159);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000423c": "execute_reent_fwalk_0000423c",
                "param_1": "reent_pointer",
                "_fwalk_reent": "execute_fwalk_reent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004248": {
            "entrypoint": "0x00004248",
            "current_name": "allocate_and_initialize_array_00004248",
            "code": "\nundefined4 * allocate_and_initialize_array_00004248(undefined4 size_of_element,int num_of_elements)\n\n{\n  undefined4 *array_ptr;\n  int total_size;\n  \n  total_size = (num_of_elements + -1) * 0x68;\n  array_ptr = (undefined4 *)_malloc_r(size_of_element,total_size + 0x74);\n  if (array_ptr != (undefined4 *)0x0) {\n    *array_ptr = 0;\n    array_ptr[1] = num_of_elements;\n    array_ptr[2] = array_ptr + 3;\n    memset(array_ptr + 3,0,total_size + 0x68);\n  }\n  return array_ptr;\n}\n\n",
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_array_00004248",
                "param_1": "size_of_element",
                "param_2": "num_of_elements",
                "puVar1": "array_ptr",
                "iVar2": "total_size"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004274": {
            "entrypoint": "0x00004274",
            "current_name": "acquire_sfp_recursive_lock_00004274",
            "code": "\nvoid acquireSfpRecursiveLock_00004274(void)\n\n{\n  acquireRecursiveLock(&sfpRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004274": "acquire_sfp_recursive_lock_00004274",
                "__retarget_lock_acquire_recursive": "acquireRecursiveLock",
                "__lock___sfp_recursive_mutex": "sfpRecursiveMutex"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004280": {
            "entrypoint": "0x00004280",
            "current_name": "release_recursive_lock_00004280",
            "code": "\nvoid releaseRecursiveLock_00004280(void)\n\n{\n  __retarget_lock_release_recursive(&__lock___sfp_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004280": "release_recursive_lock_00004280"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000428c": {
            "entrypoint": "0x0000428c",
            "current_name": "acquire_recursive_lock_0000428c",
            "code": "\nvoid acquireRecursiveLock_0000428c(void)\n\n{\n  __retarget_lock_acquire_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "__lock___sinit_recursive_mutex": "lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004298": {
            "entrypoint": "0x00004298",
            "current_name": "release_recursive_lock_00004298",
            "code": "\nvoid releaseRecursiveLock_00004298(void)\n\n{\n  __retarget_lock_release_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004298": "release_recursive_lock_00004298",
                "__lock___sinit_recursive_mutex": "lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000042a4": {
            "entrypoint": "0x000042a4",
            "current_name": "initialize_data_000042a4",
            "code": "\nvoid initializeData_000042a4(undefined1 *dataPtr)\n\n{\n  undefined4 result;\n  undefined1 *dataPtrCopy;\n  \n  acquireLock();\n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    dataPtrCopy = &globalData;\n    *(undefined4 *)(dataPtr + 0x28) = 0x423d;\n    if (dataPtr == &globalData) {\n      dataPtrCopy = (undefined1 *)0x1;\n    }\n    if (dataPtr == &globalData) {\n      *(undefined1 **)(dataPtr + 0x18) = dataPtrCopy;\n    }\n    result = getFp(dataPtr);\n    *(undefined4 *)(dataPtr + 4) = result;\n    result = getFp(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = result;\n    result = getFp(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = result;\n    setStd(*(undefined4 *)(dataPtr + 4),4,0);\n    setStd(*(undefined4 *)(dataPtr + 8),9,1);\n    setStd(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  releaseLock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "dataPtr",
                "uVar1": "result",
                "puVar2": "dataPtrCopy",
                "impure_data": "globalData",
                "__sinit_lock_acquire": "acquireLock",
                "__sfp": "getFp",
                "std": "setStd",
                "__sinit_lock_release": "releaseLock"
            },
            "calling": [
                "__sfp",
                "_fflush_r",
                "_puts_r",
                "iprintf",
                "_putc_r",
                "_getc_r",
                "__srefill_r",
                "putchar",
                "__swbuf_r",
                "getchar",
                "__srget_r",
                "_vfprintf_r",
                "__swsetup_r"
            ],
            "called": [
                "__sfp",
                "std",
                "__sinit_lock_acquire",
                "__sinit_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004314": {
            "entrypoint": "0x00004314",
            "current_name": "initialize_data_structures_00004314",
            "code": "\nint * initializeDataStructures_00004314(undefined4 *param_array)\n\n{\n  int *current_pointer_1;\n  int *current_pointer_2;\n  int **pointer_array;\n  \n  acquireLock();\n  if (DAT_1fff029c == 0) {\n    initializeImpureData(&data_structure);\n  }\n  pointer_array = (int **)&DAT_1fff02cc;\n  do {\n    current_pointer_1 = pointer_array[1];\n    current_pointer_2 = pointer_array[2];\n    while (current_pointer_1 = (int *)((int)current_pointer_1 + -1), -1 < (int)current_pointer_1) {\n      if (*(short_value *)(current_pointer_2 + 3) == 0) {\n        current_pointer_2[3] = -0xffff;\n        current_pointer_2[0x19] = 0;\n        initializeRecursiveLock(current_pointer_2 + 0x16);\n        releaseLock();\n        current_pointer_2[1] = 0;\n        current_pointer_2[2] = 0;\n        current_pointer_2[4] = 0;\n        current_pointer_2[5] = 0;\n        *current_pointer_2 = 0;\n        current_pointer_2[6] = 0;\n        setMemory(current_pointer_2 + 0x17,0,8);\n        current_pointer_2[0xd] = 0;\n        current_pointer_2[0xe] = 0;\n        current_pointer_2[0x12] = 0;\n        current_pointer_2[0x13] = 0;\n        return current_pointer_2;\n      }\n      current_pointer_2 = current_pointer_2 + 0x1a;\n    }\n    if (*pointer_array == (int *)0x0) {\n      current_pointer_1 = (int *)allocateMemory(param_array,4);\n      *pointer_array = current_pointer_1;\n      if (current_pointer_1 == (int *)0x0) {\n        releaseLock();\n        *param_array = 0xc;\n        return (int *)0x0;\n      }\n    }\n    pointer_array = (int **)*pointer_array;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00004314": "initialize_data_structures_00004314",
                "param_1": "param_array",
                "piVar1": "current_pointer_1",
                "piVar2": "current_pointer_2",
                "ppiVar3": "pointer_array",
                "__sfp_lock_acquire": "acquireLock",
                "__sinit": "initializeImpureData",
                "impure_data": "data_structure",
                "short": "short_value",
                "__retarget_lock_init_recursive": "initializeRecursiveLock",
                "__sfp_lock_release": "releaseLock",
                "memset": "setMemory",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043a0": {
            "entrypoint": "0x000043a0",
            "current_name": "process_data_000043a0",
            "code": "\nuint processData_000043a0(int inputOffset,code *dataCallback)\n\n{\n  uint callbackResult;\n  int *ptrArray;\n  int currentValue;\n  uint combinedResult;\n  int iterationCount;\n  \n  ptrArray = (int *)(inputOffset + 0x48);\n  combinedResult = 0;\n  do {\n    iterationCount = ptrArray[1];\n    currentValue = ptrArray[2];\n    while (iterationCount = iterationCount + -1, -1 < iterationCount) {\n      if ((1 < *(ushort *)(currentValue + 0xc)) && (*(short *)(currentValue + 0xe) != -1)) {\n        callbackResult = (*dataCallback)(currentValue);\n        combinedResult = combinedResult | callbackResult;\n      }\n      currentValue = currentValue + 0x68;\n    }\n    ptrArray = (int *)*ptrArray;\n  } while (ptrArray != (int *)0x0);\n  return combinedResult;\n}\n\n",
            "renaming": {
                "FUN_000043a0": "process_data_000043a0",
                "param_1": "inputOffset",
                "param_2": "dataCallback",
                "piVar2": "ptrArray",
                "iVar3": "currentValue",
                "uVar1": "callbackResult",
                "uVar4": "combinedResult",
                "iVar5": "iterationCount"
            },
            "calling": [
                "__srefill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043da": {
            "entrypoint": "0x000043da",
            "current_name": "process_data_000043da",
            "code": "\nuint processData_000043da(int input,code *callback,undefined4 arg1,undefined4 arg2)\n\n{\n  uint result;\n  int index;\n  int *ptr1;\n  int ptr2;\n  uint flags;\n  int count;\n  \n  ptr1 = (int *)(input + 0x48);\n  flags = 0;\n  do {\n    count = ptr1[1];\n    ptr2 = ptr1[2];\n    while (count = count + -1, -1 < count) {\n      if ((1 < *(ushort *)(ptr2 + 0xc)) && (index = *(short *)(ptr2 + 0xe) + 1, index != 0)) {\n        result = (*callback)(input,ptr2,arg1,index,arg2);\n        flags = flags | result;\n      }\n      ptr2 = ptr2 + 0x68;\n    }\n    ptr1 = (int *)*ptr1;\n  } while (ptr1 != (int *)0x0);\n  return flags;\n}\n\n",
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "input",
                "param_2": "callback",
                "param_3": "arg1",
                "param_4": "arg2",
                "uVar1": "result",
                "iVar2": "index",
                "piVar3": "ptr1",
                "iVar4": "ptr2",
                "uVar5": "flags",
                "iVar6": "count"
            },
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004418": {
            "entrypoint": "0x00004418",
            "current_name": "read_input_character_00004418",
            "code": "\n\n\nint readInputCharacter_00004418(void)\n\n{\n  int impurePtr;\n  \n  impurePtr = impurePtr;\n  if ((impurePtr != 0) && (*(int *)(impurePtr + 0x18) == 0)) {\n    initializeLocalStreams(impurePtr);\n  }\n  impurePtr = getCharWithStream(impurePtr,*(undefined4 *)(impurePtr + 4));\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_00004418": "read_input_character_00004418",
                "iVar1": "impurePtr",
                "_impure_ptr": "impurePtr",
                "__sinit": "initializeLocalStreams",
                "_getc_r": "getCharWithStream"
            },
            "calling": [
                "readline"
            ],
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000443c": {
            "entrypoint": "0x0000443c",
            "current_name": "decode_time_0000443c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * decodeTime_0000443c(time_t *timer,tm *timeStruct)\n\n{\n  int divResult;\n  uint yearHalf;\n  uint days;\n  uint leapYearDays;\n  int dayOfYear;\n  uint leapYears;\n  time_t timerValue1;\n  time_t timerValue2;\n  uint month;\n  bool isNeg;\n  \n  timerValue1 = *timer;\n  timerValue2 = timer[1];\n  divResult = __aeabi_ldivmod(timerValue1,timerValue2,0x15180,0);\n  days = 0x15180;\n  __aeabi_ldivmod(timerValue1,timerValue2,0x15180,0);\n  isNeg = (int)days < 0;\n  if (isNeg) {\n    days = days + 0x15180;\n  }\n  if (isNeg) {\n    yearHalf = divResult + 0xafa6b;\n  }\n  else {\n    yearHalf = divResult + 0xafa6c;\n  }\n  timeStruct->tm_hour = days / 0xe10;\n  timeStruct->tm_min = (days % 0xe10) / 0x3c;\n  timeStruct->tm_sec = (days % 0xe10) % 0x3c;\n  timeStruct->tm_wday = (yearHalf + 3) % 7;\n  days = yearHalf;\n  if ((int)yearHalf < 0) {\n    days = yearHalf - 0x23ab0;\n  }\n  yearHalf = (days / 0x23ab1) * -0x23ab1 + yearHalf;\n  leapYearDays = ((yearHalf / 0x8eac + yearHalf) - yearHalf / 0x5b4) - yearHalf / 0x23ab0;\n  leapYears = leapYearDays / 0x16d;\n  yearHalf = (leapYears / 100 - leapYearDays / 0x5b4) + yearHalf + leapYears * -0x16d;\n  month = yearHalf * 5 + 2;\n  leapYearDays = month / 0x99;\n  if (month < 0x5fa) {\n    divResult = 2;\n  }\n  else {\n    divResult = -10;\n  }\n  month = leapYearDays + divResult;\n  divResult = (days / 0x23ab1) * 400 + leapYears;\n  if (month < 2) {\n    divResult = divResult + 1;\n  }\n  if (yearHalf < 0x132) {\n    if (((leapYears & 3) == 0) && (leapYears != (leapYears / 100) * 100)) {\n      days = 1;\n    }\n    else {\n      days = (uint)(leapYears % 400 == 0);\n    }\n    dayOfYear = yearHalf + 0x3b + days;\n  }\n  else {\n    dayOfYear = yearHalf - 0x132;\n  }\n  timeStruct->tm_yday = dayOfYear;\n  timeStruct->tm_mday = (yearHalf + 1) - (leapYearDays * 0x99 + 2) / 5;\n  timeStruct->tm_mon = month;\n  timeStruct->tm_year = divResult + -0x76c;\n  timeStruct->tm_isdst = 0;\n  return timeStruct;\n}\n\n",
            "renaming": {
                "FUN_0000443c": "decode_time_0000443c",
                "__timer": "timer",
                "__tp": "timeStruct",
                "iVar1": "divResult",
                "uVar2": "yearHalf",
                "uVar3": "days",
                "uVar4": "leapYearDays",
                "iVar5": "dayOfYear",
                "uVar6": "leapYears",
                "tVar7": "timerValue1",
                "tVar8": "timerValue2",
                "uVar9": "month",
                "bVar10": "isNeg"
            },
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "called": [
                "__aeabi_ldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000459c": {
            "entrypoint": "0x0000459c",
            "current_name": "execute_fini_array_functions_0000459c",
            "code": "\nvoid executeFiniArrayFunctions_0000459c(EVP_PKEY_CTX *ctx)\n\n{\n  code **finiArrayEndPointers;\n  int index;\n  \n  finiArrayEndPointers = (code **)&__fini_array_end;\n  for (index = 0; index != 0; index = index + 1) {\n    ctx = (EVP_PKEY_CTX *)(**finiArrayEndPointers)();\n    finiArrayEndPointers = finiArrayEndPointers + 1;\n  }\n  _init(ctx);\n  finiArrayEndPointers = (code **)&__fini_array_end;\n  for (index = 0; index != 0; index = index + 1) {\n    (**finiArrayEndPointers)();\n    finiArrayEndPointers = finiArrayEndPointers + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000459c": "execute_fini_array_functions_0000459c",
                "param_1": "ctx",
                "ppcVar1": "finiArrayEndPointers",
                "iVar2": "index"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000045e4": {
            "entrypoint": "0x000045e4",
            "current_name": "FUNC_000045e4",
            "code": "\nvoid FUNC_000045e4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e4": "FUNC_000045e4"
            },
            "calling": [
                "__sfp"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e6": {
            "entrypoint": "0x000045e6",
            "current_name": "FUNC_000045e6",
            "code": "\nvoid FUNC_000045e6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e6": "FUNC_000045e6"
            },
            "calling": [
                "__tz_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e8": {
            "entrypoint": "0x000045e8",
            "current_name": "FUNC_000045e8",
            "code": "\nvoid FUNC_000045e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e8": "FUNC_000045e8"
            },
            "calling": [
                "__env_lock",
                "_fflush_r",
                "__sfp_lock_acquire",
                "__malloc_lock",
                "_puts_r",
                "_vfprintf_r",
                "__sinit_lock_acquire",
                "_putc_r",
                "_getc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ea": {
            "entrypoint": "0x000045ea",
            "current_name": "FUNC_000045ea",
            "code": "\nvoid FUNC_000045ea(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ea": "FUNC_000045ea"
            },
            "calling": [
                "__tz_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ec": {
            "entrypoint": "0x000045ec",
            "current_name": "FUNC_000045ec",
            "code": "\nvoid FUNC_000045ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ec": "FUNC_000045ec"
            },
            "calling": [
                "_fflush_r",
                "_puts_r",
                "__sfp_lock_release",
                "__malloc_unlock",
                "_vfprintf_r",
                "_putc_r",
                "__env_unlock",
                "_getc_r",
                "__sinit_lock_release"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ee": {
            "entrypoint": "0x000045ee",
            "current_name": "copy_reverse_000045ee",
            "code": "\nvoid * copy_reverse_000045ee(void *dest,void *src,size_t length)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)src + length);\n  if ((src < dest) && (dest < src_ptr)) {\n    dest_ptr = (undefined *)(length + (int)dest);\n    while (dest_ptr != (undefined *)dest) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n  }\n  else {\n    dest_ptr = (undefined *)((int)dest + -1);\n    for (; (undefined *)src != src_ptr; src = (void *)((int)src + 1)) {\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *src;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_000045ee": "copy_reverse_000045ee",
                "__dest": "dest",
                "__src": "src",
                "__n": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "fmt_lpad"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004622": {
            "entrypoint": "0x00004622",
            "current_name": "fill_memory_with_character_00004622",
            "code": "\nvoid * fillMemoryWithCharacter_00004622(void *ptr_start,int character,size_t size)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)ptr_start; puVar1 != (undefined *)(size + (int)ptr_start); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)character;\n  }\n  return ptr_start;\n}\n\n",
            "renaming": {
                "FUN_00004622": "fill_memory_with_character_00004622",
                "__s": "ptr_start",
                "__c": "character",
                "__n": "size"
            },
            "calling": [
                "__sfmoreglue",
                "__sfp",
                "std",
                "fmt_lpad",
                "write",
                "fmt_s32_dfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004634": {
            "entrypoint": "0x00004634",
            "current_name": "update_date_00004634",
            "code": "\nvoid updateDate_00004634(uint *date,uint days,undefined4 dayOfWeek)\n\n{\n  int monthDays;\n  uint year;\n  uint leapYearDays;\n  int month;\n  bool isNegative;\n  uint *quotient;\n  uint remainder;\n  undefined4 temp;\n  \n  quotient = date;\n  remainder = days;\n  temp = dayOfWeek;\n  if (0x3b < *date) {\n    div((int)&quotient,*date);\n    year = date[1] + (int)quotient;\n    date[1] = year;\n    if ((int)remainder < 0) {\n      year = year - 1;\n      *date = remainder + 0x3c;\n    }\n    else {\n      *date = remainder;\n    }\n    if ((int)remainder < 0) {\n      date[1] = year;\n    }\n  }\n  if (0x3b < date[1]) {\n    div((int)&quotient,date[1]);\n    isNegative = (int)remainder < 0;\n    leapYearDays = date[2] + (int)quotient;\n    date[2] = leapYearDays;\n    year = remainder;\n    if (isNegative) {\n      year = remainder + 0x3c;\n      leapYearDays = leapYearDays - 1;\n    }\n    if (!isNegative) {\n      date[1] = year;\n    }\n    if (isNegative) {\n      date[1] = year;\n    }\n    if (isNegative) {\n      date[2] = leapYearDays;\n    }\n  }\n  if (0x17 < date[2]) {\n    div((int)&quotient,date[2]);\n    isNegative = (int)remainder < 0;\n    leapYearDays = date[3] + (int)quotient;\n    date[3] = leapYearDays;\n    year = remainder;\n    if (isNegative) {\n      year = remainder + 0x18;\n      leapYearDays = leapYearDays - 1;\n    }\n    if (!isNegative) {\n      date[2] = year;\n    }\n    if (isNegative) {\n      date[2] = year;\n    }\n    if (isNegative) {\n      date[3] = leapYearDays;\n    }\n  }\n  if (0xb < date[4]) {\n    div((int)&quotient,date[4]);\n    isNegative = (int)remainder < 0;\n    year = date[5] + (int)quotient;\n    date[5] = year;\n    if (isNegative) {\n      remainder = remainder + 0xc;\n      year = year - 1;\n    }\n    if (!isNegative) {\n      date[4] = remainder;\n    }\n    if (isNegative) {\n      date[4] = remainder;\n    }\n    if (isNegative) {\n      date[5] = year;\n    }\n  }\n  year = date[5];\n  if ((year & 3) == 0) {\n    if (year == (year / 100) * 100) {\n      if ((year + 0x76c) % 400 == 0) {\n        month = 0x1d;\n      }\n      else {\n        month = 0x1c;\n      }\n    }\n    else {\n      month = 0x1d;\n    }\n  }\n  else {\n    month = 0x1c;\n  }\n  if ((int)date[3] < 1) {\n    while ((int)date[3] < 1) {\n      year = date[4];\n      date[4] = year - 1;\n      if (year - 1 == 0xffffffff) {\n        leapYearDays = date[5];\n        year = leapYearDays - 1;\n        date[4] = 0xb;\n        date[5] = year;\n        if ((year & 3) == 0) {\n          if (year == (year / 100) * 100) {\n            if ((leapYearDays + 0x76b) % 400 == 0) {\n              month = 0x1d;\n            }\n            else {\n              month = 0x1c;\n            }\n          }\n          else {\n            month = 0x1d;\n          }\n        }\n        else {\n          month = 0x1c;\n        }\n      }\n      monthDays = month;\n      if (date[4] != 1) {\n        monthDays = *(int *)(&DAYS_IN_MONTH + date[4] * 4);\n      }\n      date[3] = monthDays + date[3];\n    }\n  }\n  else {\n    while( true ) {\n      year = date[4];\n      monthDays = month;\n      if (year != 1) {\n        monthDays = *(int *)(&DAYS_IN_MONTH + year * 4);\n      }\n      if ((int)date[3] <= monthDays) break;\n      date[3] = date[3] - monthDays;\n      date[4] = year + 1;\n      if (year + 1 == 0xc) {\n        leapYearDays = date[5];\n        year = leapYearDays + 1;\n        date[4] = 0;\n        date[5] = year;\n        if ((year & 3) == 0) {\n          if (year % 100 == 0) {\n            if ((leapYearDays + 0x76d) % 400 == 0) {\n              month = 0x1d;\n            }\n            else {\n              month = 0x1c;\n            }\n          }\n          else {\n            month = 0x1d;\n          }\n        }\n        else {\n          month = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "date",
                "param_2": "days",
                "param_3": "dayOfWeek",
                "iVar1": "monthDays",
                "uVar2": "year",
                "uVar3": "leapYearDays",
                "iVar4": "month",
                "bVar5": "isNegative",
                "local_20": "quotient",
                "local_1c": "remainder",
                "uStack_18": "temp"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "div"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000047e4": {
            "entrypoint": "0x000047e4",
            "current_name": "calculate_adjusted_time_000047e4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t calculateAdjustedTime_000047e4(tm *timeStructure)\n\n{\n  longlong totalSeconds;\n  int *timezoneInfo;\n  uint tempVar1;\n  int tempVar2;\n  int tempVar3;\n  int daysToAdjust;\n  uint limit1;\n  uint limit2;\n  uint limit3;\n  int totalDays;\n  uint year;\n  uint isDst;\n  uint isDstAdjusted;\n  uint adjustedSeconds;\n  time_t adjustedTime;\n  bool isLeapYear;\n  \n  timezoneInfo = (int *)__gettzinfo();\n  validate_structure(timeStructure);\n  year = timeStructure->tm_year;\n  totalDays = timeStructure->tm_mday + -1 + *(int *)(&_DAYS_BEFORE_MONTH + timeStructure->tm_mon * 4);\n  if (((1 < timeStructure->tm_mon) && ((year & 3) == 0)) &&\n     ((year != (year / 100) * 100 || (year + 0x76c == ((year + 0x76c) / 400) * 400)))) {\n    totalDays = totalDays + 1;\n  }\n  timeStructure->tm_yday = totalDays;\n  if (20000 < (int)&DAT_00002710 + year) {\n    return -1;\n  }\n  if ((int)year < 0x47) {\n    if (year != 0x46) {\n      for (limit2 = 0x45; (int)year < (int)limit2; limit2 = limit2 - 1) {\n        if ((limit2 & 3) == 0) {\n          if (limit2 == (limit2 / 100) * 100) {\n            if ((limit2 + 0x76c) % 400 == 0) {\n              daysToAdjust = 0x16e;\n            }\n            else {\n              daysToAdjust = 0x16d;\n            }\n          }\n          else {\n            daysToAdjust = 0x16e;\n          }\n        }\n        else {\n          daysToAdjust = 0x16d;\n        }\n        totalDays = totalDays - daysToAdjust;\n      }\n      if ((limit2 & 3) == 0) {\n        if (year == (year / 100) * 100) {\n          daysToAdjust = 0x16d;\n          if ((year + 0x76c) % 400 == 0) {\n            daysToAdjust = 0x16e;\n          }\n        }\n        else {\n          daysToAdjust = 0x16e;\n        }\n      }\n      else {\n        daysToAdjust = 0x16d;\n      }\n      totalDays = totalDays - daysToAdjust;\n    }\n  }\n  else {\n    limit2 = 0x46;\n    do {\n      if ((limit2 & 3) == 0) {\n        if (limit2 % 100 == 0) {\n          if ((limit2 + 0x76c) % 400 == 0) {\n            daysToAdjust = 0x16e;\n          }\n          else {\n            daysToAdjust = 0x16d;\n          }\n        }\n        else {\n          daysToAdjust = 0x16e;\n        }\n      }\n      else {\n        daysToAdjust = 0x16d;\n      }\n      limit2 = limit2 + 1;\n      totalDays = totalDays + daysToAdjust;\n    } while (year != limit2);\n  }\n  totalSeconds = (longlong)totalDays * 0x15180 +\n          (longlong)(timeStructure->tm_hour * 0xe10 + timeStructure->tm_min * 0x3c + timeStructure->tm_sec);\n  adjustedSeconds = (uint)totalSeconds;\n  daysToAdjust = (int)((ulonglong)totalSeconds >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  limit2 = _daylight;\n  if (_daylight == 0) {\nLAB_00004934:\n    adjustedTime = adjustedSeconds + timezoneInfo[10];\n  }\n  else {\n    isDstAdjusted = timeStructure->tm_isdst;\n    isDst = isDstAdjusted;\n    if (0 < (int)isDstAdjusted) {\n      isDst = 1;\n    }\n    if ((timezoneInfo[1] == timeStructure->tm_year + 0x76c) || (tempVar2 = __tzcalc_limits(), tempVar2 != 0)) {\n      limit3 = timezoneInfo[0x14];\n      tempVar1 = timezoneInfo[0x12];\n      limit1 = timezoneInfo[10];\n      limit2 = tempVar1 - limit1;\n      tempVar2 = (timezoneInfo[0x13] - ((int)limit1 >> 0x1f)) - (uint)(tempVar1 < limit1);\n      if (((int)((daysToAdjust - tempVar2) - (uint)(adjustedSeconds < limit2)) < 0 ==\n           (SBORROW4(daysToAdjust,tempVar2) != SBORROW4(daysToAdjust - tempVar2,(uint)(adjustedSeconds < limit2)))) &&\n         (tempVar3 = (timezoneInfo[0x13] - ((int)limit3 >> 0x1f)) - (uint)(tempVar1 < limit3),\n         isLeapYear = adjustedSeconds < tempVar1 - limit3,\n         (int)((daysToAdjust - tempVar3) - (uint)isLeapYear) < 0 !=\n         (SBORROW4(daysToAdjust,tempVar3) != SBORROW4(daysToAdjust - tempVar3,(uint)isLeapYear)))) goto LAB_00004a88;\n      tempVar1 = timezoneInfo[8] - limit3;\n      tempVar3 = (timezoneInfo[9] - ((int)limit3 >> 0x1f)) - (uint)((uint)timezoneInfo[8] < limit3);\n      if (*timezoneInfo != 0) {\n        if ((int)((daysToAdjust - tempVar3) - (uint)(adjustedSeconds < tempVar1)) < 0 ==\n            (SBORROW4(daysToAdjust,tempVar3) != SBORROW4(daysToAdjust - tempVar3,(uint)(adjustedSeconds < tempVar1))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        limit2 = 0;\n        if ((int)isDstAdjusted < 0) goto LAB_00004934;\nLAB_00004a14:\n        isDstAdjusted = isDst ^ limit2;\n        isDst = limit2;\n        if (isDstAdjusted == 1) {\n          if (limit2 == 0) {\n            daysToAdjust = limit3 - limit1;\n          }\n          else {\n            daysToAdjust = limit1 - limit3;\n          }\n          tempVar2 = timeStructure->tm_mday;\n          adjustedSeconds = adjustedSeconds + daysToAdjust;\n          timeStructure->tm_sec = timeStructure->tm_sec + daysToAdjust;\n          validate_structure(timeStructure);\n          tempVar2 = timeStructure->tm_mday - tempVar2;\n          if (tempVar2 != 0) {\n            if (tempVar2 < 2) {\n              if (tempVar2 == -2 || tempVar2 + 2 < 0 != SCARRY4(tempVar2,2)) {\n                tempVar2 = 1;\n              }\n            }\n            else {\n              tempVar2 = -1;\n            }\n            daysToAdjust = tempVar2 + timeStructure->tm_yday;\n            totalDays = totalDays + tempVar2;\n            if (daysToAdjust < 0) {\n              limit2 = year - 1;\n              if ((limit2 & 3) == 0) {\n                if (limit2 == (limit2 / 100) * 100) {\n                  daysToAdjust = 0x16d;\n                  if ((year + 0x76b) % 400 != 0) {\n                    daysToAdjust = 0x16c;\n                  }\n                }\n                else {\n                  daysToAdjust = 0x16d;\n                }\n              }\n              else {\n                daysToAdjust = 0x16c;\n              }\n            }\n            else {\n              if ((year & 3) == 0) {\n                if (year == (year / 100) * 100) {\n                  tempVar2 = 0x16d;\n                  if ((year + 0x76c) % 400 == 0) {\n                    tempVar2 = 0x16e;\n                  }\n                }\n                else {\n                  tempVar2 = 0x16e;\n                }\n              }\n              else {\n                tempVar2 = 0x16d;\n              }\n              if (tempVar2 <= daysToAdjust) {\n                daysToAdjust = daysToAdjust - tempVar2;\n              }\n            }\n            timeStructure->tm_yday = daysToAdjust;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((daysToAdjust - tempVar3) - (uint)(adjustedSeconds < tempVar1)) < 0 !=\n          (SBORROW4(daysToAdjust,tempVar3) != SBORROW4(daysToAdjust - tempVar3,(uint)(adjustedSeconds < tempVar1)))) {\nLAB_0000491e:\n        if ((int)((daysToAdjust - tempVar2) - (uint)(adjustedSeconds < limit2)) < 0 ==\n            (SBORROW4(daysToAdjust,tempVar2) != SBORROW4(daysToAdjust - tempVar2,(uint)(adjustedSeconds < limit2))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)isDstAdjusted) {\n        limit2 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      limit2 = isDst;\n      if (isDst != 1) goto LAB_00004934;\n    }\n    adjustedTime = adjustedSeconds + timezoneInfo[0x14];\n    limit2 = 1;\n  }\n  __tz_unlock();\n  timeStructure->tm_isdst = limit2;\n  timeStructure->tm_wday = (totalDays + 4U) % 7;\n  return adjustedTime;\n}\n\n",
            "renaming": {
                "FUN_000047e4": "calculate_adjusted_time_000047e4",
                "__tp": "timeStructure",
                "lVar1": "totalSeconds",
                "piVar2": "timezoneInfo",
                "uVar3": "tempVar1",
                "iVar4": "tempVar2",
                "iVar5": "tempVar3",
                "iVar6": "daysToAdjust",
                "uVar7": "limit1",
                "uVar8": "limit2",
                "uVar9": "limit3",
                "iVar10": "totalDays",
                "uVar11": "year",
                "uVar12": "isDst",
                "uVar13": "isDstAdjusted",
                "uVar14": "adjustedSeconds",
                "tVar15": "adjustedTime",
                "bVar16": "isLeapYear"
            },
            "calling": [
                "rtc_set_alarm",
                "rtc_set_time"
            ],
            "called": [
                "_tzset_unlocked",
                "validate_structure",
                "__tz_lock",
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004b34": {
            "entrypoint": "0x00004b34",
            "current_name": "allocate_memory_00004b34",
            "code": "\nvoid allocate_memory_00004b34(undefined4 *lock_status,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int *tempPtr;\n  int **tempPtr2;\n  int **tempPtr1;\n  int **currentPtr;\n  int **nextPtr;\n  int **newPtr;\n  bool comparisonResult;\n  \n  if (size == 0) {\n    return;\n  }\n  newPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newPtr = (int **)((int)newPtr + *(int *)(size + -4));\n  }\n  acquire_lock();\n  currentPtr = (int **)&free_list;\n  if (free_list == (int **)0x0) {\n    newPtr[1] = (int *)0x0;\n    tempPtr1 = tempPtr2;\n    free_list = newPtr;\n  }\n  else {\n    nextPtr = free_list;\n    if (newPtr < free_list) {\n      tempPtr1 = (int **)*newPtr;\n      currentPtr = (int **)((int)newPtr + (int)tempPtr1);\n      comparisonResult = free_list == currentPtr;\n      if (comparisonResult) {\n        currentPtr = (int **)*free_list;\n        free_list = (int **)free_list[1];\n      }\n      newPtr[1] = (int *)free_list;\n      free_list = newPtr;\n      if (comparisonResult) {\n        currentPtr = (int **)((int)currentPtr + (int)tempPtr1);\n        *newPtr = (int *)currentPtr;\n      }\n    }\n    else {\n      do {\n        currentPtr = nextPtr;\n        nextPtr = (int **)currentPtr[1];\n        if (nextPtr == (int **)0x0) break;\n      } while (nextPtr <= newPtr);\n      tempPtr1 = (int **)*currentPtr;\n      if ((int **)((int)currentPtr + (int)tempPtr1) == newPtr) {\n        tempPtr1 = (int **)((int)tempPtr1 + (int)*newPtr);\n        *currentPtr = (int *)tempPtr1;\n        if (nextPtr == (int **)((int)currentPtr + (int)tempPtr1)) {\n          tempPtr = *nextPtr;\n          currentPtr[1] = nextPtr[1];\n          tempPtr1 = (int **)((int)tempPtr1 + (int)tempPtr);\n          *currentPtr = (int *)tempPtr1;\n        }\n      }\n      else if (newPtr < (int **)((int)currentPtr + (int)tempPtr1)) {\n        *lock_status = 0xc;\n      }\n      else {\n        tempPtr1 = (int **)((int)newPtr + (int)*newPtr);\n        comparisonResult = nextPtr == tempPtr1;\n        if (comparisonResult) {\n          tempPtr1 = (int **)*nextPtr;\n          nextPtr = (int **)nextPtr[1];\n        }\n        newPtr[1] = (int *)nextPtr;\n        if (comparisonResult) {\n          tempPtr1 = (int **)((int)tempPtr1 + (int)*newPtr);\n          *newPtr = (int *)tempPtr1;\n        }\n        currentPtr[1] = (int *)newPtr;\n      }\n    }\n  }\n  release_lock(lock_status,tempPtr1,currentPtr,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004b34": "allocate_memory_00004b34",
                "param_1": "lock_status",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "piVar1": "tempPtr",
                "extraout_r1": "tempPtr2",
                "ppiVar2": "tempPtr1",
                "ppiVar3": "currentPtr",
                "ppiVar4": "nextPtr",
                "ppiVar5": "newPtr",
                "bVar6": "comparisonResult",
                "__malloc_lock": "acquire_lock",
                "__malloc_free_list": "free_list",
                "__malloc_unlock": "release_lock"
            },
            "calling": [
                "_realloc_r",
                "__ssrefill_r",
                "free",
                "__sflush_r",
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004bd0": {
            "entrypoint": "0x00004bd0",
            "current_name": "allocate_memory_00004bd0",
            "code": "\nuint allocate_memory_00004bd0(_reent *reentrant_struct,uint size)\n\n{\n  uint *prev_block;\n  void *new_sbrk;\n  int gap_size;\n  uint block_size;\n  uint *current_block;\n  uint aligned_size;\n  \n  aligned_size = (size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < size)) {\n    reentrant_struct->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    prev_block = __malloc_free_list;\n    for (current_block = __malloc_free_list; current_block != (uint *)0x0; current_block = (uint *)current_block[1]) {\n      block_size = *current_block - aligned_size;\n      if (-1 < (int)block_size) {\n        if (0xb < block_size) {\n          *current_block = block_size;\n          current_block = (uint *)((int)current_block + block_size);\n          goto LAB_00004c34;\n        }\n        if (prev_block == current_block) {\n          __malloc_free_list = (uint *)current_block[1];\n        }\n        if (prev_block != current_block) {\n          prev_block[1] = (uint)(uint *)current_block[1];\n        }\n        goto LAB_00004c42;\n      }\n      prev_block = current_block;\n    }\n    if (__malloc_sbrk_start == (void *)0x0) {\n      __malloc_sbrk_start = _sbrk_r(reentrant_struct,0);\n    }\n    prev_block = (uint *)_sbrk_r(reentrant_struct,aligned_size);\n    if ((prev_block != (uint *)0xffffffff) &&\n       ((current_block = (uint *)((int)prev_block + 3U & 0xfffffffc), prev_block == current_block ||\n        (new_sbrk = _sbrk_r(reentrant_struct,(int)current_block - (int)prev_block), new_sbrk != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *current_block = aligned_size;\nLAB_00004c42:\n      __malloc_unlock(reentrant_struct);\n      aligned_size = (int)current_block + 0xbU & 0xfffffff8;\n      gap_size = aligned_size - (int)(current_block + 1);\n      if (gap_size == 0) {\n        return aligned_size;\n      }\n      *(uint *)((int)current_block + gap_size) = (int)(current_block + 1) - aligned_size;\n      return aligned_size;\n    }\n    reentrant_struct->_errno = 0xc;\n    __malloc_unlock(reentrant_struct);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reentrant_struct",
                "param_2": "size",
                "puVar1": "prev_block",
                "pvVar2": "new_sbrk",
                "iVar3": "gap_size",
                "uVar4": "block_size",
                "puVar5": "current_block",
                "uVar6": "aligned_size"
            },
            "calling": [
                "__sfmoreglue",
                "__submore",
                "__smakebuf_r",
                "_realloc_r",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004c84": {
            "entrypoint": "0x00004c84",
            "current_name": "print_formatted_string_00004c84",
            "code": "\nint printFormattedString_00004c84(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  char *formatPointer;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  \n  impurePtr = _impure_ptr;\n  formatPointer = formatString;\n  param1 = arg1;\n  param2 = arg2;\n  param3 = arg3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&param1,formatPointer,&param1);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "pcVar2": "formatPointer",
                "uStack_c": "param1",
                "uStack_8": "param2",
                "uStack_4": "param3"
            },
            "calling": [
                "main_trampoline",
                "read",
                "hard_fault_handler",
                "_rtc_handler",
                "handle_input_line",
                "cpu_print_last_instruction",
                "probe",
                "phydat_dump",
                "core_panic",
                "_saul",
                "write",
                "print_help",
                "ps",
                "_print_time",
                "list"
            ],
            "called": [
                "__sinit",
                "_vfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cb4": {
            "entrypoint": "0x00004cb4",
            "current_name": "print_character_00004cb4",
            "code": "\nint print_character_00004cb4(int character)\n\n{\n  int iVar1;\n  undefined4 in_r3;\n  \n  iVar1 = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 = _putc_r(iVar1,character,*(undefined4 *)(iVar1 + 8),in_r3);\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00004cb4": "print_character_00004cb4",
                "__c": "character"
            },
            "calling": [
                "_putchar"
            ],
            "called": [
                "__sinit",
                "_putc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cdc": {
            "entrypoint": "0x00004cdc",
            "current_name": "process_input_00004cdc",
            "code": "\nundefined4 processInput_00004cdc(int input_ptr,int output_size)\n\n{\n  char char_value;\n  int result;\n  char *char_ptr;\n  char **stream_ptr;\n  undefined4 return_value;\n  char *output_ptr;\n  \n  if ((input_ptr != 0) && (*(int *)(input_ptr + 0x18) == 0)) {\n    __sinit();\n  }\n  stream_ptr = *(char ***)(input_ptr + 8);\n  if (*(int *)(input_ptr + 0x18) == 0) {\n    __sinit(input_ptr);\n  }\n  if (stream_ptr == (char **)&__sf_fake_stdin) {\n    stream_ptr = *(char ***)(input_ptr + 4);\n  }\n  else if (stream_ptr == (char **)&__sf_fake_stdout) {\n    stream_ptr = *(char ***)(input_ptr + 8);\n  }\n  else if (stream_ptr == (char **)&__sf_fake_stderr) {\n    stream_ptr = *(char ***)(input_ptr + 0xc);\n  }\n  if ((-1 < (int)stream_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream_ptr[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(stream_ptr + 3) << 0x1c) < 0) && (stream_ptr[4] != (char *)0x0)) ||\n     (result = __swsetup_r(input_ptr,stream_ptr), result == 0)) {\n    output_ptr = (char *)(output_size + -1);\n    do {\n      while( true ) {\n        output_ptr = output_ptr + 1;\n        char_value = *output_ptr;\n        char_ptr = stream_ptr[2] + -1;\n        stream_ptr[2] = char_ptr;\n        if (char_value == '\\0') {\n          if (-1 < (int)char_ptr) {\n            output_ptr = *stream_ptr;\n            return_value = 10;\n            *stream_ptr = output_ptr + 1;\n            *output_ptr = '\\n';\n            goto LAB_00004d64;\n          }\n          result = __swbuf_r(input_ptr,10,stream_ptr);\n          if (result != -1) {\n            return_value = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)char_ptr < 0) && (((int)char_ptr < (int)stream_ptr[6] || (char_value == '\\n')))) break;\n        char_ptr = *stream_ptr;\n        *stream_ptr = char_ptr + 1;\n        *char_ptr = char_value;\n      }\n      result = __swbuf_r(input_ptr,char_value,stream_ptr);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  return_value = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)stream_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream_ptr[0x16]);\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_00004cdc": "process_input_00004cdc",
                "param_1": "input_ptr",
                "param_2": "output_size",
                "cVar1": "char_value",
                "iVar2": "result",
                "pcVar3": "char_ptr",
                "ppcVar4": "stream_ptr",
                "uVar5": "return_value",
                "pcVar6": "output_ptr"
            },
            "calling": [
                "puts"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004db8": {
            "entrypoint": "0x00004db8",
            "current_name": "print_string_00004db8",
            "code": "\nint print_string_00004db8(char *string)\n\n{\n  int result;\n  \n  result = _puts_r(_impure_ptr,string);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004db8": "print_string_00004db8",
                "__s": "string",
                "iVar1": "result"
            },
            "calling": [
                "_rtc_usage",
                "_rtc_gettime",
                "read",
                "hard_fault_handler",
                "handle_input_line",
                "_alarm_handler",
                "phydat_dump",
                "_rtc_setalarm",
                "main",
                "_rtc_getalarm",
                "probe_all",
                "_rtc_settime",
                "write",
                "print_help",
                "list"
            ],
            "called": [
                "_puts_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dc8": {
            "entrypoint": "0x00004dc8",
            "current_name": "read_and_update_counters_00004dc8",
            "code": "\nvoid read_and_update_counters_00004dc8(_reent *reent_struct,int data_ptr,void *buffer_ptr,size_t buffer_size)\n\n{\n  _ssize_t read_result;\n  uint updated_counter;\n  bool is_read_successful;\n  \n  read_result = _read_r(reent_struct,(int)*(short *)(data_ptr + 0xe),buffer_ptr,buffer_size);\n  is_read_successful = -1 < read_result;\n  if (is_read_successful) {\n    updated_counter = *(int *)(data_ptr + 0x54) + read_result;\n  }\n  else {\n    updated_counter = *(ushort *)(data_ptr + 0xc) & 0xffffefff;\n  }\n  if (is_read_successful) {\n    *(uint *)(data_ptr + 0x54) = updated_counter;\n  }\n  if (!is_read_successful) {\n    *(short *)(data_ptr + 0xc) = (short)updated_counter;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dc8": "read_and_update_counters_00004dc8",
                "param_1": "reent_struct",
                "param_2": "data_ptr",
                "param_3": "buffer_ptr",
                "param_4": "buffer_size",
                "_Var1": "read_result",
                "uVar2": "updated_counter",
                "bVar3": "is_read_successful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dea": {
            "entrypoint": "0x00004dea",
            "current_name": "calculate_result_00004dea",
            "code": "\nundefined4 calculate_result_00004dea(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004dea": "calculate_result_00004dea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dee": {
            "entrypoint": "0x00004dee",
            "current_name": "write_data_to_file_00004dee",
            "code": "\nvoid writeDataToFile_00004dee(reent *reentPtr,int dataPtr,void *bufferPtr,size_t bufferSize)\n\n{\n  if ((int)((uint)*(ushort *)(dataPtr + 0xc) << 0x17) < 0) {\n    lseek(reentPtr,(int)*(short *)(dataPtr + 0xe),0,2);\n  }\n  *(ushort *)(dataPtr + 0xc) = *(ushort *)(dataPtr + 0xc) & 0xefff;\n  write(reentPtr,(int)*(short *)(dataPtr + 0xe),bufferPtr,bufferSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dee": "write_data_to_file_00004dee",
                "param_1": "reentPtr",
                "param_2": "dataPtr",
                "param_3": "bufferPtr",
                "param_4": "bufferSize",
                "_reent": "reent",
                "_lseek_r": "lseek",
                "_write_r": "write"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e26": {
            "entrypoint": "0x00004e26",
            "current_name": "optimize_file_seek_00004e26",
            "code": "\nvoid optimizeFileSeek_00004e26(_reent *reentStruct,int paramPtr,_off_t offset,int whence)\n\n{\n  _off_t seekResult;\n  ushort modifiedFlag;\n  bool isError;\n  \n  seekResult = _lseek_r(reentStruct,(int)*(short *)(paramPtr + 0xe),offset,whence);\n  isError = seekResult == -1;\n  if (isError) {\n    modifiedFlag = *(ushort *)(paramPtr + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(paramPtr + 0x54) = seekResult;\n    modifiedFlag = *(ushort *)(paramPtr + 0xc) | 0x1000;\n  }\n  if (isError) {\n    *(ushort *)(paramPtr + 0xc) = modifiedFlag;\n  }\n  if (!isError) {\n    *(ushort *)(paramPtr + 0xc) = modifiedFlag;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e26": "optimize_file_seek_00004e26",
                "param_1": "reentStruct",
                "param_2": "paramPtr",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seekResult",
                "uVar2": "modifiedFlag",
                "bVar3": "isError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e4a": {
            "entrypoint": "0x00004e4a",
            "current_name": "close_file_00004e4a",
            "code": "\nvoid closeFile_00004e4a(_reent *reentrantStruct,int fileDescriptor)\n\n{\n  _close_r(reentrantStruct,(int)*(short *)(fileDescriptor + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reentrantStruct",
                "param_2": "fileDescriptor"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e52": {
            "entrypoint": "0x00004e52",
            "current_name": "compare_strings_00004e52",
            "code": "\nint compareStrings_00004e52(char *string1,char *string2)\n\n{\n  byte char1;\n  uint char2;\n  bool isEqual;\n  \n  do {\n    char2 = (uint)(byte)*string1;\n    char1 = *string2;\n    isEqual = char2 == 1;\n    if (char2 != 0) {\n      isEqual = char2 == char1;\n    }\n    string1 = (char *)((byte *)string1 + 1);\n    string2 = (char *)((byte *)string2 + 1);\n  } while (isEqual);\n  return char2 - char1;\n}\n\n",
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string1",
                "__s2": "string2",
                "bVar1": "char1",
                "uVar2": "char2",
                "bVar3": "isEqual"
            },
            "calling": [
                "_saul",
                "read",
                "handle_input_line",
                "strcmp",
                "find_handler",
                "_tzset_unlocked_r"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e66": {
            "entrypoint": "0x00004e66",
            "current_name": "compare_strings_00004e66",
            "code": "\nint compare_strings_00004e66(char *string1,char *string2,size_t length)\n\n{\n  byte *current_char1;\n  int difference;\n  byte *current_char2;\n  uint char_code;\n  \n  if (length == 0) {\n    difference = 0;\n  }\n  else {\n    current_char2 = (byte *)(string2 + -1);\n    current_char1 = (byte *)string1;\n    do {\n      char_code = (uint)*current_char1;\n      current_char2 = current_char2 + 1;\n      if ((char_code != *current_char2) || (current_char1 + 1 == (byte *)(string1 + length))) break;\n      current_char1 = current_char1 + 1;\n    } while (char_code != 0);\n    difference = char_code - *current_char2;\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "current_char1",
                "iVar2": "difference",
                "pbVar3": "current_char2",
                "uVar4": "char_code"
            },
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e8c": {
            "entrypoint": "0x00004e8c",
            "current_name": "parse_integer_00004e8c",
            "code": "\nuint parseInteger_00004e8c(undefined4 *result,byte *str,byte **end,uint base)\n\n{\n  uint value;\n  uint digit;\n  uint isPositive;\n  uint parsedDigit;\n  int state;\n  uint maxInt;\n  uint quotient;\n  byte *currChar;\n  byte *nextChar;\n  \n  nextChar = str;\n  do {\n    currChar = nextChar;\n    nextChar = currChar + 1;\n    digit = (uint)*currChar;\n    isPositive = (byte)(&DAT_00007a99)[digit] & 8;\n  } while (((&DAT_00007a99)[digit] & 8) != 0);\n  if (digit == 0x2d) {\n    digit = (uint)*nextChar;\n    isPositive = 1;\n    nextChar = currChar + 2;\n  }\n  else if (digit == 0x2b) {\n    digit = (uint)*nextChar;\n    nextChar = currChar + 2;\n  }\n  if (base == 0) {\n    if (digit != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (digit != 0x30)) goto LAB_00004ed6;\n  if ((*nextChar & 0xdf) == 0x58) {\n    digit = (uint)nextChar[1];\n    base = 0x10;\n    nextChar = nextChar + 2;\n  }\n  else {\n    digit = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  maxInt = isPositive + 0x7fffffff;\n  state = 0;\n  quotient = maxInt / base;\n  value = 0;\n  do {\n    parsedDigit = digit - 0x30;\n    if (9 < parsedDigit) {\n      if (digit - 0x41 < 0x1a) {\n        parsedDigit = digit - 0x37;\n      }\n      else {\n        if (0x19 < digit - 0x61) break;\n        parsedDigit = digit - 0x57;\n      }\n    }\n    if ((int)base <= (int)parsedDigit) break;\n    if (state != -1) {\n      if ((quotient < value) || ((quotient == value && ((int)(maxInt - base * quotient) < (int)parsedDigit)))) {\n        state = -1;\n      }\n      else {\n        value = value * base + parsedDigit;\n        state = 1;\n      }\n    }\n    digit = (uint)*nextChar;\n    nextChar = nextChar + 1;\n  } while( true );\n  if (state == -1) {\n    *result = 0x22;\n    value = maxInt;\n    if (end == (byte **)0x0) {\n      return maxInt;\n    }\n  }\n  else {\n    if (isPositive != 0) {\n      value = -value;\n    }\n    if (end == (byte **)0x0) {\n      return value;\n    }\n    if (state == 0) goto LAB_00004f64;\n  }\n  str = nextChar + -1;\nLAB_00004f64:\n  *end = str;\n  return value;\n}\n\n",
            "renaming": {
                "FUN_00004e8c": "parse_integer_00004e8c",
                "param_1": "result",
                "param_2": "str",
                "param_3": "end",
                "param_4": "base",
                "uVar1": "value",
                "uVar2": "digit",
                "uVar3": "isPositive",
                "uVar4": "parsedDigit",
                "iVar5": "state",
                "uVar6": "maxInt",
                "uVar7": "quotient",
                "pbVar8": "currChar",
                "pbVar9": "nextChar"
            },
            "calling": [
                "strtol",
                "_strtol_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f80": {
            "entrypoint": "0x00004f80",
            "current_name": "FUN_00004f80",
            "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)(&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f84": {
            "entrypoint": "0x00004f84",
            "current_name": "convert_string_to_long_00004f84",
            "code": "\nlong convertStringToLong_00004f84(char *inputString,char **endPointer,int base)\n\n{\n  long convertedValue;\n  \n  convertedValue = _strtol_l_isra_0(_impure_ptr,inputString,endPointer,base);\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00004f84": "convert_string_to_long_00004f84",
                "__nptr": "inputString",
                "__endptr": "endPointer",
                "__base": "base",
                "lVar1": "convertedValue"
            },
            "calling": [
                "_parse_time",
                "atoi"
            ],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f98": {
            "entrypoint": "0x00004f98",
            "current_name": "calculate_day_of_week_00004f98",
            "code": "\nundefined4 calculateDayOfWeek_00004f98(uint year)\n\n{\n  uint *timezoneInfo;\n  undefined4 result;\n  uint dayOfWeek;\n  int daysToAdd;\n  uint *monthInfo;\n  int totalDays;\n  uint isLeapYear;\n  int monthIndex;\n  int daysOfWeekOffset;\n  uint isLeapYearMultiple;\n  \n  timezoneInfo = (uint *)__gettzinfo();\n  if ((int)year < 0x7b2) {\n    result = 0;\n  }\n  else {\n    totalDays = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) +\n            (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    timezoneInfo[1] = year;\n    isLeapYearMultiple = (uint)(year % 400 == 0);\n    monthInfo = timezoneInfo;\n    do {\n      dayOfWeek = monthInfo[5];\n      if (*(char *)(monthInfo + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)dayOfWeek < 0x3c) {\n            daysToAdd = 0;\n          }\n          else {\n            daysToAdd = 1;\n          }\n        }\n        else {\n          daysToAdd = 0;\n        }\n        daysToAdd = daysToAdd + totalDays + dayOfWeek + -1;\n      }\n      else if (*(char *)(monthInfo + 2) == 'D') {\n        daysToAdd = totalDays + dayOfWeek;\n      }\n      else {\n        isLeapYear = isLeapYearMultiple;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          isLeapYear = 1;\n        }\n        monthIndex = 0;\n        daysToAdd = totalDays;\n        while( true ) {\n          monthIndex = monthIndex + 1;\n          if ((int)monthInfo[3] <= monthIndex) break;\n          daysToAdd = daysToAdd + *(int *)(&UNK_00007b98 + monthIndex * 4 + isLeapYear * 0x30);\n        }\n        daysOfWeekOffset = dayOfWeek - (daysToAdd + 4U) % 7;\n        if (daysOfWeekOffset < 0) {\n          daysOfWeekOffset = daysOfWeekOffset + 7;\n        }\n        for (daysOfWeekOffset = (monthInfo[4] - 1) * 7 + daysOfWeekOffset;\n            *(int *)(&UNK_00007b98 + monthIndex * 4 + isLeapYear * 0x30) <= daysOfWeekOffset; daysOfWeekOffset = daysOfWeekOffset + -7) {\n        }\n        daysToAdd = daysToAdd + daysOfWeekOffset;\n      }\n      dayOfWeek = monthInfo[10] + daysToAdd * 0x15180 + monthInfo[6];\n      monthInfo[8] = dayOfWeek;\n      monthInfo[9] = (int)dayOfWeek >> 0x1f;\n      monthInfo = monthInfo + 10;\n    } while (timezoneInfo + 0x14 != monthInfo);\n    dayOfWeek = timezoneInfo[9];\n    isLeapYearMultiple = timezoneInfo[0x13];\n    *timezoneInfo = (uint)((int)((dayOfWeek - isLeapYearMultiple) - (uint)(timezoneInfo[8] < timezoneInfo[0x12])) < 0 !=\n                    (SBORROW4(dayOfWeek,isLeapYearMultiple) !=\n                    SBORROW4(dayOfWeek - isLeapYearMultiple,(uint)(timezoneInfo[8] < timezoneInfo[0x12]))));\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "timezoneInfo",
                "uVar2": "result",
                "uVar3": "dayOfWeek",
                "iVar4": "daysToAdd",
                "puVar5": "monthInfo",
                "iVar6": "totalDays",
                "uVar7": "isLeapYear",
                "iVar8": "monthIndex",
                "iVar9": "daysOfWeekOffset",
                "uVar10": "isLeapYearMultiple"
            },
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__gettzinfo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050e8": {
            "entrypoint": "0x000050e8",
            "current_name": "acquire_tz_mutex_000050e8",
            "code": "\nvoid acquire_tz_mutex_000050e8(void)\n\n{\n  __retarget_lock_acquire(&mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050e8": "acquire_tz_mutex_000050e8",
                "__lock___tz_mutex": "mutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_acquire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050f4": {
            "entrypoint": "0x000050f4",
            "current_name": "release_lock_000050f4",
            "code": "\nvoid releaseLock_000050f4(void)\n\n{\n  __retarget_lock_release(lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050f4": "release_lock_000050f4",
                "&__lock___tz_mutex": "lock"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005100": {
            "entrypoint": "0x00005100",
            "current_name": "initialize_time_zone_00005100",
            "code": "\nvoid initializeTimeZone_00005100(void)\n\n{\n  setTimeZone(currentImpurePointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005100": "initialize_time_zone_00005100",
                "_tzset_unlocked_r": "setTimeZone",
                "_impure_ptr": "currentImpurePointer"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "_tzset_unlocked_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000510c": {
            "entrypoint": "0x0000510c",
            "current_name": "set_time_zone_info_0000510c",
            "code": "\nvoid setTimeZoneInfo_0000510c(undefined4 param)\n\n{\n  int tzinfoPtr;\n  char *envVar;\n  size_t envVarLength;\n  int comparisonResult;\n  int scanResult;\n  ulong numResult;\n  undefined flag;\n  char *scanPos;\n  bool isFirstLoop;\n  ushort *dstHoursPtr;\n  int *scanPosPtr;\n  ushort *dstMinutesPtr;\n  int *scanPosPtr2;\n  ushort stdHours;\n  ushort stdMinutes;\n  ushort stdSeconds;\n  ushort dstHours;\n  ushort dstMinutes;\n  ushort dstSeconds;\n  int scanPos2;\n  char *numResult [2];\n  \n  tzinfoPtr = __gettzinfo();\n  envVar = (char *)_getenv_r(param,&DAT_00007a5c);\n  if (envVar == (char *)0x0) {\n    _tzname = &DAT_00007a5f;\n    DAT_1fff02e8 = &DAT_00007a5f;\n    _daylight = envVar;\n    _timezone = envVar;\n    free(prev_tzenv);\n    prev_tzenv = (char *)0x0;\n  }\n  else if ((prev_tzenv == (char *)0x0) || (comparisonResult = strcmp(envVar,prev_tzenv), comparisonResult != 0)) {\n    free(prev_tzenv);\n    envVarLength = strlen(envVar);\n    prev_tzenv = (char *)_malloc_r(param,envVarLength + 1);\n    if (prev_tzenv != (char *)0x0) {\n      strcpy(prev_tzenv,envVar);\n    }\n    if (*envVar == ':') {\n      envVar = envVar + 1;\n    }\n    comparisonResult = siscanf(envVar,\"%10[^0-9,+-]%n\",&__tzname_std,&scanPos2);\n    if (0 < comparisonResult) {\n      scanPos = envVar + scanPos2;\n      if (envVar[scanPos2] == '-') {\n        scanPos = scanPos + 1;\n        comparisonResult = -1;\n      }\n      else {\n        if (envVar[scanPos2] == '+') {\n          scanPos = scanPos + 1;\n        }\n        comparisonResult = 1;\n      }\n      stdMinutes = 0;\n      stdSeconds = 0;\n      dstHoursPtr = &stdMinutes;\n      scanPosPtr = &scanPos2;\n      dstMinutesPtr = &stdSeconds;\n      scanPosPtr2 = &scanPos2;\n      scanResult = siscanf(scanPos,\"%hu%n:%hu%n:%hu%n\",&stdHours,&scanPos2,&stdMinutes,&scanPos2,&stdSeconds,\n                      &scanPos2);\n      if (0 < scanResult) {\n        *(uint *)(tzinfoPtr + 0x28) =\n             ((uint)stdHours * 0xe10 + (uint)stdMinutes * 0x3c + (uint)stdSeconds) * comparisonResult;\n        _tzname = &__tzname_std;\n        scanPos = scanPos + scanPos2;\n        comparisonResult = siscanf(scanPos,\"%10[^0-9,+-]%n\",&__tzname_dst,&scanPos2,dstHoursPtr,scanPosPtr,dstMinutesPtr,\n                        scanPosPtr2);\n        if (comparisonResult < 1) {\n          DAT_1fff02e8 = _tzname;\n          _timezone = *(char **)(tzinfoPtr + 0x28);\n          _daylight = (char *)0x0;\n        }\n        else {\n          DAT_1fff02e8 = &__tzname_dst;\n          envVar = scanPos + scanPos2;\n          if (scanPos[scanPos2] == '-') {\n            envVar = envVar + 1;\n            comparisonResult = -1;\n          }\n          else {\n            if (scanPos[scanPos2] == '+') {\n              envVar = envVar + 1;\n            }\n            comparisonResult = 1;\n          }\n          stdHours = 0;\n          stdMinutes = 0;\n          stdSeconds = 0;\n          scanPos2 = 0;\n          scanResult = siscanf(envVar,\"%hu%n:%hu%n:%hu%n\",&stdHours,&scanPos2,&stdMinutes,&scanPos2,\n                          &stdSeconds,&scanPos2);\n          if (scanResult < 1) {\n            comparisonResult = *(int *)(tzinfoPtr + 0x28) + -0xe10;\n          }\n          else {\n            comparisonResult = ((uint)stdHours * 0xe10 + (uint)stdMinutes * 0x3c + (uint)stdSeconds) * comparisonResult;\n          }\n          *(int *)(tzinfoPtr + 0x50) = comparisonResult;\n          envVar = envVar + scanPos2;\n          isFirstLoop = false;\n          comparisonResult = tzinfoPtr;\n          while( true ) {\n            if (*envVar == ',') {\n              envVar = envVar + 1;\n            }\n            if (*envVar == 'M') {\n              scanResult = siscanf(envVar,\"M%hu%n.%hu%n.%hu%n\",&dstHours,&scanPos2,&dstMinutes,&scanPos2,\n                              &dstSeconds,&scanPos2);\n              if (scanResult != 3) {\n                return;\n              }\n              if (0xb < dstHours - 1) {\n                return;\n              }\n              if (4 < dstMinutes - 1) {\n                return;\n              }\n              if (6 < dstSeconds) {\n                return;\n              }\n              *(uint *)(comparisonResult + 0xc) = (uint)dstHours;\n              *(uint *)(comparisonResult + 0x10) = (uint)dstMinutes;\n              *(undefined *)(comparisonResult + 8) = 0x4d;\n              *(uint *)(comparisonResult + 0x14) = (uint)dstSeconds;\n              scanPos = envVar + scanPos2;\n            }\n            else {\n              if (*envVar == 'J') {\n                envVar = envVar + 1;\n                flag = 0x4a;\n              }\n              else {\n                flag = 0x44;\n              }\n              numResult = strtoul(envVar,numResult,10);\n              dstSeconds = (ushort)numResult;\n              scanPos = numResult[0];\n              if (numResult[0] == envVar) {\n                if (isFirstLoop) {\n                  *(undefined *)(tzinfoPtr + 0x30) = 0x4d;\n                  *(undefined4 *)(tzinfoPtr + 0x34) = 0xb;\n                  *(undefined4 *)(tzinfoPtr + 0x38) = 1;\n                  *(undefined4 *)(tzinfoPtr + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(tzinfoPtr + 8) = 0x4d;\n                  *(undefined4 *)(tzinfoPtr + 0xc) = 3;\n                  *(undefined4 *)(tzinfoPtr + 0x10) = 2;\n                  *(undefined4 *)(tzinfoPtr + 0x14) = 0;\n                }\n              }\n              else {\n                *(undefined *)(comparisonResult + 8) = flag;\n                *(ulong *)(comparisonResult + 0x14) = numResult & 0xffff;\n              }\n            }\n            stdHours = 2;\n            stdMinutes = 0;\n            stdSeconds = 0;\n            scanPos2 = 0;\n            if (*scanPos == '/') {\n              siscanf(scanPos,\"/%hu%n:%hu%n:%hu%n\",&stdHours,&scanPos2,&stdMinutes,&scanPos2,&stdSeconds,\n                      &scanPos2);\n            }\n            *(uint *)(comparisonResult + 0x18) =\n                 (uint)stdHours * 0xe10 + (uint)stdMinutes * 0x3c + (uint)stdSeconds;\n            comparisonResult = comparisonResult + 0x28;\n            envVar = scanPos + scanPos2;\n            if (isFirstLoop) break;\n            isFirstLoop = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(tzinfoPtr + 4));\n          _timezone = *(char **)(tzinfoPtr + 0x28);\n          _daylight = (char *)(*(int *)(tzinfoPtr + 0x50) - (int)_timezone);\n          if (_daylight != (char *)0x0) {\n            _daylight = (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000510c": "set_time_zone_info_0000510c",
                "param_1": "param",
                "iVar1": "tzinfoPtr",
                "pcVar2": "envVar",
                "sVar3": "envVarLength",
                "iVar4": "comparisonResult",
                "iVar5": "scanResult",
                "uVar6": "numResult",
                "uVar7": "flag",
                "pcVar8": "scanPos",
                "bVar9": "isFirstLoop",
                "puVar10": "dstHoursPtr",
                "piVar11": "scanPosPtr",
                "puVar12": "dstMinutesPtr",
                "piVar13": "scanPosPtr2",
                "local_3c": "stdHours",
                "local_3a": "stdMinutes",
                "local_38": "stdSeconds",
                "local_36": "dstHours",
                "local_34": "dstMinutes",
                "local_32": "dstSeconds",
                "local_30": "scanPos2",
                "local_2c": "numResult"
            },
            "calling": [
                "_tzset_unlocked"
            ],
            "called": [
                "_malloc_r",
                "_getenv_r",
                "__gettzinfo",
                "siscanf",
                "free",
                "strlen",
                "strtoul",
                "strcmp",
                "__tzcalc_limits",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005404": {
            "entrypoint": "0x00005404",
            "current_name": "process_input_00005404",
            "code": "\nuint processInput_00005404(int inputPointer,uint character,int *stream,undefined4 param)\n\n{\n  int returnValue;\n  uint ushortValue;\n  undefined *pointerValue;\n  \n  if ((inputPointer != 0) && (*(int *)(inputPointer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(inputPointer + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(inputPointer + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(inputPointer + 0xc);\n  }\n  stream[2] = stream[6];\n  ushortValue = (uint)*(ushort *)(stream + 3);\n  returnValue = ushortValue << 0x1c;\n  if (((returnValue < 0) && (ushortValue = stream[4], ushortValue != 0)) ||\n     (returnValue = __swsetup_r(inputPointer,stream,returnValue,ushortValue,param), returnValue == 0)) {\n    returnValue = *stream - stream[4];\n    character = character & 0xff;\n    if ((returnValue < stream[5]) || (returnValue = _fflush_r(inputPointer,stream), returnValue == 0)) {\n      stream[2] = stream[2] + -1;\n      pointerValue = (undefined *)*stream;\n      *stream = (int)(pointerValue + 1);\n      *pointerValue = (char)character;\n      if (stream[5] != returnValue + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      returnValue = _fflush_r(inputPointer,stream);\n      if (returnValue == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00005404": "process_input_00005404",
                "param_1": "inputPointer",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "param",
                "iVar1": "returnValue",
                "uVar2": "ushortValue",
                "puVar3": "pointerValue"
            },
            "calling": [
                "__sfputc_r",
                "_puts_r",
                "_putc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000054a8": {
            "entrypoint": "0x000054a8",
            "current_name": "parse_stream_properties_000054a8",
            "code": "\nuint parseStreamProperties_000054a8(undefined4 *streamProperties,undefined4 *stream)\n\n{\n  ushort streamFlags;\n  int impure_ptr;\n  ushort streamFlagsCopy;\n  uint streamFlagsValue;\n  uint uVar5;\n  \n  impure_ptr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    initializeImpurePtr(_impure_ptr);\n  }\n  if (stream == &fakeStdin) {\n    stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (stream == (undefined4 *)&fakeStdout) {\n    stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (stream == (undefined4 *)&fakeStderr) {\n    stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  streamFlagsValue = (uint)*(ushort *)(stream + 3);\n  streamFlagsCopy = *(ushort *)(stream + 3);\n  if (-1 < (int)(streamFlagsValue << 0x1c)) {\n    if (-1 < (int)(streamFlagsValue << 0x1b)) {\n      *streamProperties = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(streamFlagsValue << 0x1d) < 0) {\n      if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)stream[0xd] != stream + 0x11) {\n          _freeResources(streamProperties);\n        }\n        stream[0xd] = 0;\n      }\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n      stream[1] = 0;\n      *stream = stream[4];\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 8;\n  }\n  if ((stream[4] == 0) && ((*(ushort *)(stream + 3) & 0x280) != 0x200)) {\n    createBuffer(streamProperties,stream);\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  streamFlagsValue = (uint)streamFlags;\n  streamFlagsCopy = *(ushort *)(stream + 3);\n  uVar5 = streamFlagsValue & 1;\n  if ((streamFlags & 1) == 0) {\n    if (-1 < (int)(streamFlagsValue << 0x1e)) {\n      uVar5 = stream[5];\n    }\n    stream[2] = uVar5;\n  }\n  else {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n  if (stream[4] != 0) {\n    return 0;\n  }\n  if ((streamFlags & 0x80) == 0) {\n    return streamFlagsValue & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(stream + 3) = streamFlagsCopy | 0x40;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000054a8": "parse_stream_properties_000054a8",
                "param_1": "streamProperties",
                "param_2": "stream",
                "uVar1": "streamFlags",
                "iVar2": "impure_ptr",
                "uVar3": "streamFlagsCopy",
                "uVar4": "streamFlagsValue",
                "__sinit": "initializeImpurePtr",
                "__sf_fake_stdin": "fakeStdin",
                "__sf_fake_stdout": "fakeStdout",
                "__sf_fake_stderr": "fakeStderr",
                "free_r": "freeResources",
                "__smakebuf_r": "createBuffer"
            },
            "calling": [
                "__swbuf_r",
                "_puts_r",
                "_vfprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005584": {
            "entrypoint": "0x00005584",
            "current_name": "divide_00005584",
            "code": "\ndiv_t divide_00005584(int numerator,int denominator)\n\n{\n  uint remainder;\n  int temp;\n  uint quotient;\n  div_t result;\n  \n  quotient = (uint)denominator / remainder;\n  temp = denominator - remainder * quotient;\n  if (denominator < 0) {\n    if (0 < temp) {\n      quotient = quotient - 1;\n      temp = temp + remainder;\n    }\n  }\n  else if (temp < 0) {\n    quotient = quotient + 1;\n    temp = temp - remainder;\n  }\n  *(uint *)numerator = quotient;\n  *(int *)(numerator + 4) = temp;\n  result.rem = denominator;\n  result.quot = numerator;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005584": "divide_00005584",
                "__numer": "numerator",
                "__denom": "denominator",
                "in_r2": "remainder",
                "iVar1": "temp",
                "uVar2": "quotient",
                "dVar3": "result"
            },
            "calling": [
                "validate_structure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000055ac": {
            "entrypoint": "0x000055ac",
            "current_name": "read_byte_from_stream_000055ac",
            "code": "\nuint readByteFromStream_000055ac(int streamHandle,byte **streamPtr)\n\n{\n  uint byteValue;\n  byte *streamDataPtr;\n  \n  if ((streamHandle != 0) && (*(int *)(streamHandle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPtr == (byte **)&__sf_fake_stdin) {\n    streamPtr = *(byte ***)(streamHandle + 4);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stdout) {\n    streamPtr = *(byte ***)(streamHandle + 8);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stderr) {\n    streamPtr = *(byte ***)(streamHandle + 0xc);\n  }\n  if ((-1 < (int)streamPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(streamPtr[0x16]);\n  }\n  streamDataPtr = streamPtr[1];\n  streamPtr[1] = streamDataPtr + -1;\n  if ((int)(streamDataPtr + -1) < 0) {\n    byteValue = __srget_r(streamHandle,streamPtr);\n  }\n  else {\n    streamDataPtr = *streamPtr;\n    *streamPtr = streamDataPtr + 1;\n    byteValue = (uint)*streamDataPtr;\n  }\n  if ((-1 < (int)streamPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(streamPtr[0x16]);\n  }\n  return byteValue;\n}\n\n",
            "renaming": {
                "FUN_000055ac": "read_byte_from_stream_000055ac",
                "param_1": "streamHandle",
                "param_2": "streamPtr",
                "uVar1": "byteValue",
                "pbVar2": "streamDataPtr"
            },
            "calling": [
                "getchar"
            ],
            "called": [
                "__sinit",
                "__srget_r",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000562c": {
            "entrypoint": "0x0000562c",
            "current_name": "find_environment_variable_0000562c",
            "code": "\nchar * find_environment_variable_0000562c(undefined4 lock,char *variable_name,int *index)\n\n{\n  char character;\n  char **env;\n  int comparison_result;\n  char *current_char;\n  char **current_env;\n  size_t name_length;\n  \n  __env_lock();\n  current_char = variable_name;\n  if (environ != (char **)0x0) {\n    do {\n      character = *current_char;\n      if (character == '\\0') {\n        name_length = (int)current_char - (int)variable_name;\n        env = environ;\n        while( true ) {\n          current_env = env;\n          if (*current_env == (char *)0x0) break;\n          comparison_result = strncmp(*current_env,variable_name,name_length);\n          env = current_env + 1;\n          if ((comparison_result == 0) && (current_char = *current_env, current_char[name_length] == '=')) {\n            *index = (int)current_env - (int)environ >> 2;\n            __env_unlock(lock);\n            return current_char + name_length + 1;\n          }\n        }\n        break;\n      }\n      current_char = current_char + 1;\n    } while (character != '=');\n  }\n  __env_unlock(lock);\n  return (char *)0x0;\n}\n\n",
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "lock",
                "param_2": "variable_name",
                "param_3": "index",
                "cVar1": "character",
                "ppcVar2": "env",
                "iVar3": "comparison_result",
                "pcVar4": "current_char",
                "ppcVar5": "current_env",
                "__n": "name_length"
            },
            "calling": [
                "_getenv_r"
            ],
            "called": [
                "__env_lock",
                "__env_unlock",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056a0": {
            "entrypoint": "0x000056a0",
            "current_name": "find_environment_variable_000056a0",
            "code": "\nvoid find_environment_variable_000056a0(undefined4 environment,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  undefined4 arg2_stack;\n  undefined4 arg3_stack;\n  \n  arg2_stack = arg2;\n  arg3_stack = arg3;\n  _findenv_r(environment,arg2,&arg2_stack,arg4,environment);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "environment",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "uStack_c": "arg2_stack",
                "uStack_8": "arg3_stack"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_findenv_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b0": {
            "entrypoint": "0x000056b0",
            "current_name": "FUNC_000056b0",
            "code": "\nundefined1 * FUNC_000056b0(void)\n\n{\n  return &tzinfo;\n}\n\n",
            "renaming": {
                "FUN_000056b0": "FUNC_000056b0"
            },
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000056b8": {
            "entrypoint": "0x000056b8",
            "current_name": "check_file_permission_000056b8",
            "code": "\nundefined4 checkFilePermission_000056b8(_reent *reentrantStruct,int fileDescriptor,undefined4 *permissionResult,uint *isSetuid)\n\n{\n  int fileStatus;\n  undefined4 permissionCode;\n  stat fileStats;\n  \n  if ((*(short *)(fileDescriptor + 0xe) < 0) ||\n     (fileStatus = _fstat_r(reentrantStruct,(int)*(short *)(fileDescriptor + 0xe),&fileStats), fileStatus < 0)) {\n    *isSetuid = 0;\n    if ((int)((uint)*(ushort *)(fileDescriptor + 0xc) << 0x18) < 0) {\n      permissionCode = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *isSetuid = (uint)((fileStats.st_mode & 0xf000) == 0x2000);\n  }\n  permissionCode = 0x400;\nLAB_000056f8:\n  *permissionResult = permissionCode;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000056b8": "check_file_permission_000056b8",
                "param_1": "reentrantStruct",
                "param_2": "fileDescriptor",
                "param_3": "permissionResult",
                "param_4": "isSetuid",
                "iVar1": "fileStatus",
                "uVar2": "permissionCode",
                "sStack_68": "fileStats"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005700": {
            "entrypoint": "0x00005700",
            "current_name": "initialize_file_descriptor_00005700",
            "code": "\nvoid initializeFileDescriptor_00005700(_reent *reentStruct,int *fileDescriptor)\n\n{\n  ushort swhatbufResult;\n  int mallocResult;\n  _reent *localReent;\n  int *localFD;\n  \n  if (-1 < (int)((uint)*(ushort *)(fileDescriptor + 3) << 0x1e)) {\n    localReent = reentStruct;\n    localFD = fileDescriptor;\n    swhatbufResult = __swhatbuf_r(reentStruct,fileDescriptor,&localReent,&localFD);\n    mallocResult = _malloc_r(reentStruct,localReent);\n    if (mallocResult != 0) {\n      reentStruct->__cleanup = _cleanup_r + 1;\n      *fileDescriptor = mallocResult;\n      *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) | 0x80;\n      fileDescriptor[5] = (int)localReent;\n      fileDescriptor[4] = mallocResult;\n      if ((localFD != (int *)0x0) &&\n         (mallocResult = _isatty_r(reentStruct,(int)*(short *)((int)fileDescriptor + 0xe)), mallocResult != 0)) {\n        *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(fileDescriptor + 3) = swhatbufResult | *(ushort *)(fileDescriptor + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(fileDescriptor + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xfffc | 2;\n  }\n  *fileDescriptor = (int)fileDescriptor + 0x47;\n  fileDescriptor[4] = (int)fileDescriptor + 0x47;\n  fileDescriptor[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005700": "initialize_file_descriptor_00005700",
                "param_1": "reentStruct",
                "param_2": "fileDescriptor",
                "uVar1": "swhatbufResult",
                "iVar2": "mallocResult",
                "local_18": "localReent",
                "local_14": "localFD"
            },
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005780": {
            "entrypoint": "0x00005780",
            "current_name": "dealloc_memory_00005780",
            "code": "\nvoid dealloc_memory_00005780(void *ptr)\n\n{\n  _free_r(_impure_ptr,ptr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005780": "dealloc_memory_00005780",
                "__ptr": "ptr"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005790": {
            "entrypoint": "0x00005790",
            "current_name": "acquire_malloc_recursive_lock_00005790",
            "code": "\nvoid acquireMallocRecursiveLock_00005790(void)\n\n{\n  __retarget_lock_acquire_recursive(&mallocRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005790": "acquire_malloc_recursive_lock_00005790",
                "__lock___malloc_recursive_mutex": "mallocRecursiveMutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000579c": {
            "entrypoint": "0x0000579c",
            "current_name": "release_recursive_mutex_0000579c",
            "code": "\nvoid releaseRecursiveMutex_0000579c(void)\n\n{\n  __retarget_lock_release_recursive(&mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000579c": "release_recursive_mutex_0000579c",
                "__lock___malloc_recursive_mutex": "mutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057a8": {
            "entrypoint": "0x000057a8",
            "current_name": "write_to_buffer_000057a8",
            "code": "\nint writeToBuffer_000057a8(undefined4 arg1,int arg2,undefined4 *buffer)\n\n{\n  int remaining;\n  undefined *currentPoi;\n  \n  remaining = buffer[2] + -1;\n  buffer[2] = remaining;\n  if ((remaining < 0) && ((remaining < (int)buffer[6] || (arg2 == 10)))) {\n    remaining = __swbuf_r();\n    return remaining;\n  }\n  currentPoi = (undefined *)*buffer;\n  *buffer = currentPoi + 1;\n  *currentPoi = (char)arg2;\n  return arg2;\n}\n\n",
            "renaming": {
                "FUN_000057a8": "write_to_buffer_000057a8",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "buffer",
                "iVar1": "remaining",
                "puVar2": "currentPoi"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057d2": {
            "entrypoint": "0x000057d2",
            "current_name": "write_to_stream_000057d2",
            "code": "\nint write_to_stream_000057d2(undefined4 stream,undefined4 position,undefined *data,int length)\n\n{\n  int result;\n  undefined *end_ptr;\n  int remaining_length;\n  \n  end_ptr = data + length;\n  remaining_length = length;\n  do {\n    if (data == end_ptr) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,position,length,remaining_length);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "stream",
                "param_2": "position",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end_ptr",
                "iVar3": "remaining_length"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057f8": {
            "entrypoint": "0x000057f8",
            "current_name": "format_string_000057f8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint formatString_000057f8(int stream,undefined4 *args,byte *format,int *outputBytes)\n\n{\n  bool foundDecimal;\n  int accumulator;\n  int result;\n  void *foundFlag;\n  int *nextArg;\n  byte *currentChar;\n  int lockIndex;\n  byte *formatPtr;\n  int *argPtr;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int argWidth;\n  int outputLength;\n  byte specifier;\n  undefined flagSpace;\n  undefined flagPlus;\n  undefined decimalPoint;\n  undefined4 modifier;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (args == &__sf_fake_stdin) {\n    args = *(undefined4 **)(stream + 4);\n  }\n  else if (args == (undefined4 *)&__sf_fake_stdout) {\n    args = *(undefined4 **)(stream + 8);\n  }\n  else if (args == (undefined4 *)&__sf_fake_stderr) {\n    args = *(undefined4 **)(stream + 0xc);\n  }\n  if ((-1 < (int)(args[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(args + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(args[0x16]);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(args + 3) << 0x1c)) || (args[4] == 0)) &&\n     (accumulator = __swsetup_r(stream,args), accumulator != 0)) {\n    if ((-1 < (int)(args[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(args + 3) << 0x16)))\n    {\n      __retarget_lock_release_recursive(args[0x16]);\n    }\n    return -1;\n  }\n  outputLength = 0;\n  flagSpace = 0x20;\n  flagPlus = 0x30;\n  formatPtr = format;\n  argPtr = outputBytes;\nLAB_0000588e:\n  currentChar = formatPtr;\n  if (*currentChar != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  formatPtr = currentChar + 1;\n  if (*currentChar == 0x25) {\nLAB_0000589a:\n    accumulator = (int)currentChar - (int)format;\n    if (accumulator != 0) {\n      result = __sfputs_r(stream,args,format,accumulator);\n      if (result == -1) {\nLAB_00005a06:\n        if ((-1 < (int)(args[0x19] << 0x1f)) &&\n           (-1 < (int)((uint)*(ushort *)(args + 3) << 0x16))) {\n          __retarget_lock_release_recursive(args[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(args + 3) << 0x19) < 0) {\n          return -1;\n        }\n        return outputLength;\n      }\n      outputLength = outputLength + accumulator;\n    }\n    if (*currentChar == 0) goto LAB_00005a06;\n    precision = -1;\n    width = 0;\n    flags = 0;\n    argWidth = 0;\n    decimalPoint = 0;\n    modifier = 0;\n    formatPtr = currentChar + 1;\n    while( true ) {\n      currentChar = formatPtr + 1;\n      foundFlag = memchr(\"#-0+ \",(uint)*formatPtr,5);\n      if (foundFlag == (void *)0x0) break;\n      flags = 1 << ((int)foundFlag - 0x7bfcU & 0xff) | flags;\n      formatPtr = currentChar;\n    }\n    if ((int)(flags << 0x1b) < 0) {\n      decimalPoint = 0x20;\n    }\n    if ((int)(flags << 0x1c) < 0) {\n      decimalPoint = 0x2b;\n    }\n    if (*formatPtr == 0x2a) {\n      nextArg = argPtr + 1;\n      argWidth = *argPtr;\n      argPtr = nextArg;\n      if (argWidth < 0) {\n        argWidth = -argWidth;\n        flags = flags | 2;\n      }\n    }\n    else {\n      foundDecimal = false;\n      accumulator = argWidth;\n      currentChar = formatPtr;\n      while( true ) {\n        if (9 < *currentChar - 0x30) break;\n        accumulator = accumulator * 10 + (*currentChar - 0x30);\n        foundDecimal = true;\n        currentChar = currentChar + 1;\n      }\n      if (foundDecimal) {\n        argWidth = accumulator;\n      }\n    }\n    if (*currentChar == 0x2e) {\n      if (currentChar[1] == 0x2a) {\n        precision = *argPtr;\n        if (precision < 0) {\n          precision = -1;\n        }\n        currentChar = currentChar + 2;\n        argPtr = argPtr + 1;\n      }\n      else {\n        foundDecimal = false;\n        precision = 0;\n        accumulator = 0;\n        while( true ) {\n          currentChar = currentChar + 1;\n          if (9 < *currentChar - 0x30) break;\n          accumulator = accumulator * 10 + (*currentChar - 0x30);\n          foundDecimal = true;\n        }\n        if (foundDecimal) {\n          precision = accumulator;\n        }\n      }\n    }\n    foundFlag = memchr(&DAT_00007c02,(uint)*currentChar,3);\n    if (foundFlag != (void *)0x0) {\n      flags = flags | 0x40 << ((int)foundFlag - 0x7c02U & 0xff);\n      currentChar = currentChar + 1;\n    }\n    format = currentChar + 1;\n    specifier = *currentChar;\n    foundFlag = memchr(\"efgEFG\",(uint)specifier,6);\n    if (foundFlag == (void *)0x0) {\n      lockIndex = _printf_i(stream,&flags,args,0x57d3,&argPtr);\n      if (lockIndex == -1) goto LAB_00005a06;\n    }\n    else {\n      argPtr = (int *)(((int)argPtr + 7U & 0xfffffff8) + 8);\n    }\n    outputLength = outputLength + lockIndex;\n    formatPtr = format;\n  }\n  goto LAB_0000588e;\n}\n\n",
            "renaming": {
                "FUN_000057f8": "format_string_000057f8",
                "param_1": "stream",
                "param_2": "args",
                "param_3": "format",
                "param_4": "outputBytes",
                "bVar1": "foundDecimal",
                "iVar2": "accumulator",
                "iVar3": "result",
                "pvVar4": "foundFlag",
                "piVar5": "nextArg",
                "pbVar6": "currentChar",
                "pbVar7": "formatPtr",
                "unaff_r7": "lockIndex",
                "local_8c": "argPtr",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "width",
                "local_7c": "argWidth",
                "local_74": "outputLength",
                "local_70": "specifier",
                "local_6f": "flagSpace",
                "local_6e": "flagPlus",
                "local_45": "decimalPoint",
                "local_30": "modifier"
            },
            "calling": [
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sfputs_r",
                "__retarget_lock_release_recursive",
                "memchr",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005a58": {
            "entrypoint": "0x00005a58",
            "current_name": "calculate_length_00005a58",
            "code": "\nundefined4\ncalculateLength_00005a58(undefined4 input,uint *array,uint *length,undefined4 param,code *callback)\n\n{\n  int loopIndex;\n  undefined4 returnValue;\n  int callbackResult;\n  uint maxValue;\n  uint count;\n  bool hasFlag;\n  \n  maxValue = array[4];\n  if ((int)array[4] < (int)array[2]) {\n    maxValue = array[2];\n  }\n  *length = maxValue;\n  if (*(char *)((int)array + 0x43) != '\\0') {\n    *length = maxValue + 1;\n  }\n  if ((int)(*array << 0x1a) < 0) {\n    *length = *length + 2;\n  }\n  if ((*array & 6) == 0) {\n    for (loopIndex = 0; loopIndex < (int)(array[3] - *length); loopIndex = loopIndex + 1) {\n      callbackResult = (*callback)(input,param,(int)array + 0x19,1);\n      if (callbackResult == -1) goto LAB_00005afc;\n    }\n  }\n  maxValue = (uint)*(byte *)((int)array + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  if ((int)(*array << 0x1a) < 0) {\n    *(undefined *)((int)array + maxValue + 0x43) = 0x30;\n    *(undefined *)((int)array + maxValue + 0x44) = *(undefined *)((int)array + 0x45);\n    maxValue = maxValue + 2;\n  }\n  loopIndex = (*callback)(input,param,(int)array + 0x43,maxValue);\n  if (loopIndex == -1) {\nLAB_00005afc:\n    returnValue = 0xffffffff;\n  }\n  else {\n    maxValue = array[3];\n    hasFlag = (*array & 6) == 4;\n    if (hasFlag) {\n      maxValue = maxValue - *length;\n    }\n    if (hasFlag) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    else {\n      maxValue = 0;\n    }\n    if ((int)array[4] < (int)array[2]) {\n      maxValue = maxValue + (array[2] - array[4]);\n    }\n    for (count = 0; maxValue != count; count = count + 1) {\n      loopIndex = (*callback)(input,param,(int)array + 0x1a,1);\n      if (loopIndex == -1) goto LAB_00005afc;\n    }\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00005a58": "calculate_length_00005a58",
                "param_1": "input",
                "param_2": "array",
                "param_3": "length",
                "param_4": "param",
                "param_5": "callback",
                "iVar1": "loopIndex",
                "uVar2": "returnValue",
                "iVar3": "callbackResult",
                "uVar4": "maxValue",
                "uVar5": "count",
                "bVar6": "hasFlag"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005b34": {
            "entrypoint": "0x00005b34",
            "current_name": "print_formatted_value_00005b34",
            "code": "\ncode * printFormattedValue_00005b34(undefined4 format,uint *value,undefined4 width,code *functionPtr,uint **inputPtr\n                   )\n\n{\n  bool isGreaterThanZero;\n  byte byteValue;\n  int result;\n  code *outputPtr;\n  char *hexDigits;\n  void *memPtr;\n  int printfResult;\n  char *formatPtr;\n  uint valueCopy;\n  uint *inputValuePtr;\n  uint base;\n  uint **nestedInputPtr;\n  char **ppcVar12;\n  uint formatLength;\n  char *currentFormatChar;\n  uint *valuePtr;\n  undefined4 formatFlags;\n  code *outputFunctionPtr;\n  \n  byteValue = *(byte *)(value + 6);\n  formatPtr = (char *)((int)value + 0x43);\n  valuePtr = value;\n  formatFlags = width;\n  outputFunctionPtr = functionPtr;\n  if (0x78 < byteValue) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)value + 0x42) = byteValue;\nLAB_00005bdc:\n    formatPtr = (char *)((int)value + 0x42);\n    valueCopy = 1;\nLAB_00005d28:\n    value[4] = valueCopy;\n    *(undefined *)((int)value + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (byteValue < 99) {\n    if (byteValue == 0) goto LAB_00005d06;\n    if (byteValue == 0x58) {\n      hexDigits = \"0123456789ABCDEF\";\n      *(undefined *)((int)value + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(byteValue) {\n  case 99:\n    valueCopy = **inputPtr;\n    *inputPtr = *inputPtr + 1;\n    *(char *)((int)value + 0x42) = (char)valueCopy;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *value;\n    inputValuePtr = *inputPtr;\n    if ((int)(base << 0x18) < 0) {\n      valueCopy = *inputValuePtr;\n      *inputPtr = inputValuePtr + 1;\n    }\n    else {\n      valueCopy = *inputValuePtr;\n      *inputPtr = inputValuePtr + 1;\n      if ((base & 0x40) != 0) {\n        valueCopy = (uint)(short)valueCopy;\n      }\n    }\n    if ((int)valueCopy < 0) {\n      valueCopy = -valueCopy;\n      *(undefined *)((int)value + 0x43) = 0x2d;\n    }\n    hexDigits = \"0123456789ABCDEF\";\n    base = 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    nestedInputPtr = (uint **)*inputPtr;\n    base = *value;\n    valueCopy = value[5];\n    *inputPtr = (uint *)(nestedInputPtr + 1);\n    inputValuePtr = *nestedInputPtr;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *inputValuePtr = valueCopy;\n    }\n    else {\n      *(short *)inputValuePtr = (short)valueCopy;\n    }\nLAB_00005d06:\n    value[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    inputValuePtr = *inputPtr;\n    valueCopy = *value;\n    *inputPtr = inputValuePtr + 1;\n    if (((int)(valueCopy << 0x18) < 0) || (-1 < (int)(valueCopy << 0x19))) {\n      valueCopy = *inputValuePtr;\n    }\n    else {\n      valueCopy = (uint)*(ushort *)inputValuePtr;\n    }\n    hexDigits = \"0123456789ABCDEF\";\n    if (byteValue == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *value = *value | 0x20;\n  case 0x78:\n    hexDigits = \"0123456789abcdef\";\n    *(undefined *)((int)value + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *value;\n    valueCopy = **inputPtr;\n    *inputPtr = *inputPtr + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      valueCopy = valueCopy & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *value = base | 0x20;\n    }\n    if (valueCopy == 0) {\n      *value = *value & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    ppcVar12 = (char **)*inputPtr;\n    *inputPtr = (uint *)(ppcVar12 + 1);\n    formatPtr = *ppcVar12;\n    memPtr = memchr(formatPtr,0,value[1]);\n    if (memPtr != (void *)0x0) {\n      value[1] = (int)memPtr - (int)formatPtr;\n    }\n    valueCopy = value[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)value + 0x43) = 0;\nLAB_00005c36:\n  formatLength = value[1];\n  value[2] = formatLength;\n  if (-1 < (int)formatLength) {\n    *value = *value & 0xfffffffb;\n  }\n  currentFormatChar = formatPtr;\n  if ((valueCopy != 0) || (formatLength != 0)) {\n    do {\n      currentFormatChar = currentFormatChar + -1;\n      *currentFormatChar = hexDigits[valueCopy - base * (valueCopy / base)];\n      isGreaterThanZero = base <= valueCopy;\n      valueCopy = valueCopy / base;\n    } while (isGreaterThanZero);\n  }\n  if (((base == 8) && ((int)(*value << 0x1f) < 0)) && ((int)value[1] <= (int)value[4])) {\n    currentFormatChar[-1] = '0';\n    currentFormatChar = currentFormatChar + -1;\n  }\n  value[4] = (int)formatPtr - (int)currentFormatChar;\n  formatPtr = currentFormatChar;\nLAB_00005c84:\n  result = _printf_common(format,value,&outputFunctionPtr,width,functionPtr,valuePtr,formatFlags);\n  if ((result == -1) || (result = (*functionPtr)(format,width,formatPtr,value[4]), result == -1)) {\nLAB_00005c98:\n    outputPtr = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*value << 0x1e) < 0) {\n      for (result = 0; result < (int)(value[3] - (int)outputFunctionPtr); result = result + 1) {\n        printfResult = (*functionPtr)(format,width,(int)value + 0x19,1);\n        if (printfResult == -1) goto LAB_00005c98;\n      }\n    }\n    outputPtr = (code *)value[3];\n    if ((int)(code *)value[3] < (int)outputFunctionPtr) {\n      outputPtr = outputFunctionPtr;\n    }\n  }\n  return outputPtr;\n}\n\n",
            "renaming": {
                "FUN_00005b34": "print_formatted_value_00005b34",
                "param_1": "format",
                "param_2": "value",
                "param_3": "width",
                "param_4": "functionPtr",
                "param_5": "inputPtr",
                "bVar1": "isGreaterThanZero",
                "bVar2": "byteValue",
                "iVar3": "result",
                "pcVar4": "outputPtr",
                "pcVar5": "hexDigits",
                "pvVar6": "memPtr",
                "iVar7": "printfResult",
                "__s": "formatPtr",
                "uVar8": "valueCopy",
                "puVar9": "inputValuePtr",
                "uVar10": "base",
                "uVar13": "formatLength",
                "pcVar14": "currentFormatChar",
                "puVar15": "valuePtr",
                "uVar16": "formatFlags",
                "local_24": "outputFunctionPtr",
                "ppuVar11": "nestedInputPtr"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005d80": {
            "entrypoint": "0x00005d80",
            "current_name": "write_byte_to_stream_00005d80",
            "code": "\nuint write_byte_to_stream_00005d80(int stream,uint byte,undefined4 *stream_ptr)\n\n{\n  int remaining_bytes;\n  undefined *buffer_ptr;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_ptr == &__sf_fake_stdin) {\n    stream_ptr = *(undefined4 **)(stream + 4);\n  }\n  else if (stream_ptr == (undefined4 *)&__sf_fake_stdout) {\n    stream_ptr = *(undefined4 **)(stream + 8);\n  }\n  else if (stream_ptr == (undefined4 *)&__sf_fake_stderr) {\n    stream_ptr = *(undefined4 **)(stream + 0xc);\n  }\n  if ((-1 < (int)(stream_ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream_ptr[0x16]);\n  }\n  remaining_bytes = stream_ptr[2] + -1;\n  stream_ptr[2] = remaining_bytes;\n  if ((remaining_bytes < 0) && ((remaining_bytes < (int)stream_ptr[6] || ((byte & 0xff) == 10)))) {\n    byte = __swbuf_r(stream,byte,stream_ptr);\n  }\n  else {\n    buffer_ptr = (undefined *)*stream_ptr;\n    *stream_ptr = buffer_ptr + 1;\n    *buffer_ptr = (char)byte;\n    byte = byte & 0xff;\n  }\n  if ((-1 < (int)(stream_ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream_ptr[0x16]);\n  }\n  return byte;\n}\n\n",
            "renaming": {
                "FUN_00005d80": "write_byte_to_stream_00005d80",
                "param_1": "stream",
                "param_2": "byte",
                "param_3": "stream_ptr",
                "iVar1": "remaining_bytes",
                "puVar2": "buffer_ptr"
            },
            "calling": [
                "putchar"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e10": {
            "entrypoint": "0x00005e10",
            "current_name": "read_byte_from_stream_00005e10",
            "code": "\nuint readByteFromStream_00005e10(int stream,byte **streamPtr)\n\n{\n  int refillResult;\n  uint byteRead;\n  byte *bytePtr;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPtr == (byte **)&__sf_fake_stdin) {\n    streamPtr = *(byte ***)(stream + 4);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stdout) {\n    streamPtr = *(byte ***)(stream + 8);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stderr) {\n    streamPtr = *(byte ***)(stream + 0xc);\n  }\n  refillResult = __srefill_r(stream,streamPtr);\n  if (refillResult == 0) {\n    streamPtr[1] = streamPtr[1] + -1;\n    bytePtr = *streamPtr;\n    *streamPtr = bytePtr + 1;\n    byteRead = (uint)*bytePtr;\n  }\n  else {\n    byteRead = 0xffffffff;\n  }\n  return byteRead;\n}\n\n",
            "renaming": {
                "FUN_00005e10": "read_byte_from_stream_00005e10",
                "param_1": "stream",
                "param_2": "streamPtr",
                "iVar1": "refillResult",
                "uVar2": "byteRead",
                "pbVar3": "bytePtr"
            },
            "calling": [
                "_getc_r"
            ],
            "called": [
                "__sinit",
                "__srefill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e68": {
            "entrypoint": "0x00005e68",
            "current_name": "scan_format_string_00005e68",
            "code": "\nint scanFormatString_00005e68(char *stringToScan,char *formatString,...)\n\n{\n  int scanResult;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *stringPointer;\n  size_t stringLength;\n  undefined2 bufferSize;\n  undefined2 endOfStringMarker;\n  char *stringStart;\n  size_t remainingStringLength;\n  undefined4 unknown1;\n  undefined4 unknown2;\n  undefined4 unknown3;\n  undefined4 unknown4;\n  undefined4 unknown5;\n  \n  bufferSize = 0x204;\n  stringPointer = stringToScan;\n  stringStart = stringToScan;\n  unknown4 = in_r2;\n  unknown5 = in_r3;\n  stringLength = strlen(stringToScan);\n  unknown1 = 0x4deb;\n  unknown2 = 0;\n  unknown3 = 0;\n  endOfStringMarker = 0xffff;\n  remainingStringLength = stringLength;\n  scanResult = stringToScansvfiscanf_r(_impure_ptr,&stringPointer,formatString,&unknown4);\n  return scanResult;\n}\n\n",
            "renaming": {
                "FUN_00005e68": "scan_format_string_00005e68",
                "__s": "stringToScan",
                "__format": "formatString",
                "iVar1": "scanResult",
                "local_80": "stringPointer",
                "local_7c": "stringLength",
                "local_74": "bufferSize",
                "local_72": "endOfStringMarker",
                "local_70": "stringStart",
                "local_6c": "remainingStringLength",
                "local_5c": "unknown1",
                "local_4c": "unknown2",
                "local_38": "unknown3",
                "uStack_8": "unknown4",
                "uStack_4": "unknown5"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ebc": {
            "entrypoint": "0x00005ebc",
            "current_name": "copy_string_00005ebc",
            "code": "\nchar * copyString_00005ebc(char *destination,char *source)\n\n{\n  char currentChar;\n  char *destinationPtr;\n  \n  destinationPtr = destination;\n  do {\n    currentChar = *source;\n    *destinationPtr = currentChar;\n    source = source + 1;\n    destinationPtr = destinationPtr + 1;\n  } while (currentChar != '\\0');\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentChar",
                "pcVar2": "destinationPtr"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ecc": {
            "entrypoint": "0x00005ecc",
            "current_name": "calculate_string_length_00005ecc",
            "code": "\nsize_t calculateStringLength_00005ecc(char *str)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = str;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_00005ecc": "calculate_string_length_00005ecc",
                "__s": "str",
                "pcVar2": "nextCharPointer",
                "cVar1": "currentChar",
                "pcVar3": "currentCharPointer"
            },
            "calling": [
                "siscanf",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005edc": {
            "entrypoint": "0x00005edc",
            "current_name": "parse_integer_from_byte_array_00005edc",
            "code": "\nuint parseIntegerFromByteArray_00005edc(undefined4 *outputInteger,byte *byteArray,byte **nextBytePointer,uint base)\n\n{\n  uint parsedInteger;\n  uint currentByte;\n  byte isNegative;\n  int resultStatus;\n  uint digitValue;\n  uint maxIntegerDivBase;\n  byte *bytePointer;\n  byte *nextByte;\n  \n  nextByte = byteArray;\n  do {\n    bytePointer = nextByte;\n    nextByte = bytePointer + 1;\n    currentByte = (uint)*bytePointer;\n    isNegative = (&DAT_00007a99)[currentByte] & 8;\n  } while (((&DAT_00007a99)[currentByte] & 8) != 0);\n  if (currentByte == 0x2d) {\n    currentByte = (uint)*nextByte;\n    isNegative = 1;\n    nextByte = bytePointer + 2;\n  }\n  else if (currentByte == 0x2b) {\n    currentByte = (uint)*nextByte;\n    nextByte = bytePointer + 2;\n  }\n  if (base == 0) {\n    if (currentByte != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((base != 0x10) || (currentByte != 0x30)) goto LAB_00005f26;\n  if ((*nextByte & 0xdf) == 0x58) {\n    currentByte = (uint)nextByte[1];\n    base = 0x10;\n    nextByte = nextByte + 2;\n  }\n  else {\n    currentByte = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  resultStatus = 0;\n  maxIntegerDivBase = 0xffffffff / base;\n  parsedInteger = 0;\n  do {\n    digitValue = currentByte - 0x30;\n    if (9 < digitValue) {\n      if (currentByte - 0x41 < 0x1a) {\n        digitValue = currentByte - 0x37;\n      }\n      else {\n        if (0x19 < currentByte - 0x61) break;\n        digitValue = currentByte - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (((resultStatus < 0) || (maxIntegerDivBase < parsedInteger)) ||\n       ((maxIntegerDivBase == parsedInteger && ((int)~(base * maxIntegerDivBase) < (int)digitValue)))) {\n      resultStatus = -1;\n    }\n    else {\n      parsedInteger = parsedInteger * base + digitValue;\n      resultStatus = 1;\n    }\n    currentByte = (uint)*nextByte;\n    nextByte = nextByte + 1;\n  } while( true );\n  if (resultStatus < 0) {\n    *outputInteger = 0x22;\n    parsedInteger = 0xffffffff;\n    if (nextBytePointer == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      parsedInteger = -parsedInteger;\n    }\n    if (nextBytePointer == (byte **)0x0) {\n      return parsedInteger;\n    }\n    if (resultStatus == 0) goto LAB_00005fb8;\n  }\n  byteArray = nextByte + -1;\nLAB_00005fb8:\n  *nextBytePointer = byteArray;\n  return parsedInteger;\n}\n\n",
            "renaming": {
                "FUN_00005edc": "parse_integer_from_byte_array_00005edc",
                "param_1": "outputInteger",
                "param_2": "byteArray",
                "param_3": "nextBytePointer",
                "param_4": "base",
                "uVar1": "parsedInteger",
                "uVar2": "currentByte",
                "bVar3": "isNegative",
                "iVar4": "resultStatus",
                "uVar5": "digitValue",
                "uVar6": "maxIntegerDivBase",
                "pbVar7": "bytePointer",
                "pbVar8": "nextByte"
            },
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd4": {
            "entrypoint": "0x00005fd4",
            "current_name": "FUN_00005fd4",
            "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = (&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd8": {
            "entrypoint": "0x00005fd8",
            "current_name": "parse_unsigned_long_00005fd8",
            "code": "\nulong parseUnsignedLong_00005fd8(char *inputString,char **endPointer,int base)\n\n{\n  ulong result;\n  \n  result = _strtoul_l_isra_0(_impure_ptr,inputString,endPointer,base);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005fd8": "parse_unsigned_long_00005fd8",
                "__nptr": "inputString",
                "__endptr": "endPointer",
                "__base": "base",
                "uVar1": "result"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fec": {
            "entrypoint": "0x00005fec",
            "current_name": "acquire_recursive_lock_00005fec",
            "code": "\nvoid acquireRecursiveLock_00005fec(void)\n\n{\n  lockAcquireRecursive(&recursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "__retarget_lock_acquire_recursive": "lockAcquireRecursive",
                "&__lock___env_recursive_mutex": "&recursiveMutex"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ff8": {
            "entrypoint": "0x00005ff8",
            "current_name": "release_recursive_lock_00005ff8",
            "code": "\nvoid releaseRecursiveLock_00005ff8(void)\n\n{\n  releaseLock(recursiveMutexLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ff8": "release_recursive_lock_00005ff8",
                "__retarget_lock_release_recursive": "releaseLock",
                "&__lock___env_recursive_mutex": "recursiveMutexLock"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006010": {
            "entrypoint": "0x00006010",
            "current_name": "find_byte_sequence_00006010",
            "code": "\nvoid * find_byte_sequence_00006010(void *input_array,int byte_to_find,size_t array_size)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  byte *pbVar6;\n  uint *puVar7;\n  byte *pbVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  bool bVar17;\n  \n  uVar9 = byte_to_find & 0xff;\n  if ((int)array_size < 0x10) {\njoined_r0x00006070:\n    do {\n      if (array_size == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 = (uint *)((int)input_array + 1);\n      bVar1 = *input_array;\n      array_size = array_size - 1;\n      input_array = puVar7;\n    } while (bVar1 != uVar9);\n  }\n  else {\n    uVar10 = (uint)input_array & 7;\n    while( true ) {\n      if (uVar10 == 0) {\n        uVar10 = uVar9 | uVar9 << 8;\n        uVar10 = uVar10 | uVar10 << 0x10;\n        uVar11 = array_size & 0xfffffff8;\n        do {\n          puVar7 = (uint *)((int)input_array + 8);\n                    /* WARNING: Load size is inaccurate */\n          uVar11 = uVar11 - 8;\n          uVar12 = *input_array ^ uVar10;\n          uVar13 = *(uint *)((int)input_array + 4) ^ uVar10;\n          cVar2 = -((char)uVar12 == '\\0');\n          cVar3 = -((char)(uVar12 >> 8) == '\\0');\n          cVar4 = -((char)(uVar12 >> 0x10) == '\\0');\n          cVar5 = -((char)(uVar12 >> 0x18) == '\\0');\n          uVar12 = CONCAT13(cVar5,CONCAT12(cVar4,CONCAT11(cVar3,cVar2)));\n          bVar14 = (char)uVar13 != '\\0';\n          bVar15 = (char)(uVar13 >> 8) != '\\0';\n          bVar16 = (char)(uVar13 >> 0x10) != '\\0';\n          bVar17 = (char)(uVar13 >> 0x18) != '\\0';\n          uVar13 = CONCAT13(bVar17 * cVar5 - !bVar17,\n                            CONCAT12(bVar16 * cVar4 - !bVar16,\n                                     CONCAT11(bVar15 * cVar3 - !bVar15,bVar14 * cVar2 - !bVar14)));\n          if (uVar13 != 0) {\n            if (uVar12 == 0) {\n              pbVar8 = (byte *)((int)input_array + 5);\n              uVar12 = uVar13;\n            }\n            else {\n              pbVar8 = (byte *)((int)input_array + 1);\n            }\n            if ((uVar12 & 1) == 0) {\n              bVar14 = (uVar12 & 0x100) == 0;\n              pbVar6 = pbVar8 + 1;\n              if (bVar14) {\n                bVar14 = (uVar12 & 0x18000) == 0;\n                pbVar6 = pbVar8 + 2;\n              }\n              pbVar8 = pbVar6;\n              if (bVar14) {\n                pbVar8 = pbVar8 + 1;\n              }\n            }\n            return pbVar8 + -1;\n          }\n          input_array = puVar7;\n        } while (uVar11 != 0);\n        array_size = array_size & 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 = (uint *)((int)input_array + 1);\n      array_size = array_size - 1;\n      if (*input_array == uVar9) break;\n      uVar10 = (uint)puVar7 & 7;\n      input_array = puVar7;\n      if (array_size == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)puVar7 + -1);\n}\n\n",
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "__s": "input_array",
                "__c": "byte_to_find",
                "__n": "array_size"
            },
            "calling": [
                "_printf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060b0": {
            "entrypoint": "0x000060b0",
            "current_name": "mem_copy_000060b0",
            "code": "\nvoid * mem_copy_000060b0(void *destination,void *source,size_t size)\n\n{\n  undefined *src_pointer;\n  undefined *end_pointer;\n  undefined *dest_pointer;\n  \n  end_pointer = (undefined *)(size + (int)source);\n  dest_pointer = (undefined *)((int)destination + -1);\n  if ((undefined *)source != end_pointer) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      src_pointer = (undefined *)((int)source + 1);\n      dest_pointer = dest_pointer + 1;\n      *dest_pointer = *source;\n      source = src_pointer;\n    } while (src_pointer != end_pointer);\n    return destination;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000060b0": "mem_copy_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "src_pointer",
                "puVar2": "end_pointer",
                "puVar3": "dest_pointer"
            },
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060cc": {
            "entrypoint": "0x000060cc",
            "current_name": "allocate_and_copy_memory_000060cc",
            "code": "\nvoid * allocate_and_copy_memory_000060cc(undefined4 context,void *source,uint size,undefined4 extra_param)\n\n{\n  void *allocated_memory;\n  uint usable_size;\n  \n  if (source != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      allocated_memory = (void *)0x0;\n    }\n    else {\n      usable_size = _malloc_usable_size_r();\n      allocated_memory = source;\n      if ((usable_size < size) && (allocated_memory = (void *)_malloc_r(context,size), allocated_memory != (void *)0x0))\n      {\n        memcpy(allocated_memory,source,size);\n        _free_r(context,source);\n      }\n    }\n    return allocated_memory;\n  }\n  allocated_memory = (void *)_malloc_r(context,size,size,extra_param);\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_000060cc": "allocate_and_copy_memory_000060cc",
                "param_1": "context",
                "param_2": "source",
                "param_3": "size",
                "param_4": "extra_param",
                "pvVar1": "allocated_memory",
                "uVar2": "usable_size"
            },
            "calling": [
                "__submore"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006118": {
            "entrypoint": "0x00006118",
            "current_name": "reverse_and_increment_00006118",
            "code": "\nuint reverseAndIncrement_00006118(undefined4 input1,uint input2,uint *data,undefined4 input3)\n\n{\n  int result;\n  uint temp1;\n  uint temp2;\n  \n  if (input2 == 0xffffffff) {\nLAB_00006120:\n    input2 = 0xffffffff;\n  }\n  else {\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xffdf;\n    temp1 = data[1];\n    input2 = input2 & 0xff;\n    if (data[0xd] == 0) {\n      temp2 = *data;\n      if (((data[4] != 0) && (data[4] < temp2)) && (*(byte *)(temp2 - 1) == input2)) {\n        *data = temp2 - 1;\n        data[1] = temp1 + 1;\n        return input2;\n      }\n      data[0xf] = temp2;\n      data[0x10] = temp1;\n      data[0xd] = (uint)(data + 0x11);\n      data[0xe] = 3;\n      *(undefined *)((int)data + 0x46) = (char)input2;\n      *data = (uint)(undefined *)((int)data + 0x46);\n      temp1 = 1;\n    }\n    else {\n      if (((int)data[0xe] <= (int)temp1) &&\n         (result = __submore(input1,data,temp1,data[0xe],input3), result != 0))\n      goto LAB_00006120;\n      temp1 = *data;\n      *data = temp1 - 1;\n      *(char *)(temp1 - 1) = (char)input2;\n      temp1 = data[1] + 1;\n    }\n    data[1] = temp1;\n  }\n  return input2;\n}\n\n",
            "renaming": {
                "FUN_00006118": "reverse_and_increment_00006118",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "data",
                "param_4": "input3",
                "iVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2"
            },
            "calling": [],
            "called": [
                "__submore"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006192": {
            "entrypoint": "0x00006192",
            "current_name": "cleanup_function_00006192",
            "code": "\nundefined4 cleanupFunction_00006192(undefined4 result,undefined4 *params)\n\n{\n  if ((undefined4 *)params[0xd] != (undefined4 *)0x0) {\n    if ((undefined4 *)params[0xd] != params + 0x11) {\n      _free_r();\n    }\n    params[1] = params[0x10];\n    params[0xd] = 0;\n    if (params[0x10] != 0) {\n      *params = params[0xf];\n      return 0;\n    }\n  }\n  *params = params[4];\n  params[1] = 0;\n  *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006192": "cleanup_function_00006192",
                "param_1": "result",
                "param_2": "params",
                "param_2[0xd]": "params[0xd]",
                "param_2[1]": "params[1]",
                "param_2[0x10]": "params[0x10]",
                "param_2[4]": "params[4]"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000061cc": {
            "entrypoint": "0x000061cc",
            "current_name": "parse_input_000061cc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint parseInput_000061cc(undefined4 param,byte **inputPtr,byte *formatPtr,int **outputPtr)\n\n{\n  int result;\n  void *ptr;\n  uint charCode;\n  byte *nextChar;\n  uint currentChar;\n  int **outputBuffer;\n  undefined characterClass [256];\n  uint flags;\n  undefined4 base;\n  uint type;\n  int count;\n  int length;\n  undefined *tempBuffer;\n  int readerState;\n  undefined4 refillFlag;\n  code *refillFunction;\n  \n  count = 0;\n  length = 0;\n  refillFlag = 0x6119;\n  refillFunction = __ssrefill_r + 1;\n  outputBuffer = outputPtr;\n  tempBuffer = characterClass;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      currentChar = (uint)*formatPtr;\n      if (currentChar == 0) {\n        return count;\n      }\n      charCode = (byte)(&DAT_00007a99)[currentChar] & 8;\n      nextChar = formatPtr + 1;\n      if (((&DAT_00007a99)[currentChar] & 8) == 0) break;\n      while (((formatPtr = nextChar, 0 < (int)inputPtr[1] ||\n              (result = (*refillFunction)(param,inputPtr), result == 0)) &&\n             ((int)((uint)(byte)(&DAT_00007a99)[**inputPtr] << 0x1c) < 0))) {\n        length = length + 1;\n        inputPtr[1] = inputPtr[1] + -1;\n        *inputPtr = *inputPtr + 1;\n      }\n    }\n    if (currentChar == 0x25) break;\nLAB_00006352:\n    if (((int)inputPtr[1] < 1) && (result = (*refillFunction)(param,inputPtr), result != 0))\n    goto LAB_00006380;\n    if (**inputPtr != currentChar) {\n      return count;\n    }\n    *inputPtr = *inputPtr + 1;\n    length = length + 1;\n    inputPtr[1] = inputPtr[1] + -1;\n    formatPtr = nextChar;\n  }\n  type = charCode;\n  flags = charCode;\n  if (formatPtr[1] == 0x2a) {\n    nextChar = formatPtr + 2;\n    flags = 0x10;\n  }\n  while( true ) {\n    charCode = (uint)*nextChar;\n    if (9 < charCode - 0x30) break;\n    nextChar = nextChar + 1;\n    type = (type * 10 + charCode) - 0x30;\n  }\n  ptr = memchr(&DAT_00007c02,charCode,3);\n  if (ptr != (void *)0x0) {\n    flags = 1 << ((int)ptr - 0x7c02U & 0xff) | flags;\n    nextChar = nextChar + 1;\n  }\n  formatPtr = nextChar + 1;\n  charCode = (uint)*nextChar;\n  if (charCode < 0x79) {\n    if (0x57 < charCode) {\n      switch(charCode) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        formatPtr = (byte *)__sccl(characterClass,formatPtr);\n        flags = flags | 0x40;\n        readerState = 1;\n        break;\n      case 99:\n        flags = flags | 0x40;\n        readerState = 0;\n        break;\n      case 100:\n      case 0x75:\n        base = 10;\nLAB_000063a0:\n        if (charCode < 0x6f) {\n          readerState = 3;\n        }\n        else {\n          readerState = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        readerState = 5;\n        break;\n      case 0x69:\n        base = 0;\n        readerState = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(flags << 0x1b)) {\n          if ((int)(flags << 0x1f) < 0) {\n            *(short *)*outputBuffer = (short)length;\n            outputBuffer = outputBuffer + 1;\n          }\n          else {\n            **outputBuffer = length;\n            outputBuffer = outputBuffer + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        base = 8;\n        readerState = 4;\n        break;\n      case 0x70:\n        flags = flags | 0x20;\n      case 0x58:\n      case 0x78:\n        flags = flags | 0x200;\n        base = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        readerState = 2;\n      }\nLAB_000063ac:\n      if (((int)inputPtr[1] < 1) && (result = (*refillFunction)(param,inputPtr), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(flags << 0x19)) {\n        while ((int)((uint)(byte)(&DAT_00007a99)[**inputPtr] << 0x1c) < 0) {\n          length = length + 1;\n          nextChar = inputPtr[1];\n          inputPtr[1] = nextChar + -1;\n          if ((int)(nextChar + -1) < 1) {\n            result = (*refillFunction)(param,inputPtr);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *inputPtr = *inputPtr + 1;\n          }\n        }\n      }\n      if (readerState < 3) {\n        result = _scanf_chars(param,&flags,inputPtr,&outputBuffer);\n      }\n      else {\n        if (4 < readerState) goto LAB_000061f6;\n        result = _scanf_i(param,&flags,inputPtr,&outputBuffer);\n      }\n      if (result == 1) {\n        return count;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (count == 0) {\nLAB_00006388:\n          count = -1;\n        }\n        else if ((*(ushort *)(inputPtr + 3) & 0x40) != 0) {\n          count = -1;\n        }\n        return count;\n      }\n      goto LAB_000061f6;\n    }\n    nextChar = formatPtr;\n    if (charCode == 0x25) goto LAB_00006352;\n    if (charCode < 0x26) {\n      if (charCode != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (charCode - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  readerState = 3;\n  base = 10;\n  goto LAB_000063ac;\n}\n\n",
            "renaming": {
                "FUN_000061cc": "parse_input_000061cc",
                "param_1": "param",
                "param_2": "inputPtr",
                "param_3": "formatPtr",
                "param_4": "outputPtr",
                "iVar1": "result",
                "pvVar2": "ptr",
                "uVar3": "charCode",
                "pbVar4": "nextChar",
                "uVar5": "currentChar",
                "local_2b0": "outputBuffer",
                "auStack_2ac": "characterClass",
                "local_1ac": "flags",
                "local_1a8": "base",
                "local_1a4": "type",
                "local_1a0": "count",
                "local_19c": "length",
                "local_198": "tempBuffer",
                "local_194": "readerState",
                "local_30": "refillFlag",
                "local_2c": "refillFunction"
            },
            "calling": [
                "siscanf"
            ],
            "called": [
                "__sccl",
                "__ssrefill_r",
                "_scanf_chars",
                "_scanf_i",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000064bc": {
            "entrypoint": "0x000064bc",
            "current_name": "validate_and_process_data_000064bc",
            "code": "\nundefined4 validate_and_process_data_000064bc(undefined4 input_value,uint *parameters,byte **data_pointers,undefined4 *status)\n\n{\n  int result;\n  uint condition;\n  byte **pointer_to_byte;\n  byte *byte_pointer_temp;\n  byte *current_byte;\n  byte *next_byte;\n  int counter;\n  \n  if (parameters[2] == 0) {\n    if (parameters[6] == 0) {\n      condition = 1;\n    }\n    else {\n      condition = 0xffffffff;\n    }\n    parameters[2] = condition;\n  }\n  if (-1 < (int)(*parameters << 0x1b)) {\n    pointer_to_byte = (byte **)*status;\n    *status = pointer_to_byte + 1;\n    current_byte = *pointer_to_byte;\n  }\n  counter = 0;\n  do {\n    condition = parameters[6];\n    if (condition != 0) {\n      if (condition == 1) {\n        if (*(char *)(parameters[5] + (uint)**data_pointers) == '\\0') {\n          if (counter == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*parameters & 0x10) == 0) && (parameters[3] = parameters[3] + 1, parameters[6] != 0)) {\n            *current_byte = 0;\n          }\n          parameters[4] = counter + parameters[4];\n          return 0;\n        }\n      }\n      else if ((condition != 2) || ((int)((uint)(byte)(&DAT_00007a99)[**data_pointers] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    next_byte = current_byte;\n    if (-1 < (int)(*parameters << 0x1b)) {\n      next_byte = current_byte + 1;\n      *current_byte = **data_pointers;\n    }\n    byte_pointer_temp = data_pointers[1];\n    *data_pointers = *data_pointers + 1;\n    condition = parameters[2] - 1;\n    data_pointers[1] = byte_pointer_temp + -1;\n    counter = counter + 1;\n    parameters[2] = condition;\n    current_byte = next_byte;\n    if ((condition == 0) ||\n       (((int)(byte_pointer_temp + -1) < 1 &&\n        (result = (*(code *)parameters[0x60])(input_value,data_pointers,condition,(code *)parameters[0x60],status),\n        result != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000064bc": "validate_and_process_data_000064bc",
                "param_1": "input_value",
                "param_2": "parameters",
                "param_3": "data_pointers",
                "param_4": "status",
                "iVar1": "result",
                "uVar2": "condition",
                "ppbVar3": "pointer_to_byte",
                "pbVar4": "byte_pointer_temp",
                "unaff_r6": "current_byte",
                "pbVar5": "next_byte",
                "iVar6": "counter"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000656c": {
            "entrypoint": "0x0000656c",
            "current_name": "parse_data_0000656c",
            "code": "\nundefined4 parseData_0000656c(undefined4 data,uint *flags,byte **input,undefined4 *output)\n\n{\n  code *strToNumFunc;\n  void *ptr;\n  int result;\n  undefined4 value;\n  uint count;\n  byte *bytePtr;\n  uint length;\n  undefined4 *outputPtr;\n  uint *ptr1;\n  uint *ptr2;\n  uint *ptr3;\n  int offset;\n  int i;\n  undefined *strings [4];\n  \n  strings[0] = &DAT_00007c2f;\n  strings[1] = &DAT_00007c32;\n  strings[2] = &DAT_00007c35;\n  strToNumFunc = _strtol_r;\n  if (flags[6] != 3) {\n    strToNumFunc = _strtoul_r;\n  }\n  length = flags[2];\n  count = length - 1;\n  if (0x15c < count) {\n    offset = length - 0x15d;\n    length = 0x15d;\n  }\n  if (0x15c < count) {\n    flags[2] = length;\n  }\n  ptr3 = flags + 7;\n  if (count < 0x15d) {\n    offset = 0;\n  }\n  *flags = *flags | 0xd00;\n  i = 0;\n  ptr2 = ptr3;\n  do {\n    ptr = memchr(strings[i],(uint)**input,2);\n    if (ptr != (void *)0x0) {\n      if (i == 1) {\n        if (flags[1] == 0) {\n          flags[1] = 8;\n          *flags = *flags | 0x200;\n        }\n        count = *flags & 0xfffffaff;\nLAB_000065f4:\n        *flags = count;\n      }\n      else if (i == 2) {\n        if ((*flags & 0x600) != 0x200) goto LAB_00006624;\n        flags[1] = 0x10;\n        count = *flags | 0x100;\n        goto LAB_000065f4;\n      }\n      count = flags[2];\n      flags[2] = count - 1;\n      if (count != 0) {\n        bytePtr = *input;\n        *input = bytePtr + 1;\n        ptr1 = (uint *)((int)ptr2 + 1);\n        *(byte *)ptr2 = *bytePtr;\n        bytePtr = input[1];\n        input[1] = bytePtr + -1;\n        ptr2 = ptr1;\n        if (((int)(bytePtr + -1) < 1) &&\n           (result = (*(code *)flags[0x60])(data,input), result != 0)) {\n          i = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    i = i + 1;\n  } while (i != 3);\n  if (flags[1] == 0) {\n    flags[1] = 10;\n  }\n  __sccl(flags[5],\"01234567]\" + (8 - flags[1]));\n  i = 0;\n  while( true ) {\n    ptr1 = ptr2;\n    if (flags[2] == 0) break;\n    bytePtr = *input;\n    count = (uint)*bytePtr;\n    if (*(char *)(flags[5] + count) == '\\0') break;\n    if ((count == 0x30) && ((int)(*flags << 0x14) < 0)) {\n      i = i + 1;\n      if (offset != 0) {\n        offset = offset + -1;\n        flags[2] = flags[2] + 1;\n      }\n    }\n    else {\n      *flags = *flags & 0xfffff6ff;\n      ptr1 = (uint *)((int)ptr2 + 1);\n      *(byte *)ptr2 = *bytePtr;\n    }\n    bytePtr = input[1];\n    input[1] = bytePtr + -1;\n    if ((int)(bytePtr + -1) < 1) {\n      result = (*(code *)flags[0x60])(data,input);\n      if (result != 0) break;\n    }\n    else {\n      *input = *input + 1;\n    }\n    flags[2] = flags[2] - 1;\n    ptr2 = ptr1;\n  }\nLAB_000066ca:\n  if ((int)(*flags << 0x17) < 0) {\n    if (ptr3 < ptr1) {\n      (*(code *)flags[0x5f])(data,*(byte *)((int)ptr1 + -1),input);\n      ptr1 = (uint *)((int)ptr1 + -1);\n    }\n    if (ptr1 == ptr3) {\n      return 1;\n    }\n  }\n  if ((*flags & 0x10) == 0) {\n    *(byte *)ptr1 = 0;\n    value = (*(strToNumFunc + 1))(data,ptr3,0,flags[1]);\n    outputPtr = (undefined4 *)*output;\n    count = *flags;\n    *output = outputPtr + 1;\n    outputPtr = (undefined4 *)*outputPtr;\n    if ((count & 0x20) == 0) {\n      if ((int)(count << 0x1f) < 0) {\n        *(short *)outputPtr = (short)value;\n      }\n      else {\n        *outputPtr = value;\n      }\n    }\n    else {\n      *outputPtr = value;\n    }\n    flags[3] = flags[3] + 1;\n  }\n  flags[4] = (uint)((int)ptr1 + flags[4] + (i - (int)ptr3));\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000656c": "parse_data_0000656c",
                "param_1": "data",
                "param_2": "flags",
                "param_3": "input",
                "param_4": "output",
                "pcVar1": "strToNumFunc",
                "pvVar2": "ptr",
                "iVar3": "result",
                "uVar4": "value",
                "uVar5": "count",
                "pbVar6": "bytePtr",
                "uVar7": "length",
                "puVar8": "outputPtr",
                "puVar9": "ptr1",
                "puVar10": "ptr2",
                "puVar11": "ptr3",
                "unaff_r9": "offset",
                "iVar12": "i",
                "local_34": "strings"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "__sccl",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006754": {
            "entrypoint": "0x00006754",
            "current_name": "flush_file_if_read_and_write_00006754",
            "code": "\nint flushFileIfReadAndWrite_00006754(FILE *file)\n\n{\n  int result;\n  \n  if ((*(ushort *)&file->_IO_read_base & 9) == 9) {\n    result = fflush(file);\n    return result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00006754": "flush_file_if_read_and_write_00006754",
                "param_1": "file",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006768": {
            "entrypoint": "0x00006768",
            "current_name": "process_stream_00006768",
            "code": "\nundefined4\nprocessStream_00006768(undefined4 *param,undefined4 *stream,undefined4 value1,undefined4 value2)\n\n{\n  undefined2 var1;\n  int var2;\n  undefined4 var3;\n  ushort var4;\n  uint var5;\n  \n  if ((param != (undefined4 *)0x0) && (param[6] == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = (undefined4 *)param[1];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = (undefined4 *)param[2];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = (undefined4 *)param[3];\n  }\n  var4 = *(ushort *)(stream + 3);\n  stream[1] = 0;\n  var5 = (uint)*(ushort *)(stream + 3);\n  if ((int)(var5 << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(var5 << 0x1d) < 0) {\n    if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)stream[0xd] != stream + 0x11) {\n        _free_r(param);\n      }\n      stream[1] = stream[0x10];\n      stream[0xd] = 0;\n      if (stream[0x10] != 0) {\n        *stream = stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(var5 << 0x1b)) {\n      *param = 9;\n      var4 = var4 | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(var5 << 0x1c) < 0) {\n      var2 = _fflush_r(param,stream,var5 << 0x1c,var5,value2);\n      if (var2 != 0) {\n        return 0xffffffff;\n      }\n      stream[2] = 0;\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n      stream[6] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n  }\n  if (stream[4] == 0) {\n    __smakebuf_r(param,stream);\n  }\n  var4 = *(ushort *)(stream + 3);\n  var1 = *(undefined2 *)(stream + 3);\n  if ((var4 & 3) != 0) {\n    *(undefined2 *)(stream + 3) = 1;\n    _fwalk(&impure_data,0x6755);\n    *(undefined2 *)(stream + 3) = var1;\n    if ((var4 & 9) == 9) {\n      __sflush_r(param,stream);\n    }\n  }\n  var3 = stream[4];\n  *stream = var3;\n  var2 = (*(code *)stream[9])(param,stream[8],var3,stream[5]);\n  stream[1] = var2;\n  if (0 < var2) {\n    return 0;\n  }\n  var4 = *(ushort *)(stream + 3);\n  if (var2 != 0) {\n    var3 = 0;\n  }\n  else {\n    var4 = var4 | 0x20;\n  }\n  if (var2 != 0) {\n    stream[1] = var3;\n    var4 = var4 | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(stream + 3) = var4;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006768": "process_stream_00006768",
                "param_1": "param",
                "param_2": "stream",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "var1",
                "iVar2": "var2",
                "uVar3": "var3",
                "uVar4": "var4",
                "uVar5": "var5"
            },
            "calling": [
                "__srget_r"
            ],
            "called": [
                "_fflush_r",
                "__sinit",
                "__smakebuf_r",
                "_fwalk",
                "__sflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000687c": {
            "entrypoint": "0x0000687c",
            "current_name": "decode_binary_0000687c",
            "code": "\nbyte * decode_binary_0000687c(int output_size,byte *input_data)\n\n{\n  byte *result;\n  uint temp1;\n  int index;\n  uint current_byte;\n  uint temp2;\n  uint temp3;\n  bool is_header;\n  \n  current_byte = (uint)*input_data;\n  is_header = current_byte == 0x5e;\n  if (is_header) {\n    current_byte = (uint)input_data[1];\n    input_data = input_data + 2;\n  }\n  else {\n    input_data = input_data + 1;\n  }\n  index = output_size + -1;\n  do {\n    index = index + 1;\n    *(bool *)index = is_header;\n  } while (index != output_size + 0xff);\n  if (current_byte == 0) {\n    result = input_data + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      temp2 = current_byte;\n      *(bool *)(output_size + temp2) = !is_header;\n      input_data = input_data + 1;\n      while( true ) {\n        current_byte = (uint)input_data[-1];\n        if (current_byte != 0x2d) break;\n        temp3 = (uint)*input_data;\n        if ((temp3 == 0x5d) || (temp1 = temp2, (int)temp3 < (int)temp2)) goto LAB_000068aa;\n        do {\n          temp1 = temp1 + 1;\n          *(bool *)(output_size + temp1) = !is_header;\n        } while ((int)temp1 < (int)temp3);\n        index = ~temp2 + temp3;\n        if ((int)temp3 <= (int)temp2) {\n          index = 0;\n        }\n        temp2 = temp2 + 1 + index;\n        input_data = input_data + 2;\n      }\n      result = input_data;\n    } while ((current_byte != 0x5d) && (result = input_data + -1, current_byte != 0));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000687c": "decode_binary_0000687c",
                "param_1": "output_size",
                "param_2": "input_data",
                "pbVar1": "result",
                "uVar2": "temp1",
                "iVar3": "index",
                "uVar4": "current_byte",
                "uVar5": "temp2",
                "uVar6": "temp3",
                "bVar7": "is_header"
            },
            "calling": [
                "__ssvfiscanf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000068f0": {
            "entrypoint": "0x000068f0",
            "current_name": "initialize_flash_configuration_000068f0",
            "code": "\nundefined4 initializeFlashConfiguration_000068f0(undefined4 size,void **configData)\n\n{\n  void *buffer;\n  void *configSize;\n  \n  if ((void **)configData[0xd] == configData + 0x11) {\n    buffer = (void *)_malloc_r(size,0x400);\n    if (buffer != (void *)0x0) {\n      configData[0xe] = flash_configuration_field;\n      configData[0xd] = buffer;\n      *(undefined *)((int)buffer + 0x3ff) = *(undefined *)((int)configData + 0x46);\n      *(undefined *)((int)buffer + 0x3fe) = *(undefined *)((int)configData + 0x45);\n      *(undefined *)((int)buffer + 0x3fd) = *(undefined *)(configData + 0x11);\n      *configData = (void *)((int)buffer + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    configSize = configData[0xe];\n    buffer = (void *)_realloc_r(size,configData[0xd],(void *)((int)configSize << 1));\n    if (buffer != (void *)0x0) {\n      memcpy((void *)((int)buffer + (int)configSize),buffer,(size_t)configSize);\n      configData[0xd] = buffer;\n      configData[0xe] = (void *)((int)configSize << 1);\n      *configData = (void *)((int)buffer + (int)configSize);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000068f0": "initialize_flash_configuration_000068f0",
                "param_1": "size",
                "param_2": "configData",
                "pvVar1": "buffer",
                "__n": "configSize"
            },
            "calling": [
                "_sungetc_r"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006964": {
            "entrypoint": "0x00006964",
            "current_name": "calculate_sum_00006964",
            "code": "\nint calculateSum_00006964(undefined4 result,int array)\n\n{\n  int currentIndex;\n  \n  currentIndex = *(int *)(array + -4) + -4;\n  if (*(int *)(array + -4) < 0) {\n    currentIndex = currentIndex + *(int *)(array + currentIndex);\n  }\n  return currentIndex;\n}\n\n",
            "renaming": {
                "FUN_00006964": "calculate_sum_00006964",
                "param_1": "result",
                "param_2": "array",
                "iVar1": "currentIndex"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006974": {
            "entrypoint": "0x00006974",
            "current_name": "divmod_function_00006974",
            "code": "\nint divmodFunction_00006974(int dividend,int divisor,int modulus,int sign)\n\n{\n  int result;\n  undefined temp [8];\n  \n  if ((sign == 0) && (modulus == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    result = __aeabi_idiv0(dividend,divisor);\n    return result;\n  }\n  if (divisor < 0) {\n    result = -divisor - (uint)(dividend != 0);\n    if (sign < 0) {\n      result = __udivmoddi4(-dividend,result,-modulus,-sign - (uint)(modulus != 0),temp);\n      return result;\n    }\n    result = __udivmoddi4(-dividend,result,modulus,sign,temp);\n    return -result;\n  }\n  if (sign < 0) {\n    result = __udivmoddi4(dividend,divisor,-modulus,-sign - (uint)(modulus != 0),temp);\n    return -result;\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006974": "divmod_function_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "modulus",
                "param_4": "sign",
                "iVar1": "result",
                "local_8": "temp"
            },
            "calling": [
                "gmtime_r"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006a14": {
            "entrypoint": "0x00006a14",
            "current_name": "perform_division_00006a14",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong performDivision_00006a14(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint quotient_low;\n  int shift_bits;\n  uint dividend_shifted;\n  uint quotient_high;\n  uint dividend_low;\n  uint dividend_portion;\n  uint divisor_low;\n  uint carry_value;\n  uint portion_divisor;\n  bool carry_flag;\n  ulonglong result;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift_bits = LZCOUNT(divisor);\n      dividend_low = divisor;\n      if (shift_bits != 0) {\n        dividend_low = divisor << shift_bits;\n        dividend_high = dividend >> (0x20U - shift_bits & 0xff) | dividend_high << shift_bits;\n        dividend = dividend << shift_bits;\n      }\n      dividend_portion = dividend_low >> 0x10;\n      carry_value = dividend_high / dividend_portion;\n      dividend_shifted = dividend >> 0x10 | (dividend_high - dividend_portion * carry_value) * 0x10000;\n      quotient_low = carry_value * (dividend_low & 0xffff);\n      quotient_high = carry_value;\n      if (dividend_shifted <= quotient_low && quotient_low - dividend_shifted != 0) {\n        carry_flag = CARRY4(dividend_low,dividend_shifted);\n        dividend_shifted = dividend_low + dividend_shifted;\n        quotient_high = carry_value - 1;\n        if ((carry_flag == false) && (dividend_shifted <= quotient_low && quotient_low - dividend_shifted != 0)) {\n          quotient_high = carry_value - 2;\n          dividend_shifted = dividend_shifted + dividend_low;\n        }\n      }\n      carry_value = (dividend_shifted - quotient_low) / dividend_portion;\n      dividend_portion = dividend & 0xffff | ((dividend_shifted - quotient_low) - dividend_portion * carry_value) * 0x10000;\n      dividend_shifted = carry_value * (dividend_low & 0xffff);\n      quotient_low = carry_value;\n      if (dividend_portion <= dividend_shifted && dividend_shifted - dividend_portion != 0) {\n        carry_flag = CARRY4(dividend_low,dividend_portion);\n        dividend_portion = dividend_low + dividend_portion;\n        quotient_low = carry_value - 1;\n        if ((carry_flag == false) && (dividend_portion <= dividend_shifted && dividend_shifted - dividend_portion != 0)) {\n          quotient_low = carry_value - 2;\n          dividend_portion = dividend_portion + dividend_low;\n        }\n      }\n      dividend_portion = dividend_portion - dividend_shifted;\n      quotient_low = quotient_low | quotient_high << 0x10;\n      dividend_low = 0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shift_bits = LZCOUNT(divisor);\n      if (shift_bits == 0) {\n        dividend_high = dividend_high - divisor;\n        portion_divisor = divisor >> 0x10;\n        divisor_low = divisor & 0xffff;\n        dividend_low = 1;\n        quotient_high = divisor;\n      }\n      else {\n        quotient_high = divisor << shift_bits;\n        portion_divisor = quotient_high >> 0x10;\n        quotient_low = dividend_high >> (0x20U - shift_bits & 0xff);\n        dividend_low = dividend >> (0x20U - shift_bits & 0xff) | dividend_high << shift_bits;\n        dividend_shifted = quotient_low / portion_divisor;\n        divisor_low = quotient_high & 0xffff;\n        carry_value = dividend_low >> 0x10 | (quotient_low - portion_divisor * dividend_shifted) * 0x10000;\n        dividend_portion = dividend_shifted * divisor_low;\n        dividend = dividend << shift_bits;\n        quotient_low = dividend_shifted;\n        if (carry_value <= dividend_portion && dividend_portion - carry_value != 0) {\n          carry_flag = CARRY4(quotient_high,carry_value);\n          carry_value = quotient_high + carry_value;\n          quotient_low = dividend_shifted - 1;\n          if ((carry_flag == false) && (carry_value <= dividend_portion && dividend_portion - carry_value != 0)) {\n            quotient_low = dividend_shifted - 2;\n            carry_value = carry_value + quotient_high;\n          }\n        }\n        dividend_shifted = (carry_value - dividend_portion) / portion_divisor;\n        dividend_high = dividend_low & 0xffff | ((carry_value - dividend_portion) - portion_divisor * dividend_shifted) * 0x10000;\n        dividend_portion = dividend_shifted * divisor_low;\n        dividend_low = dividend_shifted;\n        if (dividend_high <= dividend_portion && dividend_portion - dividend_high != 0) {\n          carry_flag = CARRY4(quotient_high,dividend_high);\n          dividend_high = quotient_high + dividend_high;\n          dividend_low = dividend_shifted - 1;\n          if ((carry_flag == false) && (dividend_high <= dividend_portion && dividend_portion - dividend_high != 0)) {\n            dividend_low = dividend_shifted - 2;\n            dividend_high = dividend_high + quotient_high;\n          }\n        }\n        dividend_high = dividend_high - dividend_portion;\n        dividend_low = dividend_low | quotient_low << 0x10;\n      }\n      carry_value = dividend_high / portion_divisor;\n      dividend_portion = dividend >> 0x10 | (dividend_high - portion_divisor * carry_value) * 0x10000;\n      quotient_low = divisor_low * carry_value;\n      dividend_shifted = carry_value;\n      if (dividend_portion <= quotient_low && quotient_low - dividend_portion != 0) {\n        carry_flag = CARRY4(quotient_high,dividend_portion);\n        dividend_portion = quotient_high + dividend_portion;\n        dividend_shifted = carry_value - 1;\n        if ((carry_flag == false) && (dividend_portion <= quotient_low && quotient_low - dividend_portion != 0)) {\n          dividend_shifted = carry_value - 2;\n          dividend_portion = dividend_portion + quotient_high;\n        }\n      }\n      carry_value = (dividend_portion - quotient_low) / portion_divisor;\n      dividend_portion = dividend & 0xffff | ((dividend_portion - quotient_low) - portion_divisor * carry_value) * 0x10000;\n      divisor_low = divisor_low * carry_value;\n      quotient_low = carry_value;\n      if (dividend_portion <= divisor_low && divisor_low - dividend_portion != 0) {\n        carry_flag = CARRY4(quotient_high,dividend_portion);\n        dividend_portion = quotient_high + dividend_portion;\n        quotient_low = carry_value - 1;\n        if ((carry_flag == false) && (dividend_portion <= divisor_low && divisor_low - dividend_portion != 0)) {\n          quotient_low = carry_value - 2;\n          dividend_portion = dividend_portion + quotient_high;\n        }\n      }\n      dividend_portion = dividend_portion - divisor_low;\n      quotient_low = quotient_low | dividend_shifted << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend_portion >> LZCOUNT(divisor);\n      remainder[1] = 0;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n      return 0;\n    }\n    quotient_low = 0;\n    dividend_low = 0;\n  }\n  else {\n    shift_bits = LZCOUNT(divisor_high);\n    if (shift_bits != 0) {\n      divisor_low = 0x20 - shift_bits;\n      dividend_shifted = divisor >> (divisor_low & 0xff) | divisor_high << shift_bits;\n      portion_divisor = dividend_shifted >> 0x10;\n      quotient_low = dividend_high >> (divisor_low & 0xff);\n      dividend_low = dividend >> (divisor_low & 0xff) | dividend_high << shift_bits;\n      dividend_portion = quotient_low / portion_divisor;\n      quotient_high = dividend_low >> 0x10 | (quotient_low - portion_divisor * dividend_portion) * 0x10000;\n      carry_value = dividend_portion * (dividend_shifted & 0xffff);\n      dividend = dividend << shift_bits;\n      quotient_low = dividend_portion;\n      if (quotient_high <= carry_value && carry_value - quotient_high != 0) {\n        carry_flag = CARRY4(dividend_shifted,quotient_high);\n        quotient_high = dividend_shifted + quotient_high;\n        quotient_low = dividend_portion - 1;\n        if ((carry_flag == false) && (quotient_high <= carry_value && carry_value - quotient_high != 0)) {\n          quotient_low = dividend_portion - 2;\n          quotient_high = quotient_high + dividend_shifted;\n        }\n      }\n      dividend_portion = (quotient_high - carry_value) / portion_divisor;\n      quotient_high = dividend_low & 0xffff | ((quotient_high - carry_value) - portion_divisor * dividend_portion) * 0x10000;\n      carry_value = dividend_portion * (dividend_shifted & 0xffff);\n      dividend_low = dividend_portion;\n      if (quotient_high <= carry_value && carry_value - quotient_high != 0) {\n        carry_flag = CARRY4(dividend_shifted,quotient_high);\n        quotient_high = dividend_shifted + quotient_high;\n        dividend_low = dividend_portion - 1;\n        if ((carry_flag == false) && (quotient_high <= carry_value && carry_value - quotient_high != 0)) {\n          dividend_low = dividend_portion - 2;\n          quotient_high = quotient_high + dividend_shifted;\n        }\n      }\n      dividend_low = dividend_low | quotient_low << 0x10;\n      result = (ulonglong)dividend_low * (ulonglong)(divisor << shift_bits);\n      if (CONCAT44(quotient_high - carry_value,dividend) < result) {\n        result = result - CONCAT44(dividend_shifted,divisor << shift_bits);\n        dividend_low = dividend_low - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        quotient_low = ((quotient_high - carry_value) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *remainder = quotient_low << (divisor_low & 0xff) | dividend - (uint)result >> shift_bits;\n        remainder[1] = quotient_low >> shift_bits;\n      }\n      return (ulonglong)dividend_low;\n    }\n    if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_high = (dividend_high - divisor_high) - (uint)carry_flag;\n      quotient_low = 1;\n    }\n    else {\n      quotient_low = 0;\n    }\n    dividend_low = 0;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n    }\n  }\n  return CONCAT44(dividend_low,quotient_low);\n}\n\n",
            "renaming": {
                "FUN_00006a14": "perform_division_00006a14",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "uVar1": "quotient_low",
                "iVar2": "shift_bits",
                "uVar3": "dividend_shifted",
                "uVar4": "quotient_high",
                "uVar5": "dividend_low",
                "uVar6": "dividend_portion",
                "uVar7": "divisor_low",
                "uVar8": "carry_value",
                "uVar9": "portion_divisor",
                "bVar10": "carry_flag",
                "uVar11": "result"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006cd4": {
            "entrypoint": "0x00006cd4",
            "current_name": "FUNC_00006cd4",
            "code": "\nvoid FUNC_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00006cd4": "FUNC_00006cd4"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 142146,
    "layers": [
        [
            "FUN_00000410",
            "FUN_00000428",
            "FUN_00000490",
            "FUN_000004b2",
            "FUN_000004d4",
            "FUN_000004f2",
            "FUN_00000514",
            "FUN_00000534",
            "FUN_00000566",
            "FUN_0000058e",
            "FUN_000005ca",
            "FUN_00000610",
            "FUN_00000698",
            "FUN_00000738",
            "FUN_00000794",
            "FUN_000007dc",
            "FUN_000008b8",
            "FUN_00000900",
            "FUN_0000091c",
            "FUN_00000930",
            "FUN_0000093c",
            "FUN_00000958",
            "FUN_00000974",
            "FUN_00000978",
            "FUN_0000099c",
            "FUN_00000a30",
            "FUN_00000a40",
            "FUN_00000a64",
            "FUN_00000aa8",
            "FUN_00000c80",
            "FUN_00000c90",
            "FUN_00000ca0",
            "FUN_00000cb0",
            "FUN_00000cc0",
            "FUN_00000cd0",
            "FUN_00000cf0",
            "FUN_00000d0c",
            "FUN_00000d2a",
            "FUN_00000d44",
            "FUN_00000d76",
            "FUN_00000d9c",
            "FUN_00000db0",
            "FUN_00000dc0",
            "FUN_00000dcc",
            "FUN_00000df4",
            "FUN_00000e14",
            "FUN_00000e38",
            "FUN_00000e58",
            "FUN_00000e64",
            "FUN_00000ed8",
            "FUN_00000f04",
            "FUN_00000f5c",
            "FUN_00000f80",
            "FUN_00000f8c",
            "FUN_00000fec",
            "FUN_00001034",
            "FUN_000010a0",
            "FUN_000010d4",
            "FUN_00001274",
            "FUN_0000129c",
            "FUN_000012b4",
            "FUN_000012e2",
            "FUN_00001318",
            "FUN_00001348",
            "FUN_00001360",
            "FUN_00001392",
            "FUN_000013b8",
            "FUN_00001448",
            "FUN_000014c4",
            "FUN_000015d0",
            "FUN_00001628",
            "FUN_00001688",
            "FUN_00001696",
            "FUN_000016c8",
            "FUN_000016ec",
            "FUN_00001710",
            "FUN_00001734",
            "FUN_00001748",
            "FUN_00001778",
            "FUN_000017dc",
            "FUN_0000182c",
            "FUN_000018bc",
            "FUN_0000191c",
            "FUN_00001960",
            "FUN_000019c0",
            "FUN_00001a18",
            "FUN_00001a3c",
            "FUN_00001a60",
            "FUN_00001ad4",
            "FUN_00001b10",
            "FUN_00001bb8",
            "FUN_00001c84",
            "FUN_00001cf0",
            "FUN_00001d08",
            "FUN_00001d3a",
            "FUN_00001d5e",
            "FUN_00001d80",
            "FUN_00001da2",
            "FUN_00001dc0",
            "FUN_00001ddc",
            "FUN_00001e0c",
            "FUN_00001e44",
            "FUN_00001ec4",
            "FUN_00001eea",
            "FUN_00001f80",
            "FUN_00001ff6",
            "FUN_00002028",
            "FUN_000020b8",
            "FUN_000020cc",
            "FUN_000020e0",
            "FUN_000020f4",
            "FUN_00002108",
            "FUN_0000211c",
            "FUN_00002270",
            "FUN_00002294",
            "FUN_000022be",
            "FUN_000022f0",
            "FUN_0000231c",
            "FUN_00002364",
            "FUN_00002396",
            "FUN_000023a4",
            "FUN_000023c8",
            "FUN_000023d0",
            "FUN_0000240c",
            "FUN_00002434",
            "FUN_000024bc",
            "FUN_00002538",
            "FUN_0000258c",
            "FUN_000025f4",
            "FUN_00002600",
            "FUN_00002624",
            "FUN_00002654",
            "FUN_00002690",
            "FUN_000026c0",
            "FUN_000026d8",
            "FUN_000026e4",
            "FUN_000026f0",
            "FUN_00002714",
            "FUN_00002744",
            "FUN_00002798",
            "FUN_000027b0",
            "FUN_0000281c",
            "FUN_0000285c",
            "FUN_00002894",
            "FUN_000028f0",
            "FUN_00002910",
            "FUN_0000294c",
            "FUN_00002970",
            "FUN_00002994",
            "FUN_00002a00",
            "FUN_00002a18",
            "FUN_00002a88",
            "FUN_00002b10",
            "FUN_00002d94",
            "FUN_00002e48",
            "FUN_00002e6c",
            "FUN_00002e9c",
            "FUN_00002eb4",
            "FUN_00002ecc",
            "FUN_00002f30",
            "FUN_00002f74",
            "FUN_00002fe0",
            "FUN_0000305c",
            "FUN_0000316c",
            "FUN_000031e0",
            "FUN_000031fc",
            "FUN_0000328c",
            "FUN_00003378",
            "FUN_000033c0",
            "FUN_000033f4",
            "FUN_00003444",
            "FUN_00003478",
            "FUN_000034c0",
            "FUN_00003524",
            "FUN_00003658",
            "FUN_00003688",
            "FUN_00003694",
            "FUN_00003810",
            "FUN_00003918",
            "FUN_000039e8",
            "FUN_00003d24",
            "FUN_00003d64",
            "FUN_00003d94",
            "FUN_00003dc4",
            "FUN_00003e58",
            "FUN_00003e9e",
            "FUN_00003ec4",
            "FUN_00003ff4",
            "FUN_00004042",
            "FUN_0000404c",
            "FUN_00004158",
            "FUN_000041d0",
            "FUN_000041f4",
            "FUN_0000423c",
            "FUN_00004248",
            "FUN_00004274",
            "FUN_00004280",
            "FUN_0000428c",
            "FUN_00004298",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_000043a0",
            "FUN_000043da",
            "FUN_00004418",
            "FUN_0000443c",
            "FUN_0000459c",
            "FUN_000045ee",
            "FUN_00004622",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_00004b34",
            "FUN_00004bd0",
            "FUN_00004c84",
            "FUN_00004cb4",
            "FUN_00004cdc",
            "FUN_00004db8",
            "FUN_00004dc8",
            "FUN_00004dea",
            "FUN_00004dee",
            "FUN_00004e26",
            "FUN_00004e4a",
            "FUN_00004e52",
            "FUN_00004e66",
            "FUN_00004e8c",
            "FUN_00004f84",
            "FUN_00004f98",
            "FUN_000050e8",
            "FUN_000050f4",
            "FUN_00005100",
            "FUN_0000510c",
            "FUN_00005404",
            "FUN_000054a8",
            "FUN_00005584",
            "FUN_000055ac",
            "FUN_0000562c",
            "FUN_000056a0",
            "FUN_000056b0",
            "FUN_000056b8",
            "FUN_00005700",
            "FUN_00005780",
            "FUN_00005790",
            "FUN_0000579c",
            "FUN_000057a8",
            "FUN_000057d2",
            "FUN_000057f8",
            "FUN_00005a58",
            "FUN_00005b34",
            "FUN_00005d80",
            "FUN_00005e10",
            "FUN_00005e68",
            "FUN_00005ebc",
            "FUN_00005ecc",
            "FUN_00005edc",
            "FUN_00005fd8",
            "FUN_00005fec",
            "FUN_00005ff8",
            "FUN_00006010",
            "FUN_000060b0",
            "FUN_000060cc",
            "FUN_00006118",
            "FUN_00006192",
            "FUN_000061cc",
            "FUN_000064bc",
            "FUN_0000656c",
            "FUN_00006754",
            "FUN_00006768",
            "FUN_0000687c",
            "FUN_000068f0",
            "FUN_00006964",
            "FUN_00006974",
            "FUN_00006a14"
        ]
    ],
    "locked_functions": []
}