{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeFlag_000800f4(undefined4 input)\n\n{\n  if ((char)DAT_200708a0 == '\\0') {\n    DAT_200708a0._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_flag_000800f4",
                "param_1": "input"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_data_00080164",
            "code": "\nvoid initializeData_00080164(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  FUN_000806f8(&DAT_200708e8,0x5a);\n  FUN_000806f8(&DAT_200708d4,0x5a,param3,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_data_00080164",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000806f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_system_000801e0",
            "code": "\nundefined8 initialize_system_000801e0(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_000813dc(&DAT_20070be8,0xe100,arg3,arg4,arg4);\n  FUN_00080f0c(0xd,1);\n  FUN_00080f0c(6,1);\n  FUN_00080f0c(0x39,0);\n  FUN_00080f0c(4,0);\n  FUN_00080f0c(3,0);\n  FUN_00080f0c(2,0);\n  FUN_000806a0(&DAT_200708d4,5);\n  FUN_000806a0(&DAT_200708e8,6);\n  FUN_00080164();\n  FUNC_00080f08(1000);\n  if (DAT_200708bc == 0) {\n    software_interrupt(0x3f);\n    return 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_system_000801e0",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000806a0",
                "FUN_00080f0c",
                "FUN_00080f08",
                "FUN_00080164",
                "FUN_000813dc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_mode_00080250",
            "code": "\nvoid controlMode_00080250(void)\n\n{\n  undefined4 returnValue;\n  int loopCounter;\n  undefined *pointer;\n  undefined tempStack [12];\n  \n  DAT_200708c0 = FUN_00081624(4,1,20000);\n  FUNC_00080f08(10);\n  DAT_200708c4 = DAT_200708c4 ^ 1;\n  FUN_00081014(0xd);\n  if (DAT_200708c0 < 0x641) {\n    if (DAT_200708c0 - 0x385U < 299) {\n      if (DAT_200708eb != '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered manual control mode.\");\n        DAT_200708eb = '\\0';\n      }\n      FUNC_00080f08(10);\n      returnValue = FUN_00081624(3,1,20000);\n      DAT_200708d8 = FUN_0008145c(0,1000,2000,0x28,0x96);\n      DAT_200708ec = FUN_0008145c(returnValue,1000,2000,0x28,0x96);\n      while (loopCounter = FUN_00081248(&DAT_20070be8), 0 < loopCounter) {\n        FUN_00081276(&DAT_20070be8);\n        thunk_FUN_0008113a(&DAT_20070be8,DAT_200708d8,10);\n        FUN_000810c4(&DAT_20070be8,&DAT_00084b13);\n        FUN_0008117a(&DAT_20070be8,DAT_200708ec,10);\n      }\n      FUN_000806f8(&DAT_200708e8,DAT_200708ec);\n      FUN_000806f8(&DAT_200708d4,DAT_200708d8);\n    }\n    else {\n      if (DAT_200708eb == '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered autonomous control mode.\");\n      }\n      DAT_200708eb = '\\x01';\nLAB_00080346:\n      loopCounter = FUN_00081248(&DAT_20070be8);\n      if (0 < loopCounter) {\n        FUN_00081214(tempStack,&DAT_20070be8,0x2c);\n        FUN_00081560(&DAT_200708dc,tempStack);\n        FUN_00081472(tempStack);\n        FUN_00081214(tempStack,&DAT_20070be8,10);\n        FUN_00081560(&DAT_200708c8,tempStack);\n        FUN_00081472(tempStack);\n        FUN_00081276(&DAT_20070be8);\n        loopCounter = FUN_000815b8(&DAT_200708dc,\"steer\");\n        if (loopCounter == 0) goto LAB_0008039c;\n        returnValue = FUN_000815de(&DAT_200708c8);\n        pointer = &DAT_200708d4;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    FUN_00080164();\n    FUN_000810e8(&DAT_20070be8,\"error\");\n  }\n  return;\nLAB_0008039c:\n  loopCounter = FUN_000815b8(&DAT_200708dc,\"motor\");\n  if (loopCounter != 0) {\n    returnValue = FUN_000815de(&DAT_200708c8);\n    pointer = &DAT_200708e8;\nLAB_000803b2:\n    FUN_000806f8(pointer,returnValue);\n  }\n  goto LAB_00080346;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_mode_00080250",
                "uVar1": "returnValue",
                "iVar2": "loopCounter",
                "puVar3": "pointer",
                "auStack_1c": "tempStack"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000810c4",
                "FUN_00081472",
                "FUN_000815b8",
                "FUN_00081248",
                "FUN_000806f8",
                "FUN_00081214",
                "FUN_00080164",
                "FUN_000810e8",
                "FUN_00080f08",
                "FUN_00081276",
                "FUN_00081560",
                "FUN_00081014",
                "FUN_00081624",
                "thunk_FUN_0008113a",
                "FUN_000815de",
                "FUN_0008117a",
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "initialize_tc_settings_000803fc",
            "code": "\nvoid initializeTCSettings_000803fc(int channelIndex,uint value,undefined4 param3,uint bitPosition)\n\n{\n  undefined4 unaffectedR4;\n  undefined4 interruptLinkRegister;\n  undefined8 combinedValue;\n  \n  combinedValue = CONCAT44(value,channelIndex);\n  FUN_00080aa8(param3);\n  FUN_00080b2c(channelIndex,value,0xc002);\n  FUN_00080b90(channelIndex,value,0xa41);\n  *(int *)((bitPosition >> 5) * 4 + -0x1fff1f00) = 1 << (bitPosition & 0x1f);\n  *(undefined4 *)(channelIndex + value * 0x40 + 0x24) = 4;\n  if (2 < value) {\n    combinedValue = FUN_000816f8(\"../source/tc.c\",0x5c,\"TC_Start\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\",\n                         unaffectedR4,interruptLinkRegister);\n  }\n  *(undefined4 *)((int)combinedValue + (int)((ulonglong)combinedValue >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "initialize_tc_settings_000803fc",
                "param_1": "channelIndex",
                "param_2": "value",
                "param_3": "param3",
                "param_4": "bitPosition",
                "unaff_r4": "unaffectedR4",
                "in_lr": "interruptLinkRegister",
                "uVar1": "combinedValue"
            },
            "calling": [
                "FUN_000806a0"
            ],
            "called": [
                "FUN_00080b90",
                "FUN_00080b2c",
                "FUN_00080aa8",
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_flags_and_values_0008044c",
            "code": "\nvoid updateFlagsAndValues_0008044c(int index,int base,int offset)\n\n{\n  uint limit;\n  int offsetMultiplier;\n  \n  offset = offset * 0x40;\n  if (((&DAT_200708f1)[index] & 0x80) == 0) {\n    offsetMultiplier = index * 0xc;\n    if (((char)(&DAT_200708f1)[index] + offsetMultiplier < (int)(uint)DAT_200708f0) &&\n       ((int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + offsetMultiplier) * 8] << 0x19) < 0\n       )) {\n      FUN_00081014((&DAT_200708f8)[(offsetMultiplier + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,0);\n    }\n  }\n  else {\n    *(uint *)(base + offset) = *(uint *)(base + offset) | 4;\n  }\n  limit = (uint)DAT_200708f0;\n  (&DAT_200708f1)[index] = (&DAT_200708f1)[index] + '\\x01';\n  offsetMultiplier = index * 0xc;\n  if (((char)(&DAT_200708f1)[index] + offsetMultiplier < (int)limit) &&\n     ((char)(&DAT_200708f1)[index] < '\\f')) {\n    *(int *)(base + offset + 0x14) =\n         *(int *)(base + offset + 0x10) +\n         *(int *)(&DAT_200708fc + ((char)(&DAT_200708f1)[index] + offsetMultiplier) * 8);\n    if (-1 < (int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + offsetMultiplier) * 8] << 0x19\n                  )) {\n      return;\n    }\n    FUN_00081014((&DAT_200708f8)[(offsetMultiplier + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,1);\n    return;\n  }\n  base = base + offset;\n  limit = (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * 20000 >> 5;\n  if (limit <= *(int *)(base + 0x10) + 4U) {\n    limit = *(int *)(base + 0x10) + 4;\n  }\n  *(uint *)(base + 0x14) = limit;\n  (&DAT_200708f1)[index] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_flags_and_values_0008044c",
                "param_1": "index",
                "param_2": "base",
                "param_3": "offset",
                "uVar1": "limit",
                "iVar2": "offsetMultiplier"
            },
            "calling": [],
            "called": [
                "FUN_00081014"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "update_data_000805a8",
            "code": "\nvoid updateData_000805a8(byte *outputBuffer)\n\n{\n  char nextDataValue;\n  uint dataCount;\n  \n  dataCount = (uint)DAT_200708f0;\n  if (dataCount < 0x3c) {\n    nextDataValue = DAT_200708f0 + 1;\n    *outputBuffer = DAT_200708f0;\n    DAT_200708f0 = nextDataValue;\n    *(uint *)(&DAT_200708fc + dataCount * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * 0x5dc >> 5;\n    return;\n  }\n  *outputBuffer = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805a8": "update_data_000805a8",
                "param_1": "outputBuffer",
                "uVar2": "dataCount",
                "cVar1": "nextDataValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "process_input_000806a0",
            "code": "\nbyte processInput_000806a0(byte *inputArray,undefined4 param2)\n\n{\n  byte byteValue;\n  undefined4 constant1;\n  uint divResult;\n  undefined4 constant2;\n  int loopCounter;\n  uint byteValueAsInt;\n  \n  if (0x3b < *inputArray) goto LAB_00080660;\n  FUN_00080f0c(param2,1,0x220,*inputArray,0x960);\n  byteValueAsInt = (uint)*inputArray;\n  byteValue = (&DAT_200708f8)[byteValueAsInt * 8];\n  inputArray[2] = 0;\n  divResult = byteValueAsInt / 0xc;\n  (&DAT_200708f8)[byteValueAsInt * 8] = byteValue & 0xc0 | (byte)param2 & 0x3f;\n  inputArray[1] = 0;\n  loopCounter = 0;\n  do {\n    if ((int)((uint)(byte)(&DAT_200708f8)[(loopCounter + divResult * 0xc) * 8] << 0x19) < 0)\n    goto LAB_00080652;\n    loopCounter = loopCounter + 1;\n  } while (loopCounter != 0xc);\n  if (divResult == 0) {\n    constant1 = 0x40084000;\n    constant2 = 0x1e;\nLAB_0008064c:\n    FUN_000803fc(constant1,divResult,constant2,constant2);\n  }\n  else {\n    if (divResult == 1) {\n      constant1 = 0x40084000;\n      constant2 = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (divResult == 2) {\n      constant1 = 0x40084000;\n      constant2 = 0x20;\n      goto LAB_0008064c;\n    }\n    if (divResult == 3) {\n      constant1 = 0x40080000;\n      divResult = 2;\n      constant2 = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (divResult == 4) {\n      constant1 = 0x40080000;\n      divResult = 0;\n      constant2 = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  (&DAT_200708f8)[(uint)*inputArray * 8] = (&DAT_200708f8)[(uint)*inputArray * 8] | 0x40;\nLAB_00080660:\n  return *inputArray;\n}\n\n",
            "renaming": {
                "FUN_000806a0": "process_input_000806a0",
                "param_1": "inputArray",
                "param_2": "param2",
                "bVar1": "byteValue",
                "uVar2": "constant1",
                "uVar3": "divResult",
                "uVar4": "constant2",
                "iVar5": "loopCounter",
                "uVar6": "byteValueAsInt"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000803fc",
                "FUN_00080f0c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "process_data_000806f8",
            "code": "\nvoid process_data_000806f8(byte *data_ptr,uint data_size)\n\n{\n  uint adjusted_size;\n  \n  if ((int)data_size < 0x220) {\n    adjusted_size = data_size;\n    if (0xb3 < (int)data_size) {\n      adjusted_size = 0xb4;\n    }\n    data_size = FUN_0008145c(adjusted_size & ~((int)adjusted_size >> 0x1f),0,0xb4,(0x88 - (char)data_ptr[1]) * 4,\n                           (600 - (char)data_ptr[2]) * 4,data_size);\n  }\n  if (*data_ptr < 0x3c) {\n    adjusted_size = (0x88 - (char)data_ptr[1]) * 4;\n    if (((int)(data_size + (0x88 - (char)data_ptr[1]) * -4) < 0 == SBORROW4(data_size,adjusted_size)) &&\n       (adjusted_size = (600 - (char)data_ptr[2]) * 4, (int)data_size <= (int)adjusted_size)) {\n      adjusted_size = data_size;\n    }\n    *(uint *)(&DAT_200708fc + (uint)*data_ptr * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * (adjusted_size - 2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000806f8": "process_data_000806f8",
                "param_1": "data_ptr",
                "param_2": "data_size",
                "uVar1": "adjusted_size"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080164"
            ],
            "called": [
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_data_00080774",
            "code": "\n\n\nvoid initializeData_00080774(void)\n\n{\n  int index;\n  int nextIndex;\n  \n  FUN_00080b98();\n  _DAT_e000e014 = Elf32_Rel_ARRAY_20070000[6].r_offset / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  FUN_00081778();\n  index = 0;\n  do {\n    nextIndex = index + 1;\n    FUN_00081014(index,0);\n    index = nextIndex;\n  } while (nextIndex != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  FUN_00080a30(0x400e0e00,1,0x300,0);\n  FUN_00081014(0,1);\n  FUN_00080a30(0x400e0e00,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,0x3000,0);\n  FUN_00080a30(0x400e1400,2,0x30,0);\n  FUN_00080a30(0x400e1000,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,3,0);\n  FUN_00080a30(0x400e1000,1,0xc000,0);\n  FUN_00080aa8(0x25);\n  FUN_00080c98(0x400c0000,Elf32_Rel_ARRAY_20070000[6].r_offset,20000000,0xc);\n  FUN_00080d3e(0x400c0000,0,0x300000,1);\n  FUN_00080d30(0x400c0000,0,0);\n  FUN_00080d6a(0x400c0000,0xffffffff);\n  FUN_00080d62(0x400c0000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_data_00080774",
                "iVar1": "index",
                "iVar2": "nextIndex"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00080d3e",
                "FUN_00081778",
                "FUN_00081014",
                "FUN_00080c98",
                "FUN_00080b98",
                "FUN_00080a30",
                "FUN_00080d30",
                "FUN_00080aa8",
                "FUN_00080d6a",
                "FUN_00080d62"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_components_0008089c",
            "code": "\nvoid initializeComponents_0008089c(undefined4 param1,undefined4 param2,undefined4 param3)\n\n{\n  FUN_000811b0(&DAT_20070c0c);\n  FUN_000811b0(&DAT_20070b60);\n  FUN_00081348(&DAT_20070be8,0x400e0800,8,8,&DAT_20070c0c,&DAT_20070b60,param3);\n  FUN_000811b0(&DAT_20070e6c);\n  FUN_000811b0(&DAT_20070ef4);\n  FUN_000811b0(&DAT_20070f7c);\n  FUN_000811b0(&DAT_20070ad8);\n  FUN_000811b0(&DAT_20070d0c);\n  FUN_000811b0(&DAT_20070d94);\n  FUN_00081438(&DAT_20070c94,0x40098000,0x11,0x11,&DAT_20070e6c,&DAT_20070ad8);\n  FUN_00081438(&DAT_20070cbc,0x4009c000,0x12,0x12,&DAT_20070ef4,&DAT_20070d0c);\n  FUN_00081438(&DAT_20070ce4,0x400a4000,0x14,0x14,&DAT_20070f7c,&DAT_20070d94);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_components_0008089c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3"
            },
            "calling": [],
            "called": [
                "FUN_000811b0",
                "FUN_00081348",
                "FUN_00081438"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "check_and_execute_functions_00080970",
            "code": "\nvoid checkAndExecuteFunctions_00080970(void)\n\n{\n  int result;\n  \n  result = FUN_00081248(&DAT_20070be8);\n  if (result != 0) {\n    FUNC_0008073a();\n  }\n  result = FUN_00081248(&DAT_20070c94);\n  if (result != 0) {\n    FUNC_00080748();\n  }\n  result = FUN_00081248(&DAT_20070cbc);\n  if (result != 0) {\n    FUNC_0008074a();\n  }\n  result = FUN_00081248(&DAT_20070ce4);\n  if (result != 0) {\n    FUNC_0008074c();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "check_and_execute_functions_00080970",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_0008074a",
                "FUN_0008073a",
                "FUN_00081248",
                "FUN_00080748",
                "FUN_0008074c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_config_000809be",
            "code": "\nvoid updateConfig_000809be(int configPtr,undefined4 option,uint value)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(configPtr + 0x44) = value;\n  switch(option) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(configPtr + 0x70) & *(uint *)(configPtr + 0x70) & ~value;\n    break;\n  case 2:\n    updatedValue = *(uint *)(configPtr + 0x70) | value;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(configPtr + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(configPtr + 4) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_config_000809be",
                "param_1": "configPtr",
                "param_2": "option",
                "param_3": "value",
                "uVar1": "updatedValue"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "set_values_based_on_flags_000809e4",
            "code": "\nvoid setValuesBasedOnFlags_000809e4(undefined4 *outputArray,undefined4 inputValue,uint flags)\n\n{\n  bool isNegative;\n  \n  isNegative = (int)(flags << 0x1f) < 0;\n  outputArray[0x11] = inputValue;\n  if (isNegative) {\n    outputArray[0x19] = inputValue;\n  }\n  if (!isNegative) {\n    outputArray[0x18] = inputValue;\n  }\n  isNegative = (flags & 10) != 0;\n  if (isNegative) {\n    outputArray[8] = inputValue;\n  }\n  if (!isNegative) {\n    outputArray[9] = inputValue;\n  }\n  if (((int)(flags << 0x1e) < 0) || ((int)(flags << 0x1c) < 0)) {\n    outputArray[0x20] = inputValue;\n  }\n  outputArray[5] = inputValue;\n  *outputArray = inputValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "set_values_based_on_flags_000809e4",
                "param_1": "outputArray",
                "param_2": "inputValue",
                "param_3": "flags",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "set_parameters_and_return_value_00080a0a",
            "code": "\nvoid setParametersAndReturnValue_00080a0a(undefined4 *parametersArray,undefined4 value,int flag1,int flag2,int flag3)\n\n{\n  parametersArray[0x11] = value;\n  if (flag3 == 0) {\n    parametersArray[0x18] = value;\n  }\n  else {\n    parametersArray[0x19] = value;\n  }\n  if (flag2 == 0) {\n    parametersArray[0x15] = value;\n  }\n  else {\n    parametersArray[0x14] = value;\n  }\n  if (flag1 == 0) {\n    parametersArray[0xd] = value;\n  }\n  else {\n    parametersArray[0xc] = value;\n  }\n  parametersArray[4] = value;\n  *parametersArray = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "set_parameters_and_return_value_00080a0a",
                "param_1": "parametersArray",
                "param_2": "value",
                "param_3": "flag1",
                "param_4": "flag2",
                "param_5": "flag3"
            },
            "calling": [
                "FUN_00081014",
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "update_data_00080a30",
            "code": "\nundefined4 updateData_00080a30(int dataPointer,int option,undefined4 newValue,uint flag)\n\n{\n  bool isNegative;\n  \n  switch(option) {\n  case 1:\n  case 2:\n    FUN_000809be(dataPointer,option,newValue);\n    isNegative = (int)(flag << 0x1f) < 0;\n    *(undefined4 *)(dataPointer + 0x44) = newValue;\n    if (isNegative) {\n      *(undefined4 *)(dataPointer + 100) = newValue;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(dataPointer + 0x60) = newValue;\n    }\n    break;\n  case 3:\n    FUN_000809e4(dataPointer,newValue,flag,0x809e5,dataPointer);\n    break;\n  case 4:\n  case 5:\n    FUN_00080a0a(dataPointer,newValue,option == 5,(flag << 0x1d) >> 0x1f,flag & 1,option,newValue)\n    ;\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "update_data_00080a30",
                "param_1": "dataPointer",
                "param_2": "option",
                "param_3": "newValue",
                "param_4": "flag",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080f0c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_000809e4",
                "FUN_000809be"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_param_flags_00080a94",
            "code": "\nuint check_param_flags_00080a94(int ptr,uint flags)\n\n{\n  uint result;\n  \n  result = *(uint *)(ptr + 8) & flags;\n  if (result != 0) {\n    if ((flags & *(uint *)(ptr + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_param_flags_00080a94",
                "param_1": "ptr",
                "param_2": "flags",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00081014"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "set_bit_in_data_00080aa8",
            "code": "\n\n\nundefined4 setBitInData_00080aa8(uint bitPosition)\n\n{\n  uint bitMask;\n  \n  if (bitPosition < 0x2d) {\n    if (bitPosition < 0x20) {\n      bitMask = 1 << (bitPosition & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (bitPosition - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "set_bit_in_data_00080aa8",
                "param_1": "bitPosition",
                "uVar1": "bitMask"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080f0c",
                "FUN_00080774",
                "FUN_000813dc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "configure_tc_channel_00080b2c",
            "code": "\nvoid configureTcChannel_00080b2c(undefined4 channelNum,uint dwChannel,char *errorMessage)\n\n{\n  int offset;\n  int tcChannelAddress;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(dwChannel,channelNum);\n  if (2 < dwChannel) {\n    errorMessage = \"TC_Configure\";\n    combinedParams = FUN_000816f8(\"../source/tc.c\",0x40,\"TC_Configure\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  offset = (int)((ulonglong)combinedParams >> 0x20) * 0x40;\n  tcChannelAddress = (int)combinedParams + offset;\n  *(undefined4 *)((int)combinedParams + offset) = 2;\n  *(undefined4 *)(tcChannelAddress + 0x28) = 0xffffffff;\n  *(char **)(tcChannelAddress + 4) = errorMessage;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "configure_tc_channel_00080b2c",
                "param_1": "channelNum",
                "param_2": "dwChannel",
                "param_3": "errorMessage",
                "uVar3": "combinedParams",
                "iVar1": "offset",
                "iVar2": "tcChannelAddress"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "set_param_00080b90",
            "code": "\nvoid setParam_00080b90(int baseAddress,int offset,undefined4 value)\n\n{\n  *(undefined4 *)(baseAddress + offset * 0x40 + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "set_param_00080b90",
                "param_1": "baseAddress",
                "param_2": "offset",
                "param_3": "value"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_memory_00080b98",
            "code": "\n\n\nvoid initializeMemory_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  arrayData[6].r_offset = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_memory_00080b98",
                "Elf32_Rel_ARRAY_20070000": "arrayData"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x00080c20",
            "current_name": "entry",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 = 0; (undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) < &DAT_200708a0\n      ; iVar1 = iVar1 + 4) {\n    *(undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) =\n         *(undefined4 *)(&DAT_00085878 + iVar1);\n  }\n  for (puVar2 = &DAT_200708a0; puVar2 < (undefined4 *)0x20071248; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  FUN_000815ec();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_000815ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "calculate_priority_00080c98",
            "code": "\nundefined4 calculatePriority_00080c98(undefined4 *priorityArray,uint dataSize,int unitSize,int timeFactor)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint thresholdArray [16];\n  \n  thresholdArray[0] = 0;\n  thresholdArray[1] = 8;\n  thresholdArray[2] = 0x10;\n  thresholdArray[3] = 0x18;\n  thresholdArray[4] = 0x40;\n  thresholdArray[5] = 0x50;\n  thresholdArray[6] = 0x60;\n  thresholdArray[7] = 0x70;\n  thresholdArray[8] = 0x200;\n  thresholdArray[9] = 0x240;\n  thresholdArray[10] = 0x280;\n  thresholdArray[11] = 0x2c0;\n  thresholdArray[12] = 0x300;\n  thresholdArray[13] = 0x340;\n  thresholdArray[14] = 0x380;\n  thresholdArray[15] = 0x3c0;\n  *priorityArray = 1;\n  priorityArray[1] = 0;\n  priorityArray[0x48] = 0x202;\n  priorityArray[0x41] = 0;\n  priorityArray[0x45] = 0;\n  uVar1 = dataSize / (uint)(unitSize * 2);\n  if (dataSize == unitSize * 2 * uVar1) {\n    uVar1 = uVar1 - 1;\n  }\n  uVar2 = 0;\n  do {\n    if ((uint)(timeFactor * (int)(((ulonglong)dataSize / (ulonglong)((uVar1 + 1) * 2)) / 1000000)) <=\n        thresholdArray[uVar2]) {\n      priorityArray[1] = (uVar2 & 0xf) << 0x10 | (uVar1 & 0xff) << 8 | priorityArray[1];\n      return 0;\n    }\n    uVar2 = uVar2 + 1;\n  } while (uVar2 != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "calculate_priority_00080c98",
                "param_1": "priorityArray",
                "param_2": "dataSize",
                "param_3": "unitSize",
                "param_4": "timeFactor",
                "local_58": "thresholdArray"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_parameters_00080d30",
            "code": "\nvoid updateParameters_00080d30(int dataPointer,uint value1,uint value2)\n\n{\n  *(uint *)(dataPointer + 4) = value1 | *(uint *)(dataPointer + 4) | (value2 & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_parameters_00080d30",
                "param_1": "dataPointer",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "update_flags_00080d3e",
            "code": "\nvoid updateFlags_00080d3e(int flagsAddress,uint input1,uint input2,uint input3)\n\n{\n  *(uint *)(flagsAddress + 4) =\n       input2 | *(uint *)(flagsAddress + 4) | (input1 & 0xf) << 0x18 | (input3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "update_flags_00080d3e",
                "param_1": "flagsAddress",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_00080d58",
            "code": "\nvoid setBit_00080d58(int baseAddress,uint bitPosition)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitPosition"
            },
            "calling": [
                "FUN_00080f0c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "initialize_memory_00080d62",
            "code": "\nvoid initializeMemory_00080d62(int memoryAddress)\n\n{\n  *(undefined4 *)(memoryAddress + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "initialize_memory_00080d62",
                "param_1": "memoryAddress"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_param_value_00080d6a",
            "code": "\nvoid setParamValue_00080d6a(int objAddress,undefined4 value)\n\n{\n  *(undefined4 *)(objAddress + 0x28) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_param_value_00080d6a",
                "param_1": "objAddress",
                "param_2": "value"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "initialize_application_00080e80",
            "code": "\nvoid initializeApplication_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "initialize_application_00080e80",
                "undefined4": "void"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "calculate_new_value_00080e88",
            "code": "\nint calculateNewValue_00080e88(int inputValue)\n\n{\n  int previousValue;\n  \n  if (DAT_20071208 == 0) {\n    DAT_20071208 = 0x20071248;\n  }\n  previousValue = DAT_20071208;\n  DAT_20071208 = inputValue + DAT_20071208;\n  return previousValue;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "calculate_new_value_00080e88",
                "param_1": "inputValue",
                "iVar1": "previousValue"
            },
            "calling": [
                "FUN_0008236c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "get_default_value_00080eaa",
            "code": "\nuint32_t get_default_value_00080eaa(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "get_default_value_00080eaa",
                "undefined4": "uint32_t"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "set_memory_address_00080eb0",
            "code": "\nundefined4 setMemoryAddress_00080eb0(undefined4 param1,int address)\n\n{\n  *(undefined4 *)(address + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "set_memory_address_00080eb0",
                "param_1": "param1",
                "param_2": "address"
            },
            "calling": [
                "FUN_00084494"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "check_if_success_00080eba",
            "code": "\nundefined4 check_if_success_00080eba(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "check_if_success_00080eba"
            },
            "calling": [
                "FUN_000844bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "initialize_application_00080ebe",
            "code": "\nundefined4 initializeApplication_00080ebe(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "initialize_application_00080ebe"
            },
            "calling": [
                "FUN_000844e0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "get_default_value_00080ec2",
            "code": "\nundefined4 getDefaultValue_00080ec2(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "get_default_value_00080ec2"
            },
            "calling": [
                "FUN_00084508"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "process_data_00080ec8",
            "code": "\n\n\nuint processData_00080ec8(undefined4 inputPtr,int dataPtr,uint dataSize)\n\n{\n  int currentIndex;\n  \n  for (currentIndex = 0; currentIndex < (int)dataSize; currentIndex = currentIndex + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)*(byte *)(dataPtr + currentIndex);\n  }\n  return dataSize & ~((int)dataSize >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "process_data_00080ec8",
                "param_1": "inputPtr",
                "param_2": "dataPtr",
                "param_3": "dataSize",
                "iVar1": "currentIndex"
            },
            "calling": [
                "FUN_00084244"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "exit_with_status_00080eec",
            "code": "\nvoid exitWithStatus_00080eec(undefined4 status,undefined4 var2,undefined4 var3,undefined4 var4)\n\n{\n  FUN_000817c8(\"Exiting with status %d.\\n\",status,var3,var4,var4);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "exit_with_status_00080eec",
                "param_1": "status",
                "param_2": "var2",
                "param_3": "var3",
                "param_4": "var4"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_000817c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\nvoid FUNC_00080efc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "initialize_error_code_00080efe",
            "code": "\nuint32_t initializeErrorCode_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "initialize_error_code_00080efe",
                "undefined4": "uint32_t"
            },
            "calling": [
                "thunk_FUN_00080efe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_000816d8": {
            "entrypoint": "0x00080f04",
            "current_name": "get_data_value_thunk_000816d8",
            "code": "\nundefined4 get_data_value_thunk_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "thunk_FUN_000816d8": "get_data_value_thunk_000816d8"
            },
            "calling": [
                "FUN_000811e8"
            ],
            "called": [
                "FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\nvoid FUNC_00080f08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0",
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "handle_data_00080f0c",
            "code": "\n\n\nint handleData_00080f0c(int deviceIndex,int data)\n\n{\n  int returnValue;\n  uint temp1;\n  undefined4 temp2;\n  uint temp3;\n  byte bitCheck1;\n  byte bitCheck2;\n  int temp4;\n  int temp5;\n  \n  returnValue = deviceIndex;\n  if ((&DAT_00084b50)[deviceIndex * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[deviceIndex] & 0xf) == 4) {\n      returnValue = FUN_00080d58(0x400c0000,(&DAT_00084b5d)[deviceIndex * 0x1c]);\n    }\n    bitCheck2 = (&DAT_20070e1c)[deviceIndex];\n    bitCheck1 = bitCheck2 & 0xf;\n    if ((bitCheck1 < 3) && (bitCheck2 != 0)) {\n      if (bitCheck1 == 2) {\n        if (data == 0) {\n          return returnValue;\n        }\n      }\n      else if (bitCheck1 == 1) {\n        if (data == 2) {\n          return returnValue;\n        }\n      }\n      else if (bitCheck1 == 3) {\n        if (data == 1) {\n          return returnValue;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (data != 1) {\nLAB_00080f68:\n      if (data == 0) {\n        returnValue = deviceIndex * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + returnValue));\n        returnValue = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + returnValue),3,\n                             *(undefined4 *)(&DAT_00084b48 + returnValue),0);\n        bitCheck2 = (&DAT_20070e1c)[deviceIndex] & 0xf0 | 2;\n      }\n      else {\n        if (data != 2) {\n          return returnValue;\n        }\n        returnValue = deviceIndex * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + returnValue));\n        returnValue = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + returnValue),3,\n                             *(undefined4 *)(&DAT_00084b48 + returnValue),1);\n        bitCheck2 = (&DAT_20070e1c)[deviceIndex] & 0xf0 | 1;\n      }\n      (&DAT_20070e1c)[deviceIndex] = bitCheck2;\n      return returnValue;\n    }\n    temp4 = deviceIndex * 0x1c;\n    temp5 = *(int *)(&DAT_00084b44 + temp4);\n    if (bitCheck2 >> 4 == 0) {\n      temp2 = 4;\n    }\n    else {\n      temp2 = 5;\n    }\n    returnValue = FUN_00080a30(temp5,temp2,*(undefined4 *)(&DAT_00084b48 + temp4),\n                         *(undefined4 *)(&DAT_00084b54 + temp4));\n    (&DAT_20070e1c)[deviceIndex] = (&DAT_20070e1c)[deviceIndex] & 0xf0 | 3;\n    if (*(int *)(temp5 + 0x18) == -1) {\n      temp1 = *(uint *)(&DAT_00084b4c + temp4);\n      if (0x2c < temp1) {\n        return 1;\n      }\n      if (temp1 < 0x20) {\n        temp1 = 1 << (temp1 & 0xff);\n        temp3 = _DAT_400e0618 & temp1;\n        if (temp3 == temp1) {\n          _DAT_400e0614 = temp3;\n        }\n      }\n      else {\n        temp1 = 1 << (temp1 - 0x20 & 0xff);\n        temp3 = _DAT_400e0708 & temp1;\n        if (temp3 == temp1) {\n          _DAT_400e0704 = temp3;\n        }\n      }\n      return 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "handle_data_00080f0c",
                "param_1": "deviceIndex",
                "param_2": "data",
                "iVar1": "returnValue",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "bVar5": "bitCheck1",
                "bVar6": "bitCheck2",
                "iVar7": "temp4",
                "iVar8": "temp5"
            },
            "calling": [
                "FUN_00081014",
                "FUN_000806a0",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080a30",
                "FUN_00080aa8",
                "FUN_00080d58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "update_parameter_00081014",
            "code": "\nvoid updateParameter_00081014(int index,int value,undefined4 param)\n\n{\n  int result;\n  undefined4 data;\n  int pointer;\n  \n  if ((&DAT_00084b50)[index * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[index] & 0xf) == 5) {\n      FUN_00080f0c(index,1,param,5,index,value,param);\n    }\n    (&DAT_20070e1c)[index] = (&DAT_20070e1c)[index] & 0xf | (byte)(value << 4);\n    pointer = *(int *)(&DAT_00084b44 + index * 0x1c);\n    data = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n    result = FUN_00080a94(pointer,data);\n    if (result == 0) {\n      if (value != 0) {\n        *(undefined4 *)(pointer + 100) = data;\n        return;\n      }\n      *(undefined4 *)(pointer + 0x60) = data;\n      return;\n    }\n    FUN_00080a0a(pointer,data,value,0,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "update_parameter_00081014",
                "param_1": "index",
                "param_2": "value",
                "param_3": "param",
                "iVar1": "result",
                "uVar2": "data",
                "iVar3": "pointer"
            },
            "calling": [
                "FUN_00080250",
                "FUN_0008044c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_00080f0c",
                "FUN_00080a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "execute_function_000810a6",
            "code": "\nvoid executeFunction_000810a6(int *functionPointer,int inputValue,undefined4 arg1,undefined4 arg2)\n\n{\n  undefined4 returnValue;\n  \n  if (inputValue != 0) {\n    returnValue = FUN_00082688(inputValue);\n    (**(code **)(*functionPointer + 4))(functionPointer,inputValue,returnValue,*(code **)(*functionPointer + 4),arg2);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810a6": "execute_function_000810a6",
                "param_1": "functionPointer",
                "param_2": "inputValue",
                "param_3": "arg1",
                "param_4": "arg2",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_000810c4",
                "FUN_000810d8",
                "FUN_000810fc",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "execute_initialization_000810c4",
            "code": "\nvoid executeInitialization_000810c4(void)\n\n{\n  FUN_000810a6();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "execute_initialization_000810c4"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "execute_function_000810cc",
            "code": "\nvoid executeFunction_000810cc(undefined4 *functionPointer)\n\n{\n  (**(code **)*functionPointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810cc": "execute_function_000810cc",
                "param_1": "functionPointer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "initialize_data_000810d8",
            "code": "\nvoid initializeData_000810d8(undefined4 data1,undefined4 data2,undefined4 data3,undefined4 data4)\n\n{\n  FUN_000810a6(data1,&DAT_00085635,data3,data4,data4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "initialize_data_000810d8",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4"
            },
            "calling": [
                "FUN_0008117a",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "calculate_sum_000810e8",
            "code": "\nint calculateSum_000810e8(undefined4 inputValue)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_000810a6();\n  result2 = FUN_000810d8(inputValue);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_000810e8": "calculate_sum_000810e8",
                "param_1": "inputValue",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6",
                "FUN_000810d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "convert_decimal_to_base_000810fc",
            "code": "\nvoid convertDecimalToBase_000810fc(undefined4 inputBuffer,uint inputNumber,uint base)\n\n{\n  char *currentChar;\n  uint quotient;\n  char *previousChar;\n  char convertedDigit;\n  uint remainder;\n  char convertedNumber [5];\n  \n  convertedNumber[1] = 0;\n  if (base < 2) {\n    base = 10;\n  }\n  currentChar = convertedNumber;\n  do {\n    previousChar = currentChar;\n    quotient = inputNumber / base;\n    remainder = inputNumber - base * quotient & 0xff;\n    convertedDigit = (char)remainder;\n    if (remainder < 10) {\n      convertedDigit = convertedDigit + '0';\n    }\n    else {\n      convertedDigit = convertedDigit + '7';\n    }\n    *previousChar = convertedDigit;\n    inputNumber = quotient;\n    currentChar = previousChar + -1;\n  } while (quotient != 0);\n  FUN_000810a6(inputBuffer,previousChar);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "convert_decimal_to_base_000810fc",
                "param_1": "inputBuffer",
                "param_2": "inputNumber",
                "param_3": "base",
                "pcVar1": "currentChar",
                "uVar2": "quotient",
                "pcVar3": "previousChar",
                "cVar4": "convertedDigit",
                "uVar5": "remainder",
                "local_15": "convertedNumber"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "process_data_0008113a",
            "code": "\nint processData_0008113a(undefined4 *data,uint value,uint format,undefined4 param)\n\n{\n  int result;\n  int negativeResult;\n  \n  if (format == 0) {\n    result = (**(code **)*data)(data,value & 0xff);\n    return result;\n  }\n  if (format == 10) {\n    format = 10;\n    if ((int)value < 0) {\n      result = FUN_000810cc(data,0x2d);\n      negativeResult = FUN_000810fc(data,-value,10);\n      return negativeResult + result;\n    }\n  }\n  else {\n    format = format & 0xff;\n  }\n  result = FUN_000810fc(data,value,format,param);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0008113a": "process_data_0008113a",
                "param_1": "data",
                "param_2": "value",
                "param_3": "format",
                "param_4": "param",
                "iVar1": "result",
                "iVar2": "negativeResult"
            },
            "calling": [
                "thunk_FUN_0008113a",
                "FUN_0008117a"
            ],
            "called": [
                "FUN_000810cc",
                "FUN_000810fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_0008113a": {
            "entrypoint": "0x00081176",
            "current_name": "convert_number_thunk_0008113a",
            "code": "\nint convertNumber_thunk_0008113a(undefined4 *numberConverter,uint value,uint base,undefined4 extraParam)\n\n{\n  int result;\n  int negativeCount;\n  \n  if (base == 0) {\n    result = (**(code **)*numberConverter)(numberConverter,value & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)value < 0) {\n      result = FUN_000810cc(numberConverter,0x2d);\n      negativeCount = FUN_000810fc(numberConverter,-value,10);\n      return negativeCount + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(numberConverter,value,base,extraParam);\n  return result;\n}\n\n",
            "renaming": {
                "thunk_FUN_0008113a": "convert_number_thunk_0008113a",
                "param_1": "numberConverter",
                "param_2": "value",
                "param_3": "base",
                "param_4": "extraParam",
                "iVar1": "result",
                "iVar2": "negativeCount"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "calculate_sum_0008117a",
            "code": "\nint calculateSum_0008117a(undefined4 inputValue)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_0008113a();\n  result2 = FUN_000810d8(inputValue);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "calculate_sum_0008117a",
                "param_1": "inputValue",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810d8",
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "check_and_call_function_00081190",
            "code": "\nvoid checkAndCallFunction_00081190(void)\n\n{\n  if ((relocationTable[6].info != 0xffffffff) &&\n     (relocationTable[6].info = relocationTable[6].info - 1,\n     relocationTable[6].info == 0)) {\n    (*(code *)((int)&relocationTable[0].offset + 1))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "check_and_call_function_00081190",
                "Elf32_Rel_ARRAY_20070000": "relocationTable",
                "r_info": "info",
                "r_offset": "offset"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_memory_000811b0",
            "code": "\nint initializeMemory_000811b0(int memoryAddress)\n\n{\n  FUN_00081f00(memoryAddress,0,0x80);\n  *(undefined4 *)(memoryAddress + 0x80) = 0;\n  *(undefined4 *)(memoryAddress + 0x84) = 0;\n  return memoryAddress;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_memory_000811b0",
                "param_1": "memoryAddress"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "update_data_and_index_000811ca",
            "code": "\nvoid updateDataAndIndex_000811ca(int dataAddress,undefined newValue)\n\n{\n  uint updatedIndex;\n  \n  updatedIndex = *(int *)(dataAddress + 0x80) + 1U & 0x7f;\n  if (updatedIndex != *(uint *)(dataAddress + 0x84)) {\n    *(undefined *)(dataAddress + *(int *)(dataAddress + 0x80)) = newValue;\n    *(uint *)(dataAddress + 0x80) = updatedIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "update_data_and_index_000811ca",
                "param_1": "dataAddress",
                "param_2": "newValue",
                "uVar1": "updatedIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "process_data_000811e8",
            "code": "\nint processData_000811e8(int *data)\n\n{\n  int result;\n  \n  result = thunk_FUN_000816d8();\n  data[3] = result;\n  do {\n    result = (**(code **)(*data + 0xc))(data);\n    if (-1 < result) {\n      return result;\n    }\n    result = thunk_FUN_000816d8();\n  } while ((uint)(result - data[3]) < (uint)data[2]);\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811e8": "process_data_000811e8",
                "param_1": "data",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "thunk_FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "process_data_00081214",
            "code": "\nvoid processData_00081214(undefined4 dataPointer,undefined4 configPointer,uint targetValue)\n\n{\n  uint returnValue;\n  \n  FUN_000814f6(dataPointer,&DAT_00085637);\n  while ((returnValue = FUN_000811e8(configPointer), -1 < (int)returnValue && (returnValue != targetValue))) {\n    FUN_0008159e(dataPointer,returnValue & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081214": "process_data_00081214",
                "param_1": "dataPointer",
                "param_2": "configPointer",
                "param_3": "targetValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008159e",
                "FUN_000811e8",
                "FUN_000814f6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "calculate_difference_00081248",
            "code": "\nuint calculateDifference_00081248(int inputValue)\n\n{\n  return *(int *)(*(int *)(inputValue + 0x10) + 0x80) - *(int *)(*(int *)(inputValue + 0x10) + 0x84) &\n         0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "calculate_difference_00081248",
                "param_1": "inputValue"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080970"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "extract_byte_from_buffer_00081276",
            "code": "\nuint extractByteFromBuffer_00081276(int buffer)\n\n{\n  byte extractedByte;\n  int ptrBuffer;\n  \n  ptrBuffer = *(int *)(buffer + 0x10);\n  if (*(int *)(ptrBuffer + 0x80) != *(int *)(ptrBuffer + 0x84)) {\n    extractedByte = *(byte *)(ptrBuffer + *(int *)(ptrBuffer + 0x84));\n    *(uint *)(ptrBuffer + 0x84) = *(int *)(ptrBuffer + 0x84) + 1U & 0x7f;\n    return (uint)extractedByte;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081276": "extract_byte_from_buffer_00081276",
                "param_1": "buffer",
                "bVar1": "extractedByte",
                "iVar2": "ptrBuffer"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "update_value_000812b8",
            "code": "\nundefined4 updateValue_000812b8(int structPtr,undefined4 newValue)\n\n{\n  int structVar1;\n  uint updatedValue;\n  \n  structVar1 = *(int *)(structPtr + 0x14);\n  if ((*(int *)(*(int *)(structPtr + 0x18) + 0x14) << 0x1e < 0) &&\n     (*(int *)(structVar1 + 0x84) == *(int *)(structVar1 + 0x80))) {\n    *(undefined4 *)(*(int *)(structPtr + 0x18) + 0x1c) = newValue;\n  }\n  else {\n    updatedValue = *(int *)(structVar1 + 0x80) + 1U & 0x8000007f;\n    if ((int)updatedValue < 0) {\n      updatedValue = (updatedValue - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (*(uint *)(structVar1 + 0x84) == updatedValue);\n    *(char *)(structVar1 + *(int *)(structVar1 + 0x80)) = (char)newValue;\n    *(uint *)(*(int *)(structPtr + 0x14) + 0x80) = updatedValue;\n    *(undefined4 *)(*(int *)(structPtr + 0x18) + 8) = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "update_value_000812b8",
                "param_1": "structPtr",
                "param_2": "newValue",
                "iVar1": "structVar1",
                "uVar2": "updatedValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_function_params_00081348",
            "code": "\nvoid initializeFunctionParams_00081348(undefined4 *functionParams,undefined4 param2,undefined param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6)\n\n{\n  functionParams[1] = 0;\n  functionParams[2] = 1000;\n  functionParams[6] = param2;\n  *functionParams = &PTR_FUN_000812b8_1_00085650;\n  *(undefined *)(functionParams + 7) = param3;\n  functionParams[4] = param5;\n  functionParams[8] = param4;\n  functionParams[5] = param6;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_function_params_00081348",
                "param_1": "functionParams",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6"
            },
            "calling": [
                "FUN_00081438",
                "FUN_0008089c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_data_000813dc",
            "code": "\nvoid initializeData_000813dc(int dataPointer,uint divisor)\n\n{\n  int pointer1;\n  undefined4 *pointer2;\n  \n  FUN_00080aa8(*(undefined4 *)(dataPointer + 0x20));\n  pointer2 = *(undefined4 **)(dataPointer + 0x18);\n  pointer2[0x48] = 0x202;\n  *pointer2 = 0xac;\n  pointer2[1] = 0x800;\n  pointer2[8] = Elf32_Rel_ARRAY_20070000[6].r_offset / divisor >> 4;\n  pointer2[3] = 0xffffffff;\n  pointer2[2] = 0x61;\n  *(int *)(((uint)(int)(char)*(byte *)(dataPointer + 0x1c) >> 5) * 4 + -0x1fff1f00) =\n       1 << (uint)(*(byte *)(dataPointer + 0x1c) & 0x1f);\n  pointer1 = *(int *)(dataPointer + 0x10);\n  *(undefined4 *)(pointer1 + 0x84) = 0;\n  *(undefined4 *)(pointer1 + 0x80) = 0;\n  pointer1 = *(int *)(dataPointer + 0x14);\n  *(undefined4 *)(pointer1 + 0x84) = 0;\n  *(undefined4 *)(pointer1 + 0x80) = 0;\n  *pointer2 = 0x50;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_data_000813dc",
                "param_1": "dataPointer",
                "param_2": "divisor",
                "iVar1": "pointer1",
                "puVar2": "pointer2"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080aa8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "initialize_function_00081438",
            "code": "\nundefined4 * initializeFunction_00081438(undefined4 *outputPointer,undefined4 inputValue)\n\n{\n  FUN_00081348();\n  *outputPointer = &PTR_FUN_000812b8_1_00085680;\n  outputPointer[9] = inputValue;\n  return outputPointer;\n}\n\n",
            "renaming": {
                "FUN_00081438": "initialize_function_00081438",
                "param_1": "outputPointer",
                "param_2": "inputValue"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "calculate_param_0008145c",
            "code": "\nint calculate_param_0008145c(int input_value,int start_range,int end_range,int start_output,int end_output)\n\n{\n  return (uint)((input_value - start_range) * (end_output - start_output)) / (uint)(end_range - start_range) + start_output;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "calculate_param_0008145c",
                "param_1": "input_value",
                "param_2": "start_range",
                "param_3": "end_range",
                "param_4": "start_output",
                "param_5": "end_output"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000806f8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "execute_function_00081472",
            "code": "\nundefined4 * executeFunction_00081472(undefined4 *functionPointer)\n\n{\n  FUN_00081800(*functionPointer);\n  return functionPointer;\n}\n\n",
            "renaming": {
                "FUN_00081472": "execute_function_00081472",
                "param_1": "functionPointer"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "clear_memory_00081480",
            "code": "\nvoid clearMemory_00081480(int *memoryPtr)\n\n{\n  if (*memoryPtr != 0) {\n    FUN_00081800();\n  }\n  *memoryPtr = 0;\n  memoryPtr2 = 0;\n  memoryPtr1 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081480": "clear_memory_00081480",
                "param_1": "memoryPtr",
                "param_1[2]": "memoryPtr2",
                "param_1[1]": "memoryPtr1"
            },
            "calling": [
                "FUN_000814d0"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "update_param_and_check_00081496",
            "code": "\nint updateParamAndCheck_00081496(int *paramArray,int paramValue,undefined4 arg1,undefined4 arg2)\n\n{\n  int result;\n  \n  result = FUN_00081f9c(*paramArray,paramValue + 1,arg1,arg2,arg2);\n  if (result != 0) {\n    *paramArray = result;\n    paramArray[1] = paramValue;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081496": "update_param_and_check_00081496",
                "param_1": "paramArray",
                "param_2": "paramValue",
                "param_3": "arg1",
                "param_4": "arg2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814ae"
            ],
            "called": [
                "FUN_00081f9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "check_and_update_value_000814ae",
            "code": "\nundefined4 check_and_update_value_000814ae(int *values,uint threshold)\n\n{\n  int result;\n  \n  if ((*values == 0) || ((uint)values[1] < threshold)) {\n    result = FUN_00081496(values);\n    if (result == 0) {\n      return 0;\n    }\n    if (values[2] == 0) {\n      *(undefined *)*values = 0;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000814ae": "check_and_update_value_000814ae",
                "param_1": "values",
                "param_2": "threshold",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [
                "FUN_00081496"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "update_data_000814d0",
            "code": "\nundefined4 * updateData_000814d0(undefined4 *array,undefined4 value1,undefined4 value2)\n\n{\n  int result;\n  \n  result = FUN_000814ae(array,value2);\n  if (result == 0) {\n    FUN_00081480(array);\n  }\n  else {\n    array[2] = value2;\n    FUN_000825cc(*array,value1);\n  }\n  return array;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "update_data_000814d0",
                "param_1": "array",
                "param_2": "value1",
                "param_3": "value2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814f6"
            ],
            "called": [
                "FUN_00081480",
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "initialize_param_array_000814f6",
            "code": "\nundefined4 * initializeParamArray_000814f6(undefined4 *paramArray,int inputValue)\n\n{\n  undefined4 result;\n  \n  *paramArray = 0;\n  paramArray[1] = 0;\n  paramArray[2] = 0;\n  if (inputValue != 0) {\n    result = FUN_00082688(inputValue);\n    FUN_000814d0(paramArray,inputValue,result);\n  }\n  return paramArray;\n}\n\n",
            "renaming": {
                "FUN_000814f6": "initialize_param_array_000814f6",
                "param_1": "paramArray",
                "param_2": "inputValue",
                "uVar1": "result",
                "param_1[1]": "paramArray[1]",
                "param_1[2]": "paramArray[2]"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_000814d0",
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "update_parameters_0008151c",
            "code": "\nvoid updateParameters_0008151c(int *source,int *destination)\n\n{\n  if (*source != 0) {\n    if ((*destination != 0) && ((uint)destination[2] <= (uint)source[1])) {\n      FUN_000825cc();\n      source[2] = destination[2];\n      goto skipUpdate;\n    }\n    FUN_00081800();\n  }\n  *source = *destination;\n  source[1] = destination[1];\n  source[2] = destination[2];\n  *destination = 0;\n  destination[1] = 0;\nskipUpdate:\n  destination[2] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008151c": "update_parameters_0008151c",
                "param_1": "source",
                "param_2": "destination",
                "LAB_00081558": "skipUpdate",
                "(uint)param_2[2]": "(uint)destination[2]",
                "(uint)param_1[1]": "(uint)source[1]"
            },
            "calling": [
                "FUN_00081560"
            ],
            "called": [
                "FUN_00081800",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "compare_and_execute_00081560",
            "code": "\nint compare_and_execute_00081560(int value1,int value2)\n\n{\n  if (value1 != value2) {\n    FUN_0008151c();\n  }\n  return value1;\n}\n\n",
            "renaming": {
                "FUN_00081560": "compare_and_execute_00081560",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008151c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "validate_and_update_data_00081570",
            "code": "\nundefined4 validateAndUpdateData_00081570(int *data,int length,int offset)\n\n{\n  int result;\n  int value;\n  \n  value = data[2];\n  if (length == 0) {\n    return 0;\n  }\n  if (offset != 0) {\n    result = FUN_000814ae(data,value + offset);\n    if (result == 0) {\n      return 0;\n    }\n    FUN_000825cc(*data + data[2],length);\n    data[2] = value + offset;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081570": "validate_and_update_data_00081570",
                "param_1": "data",
                "param_2": "length",
                "param_3": "offset",
                "iVar1": "result",
                "iVar2": "value"
            },
            "calling": [
                "FUN_0008159e"
            ],
            "called": [
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "decompile_and_execute_0008159e",
            "code": "\nvoid decompile_and_execute_0008159e(undefined4 input_param,undefined4 unused_param,undefined4 execution_param)\n\n{\n  undefined4 stack_variable_c;\n  undefined4 stack_variable_8;\n  \n  stack_variable_8 = execution_param;\n  FUN_00081570(input_param,&stack_variable_c,1,0,input_param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008159e": "decompile_and_execute_0008159e",
                "param_1": "input_param",
                "param_2": "unused_param",
                "param_3": "execution_param",
                "local_c": "stack_variable_c",
                "uStack_8": "stack_variable_8"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_00081570"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "check_input_validity_000815b8",
            "code": "\nint check_input_validity_000815b8(byte **input_data,byte *input_ptr)\n\n{\n  uint data_length;\n  int result;\n  \n  if (input_data[2] == (byte *)0x0) {\n    if (input_ptr == (byte *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    if (input_ptr != (byte *)0x0) {\n      data_length = FUN_00082390(*input_data);\n      goto LAB_000815d4;\n    }\n    input_ptr = *input_data;\n  }\n  data_length = (uint)*input_ptr;\nLAB_000815d4:\n  result = 1 - data_length;\n  if (1 < data_length) {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000815b8": "check_input_validity_000815b8",
                "param_1": "input_data",
                "param_2": "input_ptr",
                "uVar1": "data_length",
                "iVar2": "result"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00082390"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "parse_integer_000815de",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000827e8) */\n/* WARNING: Removing unreachable block (ram,0x000827a8) */\n/* WARNING: Removing unreachable block (ram,0x000827a0) */\n/* WARNING: Removing unreachable block (ram,0x000827da) */\n/* WARNING: Removing unreachable block (ram,0x000827ec) */\n/* WARNING: Removing unreachable block (ram,0x000827e4) */\n/* WARNING: Removing unreachable block (ram,0x000827a4) */\n/* WARNING: Removing unreachable block (ram,0x0008278a) */\n/* WARNING: Removing unreachable block (ram,0x000827c8) */\n/* WARNING: Removing unreachable block (ram,0x0008278c) */\n\nuint parseInteger_000815de(byte **input)\n\n{\n  byte tempByte1;\n  byte tempByte2;\n  uint result;\n  byte *currentByte;\n  uint byteValue;\n  byte *nextByte;\n  int adjustedValue;\n  int isNegative;\n  uint maxDividend;\n  uint signFlag;\n  \n  currentByte = *input;\n  if (*input == (byte *)0x0) {\n    return 0;\n  }\n  do {\n    nextByte = currentByte;\n    currentByte = nextByte + 1;\n    byteValue = (uint)*nextByte;\n    tempByte1 = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + byteValue + 1);\n    tempByte2 = tempByte1 & 8;\n  } while ((tempByte1 & 8) != 0);\n  if (byteValue == 0x2d) {\n    currentByte = nextByte + 2;\n    byteValue = (uint)nextByte[1];\n    tempByte2 = 1;\n  }\n  else if (byteValue == 0x2b) {\n    byteValue = (uint)nextByte[1];\n    currentByte = nextByte + 2;\n  }\n  if (tempByte2 == 0) {\n    signFlag = 0x7fffffff;\n  }\n  else {\n    signFlag = 0x80000000;\n  }\n  maxDividend = signFlag / 10;\n  isNegative = 0;\n  result = 0;\n  do {\n    tempByte1 = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + byteValue + 1);\n    if ((tempByte1 & 4) == 0) {\n      if ((tempByte1 & 3) == 0) {\nLAB_0008277e:\n        if (isNegative == -1) {\n          if (tempByte2 == 0) {\n            result = 0x7fffffff;\n          }\n          else {\n            result = 0x80000000;\n          }\n          *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x22;\n        }\n        else if (tempByte2 != 0) {\n          result = -result;\n        }\n        return result;\n      }\n      if ((tempByte1 & 3) == 1) {\n        adjustedValue = 0x37;\n      }\n      else {\n        adjustedValue = 0x57;\n      }\n      adjustedValue = byteValue - adjustedValue;\n    }\n    else {\n      adjustedValue = byteValue - 0x30;\n    }\n    if (9 < adjustedValue) goto LAB_0008277e;\n    if (isNegative != -1) {\n      if ((maxDividend <= result && result != maxDividend) || ((result == maxDividend && ((int)(signFlag % 10) < adjustedValue))))\n      {\n        isNegative = -1;\n      }\n      else {\n        result = result * 10 + adjustedValue;\n        isNegative = 1;\n      }\n    }\n    byteValue = (uint)*currentByte;\n    currentByte = currentByte + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815de": "parse_integer_000815de",
                "param_1": "input",
                "bVar1": "tempByte1",
                "bVar2": "tempByte2",
                "uVar3": "result",
                "pbVar4": "currentByte",
                "uVar5": "byteValue",
                "pbVar6": "nextByte",
                "iVar7": "adjustedValue",
                "iVar8": "isNegative",
                "uVar9": "maxDividend",
                "uVar10": "signFlag"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "execute_main_function_000815ec",
            "code": "\nvoid executeMainFunction_000815ec(void)\n\n{\n  FUN_00081618();\n  FUN_00080774();\n  FUNC_000815e8();\n  FUNC_00080f08(1);\n  FUN_000801e0();\n  do {\n    FUN_00080250();\n    FUN_00080970();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "execute_main_function_000815ec"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00080250",
                "FUN_00080970",
                "FUN_000801e0",
                "FUN_000815e8",
                "FUN_00081618",
                "FUN_00080f08",
                "FUN_00080774"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "initialize_memory_00081618",
            "code": "\n\n\nvoid initializeMemory_00081618(void)\n\n{\n  _DAT_400e1a54 = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "initialize_memory_00081618"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "calculate_result_00081624",
            "code": "\nint calculateResult_00081624(int index,int flag,int multiplier,undefined4 param_4)\n\n{\n  int result;\n  undefined4 value;\n  \n  value = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n  if (flag == 0) {\n    value = 0;\n  }\n  result = FUN_00081684(*(int *)(&DAT_00084b44 + index * 0x1c) + 0x3c,\n                       *(undefined4 *)(&DAT_00084b48 + index * 0x1c),value,\n                       ((Rel_ARRAY[6].r_offset / 1000000) * multiplier) / 0x12,param_4);\n  if (result != 0) {\n    result = (int)((ulonglong)(result * 18000 + 16000) /\n                 ((ulonglong)Rel_ARRAY[6].r_offset / 1000));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081624": "calculate_result_00081624",
                "param_1": "index",
                "param_2": "flag",
                "param_3": "multiplier",
                "iVar1": "result",
                "uVar2": "value",
                "Elf32_Rel_ARRAY_20070000": "Rel_ARRAY"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081684"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_value_count_00081684",
            "code": "\nint check_value_count_00081684(uint *data_ptr,uint mask,uint expected_value,int max_iterations)\n\n{\n  int iteration_count;\n  \n  do {\n    if ((*data_ptr & mask) != expected_value) {\n      do {\n        if ((*data_ptr & mask) == expected_value) {\n          iteration_count = 0;\n          do {\n            if ((*data_ptr & mask) != expected_value) {\n              return iteration_count;\n            }\n            iteration_count = iteration_count + 1;\n          } while (max_iterations != iteration_count);\n          return 0;\n        }\n        max_iterations = max_iterations + -1;\n      } while (max_iterations != 0);\n      return 0;\n    }\n    max_iterations = max_iterations + -1;\n  } while (max_iterations != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_value_count_00081684",
                "param_1": "data_ptr",
                "param_2": "mask",
                "param_3": "expected_value",
                "param_4": "max_iterations",
                "iVar1": "iteration_count"
            },
            "calling": [
                "FUN_00081624"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_return_value_000816d8",
            "code": "\nundefined4 getReturnValue_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_return_value_000816d8"
            },
            "calling": [
                "thunk_FUN_000816d8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "update_data_000816ec",
            "code": "\nvoid updateData_000816ec(dword dataValue1,dword dataValue2,dword dataValue3)\n\n{\n  dword *dataPtr;\n  uint index;\n  uint bitMask;\n  code *jumpTable;\n  \n  if (relArray[48].r_offset == 0) {\n    relArray[48].r_offset = 0x20070184;\n  }\n  index = *(uint *)(relArray[48].r_offset + 4);\n  dataPtr = (dword *)relArray[48].r_offset;\n  if (0x1f < (int)index) {\n    dataPtr = (dword *)FUN_000817f0(400);\n    if (dataPtr == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)(0xffffffff);\n      return;\n    }\n    *dataPtr = relArray[48].r_offset;\n    dataPtr[1] = 0;\n    index = 0;\n    relArray[48].r_offset = (dword)dataPtr;\n    dataPtr[0x62] = 0;\n    dataPtr[99] = 0;\n  }\n  bitMask = 1 << (index & 0xff);\n  dataPtr[index + 0x22] = dataValue1;\n  dataPtr[0x62] = dataPtr[0x62] | bitMask;\n  dataPtr[index + 0x42] = dataValue3;\n  dataPtr[99] = bitMask | dataPtr[99];\n  dataPtr[1] = index + 1;\n  dataPtr[index + 2] = dataValue2;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "update_data_000816ec",
                "param_1": "dataValue1",
                "param_2": "dataValue2",
                "param_3": "dataValue3",
                "pdVar1": "dataPtr",
                "uVar2": "index",
                "uVar3": "bitMask",
                "UNRECOVERED_JUMPTABLE_00": "jumpTable",
                "Elf32_Rel_ARRAY_20070000": "relArray"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "print_assert_failed_message_000816f8",
            "code": "\nvoid printAssertFailedMessage_000816f8(undefined4 file,undefined4 line,char *assertion,undefined4 function)\n\n{\n  undefined4 filePtr;\n  undefined4 functionPtr;\n  char *prefix;\n  undefined8 timestamp;\n  \n  filePtr = *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0xc);\n  if (assertion == (char *)0x0) goto LAB_0008171c;\n  functionPtr = function;\n  prefix = \", function: \";\n  do {\n    function = file;\n    FUN_00081750(filePtr,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",functionPtr,file,line,\n                 prefix,assertion);\n    timestamp = FUN_000836ec();\n    line = (undefined4)((ulonglong)timestamp >> 0x20);\n    filePtr = (undefined4)timestamp;\nLAB_0008171c:\n    assertion = \"\";\n    functionPtr = function;\n    prefix = assertion;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816f8": "print_assert_failed_message_000816f8",
                "param_1": "file",
                "param_2": "line",
                "param_3": "assertion",
                "param_4": "function",
                "uVar1": "filePtr",
                "uVar2": "functionPtr",
                "pcVar3": "prefix",
                "uVar4": "timestamp"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080b2c"
            ],
            "called": [
                "FUN_00081750",
                "FUN_000836ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "execute_relocation_00081750",
            "code": "\nvoid executeRelocation_00081750(undefined4 functionOffset,undefined4 param2,undefined4 relocationBase,undefined4 stackParameter)\n\n{\n  undefined4 relocatedValue;\n  undefined4 relocationOffset;\n  \n  relocatedValue = relocationBase;\n  relocationOffset = stackParameter;\n  FUN_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,functionOffset,param2,&relocatedValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "execute_relocation_00081750",
                "param_1": "functionOffset",
                "param_2": "param2",
                "param_3": "relocationBase",
                "param_4": "stackParameter",
                "uStack_8": "relocatedValue",
                "uStack_4": "relocationOffset"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "execute_function_set_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid executeFunctionSet_00081778(void)\n\n{\n  int iterationCount;\n  code **functionPointer;\n  \n  FUNC_00085844();\n  functionPointer = (code **)0x8584c;\n  iterationCount = 0;\n  do {\n    iterationCount = iterationCount + 1;\n    functionPointer = functionPointer + 1;\n    (**functionPointer)();\n  } while (iterationCount != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "execute_function_set_00081778",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointer"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080118",
                "FUN_00085844",
                "FUN_000836d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "execute_function_000817c8",
            "code": "\nvoid executeFunction_000817c8(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 stackParam1;\n  undefined4 stackParam2;\n  undefined4 stackParam3;\n  \n  stackParam1 = param2;\n  stackParam2 = param3;\n  stackParam3 = param4;\n  FUN_0008289c(relArray[140].r_offset,\n               *(undefined4 *)(relArray[140].r_offset + 8),param1,&stackParam1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "execute_function_000817c8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uStack_c": "stackParam1",
                "uStack_8": "stackParam2",
                "uStack_4": "stackParam3",
                "Elf32_Rel_ARRAY_20070000": "relArray"
            },
            "calling": [
                "FUN_00080eec"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "execute_relocation_000817f0",
            "code": "\nvoid executeRelocation_000817f0(undefined4 param)\n\n{\n  FUN_00081810(relArray[140].relocationOffset,param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "execute_relocation_000817f0",
                "param_1": "param",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                "r_offset": "relocationOffset"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "execute_elf32_relocation_00081800",
            "code": "\nvoid executeElf32Relocation_00081800(undefined4 data)\n\n{\n  FUN_00083b10(relArray[140].offset,data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "execute_elf32_relocation_00081800",
                "param_1": "data",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_00081472",
                "FUN_00081480"
            ],
            "called": [
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "allocate_memory_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_00081810(undefined4 *output_ptr,uint size)\n\n{\n  dword temp22;\n  int temp1;\n  uint temp24;\n  uint temp3;\n  int temp4;\n  uint temp16;\n  dword temp23;\n  uint temp6;\n  int temp7;\n  undefined *temp_ptr1;\n  dword temp21;\n  dword temp19;\n  int temp20;\n  dword *temp_ptr2;\n  uint temp15;\n  undefined *temp_ptr3;\n  dword *temp_ptr4;\n  uint temp12;\n  \n  if (size + 0xb < 0x17) {\n    temp15 = 0x10;\n    if (0x10 < size) goto LAB_00081876;\n  }\n  else {\n    temp15 = size + 0xb & 0xfffffff8;\n    if (((int)temp15 < 0) || (temp15 < size)) {\nLAB_00081876:\n      *output_ptr = 0xc;\n      return (int *)0x0;\n    }\n  }\n  FUNC_00081f94(output_ptr);\n  temp22 = Elf32_Rel_ARRAY_20070000[142].r_info;\n  if (temp15 < 0x1f8) {\n    temp20 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8e].r_offset + temp15);\n    if ((temp20 != temp15 + 0x20070464) ||\n       (temp1 = temp20 + 8, temp20 = *(int *)(temp20 + 0x14), temp1 != temp20)) {\n      temp4 = *(int *)(temp20 + 0xc);\n      temp7 = (*(uint *)(temp20 + 4) & 0xfffffffc) + temp20;\n      temp15 = *(uint *)(temp7 + 4);\n      temp1 = *(int *)(temp20 + 8);\n      *(int *)(temp1 + 0xc) = temp4;\n      *(int *)(temp4 + 8) = temp1;\n      *(uint *)(temp7 + 4) = temp15 | 1;\n      FUNC_00081f98(output_ptr);\n      return (int *)(temp20 + 8);\n    }\n    temp12 = (temp15 >> 3) + 2;\n  }\n  else {\n    temp12 = temp15 >> 9;\n    if (temp12 == 0) {\n      temp1 = 0x7e;\n      temp20 = 0x3f;\n    }\n    else if (temp12 < 5) {\n      temp20 = (temp15 >> 6) + 0x38;\n      temp1 = temp20 * 2;\n    }\n    else if (temp12 < 0x15) {\n      temp20 = temp12 + 0x5b;\n      temp1 = temp20 * 2;\n    }\n    else if (temp12 < 0x55) {\n      temp20 = (temp15 >> 0xc) + 0x6e;\n      temp1 = temp20 * 2;\n    }\n    else if (temp12 < 0x155) {\n      temp20 = (temp15 >> 0xf) + 0x77;\n      temp1 = temp20 * 2;\n    }\n    else if (temp12 < 0x555) {\n      temp20 = (temp15 >> 0x12) + 0x7c;\n      temp1 = temp20 * 2;\n    }\n    else {\n      temp1 = 0xfc;\n      temp20 = 0x7e;\n    }\n    for (temp23 = (&Elf32_Rel_ARRAY_20070000[0x8e].r_offset)[temp1]; temp1 * 4 + 0x20070464U != temp23\n        ; temp23 = *(dword *)(temp23 + 0xc)) {\n      temp12 = *(uint *)(temp23 + 4) & 0xfffffffc;\n      temp4 = temp12 - temp15;\n      if (0xf < temp4) {\n        temp20 = temp20 + -1;\n        break;\n      }\n      if (-1 < temp4) {\n        temp1 = temp12 + temp23;\n        temp15 = *(uint *)(temp1 + 4);\n        temp4 = *(int *)(temp23 + 0xc);\n        temp20 = *(int *)(temp23 + 8);\n        *(int *)(temp20 + 0xc) = temp4;\n        *(int *)(temp4 + 8) = temp20;\n        *(uint *)(temp1 + 4) = temp15 | 1;\n        FUNC_00081f98(output_ptr);\n        return (int *)(temp23 + 8);\n      }\n    }\n    temp12 = temp20 + 1;\n  }\n  temp23 = Elf32_Rel_ARRAY_20070000[141].r_offset;\n  if (Elf32_Rel_ARRAY_20070000[142].r_info != 0x2007046c) {\n    temp24 = *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4);\n    temp3 = temp24 & 0xfffffffc;\n    temp16 = temp3 - temp15;\n    if (0xf < (int)temp16) {\n      temp23 = temp15 + Elf32_Rel_ARRAY_20070000[142].r_info;\n      *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4) = temp15 | 1;\n      Elf32_Rel_ARRAY_20070000[142].r_info = temp23;\n      Elf32_Rel_ARRAY_20070000[143].r_offset = temp23;\n      *(undefined4 *)(temp23 + 0xc) = 0x2007046c;\n      *(undefined4 *)(temp23 + 8) = 0x2007046c;\n      *(uint *)(temp23 + 4) = temp16 | 1;\n      *(uint *)(temp23 + temp16) = temp16;\n      FUNC_00081f98(output_ptr);\n      return (int *)(temp22 + 8);\n    }\n    Elf32_Rel_ARRAY_20070000[143].r_offset = 0x2007046c;\n    Elf32_Rel_ARRAY_20070000[142].r_info = 0x2007046c;\n    if (-1 < (int)temp16) {\n      *(uint *)(temp3 + temp22 + 4) = *(uint *)(temp3 + temp22 + 4) | 1;\n      FUNC_00081f98(output_ptr);\n      return (int *)(temp22 + 8);\n    }\n    if (temp3 < 0x200) {\n      temp3 = temp24 & 0xfffffff8;\n      temp20 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + temp3);\n      temp23 = 1 << ((int)(temp24 >> 3) >> 2 & 0xffU) | Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(int *)(temp22 + 8) = temp20;\n      *(uint *)(temp22 + 0xc) = temp3 + 0x20070464;\n      Elf32_Rel_ARRAY_20070000[141].r_offset = temp23;\n      *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + temp3) = temp22;\n      *(dword *)(temp20 + 0xc) = temp22;\n    }\n    else {\n      temp16 = temp24 >> 9;\n      if (temp16 < 5) {\n        temp1 = (temp24 >> 6) + 0x38;\n        temp20 = temp1 * 2;\n      }\n      else if (temp16 < 0x15) {\n        temp1 = temp16 + 0x5b;\n        temp20 = temp1 * 2;\n      }\n      else if (temp16 < 0x55) {\n        temp1 = (temp24 >> 0xc) + 0x6e;\n        temp20 = temp1 * 2;\n      }\n      else if (temp16 < 0x155) {\n        temp1 = (temp24 >> 0xf) + 0x77;\n        temp20 = temp1 * 2;\n      }\n      else if (temp16 < 0x555) {\n        temp1 = (temp24 >> 0x12) + 0x7c;\n        temp20 = temp1 * 2;\n      }\n      else {\n        temp20 = 0xfc;\n        temp1 = 0x7e;\n      }\n      temp23 = temp20 * 4 + 0x20070464;\n      temp21 = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[temp20];\n      if (temp21 == temp23) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (temp1 >> 2 & 0xffU);\n        temp19 = temp21;\n      }\n      else {\n        do {\n          temp19 = temp21;\n          if ((*(uint *)(temp21 + 4) & 0xfffffffc) <= temp3) break;\n          temp21 = *(dword *)(temp21 + 8);\n          temp19 = temp21;\n        } while (temp23 != temp21);\n        temp21 = *(dword *)(temp19 + 0xc);\n      }\n      temp23 = Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(dword *)(temp22 + 0xc) = temp21;\n      *(dword *)(temp22 + 8) = temp19;\n      *(dword *)(temp21 + 8) = temp22;\n      *(dword *)(temp19 + 0xc) = temp22;\n    }\n  }\n  temp22 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  temp24 = 1 << ((int)temp12 >> 2 & 0xffU);\n  if (temp24 <= temp23) {\n    if ((temp23 & temp24) == 0) {\n      temp12 = temp12 & 0xfffffffc;\n      do {\n        temp24 = temp24 << 1;\n        temp12 = temp12 + 4;\n      } while ((temp23 & temp24) == 0);\n    }\n    do {\n      temp_ptr4 = &Elf32_Rel_ARRAY_20070000[temp12 + 0x8c].r_info;\n      temp_ptr2 = temp_ptr4;\n      temp3 = temp12;\n      do {\n        for (temp_ptr1 = (undefined *)temp_ptr2[3]; temp_ptr2 != (dword *)temp_ptr1;\n            temp_ptr1 = *(undefined **)(temp_ptr1 + 0xc)) {\n          temp16 = *(uint *)(temp_ptr1 + 4) & 0xfffffffc;\n          temp6 = temp16 - temp15;\n          if (0xf < (int)temp6) {\n            temp1 = *(int *)(temp_ptr1 + 8);\n            temp20 = *(int *)(temp_ptr1 + 0xc);\n            temp_ptr3 = temp_ptr1 + temp15;\n            *(uint *)(temp_ptr1 + 4) = temp15 | 1;\n            *(int *)(temp1 + 0xc) = temp20;\n            *(int *)(temp20 + 8) = temp1;\n            Elf32_Rel_ARRAY_20070000[142].r_info = (dword)temp_ptr3;\n            Elf32_Rel_ARRAY_20070000[143].r_offset = (dword)temp_ptr3;\n            *(undefined4 *)(temp_ptr3 + 0xc) = 0x2007046c;\n            *(undefined4 *)(temp_ptr3 + 8) = 0x2007046c;\n            *(uint *)(temp_ptr3 + 4) = temp6 | 1;\n            *(uint *)(temp_ptr3 + temp6) = temp6;\n            FUNC_00081f98(output_ptr);\n            return (int *)(temp_ptr1 + 8);\n          }\n          if (-1 < (int)temp6) {\n            temp20 = *(int *)(temp_ptr1 + 8);\n            temp1 = *(int *)(temp_ptr1 + 0xc);\n            *(uint *)(temp_ptr1 + temp16 + 4) = *(uint *)(temp_ptr1 + temp16 + 4) | 1;\n            *(int *)(temp20 + 0xc) = temp1;\n            *(int *)(temp1 + 8) = temp20;\n            FUNC_00081f98(output_ptr);\n            return (int *)(temp_ptr1 + 8);\n          }\n        }\n        temp3 = temp3 + 1;\n        temp_ptr2 = temp_ptr2 + 2;\n      } while ((temp3 & 3) != 0);\n      do {\n        temp16 = temp12 & 3;\n        temp_ptr1 = (undefined *)(temp_ptr4 + -2);\n        temp12 = temp12 - 1;\n        if (temp16 == 0) {\n          Elf32_Rel_ARRAY_20070000[141].r_offset = Elf32_Rel_ARRAY_20070000[141].r_offset & ~temp24;\n          break;\n        }\n        temp_ptr4 = (dword *)*temp_ptr4;\n      } while (temp_ptr4 == (dword *)temp_ptr1);\n      temp24 = temp24 * 2;\n      if ((Elf32_Rel_ARRAY_20070000[141].r_offset <= temp24 &&\n           temp24 - Elf32_Rel_ARRAY_20070000[141].r_offset != 0) || (temp12 = temp3, temp24 == 0))\n      break;\n      for (; (Elf32_Rel_ARRAY_20070000[141].r_offset & temp24) == 0; temp24 = temp24 << 1) {\n        temp12 = temp12 + 4;\n      }\n    } while( true );\n  }\n  temp12 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  if ((temp15 <= temp12) &&\n     (temp24 = temp12 - temp15, temp23 = Elf32_Rel_ARRAY_20070000[141].r_info, 0xf < (int)temp24))\n  goto LAB_00081b1a;\n  temp24 = Elf32_Rel_ARRAY_20070000[141].r_info + temp12;\n  if (Elf32_Rel_ARRAY_20070000[270].r_offset == 0xffffffff) {\n    temp3 = temp15 + DAT_20071218 + 0x10;\n  }\n  else {\n    temp3 = temp15 + DAT_20071218 + 0x100f & 0xfffff000;\n  }\n  temp23 = FUN_0008236c(output_ptr,temp3);\n  if ((temp23 == 0xffffffff) || ((temp23 < temp24 && (temp22 != 0x20070464)))) {\n    temp12 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    temp23 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\n  else {\n    temp16 = DAT_2007121c + temp3;\n    DAT_2007121c = temp16;\n    if ((temp24 == temp23) && ((temp24 & 0xfff) == 0)) {\n      *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = temp3 + temp12 | 1;\n    }\n    else {\n      temp21 = temp23;\n      if (Elf32_Rel_ARRAY_20070000[270].r_offset != 0xffffffff) {\n        temp21 = Elf32_Rel_ARRAY_20070000[270].r_offset;\n        DAT_2007121c = temp16 + (temp23 - temp24);\n      }\n      Elf32_Rel_ARRAY_20070000[270].r_offset = temp21;\n      temp24 = temp23 & 7;\n      if (temp24 == 0) {\n        temp20 = 0x1000;\n      }\n      else {\n        temp23 = temp23 + (8 - temp24);\n        temp20 = 0x1008 - temp24;\n      }\n      temp20 = temp20 - (temp3 + temp23 & 0xfff);\n      temp1 = FUN_0008236c(output_ptr,temp20);\n      if (temp1 == -1) {\n        temp24 = 1;\n        temp20 = 0;\n      }\n      else {\n        temp24 = (temp1 - temp23) + temp20 | 1;\n      }\n      temp16 = DAT_2007121c + temp20;\n      Elf32_Rel_ARRAY_20070000[141].r_info = temp23;\n      DAT_2007121c = temp16;\n      *(uint *)(temp23 + 4) = temp24;\n      if (temp22 != 0x20070464) {\n        if (temp12 < 0x10) {\n          *(undefined4 *)(temp23 + 4) = 1;\n          temp12 = 0;\n          goto LAB_00081b04;\n        }\n        temp12 = temp12 - 0xc & 0xfffffff8;\n        *(uint *)(temp22 + 4) = temp12 | *(uint *)(temp22 + 4) & 1;\n        *(undefined4 *)(temp22 + temp12 + 4) = 5;\n        *(undefined4 *)(temp22 + temp12 + 8) = 5;\n        if (0xf < temp12) {\n          FUN_00083b10(output_ptr,temp22 + 8);\n          temp16 = DAT_2007121c;\n        }\n      }\n    }\n    if (DAT_20071214 < temp16) {\n      DAT_20071214 = temp16;\n    }\n    if (DAT_20071210 < temp16) {\n      DAT_20071210 = temp16;\n    }\n    temp12 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    temp23 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\nLAB_00081b04:\n  temp24 = temp12 - temp15;\n  if ((temp12 < temp15) || ((int)temp24 < 0x10)) {\n    FUNC_00081f98(output_ptr);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  Elf32_Rel_ARRAY_20070000[141].r_info = temp15 + temp23;\n  *(uint *)(temp23 + 4) = temp15 | 1;\n  *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = temp24 | 1;\n  FUNC_00081f98(output_ptr);\n  return (int *)(temp23 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "allocate_memory_00081810",
                "param_1": "output_ptr",
                "param_2": "size",
                "dVar1": "temp22",
                "iVar2": "temp1",
                "uVar3": "temp24",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "temp16",
                "dVar7": "temp23",
                "uVar8": "temp6",
                "iVar9": "temp7",
                "puVar10": "temp_ptr1",
                "dVar11": "temp21",
                "dVar12": "temp19",
                "iVar13": "temp20",
                "pdVar14": "temp_ptr2",
                "uVar15": "temp15",
                "puVar16": "temp_ptr3",
                "pdVar17": "temp_ptr4",
                "uVar18": "temp12"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00084018",
                "FUN_00083ca8",
                "FUN_000817f0"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "copy_memory_00081d48",
            "code": "\nundefined4 * copyMemory_00081d48(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *dest_ptr_temp;\n  undefined4 *src_ptr_temp;\n  uint repeated_times;\n  uint remaining_size;\n  bool is_remaining;\n  \n  dest_ptr_temp = dest;\n  if ((((uint)src | (uint)dest) & 3) != 0) {\n    if (size < 8) {\n      remaining_size = size - 4;\n      if (3 < size) {\n        do {\n          dest_ptr = src;\n          src_ptr_temp = dest_ptr_temp;\n          is_remaining = remaining_size != 0;\n          remaining_size = remaining_size - 1;\n          *(undefined *)src_ptr_temp = *(undefined *)dest_ptr;\n          dest_ptr_temp = (undefined4 *)((int)src_ptr_temp + 1);\n          src = (undefined4 *)((int)dest_ptr + 1);\n        } while (is_remaining);\n        *(undefined *)(undefined4 *)((int)src_ptr_temp + 1) =\n             *(undefined *)(undefined4 *)((int)dest_ptr + 1);\n        *(undefined *)((int)src_ptr_temp + 2) = *(undefined *)((int)dest_ptr + 2);\n        *(undefined *)((int)src_ptr_temp + 3) = *(undefined *)((int)dest_ptr + 3);\n        return dest;\n      }\n      goto copy_remaining;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dest & 3) != 0)) {\n      remaining_size = 4 - ((uint)dest & 3);\n      size = size - remaining_size;\n      dest_ptr = dest;\n      src_ptr_temp = src;\n      if (((uint)dest & 1) != 0) {\n        src_ptr_temp = (undefined4 *)((int)src + 1);\n        dest_ptr = (undefined4 *)((int)dest + 1);\n        *(undefined *)dest = *(undefined *)src;\n      }\n      dest_ptr_temp = dest_ptr;\n      src = src_ptr_temp;\n      if ((remaining_size & 2) != 0) {\n        src = (undefined4 *)((int)src_ptr_temp + 2);\n        dest_ptr_temp = (undefined4 *)((int)dest_ptr + 2);\n        *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr_temp;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *dest_ptr_temp = *src;\n    dest_ptr[1] = src[1];\n    dest_ptr[2] = src[2];\n    dest_ptr[3] = src[3];\n    dest_ptr[4] = src[4];\n    dest_ptr[5] = src[5];\n    dest_ptr[6] = src[6];\n    dest_ptr[7] = src[7];\n    dest_ptr[8] = src[8];\n    dest_ptr[9] = src[9];\n    dest_ptr[10] = src[10];\n    dest_ptr[0xb] = src[0xb];\n    dest_ptr[0xc] = src[0xc];\n    dest_ptr[0xd] = src[0xd];\n    dest_ptr[0xe] = src[0xe];\n    dest_ptr[0xf] = src[0xf];\n    dest_ptr_temp = dest_ptr_temp + 0x10;\n    src = src + 0x10;\n    size = size - 0x40;\n  }\n  repeated_times = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *dest_ptr_temp = *src;\n      dest_ptr[1] = src[1];\n      dest_ptr[2] = src[2];\n      dest_ptr[3] = src[3];\n      dest_ptr_temp = dest_ptr_temp + 4;\n      src = src + 4;\n      is_remaining = 0xf < repeated_times;\n      repeated_times = repeated_times - 0x10;\n    } while (is_remaining);\n  }\n  remaining_size = repeated_times + 0xc;\n  src_ptr_temp = dest_ptr_temp;\n  dest_ptr = src;\n  if (0xfffffff3 < repeated_times) {\n    do {\n      src = dest_ptr + 1;\n      *src_ptr_temp = *dest_ptr;\n      is_remaining = 3 < remaining_size;\n      remaining_size = remaining_size - 4;\n      dest_ptr_temp = src_ptr_temp + 1;\n      src_ptr_temp = src_ptr_temp + 1;\n      dest_ptr = src;\n    } while (is_remaining);\n  }\ncopy_remaining:\n  if (remaining_size + 4 != 0) {\n    dest_ptr = dest_ptr_temp;\n    src_ptr_temp = src;\n    if ((remaining_size & 1) != 0) {\n      src_ptr_temp = (undefined4 *)((int)src + 1);\n      dest_ptr = (undefined4 *)((int)dest_ptr_temp + 1);\n      *(undefined *)dest_ptr_temp = *(undefined *)src;\n    }\n    if ((remaining_size + 4 & 2) != 0) {\n      *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr_temp;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "copy_memory_00081d48",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dest_ptr_temp",
                "puVar3": "src_ptr_temp",
                "uVar4": "repeated_times",
                "uVar5": "remaining_size",
                "bVar6": "is_remaining",
                "LAB_00081dcc": "copy_remaining",
                "puVar2[1]": "dest_ptr[1]",
                "puVar2[2]": "dest_ptr[2]",
                "puVar2[3]": "dest_ptr[3]",
                "puVar2[4]": "dest_ptr[4]",
                "puVar2[5]": "dest_ptr[5]",
                "puVar2[6]": "dest_ptr[6]",
                "puVar2[7]": "dest_ptr[7]",
                "puVar2[8]": "dest_ptr[8]",
                "puVar2[9]": "dest_ptr[9]",
                "puVar2[10]": "dest_ptr[10]",
                "puVar2[0xb]": "dest_ptr[0xb]",
                "puVar2[0xc]": "dest_ptr[0xc]",
                "puVar2[0xd]": "dest_ptr[0xd]",
                "puVar2[0xe]": "dest_ptr[0xe]",
                "puVar2[0xf]": "dest_ptr[0xf]"
            },
            "calling": [
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "reverse_memory_segment_00081e34",
            "code": "\nvoid reverseMemorySegment_00081e34(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  int count;\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  undefined4 *tmp_ptr;\n  uint remaining_size;\n  undefined *temp_ptr;\n  uint reminder;\n  \n  if ((src < dest) && (tmp_ptr = (undefined4 *)((int)src + size), dest < tmp_ptr)) {\n    temp_ptr = (undefined *)((int)dest + size);\n    count = size - 1;\n    if (size != 0) {\n      do {\n        tmp_ptr = (undefined4 *)((int)tmp_ptr + -1);\n        count = count + -1;\n        temp_ptr = temp_ptr + -1;\n        *temp_ptr = *(undefined *)tmp_ptr;\n      } while (count != -1);\n    }\n    return;\n  }\n  if (size < 0x10) {\n    if (size == 0) {\n      return;\n    }\n  }\n  else if ((((uint)dest | (uint)src) & 3) == 0) {\n    tmp_ptr = dest;\n    src_ptr = src;\n    do {\n      dest_ptr = tmp_ptr + 4;\n      *tmp_ptr = *src_ptr;\n      tmp_ptr[1] = src_ptr[1];\n      tmp_ptr[2] = src_ptr[2];\n      tmp_ptr[3] = src_ptr[3];\n      tmp_ptr = dest_ptr;\n      src_ptr = src_ptr + 4;\n    } while (dest_ptr != (undefined4 *)((int)dest + (size - 0x10 & 0xfffffff0) + 0x10));\n    count = (size - 0x10 >> 4) + 1;\n    reminder = size & 0xf;\n    src = src + count * 4;\n    dest = dest + count * 4;\n    remaining_size = reminder;\n    tmp_ptr = dest;\n    src_ptr = src;\n    if (3 < reminder) {\n      do {\n        remaining_size = remaining_size - 4;\n        *tmp_ptr = *src_ptr;\n        tmp_ptr = tmp_ptr + 1;\n        src_ptr = src_ptr + 1;\n      } while (3 < remaining_size);\n      count = (reminder - 4 & 0xfffffffc) + 4;\n      dest = (undefined4 *)((int)dest + count);\n      src = (undefined4 *)((int)src + count);\n      reminder = size & 3;\n    }\n    size = reminder;\n    if (size == 0) {\n      return;\n    }\n  }\n  tmp_ptr = dest;\n  do {\n    src_ptr = (undefined4 *)((int)tmp_ptr + 1);\n    *(undefined *)tmp_ptr = *(undefined *)src;\n    src = (undefined4 *)((int)src + 1);\n    tmp_ptr = src_ptr;\n  } while (src_ptr != (undefined4 *)(size + (int)dest));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "reverse_memory_segment_00081e34",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "iVar1": "count",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "puVar4": "tmp_ptr",
                "uVar5": "remaining_size",
                "puVar6": "temp_ptr",
                "uVar7": "reminder"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "memset_00081f00",
            "code": "\nvoid memset_00081f00(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *temp_ptr;\n  undefined4 value_dup;\n  uint size_temp;\n  bool is_zero;\n  \n  if (((uint)dest & 3) != 0) {\n    is_zero = size == 0;\n    dest_ptr = dest;\n    size = size - 1;\n    if (is_zero) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      if (((uint)dest & 3) == 0) break;\n      is_zero = size == 0;\n      dest_ptr = dest;\n      size = size - 1;\n      if (is_zero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    value_dup = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    size_temp = size;\n    dest_ptr = dest;\n    if (0xf < size) {\n      size_temp = size - 0x10;\n      do {\n        *dest_ptr = value_dup;\n        dest_ptr[1] = value_dup;\n        dest_ptr[2] = value_dup;\n        dest_ptr[3] = value_dup;\n        dest_ptr = dest_ptr + 4;\n      } while (dest_ptr != (undefined4 *)((int)dest + (size_temp & 0xfffffff0) + 0x10));\n      size = size & 0xf;\n      dest = dest + ((size_temp >> 4) + 1) * 4;\n      size_temp = size;\n      dest_ptr = dest;\n      if (size < 4) goto final_copy_loop;\n    }\n    do {\n      size = size - 4;\n      *dest = value_dup;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)dest_ptr + (size_temp - 4 & 0xfffffffc) + 4);\n    size = size_temp & 3;\n  }\nfinal_copy_loop:\n  if (size != 0) {\n    dest_ptr = dest;\n    do {\n      temp_ptr = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      dest_ptr = temp_ptr;\n    } while (temp_ptr != (undefined4 *)(size + (int)dest));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "memset_00081f00",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "temp_ptr",
                "uVar3": "value_dup",
                "uVar4": "size_temp",
                "bVar5": "is_zero",
                "LAB_00081f7c": "final_copy_loop"
            },
            "calling": [
                "FUN_000811b0",
                "FUN_00083888"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "execute_relocation_00081f9c",
            "code": "\nvoid executeRelocation_00081f9c(undefined4 param,undefined4 data)\n\n{\n  FUN_00081fac(relocationTable[140].r_offset,param,data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "execute_relocation_00081f9c",
                "param_1": "param",
                "param_2": "data",
                "Elf32_Rel_ARRAY_20070000": "relocationTable"
            },
            "calling": [
                "FUN_00081496"
            ],
            "called": [
                "FUN_00081fac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "allocate_memory_00081fac",
            "code": "\nint * allocateMemory_00081fac(undefined4 *param1,int *param2,uint param3)\n\n{\n  dword temp1;\n  int *result;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  int *temp6;\n  uint temp7;\n  uint temp8;\n  int *temp9;\n  \n  if (param2 == (int *)0x0) {\n    result = (int *)FUN_00081810(param1,param3);\n    return result;\n  }\n  FUNC_00081f94();\n  temp4 = param2[-1];\n  temp7 = temp4 & 0xfffffffc;\n  result = param2 + -2;\n  if (param3 + 0xb < 0x17) {\n    temp8 = 0x10;\n  }\n  else {\n    temp8 = param3 + 0xb & 0xfffffff8;\n    if ((int)temp8 < 0) goto LAB_00082078;\n  }\n  if (temp8 < param3) {\nLAB_00082078:\n    *param1 = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)temp7 < (int)temp8) {\n    temp1 = (int)result + temp7;\n    if (Elf32_Rel_ARRAY_20070000[141].r_info == temp1) {\n      temp2 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n      temp1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n      if ((int)(temp8 + 0x10) <= (int)(temp2 + temp7)) {\n        Elf32_Rel_ARRAY_20070000[141].r_info = (int)result + temp8;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (temp2 + temp7) - temp8 | 1;\n        param2[-1] = temp8 | param2[-1] & 1U;\n        FUNC_00081f98(param1);\n        return param2;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp1 + 4) & 0xfffffffe) + temp1 + 4) & 1) == 0) {\n      temp2 = *(uint *)(temp1 + 4) & 0xfffffffc;\n      if ((int)temp8 <= (int)(temp2 + temp7)) {\n        temp5 = *(int *)(temp1 + 0xc);\n        temp3 = *(int *)(temp1 + 8);\n        *(int *)(temp3 + 0xc) = temp5;\n        *(int *)(temp5 + 8) = temp3;\n        temp7 = temp2 + temp7;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      temp2 = 0;\n      temp1 = 0;\n    }\n    if (-1 < (int)(temp4 << 0x1f)) {\n      temp9 = (int *)((int)result - param2[-2]);\n      temp4 = (temp9[1] & 0xfffffffcU) + temp7;\n      if (temp1 != 0) {\n        if (temp1 == Elf32_Rel_ARRAY_20070000[141].r_info) {\n          if ((int)(temp8 + 0x10) <= (int)(temp2 + temp4)) {\n            result = temp9 + 2;\n            temp3 = *result;\n            temp5 = temp9[3];\n            temp7 = temp7 - 4;\n            *(int *)(temp3 + 0xc) = temp5;\n            *(int *)(temp5 + 8) = temp3;\n            if (temp7 < 0x25) {\n              temp6 = result;\n              if (0x13 < temp7) {\n                temp9[2] = *param2;\n                temp9[3] = param2[1];\n                if (temp7 < 0x1c) {\n                  param2 = param2 + 2;\n                  temp6 = temp9 + 4;\n                }\n                else {\n                  temp9[4] = param2[2];\n                  temp9[5] = param2[3];\n                  if (temp7 == 0x24) {\n                    temp9[6] = param2[4];\n                    temp6 = param2 + 5;\n                    param2 = param2 + 6;\n                    temp9[7] = *temp6;\n                    temp6 = temp9 + 8;\n                  }\n                  else {\n                    param2 = param2 + 4;\n                    temp6 = temp9 + 6;\n                  }\n                }\n              }\n              *temp6 = *param2;\n              temp6[1] = param2[1];\n              temp6[2] = param2[2];\n            }\n            else {\n              FUN_00081e34(result,param2);\n            }\n            Elf32_Rel_ARRAY_20070000[141].r_info = (int)temp9 + temp8;\n            *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (temp2 + temp4) - temp8 | 1;\n            temp9[1] = temp8 | temp9[1] & 1U;\n            FUNC_00081f98(param1);\n            return result;\n          }\n        }\n        else {\n          temp2 = temp2 + temp4;\n          if ((int)temp8 <= (int)temp2) {\n            temp5 = *(int *)(temp1 + 0xc);\n            temp3 = *(int *)(temp1 + 8);\n            *(int *)(temp3 + 0xc) = temp5;\n            *(int *)(temp5 + 8) = temp3;\n            temp6 = temp9 + 2;\n            temp3 = *temp6;\n            temp5 = temp9[3];\n            temp4 = temp7 - 4;\n            *(int *)(temp3 + 0xc) = temp5;\n            *(int *)(temp5 + 8) = temp3;\n            temp7 = temp2;\n            if (temp4 < 0x25) {\n              result = temp6;\n              if (0x13 < temp4) {\n                temp9[2] = *param2;\n                temp9[3] = param2[1];\n                if (temp4 < 0x1c) {\n                  param2 = param2 + 2;\n                  result = temp9 + 4;\n                }\n                else {\n                  temp9[4] = param2[2];\n                  temp9[5] = param2[3];\n                  if (temp4 == 0x24) {\n                    temp9[6] = param2[4];\n                    result = param2 + 5;\n                    param2 = param2 + 6;\n                    temp9[7] = *result;\n                    result = temp9 + 8;\n                  }\n                  else {\n                    param2 = param2 + 4;\n                    result = temp9 + 6;\n                  }\n                }\n              }\n              *result = *param2;\n              result[1] = param2[1];\n              result[2] = param2[2];\n              temp4 = temp9[1];\n              result = temp9;\n              param2 = temp6;\n            }\n            else {\n              FUN_00081e34(temp6,param2);\n              temp4 = temp9[1];\n              result = temp9;\n              param2 = temp6;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)temp8 <= (int)temp4) {\n        temp6 = temp9 + 2;\n        temp3 = *temp6;\n        temp5 = temp9[3];\n        temp2 = temp7 - 4;\n        *(int *)(temp3 + 0xc) = temp5;\n        *(int *)(temp5 + 8) = temp3;\n        temp7 = temp4;\n        if (temp2 < 0x25) {\n          result = temp6;\n          if (0x13 < temp2) {\n            temp9[2] = *param2;\n            temp9[3] = param2[1];\n            if (temp2 < 0x1c) {\n              param2 = param2 + 2;\n              result = temp9 + 4;\n            }\n            else {\n              temp9[4] = param2[2];\n              temp9[5] = param2[3];\n              if (temp2 == 0x24) {\n                temp9[6] = param2[4];\n                result = param2 + 5;\n                param2 = param2 + 6;\n                temp9[7] = *result;\n                result = temp9 + 8;\n              }\n              else {\n                param2 = param2 + 4;\n                result = temp9 + 6;\n              }\n            }\n          }\n          *result = *param2;\n          result[1] = param2[1];\n          result[2] = param2[2];\n          temp4 = temp9[1];\n          result = temp9;\n          param2 = temp6;\n        }\n        else {\n          FUN_00081e34(temp6,param2);\n          temp4 = temp9[1];\n          result = temp9;\n          param2 = temp6;\n        }\n        goto LAB_00082088;\n      }\n    }\n    temp9 = (int *)FUN_00081810(param1,param3);\n    if (temp9 == (int *)0x0) goto LAB_000820a0;\n    temp4 = param2[-1];\n    if (temp9 + -2 != (int *)((temp4 & 0xfffffffe) + (int)result)) {\n      temp7 = temp7 - 4;\n      if (temp7 < 0x25) {\n        result = param2;\n        temp6 = temp9;\n        if (0x13 < temp7) {\n          *temp9 = *param2;\n          temp9[1] = param2[1];\n          if (temp7 < 0x1c) {\n            result = param2 + 2;\n            temp6 = temp9 + 2;\n          }\n          else {\n            temp9[2] = param2[2];\n            temp9[3] = param2[3];\n            if (temp7 == 0x24) {\n              temp9[4] = param2[4];\n              temp9[5] = param2[5];\n              result = param2 + 6;\n              temp6 = temp9 + 6;\n            }\n            else {\n              result = param2 + 4;\n              temp6 = temp9 + 4;\n            }\n          }\n        }\n        *temp6 = *result;\n        temp6[1] = result[1];\n        temp6[2] = result[2];\n      }\n      else {\n        FUN_00081e34(temp9,param2);\n      }\n      FUN_00083b10(param1,param2);\n      goto LAB_000820a0;\n    }\n    temp7 = temp7 + (temp9[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  temp2 = temp7 - temp8;\n  temp9 = param2;\n  if (temp2 < 0x10) {\n    result[1] = temp4 & 1 | temp7;\n    *(uint *)((int)result + temp7 + 4) = *(uint *)((int)result + temp7 + 4) | 1;\n  }\n  else {\n    result[1] = temp4 & 1 | temp8;\n    *(uint *)((int)result + temp8 + 4) = temp2 | 1;\n    *(uint *)((int)result + temp2 + temp8 + 4) = *(uint *)((int)result + temp2 + temp8 + 4) | 1;\n    FUN_00083b10(param1,(int)result + temp8 + 8);\n  }\nLAB_000820a0:\n  FUNC_00081f98(param1);\n  return temp9;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "allocate_memory_00081fac",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "dVar1": "temp1",
                "piVar2": "result",
                "uVar3": "temp2",
                "iVar4": "temp3",
                "uVar5": "temp4",
                "iVar6": "temp5",
                "piVar7": "temp6",
                "uVar8": "temp7",
                "uVar9": "temp8",
                "piVar10": "temp9"
            },
            "calling": [
                "FUN_00081f9c",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "check_and_assign_value_0008236c",
            "code": "\nvoid checkAndAssignValue_0008236c(int *outputVariable,undefined4 inputValue)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080e88(inputValue);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *outputVariable = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "check_and_assign_value_0008236c",
                "param_1": "outputVariable",
                "param_2": "inputValue",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [
                "FUN_00080e88"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_memory_00082390",
            "code": "\nint compareMemory_00082390(uint *memoryBlock1,uint *memoryBlock2)\n\n{\n  uint *ptr1;\n  int result;\n  uint *ptr2;\n  uint *ptr3;\n  uint remainder1;\n  uint byte1;\n  uint byte2;\n  uint result1;\n  uint result2;\n  \n  if ((((uint)memoryBlock1 | (uint)memoryBlock2) & 7) != 0) {\n    ptr1 = memoryBlock1;\n    if (((uint)memoryBlock1 & 3) != 0) {\n      ptr1 = (uint *)((uint)memoryBlock1 & 0xfffffffc) + 1;\n      remainder1 = *(uint *)((uint)memoryBlock1 & 0xfffffffc);\n      ptr2 = memoryBlock2;\n      if (((uint)memoryBlock1 & 1) == 0) {\nLAB_00082410:\n        ptr3 = (uint *)((int)ptr2 + 1);\n        byte1 = remainder1 >> 0x10 & 0xff;\n        result = byte1 - *(byte *)ptr2;\n        if (result != 0) {\n          return result;\n        }\n        if (byte1 == 0) {\n          return 0;\n        }\n      }\n      else {\n        ptr3 = memoryBlock2;\n        if (((uint)memoryBlock1 & 2) == 0) {\n          ptr2 = (uint *)((int)memoryBlock2 + 1);\n          byte1 = remainder1 >> 8 & 0xff;\n          result = byte1 - *(byte *)memoryBlock2;\n          if (result != 0) {\n            return result;\n          }\n          if (byte1 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      memoryBlock2 = (uint *)((int)ptr3 + 1);\n      result = (remainder1 >> 0x18) - (uint)*(byte *)ptr3;\n      if ((result != 0) || (remainder1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    remainder1 = (uint)memoryBlock2 & 3;\n    if (remainder1 != 0) {\n      memoryBlock2 = (uint *)((uint)memoryBlock2 & 0xfffffffc);\n      if (remainder1 == 2) {\n        remainder1 = *memoryBlock2;\n        do {\n          memoryBlock2 = memoryBlock2 + 1;\n          byte2 = *ptr1;\n          remainder1 = remainder1 >> 0x10;\n          result1 = byte2 + 0xfefefeff & ~byte2;\n          result2 = result1 & 0x80808080;\n          byte1 = byte2 & 0xffff;\n          if ((result1 & 0x8080) != 0 || byte1 != remainder1) goto LAB_0008258e;\n          remainder1 = *memoryBlock2;\n          byte1 = byte1 ^ byte2;\n          byte2 = remainder1 * 0x10000;\n          ptr1 = ptr1 + 1;\n        } while (result2 == 0 && byte1 == byte2);\n      }\n      else if (remainder1 < 2) {\n        remainder1 = *memoryBlock2;\n        do {\n          memoryBlock2 = memoryBlock2 + 1;\n          byte2 = *ptr1;\n          remainder1 = remainder1 >> 8;\n          result1 = byte2 + 0xfefefeff & ~byte2;\n          result2 = result1 & 0x80808080;\n          byte1 = byte2 & 0xffffff;\n          if ((result1 & 0x808080) != 0 || byte1 != remainder1) goto LAB_0008258e;\n          remainder1 = *memoryBlock2;\n          byte1 = byte1 ^ byte2;\n          byte2 = remainder1 * 0x1000000;\n          ptr1 = ptr1 + 1;\n        } while (result2 == 0 && byte1 == byte2);\n      }\n      else {\n        remainder1 = *memoryBlock2;\n        do {\n          memoryBlock2 = memoryBlock2 + 1;\n          byte2 = *ptr1;\n          remainder1 = remainder1 >> 0x18;\n          result1 = byte2 + 0xfefefeff & ~byte2;\n          result2 = result1 & 0x80808080;\n          byte1 = byte2 & 0xff;\n          if ((result1 & 0x80) != 0 || byte1 != remainder1) goto LAB_0008258e;\n          remainder1 = *memoryBlock2;\n          byte1 = byte1 ^ byte2;\n          byte2 = remainder1 * 0x100;\n          ptr1 = ptr1 + 1;\n        } while (result2 == 0 && byte1 == byte2);\n      }\n      byte1 = byte1 << 0x18 | (byte1 >> 8 & 0xff) << 0x10 | (byte1 >> 0x10 & 0xff) << 8 |\n              byte1 >> 0x18;\n      remainder1 = (byte2 >> 8 & 0xff) << 0x10 | (byte2 >> 0x10 & 0xff) << 8 | byte2 >> 0x18;\n      goto LAB_0008259e;\n    }\n    memoryBlock1 = ptr1;\n    ptr2 = memoryBlock2;\n    if (((uint)ptr1 & 4) != 0) {\n      memoryBlock1 = ptr1 + 1;\n      remainder1 = *ptr1;\n      ptr2 = memoryBlock2 + 1;\n      byte2 = *memoryBlock2;\n      result2 = remainder1 + 0xfefefeff & ~remainder1 & 0x80808080;\n      if (remainder1 != byte2 || result2 != 0) {\nLAB_0008259a:\n        byte1 = remainder1 << 0x18 | (remainder1 >> 8 & 0xff) << 0x10 | (remainder1 >> 0x10 & 0xff) << 8 |\n                remainder1 >> 0x18;\n        remainder1 = byte2 << 0x18 | (byte2 >> 8 & 0xff) << 0x10 | (byte2 >> 0x10 & 0xff) << 8 |\n                byte2 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    memoryBlock2 = ptr2;\n    if (((uint)ptr2 & 4) != 0) {\n      remainder1 = *ptr2;\n      ptr1 = ptr2 + 1;\n      do {\n        byte1 = *memoryBlock1;\n        byte2 = memoryBlock1[1];\n        result2 = byte1 + 0xfefefeff & ~byte1 & 0x80808080;\n        if (byte1 != remainder1 || result2 != 0) goto LAB_0008258e;\n        result1 = *ptr1;\n        remainder1 = ptr1[1];\n        result2 = byte2 + 0xfefefeff & ~byte2 & 0x80808080;\n        memoryBlock1 = memoryBlock1 + 2;\n        ptr1 = ptr1 + 2;\n      } while (byte2 == result1 && result2 == 0);\n      byte1 = byte2 << 0x18 | (byte2 >> 8 & 0xff) << 0x10 | (byte2 >> 0x10 & 0xff) << 8 |\n              byte2 >> 0x18;\n      remainder1 = result1 << 0x18 | (result1 >> 8 & 0xff) << 0x10 | (result1 >> 0x10 & 0xff) << 8 |\n              result1 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    remainder1 = *memoryBlock1;\n    byte1 = memoryBlock1[1];\n    byte2 = *memoryBlock2;\n    result1 = memoryBlock2[1];\n    result2 = remainder1 + 0xfefefeff & ~remainder1 & 0x80808080;\n    if (remainder1 != byte2 || result2 != 0) goto LAB_0008259a;\n    result2 = byte1 + 0xfefefeff & ~byte1 & 0x80808080;\n    memoryBlock1 = memoryBlock1 + 2;\n    memoryBlock2 = memoryBlock2 + 2;\n  } while (byte1 == result1 && result2 == 0);\n  byte1 = byte1 << 0x18 | (byte1 >> 8 & 0xff) << 0x10 | (byte1 >> 0x10 & 0xff) << 8 | byte1 >> 0x18;\n  remainder1 = result1 << 0x18 | (result1 >> 8 & 0xff) << 0x10 | (result1 >> 0x10 & 0xff) << 8 | result1 >> 0x18;\nLAB_0008259e:\n  byte2 = result2 << 0x18 | (result2 >> 8 & 0xff) << 0x10 | (result2 >> 0x10 & 0xff) << 8 | result2 >> 0x18;\n  if (byte2 != 0) {\n    byte2 = 0x18 - LZCOUNT(byte2);\n    byte1 = byte1 >> (byte2 & 0xff);\n    remainder1 = remainder1 >> (byte2 & 0xff);\n  }\n  result = 1;\n  if (byte1 <= remainder1) {\n    result = -(uint)(byte1 < remainder1);\n  }\n  return result;\nLAB_0008258e:\n  byte1 = byte1 << 0x18 | (byte1 >> 8 & 0xff) << 0x10 | (byte1 >> 0x10 & 0xff) << 8 | byte1 >> 0x18;\n  remainder1 = remainder1 << 0x18 | (remainder1 >> 8 & 0xff) << 0x10 | (remainder1 >> 0x10 & 0xff) << 8 | remainder1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_memory_00082390",
                "param_1": "memoryBlock1",
                "param_2": "memoryBlock2",
                "puVar1": "ptr1",
                "iVar2": "result",
                "puVar3": "ptr2",
                "puVar4": "ptr3",
                "uVar5": "remainder1",
                "uVar6": "byte1",
                "uVar7": "byte2",
                "uVar8": "result1",
                "uVar9": "result2"
            },
            "calling": [
                "FUN_000815b8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_000825cc",
            "code": "\nvoid copyString_000825cc(uint *dest,uint *src)\n\n{\n  char currentChar;\n  ushort currentShort;\n  uint *nextChunk;\n  uint *nextSrcChunk;\n  uint currentChunk;\n  uint tempChunk;\n  uint *nextDestChunk;\n  bool isZeroByte;\n  \n  if ((((uint)dest ^ (uint)src) & 3) != 0) {\n    do {\n      currentChar = *(char *)src;\n      *(char *)dest = currentChar;\n      src = (uint *)((int)src + 1);\n      dest = (uint *)((int)dest + 1);\n    } while (currentChar != '\\0');\n    return;\n  }\n  if (((uint)src & 3) != 0) {\n    nextSrcChunk = src;\n    if (((uint)src & 1) != 0) {\n      nextSrcChunk = (uint *)((int)src + 1);\n      currentChar = *(char *)src;\n      *(char *)dest = currentChar;\n      dest = (uint *)((int)dest + 1);\n      if (currentChar == '\\0') {\n        return;\n      }\n    }\n    src = nextSrcChunk;\n    if (((uint)nextSrcChunk & 2) != 0) {\n      src = (uint *)((int)nextSrcChunk + 2);\n      currentShort = *(ushort *)nextSrcChunk;\n      isZeroByte = (currentShort & 0xff) == 0;\n      if (isZeroByte) {\n        *(char *)dest = (char)currentShort;\n      }\n      else {\n        *(ushort *)dest = currentShort;\n        isZeroByte = (currentShort & 0xff00) == 0;\n        dest = (uint *)((int)dest + 2);\n      }\n      if (isZeroByte) {\n        return;\n      }\n    }\n  }\n  currentChunk = *src;\n  nextSrcChunk = src + 1;\n  nextDestChunk = dest;\n  if (((uint)src & 4) != 0) {\n    if ((currentChunk + 0xfefefeff & ~currentChunk & 0x80808080) != 0) goto checkEndOfChunk;\n    nextDestChunk = dest + 1;\n    *dest = currentChunk;\n    nextSrcChunk = src + 2;\n    currentChunk = src[1];\n  }\n  while( true ) {\n    nextChunk = nextSrcChunk + 1;\n    tempChunk = *nextSrcChunk;\n    dest = nextDestChunk;\n    if ((currentChunk + 0xfefefeff & ~currentChunk & 0x80808080) != 0) break;\n    dest = nextDestChunk + 1;\n    *nextDestChunk = currentChunk;\n    currentChunk = tempChunk;\n    if ((tempChunk + 0xfefefeff & ~tempChunk & 0x80808080) != 0) break;\n    nextSrcChunk = nextSrcChunk + 2;\n    currentChunk = *nextChunk;\n    nextDestChunk = nextDestChunk + 2;\n    *dest = tempChunk;\n  }\ncheckEndOfChunk:\n  do {\n    *(char *)dest = (char)currentChunk;\n    tempChunk = currentChunk & 0xff;\n    currentChunk = currentChunk >> 8 | currentChunk << 0x18;\n    dest = (uint *)((int)dest + 1);\n  } while (tempChunk != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_000825cc",
                "param_1": "dest",
                "param_2": "src",
                "cVar1": "currentChar",
                "uVar2": "currentShort",
                "puVar3": "nextChunk",
                "puVar4": "nextSrcChunk",
                "uVar5": "currentChunk",
                "uVar6": "tempChunk",
                "puVar7": "nextDestChunk",
                "bVar8": "isZeroByte",
                "LAB_00082630": "checkEndOfChunk"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "count_leading_zeroes_00082688",
            "code": "\nint countLeadingZeroes_00082688(uint input)\n\n{\n  int leadingZeroCount;\n  uint *ptr;\n  uint value;\n  bool byteZeroFlag;\n  \n  ptr = (uint *)(input & 0xfffffffc);\n  leadingZeroCount = -(input & 3);\n  value = *ptr;\n  if ((input & 3) != 0) {\n    value = value | 0xffffffffU >> ((leadingZeroCount + 4U & 0x1f) << 3);\n  }\n  while (ptr = ptr + 1, (value + 0xfefefeff & ~value & 0x80808080) == 0) {\n    leadingZeroCount = leadingZeroCount + 4;\n    value = *ptr;\n  }\n  byteZeroFlag = (value & 0xff) == 0;\n  if (!byteZeroFlag) {\n    leadingZeroCount = leadingZeroCount + 1;\n    byteZeroFlag = (value & 0xff00) == 0;\n  }\n  if (!byteZeroFlag) {\n    leadingZeroCount = leadingZeroCount + 1;\n    byteZeroFlag = (value & 0xff0000) == 0;\n  }\n  if (!byteZeroFlag) {\n    leadingZeroCount = leadingZeroCount + 1;\n  }\n  return leadingZeroCount;\n}\n\n",
            "renaming": {
                "FUN_00082688": "count_leading_zeroes_00082688",
                "param_1": "input",
                "iVar1": "leadingZeroCount",
                "puVar2": "ptr",
                "uVar3": "value",
                "bVar4": "byteZeroFlag"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000814f6",
                "FUN_000810a6"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "process_data_00082824",
            "code": "\nint processData_00082824(undefined4 input_param,int length_param,int **data_param)\n\n{\n  int *currentPtr;\n  int returnValue;\n  int *tempPtr;\n  uint counter;\n  undefined4 *funcPtr;\n  uint tempVar1;\n  uint tempVar2;\n  \n  if (-1 < *(int *)(length_param + 100) << 0x12) {\n    returnValue = FUN_00083ca8();\n    data_param[2] = (int *)0x0;\n    data_param[1] = (int *)0x0;\n    return returnValue;\n  }\n  tempPtr = data_param[2];\n  currentPtr = *data_param;\n  while (tempPtr != (int *)0x0) {\n    tempVar1 = currentPtr[1];\n    tempVar2 = tempVar1 >> 2;\n    if (tempVar2 != 0) {\n      funcPtr = (undefined4 *)(*currentPtr + -4);\n      counter = 0;\n      do {\n        funcPtr = funcPtr + 1;\n        returnValue = FUN_000839b4(input_param,*funcPtr,length_param);\n        counter = counter + 1;\n        if (returnValue == -1) goto LAB_00082864;\n      } while (tempVar2 != counter);\n      tempPtr = data_param[2];\n    }\n    tempPtr = (int *)((int)tempPtr - (tempVar1 & 0xfffffffc));\n    data_param[2] = tempPtr;\n    currentPtr = currentPtr + 2;\n  }\n  returnValue = 0;\nLAB_00082864:\n  data_param[2] = (int *)0x0;\n  data_param[1] = (int *)0x0;\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00082824": "process_data_00082824",
                "param_1": "input_param",
                "param_2": "length_param",
                "param_3": "data_param",
                "piVar1": "currentPtr",
                "iVar2": "returnValue",
                "piVar3": "tempPtr",
                "uVar4": "counter",
                "puVar5": "funcPtr",
                "uVar6": "tempVar1",
                "uVar7": "tempVar2"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083ca8",
                "FUN_000839b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "format_string_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint formatString_0008289c(int str_ptr,int format_ptr,int *******arg_ptr,int **argSizes_ptr)\n\n{\n  bool isLeftJustified;\n  bool isSigned;\n  bool isAlternate;\n  char paddingChar;\n  bool isPositive;\n  int ********argData_ptr;\n  int *arg_ptr_1;\n  int argCount;\n  char char1;\n  int *******ptr;\n  uint temp1;\n  int **temp_ptr;\n  uint temp2;\n  uint temp3;\n  int temp4;\n  int ********temp_ptr1;\n  int temp5;\n  int *******temp_ptr2;\n  int *arg_ptr_temp;\n  int *******temp_ptr4;\n  uint temp6;\n  int *temp_ptr3;\n  int *******temp_ptr5;\n  undefined4 uVar24;\n  int ********ppppppppiVar25;\n  bool isSigned6;\n  longlong combinedValue;\n  int *******numChars;\n  int *******maxChars;\n  int **argSizes_ptr_temp;\n  int totalChars;\n  char *decimalDigits;\n  char paddingChar;\n  undefined paddingChar1;\n  undefined paddingChar2;\n  int ********argData_ptr_temp;\n  int argCount_temp;\n  int *******argSizes_ptr_temp;\n  undefined paddingChar3;\n  char cStack_6a;\n  undefined local_69;\n  undefined tempBuffer [4];\n  int *******local_64 [16];\n  \n  if ((str_ptr != 0) && (*(int *)(str_ptr + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  temp2 = (uint)*(ushort *)(format_ptr + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(format_ptr + 0xc) << 0x12)) {\n    temp2 = temp2 | 0x2000;\n    *(short *)(format_ptr + 0xc) = (short)temp2;\n    *(uint *)(format_ptr + 100) = *(uint *)(format_ptr + 100) & 0xffffdfff;\n  }\n  if (((int)(temp2 << 0x1c) < 0) && (*(int *)(format_ptr + 0x10) != 0)) {\n    if ((temp2 & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    argCount = FUN_0008356c(str_ptr,format_ptr);\n    if (argCount != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(format_ptr + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(format_ptr + 0xe)) {\n    argCount = FUN_000834f0(str_ptr,format_ptr,arg_ptr,argSizes_ptr);\n    return argCount;\n  }\nLAB_000828ee:\n  decimalDigits = (char *)0x0;\n  argSizes_ptr_temp = (int *******)0x0;\n  argCount_temp = 0;\n  totalChars = 0;\n  argData_ptr = (int ********)tempBuffer;\n  argSizes_ptr_temp = argSizes_ptr;\n  argData_ptr_temp = (int ********)tempBuffer;\nLAB_00082902:\n  ptr = arg_ptr;\n  if ((*(char *)arg_ptr != '\\0') && (*(char *)arg_ptr != '%')) {\n    do {\n      ptr = (int *******)((int)ptr + 1);\n      if (*(char *)ptr == '\\0') break;\n    } while (*(char *)ptr != '%');\n    temp_ptr4 = (int *******)((int)ptr - (int)arg_ptr);\n    if (temp_ptr4 != (int *******)0x0) {\n      argCount_temp = argCount_temp + 1;\n      argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + (int)temp_ptr4);\n      *argData_ptr = arg_ptr;\n      argData_ptr[1] = temp_ptr4;\n      if (argCount_temp < 8) {\n        argData_ptr = argData_ptr + 2;\n      }\n      else {\n        if (argSizes_ptr_temp == (int *******)0x0) {\n          totalChars = totalChars + (int)temp_ptr4;\n          argCount_temp = 0;\n          argData_ptr = (int ********)tempBuffer;\n          goto LAB_00082952;\n        }\n        argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n        argData_ptr = (int ********)tempBuffer;\n        if (argCount != 0) goto LAB_00083142;\n      }\n      totalChars = totalChars + (int)temp_ptr4;\n    }\n  }\nLAB_00082952:\n  if (*(char *)ptr != '\\0') {\n    paddingChar = '\\0';\n    temp3 = (uint)*(byte *)((int)ptr + 1);\n    temp2 = 0;\n    isPositive = false;\n    isSigned = false;\n    isLeftJustified = false;\n    isAlternate = false;\n    isSigned6 = false;\n    temp_ptr4 = (int *******)0x0;\n    maxChars = (int *******)0xffffffff;\n    arg_ptr = (int *******)((int)ptr + 1);\nLAB_00082976:\n    arg_ptr = (int *******)((int)arg_ptr + 1);\nLAB_0008297a:\n    switch(temp3) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (temp3 != 0) {\n        numChars = (int *******)0x1;\n        maxChars = (int *******)0x1;\n        ppppppppiVar25 = (int ********)&paddingChar3;\n        paddingChar3 = (char)temp3;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      isAlternate = true;\n      temp3 = (uint)*(byte *)arg_ptr;\n      goto LAB_00082976;\n    case 0x2a:\n      temp_ptr4 = (int *******)*argSizes_ptr_temp;\n      argSizes_ptr_temp = argSizes_ptr_temp + 1;\n      if ((int)temp_ptr4 < 0) {\n        temp_ptr4 = (int *******)-(int)temp_ptr4;\n        goto switchD_00082984_caseD_2d;\n      }\n      temp3 = (uint)*(byte *)arg_ptr;\n      goto LAB_00082976;\n    case 0x2b:\n      temp3 = (uint)*(byte *)arg_ptr;\n      paddingChar = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      temp2 = temp2 | 4;\n      temp3 = (uint)*(byte *)arg_ptr;\n      goto LAB_00082976;\n    case 0x2e:\n      temp3 = (uint)*(byte *)arg_ptr;\n      ptr = (int *******)((int)arg_ptr + 1);\n      if (temp3 == 0x2a) {\n        temp3 = (uint)*(byte *)((int)arg_ptr + 1);\n        maxChars = (int *******)*argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        arg_ptr = ptr;\n        if ((int)maxChars < 0) {\n          maxChars = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      temp1 = temp3 - 0x30;\n      if (temp1 < 10) {\n        temp6 = 0;\n        do {\n          arg_ptr = (int *******)((int)ptr + 1);\n          temp3 = (uint)*(byte *)ptr;\n          temp6 = temp1 + temp6 * 10;\n          temp1 = temp3 - 0x30;\n          ptr = arg_ptr;\n        } while (temp1 < 10);\n        maxChars = (int *******)(temp6 | (int)temp6 >> 0x1f);\n      }\n      else {\n        maxChars = (int *******)0x0;\n        arg_ptr = ptr;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      temp2 = temp2 | 0x80;\n      temp3 = (uint)*(byte *)arg_ptr;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      isSigned = true;\n      if (isLeftJustified == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      argSizes_ptr_temp = (int **)((int)argSizes_ptr_temp + 7U & 0xfffffff8);\n      arg_ptr_temp = *argSizes_ptr_temp;\n      temp_ptr3 = argSizes_ptr_temp[1];\n      argSizes_ptr_temp = argSizes_ptr_temp + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      isSigned = true;\n      if (isLeftJustified != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      argCount = (uint)isSigned << 4;\n      temp4 = (uint)isLeftJustified << 5;\n      if ((isSigned == 0) && (temp4 = (uint)isSigned6 << 6, isSigned6 != 0)) {\n        arg_ptr_temp = (int *)(uint)*(ushort *)argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        temp_ptr3 = (int *)0x0;\n      }\n      else {\n        argCount = temp4;\n        arg_ptr_temp = *argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        temp_ptr3 = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      isSigned = true;\n      if (isLeftJustified != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((isSigned) || (isSigned6 == false)) {\n        argCount = 1;\n        arg_ptr_temp = *argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        temp_ptr3 = (int *)0x0;\n      }\n      else {\n        temp_ptr3 = (int *)0x0;\n        arg_ptr_temp = (int *)(uint)*(ushort *)argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        argCount = 1;\n      }\n      break;\n    case 0x58:\n      decimalDigits = \"0123456789ABCDEF\";\n      if (isLeftJustified == false) goto LAB_00082efa;\nLAB_00082d1a:\n      temp_ptr = (int **)((int)argSizes_ptr_temp + 7U & 0xfffffff8);\n      argSizes_ptr_temp = temp_ptr + 2;\n      arg_ptr_temp = *temp_ptr;\n      temp_ptr3 = temp_ptr[1];\n      goto LAB_00082d2e;\n    case 99:\n      arg_ptr_temp = *argSizes_ptr_temp;\n      argSizes_ptr_temp = argSizes_ptr_temp + 1;\n      numChars = (int *******)0x1;\n      paddingChar3 = SUB41(arg_ptr_temp,0);\n      maxChars = (int *******)0x1;\n      ppppppppiVar25 = (int ********)&paddingChar3;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (isLeftJustified != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((isSigned == false) && (isSigned6 != false)) {\n        arg_ptr_temp = (int *)(int)*(short *)argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        temp_ptr3 = (int *)((int)arg_ptr_temp >> 0x1f);\n      }\n      else {\n        arg_ptr_temp = *argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        temp_ptr3 = (int *)((int)arg_ptr_temp >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)temp_ptr3 < 0) {\n        isSigned6 = arg_ptr_temp != (int *)0x0;\n        arg_ptr_temp = (int *)-(int)arg_ptr_temp;\n        temp_ptr3 = (int *)(-(int)temp_ptr3 - (uint)isSigned6);\n        paddingChar = '-';\n        paddingChar = '-';\n        argCount = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)maxChars) {\n        temp2 = temp2 & 0xffffff7f;\n      }\n      isPositive = false;\n      temp3 = (uint)arg_ptr_temp | (uint)temp_ptr3;\n      argCount = 1;\n      paddingChar = paddingChar;\n      goto joined_r0x00082adc;\n    case 0x68:\n      isSigned6 = true;\n      temp3 = (uint)*(byte *)arg_ptr;\n      goto LAB_00082976;\n    case 0x6c:\n      temp3 = (uint)*(byte *)arg_ptr;\n      if (temp3 == 0x6c) {\n        isLeftJustified = true;\n        temp3 = (uint)*(byte *)((int)arg_ptr + 1);\n        arg_ptr = (int *******)((int)arg_ptr + 1);\n      }\n      else {\n        isSigned = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (isLeftJustified == false) {\n        if (isSigned == false) {\n          if (isSigned6) {\n            arg_ptr_temp = *argSizes_ptr_temp;\n            argSizes_ptr_temp = argSizes_ptr_temp + 1;\n            *(short *)arg_ptr_temp = (short)totalChars;\n          }\n          else {\n            arg_ptr_temp = *argSizes_ptr_temp;\n            argSizes_ptr_temp = argSizes_ptr_temp + 1;\n            *arg_ptr_temp = totalChars;\n          }\n        }\n        else {\n          arg_ptr_temp = *argSizes_ptr_temp;\n          argSizes_ptr_temp = argSizes_ptr_temp + 1;\n          *arg_ptr_temp = totalChars;\n        }\n      }\n      else {\n        arg_ptr_temp = *argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        *arg_ptr_temp = totalChars;\n        arg_ptr_temp[1] = totalChars >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (isLeftJustified == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      temp_ptr = (int **)((int)argSizes_ptr_temp + 7U & 0xfffffff8);\n      argSizes_ptr_temp = temp_ptr + 2;\n      arg_ptr_temp = *temp_ptr;\n      temp_ptr3 = temp_ptr[1];\n      argCount = 0;\n      break;\n    case 0x70:\n      arg_ptr_temp = *argSizes_ptr_temp;\n      argSizes_ptr_temp = argSizes_ptr_temp + 1;\n      paddingChar2 = 0x78;\n      isPositive = true;\n      temp_ptr3 = (int *)0x0;\n      paddingChar1 = 0x30;\n      decimalDigits = \"0123456789abcdef\";\n      argCount = 2;\n      break;\n    case 0x71:\n      isLeftJustified = true;\n      temp3 = (uint)*(byte *)arg_ptr;\n      goto LAB_00082976;\n    case 0x73:\n      ppppppppiVar25 = (int ********)*argSizes_ptr_temp;\n      paddingChar = '\\0';\n      argSizes_ptr_temp = argSizes_ptr_temp + 1;\n      if (ppppppppiVar25 != (int ********)0x0) {\n        if ((int)maxChars < 0) {\n          maxChars = (int *******)FUN_00082688(ppppppppiVar25);\n          ptr = (int *******)0x0;\n          paddingChar = paddingChar;\n        }\n        else {\n          argCount = FUN_000840f8(ppppppppiVar25,0,maxChars);\n          paddingChar = paddingChar;\n          if (argCount == 0) {\n            ptr = (int *******)0x0;\n          }\n          else {\n            temp_ptr2 = (int *******)(argCount - (int)ppppppppiVar25);\n            if ((int)maxChars <= (int)(int *******)(argCount - (int)ppppppppiVar25)) {\n              temp_ptr2 = maxChars;\n            }\n            ptr = (int *******)0x0;\n            maxChars = temp_ptr2;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < maxChars) {\n        maxChars = (int *******)0x6;\n      }\n      numChars = (int *******)((uint)maxChars & ~((int)maxChars >> 0x1f));\n      ppppppppiVar25 = (int ********)&UNK_00085728;\nLAB_00082d76:\n      paddingChar = '\\0';\n      ptr = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!isLeftJustified) goto LAB_00082ce0;\nLAB_00082bc6:\n      temp_ptr = (int **)((int)argSizes_ptr_temp + 7U & 0xfffffff8);\n      argSizes_ptr_temp = temp_ptr + 2;\n      arg_ptr_temp = *temp_ptr;\n      temp_ptr3 = temp_ptr[1];\n      argCount = 1;\n      break;\n    case 0x78:\n      decimalDigits = \"0123456789abcdef\";\n      if (isLeftJustified != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((isSigned == false) && (isSigned6 != false)) {\n        temp_ptr3 = (int *)0x0;\n        arg_ptr_temp = (int *)(uint)*(ushort *)argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n      }\n      else {\n        arg_ptr_temp = *argSizes_ptr_temp;\n        argSizes_ptr_temp = argSizes_ptr_temp + 1;\n        temp_ptr3 = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((isAlternate) && (((uint)arg_ptr_temp | (uint)temp_ptr3) != 0)) {\n        isPositive = true;\n        paddingChar1 = 0x30;\n        argCount = 2;\n        paddingChar2 = (char)temp3;\n      }\n      else {\n        argCount = 2;\n      }\n    }\n    paddingChar = '\\0';\n    paddingChar = '\\0';\nLAB_00082ace:\n    if (-1 < (int)maxChars) {\n      temp2 = temp2 & 0xffffff7f;\n    }\n    temp3 = (uint)arg_ptr_temp | (uint)temp_ptr3;\njoined_r0x00082adc:\n    combinedValue = CONCAT44(temp_ptr3,arg_ptr_temp);\n    ptr = maxChars;\n    if ((temp3 == 0) && (maxChars == (int *******)0x0)) {\n      ppppppppiVar25 = (int ********)tempBuffer;\n      if ((argCount != 0) || (!isAlternate)) goto LAB_00082b04;\n      ppppppppiVar25 = (int ********)(&cStack_6a + 1);\n      local_69 = '0';\n      goto LAB_00082afe;\n    }\n    if (argCount == 1) {\n      if (temp_ptr3 != (int *)0x0 || (int *)0x9 < arg_ptr_temp) {\n        temp_ptr1 = (int ********)(&cStack_6a + 1);\n        do {\n          ppppppppiVar25 = temp_ptr1;\n          uVar24 = (undefined4)((ulonglong)combinedValue >> 0x20);\n          char1 = '\\n';\n          FUN_00084530((int)combinedValue,uVar24,10,0);\n          *(char *)ppppppppiVar25 = char1 + '0';\n          combinedValue = FUN_00084530((int)combinedValue,uVar24,10,0);\n          temp_ptr1 = (int ********)((int)ppppppppiVar25 + -1);\n        } while (combinedValue != 0);\n        maxChars = (int *******)((int)tempBuffer - (int)ppppppppiVar25);\n        goto LAB_00082b04;\n      }\n      local_69 = (char)arg_ptr_temp + '0';\n      ppppppppiVar25 = (int ********)(&cStack_6a + 1);\n      goto LAB_00083282;\n    }\n    temp_ptr1 = (int ********)(&cStack_6a + 1);\n    if (argCount != 2) goto LAB_000830e2;\n    do {\n      ppppppppiVar25 = temp_ptr1;\n      temp3 = (uint)arg_ptr_temp & 0xf;\n      arg_ptr_temp = (int *)((uint)arg_ptr_temp >> 4 | (int)temp_ptr3 << 0x1c);\n      temp_ptr3 = (int *)((uint)temp_ptr3 >> 4);\n      *(char *)ppppppppiVar25 = decimalDigits[temp3];\n      temp_ptr1 = (int ********)((int)ppppppppiVar25 + -1);\n    } while (((uint)arg_ptr_temp | (uint)temp_ptr3) != 0);\n    maxChars = (int *******)((int)tempBuffer - (int)ppppppppiVar25);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (argSizes_ptr_temp != (int *******)0x0) {\n    FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(format_ptr + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return totalChars;\nLAB_000830e2:\n  do {\n    ppppppppiVar25 = temp_ptr1;\n    arg_ptr_1 = (int *)((uint)arg_ptr_temp >> 3 | (int)temp_ptr3 << 0x1d);\n    temp_ptr3 = (int *)((uint)temp_ptr3 >> 3);\n    argCount = ((uint)arg_ptr_temp & 7) + 0x30;\n    *(char *)ppppppppiVar25 = (char)argCount;\n    temp_ptr1 = (int ********)((int)ppppppppiVar25 + -1);\n    arg_ptr_temp = arg_ptr_1;\n  } while (((uint)arg_ptr_1 | (uint)temp_ptr3) != 0);\n  if (isAlternate) {\n    if (argCount == 0x30) {\nLAB_00082afe:\n      maxChars = (int *******)((int)tempBuffer - (int)ppppppppiVar25);\n    }\n    else {\n      *(undefined *)((int)ppppppppiVar25 + -1) = 0x30;\n      ppppppppiVar25 = temp_ptr1;\n      maxChars = (int *******)((int)tempBuffer - (int)temp_ptr1);\n    }\n  }\n  else {\nLAB_00083282:\n    maxChars = (int *******)((int)tempBuffer - (int)ppppppppiVar25);\n  }\nLAB_00082b04:\n  numChars = maxChars;\n  if ((int)maxChars < (int)ptr) {\n    numChars = ptr;\n  }\n  if (paddingChar != '\\0') {\n    numChars = (int *******)((int)numChars + 1);\n  }\nLAB_00082b1e:\n  if (isPositive) {\n    numChars = (int *******)((int)numChars + 2);\n  }\n  if ((temp2 == 0) &&\n     (temp_ptr2 = (int *******)((int)temp_ptr4 - (int)numChars), 0 < (int)temp_ptr2)) {\n    if ((int)temp_ptr2 < 0x11) {\n      argCount_temp = argCount_temp + 1;\n    }\n    else {\n      do {\n        temp_ptr5 = temp_ptr2;\n        argCount = argCount_temp + 1;\n        argSizes_ptr_temp = argSizes_ptr_temp + 4;\n        *argData_ptr = (int *******)0x856f0;\n        argData_ptr[1] = (int *******)0x10;\n        if (argCount < 8) {\n          temp4 = argCount_temp + 2;\n          argData_ptr = argData_ptr + 2;\n          argCount_temp = argCount;\n        }\n        else if (argSizes_ptr_temp == (int *******)0x0) {\n          temp4 = 1;\n          argData_ptr = (int ********)tempBuffer;\n          argCount_temp = 0;\n        }\n        else {\n          argCount_temp = argCount;\n          argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n          if (argCount != 0) goto LAB_00083142;\n          temp4 = argCount_temp + 1;\n          argData_ptr = (int ********)tempBuffer;\n        }\n        temp_ptr2 = temp_ptr5 + -4;\n      } while (0x10 < (int)temp_ptr2);\n      temp_ptr2 = temp_ptr5 + -4;\n      argCount_temp = temp4;\n    }\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + (int)temp_ptr2);\n    *argData_ptr = (int *******)0x856f0;\n    argData_ptr[1] = temp_ptr2;\n    if (argCount_temp < 8) {\n      argCount = argCount_temp + 1;\n      argData_ptr = argData_ptr + 2;\n    }\n    else if (argSizes_ptr_temp == (int *******)0x0) {\n      argCount = 1;\n      argCount_temp = 0;\n      argData_ptr = (int ********)tempBuffer;\n    }\n    else {\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n      argCount = argCount_temp + 1;\n      argData_ptr = (int ********)tempBuffer;\n    }\n  }\n  else {\n    argCount = argCount_temp + 1;\n  }\n  temp4 = argCount;\n  if (paddingChar != '\\0') {\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + 1);\n    temp4 = 1;\n    *argData_ptr = (int *******)&paddingChar;\n    argData_ptr[1] = (int *******)0x1;\n    argCount_temp = argCount;\n    if (argCount < 8) {\n      temp4 = argCount + 1;\n      argData_ptr = argData_ptr + 2;\n    }\n    else if (argSizes_ptr_temp == (int *******)0x0) {\n      argCount_temp = 0;\n      argData_ptr = (int ********)tempBuffer;\n    }\n    else {\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n      temp4 = argCount_temp + 1;\n      argData_ptr = (int ********)tempBuffer;\n    }\n  }\n  argCount = temp4;\n  temp5 = argCount_temp;\n  if (isPositive) {\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + 2);\n    *argData_ptr = (int *******)&paddingChar1;\n    argData_ptr[1] = (int *******)0x2;\n    if (temp4 < 8) {\n      argCount = temp4 + 1;\n      temp5 = temp4;\n      argData_ptr = argData_ptr + 2;\n    }\n    else if (argSizes_ptr_temp == (int *******)0x0) {\n      argCount = 1;\n      temp5 = 0;\n      argData_ptr = (int ********)tempBuffer;\n    }\n    else {\n      argCount_temp = temp4;\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n      argCount = argCount_temp + 1;\n      temp5 = argCount_temp;\n      argData_ptr = (int ********)tempBuffer;\n    }\n  }\n  argCount_temp = temp5;\n  if ((temp2 == 0x80) &&\n     (temp_ptr2 = (int *******)((int)temp_ptr4 - (int)numChars), 0 < (int)temp_ptr2)) {\n    if (0x10 < (int)temp_ptr2) {\n      do {\n        while( true ) {\n          temp_ptr5 = temp_ptr2;\n          argCount_temp = temp5 + 1;\n          argSizes_ptr_temp = argSizes_ptr_temp + 4;\n          *argData_ptr = (int *******)\"0000000000000000\";\n          argData_ptr[1] = (int *******)0x10;\n          if (7 < argCount_temp) break;\n          argCount = temp5 + 2;\n          argData_ptr = argData_ptr + 2;\nLAB_000831f2:\n          temp5 = argCount_temp;\n          temp_ptr2 = temp_ptr5 + -4;\n          if ((int)(temp_ptr5 + -4) < 0x11) goto LAB_00083218;\n        }\n        if (argSizes_ptr_temp != (int *******)0x0) {\n          argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n          if (argCount == 0) {\n            argCount = argCount_temp + 1;\n            argData_ptr = (int ********)tempBuffer;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        argCount = 1;\n        temp5 = 0;\n        temp_ptr2 = temp_ptr5 + -4;\n        argData_ptr = (int ********)tempBuffer;\n      } while (0x10 < (int)(temp_ptr5 + -4));\nLAB_00083218:\n      temp_ptr2 = temp_ptr5 + -4;\n    }\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + (int)temp_ptr2);\n    *argData_ptr = (int *******)\"0000000000000000\";\n    argData_ptr[1] = temp_ptr2;\n    argCount_temp = argCount;\n    if (argCount < 8) {\n      argCount = argCount + 1;\n      argData_ptr = argData_ptr + 2;\n    }\n    else if (argSizes_ptr_temp == (int *******)0x0) {\n      argCount = 1;\n      argCount_temp = 0;\n      argData_ptr = (int ********)tempBuffer;\n    }\n    else {\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n      argCount = argCount_temp + 1;\n      argData_ptr = (int ********)tempBuffer;\n    }\n  }\n  ptr = (int *******)((int)ptr - (int)maxChars);\n  temp_ptr1 = (int ********)tempBuffer;\n  if ((int)ptr < 1) {\nLAB_0008302a:\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + (int)maxChars);\n    *argData_ptr = (int *******)ppppppppiVar25;\n    argData_ptr[1] = maxChars;\n    maxChars = argSizes_ptr_temp;\n    argCount_temp = argCount;\n    if (argCount < 8) goto LAB_000831be;\n    if (argSizes_ptr_temp == (int *******)0x0) {\n      argCount_temp = 0;\n    }\n    else {\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    temp4 = argCount_temp;\n    if (0x10 < (int)ptr) {\n      do {\n        while( true ) {\n          temp_ptr2 = ptr;\n          argCount_temp = temp4 + 1;\n          argSizes_ptr_temp = argSizes_ptr_temp + 4;\n          *argData_ptr = (int *******)\"0000000000000000\";\n          argData_ptr[1] = (int *******)0x10;\n          if (7 < argCount_temp) break;\n          argCount = temp4 + 2;\n          argData_ptr = argData_ptr + 2;\nLAB_00082fe6:\n          temp4 = argCount_temp;\n          ptr = temp_ptr2 + -4;\n          if ((int)(temp_ptr2 + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (argSizes_ptr_temp != (int *******)0x0) {\n          argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n          if (argCount == 0) {\n            argCount = argCount_temp + 1;\n            argData_ptr = (int ********)tempBuffer;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        argCount = 1;\n        argData_ptr = (int ********)tempBuffer;\n        temp4 = 0;\n        ptr = temp_ptr2 + -4;\n      } while (0x10 < (int)(temp_ptr2 + -4));\nLAB_0008300e:\n      ptr = temp_ptr2 + -4;\n    }\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + (int)ptr);\n    *argData_ptr = (int *******)\"0000000000000000\";\n    argData_ptr[1] = ptr;\n    if (argCount < 8) {\n      argCount = argCount + 1;\n      argData_ptr = argData_ptr + 2;\n      goto LAB_0008302a;\n    }\n    if (argSizes_ptr_temp != (int *******)0x0) {\n      argCount_temp = argCount;\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n      argCount = argCount_temp + 1;\n      argData_ptr = (int ********)tempBuffer;\n      goto LAB_0008302a;\n    }\n    local_64[0] = maxChars;\n    argCount_temp = 1;\n    argData_ptr = (int ********)tempBuffer;\n    tempBuffer = (undefined  [4])ppppppppiVar25;\nLAB_000831be:\n    temp_ptr1 = argData_ptr + 2;\n    argSizes_ptr_temp = maxChars;\n  }\n  if (((temp2 & 4) != 0) &&\n     (ptr = (int *******)((int)temp_ptr4 - (int)numChars), 0 < (int)ptr)) {\n    argCount = argCount_temp;\n    if ((int)ptr < 0x11) {\n      temp4 = argCount_temp + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          argCount_temp = argCount + 1;\n          argSizes_ptr_temp = argSizes_ptr_temp + 4;\n          *temp_ptr1 = (int *******)0x856f0;\n          temp_ptr1[1] = (int *******)0x10;\n          if (7 < argCount_temp) break;\n          temp4 = argCount + 2;\n          temp_ptr1 = temp_ptr1 + 2;\nLAB_0008307a:\n          ptr = ptr + -4;\n          argCount = argCount_temp;\n          if ((int)ptr < 0x11) goto LAB_000830a2;\n        }\n        if (argSizes_ptr_temp != (int *******)0x0) {\n          argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n          if (argCount == 0) {\n            temp4 = argCount_temp + 1;\n            temp_ptr1 = (int ********)tempBuffer;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        ptr = ptr + -4;\n        temp4 = 1;\n        argCount = 0;\n        temp_ptr1 = (int ********)tempBuffer;\n      } while (0x10 < (int)ptr);\n    }\nLAB_000830a2:\n    argSizes_ptr_temp = (int *******)((int)argSizes_ptr_temp + (int)ptr);\n    *temp_ptr1 = (int *******)0x856f0;\n    temp_ptr1[1] = ptr;\n    argCount_temp = temp4;\n    if (7 < temp4) {\n      if (argSizes_ptr_temp == (int *******)0x0) {\n        if ((int)numChars < (int)temp_ptr4) {\n          numChars = temp_ptr4;\n        }\n        totalChars = totalChars + (int)numChars;\n        goto LAB_00083186;\n      }\n      argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp);\n      if (argCount != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)numChars < (int)temp_ptr4) {\n    numChars = temp_ptr4;\n  }\n  totalChars = totalChars + (int)numChars;\n  if ((argSizes_ptr_temp != (int *******)0x0) &&\n     (argCount = FUN_00082824(str_ptr,format_ptr,&argData_ptr_temp), argCount != 0)) goto LAB_00083142;\nLAB_00083186:\n  argCount_temp = 0;\n  argData_ptr = (int ********)tempBuffer;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  temp1 = temp3 - 0x30;\n  temp_ptr4 = (int *******)0x0;\n  ptr = arg_ptr;\n  do {\n    arg_ptr = (int *******)((int)ptr + 1);\n    temp3 = (uint)*(byte *)ptr;\n    temp_ptr4 = (int *******)(temp1 + (int)temp_ptr4 * 10);\n    temp1 = temp3 - 0x30;\n    ptr = arg_ptr;\n  } while (temp1 < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  temp3 = (uint)*(byte *)arg_ptr;\n  if (paddingChar == '\\0') {\n    paddingChar = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "format_string_0008289c",
                "param_1": "str_ptr",
                "param_2": "format_ptr",
                "param_3": "arg_ptr",
                "param_4": "argSizes_ptr",
                "bVar1": "isLeftJustified",
                "bVar2": "isSigned",
                "bVar3": "isAlternate",
                "cVar4": "paddingChar",
                "bVar5": "isPositive",
                "ppppppppiVar6": "argData_ptr",
                "piVar7": "arg_ptr_1",
                "iVar8": "argCount",
                "cVar9": "char1",
                "pppppppiVar10": "ptr",
                "uVar11": "temp1",
                "ppiVar12": "temp_ptr",
                "uVar13": "temp2",
                "uVar14": "temp3",
                "iVar15": "temp4",
                "ppppppppiVar16": "temp_ptr1",
                "iVar17": "temp5",
                "pppppppiVar18": "temp_ptr2",
                "piVar19": "arg_ptr_temp",
                "piVar22": "temp_ptr3",
                "pppppppiVar20": "temp_ptr4",
                "uVar21": "temp6",
                "pppppppiVar16": "temp_ptr1",
                "pppppppiVar23": "temp_ptr5",
                "lVar27": "combinedValue",
                "local_dc": "numChars",
                "local_d4": "maxChars",
                "local_c8": "argSizes_ptr_temp",
                "local_c4": "totalChars",
                "local_c0": "decimalDigits",
                "local_a1": "paddingChar",
                "local_a0": "paddingChar1",
                "local_9f": "paddingChar2",
                "local_9c": "argData_ptr_temp",
                "local_98": "argCount_temp",
                "local_94": "argSizes_ptr_temp",
                "local_90": "paddingChar3",
                "local_68": "tempBuffer"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00081750",
                "FUN_000817c8"
            ],
            "called": [
                "FUN_000834f0",
                "FUN_00082824",
                "FUN_0008356c",
                "FUN_000840f8",
                "FUN_00084530",
                "FUN_00082688",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "process_data_000834f0",
            "code": "\nint processData_000834f0(undefined4 input,int dataAddress)\n\n{\n  int returnValue;\n  int checkValue;\n  undefined *bufferArray [2];\n  undefined4 bufferSize;\n  ushort localVar1;\n  undefined2 localVar2;\n  undefined *localVar3;\n  undefined4 localVar4;\n  undefined4 localVar5;\n  undefined4 localVar6;\n  undefined4 localVar7;\n  undefined4 localVar8;\n  undefined stackArray [1024];\n  \n  localVar8 = *(undefined4 *)(dataAddress + 100);\n  localVar6 = *(undefined4 *)(dataAddress + 0x1c);\n  localVar2 = *(undefined2 *)(dataAddress + 0xe);\n  localVar7 = *(undefined4 *)(dataAddress + 0x24);\n  bufferArray[0] = stackArray;\n  localVar1 = *(ushort *)(dataAddress + 0xc) & 0xfffd;\n  bufferSize = 0x400;\n  localVar4 = 0x400;\n  localVar5 = 0;\n  localVar3 = bufferArray[0];\n  returnValue = FUN_0008289c(input,bufferArray);\n  if ((-1 < returnValue) && (checkValue = FUN_00083850(input,bufferArray), checkValue != 0)) {\n    returnValue = -1;\n  }\n  if ((int)((uint)localVar1 << 0x19) < 0) {\n    *(ushort *)(dataAddress + 0xc) = *(ushort *)(dataAddress + 0xc) | 0x40;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "process_data_000834f0",
                "param_1": "input",
                "param_2": "dataAddress",
                "iVar1": "returnValue",
                "iVar2": "checkValue",
                "local_488": "bufferArray",
                "local_480": "bufferSize",
                "local_47c": "localVar1",
                "local_47a": "localVar2",
                "local_478": "localVar3",
                "local_474": "localVar4",
                "local_470": "localVar5",
                "local_46c": "localVar6",
                "local_464": "localVar7",
                "local_424": "localVar8",
                "auStack_420": "stackArray"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008289c",
                "FUN_00083850"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "process_data_0008356c",
            "code": "\nundefined4 processData_0008356c(undefined4 *result,int *data)\n\n{\n  int tempVar1;\n  int tempVar2;\n  uint ushortVal;\n  ushort ushortVal2;\n  \n  if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  ushortVal2 = *(ushort *)(data + 3);\n  ushortVal = (uint)ushortVal2;\n  if ((int)(ushortVal << 0x1c) < 0) {\n    tempVar2 = data[4];\n  }\n  else {\n    if (-1 < (int)(ushortVal << 0x1b)) {\n      *result = 9;\n      *(ushort *)(data + 3) = ushortVal2 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(ushortVal << 0x1d) < 0) {\n      if ((int *)data[0xc] != (int *)0x0) {\n        if ((int *)data[0xc] != data + 0x10) {\n          FUN_00083b10(result);\n          ushortVal2 = *(ushort *)(data + 3);\n        }\n        data[0xc] = 0;\n      }\n      tempVar2 = data[4];\n      ushortVal2 = ushortVal2 & 0xffdb;\n      *data = tempVar2;\n      data[1] = 0;\n    }\n    else {\n      tempVar2 = data[4];\n    }\n    *(ushort *)(data + 3) = ushortVal2 | 8;\n    ushortVal = (uint)(ushortVal2 | 8);\n  }\n  if ((tempVar2 == 0) && ((ushortVal & 0x280) != 0x200)) {\n    FUN_00084018(result,data);\n    ushortVal = (uint)*(ushort *)(data + 3);\n    tempVar2 = data[4];\n  }\n  if ((ushortVal & 1) == 0) {\n    tempVar1 = 0;\n    if (-1 < (int)(ushortVal << 0x1e)) {\n      tempVar1 = data[5];\n    }\n    data[2] = tempVar1;\n  }\n  else {\n    data[6] = -data[5];\n    data[2] = 0;\n  }\n  if ((tempVar2 == 0) && ((int)((uint)*(ushort *)(data + 3) << 0x18) < 0)) {\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "process_data_0008356c",
                "param_1": "result",
                "param_2": "data",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "ushortVal",
                "uVar4": "ushortVal2"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00084018",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x00083630) */\n/* WARNING: Removing unreachable block (ram,0x000836c4) */\n/* WARNING: Removing unreachable block (ram,0x00083642) */\n/* WARNING: Removing unreachable block (ram,0x00083648) */\n/* WARNING: Removing unreachable block (ram,0x00083654) */\n/* WARNING: Removing unreachable block (ram,0x0008366e) */\n/* WARNING: Removing unreachable block (ram,0x0008364c) */\n/* WARNING: Removing unreachable block (ram,0x00083686) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n/* WARNING: Removing unreachable block (ram,0x00083688) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "initialize_relocations_000836ec",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n\nvoid initializeRelocations_000836ec(void)\n\n{\n  dword *relocationTablePtr;\n  dword relocationValue;\n  int relocationCount;\n  code *errorHandler;\n  \n  FUN_000841e4(6);\n  errorHandler = (code *)0x836fb;\n  relocationValue = FUN_00080eec(1);\n  if (relocationArray[48].r_offset == 0) {\n    relocationArray[48].r_offset = 0x20070184;\n  }\n  relocationCount = *(int *)(relocationArray[48].r_offset + 4);\n  relocationTablePtr = (dword *)relocationArray[48].r_offset;\n  if (0x1f < relocationCount) {\n    relocationTablePtr = (dword *)FUN_000817f0(400);\n    if (relocationTablePtr == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*errorHandler)(0xffffffff);\n      return;\n    }\n    *relocationTablePtr = relocationArray[48].r_offset;\n    relocationTablePtr[1] = 0;\n    relocationCount = 0;\n    relocationArray[48].r_offset = (dword)relocationTablePtr;\n    relocationTablePtr[0x62] = 0;\n    relocationTablePtr[99] = 0;\n  }\n  relocationTablePtr[1] = relocationCount + 1;\n  relocationTablePtr[relocationCount + 2] = relocationValue;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*errorHandler)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836ec": "initialize_relocations_000836ec",
                "pdVar1": "relocationTablePtr",
                "dVar2": "relocationValue",
                "iVar3": "relocationCount",
                "UNRECOVERED_JUMPTABLE_00": "errorHandler",
                "Elf32_Rel_ARRAY_20070000": "relocationArray"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_000841e4",
                "FUN_00080eec",
                "FUN_000817f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "process_data_00083850",
            "code": "\nundefined4 processData_00083850(int *dataBuffer,int *metadata)\n\n{\n  int *ptr;\n  int size;\n  ushort metadataFlags;\n  uint flags;\n  int partSize;\n  code *callback;\n  undefined4 result;\n  int tempVar;\n  \n  if ((dataBuffer != (int *)0x0) && (dataBuffer[0xe] == 0)) {\n    FUN_00083888();\n  }\n  if (*(short *)(metadata + 3) == 0) {\n    return 0;\n  }\n  metadataFlags = *(ushort *)(metadata + 3);\n  if ((int)((uint)metadataFlags << 0x1c) < 0) {\n    tempVar = metadata[4];\n    if (tempVar == 0) {\n      return 0;\n    }\n    size = *metadata;\n    if ((metadataFlags & 3) == 0) {\n      partSize = metadata[5];\n    }\n    else {\n      partSize = 0;\n    }\n    *metadata = tempVar;\n    size = size - tempVar;\n    metadata[2] = partSize;\n    do {\n      if (size < 1) {\n        return 0;\n      }\n      partSize = (*(code *)metadata[9])(dataBuffer,metadata[7],tempVar,size,result);\n      size = size - partSize;\n      tempVar = tempVar + partSize;\n    } while (0 < partSize);\nLAB_000837c8:\n    *(ushort *)(metadata + 3) = *(ushort *)(metadata + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(metadata + 3) = metadataFlags | 0x800;\n  if ((metadata[1] < 1) && (metadata[0xf] < 1)) {\n    return 0;\n  }\n  callback = (code *)metadata[10];\n  if (callback == (code *)0x0) {\n    return 0;\n  }\n  flags = (uint)(metadataFlags | 0x800);\n  tempVar = *dataBuffer;\n  *dataBuffer = 0;\n  if ((metadataFlags & 0x1000) == 0) {\n    size = (*callback)(dataBuffer,metadata[7],flags & 0x1000,1);\n    if ((size == -1) && (partSize = *dataBuffer, partSize != 0)) {\n      if ((partSize == 0x1d) || (partSize == 0x16)) {\n        *dataBuffer = tempVar;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    flags = (uint)*(ushort *)(metadata + 3);\n    callback = (code *)metadata[10];\n  }\n  else {\n    size = metadata[0x14];\n  }\n  if (((int)(flags << 0x1d) < 0) && (size = size - metadata[1], metadata[0xc] != 0)) {\n    size = size - metadata[0xf];\n  }\n  size = (*callback)(dataBuffer,metadata[7],size,0);\n  if (size == -1) {\n    partSize = *dataBuffer;\n    if (partSize != 0) {\n      if ((partSize != 0x1d) && (partSize != 0x16)) {\n        *(ushort *)(metadata + 3) = *(ushort *)(metadata + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(metadata + 3) = *(ushort *)(metadata + 3) & 0xf7ff;\n      *metadata = metadata[4];\n      metadata[1] = 0;\n      goto LAB_00083774;\n    }\n    metadataFlags = *(ushort *)(metadata + 3) & 0xf7ff;\n    metadata[1] = 0;\n    *(ushort *)(metadata + 3) = metadataFlags;\n    *metadata = metadata[4];\n  }\n  else {\n    metadataFlags = *(ushort *)(metadata + 3) & 0xf7ff;\n    *metadata = metadata[4];\n    *(ushort *)(metadata + 3) = metadataFlags;\n    metadata[1] = 0;\n  }\n  if ((int)((uint)metadataFlags << 0x13) < 0) {\n    metadata[0x14] = size;\n  }\nLAB_00083774:\n  ptr = (int *)metadata[0xc];\n  *dataBuffer = tempVar;\n  if (ptr == (int *)0x0) {\n    return 0;\n  }\n  if (ptr != metadata + 0x10) {\n    FUN_00083b10(dataBuffer);\n  }\n  metadata[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083850": "process_data_00083850",
                "param_1": "dataBuffer",
                "param_2": "metadata",
                "piVar1": "ptr",
                "iVar2": "size",
                "uVar3": "metadataFlags",
                "uVar4": "flags",
                "iVar5": "partSize",
                "pcVar6": "callback",
                "unaff_r4": "result",
                "iVar7": "tempVar"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00084484",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_data_structures_00083888",
            "code": "\nvoid initializeDataStructures_00083888(int dataStruct)\n\n{\n  undefined4 *ptr1;\n  undefined4 *ptr2;\n  \n  if (*(int *)(dataStruct + 0x38) == 0) {\n    ptr1 = *(undefined4 **)(dataStruct + 4);\n    *(undefined **)(dataStruct + 0x3c) = &LAB_0008387c_1;\n    *(undefined4 *)(dataStruct + 0x2e4) = 3;\n    *(int *)(dataStruct + 0x2e8) = dataStruct + 0x2ec;\n    *(undefined4 *)(dataStruct + 0x2e0) = 0;\n    *(undefined2 *)(ptr1 + 3) = 4;\n    *ptr1 = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[0x19] = 0;\n    *(undefined2 *)((int)ptr1 + 0xe) = 0;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    FUN_00081f00(ptr1 + 0x17,0,8);\n    ptr2 = *(undefined4 **)(dataStruct + 8);\n    ptr1[7] = ptr1;\n    ptr1[8] = 0x84221;\n    ptr1[9] = 0x84245;\n    ptr1[10] = 0x8427d;\n    ptr1[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)((int)ptr2 + 0xe) = 1;\n    *(undefined2 *)(ptr2 + 3) = 9;\n    *ptr2 = 0;\n    ptr2[1] = 0;\n    ptr2[2] = 0;\n    ptr2[0x19] = 0;\n    ptr2[4] = 0;\n    ptr2[5] = 0;\n    ptr2[6] = 0;\n    FUN_00081f00(ptr2 + 0x17,0,8);\n    ptr1 = *(undefined4 **)(dataStruct + 0xc);\n    ptr2[7] = ptr2;\n    ptr2[8] = 0x84221;\n    ptr2[9] = 0x84245;\n    ptr2[10] = 0x8427d;\n    ptr2[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)(ptr1 + 3) = 0x12;\n    *(undefined2 *)((int)ptr1 + 0xe) = 2;\n    *ptr1 = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[0x19] = 0;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    FUN_00081f00(ptr1 + 0x17,0,8);\n    ptr1[7] = ptr1;\n    ptr1[8] = 0x84221;\n    ptr1[9] = 0x84245;\n    ptr1[10] = 0x8427d;\n    ptr1[0xb] = &LAB_0008429c_1;\n    *(undefined4 *)(dataStruct + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_data_structures_00083888",
                "param_1": "dataStruct",
                "puVar1": "ptr1",
                "puVar2": "ptr2"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_000842a4"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "process_data_000839b4",
            "code": "\nuint processData_000839b4(undefined4 input1,uint input2,byte **input3)\n\n{\n  int result;\n  uint flag;\n  uint value;\n  byte *ptr;\n  uint counter;\n  byte temp1;\n  byte temp2 [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(input3 + 3) << 0x12)) {\n    *(ushort *)(input3 + 3) = *(ushort *)(input3 + 3) | 0x2000;\n    input3[0x19] = (byte *)((uint)input3[0x19] | 0x2000);\n  }\n  result = FUN_0008400c();\n  if ((result == 1) && (input2 - 1 < 0xff)) {\n    value = input2 & 0xff;\n    temp1 = (byte)value;\n    flag = 1;\n  }\n  else {\n    flag = FUN_0008434c(input1,&temp1,input2,input3 + 0x17);\n    if (flag == 0xffffffff) {\n      *(ushort *)(input3 + 3) = *(ushort *)(input3 + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (flag == 0) {\n      return input2;\n    }\n    value = (uint)temp1;\n  }\n  counter = 0;\n  do {\n    ptr = input3[2] + -1;\n    input3[2] = ptr;\n    if ((int)ptr < 0) {\n      if ((int)input3[6] <= (int)ptr) {\n        **input3 = (byte)value;\n        ptr = *input3;\n        value = (uint)*ptr;\n        if (value != 10) goto LAB_00083a04;\n      }\n      result = FUN_000842a4(input1,value,input3);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **input3 = (byte)value;\n      ptr = *input3;\nLAB_00083a04:\n      *input3 = ptr + 1;\n    }\n    if (flag <= counter + 1) {\n      return input2;\n    }\n    value = (uint)temp2[counter];\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "process_data_000839b4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "iVar1": "result",
                "uVar2": "flag",
                "uVar3": "value",
                "pbVar4": "ptr",
                "uVar5": "counter",
                "local_1c": "temp1",
                "abStack_1b": "temp2"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_0008434c",
                "FUN_0008400c",
                "FUN_000842a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "relocate_memory_region_00083a74",
            "code": "\nundefined4 relocateMemoryRegion_00083a74(undefined4 param_1,int numBytesToRelocate)\n\n{\n  int result;\n  uint relInfoVal;\n  int newStartAddress;\n  \n  FUNC_00081f94();\n  relInfoVal = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  newStartAddress = ((relInfoVal - numBytesToRelocate) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < newStartAddress) {\n    result = FUN_0008236c(param_1,0);\n    if (result == Elf32_Rel_ARRAY_20070000[141].r_info + relInfoVal) {\n      result = FUN_0008236c(param_1,-newStartAddress);\n      if (result != -1) {\n        DAT_2007121c = DAT_2007121c - newStartAddress;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = relInfoVal - newStartAddress | 1;\n        FUNC_00081f98(param_1);\n        return 1;\n      }\n      newStartAddress = FUN_0008236c(param_1,0);\n      if (0xf < (int)(newStartAddress - Elf32_Rel_ARRAY_20070000[141].r_info)) {\n        DAT_2007121c = newStartAddress - Elf32_Rel_ARRAY_20070000[270].r_offset;\n        *(dword *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) =\n             newStartAddress - Elf32_Rel_ARRAY_20070000[141].r_info | 1;\n      }\n    }\n  }\n  FUNC_00081f98(param_1);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "relocate_memory_region_00083a74",
                "param_2": "numBytesToRelocate",
                "iVar1": "result",
                "uVar2": "relInfoVal",
                "iVar3": "newStartAddress"
            },
            "calling": [
                "FUN_00083b10"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "update_relocation_table_00083b10",
            "code": "\nvoid updateRelocationTable_00083b10(undefined4 param1,int param2)\n\n{\n  int prevSymbol;\n  bool isSymbol2007046c;\n  uint symbolInfo;\n  dword currentRelocEntry;\n  int nextSymbol;\n  uint symbolOffset;\n  dword currentSymbol;\n  uint newSymbolOffset;\n  dword prevRelocEntry;\n  \n  if (param2 == 0) {\n    return;\n  }\n  FUNC_00081f94();\n  symbolInfo = *(uint *)(param2 + -4);\n  currentSymbol = param2 - 8;\n  symbolOffset = symbolInfo & 0xfffffffe;\n  currentRelocEntry = currentSymbol + symbolOffset;\n  newSymbolOffset = *(uint *)(currentRelocEntry + 4) & 0xfffffffc;\n  if (Elf32_Rel_ARRAY_20070000[141].r_info == currentRelocEntry) {\n    newSymbolOffset = newSymbolOffset + symbolOffset;\n    if (-1 < (int)(symbolInfo << 0x1f)) {\n      currentSymbol = currentSymbol - *(int *)(param2 + -8);\n      nextSymbol = *(int *)(currentSymbol + 0xc);\n      prevSymbol = *(int *)(currentSymbol + 8);\n      newSymbolOffset = newSymbolOffset + *(int *)(param2 + -8);\n      *(int *)(prevSymbol + 0xc) = nextSymbol;\n      *(int *)(nextSymbol + 8) = prevSymbol;\n    }\n    currentRelocEntry = Elf32_Rel_ARRAY_20070000[269].r_info;\n    *(uint *)(currentSymbol + 4) = newSymbolOffset | 1;\n    Elf32_Rel_ARRAY_20070000[141].r_info = currentSymbol;\n    if (currentRelocEntry <= newSymbolOffset) {\n      FUN_00083a74(param1,DAT_20071218);\n    }\n  }\n  else {\n    *(uint *)(currentRelocEntry + 4) = newSymbolOffset;\n    if ((symbolInfo & 1) == 0) {\n      currentSymbol = currentSymbol - *(int *)(param2 + -8);\n      prevSymbol = *(int *)(currentSymbol + 8);\n      symbolOffset = symbolOffset + *(int *)(param2 + -8);\n      if (prevSymbol == 0x2007046c) {\n        isSymbol2007046c = true;\n      }\n      else {\n        nextSymbol = *(int *)(currentSymbol + 0xc);\n        *(int *)(prevSymbol + 0xc) = nextSymbol;\n        *(int *)(nextSymbol + 8) = prevSymbol;\n        isSymbol2007046c = false;\n      }\n    }\n    else {\n      isSymbol2007046c = false;\n    }\n    if (-1 < *(int *)(currentRelocEntry + newSymbolOffset + 4) << 0x1f) {\n      symbolOffset = symbolOffset + newSymbolOffset;\n      prevSymbol = *(int *)(currentRelocEntry + 8);\n      if ((!isSymbol2007046c) && (prevSymbol == 0x2007046c)) {\n        Elf32_Rel_ARRAY_20070000[142].r_info = currentSymbol;\n        Elf32_Rel_ARRAY_20070000[143].r_offset = currentSymbol;\n        *(undefined4 *)(currentSymbol + 0xc) = 0x2007046c;\n        *(undefined4 *)(currentSymbol + 8) = 0x2007046c;\n        *(uint *)(currentSymbol + 4) = symbolOffset | 1;\n        *(uint *)(currentSymbol + symbolOffset) = symbolOffset;\n        goto LAB_00083ba4;\n      }\n      nextSymbol = *(int *)(currentRelocEntry + 0xc);\n      *(int *)(prevSymbol + 0xc) = nextSymbol;\n      *(int *)(nextSymbol + 8) = prevSymbol;\n    }\n    *(uint *)(currentSymbol + 4) = symbolOffset | 1;\n    *(uint *)(currentSymbol + symbolOffset) = symbolOffset;\n    if (!isSymbol2007046c) {\n      if (symbolOffset < 0x200) {\n        symbolInfo = symbolOffset & 0xfffffff8;\n        prevSymbol = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + symbolInfo);\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << ((int)(symbolOffset >> 3) >> 2 & 0xffU);\n        *(int *)(currentSymbol + 8) = prevSymbol;\n        *(uint *)(currentSymbol + 0xc) = symbolInfo + 0x20070464;\n        *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + symbolInfo) = currentSymbol;\n        *(dword *)(prevSymbol + 0xc) = currentSymbol;\n        FUNC_00081f98(param1);\n        return;\n      }\n      symbolInfo = symbolOffset >> 9;\n      if (symbolInfo < 5) {\n        prevSymbol = (symbolOffset >> 6) + 0x38;\n        nextSymbol = prevSymbol * 2;\n      }\n      else if (symbolInfo < 0x15) {\n        prevSymbol = symbolInfo + 0x5b;\n        nextSymbol = prevSymbol * 2;\n      }\n      else if (symbolInfo < 0x55) {\n        prevSymbol = (symbolOffset >> 0xc) + 0x6e;\n        nextSymbol = prevSymbol * 2;\n      }\n      else if (symbolInfo < 0x155) {\n        prevSymbol = (symbolOffset >> 0xf) + 0x77;\n        nextSymbol = prevSymbol * 2;\n      }\n      else if (symbolInfo < 0x555) {\n        prevSymbol = (symbolOffset >> 0x12) + 0x7c;\n        nextSymbol = prevSymbol * 2;\n      }\n      else {\n        nextSymbol = 0xfc;\n        prevSymbol = 0x7e;\n      }\n      prevRelocEntry = nextSymbol * 4 + 0x20070464;\n      currentRelocEntry = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[nextSymbol];\n      if (currentRelocEntry == prevRelocEntry) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (prevSymbol >> 2 & 0xffU);\n        prevRelocEntry = currentRelocEntry;\n      }\n      else {\n        do {\n          if ((*(uint *)(currentRelocEntry + 4) & 0xfffffffc) <= symbolOffset) break;\n          currentRelocEntry = *(dword *)(currentRelocEntry + 8);\n        } while (prevRelocEntry != currentRelocEntry);\n        prevRelocEntry = *(dword *)(currentRelocEntry + 0xc);\n      }\n      *(dword *)(currentSymbol + 0xc) = prevRelocEntry;\n      *(dword *)(currentSymbol + 8) = currentRelocEntry;\n      *(dword *)(prevRelocEntry + 8) = currentSymbol;\n      *(dword *)(currentRelocEntry + 0xc) = currentSymbol;\n    }\n  }\nLAB_00083ba4:\n  FUNC_00081f98(param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "update_relocation_table_00083b10",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "prevSymbol",
                "bVar2": "isSymbol2007046c",
                "uVar3": "symbolInfo",
                "dVar4": "currentRelocEntry",
                "iVar5": "nextSymbol",
                "uVar6": "symbolOffset",
                "dVar7": "currentSymbol",
                "uVar8": "newSymbolOffset",
                "dVar9": "prevRelocEntry"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081800",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00083a74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "process_data_00083ca8",
            "code": "\nundefined4 processData_00083ca8(undefined4 *output,uint *inputBuffer,uint **paramArray)\n\n{\n  int result;\n  uint tempVar1;\n  uint tempVar2;\n  ushort flag;\n  uint flagValue;\n  uint *pointer1;\n  uint *pointer2;\n  uint accumulatedValue;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint tempVar6;\n  \n  if (paramArray[2] != (uint *)0x0) {\n    flag = *(ushort *)(inputBuffer + 3);\n    flagValue = (uint)flag;\n    if (((int)(flagValue << 0x1c) < 0) && (inputBuffer[4] != 0)) {\n      pointer2 = *paramArray;\n    }\n    else {\n      result = FUN_0008356c(output,inputBuffer);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      flag = *(ushort *)(inputBuffer + 3);\n      flagValue = (uint)flag;\n      pointer2 = *paramArray;\n    }\n    if ((flag & 2) == 0) {\n      tempVar1 = flagValue & 2;\n      tempVar4 = tempVar1;\n      accumulatedValue = tempVar1;\n      tempVar6 = tempVar1;\n      if ((flagValue & 1) == 0) {\n        tempVar1 = 0;\n        tempVar4 = 0;\n        while( true ) {\n          while (tempVar1 == 0) {\n            tempVar4 = *pointer2;\n            pointer1 = pointer2 + 1;\n            pointer2 = pointer2 + 2;\n            tempVar1 = *pointer1;\n          }\n          accumulatedValue = inputBuffer[2];\n          if ((int)(flagValue << 0x16) < 0) {\n            if (tempVar1 < accumulatedValue) {\n              flagValue = *inputBuffer;\n              accumulatedValue = tempVar1;\n            }\n            else if ((flagValue & 0x480) == 0) {\n              flagValue = *inputBuffer;\n            }\n            else {\n              result = *inputBuffer - inputBuffer[4];\n              accumulatedValue = result + 1 + tempVar1;\n              tempVar3 = (int)(inputBuffer[5] * 3) / 2;\n              if (accumulatedValue <= tempVar3) {\n                accumulatedValue = tempVar3;\n              }\n              if ((int)(flagValue << 0x15) < 0) {\n                tempVar3 = FUN_00081810(output,accumulatedValue);\n                if (tempVar3 == 0) {\n                  *output = 0xc;\n                  flag = *(ushort *)(inputBuffer + 3);\n                  goto LAB_00083da4;\n                }\n                FUN_00081d48(tempVar3,inputBuffer[4],result);\n                *(ushort *)(inputBuffer + 3) = *(ushort *)(inputBuffer + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                tempVar3 = FUN_00081fac(output);\n                if (tempVar3 == 0) {\n                  FUN_00083b10(output,inputBuffer[4]);\n                  flag = *(ushort *)(inputBuffer + 3) & 0xff7f;\n                  *output = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              flagValue = tempVar3 + result;\n              inputBuffer[4] = tempVar3;\n              inputBuffer[5] = accumulatedValue;\n              *inputBuffer = flagValue;\n              inputBuffer[2] = accumulatedValue - result;\n              accumulatedValue = tempVar1;\n            }\n            FUN_00081e34(flagValue,tempVar4,accumulatedValue);\n            inputBuffer[2] = inputBuffer[2] - accumulatedValue;\n            *inputBuffer = *inputBuffer + accumulatedValue;\n            accumulatedValue = tempVar1;\n          }\n          else if ((inputBuffer[4] < *inputBuffer) || (flagValue = inputBuffer[5], tempVar1 < flagValue)) {\n            if (tempVar1 < accumulatedValue) {\n              accumulatedValue = tempVar1;\n            }\n            FUN_00081e34(*inputBuffer,tempVar4,accumulatedValue);\n            flagValue = inputBuffer[2];\n            inputBuffer[2] = flagValue - accumulatedValue;\n            *inputBuffer = *inputBuffer + accumulatedValue;\n            if ((flagValue - accumulatedValue == 0) && (result = FUN_00083850(output,inputBuffer), result != 0))\n            goto LAB_00083da2;\n          }\n          else {\n            accumulatedValue = 0x7fffffff;\n            if (tempVar1 < 0x7fffffff) {\n              accumulatedValue = tempVar1;\n            }\n            accumulatedValue = (*(code *)inputBuffer[9])(output,inputBuffer[7],tempVar4,(accumulatedValue / flagValue) * flagValue);\n            if ((int)accumulatedValue < 1) goto LAB_00083da2;\n          }\n          pointer1 = paramArray[2];\n          tempVar4 = tempVar4 + accumulatedValue;\n          tempVar1 = tempVar1 - accumulatedValue;\n          paramArray[2] = (uint *)((int)pointer1 - accumulatedValue);\n          if ((uint *)((int)pointer1 - accumulatedValue) == (uint *)0x0) break;\n          flagValue = (uint)*(ushort *)(inputBuffer + 3);\n        }\n      }\n      else {\n        do {\n          while (tempVar1 == 0) {\n            accumulatedValue = *pointer2;\n            tempVar1 = pointer2[1];\n            tempVar6 = 0;\n            pointer2 = pointer2 + 2;\n          }\n          if (tempVar6 == 0) {\n            result = FUN_000840f8(accumulatedValue,10,tempVar1);\n            if (result == 0) {\n              tempVar4 = tempVar1 + 1;\n              tempVar6 = 1;\n            }\n            else {\n              tempVar4 = (result + 1) - accumulatedValue;\n              tempVar6 = 1;\n            }\n          }\n          tempVar3 = *inputBuffer;\n          flagValue = tempVar4;\n          if (tempVar1 <= tempVar4) {\n            flagValue = tempVar1;\n          }\n          tempVar2 = inputBuffer[5];\n          if ((inputBuffer[4] < tempVar3) && (tempVar5 = inputBuffer[2] + tempVar2, (int)tempVar5 < (int)flagValue)) {\n            FUN_00081e34(tempVar3,accumulatedValue,tempVar5);\n            *inputBuffer = *inputBuffer + tempVar5;\n            result = FUN_00083850(output,inputBuffer);\n            if (result != 0) goto LAB_00083da2;\n          }\n          else if ((int)flagValue < (int)tempVar2) {\n            FUN_00081e34(tempVar3,accumulatedValue,flagValue);\n            inputBuffer[2] = inputBuffer[2] - flagValue;\n            *inputBuffer = flagValue + *inputBuffer;\n            tempVar5 = flagValue;\n          }\n          else {\n            tempVar5 = (*(code *)inputBuffer[9])(output,inputBuffer[7],accumulatedValue,tempVar2);\n            if ((int)tempVar5 < 1) goto LAB_00083da2;\n          }\n          tempVar4 = tempVar4 - tempVar5;\n          if (tempVar4 == 0) {\n            result = FUN_00083850(output,inputBuffer);\n            if (result != 0) goto LAB_00083da2;\n            tempVar6 = 0;\n          }\n          pointer1 = paramArray[2];\n          accumulatedValue = accumulatedValue + tempVar5;\n          tempVar1 = tempVar1 - tempVar5;\n          paramArray[2] = (uint *)((int)pointer1 - tempVar5);\n        } while ((uint *)((int)pointer1 - tempVar5) != (uint *)0x0);\n      }\n    }\n    else {\n      tempVar1 = 0;\n      flagValue = 0;\n      do {\n        while( true ) {\n          tempVar4 = flagValue;\n          if (0x7ffffbff < flagValue) {\n            tempVar4 = 0x7ffffc00;\n          }\n          if (flagValue != 0) break;\n          tempVar1 = *pointer2;\n          flagValue = pointer2[1];\n          pointer2 = pointer2 + 2;\n        }\n        result = (*(code *)inputBuffer[9])(output,inputBuffer[7],tempVar1,tempVar4);\n        if (result < 1) {\nLAB_00083da2:\n          flag = *(ushort *)(inputBuffer + 3);\nLAB_00083da4:\n          *(ushort *)(inputBuffer + 3) = flag | 0x40;\n          return 0xffffffff;\n        }\n        pointer1 = paramArray[2];\n        tempVar1 = tempVar1 + result;\n        flagValue = flagValue - result;\n        paramArray[2] = (uint *)((int)pointer1 - result);\n      } while ((uint *)((int)pointer1 - result) != (uint *)0x0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "process_data_00083ca8",
                "param_1": "output",
                "param_2": "inputBuffer",
                "param_3": "paramArray",
                "iVar1": "result",
                "uVar2": "tempVar1",
                "uVar3": "tempVar2",
                "uVar4": "flag",
                "uVar5": "flagValue",
                "puVar6": "pointer1",
                "puVar7": "pointer2",
                "uVar8": "accumulatedValue",
                "uVar9": "tempVar3",
                "uVar10": "tempVar4",
                "uVar11": "tempVar5",
                "local_2c": "tempVar6"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_00081d48",
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_000840f8",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_memory_address_00084004",
            "code": "\nundefined4 getMemoryAddress_00084004(void)\n\n{\n  return 0x20070878;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_memory_address_00084004"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_offset_from_elf_rel_array_0008400c",
            "code": "\ndword getOffsetFromElfRelArray_0008400c(void)\n\n{\n  return elfRelArray[275].offset;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_offset_from_elf_rel_array_0008400c",
                "Elf32_Rel_ARRAY_20070000": "elfRelArray",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "process_data_00084018",
            "code": "\nvoid processData_00084018(int input,int *output)\n\n{\n  ushort value1;\n  int result1;\n  int result2;\n  uint value2;\n  bool condition;\n  undefined tempArray [4];\n  uint localValue;\n  \n  value1 = *(ushort *)(output + 3);\n  value2 = (uint)value1;\n  if ((int)(value2 << 0x1e) < 0) {\n    *output = (int)output + 0x43;\n    output[4] = (int)output + 0x43;\n    output[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)output + 0xe)) {\n    result1 = FUN_00084494(input,(int)*(short *)((int)output + 0xe),tempArray);\n    if (-1 < result1) {\n      condition = (localValue & 0xf000) == 0x2000;\n      if (((localValue & 0xf000) == 0x8000) && (output[10] == 0x8427d)) {\n        result1 = 0x400;\n        *(ushort *)(output + 3) = *(ushort *)(output + 3) | 0x400;\n        output[0x13] = 0x400;\n      }\n      else {\n        result1 = 0x400;\n        *(ushort *)(output + 3) = *(ushort *)(output + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    value1 = *(ushort *)(output + 3);\n    value2 = (uint)value1;\n  }\n  *(ushort *)(output + 3) = value1 | 0x800;\n  if ((value2 & 0x80) == 0) {\n    result1 = 0x400;\n  }\n  else {\n    result1 = 0x40;\n  }\n  condition = false;\nLAB_00084074:\n  result2 = FUN_00081810(input,result1);\n  value1 = *(ushort *)(output + 3);\n  if (result2 == 0) {\n    if (-1 < (int)((uint)value1 << 0x16)) {\n      *(ushort *)(output + 3) = value1 | 2;\n      *output = (int)output + 0x43;\n      output[4] = (int)output + 0x43;\n      output[5] = 1;\n    }\n  }\n  else {\n    *(undefined **)(input + 0x3c) = &LAB_0008387c_1;\n    *(ushort *)(output + 3) = value1 | 0x80;\n    *output = result2;\n    output[4] = result2;\n    output[5] = result1;\n    if ((condition) && (result1 = FUN_000844bc(input,(int)*(short *)((int)output + 0xe)), result1 != 0))\n    {\n      *(ushort *)(output + 3) = *(ushort *)(output + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "process_data_00084018",
                "param_1": "input",
                "param_2": "output",
                "uVar1": "value1",
                "iVar2": "result1",
                "iVar3": "result2",
                "uVar4": "value2",
                "bVar5": "condition",
                "auStack_54": "tempArray",
                "local_50": "localValue"
            },
            "calling": [
                "FUN_0008356c"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00084494",
                "FUN_000844bc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "find_character_000840f8",
            "code": "\nuint * find_character_000840f8(uint *input_array,char target,uint array_length)\n\n{\n  uint result;\n  int index;\n  uint *ptr;\n  bool found;\n  \n  if (((uint)input_array & 3) == 0) {\nLAB_00084128:\n    if (3 < array_length) {\n      ptr = input_array;\n      do {\n        result = *ptr ^ CONCAT22(CONCAT11(target,target),CONCAT11(target,target));\n        input_array = ptr;\n        if ((result + 0xfefefeff & ~result & 0x80808080) != 0) break;\n        array_length = array_length - 4;\n        input_array = ptr + 1;\n        ptr = ptr + 1;\n      } while (3 < array_length);\n    }\n    if (array_length == 0) {\n      input_array = (uint *)0x0;\n    }\n    else if (*(char *)input_array != target) {\n      index = 0;\n      do {\n        input_array = (uint *)((int)input_array + 1);\n        found = index == array_length - 1;\n        index = index + 1;\n        if (found) goto LAB_00084150;\n      } while (*(char *)input_array != target);\n    }\n  }\n  else if (array_length == 0) {\nLAB_00084150:\n    input_array = (uint *)0x0;\n  }\n  else if (*(char *)input_array != target) {\n    ptr = (uint *)((int)input_array + 1);\n    array_length = array_length - 1;\n    do {\n      input_array = ptr;\n      if (((uint)input_array & 3) == 0) goto LAB_00084128;\n      if (array_length == 0) goto LAB_00084150;\n      ptr = (uint *)((int)input_array + 1);\n      array_length = array_length - 1;\n    } while (*(char *)input_array != target);\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "find_character_000840f8",
                "param_1": "input_array",
                "param_2": "target",
                "param_3": "array_length",
                "uVar1": "result",
                "iVar2": "index",
                "puVar3": "ptr",
                "bVar4": "found"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "process_parameter_000841e4",
            "code": "\nint processParameter_000841e4(uint parameter)\n\n{\n  dword offset;\n  undefined4 result;\n  int pointer;\n  code *codePtr;\n  undefined4 register4;\n  undefined4 register5;\n  undefined4 linkRegister;\n  undefined4 constantValue;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  constantValue = 0x20070460;\n  if (0x1f < parameter) {\n    *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n    return -1;\n  }\n  pointer = *(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x2dc);\n  if ((pointer == 0) || (codePtr = *(code **)(pointer + parameter * 4), codePtr == (code *)0x0)) {\n    result = thunk_FUN_00080efe(Elf32_Rel_ARRAY_20070000[140].r_offset);\n    DAT_20071244 = 0;\n    pointer = FUNC_00080efc(result,parameter,parameter,0,constantValue,register4,register5,linkRegister);\n    if ((pointer == -1) && (DAT_20071244 != 0)) {\n      *(int *)offset = DAT_20071244;\n      return -1;\n    }\n    return pointer;\n  }\n  if (codePtr == (code *)0x1) {\n    return 0;\n  }\n  if (codePtr != (code *)0xffffffff) {\n    *(undefined4 *)(pointer + parameter * 4) = 0;\n    (*codePtr)(parameter);\n    return 0;\n  }\n  *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "process_parameter_000841e4",
                "param_1": "parameter",
                "dVar1": "offset",
                "uVar2": "result",
                "iVar3": "pointer",
                "pcVar4": "codePtr",
                "unaff_r4": "register4",
                "unaff_r5": "register5",
                "in_lr": "linkRegister",
                "uVar5": "constantValue"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00080efc",
                "thunk_FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_00080efe": {
            "entrypoint": "0x0008421c",
            "current_name": "get_error_code_thunk_00080efe",
            "code": "\nuint32_t get_error_code_thunk_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "thunk_FUN_00080efe": "get_error_code_thunk_00080efe",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [
                "FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_value_00084220",
            "code": "\nvoid updateValue_00084220(undefined4 input1,int input2)\n\n{\n  int result;\n  \n  result = FUN_00084508(input1,(int)*(short *)(input2 + 0xe));\n  if (-1 < result) {\n    *(int *)(input2 + 0x50) = *(int *)(input2 + 0x50) + result;\n    return;\n  }\n  *(ushort *)(input2 + 0xc) = *(ushort *)(input2 + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_value_00084220",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "FUN_00084508"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "process_data_00084244",
            "code": "\nvoid processData_00084244(int *outputArray,int inputStructAddr,undefined4 paramA,undefined4 paramB)\n\n{\n  int result;\n  ushort value;\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  undefined4 tempVar3;\n  undefined4 stackVar;\n  \n  value = *(ushort *)(inputStructAddr + 0xc);\n  if ((int)((uint)value << 0x17) < 0) {\n    FUN_000844e0(outputArray,(int)*(short *)(inputStructAddr + 0xe),0,2);\n    value = *(ushort *)(inputStructAddr + 0xc);\n  }\n  *(ushort *)(inputStructAddr + 0xc) = value & 0xefff;\n  DAT_20071244 = 0;\n  result = FUN_00080ec8((int)*(short *)(inputStructAddr + 0xe),paramA,paramB,paramB,tempVar1,tempVar2,\n                       tempVar3,stackVar);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *outputArray = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "process_data_00084244",
                "param_1": "outputArray",
                "param_2": "inputStructAddr",
                "param_3": "paramA",
                "param_4": "paramB",
                "iVar1": "result",
                "uVar2": "value",
                "unaff_r4": "tempVar1",
                "unaff_r5": "tempVar2",
                "unaff_r6": "tempVar3",
                "in_lr": "stackVar"
            },
            "calling": [],
            "called": [
                "FUN_00080ec8",
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "update_status_0008427c",
            "code": "\nvoid updateStatus_0008427c(undefined4 status_data,int data_ptr)\n\n{\n  int result;\n  ushort modified_flag;\n  \n  result = FUN_000844e0(status_data,(int)*(short *)(data_ptr + 0xe));\n  if (result == -1) {\n    modified_flag = *(ushort *)(data_ptr + 0xc) & 0xefff;\n  }\n  else {\n    modified_flag = *(ushort *)(data_ptr + 0xc) | 0x1000;\n  }\n  if (result != -1) {\n    *(int *)(data_ptr + 0x50) = result;\n  }\n  *(ushort *)(data_ptr + 0xc) = modified_flag;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "update_status_0008427c",
                "param_1": "status_data",
                "param_2": "data_ptr",
                "iVar1": "result",
                "uVar2": "modified_flag"
            },
            "calling": [],
            "called": [
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_data_000842a4",
            "code": "\nuint processData_000842a4(int input,uint value,undefined4 *data,undefined4 param)\n\n{\n  ushort length;\n  uint convertedLength;\n  undefined *ptr;\n  int counter;\n  \n  if ((input != 0) && (*(int *)(input + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  length = *(ushort *)(data + 3);\n  convertedLength = (uint)length;\n  data[2] = data[6];\n  if ((-1 < (int)(convertedLength << 0x1c)) || (counter = data[4], counter == 0)) {\n    counter = FUN_0008356c(input,data,length,convertedLength,param);\n    if (counter != 0) {\n      return 0xffffffff;\n    }\n    length = *(ushort *)(data + 3);\n    counter = data[4];\n    convertedLength = (uint)length;\n  }\n  value = value & 0xff;\n  if ((int)(convertedLength << 0x12) < 0) {\n    ptr = (undefined *)*data;\n    counter = (int)ptr - counter;\n    if (counter < (int)data[5]) {\nLAB_000842d6:\n      counter = counter + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    data[0x19] = data[0x19] & 0xffffdfff;\n    ptr = (undefined *)*data;\n    *(ushort *)(data + 3) = length | 0x2000;\n    counter = (int)ptr - counter;\n    if (counter < (int)data[5]) goto LAB_000842d6;\n  }\n  counter = FUN_00083850(input,data);\n  if (counter != 0) {\n    return 0xffffffff;\n  }\n  ptr = (undefined *)*data;\n  counter = 1;\nLAB_000842d8:\n  data[2] = data[2] + -1;\n  *data = ptr + 1;\n  *ptr = (char)value;\n  if (((data[5] == counter) ||\n      (((int)((uint)*(ushort *)(data + 3) << 0x1f) < 0 && (value == 10)))) &&\n     (counter = FUN_00083850(input,data), counter != 0)) {\n    return 0xffffffff;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_data_000842a4",
                "param_1": "input",
                "param_2": "value",
                "param_3": "data",
                "param_4": "param",
                "uVar1": "length",
                "uVar2": "convertedLength",
                "puVar3": "ptr",
                "iVar4": "counter"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "execute_relocation_0008434c",
            "code": "\nvoid executeRelocation_0008434c(undefined4 *result,int size,undefined4 value,undefined4 *errorCode)\n\n{\n  dword relocationInfo;\n  undefined4 auxiliaryResult;\n  int returnValue;\n  undefined auxiliaryStack [12];\n  \n  relocationInfo = Elf32_Rel_ARRAY_20070000[275].r_info;\n  if (size == 0) {\n    auxiliaryResult = FUN_00084004();\n    returnValue = (*(code *)relocationInfo)(result,auxiliaryStack,0,auxiliaryResult,errorCode);\n  }\n  else {\n    auxiliaryResult = FUN_00084004();\n    returnValue = (*(code *)relocationInfo)(result,size,value,auxiliaryResult,errorCode);\n  }\n  if (returnValue == -1) {\n    *errorCode = 0;\n    *result = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "execute_relocation_0008434c",
                "param_1": "result",
                "param_2": "size",
                "param_3": "value",
                "param_4": "errorCode",
                "dVar1": "relocationInfo",
                "uVar2": "auxiliaryResult",
                "iVar3": "returnValue",
                "auStack_24": "auxiliaryStack"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008439c",
                "FUN_00084004"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "convert_uint_to_char_0008439c",
            "code": "\nundefined4 convert_uint_to_char_0008439c(undefined4 *output_pointer,undefined *input_pointer,uint input_value)\n\n{\n  if (input_pointer == (undefined *)0x0) {\n    return 0;\n  }\n  if (input_value < 0x100) {\n    *input_pointer = (char)input_value;\n    return 1;\n  }\n  *output_pointer = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "convert_uint_to_char_0008439c",
                "param_1": "output_pointer",
                "param_2": "input_pointer",
                "param_3": "input_value"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "check_and_process_param_00084484",
            "code": "\nundefined4 check_and_process_param_00084484(int input)\n\n{\n  dword offset;\n  undefined4 result;\n  int status;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  if (input != 0) {\n    if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n       (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n      FUN_00083888();\n    }\n    if (*(short *)(input + 0xc) != 0) {\n      result = FUN_00083850(offset,input);\n      if ((*(code **)(input + 0x2c) != (code *)0x0) &&\n         (status = (**(code **)(input + 0x2c))(offset,*(undefined4 *)(input + 0x1c)), status < 0))\n      {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(input + 0xc) << 0x18) < 0) {\n        FUN_00083b10(offset,*(undefined4 *)(input + 0x10));\n      }\n      if (*(int *)(input + 0x30) != 0) {\n        if (*(int *)(input + 0x30) != input + 0x40) {\n          FUN_00083b10(offset);\n        }\n        *(undefined4 *)(input + 0x30) = 0;\n      }\n      if (*(int *)(input + 0x44) != 0) {\n        FUN_00083b10(offset);\n        *(undefined4 *)(input + 0x44) = 0;\n      }\n      FUNC_0008397c();\n      *(undefined2 *)(input + 0xc) = 0;\n      FUNC_00083980();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084484": "check_and_process_param_00084484",
                "param_1": "input",
                "dVar1": "offset",
                "uVar2": "result",
                "iVar3": "status"
            },
            "calling": [],
            "called": [
                "FUN_00083b10",
                "FUN_00083850",
                "FUN_00083980",
                "FUN_0008397c",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "find_value_in_data_00084494",
            "code": "\nvoid findValueInData_00084494(int *outputValue,undefined4 inputValue1,undefined4 inputValue2,undefined4 inputValue3)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080eb0(inputValue1,inputValue2,inputValue2,0,inputValue3);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *outputValue = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "find_value_in_data_00084494",
                "param_1": "outputValue",
                "param_2": "inputValue1",
                "param_3": "inputValue2",
                "param_4": "inputValue3",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eb0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "check_return_value_and_update_param_000844bc",
            "code": "\nvoid checkReturnValueAndUpdateParam_000844bc(int *result,undefined4 inputValue)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = FUN_00080eba(inputValue);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "check_return_value_and_update_param_000844bc",
                "param_1": "result",
                "param_2": "inputValue",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "extract_binary_data_000844e0",
            "code": "\nvoid extractBinaryData_000844e0(int *output,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = FUN_00080ebe(input1,input2,input3);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *output = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "extract_binary_data_000844e0",
                "param_1": "output",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_0008427c",
                "FUN_00084244"
            ],
            "called": [
                "FUN_00080ebe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "check_function_result_00084508",
            "code": "\nvoid checkFunctionResult_00084508(int *result,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int functionResult;\n  \n  DAT_20071244 = 0;\n  functionResult = FUN_00080ec2(input1,input2,input3);\n  if ((functionResult == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "check_function_result_00084508",
                "param_1": "result",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "functionResult"
            },
            "calling": [
                "FUN_00084220"
            ],
            "called": [
                "FUN_00080ec2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "check_parameters_00084530",
            "code": "\nint checkParameters_00084530(int input_1,int input_2,int input_3,int input_4)\n\n{\n  int result;\n  \n  if ((input_4 == 0) && (input_3 == 0)) {\n    if (input_2 != 0 || input_1 != 0) {\n      input_1 = -1;\n    }\n    return input_1;\n  }\n  result = FUN_0008458c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00084530": "check_parameters_00084530",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008458c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "calculate_difference_0008455c",
            "code": "\nvoid calculate_difference_0008455c(uint input_value_1,int input_value_2,undefined4 constant_value_1,undefined4 constant_value_2,int *output_values)\n\n{\n  uint calculated_value_1;\n  longlong calculated_value_2;\n  \n  calculated_value_2 = FUN_000845c0();\n  calculated_value_2 = calculated_value_2 * CONCAT44(constant_value_2,constant_value_1);\n  calculated_value_1 = (uint)calculated_value_2;\n  *output_values = input_value_1 - calculated_value_1;\n  output_values[1] = (input_value_2 - (int)((ulonglong)calculated_value_2 >> 0x20)) - (uint)(input_value_1 < calculated_value_1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "calculate_difference_0008455c",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "constant_value_1",
                "param_4": "constant_value_2",
                "param_5": "output_values",
                "uVar1": "calculated_value_1",
                "lVar2": "calculated_value_2"
            },
            "calling": [],
            "called": [
                "FUN_000845c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "subtract_and_assign_params_0008458c",
            "code": "\nvoid subtractAndAssignParams_0008458c(uint inputValue,int intValue,undefined4 param3Value,undefined4 param4Value,int *outputArray)\n\n{\n  uint result;\n  longlong product;\n  \n  product = FUN_00084860();\n  product = product * CONCAT44(param4Value,param3Value);\n  result = (uint)product;\n  *outputArray = inputValue - result;\n  outputArray[1] = (intValue - (int)((ulonglong)product >> 0x20)) - (uint)(inputValue < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "subtract_and_assign_params_0008458c",
                "param_1": "inputValue",
                "param_2": "intValue",
                "param_3": "param3Value",
                "param_4": "param4Value",
                "param_5": "outputArray",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [
                "FUN_00084530"
            ],
            "called": [
                "FUN_00084860"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "divide_unsigned_integers_000845c0",
            "code": "\nundefined8 divideUnsignedIntegers_000845c0(uint dividend,uint dividend_high_bits,uint divisor,uint divisor_high_bits)\n\n{\n  longlong quotient;\n  uint quotient_low_bits;\n  uint quotient_high_bits;\n  uint quotient_temp;\n  uint remainder_temp;\n  int shift_amount;\n  uint divisor_partial;\n  uint temp1;\n  uint sign_bit_dividend;\n  uint temp2;\n  uint temp3;\n  uint extended_divisor;\n  bool is_carry;\n  \n  if ((int)dividend_high_bits < 0) {\n    is_carry = dividend != 0;\n    dividend = -dividend;\n    dividend_high_bits = -dividend_high_bits - (uint)is_carry;\n    sign_bit_dividend = 0xffffffff;\n  }\n  else {\n    sign_bit_dividend = 0;\n  }\n  if ((int)divisor_high_bits < 0) {\n    sign_bit_dividend = ~sign_bit_dividend;\n    is_carry = divisor != 0;\n    divisor = -divisor;\n    divisor_high_bits = -divisor_high_bits - (uint)is_carry;\n  }\n  if (divisor_high_bits == 0) {\n    if (dividend_high_bits < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount != 0) {\n        quotient_high_bits = dividend >> (0x20U - shift_amount & 0xff);\n        divisor = divisor << shift_amount;\n        dividend = dividend << shift_amount;\n        dividend_high_bits = dividend_high_bits << shift_amount | quotient_high_bits;\n      }\n      quotient_low_bits = divisor >> 0x10;\n      quotient_temp = dividend_high_bits / quotient_low_bits;\n      divisor_partial = (divisor & 0xffff) * quotient_temp;\n      temp2 = dividend >> 0x10 | (dividend_high_bits - quotient_low_bits * quotient_temp) * 0x10000;\n      quotient_high_bits = quotient_temp;\n      if (temp2 <= divisor_partial && divisor_partial - temp2 != 0) {\n        is_carry = CARRY4(temp2,divisor);\n        temp2 = temp2 + divisor;\n        quotient_high_bits = quotient_temp - 1;\n        if ((is_carry == false) && (temp2 <= divisor_partial && divisor_partial - temp2 != 0)) {\n          quotient_high_bits = quotient_temp - 2;\n          temp2 = temp2 + divisor;\n        }\n      }\n      temp1 = (temp2 - divisor_partial) / quotient_low_bits;\n      quotient_temp = (divisor & 0xffff) * temp1;\n      divisor_partial = dividend & 0xffff | ((temp2 - divisor_partial) - quotient_low_bits * temp1) * 0x10000;\n      quotient_low_bits = temp1;\n      if (divisor_partial <= quotient_temp && quotient_temp - divisor_partial != 0) {\n        quotient_low_bits = temp1 - 1;\n        if ((CARRY4(divisor_partial,divisor) == false) &&\n           (divisor_partial + divisor <= quotient_temp && quotient_temp - (divisor_partial + divisor) != 0)) {\n          quotient_low_bits = temp1 - 2;\n        }\n      }\n      quotient_low_bits = quotient_low_bits | quotient_high_bits << 0x10;\n      quotient_high_bits = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        dividend_high_bits = dividend_high_bits - divisor;\n        quotient_temp = divisor >> 0x10;\n        extended_divisor = divisor & 0xffff;\n        quotient_high_bits = 1;\n      }\n      else {\n        divisor = divisor << shift_amount;\n        quotient_high_bits = dividend_high_bits >> (0x20U - shift_amount & 0xff);\n        quotient_temp = divisor >> 0x10;\n        temp2 = quotient_high_bits / quotient_temp;\n        extended_divisor = divisor & 0xffff;\n        divisor_partial = extended_divisor * temp2;\n        temp1 = dividend >> (0x20U - shift_amount & 0xff) | dividend_high_bits << shift_amount;\n        quotient_high_bits = temp1 >> 0x10 | (quotient_high_bits - quotient_temp * temp2) * 0x10000;\n        dividend = dividend << shift_amount;\n        quotient_low_bits = temp2;\n        if (quotient_high_bits <= divisor_partial && divisor_partial - quotient_high_bits != 0) {\n          is_carry = CARRY4(quotient_high_bits,divisor);\n          quotient_high_bits = quotient_high_bits + divisor;\n          quotient_low_bits = temp2 - 1;\n          if ((is_carry == false) && (quotient_high_bits <= divisor_partial && divisor_partial - quotient_high_bits != 0)) {\n            quotient_low_bits = temp2 - 2;\n            quotient_high_bits = quotient_high_bits + divisor;\n          }\n        }\n        remainder_temp = (quotient_high_bits - divisor_partial) / quotient_temp;\n        temp2 = extended_divisor * remainder_temp;\n        dividend_high_bits = temp1 & 0xffff | ((quotient_high_bits - divisor_partial) - quotient_temp * remainder_temp) * 0x10000;\n        quotient_high_bits = remainder_temp;\n        if (dividend_high_bits <= temp2 && temp2 - dividend_high_bits != 0) {\n          is_carry = CARRY4(dividend_high_bits,divisor);\n          dividend_high_bits = dividend_high_bits + divisor;\n          quotient_high_bits = remainder_temp - 1;\n          if ((is_carry == false) && (dividend_high_bits <= temp2 && temp2 - dividend_high_bits != 0)) {\n            quotient_high_bits = remainder_temp - 2;\n            dividend_high_bits = dividend_high_bits + divisor;\n          }\n        }\n        dividend_high_bits = dividend_high_bits - temp2;\n        quotient_high_bits = quotient_high_bits | quotient_low_bits << 0x10;\n      }\n      quotient_low_bits = dividend_high_bits / quotient_temp;\n      temp2 = extended_divisor * quotient_low_bits;\n      temp1 = dividend >> 0x10 | (dividend_high_bits - quotient_temp * quotient_low_bits) * 0x10000;\n      divisor_partial = quotient_low_bits;\n      if (temp1 <= temp2 && temp2 - temp1 != 0) {\n        is_carry = CARRY4(temp1,divisor);\n        temp1 = temp1 + divisor;\n        divisor_partial = quotient_low_bits - 1;\n        if ((is_carry == false) && (temp1 <= temp2 && temp2 - temp1 != 0)) {\n          divisor_partial = quotient_low_bits - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      remainder_temp = (temp1 - temp2) / quotient_temp;\n      extended_divisor = extended_divisor * remainder_temp;\n      quotient_temp = dividend & 0xffff | ((temp1 - temp2) - quotient_temp * remainder_temp) * 0x10000;\n      quotient_low_bits = remainder_temp;\n      if (quotient_temp <= extended_divisor && extended_divisor - quotient_temp != 0) {\n        quotient_low_bits = remainder_temp - 1;\n        if ((CARRY4(quotient_temp,divisor) == false) &&\n           (quotient_temp + divisor <= extended_divisor && extended_divisor - (quotient_temp + divisor) != 0)) {\n          quotient_low_bits = remainder_temp - 2;\n        }\n      }\n      quotient_low_bits = quotient_low_bits | divisor_partial << 0x10;\n    }\n  }\n  else if (dividend_high_bits < divisor_high_bits) {\n    quotient_high_bits = 0;\n    quotient_low_bits = 0;\n  }\n  else {\n    shift_amount = LZCOUNT(divisor_high_bits);\n    if (shift_amount == 0) {\n      if ((divisor_high_bits < dividend_high_bits) || (divisor <= dividend)) {\n        quotient_high_bits = 0;\n        quotient_low_bits = 1;\n      }\n      else {\n        quotient_low_bits = 0;\n        quotient_high_bits = 0;\n      }\n    }\n    else {\n      quotient_high_bits = 0x20 - shift_amount;\n      quotient_temp = dividend_high_bits >> (quotient_high_bits & 0xff);\n      extended_divisor = divisor >> (quotient_high_bits & 0xff) | divisor_high_bits << shift_amount;\n      temp2 = extended_divisor >> 0x10;\n      quotient_low_bits = quotient_temp / temp2;\n      temp1 = (extended_divisor & 0xffff) * quotient_low_bits;\n      divisor_partial = dividend_high_bits << shift_amount | dividend >> (quotient_high_bits & 0xff);\n      quotient_temp = divisor_partial >> 0x10 | (quotient_temp - temp2 * quotient_low_bits) * 0x10000;\n      quotient_high_bits = quotient_low_bits;\n      if (quotient_temp <= temp1 && temp1 - quotient_temp != 0) {\n        is_carry = CARRY4(quotient_temp,extended_divisor);\n        quotient_temp = quotient_temp + extended_divisor;\n        quotient_high_bits = quotient_low_bits - 1;\n        if ((is_carry == false) && (quotient_temp <= temp1 && temp1 - quotient_temp != 0)) {\n          quotient_high_bits = quotient_low_bits - 2;\n          quotient_temp = quotient_temp + extended_divisor;\n        }\n      }\n      remainder_temp = (quotient_temp - temp1) / temp2;\n      temp3 = (extended_divisor & 0xffff) * remainder_temp;\n      quotient_temp = divisor_partial & 0xffff | ((quotient_temp - temp1) - temp2 * remainder_temp) * 0x10000;\n      quotient_low_bits = remainder_temp;\n      if (quotient_temp <= temp3 && temp3 - quotient_temp != 0) {\n        is_carry = CARRY4(quotient_temp,extended_divisor);\n        quotient_temp = quotient_temp + extended_divisor;\n        quotient_low_bits = remainder_temp - 1;\n        if ((is_carry == false) && (quotient_temp <= temp3 && temp3 - quotient_temp != 0)) {\n          quotient_low_bits = remainder_temp - 2;\n          quotient_temp = quotient_temp + extended_divisor;\n        }\n      }\n      quotient_low_bits = quotient_low_bits | quotient_high_bits << 0x10;\n      quotient = (ulonglong)quotient_low_bits * (ulonglong)(divisor << shift_amount);\n      divisor_partial = (uint)((ulonglong)quotient >> 0x20);\n      quotient_high_bits = 0;\n      if ((quotient_temp - temp3 < divisor_partial) ||\n         ((quotient_temp - temp3 == divisor_partial && (dividend << shift_amount < (uint)quotient)))) {\n        quotient_low_bits = quotient_low_bits - 1;\n        quotient_high_bits = 0;\n      }\n    }\n  }\n  if (sign_bit_dividend != 0) {\n    is_carry = quotient_low_bits != 0;\n    quotient_low_bits = -quotient_low_bits;\n    quotient_high_bits = -quotient_high_bits - (uint)is_carry;\n  }\n  return CONCAT44(quotient_high_bits,quotient_low_bits);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "divide_unsigned_integers_000845c0",
                "param_1": "dividend",
                "param_2": "dividend_high_bits",
                "param_3": "divisor",
                "param_4": "divisor_high_bits",
                "lVar1": "quotient",
                "uVar2": "quotient_low_bits",
                "uVar3": "quotient_high_bits",
                "uVar4": "quotient_temp",
                "uVar5": "remainder_temp",
                "iVar6": "shift_amount",
                "uVar7": "divisor_partial",
                "uVar8": "temp1",
                "uVar9": "sign_bit_dividend",
                "uVar10": "temp2",
                "uVar11": "temp3",
                "uVar12": "extended_divisor",
                "bVar13": "is_carry"
            },
            "calling": [
                "FUN_0008455c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "calculate_division_00084860",
            "code": "\nulonglong calculateDivision_00084860(uint dividend,uint dividend_copy,uint divisor,uint divisor_copy)\n\n{\n  longlong result;\n  uint quotient1;\n  uint quotient2;\n  uint quotient3;\n  uint remainder1;\n  uint remainder2;\n  uint remainder3;\n  uint quotient1_copy;\n  uint quotient2_copy;\n  int iVar10;\n  bool carry_flag;\n  \n  if (divisor_copy == 0) {\n    if (divisor <= dividend_copy) {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      iVar10 = LZCOUNT(divisor);\n      if (iVar10 == 0) {\n        dividend_copy = dividend_copy - divisor;\n        quotient2 = divisor >> 0x10;\n        remainder1 = divisor & 0xffff;\n        quotient1 = 1;\n      }\n      else {\n        divisor = divisor << iVar10;\n        quotient1_copy = dividend_copy >> (0x20U - iVar10 & 0xff);\n        quotient2 = divisor >> 0x10;\n        quotient2_copy = quotient1_copy / quotient2;\n        remainder1 = divisor & 0xffff;\n        quotient1 = remainder1 * quotient2_copy;\n        remainder2 = dividend >> (0x20U - iVar10 & 0xff) | dividend_copy << iVar10;\n        quotient3 = remainder2 >> 0x10 | (quotient1_copy - quotient2 * quotient2_copy) * 0x10000;\n        dividend = dividend << iVar10;\n        quotient1_copy = quotient2_copy;\n        if (quotient3 <= quotient1 && quotient1 - quotient3 != 0) {\n          carry_flag = CARRY4(quotient3,divisor);\n          quotient3 = quotient3 + divisor;\n          quotient1_copy = quotient2_copy - 1;\n          if ((carry_flag == false) && (quotient3 <= quotient1 && quotient1 - quotient3 != 0)) {\n            quotient1_copy = quotient2_copy - 2;\n            quotient3 = quotient3 + divisor;\n          }\n        }\n        remainder3 = (quotient3 - quotient1) / quotient2;\n        quotient2_copy = remainder1 * remainder3;\n        dividend_copy = remainder2 & 0xffff | ((quotient3 - quotient1) - quotient2 * remainder3) * 0x10000;\n        quotient1 = remainder3;\n        if (dividend_copy <= quotient2_copy && quotient2_copy - dividend_copy != 0) {\n          carry_flag = CARRY4(dividend_copy,divisor);\n          dividend_copy = dividend_copy + divisor;\n          quotient1 = remainder3 - 1;\n          if ((carry_flag == false) && (dividend_copy <= quotient2_copy && quotient2_copy - dividend_copy != 0)) {\n            quotient1 = remainder3 - 2;\n            dividend_copy = dividend_copy + divisor;\n          }\n        }\n        dividend_copy = dividend_copy - quotient2_copy;\n        quotient1 = quotient1 | quotient1_copy << 0x10;\n      }\n      quotient2_copy = dividend_copy / quotient2;\n      quotient3 = remainder1 * quotient2_copy;\n      remainder2 = dividend >> 0x10 | (dividend_copy - quotient2 * quotient2_copy) * 0x10000;\n      quotient1_copy = quotient2_copy;\n      if (remainder2 <= quotient3 && quotient3 - remainder2 != 0) {\n        carry_flag = CARRY4(remainder2,divisor);\n        remainder2 = remainder2 + divisor;\n        quotient1_copy = quotient2_copy - 1;\n        if ((carry_flag == false) && (remainder2 <= quotient3 && quotient3 - remainder2 != 0)) {\n          quotient1_copy = quotient2_copy - 2;\n          remainder2 = remainder2 + divisor;\n        }\n      }\n      quotient2_copy = (remainder2 - quotient3) / quotient2;\n      remainder1 = remainder1 * quotient2_copy;\n      remainder2 = dividend & 0xffff | ((remainder2 - quotient3) - quotient2 * quotient2_copy) * 0x10000;\n      quotient2 = quotient2_copy;\n      if (remainder2 <= remainder1 && remainder1 - remainder2 != 0) {\n        quotient2 = quotient2_copy - 1;\n        if ((CARRY4(remainder2,divisor) == false) &&\n           (remainder2 + divisor <= remainder1 && remainder1 - (remainder2 + divisor) != 0)) {\n          quotient2 = quotient2_copy - 2;\n        }\n      }\n      return CONCAT44(quotient1,quotient2 | quotient1_copy << 0x10);\n    }\n    iVar10 = LZCOUNT(divisor);\n    if (iVar10 != 0) {\n      quotient1_copy = dividend >> (0x20U - iVar10 & 0xff);\n      divisor = divisor << iVar10;\n      dividend = dividend << iVar10;\n      dividend_copy = quotient1_copy | dividend_copy << iVar10;\n    }\n    quotient1 = divisor >> 0x10;\n    quotient2 = dividend_copy / quotient1;\n    remainder1 = (divisor & 0xffff) * quotient2;\n    quotient2_copy = dividend >> 0x10 | (dividend_copy - quotient1 * quotient2) * 0x10000;\n    quotient1_copy = quotient2;\n    if (quotient2_copy <= remainder1 && remainder1 - quotient2_copy != 0) {\n      carry_flag = CARRY4(quotient2_copy,divisor);\n      quotient2_copy = quotient2_copy + divisor;\n      quotient1_copy = quotient2 - 1;\n      if ((carry_flag == false) && (quotient2_copy <= remainder1 && remainder1 - quotient2_copy != 0)) {\n        quotient1_copy = quotient2 - 2;\n        quotient2_copy = quotient2_copy + divisor;\n      }\n    }\n    remainder2 = (quotient2_copy - remainder1) / quotient1;\n    quotient2 = (divisor & 0xffff) * remainder2;\n    remainder1 = dividend & 0xffff | ((quotient2_copy - remainder1) - quotient1 * remainder2) * 0x10000;\n    quotient1 = remainder2;\n    if (remainder1 <= quotient2 && quotient2 - remainder1 != 0) {\n      quotient1 = remainder2 - 1;\n      if ((CARRY4(remainder1,divisor) == false) &&\n         (remainder1 + divisor <= quotient2 && quotient2 - (remainder1 + divisor) != 0)) {\n        quotient1 = remainder2 - 2;\n      }\n    }\n    quotient1 = quotient1 | quotient1_copy << 0x10;\n  }\n  else {\n    if (dividend_copy < divisor_copy) {\n      return 0;\n    }\n    iVar10 = LZCOUNT(divisor_copy);\n    if (iVar10 == 0) {\n      if ((divisor_copy < dividend_copy) || (divisor <= dividend)) {\n        return 1;\n      }\n      quotient1 = 0;\n    }\n    else {\n      quotient1 = 0x20 - iVar10;\n      quotient1_copy = dividend_copy >> (quotient1 & 0xff);\n      quotient2 = divisor_copy << iVar10 | divisor >> (quotient1 & 0xff);\n      remainder1 = quotient2 >> 0x10;\n      quotient3 = quotient1_copy / remainder1;\n      quotient2_copy = (quotient2 & 0xffff) * quotient3;\n      remainder2 = dividend >> (quotient1 & 0xff) | dividend_copy << iVar10;\n      quotient1 = remainder2 >> 0x10 | (quotient1_copy - remainder1 * quotient3) * 0x10000;\n      quotient1_copy = quotient3;\n      if (quotient1 <= quotient2_copy && quotient2_copy - quotient1 != 0) {\n        carry_flag = CARRY4(quotient1,quotient2);\n        quotient1 = quotient1 + quotient2;\n        quotient1_copy = quotient3 - 1;\n        if ((carry_flag == false) && (quotient1 <= quotient2_copy && quotient2_copy - quotient1 != 0)) {\n          quotient1_copy = quotient3 - 2;\n          quotient1 = quotient1 + quotient2;\n        }\n      }\n      quotient3 = (quotient1 - quotient2_copy) / remainder1;\n      remainder3 = (quotient2 & 0xffff) * quotient3;\n      remainder1 = remainder2 & 0xffff | ((quotient1 - quotient2_copy) - remainder1 * quotient3) * 0x10000;\n      quotient1 = quotient3;\n      if (remainder1 <= remainder3 && remainder3 - remainder1 != 0) {\n        carry_flag = CARRY4(remainder1,quotient2);\n        remainder1 = remainder1 + quotient2;\n        quotient1 = quotient3 - 1;\n        if ((carry_flag == false) && (remainder1 <= remainder3 && remainder3 - remainder1 != 0)) {\n          quotient1 = quotient3 - 2;\n          remainder1 = remainder1 + quotient2;\n        }\n      }\n      quotient1 = quotient1 | quotient1_copy << 0x10;\n      result = (ulonglong)quotient1 * (ulonglong)(divisor << iVar10);\n      quotient1_copy = (uint)((ulonglong)result >> 0x20);\n      if ((remainder1 - remainder3 < quotient1_copy) || ((remainder1 - remainder3 == quotient1_copy && (dividend << iVar10 < (uint)result)))\n         ) {\n        quotient1 = quotient1 - 1;\n      }\n    }\n  }\n  return (ulonglong)quotient1;\n}\n\n",
            "renaming": {
                "FUN_00084860": "calculate_division_00084860",
                "param_1": "dividend",
                "param_2": "dividend_copy",
                "param_3": "divisor",
                "param_4": "divisor_copy",
                "lVar1": "result",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "uVar4": "quotient3",
                "uVar5": "remainder1",
                "uVar6": "remainder2",
                "uVar7": "remainder3",
                "uVar8": "quotient1_copy",
                "uVar9": "quotient2_copy",
                "bVar11": "carry_flag"
            },
            "calling": [
                "FUN_0008458c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 114692,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080164",
            "FUN_000801e0",
            "FUN_00080250",
            "FUN_000803fc",
            "FUN_0008044c",
            "FUN_000805a8",
            "FUN_000806a0",
            "FUN_000806f8",
            "FUN_00080774",
            "FUN_0008089c",
            "FUN_00080970",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a30",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080b2c",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080e80",
            "FUN_00080e88",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080eec",
            "FUN_00080efe",
            "thunk_FUN_000816d8",
            "FUN_00080f0c",
            "FUN_00081014",
            "FUN_000810a6",
            "FUN_000810c4",
            "FUN_000810cc",
            "FUN_000810d8",
            "FUN_000810e8",
            "FUN_000810fc",
            "FUN_0008113a",
            "thunk_FUN_0008113a",
            "FUN_0008117a",
            "FUN_00081190",
            "FUN_000811b0",
            "FUN_000811ca",
            "FUN_000811e8",
            "FUN_00081214",
            "FUN_00081248",
            "FUN_00081276",
            "FUN_000812b8",
            "FUN_00081348",
            "FUN_000813dc",
            "FUN_00081438",
            "FUN_0008145c",
            "FUN_00081472",
            "FUN_00081480",
            "FUN_00081496",
            "FUN_000814ae",
            "FUN_000814d0",
            "FUN_000814f6",
            "FUN_0008151c",
            "FUN_00081560",
            "FUN_00081570",
            "FUN_0008159e",
            "FUN_000815b8",
            "FUN_000815de",
            "FUN_000815ec",
            "FUN_00081618",
            "FUN_00081624",
            "FUN_00081684",
            "FUN_000816d8",
            "FUN_000816ec",
            "FUN_000816f8",
            "FUN_00081750",
            "FUN_00081778",
            "FUN_000817c8",
            "FUN_000817f0",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00081f9c",
            "FUN_00081fac",
            "FUN_0008236c",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_00082824",
            "FUN_0008289c",
            "FUN_000834f0",
            "FUN_0008356c",
            "FUN_000836ec",
            "FUN_00083850",
            "FUN_00083888",
            "FUN_000839b4",
            "FUN_00083a74",
            "FUN_00083b10",
            "FUN_00083ca8",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_00084018",
            "FUN_000840f8",
            "FUN_000841e4",
            "thunk_FUN_00080efe",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_000842a4",
            "FUN_0008434c",
            "FUN_0008439c",
            "FUN_00084484",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_00084530",
            "FUN_0008455c",
            "FUN_0008458c",
            "FUN_000845c0",
            "FUN_00084860"
        ]
    ],
    "locked_functions": []
}