{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initialize_completed_flag_08000110(undefined4 input_param)\n\n{\n  if ((char)completed_flag == '\\0') {\n    completed_flag._0_1_ = '\\x01';\n  }\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "input_param",
                "completed_8655": "completed_flag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_64_bits_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_64_bits_08000134(undefined4 lower_32_bits,undefined4 upper_32_bits)\n\n{\n  return CONCAT44(upper_32_bits,lower_32_bits);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_64_bits_08000134",
                "param_1": "lower_32_bits",
                "param_2": "upper_32_bits"
            },
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "calculate_sum_08000150",
            "code": "\nvoid calculate_sum_08000150(undefined4 input_value,uint modifier)\n\n{\n  __aeabi_dadd(input_value,modifier ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000150": "calculate_sum_08000150",
                "param_1": "input_value",
                "param_2": "modifier"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_xor_result_08000158",
            "code": "\nulonglong calculate_xor_result_08000158(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shifted_bits_1;\n  byte carry_bit;\n  uint sum_1;\n  uint masked_input_1;\n  uint sum_2;\n  uint masked_input_2;\n  uint shifted_bits_2;\n  int shifted_16_bits_1;\n  uint shifted_input_2;\n  uint shifted_input_1;\n  uint absolute_difference;\n  uint abs_difference_shifted;\n  bool is_zero;\n  bool is_negative;\n  bool is_negative_2;\n  \n  masked_input_2 = input_4 ^ 0x80000000;\n  shifted_input_2 = input_2 << 1;\n  input_4 = input_4 << 1;\n  is_zero = ((input_2 ^ masked_input_2) & 0x7fffffff) == 0;\n  is_negative = is_zero && input_1 == input_3;\n  if (!is_zero || input_1 != input_3) {\n    is_negative = (shifted_input_2 | input_1) == 0;\n  }\n  if (!is_negative) {\n    is_negative = (input_4 | input_3) == 0;\n  }\n  shifted_16_bits_1 = (int)shifted_input_2 >> 0x15;\n  if (!is_negative) {\n    is_negative = shifted_16_bits_1 == -1;\n  }\n  shifted_bits_1 = (int)input_4 >> 0x15;\n  if (!is_negative) {\n    is_negative = shifted_bits_1 == -1;\n  }\n  if (is_negative) {\n    if (shifted_16_bits_1 == -1 || shifted_bits_1 == -1) {\n      shifted_input_2 = masked_input_2;\n      absolute_difference = input_3;\n      if (shifted_16_bits_1 == -1) {\n        shifted_input_2 = input_2;\n        absolute_difference = input_1;\n      }\n      if (shifted_16_bits_1 != -1 || shifted_bits_1 != -1) {\n        input_3 = absolute_difference;\n        masked_input_2 = shifted_input_2;\n      }\n      is_negative = (absolute_difference | shifted_input_2 << 0xc) == 0;\n      if (is_negative) {\n        is_negative = (input_3 | masked_input_2 << 0xc) == 0;\n      }\n      if (is_negative) {\n        is_negative = shifted_input_2 == masked_input_2;\n      }\n      if (!is_negative) {\n        shifted_input_2 = shifted_input_2 | 0x80000;\n      }\n      return CONCAT44(shifted_input_2,absolute_difference);\n    }\n    if (((input_2 ^ masked_input_2) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((shifted_input_2 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = masked_input_2;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != masked_input_2) {\n      return 0;\n    }\n    if (shifted_input_2 >> 0x15 == 0) {\n      is_negative = (input_1 & 0x80000000) != 0;\n      masked_input_2 = input_2 * 2 + (uint)is_negative;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)is_negative)) {\n        masked_input_2 = masked_input_2 | 0x80000000;\n      }\n      return CONCAT44(masked_input_2,input_1 << 1);\n    }\n    if (shifted_input_2 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  shifted_input_2 = shifted_input_2 >> 0x15;\n  input_4 = input_4 >> 0x15;\n  absolute_difference = input_4 - shifted_input_2;\n  is_negative = absolute_difference != 0;\n  if (input_4 < shifted_input_2) {\n    absolute_difference = -absolute_difference;\n  }\n  shifted_input_1 = input_1;\n  shifted_bits_2 = input_2;\n  if (is_negative && shifted_input_2 <= input_4) {\n    shifted_input_2 = shifted_input_2 + absolute_difference;\n    shifted_input_1 = input_3;\n    shifted_bits_2 = masked_input_2;\n    input_3 = input_1;\n    masked_input_2 = input_2;\n  }\n  if (0x36 < absolute_difference) {\n    return CONCAT44(shifted_bits_2,shifted_input_1);\n  }\n  masked_input_1 = shifted_bits_2 & 0xfffff | 0x100000;\n  if ((shifted_bits_2 & 0x80000000) != 0) {\n    is_negative = shifted_input_1 != 0;\n    shifted_input_1 = -shifted_input_1;\n    masked_input_1 = -masked_input_1 - (uint)is_negative;\n  }\n  shifted_bits_2 = masked_input_2 & 0xfffff | 0x100000;\n  if ((masked_input_2 & 0x80000000) != 0) {\n    is_negative = input_3 != 0;\n    input_3 = -input_3;\n    shifted_bits_2 = -shifted_bits_2 - (uint)is_negative;\n  }\n  if (shifted_input_2 == absolute_difference) {\n    shifted_bits_2 = shifted_bits_2 ^ 0x100000;\n    if (shifted_input_2 == 0) {\n      masked_input_1 = masked_input_1 ^ 0x100000;\n      shifted_input_2 = 1;\n    }\n    else {\n      absolute_difference = absolute_difference - 1;\n    }\n  }\n  masked_input_2 = -absolute_difference + 0x20;\n  if ((int)absolute_difference < 0x21) {\n    abs_difference_shifted = input_3 << (masked_input_2 & 0xff);\n    input_3 = input_3 >> (absolute_difference & 0xff);\n    sum_1 = shifted_input_1 + input_3;\n    sum_2 = shifted_bits_2 << (masked_input_2 & 0xff);\n    masked_input_2 = sum_1 + sum_2;\n    masked_input_1 = masked_input_1 + CARRY4(shifted_input_1,input_3) + ((int)shifted_bits_2 >> (absolute_difference & 0xff)) +\n            (uint)CARRY4(sum_1,sum_2);\n  }\n  else {\n    abs_difference_shifted = shifted_bits_2 << (-absolute_difference + 0x40 & 0xff);\n    if (input_3 != 0) {\n      abs_difference_shifted = abs_difference_shifted | 2;\n    }\n    shifted_bits_2 = (int)shifted_bits_2 >> (absolute_difference - 0x20 & 0xff);\n    masked_input_2 = shifted_input_1 + shifted_bits_2;\n    masked_input_1 = masked_input_1 + ((int)shifted_bits_2 >> 0x1f) + (uint)CARRY4(shifted_input_1,shifted_bits_2);\n  }\n  input_2 = masked_input_1 & 0x80000000;\n  absolute_difference = masked_input_1;\n  if ((int)masked_input_1 < 0) {\n    is_negative = abs_difference_shifted == 0;\n    abs_difference_shifted = -abs_difference_shifted;\n    absolute_difference = -masked_input_2;\n    masked_input_2 = -(uint)!is_negative - masked_input_2;\n    absolute_difference = -(uint)(is_negative <= absolute_difference) - masked_input_1;\n  }\n  if (0xfffff < absolute_difference) {\n    shifted_input_1 = shifted_input_2 - 1;\n    if (0x1fffff < absolute_difference) {\n      shifted_input_1 = absolute_difference & 1;\n      absolute_difference = absolute_difference >> 1;\n      carry_bit = (byte)masked_input_2;\n      masked_input_2 = (uint)(shifted_input_1 != 0) << 0x1f | masked_input_2 >> 1;\n      abs_difference_shifted = (uint)(carry_bit & 1) << 0x1f | abs_difference_shifted >> 1;\n      shifted_input_1 = shifted_input_2;\n      if (0xffbfffff < shifted_input_2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    is_negative = 0x7fffffff < abs_difference_shifted;\n    if (abs_difference_shifted == 0x80000000) {\n      is_negative = (masked_input_2 & 1) != 0;\n    }\n    return CONCAT44(absolute_difference + shifted_input_1 * 0x100000 + (uint)CARRY4(masked_input_2,(uint)is_negative) | input_2,\n                    masked_input_2 + is_negative);\n  }\n  is_zero = (abs_difference_shifted & 0x80000000) != 0;\n  abs_difference_shifted = abs_difference_shifted << 1;\n  shifted_input_1 = masked_input_2 * 2;\n  is_negative = CARRY4(masked_input_2,masked_input_2);\n  masked_input_2 = masked_input_2 * 2 + (uint)is_zero;\n  absolute_difference = absolute_difference * 2 + (uint)(is_negative || CARRY4(shifted_input_1,(uint)is_zero));\n  shifted_input_1 = shifted_input_2 - 2;\n  if ((absolute_difference & 0x100000) != 0) goto LAB_08000268;\n  shifted_bits_2 = masked_input_2;\n  shifted_input_2 = absolute_difference;\n  if (absolute_difference == 0) {\n    shifted_bits_2 = 0;\n    shifted_input_2 = masked_input_2;\n  }\n  shifted_16_bits_1 = LZCOUNT(shifted_input_2);\n  if (absolute_difference == 0) {\n    shifted_16_bits_1 = shifted_16_bits_1 + 0x20;\n  }\n  absolute_difference = shifted_16_bits_1 - 0xb;\n  is_negative_2 = SBORROW4(absolute_difference,0x20);\n  masked_input_2 = shifted_16_bits_1 - 0x2b;\n  is_negative = (int)masked_input_2 < 0;\n  is_zero = masked_input_2 == 0;\n  if ((int)absolute_difference < 0x20) {\n    is_negative_2 = SCARRY4(masked_input_2,0xc);\n    shifted_16_bits_1 = shifted_16_bits_1 + -0x1f;\n    is_negative = shifted_16_bits_1 < 0;\n    is_zero = shifted_16_bits_1 == 0;\n    masked_input_2 = absolute_difference;\n    if (!is_zero && is_negative == is_negative_2) {\n      shifted_bits_2 = shifted_input_2 << (absolute_difference & 0xff);\n      shifted_input_2 = shifted_input_2 >> (0xcU - shifted_16_bits_1 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative != is_negative_2) {\n    abs_difference_shifted = 0x20 - masked_input_2;\n  }\n  shifted_input_2 = shifted_input_2 << (masked_input_2 & 0xff);\n  if (is_zero || is_negative != is_negative_2) {\n    shifted_input_2 = shifted_input_2 | shifted_bits_2 >> (abs_difference_shifted & 0xff);\n  }\n  if (is_zero || is_negative != is_negative_2) {\n    shifted_bits_2 = shifted_bits_2 << (masked_input_2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)absolute_difference <= (int)shifted_input_1) {\n    return CONCAT44(shifted_input_2 + (shifted_input_1 - absolute_difference) * 0x100000 | input_2,shifted_bits_2);\n  }\n  masked_input_2 = ~(shifted_input_1 - absolute_difference);\n  if ((int)masked_input_2 < 0x1f) {\n    shifted_16_bits_1 = masked_input_2 - 0x13;\n    if (shifted_16_bits_1 != 0 && shifted_16_bits_1 < 0 == SCARRY4(masked_input_2 - 0x1f,0xc)) {\n      return CONCAT44(masked_input_1,shifted_bits_2 >> (0x20 - (0xcU - shifted_16_bits_1) & 0xff) | shifted_input_2 << (0xcU - shifted_16_bits_1 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    masked_input_2 = masked_input_2 + 1;\n    return CONCAT44(input_2 | shifted_input_2 >> (masked_input_2 & 0xff),\n                    shifted_bits_2 >> (masked_input_2 & 0xff) | shifted_input_2 << (0x20 - masked_input_2 & 0xff));\n  }\n  return CONCAT44(masked_input_1,shifted_input_2 >> (masked_input_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_xor_result_08000158",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shifted_bits_1",
                "bVar2": "carry_bit",
                "uVar3": "sum_1",
                "uVar4": "masked_input_1",
                "uVar5": "sum_2",
                "uVar6": "masked_input_2",
                "uVar7": "shifted_bits_2",
                "iVar8": "shifted_16_bits_1",
                "uVar9": "shifted_input_2",
                "uVar10": "shifted_input_1",
                "uVar11": "absolute_difference",
                "uVar12": "abs_difference_shifted",
                "bVar13": "is_zero",
                "bVar14": "is_negative",
                "bVar15": "is_negative_2"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_sum_0800015c",
            "code": "\nulonglong calculate_sum_0800015c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp1;\n  byte temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  bool check1;\n  bool check2;\n  bool check3;\n  \n  temp7 = input2 << 1;\n  temp9 = input4 << 1;\n  check1 = ((input2 ^ input4) & 0x7fffffff) == 0;\n  check2 = check1 && input1 == input3;\n  if (!check1 || input1 != input3) {\n    check2 = (temp7 | input1) == 0;\n  }\n  if (!check2) {\n    check2 = (temp9 | input3) == 0;\n  }\n  temp6 = (int)temp7 >> 0x15;\n  if (!check2) {\n    check2 = temp6 == -1;\n  }\n  temp1 = (int)temp9 >> 0x15;\n  if (!check2) {\n    check2 = temp1 == -1;\n  }\n  if (check2) {\n    if (temp6 == -1 || temp1 == -1) {\n      temp9 = input4;\n      temp7 = input3;\n      if (temp6 == -1) {\n        temp9 = input2;\n        temp7 = input1;\n      }\n      if (temp6 != -1 || temp1 != -1) {\n        input3 = temp7;\n        input4 = temp9;\n      }\n      check2 = (temp7 | temp9 << 0xc) == 0;\n      if (check2) {\n        check2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (check2) {\n        check2 = temp9 == input4;\n      }\n      if (!check2) {\n        temp9 = temp9 | 0x80000;\n      }\n      return CONCAT44(temp9,temp7);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp7 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (temp7 >> 0x15 == 0) {\n      check2 = (input1 & 0x80000000) != 0;\n      temp9 = input2 * 2 + (uint)check2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)check2)) {\n        temp9 = temp9 | 0x80000000;\n      }\n      return CONCAT44(temp9,input1 << 1);\n    }\n    if (temp7 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp7 = temp7 >> 0x15;\n  temp9 = temp9 >> 0x15;\n  temp10 = temp9 - temp7;\n  check2 = temp10 != 0;\n  if (temp9 < temp7) {\n    temp10 = -temp10;\n  }\n  temp8 = input1;\n  temp5 = input2;\n  if (check2 && temp7 <= temp9) {\n    temp7 = temp7 + temp10;\n    temp8 = input3;\n    temp5 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < temp10) {\n    return CONCAT44(temp5,temp8);\n  }\n  temp9 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    check2 = temp8 != 0;\n    temp8 = -temp8;\n    temp9 = -temp9 - (uint)check2;\n  }\n  temp5 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    check2 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)check2;\n  }\n  if (temp7 == temp10) {\n    temp5 = temp5 ^ 0x100000;\n    if (temp7 == 0) {\n      temp9 = temp9 ^ 0x100000;\n      temp7 = 1;\n    }\n    else {\n      temp10 = temp10 - 1;\n    }\n  }\n  temp12 = -temp10 + 0x20;\n  if ((int)temp10 < 0x21) {\n    temp11 = input3 << (temp12 & 0xff);\n    input3 = input3 >> (temp10 & 0xff);\n    temp3 = temp8 + input3;\n    temp4 = temp5 << (temp12 & 0xff);\n    temp12 = temp3 + temp4;\n    temp9 = temp9 + CARRY4(temp8,input3) + ((int)temp5 >> (temp10 & 0xff)) +\n            (uint)CARRY4(temp3,temp4);\n  }\n  else {\n    temp11 = temp5 << (-temp10 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp11 = temp11 | 2;\n    }\n    temp5 = (int)temp5 >> (temp10 - 0x20 & 0xff);\n    temp12 = temp8 + temp5;\n    temp9 = temp9 + ((int)temp5 >> 0x1f) + (uint)CARRY4(temp8,temp5);\n  }\n  input2 = temp9 & 0x80000000;\n  temp10 = temp9;\n  if ((int)temp9 < 0) {\n    check2 = temp11 == 0;\n    temp11 = -temp11;\n    temp10 = -temp12;\n    temp12 = -(uint)!check2 - temp12;\n    temp10 = -(uint)(check2 <= temp10) - temp9;\n  }\n  if (0xfffff < temp10) {\n    temp8 = temp7 - 1;\n    if (0x1fffff < temp10) {\n      temp9 = temp10 & 1;\n      temp10 = temp10 >> 1;\n      temp2 = (byte)temp12;\n      temp12 = (uint)(temp9 != 0) << 0x1f | temp12 >> 1;\n      temp11 = (uint)(temp2 & 1) << 0x1f | temp11 >> 1;\n      temp8 = temp7;\n      if (0xffbfffff < temp7 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    check2 = 0x7fffffff < temp11;\n    if (temp11 == 0x80000000) {\n      check2 = (temp12 & 1) != 0;\n    }\n    return CONCAT44(temp10 + temp8 * 0x100000 + (uint)CARRY4(temp12,(uint)check2) | input2,\n                    temp12 + check2);\n  }\n  check1 = (temp11 & 0x80000000) != 0;\n  temp11 = temp11 << 1;\n  temp8 = temp12 * 2;\n  check2 = CARRY4(temp12,temp12);\n  temp12 = temp12 * 2 + (uint)check1;\n  temp10 = temp10 * 2 + (uint)(check2 || CARRY4(temp8,(uint)check1));\n  temp8 = temp7 - 2;\n  if ((temp10 & 0x100000) != 0) goto LAB_08000268;\n  temp5 = temp12;\n  temp7 = temp10;\n  if (temp10 == 0) {\n    temp5 = 0;\n    temp7 = temp12;\n  }\n  temp6 = LZCOUNT(temp7);\n  if (temp10 == 0) {\n    temp6 = temp6 + 0x20;\n  }\n  temp12 = temp6 - 0xb;\n  check3 = SBORROW4(temp12,0x20);\n  temp10 = temp6 - 0x2b;\n  check2 = (int)temp10 < 0;\n  check1 = temp10 == 0;\n  if ((int)temp12 < 0x20) {\n    check3 = SCARRY4(temp10,0xc);\n    temp6 = temp6 + -0x1f;\n    check2 = temp6 < 0;\n    check1 = temp6 == 0;\n    temp10 = temp12;\n    if (!check1 && check2 == check3) {\n      temp5 = temp7 << (temp12 & 0xff);\n      temp7 = temp7 >> (0xcU - temp6 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (check1 || check2 != check3) {\n    temp11 = 0x20 - temp10;\n  }\n  temp7 = temp7 << (temp10 & 0xff);\n  if (check1 || check2 != check3) {\n    temp7 = temp7 | temp5 >> (temp11 & 0xff);\n  }\n  if (check1 || check2 != check3) {\n    temp5 = temp5 << (temp10 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp12 <= (int)temp8) {\n    return CONCAT44(temp7 + (temp8 - temp12) * 0x100000 | input2,temp5);\n  }\n  temp10 = ~(temp8 - temp12);\n  if ((int)temp10 < 0x1f) {\n    temp6 = temp10 - 0x13;\n    if (temp6 != 0 && temp6 < 0 == SCARRY4(temp10 - 0x1f,0xc)) {\n      return CONCAT44(temp9,temp5 >> (0x20 - (0xcU - temp6) & 0xff) | temp7 << (0xcU - temp6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp10 = temp10 + 1;\n    return CONCAT44(input2 | temp7 >> (temp10 & 0xff),\n                    temp5 >> (temp10 & 0xff) | temp7 << (0x20 - temp10 & 0xff));\n  }\n  return CONCAT44(temp9,temp7 >> (temp10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_sum_0800015c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "bVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "iVar6": "temp6",
                "uVar7": "temp7",
                "uVar8": "temp8",
                "uVar9": "temp9",
                "uVar10": "temp10",
                "uVar11": "temp11",
                "uVar12": "temp12",
                "bVar13": "check1",
                "bVar14": "check2",
                "bVar15": "check3"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "__aeabi_drsub",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "bitwise_shift_with_offset_080003d4",
            "code": "\nulonglong bitwise_shift_with_offset_080003d4(uint input_value)\n\n{\n  uint shifted_value;\n  uint offset;\n  int count;\n  uint adjusted_count;\n  uint remaining_bits;\n  bool is_negative_count;\n  bool is_zero_count;\n  bool is_negative_adjusted_count;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  shifted_value = 0;\n  count = LZCOUNT(input_value);\n  adjusted_count = count + 0x15;\n  is_negative_adjusted_count = SBORROW4(adjusted_count,0x20);\n  offset = count - 0xb;\n  is_negative_count = (int)offset < 0;\n  is_zero_count = offset == 0;\n  if (adjusted_count < 0x20) {\n    is_negative_adjusted_count = SCARRY4(offset,0xc);\n    is_negative_count = false;\n    is_zero_count = count + 1 == 0;\n    offset = adjusted_count;\n    if (!is_zero_count && is_negative_adjusted_count == false) {\n      shifted_value = input_value << adjusted_count;\n      input_value = input_value >> (0xcU - (count + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero_count || is_negative_count != is_negative_adjusted_count) {\n    remaining_bits = 0x20 - offset;\n  }\n  input_value = input_value << (offset & 0xff);\n  if (is_zero_count || is_negative_count != is_negative_adjusted_count) {\n    input_value = input_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero_count || is_negative_count != is_negative_adjusted_count) {\n    shifted_value = 0 << (offset & 0xff);\n  }\nLAB_080002e0:\n  if (adjusted_count < 0x433) {\n    return CONCAT44(input_value + (0x432 - adjusted_count) * 0x100000,shifted_value);\n  }\n  offset = ~(0x432 - adjusted_count);\n  if (0x1e < (int)offset) {\n    return (ulonglong)(input_value >> (offset - 0x1f & 0xff));\n  }\n  count = offset - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(offset - 0x1f,0xc)) {\n    offset = offset + 1;\n    return CONCAT44(input_value >> (offset & 0xff),\n                    shifted_value >> (offset & 0xff) | input_value << (0x20 - offset & 0xff));\n  }\n  return (ulonglong)(shifted_value >> (0x20 - (0xcU - count) & 0xff) | input_value << (0xcU - count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "bitwise_shift_with_offset_080003d4",
                "param_1": "input_value",
                "uVar1": "shifted_value",
                "uVar2": "offset",
                "iVar3": "count",
                "uVar4": "adjusted_count",
                "in_r12": "remaining_bits",
                "bVar5": "is_negative_count",
                "bVar6": "is_zero_count",
                "bVar7": "is_negative_adjusted_count"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "decode_bits_080003f4",
            "code": "\nulonglong decode_bits_080003f4(uint input)\n\n{\n  uint shift_amount;\n  uint abs_input;\n  uint extra_shift;\n  int bit_count;\n  uint total_shift;\n  uint sign_bit;\n  uint remaining_bits;\n  bool is_negative;\n  bool is_zero;\n  bool carry_flag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  sign_bit = input & 0x80000000;\n  abs_input = input;\n  if ((int)sign_bit < 0) {\n    abs_input = -input;\n  }\n  shift_amount = 0;\n  bit_count = LZCOUNT(abs_input);\n  total_shift = bit_count + 0x15;\n  carry_flag = SBORROW4(total_shift,0x20);\n  extra_shift = bit_count - 0xb;\n  is_negative = (int)extra_shift < 0;\n  is_zero = extra_shift == 0;\n  if (total_shift < 0x20) {\n    carry_flag = SCARRY4(extra_shift,0xc);\n    is_negative = false;\n    is_zero = bit_count + 1 == 0;\n    extra_shift = total_shift;\n    if (!is_zero && carry_flag == false) {\n      shift_amount = abs_input << total_shift;\n      abs_input = abs_input >> (0xcU - (bit_count + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative != carry_flag) {\n    remaining_bits = 0x20 - extra_shift;\n  }\n  abs_input = abs_input << (extra_shift & 0xff);\n  if (is_zero || is_negative != carry_flag) {\n    abs_input = abs_input | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero || is_negative != carry_flag) {\n    shift_amount = 0 << (extra_shift & 0xff);\n  }\nLAB_080002e0:\n  if (total_shift < 0x433) {\n    return CONCAT44(abs_input + (0x432 - total_shift) * 0x100000 | sign_bit,shift_amount);\n  }\n  extra_shift = ~(0x432 - total_shift);\n  if (0x1e < (int)extra_shift) {\n    return CONCAT44(input,abs_input >> (extra_shift - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bit_count = extra_shift - 0x13;\n  if (bit_count == 0 || bit_count < 0 != SCARRY4(extra_shift - 0x1f,0xc)) {\n    extra_shift = extra_shift + 1;\n    return CONCAT44(sign_bit | abs_input >> (extra_shift & 0xff),\n                    shift_amount >> (extra_shift & 0xff) | abs_input << (0x20 - extra_shift & 0xff));\n  }\n  return CONCAT44(input,shift_amount >> (0x20 - (0xcU - bit_count) & 0xff) | abs_input << (0xcU - bit_count & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "decode_bits_080003f4",
                "param_1": "input",
                "uVar1": "shift_amount",
                "uVar2": "abs_input",
                "uVar3": "extra_shift",
                "iVar4": "bit_count",
                "uVar5": "total_shift",
                "uVar6": "sign_bit",
                "in_r12": "remaining_bits",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "carry_flag"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverseBits_08000418(uint inputValue,undefined4 param_2,undefined4 param_3,uint mask)\n\n{\n  uint signBit;\n  uint temp;\n  uint result;\n  uint shiftCount;\n  uint tempValue;\n  int bitCount;\n  uint shiftedBitCount;\n  uint mask2;\n  bool isShiftZero;\n  bool isMaskSet;\n  bool isOverflow;\n  \n  tempValue = inputValue << 1;\n  isMaskSet = tempValue == 0;\n  signBit = (uint)((inputValue & 0x80000000) != 0) << 0x1f;\n  shiftCount = (uint)((int)tempValue >> 3) >> 1;\n  result = signBit | shiftCount;\n  inputValue = inputValue << 0x1d;\n  if (!isMaskSet) {\n    mask = tempValue & 0xff000000;\n    isMaskSet = mask == 0;\n  }\n  if (!isMaskSet) {\n    isMaskSet = mask == 0xff000000;\n  }\n  if (!isMaskSet) {\n    return CONCAT44(result,inputValue) ^ 0x3800000000000000;\n  }\n  if ((tempValue & 0xffffff) == 0) {\n    return CONCAT44(result,inputValue);\n  }\n  if (mask == 0xff000000) {\n    return CONCAT44(result,inputValue) | 0x8000000000000;\n  }\n  temp = inputValue;\n  tempValue = shiftCount;\n  if (shiftCount == 0) {\n    temp = 0;\n    tempValue = inputValue;\n  }\n  bitCount = LZCOUNT(tempValue);\n  if (shiftCount == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  shiftedBitCount = bitCount - 0xb;\n  isOverflow = SBORROW4(shiftedBitCount,0x20);\n  shiftCount = bitCount - 0x2b;\n  isMaskSet = (int)shiftCount < 0;\n  isShiftZero = shiftCount == 0;\n  if ((int)shiftedBitCount < 0x20) {\n    isOverflow = SCARRY4(shiftCount,0xc);\n    bitCount = bitCount + -0x1f;\n    isMaskSet = bitCount < 0;\n    isShiftZero = bitCount == 0;\n    shiftCount = shiftedBitCount;\n    if (!isShiftZero && isMaskSet == isOverflow) {\n      temp = tempValue << (shiftedBitCount & 0xff);\n      tempValue = tempValue >> (0xcU - bitCount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isShiftZero || isMaskSet != isOverflow) {\n    mask2 = 0x20 - shiftCount;\n  }\n  tempValue = tempValue << (shiftCount & 0xff);\n  if (isShiftZero || isMaskSet != isOverflow) {\n    tempValue = tempValue | temp >> (mask2 & 0xff);\n  }\n  if (isShiftZero || isMaskSet != isOverflow) {\n    temp = temp << (shiftCount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftedBitCount < 0x381) {\n    return CONCAT44(tempValue + (0x380 - shiftedBitCount) * 0x100000 | signBit,temp);\n  }\n  shiftCount = ~(0x380 - shiftedBitCount);\n  if (0x1e < (int)shiftCount) {\n    return CONCAT44(result,tempValue >> (shiftCount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bitCount = shiftCount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftCount - 0x1f,0xc)) {\n    shiftCount = shiftCount + 1;\n    return CONCAT44(signBit | tempValue >> (shiftCount & 0xff),\n                    temp >> (shiftCount & 0xff) | tempValue << (0x20 - shiftCount & 0xff));\n  }\n  return CONCAT44(result,temp >> (0x20 - (0xcU - bitCount) & 0xff) | tempValue << (0xcU - bitCount & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "inputValue",
                "param_4": "mask",
                "uVar1": "signBit",
                "uVar2": "temp",
                "uVar3": "result",
                "uVar4": "shiftCount",
                "uVar5": "tempValue",
                "iVar6": "bitCount",
                "uVar7": "shiftedBitCount",
                "in_r12": "mask2",
                "bVar8": "isShiftZero",
                "bVar9": "isMaskSet",
                "bVar10": "isOverflow"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800045c": {
            "entrypoint": "0x0800045c",
            "current_name": "calculate_float_0800045c",
            "code": "\nulonglong calculateFloat_0800045c(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftAmount;\n  uint shiftedBits1;\n  int iteration;\n  uint shiftedBits2;\n  bool carry;\n  bool overflow;\n  bool borrow;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  iteration = 0x432;\n  shiftedBits2 = input2 >> 0x16;\n  if (shiftedBits2 != 0) {\n    iteration = 3;\n    if (input2 >> 0x19 != 0) {\n      iteration = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      iteration = iteration + 3;\n    }\n    temp3 = iteration - ((int)input2 >> 0x1f);\n    shiftedBits2 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    iteration = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      shiftedBits2 = (uint)(bit1 & 1) << 0x1f | shiftedBits2 >> 1;\n      iteration = iteration + 1;\n      if (0xffbfffff < (uint)(iteration * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000268:\n    overflow = 0x7fffffff < shiftedBits2;\n    if (shiftedBits2 == 0x80000000) {\n      overflow = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + iteration * 0x100000 + (uint)CARRY4(input1,(uint)overflow),input1 + overflow\n                   );\n  }\n  carry = (shiftedBits2 & 0x80000000) != 0;\n  shiftedBits2 = shiftedBits2 << 1;\n  temp3 = input1 * 2;\n  overflow = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)carry;\n  input2 = input2 * 2 + (uint)(overflow || CARRY4(temp3,(uint)carry));\n  iteration = iteration + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000268;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  shiftAmount = LZCOUNT(temp3);\n  if (input2 == 0) {\n    shiftAmount = shiftAmount + 0x20;\n  }\n  shiftedBits1 = shiftAmount - 0xb;\n  borrow = SBORROW4(shiftedBits1,0x20);\n  temp2 = shiftAmount - 0x2b;\n  overflow = (int)temp2 < 0;\n  carry = temp2 == 0;\n  if ((int)shiftedBits1 < 0x20) {\n    borrow = SCARRY4(temp2,0xc);\n    shiftAmount = shiftAmount + -0x1f;\n    overflow = shiftAmount < 0;\n    carry = shiftAmount == 0;\n    temp2 = shiftedBits1;\n    if (!carry && overflow == borrow) {\n      temp1 = temp3 << (shiftedBits1 & 0xff);\n      temp3 = temp3 >> (0xcU - shiftAmount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (carry || overflow != borrow) {\n    shiftedBits2 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (carry || overflow != borrow) {\n    temp3 = temp3 | temp1 >> (shiftedBits2 & 0xff);\n  }\n  if (carry || overflow != borrow) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftedBits1 <= iteration) {\n    return CONCAT44(temp3 + (iteration - shiftedBits1) * 0x100000,temp1);\n  }\n  shiftedBits2 = ~(iteration - shiftedBits1);\n  if (0x1e < (int)shiftedBits2) {\n    return (ulonglong)(temp3 >> (shiftedBits2 - 0x1f & 0xff));\n  }\n  iteration = shiftedBits2 - 0x13;\n  if (iteration == 0 || iteration < 0 != SCARRY4(shiftedBits2 - 0x1f,0xc)) {\n    shiftedBits2 = shiftedBits2 + 1;\n    return CONCAT44(temp3 >> (shiftedBits2 & 0xff),temp1 >> (shiftedBits2 & 0xff) | temp3 << (0x20 - shiftedBits2 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - iteration) & 0xff) | temp3 << (0xcU - iteration & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800045c": "calculate_float_0800045c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "shiftAmount",
                "uVar6": "shiftedBits1",
                "iVar7": "iteration",
                "uVar8": "shiftedBits2",
                "bVar9": "carry",
                "bVar10": "overflow",
                "bVar11": "borrow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800046c": {
            "entrypoint": "0x0800046c",
            "current_name": "calculate_floating_point_0800046c",
            "code": "\nulonglong calculateFloatingPoint_0800046c(uint unsignedInteger1,uint unsignedInteger2)\n\n{\n  byte bit1;\n  uint tempUnsigned1;\n  uint tempUnsigned2;\n  uint tempUnsigned3;\n  int tempInteger1;\n  uint tempUnsigned4;\n  int tempInteger2;\n  uint tempUnsigned5;\n  uint tempUnsigned6;\n  bool carryFlag1;\n  bool compareFlag1;\n  bool signedOverflowFlag1;\n  \n  if ((unsignedInteger1 | unsignedInteger2) == 0) {\n    return concatenate(unsignedInteger2,unsignedInteger1);\n  }\n  tempUnsigned5 = unsignedInteger2 & 0x80000000;\n  tempUnsigned2 = unsignedInteger2;\n  if ((int)tempUnsigned5 < 0) {\n    compareFlag1 = unsignedInteger1 != 0;\n    unsignedInteger1 = -unsignedInteger1;\n    tempUnsigned2 = -unsignedInteger2 - (uint)compareFlag1;\n  }\n  tempInteger2 = 0x432;\n  tempUnsigned6 = tempUnsigned2 >> 0x16;\n  if (tempUnsigned6 != 0) {\n    tempInteger2 = 3;\n    if (tempUnsigned2 >> 0x19 != 0) {\n      tempInteger2 = 6;\n    }\n    if (tempUnsigned2 >> 0x1c != 0) {\n      tempInteger2 = tempInteger2 + 3;\n    }\n    tempUnsigned3 = tempInteger2 - ((int)tempUnsigned2 >> 0x1f);\n    tempUnsigned6 = unsignedInteger1 << (0x20 - tempUnsigned3 & 0xff);\n    unsignedInteger1 = unsignedInteger1 >> (tempUnsigned3 & 0xff) | tempUnsigned2 << (0x20 - tempUnsigned3 & 0xff);\n    tempUnsigned2 = tempUnsigned2 >> (tempUnsigned3 & 0xff);\n    tempInteger2 = tempUnsigned3 + 0x432;\n  }\n  if (0xfffff < tempUnsigned2) {\n    if (0x1fffff < tempUnsigned2) {\n      tempUnsigned3 = tempUnsigned2 & 1;\n      tempUnsigned2 = tempUnsigned2 >> 1;\n      bit1 = (byte)unsignedInteger1;\n      unsignedInteger1 = (uint)(tempUnsigned3 != 0) << 0x1f | unsignedInteger1 >> 1;\n      tempUnsigned6 = (uint)(bit1 & 1) << 0x1f | tempUnsigned6 >> 1;\n      tempInteger2 = tempInteger2 + 1;\n      if (0xffbfffff < (uint)(tempInteger2 * 0x200000)) {\n        return (ulonglong)(tempUnsigned5 | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000268:\n    compareFlag1 = 0x7fffffff < tempUnsigned6;\n    if (tempUnsigned6 == 0x80000000) {\n      compareFlag1 = (unsignedInteger1 & 1) != 0;\n    }\n    return concatenate(tempUnsigned2 + tempInteger2 * 0x100000 + (uint)calculateCarry(unsignedInteger1,(uint)compareFlag1) | tempUnsigned5,\n                    unsignedInteger1 + compareFlag1);\n  }\n  carryFlag1 = (tempUnsigned6 & 0x80000000) != 0;\n  tempUnsigned6 = tempUnsigned6 << 1;\n  tempUnsigned3 = unsignedInteger1 * 2;\n  compareFlag1 = calculateCarry(unsignedInteger1,unsignedInteger1);\n  unsignedInteger1 = unsignedInteger1 * 2 + (uint)carryFlag1;\n  tempUnsigned2 = tempUnsigned2 * 2 + (uint)(compareFlag1 || calculateCarry(tempUnsigned3,(uint)carryFlag1));\n  tempInteger2 = tempInteger2 + -1;\n  if ((tempUnsigned2 & 0x100000) != 0) goto LAB_08000268;\n  tempUnsigned1 = unsignedInteger1;\n  tempUnsigned3 = tempUnsigned2;\n  if (tempUnsigned2 == 0) {\n    tempUnsigned1 = 0;\n    tempUnsigned3 = unsignedInteger1;\n  }\n  tempInteger1 = leadingZeroCount(tempUnsigned3);\n  if (tempUnsigned2 == 0) {\n    tempInteger1 = tempInteger1 + 0x20;\n  }\n  tempUnsigned4 = tempInteger1 - 0xb;\n  signedOverflowFlag1 = calculateSignedOverflow(tempUnsigned4,0x20);\n  tempUnsigned2 = tempInteger1 - 0x2b;\n  compareFlag1 = (int)tempUnsigned2 < 0;\n  carryFlag1 = tempUnsigned2 == 0;\n  if ((int)tempUnsigned4 < 0x20) {\n    signedOverflowFlag1 = calculateSignedCarry(tempUnsigned2,0xc);\n    tempInteger1 = tempInteger1 + -0x1f;\n    compareFlag1 = tempInteger1 < 0;\n    carryFlag1 = tempInteger1 == 0;\n    tempUnsigned2 = tempUnsigned4;\n    if (!carryFlag1 && compareFlag1 == signedOverflowFlag1) {\n      tempUnsigned1 = tempUnsigned3 << (tempUnsigned4 & 0xff);\n      tempUnsigned3 = tempUnsigned3 >> (0xcU - tempInteger1 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (carryFlag1 || compareFlag1 != signedOverflowFlag1) {\n    tempUnsigned6 = 0x20 - tempUnsigned2;\n  }\n  tempUnsigned3 = tempUnsigned3 << (tempUnsigned2 & 0xff);\n  if (carryFlag1 || compareFlag1 != signedOverflowFlag1) {\n    tempUnsigned3 = tempUnsigned3 | tempUnsigned1 >> (tempUnsigned6 & 0xff);\n  }\n  if (carryFlag1 || compareFlag1 != signedOverflowFlag1) {\n    tempUnsigned1 = tempUnsigned1 << (tempUnsigned2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)tempUnsigned4 <= tempInteger2) {\n    return concatenate(tempUnsigned3 + (tempInteger2 - tempUnsigned4) * 0x100000 | tempUnsigned5,tempUnsigned1);\n  }\n  tempUnsigned2 = ~(tempInteger2 - tempUnsigned4);\n  if (0x1e < (int)tempUnsigned2) {\n    return concatenate(unsignedInteger2,tempUnsigned3 >> (tempUnsigned2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  tempInteger2 = tempUnsigned2 - 0x13;\n  if (tempInteger2 == 0 || tempInteger2 < 0 != calculateSignedCarry(tempUnsigned2 - 0x1f,0xc)) {\n    tempUnsigned2 = tempUnsigned2 + 1;\n    return concatenate(tempUnsigned5 | tempUnsigned3 >> (tempUnsigned2 & 0xff),\n                    tempUnsigned1 >> (tempUnsigned2 & 0xff) | tempUnsigned3 << (0x20 - tempUnsigned2 & 0xff));\n  }\n  return concatenate(unsignedInteger2,tempUnsigned1 >> (0x20 - (0xcU - tempInteger2) & 0xff) | tempUnsigned3 << (0xcU - tempInteger2 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800046c": "calculate_floating_point_0800046c",
                "param_1": "unsignedInteger1",
                "param_2": "unsignedInteger2",
                "bVar1": "bit1",
                "uVar2": "tempUnsigned1",
                "uVar3": "tempUnsigned2",
                "uVar4": "tempUnsigned3",
                "iVar5": "tempInteger1",
                "uVar6": "tempUnsigned4",
                "iVar7": "tempInteger2",
                "uVar8": "tempUnsigned5",
                "uVar9": "tempUnsigned6",
                "bVar10": "carryFlag1",
                "bVar11": "compareFlag1",
                "bVar12": "signedOverflowFlag1",
                "CONCAT44": "concatenate",
                "CARRY4": "calculateCarry",
                "LZCOUNT": "leadingZeroCount",
                "SBORROW4": "calculateSignedOverflow",
                "SCARRY4": "calculateSignedCarry"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_value_080004c8",
            "code": "\nulonglong calculate_value_080004c8(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  ulonglong result;\n  longlong temp;\n  uint temp_1;\n  uint temp_2;\n  int temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint temp_7;\n  bool flag_1;\n  bool flag_2;\n  bool flag_3;\n  ulonglong input_combined;\n  \n  input_combined = CONCAT44(input_2,input_1);\n  temp_6 = 0x7ff;\n  temp_2 = input_2 >> 0x14 & 0x7ff;\n  flag_1 = temp_2 == 0;\n  if (!flag_1) {\n    temp_5 = input_4 >> 0x14 & 0x7ff;\n    flag_1 = temp_5 == 0;\n  }\n  if (!flag_1) {\n    flag_1 = temp_2 == 0x7ff;\n  }\n  if (!flag_1) {\n    flag_1 = temp_5 == 0x7ff;\n  }\n  if (flag_1) {\n    input_combined = calculate_bitwise_080006a4();\n  }\n  temp_1 = (uint)(input_combined >> 0x20);\n  temp_3 = temp_2 + temp_5;\n  temp_2 = temp_1 ^ input_4;\n  temp_1 = temp_1 & ~(temp_6 << 0x15);\n  input_4 = input_4 & ~(temp_6 << 0x15);\n  flag_1 = ((uint)input_combined | temp_1 << 0xc) == 0;\n  if (!flag_1) {\n    flag_1 = (input_3 | input_4 << 0xc) == 0;\n  }\n  temp_1 = temp_1 | 0x100000;\n  input_4 = input_4 | 0x100000;\n  if (flag_1) {\n    input_3 = (uint)input_combined | input_3;\n    input_4 = (temp_2 & 0x80000000 | temp_1) ^ input_4;\n    temp_2 = temp_6 >> 1;\n    flag_3 = SBORROW4(temp_3,temp_2);\n    temp_4 = temp_3 - temp_2;\n    flag_1 = temp_4 == 0;\n    temp_1 = temp_4;\n    if (!flag_1 && (int)temp_2 <= temp_3) {\n      flag_3 = SBORROW4(temp_6,temp_4);\n      temp_1 = temp_6 - temp_4;\n      flag_1 = temp_6 == temp_4;\n    }\n    if (!flag_1 && (int)temp_1 < 0 == flag_3) {\n      input_4 = input_4 | temp_4 * 0x100000;\n    }\n    if (!flag_1 && (int)temp_1 < 0 == flag_3) {\n      return CONCAT44(input_4,input_3);\n    }\n    input_4 = input_4 | 0x100000;\n    temp_6 = 0;\n    flag_3 = SBORROW4(temp_4,1);\n    temp_4 = temp_4 - 1;\n    flag_1 = temp_4 == 0;\n    temp_2 = temp_4;\n  }\n  else {\n    result = (input_combined & 0xffffffff) * (ulonglong)input_3;\n    input_combined = (input_combined & 0xffffffff) * (ulonglong)input_4 +\n             (ulonglong)temp_1 * (ulonglong)input_3 + (result >> 0x20);\n    temp_7 = (uint)input_combined;\n    temp = (ulonglong)temp_1 * (ulonglong)input_4 + (input_combined >> 0x20);\n    temp_6 = (uint)temp;\n    temp_1 = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result != 0) {\n      temp_7 = temp_7 | 1;\n    }\n    temp_4 = (temp_3 + -0x3ff) - (uint)(temp_1 < 0x200);\n    if (temp_1 < 0x200) {\n      flag_1 = (temp_7 & 0x80000000) != 0;\n      temp_7 = temp_7 << 1;\n      temp = CONCAT44(temp_1 * 2 + (uint)(CARRY4(temp_6,temp_6) || CARRY4(temp_6 * 2,(uint)flag_1)),\n                       temp_6 * 2 + (uint)flag_1);\n    }\n    input_4 = temp_2 & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    input_3 = (uint)temp << 0xb | temp_7 >> 0x15;\n    temp_6 = temp_7 * 0x800;\n    flag_2 = 0xfc < temp_4;\n    flag_3 = SBORROW4(temp_4,0xfd);\n    temp_1 = temp_4 - 0xfd;\n    flag_1 = temp_1 == 0;\n    temp_2 = temp_1;\n    if (flag_2 && !flag_1) {\n      flag_2 = 0x6ff < temp_1;\n      flag_3 = SBORROW4(temp_1,0x700);\n      temp_2 = temp_4 - 0x7fd;\n      flag_1 = temp_1 == 0x700;\n    }\n    if (!flag_2 || flag_1) {\n      flag_1 = 0x7fffffff < temp_6;\n      if (temp_6 == 0x80000000) {\n        flag_1 = (temp_7 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_4 + temp_4 * 0x100000 + (uint)CARRY4(input_3,(uint)flag_1),input_3 + flag_1\n                     );\n    }\n  }\n  if (!flag_1 && (int)temp_2 < 0 == flag_3) {\n    return (ulonglong)(input_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag_2 = SCARRY4(temp_4,0x36);\n  flag_1 = (int)(temp_4 + 0x36) < 0;\n  flag_3 = temp_4 == 0xffffffca;\n  if (flag_3 || flag_1 != flag_2) {\n    input_3 = 0;\n  }\n  if (flag_3 || flag_1 != flag_2) {\n    input_4 = input_4 & 0x80000000;\n  }\n  if (flag_3 || flag_1 != flag_2) {\n    return CONCAT44(input_4,input_3);\n  }\n  temp_2 = -temp_4;\n  temp_1 = temp_2 - 0x20;\n  if (0x1f < (int)temp_2) {\n    temp_4 = input_3 >> (temp_1 & 0xff) | input_4 << (0x20 - temp_1 & 0xff);\n    temp_2 = (input_4 >> (temp_1 & 0xff) & ~((input_4 & 0x80000000) >> (temp_1 & 0xff))) -\n            ((int)temp_4 >> 0x1f);\n    if ((temp_6 | input_3 << (0x20 - temp_1 & 0xff) | temp_4 << 1) == 0) {\n      temp_2 = temp_2 & ~(temp_4 >> 0x1f);\n    }\n    return CONCAT44(input_4,temp_2) & 0x80000000ffffffff;\n  }\n  temp_3 = temp_2 - 0x14;\n  if (temp_3 == 0 || temp_3 < 0 != SCARRY4(temp_1,0xc)) {\n    temp_7 = input_3 << (temp_4 + 0x20 & 0xff);\n    temp_1 = input_3 >> (temp_2 & 0xff) | input_4 << (temp_4 + 0x20 & 0xff);\n    temp_4 = temp_1 + -((int)temp_7 >> 0x1f);\n    if ((temp_6 | temp_7 << 1) == 0) {\n      temp_4 = temp_4 & ~(temp_7 >> 0x1f);\n    }\n    return CONCAT44((input_4 & 0x80000000) +\n                    ((input_4 & 0x7fffffff) >> (temp_2 & 0xff)) +\n                    (uint)CARRY4(temp_1,-((int)temp_7 >> 0x1f)),temp_4);\n  }\n  temp_2 = 0xc - temp_3;\n  temp_4 = input_3 << (temp_2 & 0xff);\n  temp_2 = input_3 >> (0x20 - temp_2 & 0xff) | input_4 << (temp_2 & 0xff);\n  temp_1 = temp_2 + -((int)temp_4 >> 0x1f);\n  if ((temp_6 | temp_4 << 1) == 0) {\n    temp_1 = temp_1 & ~(temp_4 >> 0x1f);\n  }\n  return CONCAT44((input_4 & 0x80000000) + (uint)CARRY4(temp_2,-((int)temp_4 >> 0x1f)),temp_1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_value_080004c8",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "lVar2": "temp",
                "uVar3": "temp_1",
                "uVar4": "temp_2",
                "iVar5": "temp_3",
                "uVar6": "temp_4",
                "unaff_r5": "temp_5",
                "uVar7": "temp_6",
                "uVar8": "temp_7",
                "bVar9": "flag_1",
                "bVar10": "flag_2",
                "bVar11": "flag_3",
                "uVar12": "input_combined"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "frexp",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_bitwise_080006a4",
            "code": "\nulonglong calculate_bitwise_080006a4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint bit_4;\n  uint bit_5;\n  bool is_zero;\n  \n  bit_3 = bit_5 & input_4 >> 0x14;\n  if (bit_2 != bit_5 && bit_3 != bit_5) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      result (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (bit_2 == 0) {\n      bit_4 = input_2 & 0x80000000;\n      do {\n        bit_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | bit_4;\n      if (bit_3 != 0) {\n        result CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      bit_3 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(bit_3 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    result CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  bit_4 = input_2;\n  if (((!is_zero) && ((bit_2 != bit_5 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((bit_3 != bit_5 || (input_1 = input_3, bit_4 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    result (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  result CONCAT44(bit_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_bitwise_080006a4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "bit_4",
                "in_r12": "bit_5",
                "bVar4": "is_zero",
                "return": "result"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_floating_point_0800071c",
            "code": "\nulonglong calculateFloatingPoint_0800071c(undefined4 signBit,uint exponentBits,uint mantissaBits1,uint mantissaBits2)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int exponentDiff;\n  uint exponent1;\n  uint exponent2;\n  uint temp8;\n  uint mantissa1;\n  uint mantissaDiff;\n  uint mantissa2;\n  bool condition1;\n  bool condition2;\n  bool overflow;\n  undefined8 result;\n  \n  result = CONCAT44(exponentBits,signBit);\n  mantissa2 = 0x7ff;\n  temp7 = exponentBits >> 0x14 & 0x7ff;\n  condition1 = temp7 == 0;\n  if (!condition1) {\n    exponent2 = mantissaBits2 >> 0x14 & 0x7ff;\n    condition1 = exponent2 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp7 == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = exponent2 == 0x7ff;\n  }\n  if (condition1) {\n    result = extract_and_combine_bits_0800088a();\n  }\n  exponent1 = (uint)((ulonglong)result >> 0x20);\n  mantissa1 = (uint)result;\n  exponentDiff = temp7 - exponent2;\n  if ((mantissaBits1 | mantissaBits2 << 0xc) == 0) {\n    temp7 = (exponent1 ^ mantissaBits2) & 0x80000000 | exponent1 & 0xfffff;\n    overflow = SCARRY4(exponentDiff,mantissa2 >> 1);\n    exponent1 = exponentDiff + (mantissa2 >> 1);\n    condition1 = (int)exponent1 < 0;\n    condition2 = exponent1 == 0;\n    if (!condition2 && condition1 == overflow) {\n      overflow = SBORROW4(mantissa2,exponent1);\n      condition1 = (int)(mantissa2 - exponent1) < 0;\n      condition2 = mantissa2 == exponent1;\n    }\n    if (!condition2 && condition1 == overflow) {\n      temp7 = temp7 | exponent1 * 0x100000;\n    }\n    if (!condition2 && condition1 == overflow) {\n      return CONCAT44(temp7,mantissa1);\n    }\n    temp7 = temp7 | 0x100000;\n    mantissa2 = 0;\n    condition2 = SBORROW4(exponent1,1);\n    exponent1 = exponent1 - 1;\n    condition1 = exponent1 == 0;\n    temp3 = exponent1;\n  }\n  else {\n    temp3 = (mantissaBits2 << 0xc) >> 4 | 0x10000000 | mantissaBits1 >> 0x18;\n    mantissa2 = mantissaBits1 << 8;\n    temp8 = (exponent1 << 0xc) >> 4 | 0x10000000 | mantissa1 >> 0x18;\n    mantissa1 = mantissa1 * 0x100;\n    temp7 = (exponent1 ^ mantissaBits2) & 0x80000000;\n    condition1 = temp3 <= temp8;\n    if (temp8 == temp3) {\n      condition1 = mantissa2 <= mantissa1;\n    }\n    exponentDiff = exponentDiff + (uint)condition1;\n    exponent1 = exponentDiff + 0x3fd;\n    if (condition1 == false) {\n      temp3 = temp3 >> 1;\n      mantissa2 = (uint)((mantissaBits1 >> 0x18 & 1) != 0) << 0x1f | mantissa2 >> 1;\n    }\n    mantissaDiff = mantissa1 - mantissa2;\n    temp8 = (temp8 - temp3) - (uint)(mantissa1 < mantissa2);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | mantissa2 >> 1;\n    mantissa1 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      condition1 = temp1 <= mantissaDiff;\n      if (temp4 < temp8 || temp8 - temp4 < (uint)condition1) {\n        mantissaDiff = mantissaDiff - temp1;\n        mantissa1 = mantissa1 | temp3;\n        temp8 = (temp8 - temp4) - (uint)!condition1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      condition2 = temp1 <= mantissaDiff;\n      condition1 = temp8 - temp5 < (uint)condition2;\n      mantissa2 = temp8;\n      if (temp5 < temp8 || condition1) {\n        mantissaDiff = mantissaDiff - temp1;\n        mantissa2 = (temp8 - temp5) - (uint)!condition2;\n      }\n      if (temp5 < temp8 || condition1) {\n        mantissa1 = mantissa1 | temp3 >> 1;\n      }\n      temp8 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      condition2 = temp2 <= mantissaDiff;\n      condition1 = mantissa2 - temp8 < (uint)condition2;\n      temp5 = mantissa2;\n      if (temp8 < mantissa2 || condition1) {\n        mantissaDiff = mantissaDiff - temp2;\n        temp5 = (mantissa2 - temp8) - (uint)!condition2;\n      }\n      if (temp8 < mantissa2 || condition1) {\n        mantissa1 = mantissa1 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp8 & 1) != 0) << 0x1f | temp2 >> 1;\n      condition2 = temp1 <= mantissaDiff;\n      condition1 = temp5 - temp6 < (uint)condition2;\n      temp8 = temp5;\n      if (temp6 < temp5 || condition1) {\n        mantissaDiff = mantissaDiff - temp1;\n        temp8 = (temp5 - temp6) - (uint)!condition2;\n      }\n      if (temp6 < temp5 || condition1) {\n        mantissa1 = mantissa1 | temp3 >> 3;\n      }\n      mantissa2 = temp8 | mantissaDiff;\n      if (mantissa2 == 0) break;\n      temp8 = temp8 << 4 | mantissaDiff >> 0x1c;\n      mantissaDiff = mantissaDiff << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800083a;\n        temp7 = temp7 | mantissa1;\n        mantissa1 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | mantissa1;\n      mantissa1 = 0;\n    }\nLAB_0800083a:\n    overflow = 0xfc < exponent1;\n    condition2 = SBORROW4(exponent1,0xfd);\n    temp4 = exponentDiff + 0x300;\n    condition1 = temp4 == 0;\n    temp3 = temp4;\n    if (overflow && !condition1) {\n      overflow = 0x6ff < temp4;\n      condition2 = SBORROW4(temp4,0x700);\n      temp3 = exponentDiff - 0x400;\n      condition1 = temp4 == 0x700;\n    }\n    if (!overflow || condition1) {\n      condition1 = temp6 <= temp8;\n      if (temp8 == temp6) {\n        condition1 = temp1 <= mantissaDiff;\n      }\n      if (temp8 == temp6 && mantissaDiff == temp1) {\n        condition1 = (mantissa1 & 1) != 0;\n      }\n      return CONCAT44(temp7 + exponent1 * 0x100000 + (uint)CARRY4(mantissa1,(uint)condition1),mantissa1 + condition1);\n    }\n  }\n  if (!condition1 && (int)temp3 < 0 == condition2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  overflow = SCARRY4(exponent1,0x36);\n  condition1 = (int)(exponent1 + 0x36) < 0;\n  condition2 = exponent1 == 0xffffffca;\n  if (condition2 || condition1 != overflow) {\n    mantissa1 = 0;\n  }\n  if (condition2 || condition1 != overflow) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (condition2 || condition1 != overflow) {\n    return CONCAT44(temp7,mantissa1);\n  }\n  temp3 = -exponent1;\n  temp8 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = mantissa1 >> (temp8 & 0xff) | temp7 << (0x20 - temp8 & 0xff);\n    exponent1 = (temp7 >> (temp8 & 0xff) & ~((temp7 & 0x80000000) >> (temp8 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((mantissa2 | mantissa1 << (0x20 - temp8 & 0xff) | temp3 << 1) == 0) {\n      exponent1 = exponent1 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,exponent1) & 0x80000000ffffffff;\n  }\n  exponentDiff = temp3 - 0x14;\n  if (exponentDiff != 0 && exponentDiff < 0 == SCARRY4(temp8,0xc)) {\n    exponent1 = 0xc - exponentDiff;\n    temp3 = mantissa1 << (exponent1 & 0xff);\n    mantissa1 = mantissa1 >> (0x20 - exponent1 & 0xff) | temp7 << (exponent1 & 0xff);\n    exponent1 = mantissa1 + -((int)temp3 >> 0x1f);\n    if ((mantissa2 | temp3 << 1) == 0) {\n      exponent1 = exponent1 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(mantissa1,-((int)temp3 >> 0x1f)),exponent1);\n  }\n  temp8 = mantissa1 << (exponent1 + 0x20 & 0xff);\n  mantissa1 = mantissa1 >> (temp3 & 0xff) | temp7 << (exponent1 + 0x20 & 0xff);\n  exponent1 = mantissa1 + -((int)temp8 >> 0x1f);\n  if ((mantissa2 | temp8 << 1) == 0) {\n    exponent1 = exponent1 & ~(temp8 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(mantissa1,-((int)temp8 >> 0x1f)),exponent1);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "signBit",
                "param_2": "exponentBits",
                "param_3": "mantissaBits1",
                "param_4": "mantissaBits2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "exponentDiff",
                "uVar9": "exponent1",
                "unaff_r5": "exponent2",
                "uVar10": "temp8",
                "uVar11": "mantissa1",
                "uVar12": "mantissaDiff",
                "uVar13": "mantissa2",
                "bVar14": "condition1",
                "bVar15": "condition2",
                "bVar16": "overflow",
                "uVar17": "result"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "extract_and_combine_bits_0800088a",
            "code": "\nulonglong extractAndCombineBits_0800088a(uint source1,uint source2,uint source3,uint source4)\n\n{\n  uint bitShifted1;\n  uint temp1;\n  uint bitShifted2;\n  uint temp2;\n  uint bitMask;\n  bool isZero;\n  \n  bitShifted2 = bitMask & source4 >> 0x14;\n  temp2 = source2;\n  if (temp1 != bitMask || bitShifted2 != bitMask) {\n    if (temp1 == bitMask) {\n      if (((source1 | source2 << 0xc) == 0) && (source1 = source3, temp2 = source4, bitShifted2 != bitMask)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((source2 ^ source4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bitShifted2 == bitMask) {\n      source1 = source3;\n      temp2 = source4;\n      if ((source3 | source4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((source2 ^ source4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (source1 | source2 << 1) == 0;\n      if (!isZero) {\n        isZero = (source3 | source4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (temp1 == 0) {\n          temp2 = source2 & 0x80000000;\n          do {\n            bitShifted1 = source1 & 0x80000000;\n            source1 = source1 << 1;\n            source2 = source2 * 2 + (uint)(bitShifted1 != 0);\n          } while ((source2 & 0x100000) == 0);\n          source2 = source2 | temp2;\n          if (bitShifted2 != 0) {\n            return CONCAT44(source2,source1);\n          }\n        }\n        do {\n          temp2 = source3 & 0x80000000;\n          source3 = source3 << 1;\n          source4 = source4 * 2 + (uint)(temp2 != 0);\n        } while ((source4 & 0x100000) == 0);\n        return CONCAT44(source2,source1);\n      }\n      if ((source1 | source2 << 1) != 0) goto LAB_080006fc;\n      if ((source3 | source4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(temp2,source1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "extract_and_combine_bits_0800088a",
                "param_1": "source1",
                "param_2": "source2",
                "param_3": "source3",
                "param_4": "source4",
                "uVar1": "bitShifted1",
                "unaff_r4": "temp1",
                "uVar2": "bitShifted2",
                "uVar3": "temp2",
                "in_r12": "bitMask",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ec": {
            "entrypoint": "0x080008ec",
            "current_name": "check_parameters_080008ec",
            "code": "\nuint check_parameters_080008ec(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLess;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (param_1 | param_2 << 1) == 0;\n  if (isZero) {\n    isZero = (param_3 | param_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = param_2 == param_4;\n  }\n  if (isZero) {\n    isZero = param_1 == param_3;\n  }\n  if (!isZero) {\n    result = param_2 ^ param_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = param_2 == param_4;\n    }\n    isLess = -1 < (int)result && param_4 <= param_2;\n    if (isZero) {\n      isLess = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!isLess) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008ec": "check_parameters_080008ec",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLess"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_parameters_080008f4",
            "code": "\nuint check_parameters_080008f4(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint x;\n  bool is_zero;\n  bool is_ordered;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (param_1 | param_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (param_3 | param_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = param_2 == param_4;\n  }\n  if (is_zero) {\n    is_zero = param_1 == param_3;\n  }\n  if (!is_zero) {\n    x = param_2 ^ param_4;\n    is_zero = x == 0;\n    if (-1 < (int)x) {\n      is_zero = param_2 == param_4;\n    }\n    is_ordered = -1 < (int)x && param_4 <= param_2;\n    if (is_zero) {\n      is_ordered = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!is_ordered) {\n      param_4 = not_d;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_parameters_080008f4",
                "uVar1": "x",
                "bVar2": "is_zero",
                "bVar3": "is_ordered",
                "~param_4": "not_d"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_parameters_080008fc",
            "code": "\nuint check_parameters_080008fc(uint input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less_or_equal;\n  \n  if (((int)(input_param_2 << 1) >> 0x15 == -1 || (int)(input_param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_param_2 << 1) >> 0x15 == -1 && ((input_param_1 | input_param_2 << 0xc) != 0)) ||\n      (((int)(input_param_4 << 1) >> 0x15 == -1 && ((input_param_3 | input_param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (input_param_1 | input_param_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (input_param_3 | input_param_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = input_param_2 == input_param_4;\n  }\n  if (is_zero) {\n    is_zero = input_param_1 == input_param_3;\n  }\n  if (!is_zero) {\n    result = input_param_2 ^ input_param_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = input_param_2 == input_param_4;\n    }\n    is_less_or_equal = -1 < (int)result && input_param_4 <= input_param_2;\n    if (is_zero) {\n      is_less_or_equal = input_param_3 <= input_param_1;\n    }\n    input_param_4 = (int)input_param_4 >> 0x1f;\n    if (!is_less_or_equal) {\n      input_param_4 = ~input_param_4;\n    }\n    return input_param_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less_or_equal"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_and_assign_08000978",
            "code": "\nvoid compareAndAssign_08000978(undefined4 result,undefined4 source,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,result,source);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_and_assign_08000978",
                "param_1": "result",
                "param_2": "source",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "convert_float_to_undefined_08000988",
            "code": "\nundefined4 convertFloatToUndefined_08000988(undefined4 inputFloat)\n\n{\n  performUndefinedConversion();\n  return inputFloat;\n}\n\n",
            "renaming": {
                "FUN_08000988": "convert_float_to_undefined_08000988",
                "param_1": "inputFloat",
                "__nedf2": "performUndefinedConversion"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmple",
                "__aeabi_dcmplt"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "is_comparison_equal_08000998",
            "code": "\nbool is_comparison_equal_08000998(void)\n\n{\n  char result;\n  \n  __aeabi_cdcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "is_comparison_equal_08000998",
                "in_ZR": "result"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "is_null_character_080009ac",
            "code": "\nbool is_null_character_080009ac(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "is_null_character_080009ac",
                "in_CY": "input_character"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_cdcmpeq_result_080009c0",
            "code": "\nbool check_cdcmpeq_result_080009c0(void)\n\n{\n  undefined zero_result;\n  undefined carry_result;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)carry_result || (bool)zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_cdcmpeq_result_080009c0",
                "in_ZR": "zero_result",
                "in_CY": "carry_result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_comparison_true_080009d4",
            "code": "\nbool isComparisonTrue_080009d4(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_comparison_true_080009d4",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_null_character_080009e8",
            "code": "\nbool is_null_character_080009e8(void)\n\n{\n  char character;\n  \n  __aeabi_cdrcmple();\n  return character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_null_character_080009e8",
                "in_CY": "character"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_float_bits_080009fc",
            "code": "\nuint calculate_float_bits_080009fc(uint float_value,uint bit_pattern)\n\n{\n  uint result;\n  uint shifted_bits;\n  uint adjusted_bits;\n  uint temp;\n  bool is_zero;\n  bool is_less_than_threshold;\n  \n  shifted_bits = bit_pattern * 2;\n  is_less_than_threshold = shifted_bits < 0x70000000;\n  adjusted_bits = shifted_bits + 0x90000000;\n  result = adjusted_bits;\n  if (!is_less_than_threshold) {\n    temp = shifted_bits + 0x8fe00000;\n    result = temp;\n  }\n  is_zero = result == 0;\n  if (!is_less_than_threshold && adjusted_bits >= 0x200000) {\n    is_zero = temp == 0x1fc00000;\n  }\n  if (((is_less_than_threshold || adjusted_bits < 0x200000) || 0x1fc00000 < temp) || is_zero) {\n    if ((bit_pattern & 0x40000000) != 0) {\n      if (((int)shifted_bits >> 0x15 == -1) && ((float_value | bit_pattern << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return bit_pattern & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(shifted_bits + 0x92e00000) < 0 != SCARRY4(adjusted_bits,0x2e00000)) {\n      return bit_pattern & 0x80000000;\n    }\n    shifted_bits = 0x18 - (shifted_bits + 0x92e00000 >> 0x15);\n    result = float_value >> (shifted_bits & 0xff);\n    if (float_value << (0x20 - shifted_bits & 0xff) != 0) {\n      result = result | 1;\n    }\n    adjusted_bits = bit_pattern & 0x1fffff | 0x100000;\n    float_value = result | adjusted_bits << (0x20 - shifted_bits & 0xff);\n    adjusted_bits = (adjusted_bits >> (shifted_bits & 0xff)) << 1;\n  }\n  result = (bit_pattern & 0x80000000 | float_value >> 0x1d) + adjusted_bits * 4 + (uint)(0x7fffffff < float_value * 8);\n  if (float_value * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_float_bits_080009fc",
                "param_1": "float_value",
                "param_2": "bit_pattern",
                "uVar1": "result",
                "uVar2": "shifted_bits",
                "uVar3": "adjusted_bits",
                "in_r12": "temp",
                "bVar4": "is_zero",
                "bVar5": "is_less_than_threshold"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a9c": {
            "entrypoint": "0x08000a9c",
            "current_name": "convert_to_negative_float_08000a9c",
            "code": "\nvoid convertToNegativeFloat_08000a9c(uint inputFloat)\n\n{\n  __addsf3(inputFloat ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a9c": "convert_to_negative_float_08000a9c",
                "param_1": "inputFloat"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_shifted_value_08000aa4",
            "code": "\nuint calculate_shifted_value_08000aa4(uint input_value,uint shift_amount,undefined4 param_3,uint param_4)\n\n{\n  int shifted_value_byte;\n  int shifted_value_byte2;\n  uint temp_value;\n  uint temp_value2;\n  uint result;\n  uint shift_count;\n  uint difference;\n  bool is_valid;\n  \n  temp_value = shift_amount ^ 0x80000000;\n  result = input_value << 1;\n  is_valid = result == 0;\n  if (!is_valid) {\n    param_4 = shift_amount << 1;\n    is_valid = param_4 == 0;\n  }\n  if (!is_valid) {\n    is_valid = result == param_4;\n  }\n  shifted_value_byte = (int)result >> 0x18;\n  if (!is_valid) {\n    is_valid = shifted_value_byte == -1;\n  }\n  if (!is_valid) {\n    is_valid = (int)param_4 >> 0x18 == -1;\n  }\n  if (is_valid) {\n    shifted_value_byte2 = (int)(shift_amount << 1) >> 0x18;\n    if (shifted_value_byte == -1 || shifted_value_byte2 == -1) {\n      result = temp_value;\n      if (shifted_value_byte == -1) {\n        result = input_value;\n      }\n      if (shifted_value_byte != -1 || shifted_value_byte2 != -1) {\n        temp_value = result;\n      }\n      is_valid = (result & 0x7fffff) == 0;\n      if (is_valid) {\n        is_valid = (temp_value & 0x7fffff) == 0;\n      }\n      if (is_valid) {\n        is_valid = result == temp_value;\n      }\n      if (!is_valid) {\n        result = result | 0x400000;\n      }\n      return result;\n    }\n    if (((input_value ^ temp_value) & 0x7fffffff) != 0) {\n      if (result == 0) {\n        input_value = temp_value;\n      }\n      return input_value;\n    }\n    if (input_value != temp_value) {\n      return 0;\n    }\n    if ((result & 0xff000000) == 0) {\n      temp_value = input_value << 1;\n      if ((input_value & 0x80000000) != 0) {\n        temp_value = temp_value | 0x80000000;\n      }\n      return temp_value;\n    }\n    if (result < 0xfe000000) {\n      return input_value + 0x800000;\n    }\n    input_value = input_value & 0x80000000;\nLAB_08000bde:\n    return input_value | 0x7f800000;\n  }\n  result = result >> 0x18;\n  param_4 = param_4 >> 0x18;\n  difference = param_4 - result;\n  is_valid = difference != 0;\n  shift_count = result;\n  if (is_valid && result <= param_4) {\n    shift_count = result + difference;\n  }\n  if (is_valid && result <= param_4) {\n    temp_value = temp_value ^ input_value;\n  }\n  if (is_valid && result <= param_4) {\n    input_value = input_value ^ temp_value;\n  }\n  if (is_valid && result <= param_4) {\n    temp_value = temp_value ^ input_value;\n  }\n  if (param_4 < result) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_value;\n  }\n  result = input_value & 0xffffff | 0x800000;\n  if ((input_value & 0x80000000) != 0) {\n    result = -result;\n  }\n  temp_value2 = temp_value & 0xffffff | 0x800000;\n  if ((temp_value & 0x80000000) != 0) {\n    temp_value2 = -temp_value2;\n  }\n  if (shift_count == difference) {\n    temp_value2 = temp_value2 ^ 0x800000;\n    if (shift_count == 0) {\n      result = result ^ 0x800000;\n      shift_count = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  result = result + ((int)temp_value2 >> (difference & 0xff));\n  temp_value2 = temp_value2 << (0x20 - difference & 0xff);\n  input_value = result & 0x80000000;\n  if ((int)result < 0) {\n    is_valid = temp_value2 != 0;\n    temp_value2 = -temp_value2;\n    result = -result - (uint)is_valid;\n  }\n  if (result < 0x800000) {\n    temp_value = temp_value2 & 0x80000000;\n    temp_value2 = temp_value2 << 1;\n    result = result * 2 + (uint)(temp_value != 0);\n    temp_value = shift_count - 2;\n    if ((result & 0x800000) == 0) {\n      difference = LZCOUNT(result) - 8;\n      result = result << (difference & 0xff);\n      if ((int)temp_value < (int)difference) {\n        result = result >> (-(temp_value - difference) & 0xff);\n      }\n      else {\n        result = result + (temp_value - difference) * 0x800000;\n      }\n      return result | input_value;\n    }\n  }\n  else {\n    temp_value = shift_count - 1;\n    if (0xffffff < result) {\n      temp_value = result & 1;\n      result = result >> 1;\n      temp_value2 = (uint)(temp_value != 0) << 0x1f | temp_value2 >> 1;\n      temp_value = shift_count;\n      if (0xfd < shift_count) goto LAB_08000bde;\n    }\n  }\n  result = result + temp_value * 0x800000 + (uint)(0x7fffffff < temp_value2);\n  if (temp_value2 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result | input_value;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_shifted_value_08000aa4",
                "param_1": "input_value",
                "param_2": "shift_amount",
                "iVar1": "shifted_value_byte",
                "iVar2": "shifted_value_byte2",
                "uVar3": "temp_value",
                "uVar4": "temp_value2",
                "uVar5": "result",
                "uVar6": "shift_count",
                "uVar7": "difference",
                "bVar8": "is_valid"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_float_08000aa8",
            "code": "\nuint calculateFloat_08000aa8(uint num1,uint num2,undefined4 param3,uint param4)\n\n{\n  int shiftedNum1;\n  int shiftedNum2;\n  uint mantissa1;\n  uint mantissa2;\n  uint shiftCount;\n  uint difference;\n  bool isZero;\n  \n  mantissa2 = num1 << 1;\n  isZero = mantissa2 == 0;\n  if (!isZero) {\n    param4 = num2 << 1;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = mantissa2 == param4;\n  }\n  shiftedNum1 = (int)mantissa2 >> 0x18;\n  if (!isZero) {\n    isZero = shiftedNum1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)param4 >> 0x18 == -1;\n  }\n  if (isZero) {\n    shiftedNum2 = (int)(num2 << 1) >> 0x18;\n    if (shiftedNum1 == -1 || shiftedNum2 == -1) {\n      mantissa2 = num2;\n      if (shiftedNum1 == -1) {\n        mantissa2 = num1;\n      }\n      if (shiftedNum1 != -1 || shiftedNum2 != -1) {\n        num2 = mantissa2;\n      }\n      isZero = (mantissa2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (num2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = mantissa2 == num2;\n      }\n      if (!isZero) {\n        mantissa2 = mantissa2 | 0x400000;\n      }\n      return mantissa2;\n    }\n    if (((num1 ^ num2) & 0x7fffffff) != 0) {\n      if (mantissa2 == 0) {\n        num1 = num2;\n      }\n      return num1;\n    }\n    if (num1 != num2) {\n      return 0;\n    }\n    if ((mantissa2 & 0xff000000) == 0) {\n      mantissa2 = num1 << 1;\n      if ((num1 & 0x80000000) != 0) {\n        mantissa2 = mantissa2 | 0x80000000;\n      }\n      return mantissa2;\n    }\n    if (mantissa2 < 0xfe000000) {\n      return num1 + 0x800000;\n    }\n    num1 = num1 & 0x80000000;\nLAB_08000bde:\n    return num1 | 0x7f800000;\n  }\n  mantissa2 = mantissa2 >> 0x18;\n  param4 = param4 >> 0x18;\n  difference = param4 - mantissa2;\n  isZero = difference != 0;\n  shiftCount = mantissa2;\n  if (isZero && mantissa2 <= param4) {\n    shiftCount = mantissa2 + difference;\n  }\n  if (isZero && mantissa2 <= param4) {\n    num2 = num2 ^ num1;\n  }\n  if (isZero && mantissa2 <= param4) {\n    num1 = num1 ^ num2;\n  }\n  if (isZero && mantissa2 <= param4) {\n    num2 = num2 ^ num1;\n  }\n  if (param4 < mantissa2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return num1;\n  }\n  mantissa2 = num1 & 0xffffff | 0x800000;\n  if ((num1 & 0x80000000) != 0) {\n    mantissa2 = -mantissa2;\n  }\n  mantissa1 = num2 & 0xffffff | 0x800000;\n  if ((num2 & 0x80000000) != 0) {\n    mantissa1 = -mantissa1;\n  }\n  if (shiftCount == difference) {\n    mantissa1 = mantissa1 ^ 0x800000;\n    if (shiftCount == 0) {\n      mantissa2 = mantissa2 ^ 0x800000;\n      shiftCount = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  mantissa2 = mantissa2 + ((int)mantissa1 >> (difference & 0xff));\n  mantissa1 = mantissa1 << (0x20 - difference & 0xff);\n  num1 = mantissa2 & 0x80000000;\n  if ((int)mantissa2 < 0) {\n    isZero = mantissa1 != 0;\n    mantissa1 = -mantissa1;\n    mantissa2 = -mantissa2 - (uint)isZero;\n  }\n  if (mantissa2 < 0x800000) {\n    difference = mantissa1 & 0x80000000;\n    mantissa1 = mantissa1 << 1;\n    mantissa2 = mantissa2 * 2 + (uint)(difference != 0);\n    difference = shiftCount - 2;\n    if ((mantissa2 & 0x800000) == 0) {\n      shiftCount = LZCOUNT(mantissa2) - 8;\n      mantissa2 = mantissa2 << (shiftCount & 0xff);\n      if ((int)difference < (int)shiftCount) {\n        mantissa2 = mantissa2 >> (-(difference - shiftCount) & 0xff);\n      }\n      else {\n        mantissa2 = mantissa2 + (difference - shiftCount) * 0x800000;\n      }\n      return mantissa2 | num1;\n    }\n  }\n  else {\n    difference = shiftCount - 1;\n    if (0xffffff < mantissa2) {\n      difference = mantissa2 & 1;\n      mantissa2 = mantissa2 >> 1;\n      mantissa1 = (uint)(difference != 0) << 0x1f | mantissa1 >> 1;\n      difference = shiftCount;\n      if (0xfd < shiftCount) goto LAB_08000bde;\n    }\n  }\n  mantissa2 = mantissa2 + difference * 0x800000 + (uint)(0x7fffffff < mantissa1);\n  if (mantissa1 == 0x80000000) {\n    mantissa2 = mantissa2 & 0xfffffffe;\n  }\n  return mantissa2 | num1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_float_08000aa8",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "shiftedNum1",
                "iVar2": "shiftedNum2",
                "uVar3": "mantissa1",
                "uVar4": "mantissa2",
                "uVar5": "shiftCount",
                "uVar6": "difference",
                "bVar7": "isZero"
            },
            "calling": [
                "__aeabi_frsub",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_magic_number_08000c08",
            "code": "\nuint calculate_magic_number_08000c08(uint input_number)\n\n{\n  uint result;\n  uint shifted_input;\n  int magic_constant;\n  uint left_shifted_zero;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  result = LZCOUNT(input_number);\n  shifted_input = result - 8;\n  magic_constant = shifted_input * -0x800000 + 0x4a800000;\n  if (7 < result) {\n    left_shifted_zero = 0 << (shifted_input & 0xff);\n    result = magic_constant + (input_number << (shifted_input & 0xff)) +\n            (0U >> (0x20 - shifted_input & 0xff)) + (uint)(0x7fffffff < left_shifted_zero);\n    if (left_shifted_zero == 0x80000000) {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  shifted_input = input_number << result + 0x18;\n  result = magic_constant + ((input_number >> (0x20 - (result + 0x18) & 0xff)) - ((int)shifted_input >> 0x1f));\n  if ((shifted_input & 0x7fffffff) == 0) {\n    result = result & ~(shifted_input >> 0x1f);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_magic_number_08000c08",
                "param_1": "input_number",
                "uVar1": "result",
                "uVar2": "shifted_input",
                "iVar3": "magic_constant",
                "uVar4": "left_shifted_zero"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "calculate_shifted_value_08000c10",
            "code": "\nuint calculateShiftedValue_08000c10(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  uint signBit;\n  int result;\n  \n  signBit = inputValue & 0x80000000;\n  if ((int)signBit < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(inputValue);\n  shiftAmount = leadingZeros - 8;\n  result = ((signBit | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n    signBit = result + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  signBit = result + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftAmount >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "calculate_shifted_value_08000c10",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "uVar3": "signBit",
                "iVar4": "result",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "mpu6050_update",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c2c": {
            "entrypoint": "0x08000c2c",
            "current_name": "calculate_sum_08000c2c",
            "code": "\nuint calculate_sum_08000c2c(uint num1,uint num2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint shift;\n  int constant;\n  \n  if ((num1 | num2) == 0) {\n    return num1;\n  }\n  result1 = num1;\n  result2 = num2;\n  if (num2 == 0) {\n    result1 = 0;\n    result2 = num1;\n  }\n  constant = 0x5b000000;\n  if (num2 == 0) {\n    constant = 0x4b000000;\n  }\n  count = leading_zero_count(result2);\n  shift = count - 8;\n  constant = constant + -0x800000 + shift * -0x800000;\n  if (count < 8) {\n    shift = result2 << count + 0x18;\n    result2 = constant + ((result2 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((result1 | shift << 1) == 0) {\n      result2 = result2 & ~(shift >> 0x1f);\n    }\n    return result2;\n  }\n  count = result1 << (shift & 0xff);\n  result2 = constant + (result2 << (shift & 0xff)) +\n          (result1 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    result2 = result2 & 0xfffffffe;\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_08000c2c": "calculate_sum_08000c2c",
                "param_1": "num1",
                "param_2": "num2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "shift",
                "iVar5": "constant",
                "LZCOUNT": "leading_zero_count"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_08000c3c",
            "code": "\nuint calculate_08000c3c(uint x,uint y)\n\n{\n  uint result1;\n  uint result2;\n  uint shift_amount;\n  uint temp;\n  uint sign_bit;\n  int intermediate_value;\n  bool is_x_nonzero;\n  \n  if ((x | y) == 0) {\n    return x;\n  }\n  sign_bit = y & 0x80000000;\n  if ((int)sign_bit < 0) {\n    is_x_nonzero = x != 0;\n    x = -x;\n    y = -y - (uint)is_x_nonzero;\n  }\n  result2 = x;\n  result1 = y;\n  if (y == 0) {\n    result2 = 0;\n    result1 = x;\n  }\n  sign_bit = sign_bit | 0x5b000000;\n  if (y == 0) {\n    sign_bit = sign_bit + 0xf0000000;\n  }\n  shift_amount = LZCOUNT(result1);\n  temp = shift_amount - 8;\n  intermediate_value = (sign_bit - 0x800000) + temp * -0x800000;\n  if (shift_amount < 8) {\n    temp = result1 << shift_amount + 0x18;\n    sign_bit = intermediate_value + ((result1 >> (0x20 - (shift_amount + 0x18) & 0xff)) - ((int)temp >> 0x1f));\n    if ((result2 | temp << 1) == 0) {\n      sign_bit = sign_bit & ~(temp >> 0x1f);\n    }\n    return sign_bit;\n  }\n  shift_amount = result2 << (temp & 0xff);\n  sign_bit = intermediate_value + (result1 << (temp & 0xff)) +\n          (result2 >> (0x20 - temp & 0xff)) + (uint)(0x7fffffff < shift_amount);\n  if (shift_amount == 0x80000000) {\n    sign_bit = sign_bit & 0xfffffffe;\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_08000c3c",
                "param_1": "x",
                "param_2": "y",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "shift_amount",
                "uVar4": "temp",
                "uVar5": "sign_bit",
                "iVar6": "intermediate_value",
                "bVar7": "is_x_nonzero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculateFloatingPoint_08000cb8(uint input1,uint input2,undefined4 constant,uint constant2)\n\n{\n  longlong product;\n  uint result;\n  uint shift1;\n  int shiftedSum;\n  int normalizedShift;\n  uint normalizedProduct;\n  int normalizedDiff;\n  uint normalizedResult;\n  bool isZero;\n  bool isNegative;\n  \n  shift1 = input1 >> 0x17 & 0xff;\n  isZero = shift1 == 0;\n  if (!isZero) {\n    constant2 = input2 >> 0x17 & 0xff;\n    isZero = constant2 == 0;\n  }\n  if (!isZero) {\n    isZero = shift1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = constant2 == 0xff;\n  }\n  if (isZero) {\n    constant2 = input2 >> 0x17 & 0xff;\n    if (shift1 == 0xff || constant2 == 0xff) {\n      isZero = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZero = input2 == 0;\n        result = input1;\n      }\n      if (!isZero) {\n        isZero = input2 == 0x80000000;\n      }\n      normalizedResult = result;\n      if (((isZero) || ((shift1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((constant2 == 0xff && (normalizedResult = input2, (input2 & 0x7fffff) != 0)))) {\n        return normalizedResult | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e08;\n    }\n    isZero = (input1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZero = shift1 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input1 = input1 << 1;\n        isZero = (input1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      shift1 = shift1 - 1;\n    }\n    input1 = input1 | result;\n    isZero = constant2 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input2 = input2 << 1;\n        isZero = (input2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      constant2 = constant2 - 1;\n    }\n    input2 = input2 | result;\n  }\n  shiftedSum = shift1 + constant2;\n  normalizedResult = input1 ^ input2;\n  shift1 = input1 << 9;\n  isZero = shift1 == 0;\n  if (!isZero) {\n    input2 = input2 << 9;\n    isZero = input2 == 0;\n  }\n  if (isZero) {\n    if (shift1 == 0) {\n      input2 = input2 << 9;\n    }\n    result = normalizedResult & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    isNegative = SBORROW4(shiftedSum,0x7f);\n    normalizedShift = shiftedSum + -0x7f;\n    isZero = normalizedShift == 0;\n    normalizedDiff = normalizedShift;\n    if (!isZero && 0x7e < shiftedSum) {\n      isNegative = SBORROW4(0xff,normalizedShift);\n      normalizedDiff = 0xff - normalizedShift;\n      isZero = normalizedShift == 0xff;\n    }\n    if (!isZero && normalizedDiff < 0 == isNegative) {\n      result = result | normalizedShift * 0x800000;\n    }\n    if (!isZero && normalizedDiff < 0 == isNegative) {\n      return result;\n    }\n    result = result | 0x800000;\n    normalizedProduct = 0;\n    isNegative = SBORROW4(normalizedShift,1);\n    normalizedResult = shiftedSum - 0x80;\n    isZero = normalizedResult == 0;\n    shift1 = normalizedResult;\n  }\n  else {\n    product = (ulonglong)(shift1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    normalizedProduct = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | normalizedProduct >> 0x1f;\n      normalizedProduct = normalizedProduct << 1;\n    }\n    result = normalizedResult & 0x80000000 | result;\n    normalizedResult = (shiftedSum + -0x7f) - (uint)isZero;\n    isNegative = SBORROW4(normalizedResult,0xfd);\n    isZero = normalizedResult == 0xfd;\n    shift1 = normalizedResult - 0xfd;\n    if (normalizedResult < 0xfe) {\n      result = result + normalizedResult * 0x800000 + (uint)(0x7fffffff < normalizedProduct);\n      if (normalizedProduct == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)shift1 < 0 != isNegative) {\n    isZero = (int)(normalizedResult + 0x19) < 0;\n    if (normalizedResult == 0xffffffe7 || isZero != SCARRY4(normalizedResult,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (normalizedResult != 0xffffffe7 && isZero == SCARRY4(normalizedResult,0x19)) {\n      shift1 = (result << 1) >> (-normalizedResult & 0xff);\n      normalizedResult = result << (normalizedResult + 0x20 & 0xff);\n      shift1 = ((uint)((result & 0x80000000) != 0) << 0x1f | shift1 >> 1) + (uint)((byte)shift1 & 1);\n      if ((normalizedProduct | normalizedResult << 1) == 0) {\n        shift1 = shift1 & ~(normalizedResult >> 0x1f);\n      }\n      return shift1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "constant",
                "param_4": "constant2",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "shift1",
                "iVar4": "shiftedSum",
                "iVar5": "normalizedShift",
                "uVar6": "normalizedProduct",
                "iVar7": "normalizedDiff",
                "uVar8": "normalizedResult",
                "bVar9": "isZero",
                "bVar10": "isNegative"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "floating_point_conversion_08000e20",
            "code": "\nuint floatingPointConversion_08000e20(uint number1,uint number2,undefined4 parameter3,uint parameter4)\n\n{\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  uint result;\n  bool isZero;\n  bool isNegative;\n  bool isOverflow;\n  \n  temp2 = number1 >> 0x17 & 0xff;\n  isZero = temp2 == 0;\n  if (!isZero) {\n    parameter4 = number2 >> 0x17 & 0xff;\n    isZero = parameter4 == 0;\n  }\n  if (!isZero) {\n    isZero = temp2 == 0xff;\n  }\n  if (!isZero) {\n    isZero = parameter4 == 0xff;\n  }\n  if (isZero) {\n    parameter4 = number2 >> 0x17 & 0xff;\n    result = number1;\n    if (temp2 == 0xff) {\n      if (((number1 & 0x7fffff) != 0) || (result = number2, parameter4 == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (parameter4 == 0xff) {\n        result = number2;\n        if ((number2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (number1 ^ number2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      isZero = (number1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (number2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = temp2 == 0;\n        result = number1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            number1 = number1 << 1;\n            isZero = (number1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          temp2 = temp2 - 1;\n        }\n        number1 = number1 | result;\n        isZero = parameter4 == 0;\n        result = number2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            number2 = number2 << 1;\n            isZero = (number2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          parameter4 = parameter4 - 1;\n        }\n        number2 = number2 | result;\n        goto LAB_08000e38;\n      }\n      if ((number1 & 0x7fffffff) == 0) {\n        if ((number2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    number1 = number1 ^ number2;\n  }\n  else {\nLAB_08000e38:\n    temp3 = temp2 - parameter4;\n    if (number2 << 9 == 0) {\n      number1 = (number1 ^ number2) & 0x80000000 | number1 & 0x7fffff;\n      isOverflow = subtractCarry(temp3,0x7f);\n      temp5 = temp3 + 0x7f;\n      isZero = temp5 < 0;\n      isNegative = temp5 == 0;\n      if (!isNegative && isZero == isOverflow) {\n        isOverflow = subtractBorrow(0xff,temp5);\n        isZero = 0xff - temp5 < 0;\n        isNegative = temp5 == 0xff;\n      }\n      if (!isNegative && isZero == isOverflow) {\n        number1 = number1 | temp5 * 0x800000;\n      }\n      if (!isNegative && isZero == isOverflow) {\n        return number1;\n      }\n      number1 = number1 | 0x800000;\n      temp2 = 0;\n      isNegative = subtractBorrow(temp5,1);\n      temp4 = temp3 + 0x7e;\n      isZero = temp4 == 0;\n      result = temp4;\n    }\n    else {\n      temp1 = (number2 << 9) >> 4 | 0x10000000;\n      temp2 = (number1 << 9) >> 4 | 0x10000000;\n      number1 = (number1 ^ number2) & 0x80000000;\n      isZero = temp1 <= temp2;\n      if (!isZero) {\n        temp2 = temp2 << 1;\n      }\n      temp4 = temp3 + 0x7d + (uint)isZero;\n      result = 0x800000;\n      do {\n        if (temp1 <= temp2) {\n          temp2 = temp2 - temp1;\n          number1 = number1 | result;\n        }\n        isZero = temp1 >> 1 <= temp2;\n        if (isZero) {\n          temp2 = temp2 - (temp1 >> 1);\n        }\n        if (isZero) {\n          number1 = number1 | result >> 1;\n        }\n        isZero = temp1 >> 2 <= temp2;\n        if (isZero) {\n          temp2 = temp2 - (temp1 >> 2);\n        }\n        if (isZero) {\n          number1 = number1 | result >> 2;\n        }\n        isZero = temp1 >> 3 <= temp2;\n        if (isZero) {\n          temp2 = temp2 - (temp1 >> 3);\n        }\n        if (isZero) {\n          number1 = number1 | result >> 3;\n        }\n        temp2 = temp2 * 0x10;\n        isZero = temp2 == 0;\n        if (!isZero) {\n          result = result >> 4;\n          isZero = result == 0;\n        }\n      } while (!isZero);\n      isNegative = subtractBorrow(temp4,0xfd);\n      isZero = temp4 == 0xfd;\n      result = temp4 - 0xfd;\n      if (temp4 < 0xfe) {\n        number1 = number1 + temp4 * 0x800000 + (uint)(temp1 <= temp2);\n        if (temp2 - temp1 == 0) {\n          number1 = number1 & 0xfffffffe;\n        }\n        return number1;\n      }\n    }\n    if (isZero || (int)result < 0 != isNegative) {\n      isZero = (int)(temp4 + 0x19) < 0;\n      if (temp4 == 0xffffffe7 || isZero != subtractCarry(temp4,0x19)) {\n        number1 = number1 & 0x80000000;\n      }\n      if (temp4 == 0xffffffe7 || isZero != subtractCarry(temp4,0x19)) {\n        return number1;\n      }\n      result = (number1 << 1) >> (-temp4 & 0xff);\n      temp4 = number1 << (temp4 + 0x20 & 0xff);\n      result = ((uint)((number1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((temp2 | temp4 << 1) == 0) {\n        result = result & ~(temp4 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return number1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "floating_point_conversion_08000e20",
                "param_1": "number1",
                "param_2": "number2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "result",
                "bVar7": "isZero",
                "bVar8": "isNegative",
                "bVar9": "isOverflow",
                "SCARRY4": "subtractCarry",
                "SBORROW4": "subtractBorrow"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f58": {
            "entrypoint": "0x08000f58",
            "current_name": "calculate_checksum_08000f58",
            "code": "\nuint calculate_checksum_08000f58(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint doubled_input_1;\n  uint doubled_input_2;\n  uint combined_inputs;\n  bool is_zero;\n  \n  doubled_input_1 = input_1 * 2;\n  doubled_input_2 = input_2 * 2;\n  if (((int)doubled_input_1 >> 0x18 == -1 || (int)doubled_input_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_inputs = doubled_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_inputs == 0;\n  if (!is_zero) {\n    combined_inputs = input_1 ^ input_2;\n    is_zero = combined_inputs == 0;\n  }\n  is_negative = -1 < (int)combined_inputs;\n  if (is_negative) {\n    input_1 = doubled_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && doubled_input_2 <= doubled_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || doubled_input_2 > doubled_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f58": "calculate_checksum_08000f58",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "combined_inputs",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f60": {
            "entrypoint": "0x08000f60",
            "current_name": "check_overflow_08000f60",
            "code": "\nuint check_overflow_08000f60(uint input_param_1,uint input_param_2)\n\n{\n  bool is_negative;\n  uint param_1_times_2;\n  uint param_2_times_2;\n  uint param_1_or_param_2_bitwise_and;\n  bool is_zero;\n  \n  param_1_times_2 = input_param_1 * 2;\n  param_2_times_2 = input_param_2 * 2;\n  if (((int)param_1_times_2 >> 0x18 == -1 || (int)param_2_times_2 >> 0x18 == -1) &&\n     ((((int)param_1_times_2 >> 0x18 == -1 && ((input_param_1 & 0x7fffff) != 0)) ||\n      (((int)param_2_times_2 >> 0x18 == -1 && ((input_param_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  param_1_or_param_2_bitwise_and = param_1_times_2 | input_param_2 & 0x7fffffff;\n  is_zero = param_1_or_param_2_bitwise_and == 0;\n  if (!is_zero) {\n    param_1_or_param_2_bitwise_and = input_param_1 ^ input_param_2;\n    is_zero = param_1_or_param_2_bitwise_and == 0;\n  }\n  is_negative = -1 < (int)param_1_or_param_2_bitwise_and;\n  if (is_negative) {\n    input_param_1 = param_1_times_2 + input_param_2 * -2;\n    is_zero = input_param_1 == 0;\n  }\n  if ((is_negative && param_2_times_2 <= param_1_times_2) && !is_zero) {\n    input_param_1 = (int)input_param_2 >> 0x1f;\n  }\n  if (!is_negative || param_2_times_2 > param_1_times_2) {\n    input_param_1 = ~((int)input_param_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_param_1 = input_param_1 | 1;\n  }\n  return input_param_1;\n}\n\n",
            "renaming": {
                "FUN_08000f60": "check_overflow_08000f60",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "uVar2": "param_1_times_2",
                "uVar3": "param_2_times_2",
                "uVar4": "param_1_or_param_2_bitwise_and",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_integer_overflow_08000f68",
            "code": "\nuint check_integer_overflow_08000f68(uint number_1,uint number_2)\n\n{\n  bool is_negative;\n  uint doubled_number_1;\n  uint doubled_number_2;\n  uint combined_numbers;\n  bool is_zero;\n  \n  doubled_number_1 = number_1 * 2;\n  doubled_number_2 = number_2 * 2;\n  if (((int)doubled_number_1 >> 0x18 == -1 || (int)doubled_number_2 >> 0x18 == -1) &&\n     ((((int)doubled_number_1 >> 0x18 == -1 && ((number_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_number_2 >> 0x18 == -1 && ((number_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_numbers = doubled_number_1 | number_2 & 0x7fffffff;\n  is_zero = combined_numbers == 0;\n  if (!is_zero) {\n    combined_numbers = number_1 ^ number_2;\n    is_zero = combined_numbers == 0;\n  }\n  is_negative = -1 < (int)combined_numbers;\n  if (is_negative) {\n    number_1 = doubled_number_1 + number_2 * -2;\n    is_zero = number_1 == 0;\n  }\n  if ((is_negative && doubled_number_2 <= doubled_number_1) && !is_zero) {\n    number_1 = (int)number_2 >> 0x1f;\n  }\n  if (!is_negative || doubled_number_2 > doubled_number_1) {\n    number_1 = ~((int)number_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    number_1 = number_1 | 1;\n  }\n  return number_1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_integer_overflow_08000f68",
                "param_1": "number_1",
                "param_2": "number_2",
                "uVar2": "doubled_number_1",
                "uVar3": "doubled_number_2",
                "uVar4": "combined_numbers",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floats_08000fc8",
            "code": "\nvoid compareFloats_08000fc8(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floats_08000fc8",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_params_08000fd0",
            "code": "\nundefined8 concatenateParams_08000fd0(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_params_08000fd0",
                "param_1": "firstParameter",
                "param_2": "secondParameter"
            },
            "calling": [
                "__aeabi_fcmplt",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmpeq"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fe0": {
            "entrypoint": "0x08000fe0",
            "current_name": "compare_floats_08000fe0",
            "code": "\nbool compare_floats_08000fe0(void)\n\n{\n  char result;\n  \n  __aeabi_cfcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000fe0": "compare_floats_08000fe0",
                "in_ZR": "result"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "is_null_char_present_08000ff4",
            "code": "\nbool is_null_char_present_08000ff4(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "is_null_char_present_08000ff4",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001008": {
            "entrypoint": "0x08001008",
            "current_name": "compare_and_return_08001008",
            "code": "\nbool compareAndReturn_08001008(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_08001008": "compare_and_return_08001008",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800101c": {
            "entrypoint": "0x0800101c",
            "current_name": "check_float_order_0800101c",
            "code": "\nbool check_float_order_0800101c(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry;\n  \n  compare_float();\n  return !(bool)is_carry || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_0800101c": "check_float_order_0800101c",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry",
                "__aeabi_cfrcmple": "compare_float"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_if_null_termination_08001030",
            "code": "\nbool check_if_null_termination_08001030(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_if_null_termination_08001030",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "validate_and_convert_08001044",
            "code": "\nuint validate_and_convert_08001044(uint input_number)\n\n{\n  uint result;\n  \n  if (((input_number & 0x80000000) != 0) || (input_number << 1 < 0x7f000000)) {\n    return 0;\n  }\n  result = 0x9e - ((input_number << 1) >> 0x18);\n  if (-1 < (int)result) {\n    return (input_number << 8 | 0x80000000) >> (result & 0xff);\n  }\n  if ((result == 0xffffff9f) && ((input_number & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "validate_and_convert_08001044",
                "param_1": "input_number",
                "uVar1": "result"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nvoid * copyMemory_08001084(void *destination,void *source,size_t size)\n\n{\n  undefined *destPointer;\n  undefined4 *destAlign4;\n  undefined4 *destAlign16;\n  undefined *tempDest;\n  undefined4 *srcAlign4;\n  undefined *tempSrc;\n  uint remainingBytes;\n  uint alignmentDiff;\n  bool isRemaining;\n  \n  destAlign16 = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      alignmentDiff = size - 4;\n      destPointer = (undefined *)destination;\n      if (3 < size) {\n        do {\n          tempSrc = (undefined *)source;\n          tempDest = destPointer;\n          isRemaining = alignmentDiff != 0;\n          alignmentDiff = alignmentDiff - 1;\n          *tempDest = *tempSrc;\n          destPointer = tempDest + 1;\n          source = tempSrc + 1;\n        } while (isRemaining);\n        tempDest[1] = tempSrc[1];\n        tempDest[2] = tempSrc[2];\n        tempDest[3] = tempSrc[3];\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      alignmentDiff = 4 - ((uint)destination & 3);\n      size = size - alignmentDiff;\n      destAlign4 = (undefined4 *)destination;\n      srcAlign4 = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcAlign4 = (undefined4 *)((int)source + 1);\n        destAlign4 = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destAlign16 = destAlign4;\n      source = srcAlign4;\n      if ((alignmentDiff & 2) != 0) {\n        source = (void *)((int)srcAlign4 + 2);\n        destAlign16 = (undefined4 *)((int)destAlign4 + 2);\n        *(undefined2 *)destAlign4 = *(undefined2 *)srcAlign4;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *destAlign16 = *source;\n    destAlign16[1] = *(undefined4 *)((int)source + 4);\n    destAlign16[2] = *(undefined4 *)((int)source + 8);\n    destAlign16[3] = *(undefined4 *)((int)source + 0xc);\n    destAlign16[4] = *(undefined4 *)((int)source + 0x10);\n    destAlign16[5] = *(undefined4 *)((int)source + 0x14);\n    destAlign16[6] = *(undefined4 *)((int)source + 0x18);\n    destAlign16[7] = *(undefined4 *)((int)source + 0x1c);\n    destAlign16[8] = *(undefined4 *)((int)source + 0x20);\n    destAlign16[9] = *(undefined4 *)((int)source + 0x24);\n    destAlign16[10] = *(undefined4 *)((int)source + 0x28);\n    destAlign16[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destAlign16[0xc] = *(undefined4 *)((int)source + 0x30);\n    destAlign16[0xd] = *(undefined4 *)((int)source + 0x34);\n    destAlign16[0xe] = *(undefined4 *)((int)source + 0x38);\n    destAlign16[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destAlign16 = destAlign16 + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remainingBytes = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destAlign16 = *source;\n      destAlign16[1] = *(undefined4 *)((int)source + 4);\n      destAlign16[2] = *(undefined4 *)((int)source + 8);\n      destAlign16[3] = *(undefined4 *)((int)source + 0xc);\n      destAlign16 = destAlign16 + 4;\n      source = (void *)((int)source + 0x10);\n      isRemaining = 0xf < remainingBytes;\n      remainingBytes = remainingBytes - 0x10;\n    } while (isRemaining);\n  }\n  alignmentDiff = remainingBytes + 0xc;\n  srcAlign4 = destAlign16;\n  destAlign4 = (undefined4 *)source;\n  if (0xfffffff3 < remainingBytes) {\n    do {\n      source = destAlign4 + 1;\n      *srcAlign4 = *destAlign4;\n      isRemaining = 3 < alignmentDiff;\n      alignmentDiff = alignmentDiff - 4;\n      destAlign16 = srcAlign4 + 1;\n      srcAlign4 = srcAlign4 + 1;\n      destAlign4 = (undefined4 *)source;\n    } while (isRemaining);\n  }\nLAB_08001108:\n  if (alignmentDiff + 4 != 0) {\n    destAlign4 = destAlign16;\n    srcAlign4 = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((alignmentDiff & 1) != 0) {\n      srcAlign4 = (undefined4 *)((int)source + 1);\n      destAlign4 = (undefined4 *)((int)destAlign16 + 1);\n      *(undefined *)destAlign16 = *source;\n    }\n    if ((alignmentDiff + 4 & 2) != 0) {\n      *(undefined2 *)destAlign4 = *(undefined2 *)srcAlign4;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destPointer",
                "puVar2": "destAlign4",
                "puVar3": "destAlign16",
                "puVar4": "tempDest",
                "puVar5": "srcAlign4",
                "puVar6": "tempSrc",
                "uVar7": "remainingBytes",
                "uVar8": "alignmentDiff",
                "bVar9": "isRemaining"
            },
            "calling": [
                "__ssprint_r",
                "_dtoa_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_condition_08001170",
            "code": "\nundefined4 check_condition_08001170(uint value_1,int shifted_value_1,uint value_2,int shifted_value_2)\n\n{\n  if ((((shifted_value_1 << 1) >> 0x15 != -1) || ((value_1 | shifted_value_1 << 0xc) == 0)) &&\n     (((shifted_value_2 << 1) >> 0x15 != -1 || ((value_2 | shifted_value_2 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_condition_08001170",
                "param_1": "value_1",
                "param_2": "shifted_value_1",
                "param_3": "value_2",
                "param_4": "shifted_value_2"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "convert_value_0800119c",
            "code": "\nuint convertValue_0800119c(uint inputValue1,uint negativeFlag)\n\n{\n  uint maxValue;\n  int computedValue1;\n  uint mask;\n  \n  computedValue1 = negativeFlag * 2 + 0x200000;\n  if (negativeFlag * 2 < 0xffe00000) {\n    if (-1 < computedValue1) {\n      return 0;\n    }\n    maxValue = computedValue1 >> 0x15;\n    mask = -maxValue - 0x3e1;\n    if (maxValue < 0xfffffc20 && mask != 0) {\n      maxValue = (negativeFlag << 0xb | 0x80000000 | inputValue1 >> 0x15) >> (mask & 0xff);\n      if ((negativeFlag & 0x80000000) != 0) {\n        maxValue = -maxValue;\n      }\n      return maxValue;\n    }\n  }\n  else if ((inputValue1 | negativeFlag << 0xc) != 0) {\n    return 0;\n  }\n  negativeFlag = negativeFlag & 0x80000000;\n  if (negativeFlag == 0) {\n    negativeFlag = 0x7fffffff;\n  }\n  return negativeFlag;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "convert_value_0800119c",
                "param_1": "inputValue1",
                "param_2": "negativeFlag",
                "uVar1": "maxValue",
                "iVar2": "computedValue1",
                "uVar3": "mask"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "perform_division_or_error_handling_080011ec",
            "code": "\nvoid performDivisionOrErrorHandling_080011ec(int dividend,int divisor,int param_3,int param_4)\n\n{\n  if ((param_4 == 0) && (param_3 == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend,divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "perform_division_or_error_handling_080011ec",
                "param_1": "dividend",
                "param_2": "divisor"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "perform_arithmetic_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 performArithmetic_0800121c(uint input1,uint input2,uint divisor,uint dividend,uint *output)\n\n{\n  code *jumpTable;\n  ulonglong tempResult;\n  uint quotient1;\n  uint quotient2;\n  uint temp;\n  int shiftAmount;\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint *puVar9;\n  uint quotient3;\n  uint divisorHigh;\n  uint dividendHigh;\n  bool carryFlag;\n  undefined8 retVal;\n  \n  if (dividend == 0) {\n    if (input2 < divisor) {\n      shiftAmount = leadingZeroCount(divisor);\n      temp1 = divisor;\n      if (shiftAmount != 0) {\n        temp1 = divisor << shiftAmount;\n        input2 = input1 >> (0x20U - shiftAmount & 0xff) | input2 << shiftAmount;\n        input1 = input1 << shiftAmount;\n      }\n      divisorHigh = temp1 >> 0x10;\n      temp2 = input2 / divisorHigh;\n      quotient3 = temp2 * (temp1 & 0xffff);\n      result = input1 >> 0x10 | (input2 - divisorHigh * temp2) * 0x10000;\n      quotient2 = temp2;\n      if (result <= quotient3 && quotient3 - result != 0) {\n        carryFlag = carryCheck(temp1,result);\n        result = temp1 + result;\n        quotient2 = temp2 - 1;\n        if ((carryFlag == false) && (result <= quotient3 && quotient3 - result != 0)) {\n          quotient2 = temp2 - 2;\n          result = result + temp1;\n        }\n      }\n      quotient1 = (result - quotient3) / divisorHigh;\n      temp = quotient1 * (temp1 & 0xffff);\n      temp2 = input1 & 0xffff | ((result - quotient3) - divisorHigh * quotient1) * 0x10000;\n      result = quotient1;\n      if (temp2 <= temp && temp - temp2 != 0) {\n        carryFlag = carryCheck(temp1,temp2);\n        temp2 = temp1 + temp2;\n        result = quotient1 - 1;\n        if ((carryFlag == false) && (temp2 <= temp && temp - temp2 != 0)) {\n          result = quotient1 - 2;\n          temp2 = temp2 + temp1;\n        }\n      }\n      result = result | quotient2 << 0x10;\n      puVar9 = (uint *)0x0;\n      temp2 = temp2 - temp;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        jumpTable = (code *)software_udf(0xff,0x8001302);\n        retVal = (*jumpTable)();\n        return retVal;\n      }\n      shiftAmount = leadingZeroCount(divisor);\n      if (shiftAmount == 0) {\n        puVar9 = (uint *)0x1;\n        input2 = input2 - divisor;\n        divisorHigh = divisor >> 0x10;\n        quotient1 = divisor & 0xffff;\n        temp1 = divisor;\n      }\n      else {\n        temp1 = divisor << shiftAmount;\n        result = input2 >> (0x20U - shiftAmount & 0xff);\n        divisorHigh = temp1 >> 0x10;\n        quotient3 = result / divisorHigh;\n        quotient1 = temp1 & 0xffff;\n        temp = quotient3 * quotient1;\n        temp2 = input1 >> (0x20U - shiftAmount & 0xff) | input2 << shiftAmount;\n        quotient2 = temp2 >> 0x10 | (result - divisorHigh * quotient3) * 0x10000;\n        input1 = input1 << shiftAmount;\n        result = quotient3;\n        if (quotient2 <= temp && temp - quotient2 != 0) {\n          carryFlag = carryCheck(temp1,quotient2);\n          quotient2 = temp1 + quotient2;\n          result = quotient3 - 1;\n          if ((carryFlag == false) && (quotient2 <= temp && temp - quotient2 != 0)) {\n            result = quotient3 - 2;\n            quotient2 = quotient2 + temp1;\n          }\n        }\n        quotient3 = (quotient2 - temp) / divisorHigh;\n        dividendHigh = quotient3 * quotient1;\n        input2 = temp2 & 0xffff | ((quotient2 - temp) - divisorHigh * quotient3) * 0x10000;\n        quotient2 = quotient3;\n        if (input2 <= dividendHigh && dividendHigh - input2 != 0) {\n          carryFlag = carryCheck(temp1,input2);\n          input2 = temp1 + input2;\n          quotient2 = quotient3 - 1;\n          if ((carryFlag == false) && (input2 <= dividendHigh && dividendHigh - input2 != 0)) {\n            quotient2 = quotient3 - 2;\n            input2 = input2 + temp1;\n          }\n        }\n        input2 = input2 - dividendHigh;\n        puVar9 = (uint *)(quotient2 | result << 0x10);\n      }\n      quotient3 = input2 / divisorHigh;\n      result = quotient1 * quotient3;\n      temp2 = input1 >> 0x10 | (input2 - divisorHigh * quotient3) * 0x10000;\n      quotient2 = quotient3;\n      if (temp2 <= result && result - temp2 != 0) {\n        carryFlag = carryCheck(temp1,temp2);\n        temp2 = temp1 + temp2;\n        quotient2 = quotient3 - 1;\n        if ((carryFlag == false) && (temp2 <= result && result - temp2 != 0)) {\n          quotient2 = quotient3 - 2;\n          temp2 = temp2 + temp1;\n        }\n      }\n      quotient3 = (temp2 - result) / divisorHigh;\n      quotient1 = quotient1 * quotient3;\n      temp2 = input1 & 0xffff | ((temp2 - result) - divisorHigh * quotient3) * 0x10000;\n      result = quotient3;\n      if (temp2 <= quotient1 && quotient1 - temp2 != 0) {\n        carryFlag = carryCheck(temp1,temp2);\n        temp2 = temp1 + temp2;\n        result = quotient3 - 1;\n        if ((carryFlag == false) && (temp2 <= quotient1 && quotient1 - temp2 != 0)) {\n          result = quotient3 - 2;\n          temp2 = temp2 + temp1;\n        }\n      }\n      temp2 = temp2 - quotient1;\n      result = result | quotient2 << 0x10;\n    }\n    if (output != (uint *)0x0) {\n      *output = temp2 >> leadingZeroCount(divisor);\n      output[1] = 0;\n    }\n  }\n  else {\n    puVar9 = output;\n    if (input2 < dividend) {\n      if (output != (uint *)0x0) {\n        *output = input1;\n        output[1] = input2;\n        return 0;\n      }\n      result = 0;\n    }\n    else {\n      shiftAmount = leadingZeroCount(dividend);\n      if (shiftAmount == 0) {\n        if ((dividend < input2) || (divisor <= input1)) {\n          carryFlag = input1 < divisor;\n          input1 = input1 - divisor;\n          input2 = (input2 - dividend) - (uint)carryFlag;\n          result = 1;\n        }\n        else {\n          result = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (output != (uint *)0x0) {\n          *output = input1;\n          output[1] = input2;\n        }\n      }\n      else {\n        temp2 = 0x20 - shiftAmount;\n        quotient1 = divisor >> (temp2 & 0xff) | dividend << shiftAmount;\n        temp1 = input2 >> (temp2 & 0xff);\n        temp = quotient1 >> 0x10;\n        quotient3 = temp1 / temp;\n        divisorHigh = quotient3 * (quotient1 & 0xffff);\n        result = input2 << shiftAmount | input1 >> (temp2 & 0xff);\n        quotient2 = result >> 0x10 | (temp1 - temp * quotient3) * 0x10000;\n        input1 = input1 << shiftAmount;\n        temp1 = quotient3;\n        if (quotient2 <= divisorHigh && divisorHigh - quotient2 != 0) {\n          carryFlag = carryCheck(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          temp1 = quotient3 - 1;\n          if ((carryFlag == false) && (quotient2 <= divisorHigh && divisorHigh - quotient2 != 0)) {\n            temp1 = quotient3 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        quotient3 = (quotient2 - divisorHigh) / temp;\n        dividendHigh = quotient3 * (quotient1 & 0xffff);\n        quotient2 = result & 0xffff | ((quotient2 - divisorHigh) - temp * quotient3) * 0x10000;\n        result = quotient3;\n        if (quotient2 <= dividendHigh && dividendHigh - quotient2 != 0) {\n          carryFlag = carryCheck(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          result = quotient3 - 1;\n          if ((carryFlag == false) && (quotient2 <= dividendHigh && dividendHigh - quotient2 != 0)) {\n            result = quotient3 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        result = result | temp1 << 0x10;\n        tempResult = (ulonglong)result * (ulonglong)(divisor << shiftAmount);\n        if (CONCAT44(quotient2 - dividendHigh,input1) < tempResult) {\n          result = result - 1;\n          tempResult = tempResult - CONCAT44(quotient1,divisor << shiftAmount);\n        }\n        if (output != (uint *)0x0) {\n          temp1 = ((quotient2 - dividendHigh) - (int)(tempResult >> 0x20)) - (uint)(input1 < (uint)tempResult);\n          *output = temp1 << (temp2 & 0xff) | input1 - (uint)tempResult >> shiftAmount;\n          output[1] = temp1 >> shiftAmount;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,result);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "perform_arithmetic_0800121c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "divisor",
                "param_4": "dividend",
                "param_5": "output",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "uVar1": "tempResult",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "uVar4": "temp",
                "iVar5": "shiftAmount",
                "uVar6": "result",
                "uVar7": "temp1",
                "uVar8": "temp2",
                "uVar10": "quotient3",
                "uVar11": "divisorHigh",
                "uVar12": "dividendHigh",
                "bVar13": "carryFlag",
                "uVar14": "retVal",
                "LZCOUNT": "leadingZeroCount",
                "CARRY4": "carryCheck"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "FUNC_080014ec",
            "code": "\nvoid FUNC_080014ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "FUNC_080014ec"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hardware_080014f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nInitializationStatus initializeHardware_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGrouping(3);\n  initializeTick(0xf);\n  initializePeripheral();\n  return Initialization_OK;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hardware_080014f0",
                "HAL_StatusTypeDef": "InitializationStatus",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeripheral",
                "HAL_OK": "Initialization_OK"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_sys_tick_0800151c",
            "code": "\nHAL_StatusTypeDef configureSysTick_0800151c(uint32_t priority)\n\n{\n  uint32_t systickConfigStatus;\n  HAL_StatusTypeDef status;\n  uint32_t priority_local;\n  \n  systickConfigStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (systickConfigStatus == 0) {\n    if (priority < 0x10) {\n      HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n      status = HAL_OK;\n      uwTickPrio = priority;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  else {\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_sys_tick_0800151c",
                "TickPriority": "priority",
                "uVar1": "systickConfigStatus",
                "HVar2": "status",
                "TickPriority_local": "priority_local"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "update_tick_0800157c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTick_0800157c(void)\n\n{\n  currentTick = currentTick + tickFrequency;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "update_tick_0800157c",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_system_tick_080015a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_080015a0(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_system_tick_080015a0",
                "uwTick": "systemTick"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite",
                "_get_ms_tick",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "initialize_priority_group_080015b4",
            "code": "\n\n\nvoid initializePriorityGroup_080015b4(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  uint32_t registerValue;\n  uint32_t temporaryPriorityGroup;\n  \n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (priorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "initialize_priority_group_080015b4",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "temporaryPriorityGroup"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_bits_080015fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getBits_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_bits_080015fc"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "set_interrupt_priority_08001618",
            "code": "\nvoid setInterruptPriority_08001618(interruptNumber_Type interruptNumber,uint32_t interruptPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((interruptPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((interruptPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "set_interrupt_priority_08001618",
                "IRQn": "interruptNumber",
                "priority": "interruptPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "set_priority_0800166c",
            "code": "\nuint32_t setPriority_0800166c(uint32_t priorityGroup,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint groupBits;\n  uint remainingBits;\n  uint32_t localSubPriority;\n  uint32_t localPreemptPriority;\n  uint32_t localPriorityGroup;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  groupBits = priorityGroup & 7;\n  remainingBits = 7 - groupBits;\n  if (3 < remainingBits) {\n    remainingBits = 4;\n  }\n  if (groupBits + 4 < 7) {\n    groupBits = 0;\n  }\n  else {\n    groupBits = groupBits - 3;\n  }\n  return subPriority & ~(-1 << (groupBits & 0xff)) |\n         (~(-1 << (remainingBits & 0xff)) & preemptPriority) << (groupBits & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "set_priority_0800166c",
                "PriorityGroup": "priorityGroup",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "groupBits",
                "uVar2": "remainingBits",
                "SubPriority_local": "localSubPriority",
                "PreemptPriority_local": "localPreemptPriority",
                "PriorityGroup_local": "localPriorityGroup",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_configure_sys_tick_080016d0",
            "code": "\n\n\nuint32_t checkAndConfigureSysTick_080016d0(uint32_t inputTicks)\n\n{\n  bool isWithinRange;\n  uint32_t adjustedTicks;\n  \n  isWithinRange = inputTicks - 1 < 0x1000000;\n  if (isWithinRange) {\n    _DAT_e000e014 = inputTicks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!isWithinRange;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_configure_sys_tick_080016d0",
                "ticks": "inputTicks",
                "bVar1": "isWithinRange",
                "ticks_local": "adjustedTicks"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_priority_group_08001714",
            "code": "\nvoid setPriorityGroup_08001714(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  \n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_priority_group_08001714",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_interrupt_priority_0800172a",
            "code": "\nvoid setInterruptPriority_0800172a(interruptNumber_Type interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint32_t priorityGroup;\n  uint32_t subPriorityLocal;\n  uint32_t preemptPriorityLocal;\n  interruptNumber_Type interruptNumberLocal;\n  uint32_t priorityGrouping;\n  \n  priorityGroup = NVIC_GetPriorityGrouping();\n  priorityGroup = NVIC_EncodePriority(priorityGroup,preemptPriority,subPriority);\n  NVIC_SetPriority(interruptNumber,priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_interrupt_priority_0800172a",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroup",
                "SubPriority_local": "subPriorityLocal",
                "PreemptPriority_local": "preemptPriorityLocal",
                "IRQn_local": "interruptNumberLocal",
                "prioritygroup": "priorityGrouping"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_EncodePriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_sys_tick_08001762",
            "code": "\nuint32_t initializeSysTick_08001762(uint32_t tickInterval)\n\n{\n  uint32_t systickConfigStatus;\n  uint32_t localTicksNumb;\n  \n  systickConfigStatus = SysTick_Config(tickInterval);\n  return systickConfigStatus;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_sys_tick_08001762",
                "TicksNumb": "tickInterval",
                "uVar1": "systickConfigStatus",
                "TicksNumb_local": "localTicksNumb"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_clock_source_0800177c",
            "code": "\n\n\nvoid setClockSource_0800177c(uint32_t source)\n\n{\n  uint32_t localSource;\n  \n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_clock_source_0800177c",
                "CLKSource": "source",
                "CLKSource_local": "localSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "handle_tim_period_elapsed_080017b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimPeriodElapsed_080017b4(void)\n\n{\n  HAL_TIM_PeriodElapsedCallback((timHandle *)0x0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "handle_tim_period_elapsed_080017b4",
                "TIM_HandleTypeDef": "timHandle"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "configure_gpio_080017c4",
            "code": "\n\n\nvoid configureGPIO_080017c4(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  uint bitMask;\n  uint pinMatch;\n  uint mode;\n  GPIO_TypeDef *gpioRegister;\n  int portNumber;\n  gpioConfigTypeDef *localConfig;\n  GPIO_TypeDef *localGpioPort;\n  uint32_t tempRegister;\n  uint32_t *configRegister;\n  uint32_t registerOffset;\n  uint32_t tempVariable;\n  uint32_t ioCurrent;\n  uint32_t ioPosition;\n  uint32_t configuration;\n  uint32_t pinPosition;\n  \n  configuration = 0;\n  pinPosition = 0;\n  do {\n    if (0xf < pinPosition) {\n      return;\n    }\n    bitMask = 1 << (pinPosition & 0xff);\n    pinMatch = gpioConfig->Pin & bitMask;\n    if (pinMatch == bitMask) {\n      mode = gpioConfig->Mode;\n      if (mode == 0x12) {\n        configuration = gpioConfig->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          configuration = gpioConfig->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08001882;\n          if (mode == 1) {\n            configuration = gpioConfig->Speed;\n          }\n        }\n        else if (mode == 3) {\n          configuration = 0;\n        }\n        else if (mode == 0x11) {\n          configuration = gpioConfig->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08001882:\n        if (gpioConfig->Pull == 0) {\n          configuration = 4;\n        }\n        else if (gpioConfig->Pull == 1) {\n          configuration = 8;\n          gpioPort->BSRR = bitMask;\n        }\n        else {\n          configuration = 8;\n          gpioPort->BRR = bitMask;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((mode == 0x10310000) || (mode == 0x10320000)) || (mode == 0x10220000))\n      goto LAB_08001882;\n      if (pinMatch < 0x100) {\n        bitMask = pinPosition << 2;\n        gpioRegister = gpioPort;\n      }\n      else {\n        gpioRegister = (GPIO_TypeDef *)&gpioPort->CRH;\n        bitMask = (pinPosition - 8) * 4;\n      }\n      gpioRegister->CRL = gpioRegister->CRL & ~(0xf << (bitMask & 0xff)) | configuration << (bitMask & 0xff);\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          portNumber = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          portNumber = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          portNumber = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          portNumber = 3;\n        }\n        else {\n          portNumber = 4;\n        }\n        *(uint *)(((pinPosition >> 2) + 2) * 4 + 0x40010000) =\n             portNumber << ((pinPosition & 3) << 2) |\n             ~(0xf << ((pinPosition & 3) << 2)) & *(uint *)(((pinPosition >> 2) + 2) * 4 + 0x40010000);\n        if ((gpioConfig->Mode & 0x10000) == 0) {\n          _DAT_40010400 = ~pinMatch & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = pinMatch | _DAT_40010400;\n        }\n        if ((gpioConfig->Mode & 0x20000) == 0) {\n          _DAT_40010404 = ~pinMatch & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = pinMatch | _DAT_40010404;\n        }\n        if ((gpioConfig->Mode & 0x100000) == 0) {\n          _DAT_40010408 = ~pinMatch & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = pinMatch | _DAT_40010408;\n        }\n        if ((gpioConfig->Mode & 0x200000) == 0) {\n          _DAT_4001040c = ~pinMatch & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = pinMatch | _DAT_4001040c;\n        }\n      }\n    }\n    pinPosition = pinPosition + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "configure_gpio_080017c4",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "uVar1": "bitMask",
                "uVar2": "pinMatch",
                "uVar3": "mode",
                "pGVar4": "gpioRegister",
                "iVar5": "portNumber",
                "GPIO_Init_local": "localConfig",
                "GPIOx_local": "localGpioPort",
                "tmpreg": "tempRegister",
                "configregister": "configRegister",
                "registeroffset": "registerOffset",
                "temp": "tempVariable",
                "iocurrent": "ioCurrent",
                "ioposition": "ioPosition",
                "config": "configuration",
                "position": "pinPosition"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_pin_state_08001a80",
            "code": "\nvoid setPinState_08001a80(GPIO_TypeDef *port,uint16_t pin,pinState state)\n\n{\n  pinState state_local;\n  uint16_t pin_local;\n  GPIO_TypeDef *port_local;\n  \n  if (state == GPIO_PIN_RESET) {\n    port->BSRR = (uint)pin << 0x10;\n  }\n  else {\n    port->BSRR = (uint)pin;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_pin_state_08001a80",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "PinState_local": "state_local",
                "GPIO_Pin_local": "pin_local",
                "GPIOx_local": "port_local"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nHAL_StatusTypeDef initializeI2C_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t pclk1Freq;\n  char isValidFreq;\n  HAL_StatusTypeDef status;\n  uint32_t pclk1;\n  uint trise;\n  bool isZero;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t pclk1Freq;\n  uint32_t frequencyRange;\n  \n  if (i2cHandle == (I2C_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandle);\n    }\n    i2cHandle->State = HAL_I2C_STATE_BUSY;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n      pclk1 = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        pclk1 = 1;\n      }\n      isValidFreq = (char)pclk1;\n      if (1999999 < pclk1Freq) {\n        isValidFreq = '\\0';\n      }\n    }\n    else {\n      pclk1 = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        pclk1 = 1;\n      }\n      isValidFreq = (char)pclk1;\n      if (3999999 < pclk1Freq) {\n        isValidFreq = '\\0';\n      }\n    }\n    if (isValidFreq == '\\0') {\n      trise = pclk1Freq / 1000000;\n      i2cHandle->Instance->CR2 = trise;\n      if (100000 < (i2cHandle->Init).ClockSpeed) {\n        trise = (trise * 300) / 1000;\n      }\n      i2cHandle->Instance->TRISE = trise + 1;\n      if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if ((i2cHandle->Init).DutyCycle == 0) {\n          trise = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 3) + 1 & 0xfff;\n          isZero = trise == 0;\n          if (isZero) {\n            trise = 1;\n          }\n          isValidFreq = (char)trise;\n          if (!isZero) {\n            isValidFreq = '\\0';\n          }\n        }\n        else {\n          trise = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 0x19) + 1 & 0xfff;\n          isZero = trise == 0;\n          if (isZero) {\n            trise = 1;\n          }\n          isValidFreq = (char)trise;\n          if (!isZero) {\n            isValidFreq = '\\0';\n          }\n        }\n        if (isValidFreq == '\\0') {\n          if ((i2cHandle->Init).DutyCycle == 0) {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      i2cHandle->Instance->CCR = pclk1Freq;\n      i2cHandle->Instance->CR1 = (i2cHandle->Init).NoStretchMode | (i2cHandle->Init).GeneralCallMode;\n      i2cHandle->Instance->OAR1 = (i2cHandle->Init).OwnAddress1 | (i2cHandle->Init).AddressingMode;\n      i2cHandle->Instance->OAR2 = (i2cHandle->Init).OwnAddress2 | (i2cHandle->Init).DualAddressMode;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      status = HAL_OK;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "hi2c": "i2cHandle",
                "uVar1": "pclk1Freq",
                "cVar2": "isValidFreq",
                "HVar3": "status",
                "uVar4": "pclk1",
                "uVar5": "trise",
                "bVar6": "isZero",
                "hi2c_local": "localI2CHandle",
                "pclk1": "pclk1Freq",
                "freqrange": "frequencyRange"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "init_i2_c_08001cb8",
            "code": "\nvoid initI2C_08001cb8(I2C_HandleTypeDef *i2cHandler)\n\n{\n  I2C_HandleTypeDef *localI2CHandler;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "init_i2_c_08001cb8",
                "hi2c": "i2cHandler",
                "hi2c_local": "localI2CHandler"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "write_memory_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nHAL_StatusTypeDef\nwriteMemory_08001ccc(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  int loopCounter;\n  byte *bufferPointer;\n  uint16_t localMemAddressSize;\n  uint16_t localMemAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t startTick;\n  \n  startTick = HAL_GetTick();\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandle->Instance->SR2 & 2) != 0) {\n        loopCounter = 0;\n        goto LAB_08001d9c;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    loopCounter = 3;\nLAB_08001d9c:\n    if (loopCounter == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = dataBuffer;\n        i2cHandle->XferCount = dataSize;\n        i2cHandle->XferOptions = 0xffff0000;\n        i2cHandle->XferdataSize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,startTick);\n        if (status == HAL_OK) {\n          while (i2cHandle->XferdataSize != 0) {\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,startTick);\n            if (status != HAL_OK) {\n              if (i2cHandle->ErrorCode == 4) {\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                return HAL_ERROR;\n              }\n              return HAL_TIMEOUT;\n            }\n            bufferPointer = i2cHandle->pBuffPtr;\n            i2cHandle->pBuffPtr = bufferPointer + 1;\n            i2cHandle->Instance->DR = (uint)*bufferPointer;\n            i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n            i2cHandle->XferCount = i2cHandle->XferCount - 1;\n            if (((i2cHandle->Instance->SR1 & 4) == 4) && (i2cHandle->XferdataSize != 0)) {\n              bufferPointer = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = bufferPointer + 1;\n              i2cHandle->Instance->DR = (uint)*bufferPointer;\n              i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n            }\n          }\n          status = I2C_WaitOnBTFFlagUntiltimeout(i2cHandle,timeout,startTick);\n          if (status == HAL_OK) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            i2cHandle->State = HAL_I2C_STATE_READY;\n            i2cHandle->Mode = HAL_I2C_MODE_NONE;\n            i2cHandle->Lock = HAL_UNLOCKED;\n            status = HAL_OK;\n          }\n          else if (i2cHandle->ErrorCode == 4) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            status = HAL_ERROR;\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "write_memory_08001ccc",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTick",
                "uVar2": "currentTick",
                "iVar3": "loopCounter",
                "pbVar4": "bufferPointer",
                "MemAddSize_local": "localMemAddressSize",
                "MemAddress_local": "localMemAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tickstart": "startTick"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "read_memory_via_i2_c_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nHAL_StatusTypeDef\nreadMemoryViaI2C_08001f6c(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  int loopCounter;\n  uint8_t *bufferPointer;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t tempRegister3;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  uint32_t localStartTick;\n  \n  startTick = HAL_GetTick();\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandle->Instance->SR2 & 2) != 0) {\n        loopCounter = 0;\n        goto LAB_08002040;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    loopCounter = 3;\nLAB_08002040:\n    if (loopCounter == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = dataBuffer;\n        i2cHandle->XferCount = dataSize;\n        i2cHandle->XferOptions = 0xffff0000;\n        i2cHandle->XferdataSize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,startTick);\n        if (status == HAL_OK) {\n          if (i2cHandle->XferdataSize == 0) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          }\n          else if (i2cHandle->XferdataSize == 1) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (i2cHandle->XferdataSize == 2) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n          }\n          while (i2cHandle->XferdataSize != 0) {\n            if (i2cHandle->XferdataSize < 4) {\n              if (i2cHandle->XferdataSize == 1) {\n                status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,startTick);\n                if (status != HAL_OK) {\n                  if (i2cHandle->ErrorCode == 0x20) {\n                    return HAL_TIMEOUT;\n                  }\n                  return HAL_ERROR;\n                }\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else if (i2cHandle->XferdataSize == 2) {\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    loopCounter = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                loopCounter = 3;\nLAB_080022fa:\n                if (loopCounter != 0) {\n                  return HAL_TIMEOUT;\n                }\n                disableIRQinterrupts();\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else {\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    loopCounter = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                loopCounter = 3;\nLAB_08002418:\n                if (loopCounter != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n                disableIRQinterrupts();\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    loopCounter = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                loopCounter = 3;\nLAB_0800250a:\n                if (loopCounter != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n            else {\n              status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,startTick);\n              if (status != HAL_OK) {\n                if (i2cHandle->ErrorCode == 0x20) {\n                  return HAL_TIMEOUT;\n                }\n                return HAL_ERROR;\n              }\n              currentTick = i2cHandle->Instance->DR;\n              bufferPointer = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = bufferPointer + 1;\n              *bufferPointer = (uint8_t)currentTick;\n              i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              if ((i2cHandle->Instance->SR1 & 4) == 4) {\n                currentTick = i2cHandle->Instance->DR;\n                bufferPointer = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPointer + 1;\n                *bufferPointer = (uint8_t)currentTick;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n          }\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_OK;\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "read_memory_via_i2_c_08001f6c",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTick",
                "uVar2": "currentTick",
                "iVar3": "loopCounter",
                "puVar4": "bufferPointer",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg_3": "tempRegister3",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "tickstart": "localStartTick"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "write_to_device_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nHAL_StatusTypeDef\nwriteToDevice_08002640(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  int loopCount;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      loopCount = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  loopCount = 3;\nLAB_0800270a:\n  if (loopCount == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n    if (status == HAL_OK) {\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n      if (status == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (status != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        status = HAL_OK;\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        status = HAL_ERROR;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      status = HAL_ERROR;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002640": "write_to_device_08002640",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "iVar3": "loopCount",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "read_from_i2_c_device_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nHAL_StatusTypeDef\nreadFromI2CDevice_080027f4(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  int iterationCount;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      iterationCount = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  iterationCount = 3;\nLAB_080028d2:\n  if (iterationCount == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n    if (status == HAL_OK) {\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n      if (status == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (status != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n        if (status == HAL_OK) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n          do {\n            if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n              iterationCount = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n          i2cHandle->PreviousState = 0;\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          iterationCount = 3;\nLAB_08002a90:\n          if (iterationCount == 0) {\n            i2cHandle->Instance->DR = (uint)(byte)((byte)deviceAddress | 1);\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n            if (status == HAL_OK) {\n              status = HAL_OK;\n            }\n            else if (i2cHandle->ErrorCode == 4) {\n              status = HAL_ERROR;\n            }\n            else {\n              status = HAL_TIMEOUT;\n            }\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          status = HAL_ERROR;\n        }\n        else {\n          status = HAL_TIMEOUT;\n        }\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        status = HAL_ERROR;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      status = HAL_ERROR;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "read_from_i2_c_device_080027f4",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "iVar3": "iterationCount",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "handle_i2_c_flag_08002ad8",
            "code": "\nHAL_StatusTypeDef\nhandleI2CFlag_08002ad8(I2C_HandleTypeDef *i2cHandle,uint32_t flag,uint32_t timeout,uint32_t tickstart)\n\n{\n  uint32_t tempVar1;\n  char tempVar2;\n  uint tempVar3;\n  bool tempVar4;\n  uint32_t localTickstart;\n  uint32_t localTimeout;\n  uint32_t localFlag;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  do {\n    if ((flag >> 0x10 & 0xff) == 1) {\n      tempVar3 = flag & ~i2cHandle->Instance->SR1 & 0xffff;\n      tempVar4 = tempVar3 != 0;\n      if (tempVar4) {\n        tempVar3 = 1;\n      }\n      tempVar2 = (char)tempVar3;\n      if (!tempVar4) {\n        tempVar2 = '\\0';\n      }\n    }\n    else {\n      tempVar3 = flag & ~i2cHandle->Instance->SR2 & 0xffff;\n      tempVar4 = tempVar3 != 0;\n      if (tempVar4) {\n        tempVar3 = 1;\n      }\n      tempVar2 = (char)tempVar3;\n      if (!tempVar4) {\n        tempVar2 = '\\0';\n      }\n    }\n    if (tempVar2 == '\\0') {\n      return HAL_OK;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x400) == 0x400) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n      i2cHandle->ErrorCode = 4;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tempVar1 = HAL_GetTick(), tempVar1 - tickstart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "handle_i2_c_flag_08002ad8",
                "hi2c": "i2cHandle",
                "Flag": "flag",
                "Timeout": "timeout",
                "Tickstart": "tickstart",
                "uVar1": "tempVar1",
                "cVar2": "tempVar2",
                "uVar3": "tempVar3",
                "bVar4": "tempVar4",
                "Tickstart_local": "localTickstart",
                "Timeout_local": "localTimeout",
                "Flag_local": "localFlag",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "wait_for_i2_c_ack_08002bb4",
            "code": "\nHAL_StatusTypeDef waitForI2CAck_08002bb4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 0x80) == 0x80) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "wait_for_i2_c_ack_08002bb4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "wait_for_i2_c_acknowledge_08002c2e",
            "code": "\nHAL_StatusTypeDef waitForI2CAcknowledge_08002c2e(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 4) == 4) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "wait_for_i2_c_acknowledge_08002c2e",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "wait_for_flag_08002ca8",
            "code": "\nHAL_StatusTypeDef waitForFlag_08002ca8(I2C_HandleTypeDef *i2c_handle,uint32_t timeout,uint32_t tick_start)\n\n{\n  uint32_t current_tick;\n  uint32_t local_tick_start;\n  uint32_t local_timeout;\n  I2C_HandleTypeDef *local_i2c_handle;\n  \n  while( true ) {\n    if ((i2c_handle->Instance->SR1 & 0x40) == 0x40) {\n      return HAL_OK;\n    }\n    if ((i2c_handle->Instance->SR1 & 0x10) == 0x10) break;\n    if ((timeout == 0) || (current_tick = HAL_GetTick(), timeout < current_tick - tick_start)) {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 0x20;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2c_handle->Instance->SR1 = 0xffffffef;\n  i2c_handle->ErrorCode = 0;\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "wait_for_flag_08002ca8",
                "hi2c": "i2c_handle",
                "Timeout": "timeout",
                "Tickstart": "tick_start",
                "uVar1": "current_tick",
                "Tickstart_local": "local_tick_start",
                "Timeout_local": "local_timeout",
                "hi2c_local": "local_i2c_handle"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_i2_c_status_08002d3c",
            "code": "\nHAL_StatusTypeDef checkI2CStatus_08002d3c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  bool isBusError;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  isBusError = (i2cHandle->Instance->SR1 & 0x400) == 0x400;\n  if (isBusError) {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->ErrorCode = 4;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Lock = HAL_UNLOCKED;\n  }\n  return isBusError;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_i2_c_status_08002d3c",
                "hi2c": "i2cHandle",
                "bVar1": "isBusError",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "configure_rcc_oscillators_08002d98",
            "code": "\n\n\nHAL_StatusTypeDef configureRCCOscillators_08002d98(RCC_OscInitTypeDef *oscInit)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  bool isHSEEnabled;\n  RCC_OscInitTypeDef *localOscInit;\n  uint32_t temporaryRegister;\n  uint32_t tickStart;\n  FlagStatus powerClockChanged;\n  \n  if ((oscInit->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscInit->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscInit->HSEState == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (oscInit->HSEState == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (oscInit->HSEState == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscInit->HSEState == 0) {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscInit->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscInit->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = oscInit->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (oscInit->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = oscInit->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((oscInit->OscillatorType & 8) != 0) {\n    if (oscInit->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscInit->OscillatorType & 4) != 0) {\n    isHSEEnabled = (_DAT_4002101c & 0x10000000) == 0;\n    if (isHSEEnabled) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscInit->LSEState == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (oscInit->LSEState == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (oscInit->LSEState == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscInit->LSEState == 0) {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isHSEEnabled) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((oscInit->PLL).PLLState == 0) {\nLAB_0800324a:\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if ((oscInit->PLL).PLLState == 2) {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscInit->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = oscInit->HSEPredivValue | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 =\n             (oscInit->PLL).PLLMUL | (oscInit->PLL).PLLSource |\n             _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTick = HAL_GetTick();\n          if (2 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "configure_rcc_oscillators_08002d98",
                "RCC_OscInitStruct": "oscInit",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "HVar3": "status",
                "bVar4": "isHSEEnabled",
                "RCC_OscInitStruct_local": "localOscInit",
                "tmpreg": "temporaryRegister",
                "tickstart": "tickStart",
                "pwrclkchanged": "powerClockChanged"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "configure_system_clock_08003260",
            "code": "\n\n\nHAL_StatusTypeDef configureSystemClock_08003260(RCC_ClkInitTypeDef *clockInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t sysClockFreq;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  uint32_t localFlashLatency;\n  RCC_ClkInitTypeDef *localClockInitStruct;\n  uint32_t startTick;\n  \n  if (((_DAT_40022000 & 7) < flashLatency) &&\n     (_DAT_40022000 = flashLatency | _DAT_40022000 & 0xfffffff8, flashLatency != (flashLatency & 7))) {\n    status = HAL_ERROR;\n  }\n  else {\n    if ((clockInitStruct->ClockType & 2) != 0) {\n      _DAT_40021004 = clockInitStruct->AHBCLKDivider | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((clockInitStruct->ClockType & 1) == 0) {\nLAB_08003394:\n      if ((flashLatency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = flashLatency | _DAT_40022000 & 0xfffffff8, flashLatency != (flashLatency & 7))) {\n        status = HAL_ERROR;\n      }\n      else {\n        if ((clockInitStruct->ClockType & 4) != 0) {\n          _DAT_40021004 = clockInitStruct->APB1CLKDivider | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((clockInitStruct->ClockType & 8) != 0) {\n          _DAT_40021004 = clockInitStruct->APB2CLKDivider << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = HAL_RCC_GetSysClockFreq();\n        SystemCoreClock = sysClockFreq >> \"\"[_DAT_40021004 >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        status = HAL_OK;\n      }\n    }\n    else {\n      if (clockInitStruct->SYSCLKSource == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((clockInitStruct->SYSCLKSource != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021004 = clockInitStruct->SYSCLKSource | _DAT_40021004 & 0xfffffffc;\n      sysClockFreq = HAL_GetTick();\n      if (clockInitStruct->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003260": "configure_system_clock_08003260",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "flashLatency",
                "uVar1": "sysClockFreq",
                "uVar2": "currentTick",
                "HVar3": "status",
                "FLatency_local": "localFlashLatency",
                "RCC_ClkInitStruct_local": "localClockInitStruct",
                "tickstart": "startTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_sys_clock_freq_08003440",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSysClockFreq_08003440(void)\n\n{\n  uint8_t predivFactors [2];\n  uint8_t pllmulFactors [16];\n  uint32_t pllmul;\n  uint32_t prediv;\n  uint32_t tmpreg;\n  uint32_t sysClockFreq;\n  uint32_t pllClock;\n  \n  pllmulFactors[0] = '\\x02';\n  pllmulFactors[1] = '\\x03';\n  pllmulFactors[2] = '\\x04';\n  pllmulFactors[3] = '\\x05';\n  pllmulFactors[4] = '\\x06';\n  pllmulFactors[5] = '\\a';\n  pllmulFactors[6] = '\\b';\n  pllmulFactors[7] = '\\t';\n  pllmulFactors[8] = '\\n';\n  pllmulFactors[9] = '\\v';\n  pllmulFactors[10] = '\\f';\n  pllmulFactors[11] = '\\r';\n  pllmulFactors[12] = '\\x0e';\n  pllmulFactors[13] = '\\x0f';\n  pllmulFactors[14] = '\\x10';\n  pllmulFactors[15] = '\\x10';\n  predivFactors[0] = '\\x01';\n  predivFactors[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 4) {\n    sysClockFreq = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      pllClock = (uint)pllmulFactors[_DAT_40021004 >> 0x12 & 0xf] * 4000000;\n    }\n    else {\n      pllClock = ((uint)pllmulFactors[_DAT_40021004 >> 0x12 & 0xf] * 8000000) /\n               (uint)predivFactors[_DAT_40021004 >> 0x11 & 1];\n    }\n    sysClockFreq = pllClock;\n  }\n  else {\n    sysClockFreq = 8000000;\n  }\n  return sysClockFreq;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_sys_clock_freq_08003440",
                "aPredivFactorTable": "predivFactors",
                "aPLLMULFactorTable": "pllmulFactors",
                "sysclockfreq": "sysClockFreq",
                "pllclk": "pllClock"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_system_core_clock_08003504",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003504(void)\n\n{\n  return coreClock;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_system_core_clock_08003504",
                "SystemCoreClock": "coreClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_hclk_frequency_08003518",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_08003518(void)\n\n{\n  uint32_t hclk_frequency;\n  \n  hclk_frequency = HAL_RCC_GetHCLKFreq();\n  return hclk_frequency >> \"\"[_DAT_40021004 >> 8 & 7];\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_hclk_frequency_08003518",
                "uVar1": "hclk_frequency"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_clock_frequency_08003540",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_clock_frequency_08003540(void)\n\n{\n  uint32_t hclk_frequency;\n  \n  hclk_frequency = HAL_RCC_GetHCLKFreq();\n  return hclk_frequency >> \"\"[_DAT_40021004 >> 0xb & 7];\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_clock_frequency_08003540",
                "uVar1": "hclk_frequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_milliseconds_08003568",
            "code": "\nvoid delayMilliseconds_08003568(uint32_t inputDelay)\n\n{\n  bool continueLoop;\n  uint32_t localDelay;\n  uint32_t totalTicks;\n  \n  totalTicks = inputDelay * (SystemCoreClock / 8000);\n  do {\n    continueLoop = totalTicks != 0;\n    totalTicks = totalTicks - 1;\n  } while (continueLoop);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_milliseconds_08003568",
                "mdelay": "inputDelay",
                "mdelay_local": "localDelay",
                "Delay": "totalTicks",
                "bVar1": "continueLoop"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nHAL_StatusTypeDef initialize_timer_080035a4(TIM_HandleTypeDef *timer)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *local_timer;\n  \n  if (timer == (TIM_HandleTypeDef *)0x0) {\n    status = error;\n  }\n  else {\n    if (timer->State == reset_state) {\n      timer->Lock = unlocked;\n      initialize_timer_080035a4_dependencies(timer);\n    }\n    timer->State = busy_state;\n    set_timer_configuration(timer->timer_instance,&timer->timer_init);\n    timer->State = ready_state;\n    status = ok;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "htim": "timer",
                "HVar1": "status",
                "htim_local": "local_timer",
                "HAL_ERROR": "error",
                "HAL_TIM_STATE_RESET": "reset_state",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_STATE_BUSY": "busy_state",
                "HAL_TIM_STATE_READY": "ready_state",
                "HAL_OK": "ok",
                "HAL_TIM_Base_MspInit": "initialize_timer_dependencies",
                "TIM_Base_SetConfig": "set_timer_configuration",
                "Instance": "timer_instance",
                "Init": "timer_init"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "initialize_timer_080035fa",
            "code": "\nvoid initialize_timer_080035fa(TIM_HandleTypeDef *timer_handler)\n\n{\n  TIM_HandleTypeDef *timer_handler_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "initialize_timer_080035fa",
                "htim": "timer_handler"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "enable_timer_interrupts_0800360c",
            "code": "\nHAL_StatusTypeDef enableTimerInterrupts_0800360c(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  timer->Instance->DIER = timer->Instance->DIER | 1;\n  timer->Instance->CR1 = timer->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "enable_timer_interrupts_0800360c",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_timer_08003640",
            "code": "\nHAL_StatusTypeDef initializeTimer_08003640(TIM_HandleTypeDef *timer)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *localTimer;\n  \n  if (timer == (TIM_HandleTypeDef *)0x0) {\n    status = Error;\n  }\n  else {\n    if (timer->State == TimerStateReset) {\n      timer->Lock = Unlocked;\n      initializePWM(timer);\n    }\n    timer->State = TimerStateBusy;\n    setTimerConfig(timer->Instance,&timer->Init);\n    timer->State = TimerStateReady;\n    status = OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_timer_08003640",
                "htim": "timer",
                "HVar1": "status",
                "htim_local": "localTimer",
                "HAL_ERROR": "Error",
                "HAL_TIM_STATE_RESET": "TimerStateReset",
                "HAL_UNLOCKED": "Unlocked",
                "HAL_TIM_PWM_MspInit": "initializePWM",
                "HAL_TIM_STATE_BUSY": "TimerStateBusy",
                "TIM_Base_SetConfig": "setTimerConfig",
                "HAL_TIM_STATE_READY": "TimerStateReady",
                "HAL_OK": "OK"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "initialize_tim_08003696",
            "code": "\nvoid initialize_TIM_08003696(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *local_timer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "initialize_tim_08003696",
                "htim": "timer",
                "htim_local": "local_timer"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "initialize_timer_channel_080036a8",
            "code": "\nHAL_StatusTypeDef initializeTimerChannel_080036a8(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  uint32_t localChannel;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,1);\n  if (timerHandle->Instance == (TIM_TypeDef *)0x40012c00) {\n    timerHandle->Instance->BDTR = timerHandle->Instance->BDTR | 0x8000;\n  }\n  timerHandle->Instance->CR1 = timerHandle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "initialize_timer_channel_080036a8",
                "htim": "timerHandle",
                "Channel": "channel",
                "Channel_local": "localChannel",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "check_timers_and_callbacks_080036f8",
            "code": "\nvoid checkTimersAndCallbacks_080036f8(TIM_HandleTypeDef *timerHandler)\n\n{\n  TIM_HandleTypeDef *localTimerHandler;\n  \n  if (((timerHandler->Instance->SR & 2) == 2) && ((timerHandler->Instance->DIER & 2) == 2)) {\n    timerHandler->Instance->SR = 0xfffffffd;\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timerHandler->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandler);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandler);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandler);\n    }\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandler->Instance->SR & 4) == 4) && ((timerHandler->Instance->DIER & 4) == 4)) {\n    timerHandler->Instance->SR = 0xfffffffb;\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timerHandler->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandler);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandler);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandler);\n    }\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandler->Instance->SR & 8) == 8) && ((timerHandler->Instance->DIER & 8) == 8)) {\n    timerHandler->Instance->SR = 0xfffffff7;\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timerHandler->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandler);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandler);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandler);\n    }\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandler->Instance->SR & 0x10) == 0x10) && ((timerHandler->Instance->DIER & 0x10) == 0x10)) {\n    timerHandler->Instance->SR = 0xffffffef;\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timerHandler->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandler);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandler);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandler);\n    }\n    timerHandler->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandler->Instance->SR & 1) == 1) && ((timerHandler->Instance->DIER & 1) == 1)) {\n    timerHandler->Instance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerHandler);\n  }\n  if (((timerHandler->Instance->SR & 0x80) == 0x80) && ((timerHandler->Instance->DIER & 0x80) == 0x80)) {\n    timerHandler->Instance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerHandler);\n  }\n  if (((timerHandler->Instance->SR & 0x40) == 0x40) && ((timerHandler->Instance->DIER & 0x40) == 0x40)) {\n    timerHandler->Instance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerHandler);\n  }\n  if (((timerHandler->Instance->SR & 0x20) == 0x20) && ((timerHandler->Instance->DIER & 0x20) == 0x20)) {\n    timerHandler->Instance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerHandler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "check_timers_and_callbacks_080036f8",
                "htim": "timerHandler",
                "htim_local": "localTimerHandler"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_tim_output_channel_08003908",
            "code": "\nHAL_StatusTypeDef configure_TIM_output_channel_08003908(TIM_HandleTypeDef *timer_handle,TIM_OC_InitTypeDef *output_channel_config,uint32_t channel)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t local_channel;\n  TIM_OC_InitTypeDef *local_output_channel_config;\n  TIM_HandleTypeDef *local_timer_handle;\n  \n  if (timer_handle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timer_handle->Lock = HAL_LOCKED;\n    timer_handle->State = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timer_handle->Instance,output_channel_config);\n      timer_handle->Instance->CCMR1 = timer_handle->Instance->CCMR1 | 8;\n      timer_handle->Instance->CCMR1 = timer_handle->Instance->CCMR1 & 0xfffffffb;\n      timer_handle->Instance->CCMR1 = output_channel_config->OCFastMode | timer_handle->Instance->CCMR1;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timer_handle->Instance,output_channel_config);\n      timer_handle->Instance->CCMR1 = timer_handle->Instance->CCMR1 | 0x800;\n      timer_handle->Instance->CCMR1 = timer_handle->Instance->CCMR1 & 0xfffffbff;\n      timer_handle->Instance->CCMR1 = output_channel_config->OCFastMode << 8 | timer_handle->Instance->CCMR1;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timer_handle->Instance,output_channel_config);\n      timer_handle->Instance->CCMR2 = timer_handle->Instance->CCMR2 | 8;\n      timer_handle->Instance->CCMR2 = timer_handle->Instance->CCMR2 & 0xfffffffb;\n      timer_handle->Instance->CCMR2 = output_channel_config->OCFastMode | timer_handle->Instance->CCMR2;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timer_handle->Instance,output_channel_config);\n      timer_handle->Instance->CCMR2 = timer_handle->Instance->CCMR2 | 0x800;\n      timer_handle->Instance->CCMR2 = timer_handle->Instance->CCMR2 & 0xfffffbff;\n      timer_handle->Instance->CCMR2 = output_channel_config->OCFastMode << 8 | timer_handle->Instance->CCMR2;\n    }\n    timer_handle->State = HAL_TIM_STATE_READY;\n    timer_handle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_tim_output_channel_08003908",
                "htim": "timer_handle",
                "sConfig": "output_channel_config",
                "Channel": "channel",
                "HVar1": "status",
                "Channel_local": "local_channel",
                "sConfig_local": "local_output_channel_config",
                "htim_local": "local_timer_handle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_clock_08003a94",
            "code": "\nHAL_StatusTypeDef configureTimerClock_08003a94(TIM_HandleTypeDef *timerHandle,TIM_ClockConfigTypeDef *clockConfig)\n\n{\n  HAL_StatusTypeDef status;\n  uint clockSource;\n  TIM_ClockConfigTypeDef *localClockConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  uint32_t temporarySMCR;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffff0088;\n    clockSource = clockConfig->ClockSource;\n    if (clockSource == 0x40) {\n      TIM_TI1_ConfigInputStage\n                (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      TIM_ITRx_SetConfig(timerHandle->Instance,0x40);\n    }\n    else if (clockSource < 0x41) {\n      if (clockSource == 0x10) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x10);\n      }\n      else if (clockSource < 0x11) {\n        if (clockSource == 0) {\n          TIM_ITRx_SetConfig(timerHandle->Instance,0);\n        }\n      }\n      else if (clockSource == 0x20) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x20);\n      }\n      else if (clockSource == 0x30) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x30);\n      }\n    }\n    else if (clockSource == 0x70) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff88 | 0x77;\n    }\n    else if (clockSource < 0x71) {\n      if (clockSource == 0x50) {\n        TIM_TI1_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x50);\n      }\n      else if (clockSource == 0x60) {\n        TIM_TI2_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x60);\n      }\n    }\n    else if (clockSource == 0x1000) {\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xfffffff8;\n    }\n    else if (clockSource == 0x2000) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR | 0x4000;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_clock_08003a94",
                "htim": "timerHandle",
                "sClockSourceConfig": "clockConfig",
                "HVar1": "status",
                "uVar2": "clockSource",
                "sClockSourceConfig_local": "localClockConfig",
                "htim_local": "localTimerHandle",
                "tmpsmcr": "temporarySMCR"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_ETR_SetConfig",
                "TIM_TI2_ConfigInputStage",
                "TIM_TI1_ConfigInputStage",
                "TIM_ITRx_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "initialize_timer_08003c4a",
            "code": "\nvoid initializeTimer_08003c4a(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "initialize_timer_08003c4a",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "initialize_timer_08003c5c",
            "code": "\nvoid initialize_timer_08003c5c(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *local_timer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "initialize_timer_08003c5c",
                "htim": "timer",
                "htim_local": "local_timer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "initialize_timer_08003c6e",
            "code": "\nvoid initialize_timer_08003c6e(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *local_timer_handle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "initialize_timer_08003c6e",
                "htim": "timer_handle",
                "htim_local": "local_timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "initialize_timer_08003c80",
            "code": "\nvoid initialize_timer_08003c80(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *local_timer_handle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "initialize_timer_08003c80",
                "htim": "timer_handle",
                "htim_local": "local_timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "initialize_timer_08003c94",
            "code": "\nvoid initializeTimer_08003c94(TIM_TypeDef *timer,TIM_Base_InitTypeDef *config)\n\n{\n  TIM_Base_InitTypeDef *localConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t tempControlReg1;\n  \n  tempControlReg1 = timer->CR1;\n  if ((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n      (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) {\n    tempControlReg1 = config->CounterMode | tempControlReg1 & 0xffffff8f;\n  }\n  if (((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n     ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))) {\n    tempControlReg1 = config->ClockDivision | tempControlReg1 & 0xfffffcff;\n  }\n  timer->CR1 = config->AutoReloadPreload | tempControlReg1 & 0xffffff7f;\n  timer->ARR = config->Period;\n  timer->PSC = config->Prescaler;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    uRam40012c30 = config->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "initialize_timer_08003c94",
                "TIMx": "timer",
                "Structure": "config",
                "Structure_local": "localConfig",
                "TIMx_local": "localTimer",
                "tmpcr1": "tempControlReg1"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "configure_output_compare_08003d60",
            "code": "\nvoid configureOutputCompare_08003d60(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint ocMode;\n  uint32_t ocPolarity;\n  TIM_OC_InitTypeDef *localOutputCompareConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t tempCcmr;\n  uint32_t tempCr2;\n  uint32_t tempCcer;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  tempCr2 = timer->CR2;\n  ocMode = outputCompareConfig->OCMode;\n  ocPolarity = outputCompareConfig->OCPolarity | timer->CCER & 0xfffffffd;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocPolarity = (outputCompareConfig->OCNPolarity | ocPolarity & 0xfffffff7) & 0xfffffffb;\n    tempCr2 = outputCompareConfig->OCNIdleState | outputCompareConfig->OCIdleState | tempCr2 & 0xfffffcff;\n  }\n  timer->CR2 = tempCr2;\n  timer->CCMR1 = ocMode | timer->CCMR1 & 0xffffff8c;\n  timer->CCR1 = outputCompareConfig->Pulse;\n  timer->CCER = ocPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "configure_output_compare_08003d60",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ocMode",
                "uVar2": "ocPolarity",
                "OC_Config_local": "localOutputCompareConfig",
                "TIMx_local": "localTimer",
                "tmpccmrx": "tempCcmr",
                "tmpcr2": "tempCr2",
                "tmpccer": "tempCcer"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "configure_timer_output_08003e38",
            "code": "\nvoid configureTimerOutput_08003e38(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t outputMode;\n  uint32_t outputPolarity;\n  TIM_OC_InitTypeDef *localOutputConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t tmpCCMR;\n  uint32_t tmpCR2;\n  uint32_t tmpCCER;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  tmpCR2 = timer->CR2;\n  outputMode = outputConfig->OCMode;\n  outputPolarity = outputConfig->OCPolarity << 4 | timer->CCER & 0xffffffdf;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    outputPolarity = (outputConfig->OCNPolarity << 4 | outputPolarity & 0xffffff7f) & 0xffffffbf;\n    tmpCR2 = outputConfig->OCNIdleState << 2 | outputConfig->OCIdleState << 2 | tmpCR2 & 0xfffff3ff;\n  }\n  timer->CR2 = tmpCR2;\n  timer->CCMR1 = outputMode << 8 | timer->CCMR1 & 0xffff8cff;\n  timer->CCR2 = outputConfig->Pulse;\n  timer->CCER = outputPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "configure_timer_output_08003e38",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "outputMode",
                "uVar2": "outputPolarity",
                "OC_Config_local": "localOutputConfig",
                "TIMx_local": "localTimer",
                "tmpccmrx": "tmpCCMR",
                "tmpcr2": "tmpCR2",
                "tmpccer": "tmpCCER"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "configure_timer_oc_channel_08003f18",
            "code": "\nvoid configureTimerOCChannel_08003f18(TIM_TypeDef *timer,TIM_OC_InitTypeDef *ocConfig)\n\n{\n  uint outputCompareMode;\n  uint32_t ocConfigValue;\n  TIM_OC_InitTypeDef *ocConfigLocal;\n  TIM_TypeDef *timerLocal;\n  uint32_t temporaryCcmrx;\n  uint32_t temporaryCr2;\n  uint32_t temporaryCcer;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  temporaryCr2 = timer->CR2;\n  outputCompareMode = ocConfig->OCMode;\n  ocConfigValue = ocConfig->OCPolarity << 8 | timer->CCER & 0xfffffdff;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocConfigValue = (ocConfig->OCNPolarity << 8 | ocConfigValue & 0xfffff7ff) & 0xfffffbff;\n    temporaryCr2 = ocConfig->OCNIdleState << 4 | ocConfig->OCIdleState << 4 | temporaryCr2 & 0xffffcfff;\n  }\n  timer->CR2 = temporaryCr2;\n  timer->CCMR2 = outputCompareMode | timer->CCMR2 & 0xffffff8c;\n  timer->CCR3 = ocConfig->Pulse;\n  timer->CCER = ocConfigValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "configure_timer_oc_channel_08003f18",
                "TIMx": "timer",
                "OC_Config": "ocConfig",
                "OC_Config_local": "ocConfigLocal",
                "TIMx_local": "timerLocal",
                "tmpccmrx": "temporaryCcmrx",
                "tmpcr2": "temporaryCr2",
                "tmpccer": "temporaryCcer",
                "uVar1": "outputCompareMode",
                "uVar2": "ocConfigValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "configure_timer_output_08003ff8",
            "code": "\nvoid configureTimerOutput_08003ff8(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ocMode;\n  uint32_t ocPolarity;\n  TIM_OC_InitTypeDef *localOutputConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCCER;\n  uint32_t temporaryCCMRX;\n  uint32_t temporaryCR2;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  temporaryCR2 = timer->CR2;\n  ocMode = outputConfig->OCMode;\n  ocPolarity = outputConfig->OCPolarity;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    temporaryCR2 = outputConfig->OCIdleState << 6 | temporaryCR2 & 0xffffbfff;\n  }\n  timer->CR2 = temporaryCR2;\n  timer->CCMR2 = ocMode << 8 | timer->CCMR2 & 0xffff8cff;\n  timer->CCR4 = outputConfig->Pulse;\n  timer->CCER = ocPolarity << 0xc | timer->CCER & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "configure_timer_output_08003ff8",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "OC_Config_local": "localOutputConfig",
                "TIMx_local": "localTimer",
                "tmpccer": "temporaryCCER",
                "tmpccmrx": "temporaryCCMRX",
                "tmpcr2": "temporaryCR2",
                "uVar1": "ocMode",
                "uVar2": "ocPolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "configure_timer_input_capture_080040a0",
            "code": "\nvoid configureTimerInputCapture_080040a0(TIM_TypeDef *timerInstance,uint32_t inputCapturePolarity,uint32_t inputCaptureFilter)\n\n{\n  uint ccerValue;\n  uint32_t icFilterLocal;\n  uint32_t icPolarityLocal;\n  TIM_TypeDef *timerInstanceLocal;\n  uint32_t tmpCCER;\n  uint32_t tmpCCMR1;\n  \n  ccerValue = timerInstance->CCER;\n  timerInstance->CCER = timerInstance->CCER & 0xfffffffe;\n  timerInstance->CCMR1 = inputCaptureFilter << 4 | timerInstance->CCMR1 & 0xffffff0f;\n  timerInstance->CCER = inputCapturePolarity | ccerValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "configure_timer_input_capture_080040a0",
                "TIMx": "timerInstance",
                "TIM_ICPolarity": "inputCapturePolarity",
                "TIM_ICFilter": "inputCaptureFilter",
                "uVar1": "ccerValue",
                "TIM_ICFilter_local": "icFilterLocal",
                "TIM_ICPolarity_local": "icPolarityLocal",
                "TIMx_local": "timerInstanceLocal",
                "tmpccer": "tmpCCER",
                "tmpccmr1": "tmpCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "set_timer_capture_settings_08004104",
            "code": "\nvoid setTimerCaptureSettings_08004104(TIM_TypeDef *timer,uint32_t inputCapturePolarity,uint32_t inputCaptureFilter)\n\n{\n  uint32_t localInputCaptureFilter;\n  uint32_t localInputCapturePolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCCER;\n  uint32_t temporaryCCMR1;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  timer->CCMR1 = inputCaptureFilter << 0xc | timer->CCMR1 & 0xffff0fff;\n  timer->CCER = inputCapturePolarity << 4 | timer->CCER & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "set_timer_capture_settings_08004104",
                "TIMx": "timer",
                "TIM_ICPolarity": "inputCapturePolarity",
                "TIM_ICFilter": "inputCaptureFilter",
                "TIM_ICFilter_local": "localInputCaptureFilter",
                "TIM_ICPolarity_local": "localInputCapturePolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "temporaryCCER",
                "tmpccmr1": "temporaryCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "configure_input_trigger_0800416a",
            "code": "\nvoid configureInputTrigger_0800416a(TIM_TypeDef *timer,uint16_t inputSource)\n\n{\n  uint16_t localInputSource;\n  TIM_TypeDef *localTimer;\n  uint32_t temporarySMCR;\n  \n  timer->SMCR = timer->SMCR & 0xffffff8f | (uint)(inputSource | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "configure_input_trigger_0800416a",
                "TIMx": "timer",
                "InputTriggerSource": "inputSource",
                "InputTriggerSource_local": "localInputSource",
                "TIMx_local": "localTimer",
                "tmpsmcr": "temporarySMCR"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "configure_external_trigger_080041a8",
            "code": "\nvoid configureExternalTrigger_080041a8(TIM_TypeDef *timer,uint32_t prescaler,uint32_t polarity,\n                 uint32_t filter)\n\n{\n  uint32_t localFilter;\n  uint32_t localPolarity;\n  uint32_t localPrescaler;\n  TIM_TypeDef *localTimer;\n  uint32_t tmpSMCR;\n  \n  timer->SMCR = prescaler | filter << 8 | polarity |\n               timer->SMCR & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "configure_external_trigger_080041a8",
                "TIMx": "timer",
                "TIM_ExtTRGPrescaler": "prescaler",
                "TIM_ExtTRGPolarity": "polarity",
                "ExtTRGFilter": "filter",
                "ExtTRGFilter_local": "localFilter",
                "TIM_ExtTRGPolarity_local": "localPolarity",
                "TIM_ExtTRGPrescaler_local": "localPrescaler",
                "TIMx_local": "localTimer",
                "tmpsmcr": "tmpSMCR"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "configure_timer_channel_080041ea",
            "code": "\nvoid configureTimerChannel_080041ea(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  uint32_t localChannelState;\n  uint32_t localChannel;\n  TIM_TypeDef *localTimer;\n  uint32_t temporary;\n  \n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "configure_timer_channel_080041ea",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState",
                "ChannelState_local": "localChannelState",
                "Channel_local": "localChannel",
                "TIMx_local": "localTimer",
                "tmp": "temporary"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "configure_break_dead_time_0800422e",
            "code": "\nHAL_StatusTypeDef\nconfigureBreakDeadTime_0800422e(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef *localBreakDeadTimeConfig;\n  TIM_HandleTypeDef *localTimer;\n  uint32_t bdtrTemp;\n  \n  if (timer->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timer->Lock = HAL_LOCKED;\n    timer->Instance->BDTR =\n         breakDeadTimeConfig->AutomaticOutput |\n         (breakDeadTimeConfig->AutomaticOutput |\n         (breakDeadTimeConfig->BreakPolarity |\n         (breakDeadTimeConfig->BreakState |\n         (breakDeadTimeConfig->OffStateRunMode |\n         (breakDeadTimeConfig->OffStateIDLEMode |\n         (breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime & 0xfffffcff) &\n         0xfffffbff) & 0xfffff7ff) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    timer->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "configure_break_dead_time_0800422e",
                "htim": "timer",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status",
                "sBreakDeadTimeConfig_local": "localBreakDeadTimeConfig",
                "htim_local": "localTimer",
                "tmpbdtr": "bdtrTemp"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "configure_master_timer_080042de",
            "code": "\nHAL_StatusTypeDef configureMasterTimer_080042de(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef *localMasterConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->CR2 = timerHandle->Instance->CR2 & 0xffffff8f;\n    timerHandle->Instance->CR2 = masterConfig->MasterOutputTrigger | timerHandle->Instance->CR2;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff7f;\n    timerHandle->Instance->SMCR = masterConfig->MasterSlaveMode | timerHandle->Instance->SMCR;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080042de": "configure_master_timer_080042de",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar1": "status",
                "sMasterConfig_local": "localMasterConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "initialize_timer_08004366",
            "code": "\nvoid initialize_timer_08004366(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *local_timer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "initialize_timer_08004366",
                "htim": "timer",
                "htim_local": "local_timer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "initialize_timer_08004378",
            "code": "\nvoid initializeTimer_08004378(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "initialize_timer_08004378",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nHAL_StatusTypeDef initializeUART_0800438a(UART_HandleTypeDef *uartHandle)\n\n{\n  HAL_StatusTypeDef status;\n  UART_HandleTypeDef *localUartHandle;\n  \n  if (uartHandle == (UART_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (uartHandle->gState == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->gState = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffb7ff;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xffffffd5;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->RxState = HAL_UART_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "huart": "uartHandle",
                "HVar1": "status",
                "huart_local": "localUartHandle"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "initialize_uart_08004424",
            "code": "\nvoid initialize_uart_08004424(UART_HandleTypeDef *uart_handle)\n\n{\n  UART_HandleTypeDef *uart_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "initialize_uart_08004424",
                "huart": "uart_handle"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "transmit_data_08004436",
            "code": "\nHALStatus\ntransmitData_08004436(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  HALStatus status;\n  int error;\n  uint32_t localTimeout;\n  uint16_t localSize;\n  uint8_t *localData;\n  UART_HandleTypeDef *localUartHandle;\n  uint16_t *tmp;\n  uint32_t startTick;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if ((data == (uint8_t *)0x0) || (dataSize == 0)) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      uVar1 = HAL_GetTick();\n      uartHandle->TxXferdataSize = dataSize;\n      uartHandle->TxXferCount = dataSize;\n      localData = data;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              error = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          error = 3;\nLAB_0800454c:\n          if (error != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)localData & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            localData = localData + 2;\n          }\n          else {\n            localData = localData + 1;\n          }\n        }\n        else {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              error = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          error = 3;\nLAB_08004614:\n          if (error != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*localData;\n          localData = localData + 1;\n        }\n      }\n      do {\n        if ((uartHandle->Instance->SR & 0x40) == 0x40) {\n          error = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout))));\n      uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n      uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n      uartHandle->gState = HAL_UART_STATE_READY;\n      uartHandle->RxState = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      error = 3;\nLAB_080046c6:\n      if (error == 0) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004436": "transmit_data_08004436",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar3": "status",
                "iVar4": "error",
                "Timeout_local": "localTimeout",
                "Size_local": "localSize",
                "pData_local": "localData",
                "huart_local": "localUartHandle",
                "tickstart": "startTick",
                "HAL_StatusTypeDef": "HALStatus"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "initialize_uart_080046ec",
            "code": "\nvoid initialize_uart_080046ec(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  UART_HandleTypeDef *local_uart_handle;\n  uint32_t tmp_register;\n  \n  uart_handle->Instance->CR2 = (uart_handle->Init).StopBits | uart_handle->Instance->CR2 & 0xffffcfff;\n  uart_handle->Instance->CR1 =\n       uart_handle->Instance->CR1 & 0xffffe9f3 |\n       (uart_handle->Init).Mode | (uart_handle->Init).WordLength | (uart_handle->Init).Parity;\n  uart_handle->Instance->CR3 = (uart_handle->Init).HwFlowCtl | uart_handle->Instance->CR3 & 0xfffffcff;\n  if (uart_handle->Instance == (USART_TypeDef *)0x40013800) {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    uart_handle->Instance->BRR =\n         ((((pclk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10 +\n         ((((pclk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  else {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    uart_handle->Instance->BRR =\n         ((((pclk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10 +\n         ((((pclk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "initialize_uart_080046ec",
                "huart": "uart_handle",
                "uVar1": "pclk_freq",
                "uVar2": "pclk_freq",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "uVar5": "pclk_freq",
                "uVar6": "baud_rate",
                "uVar7": "baud_rate",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "huart_local": "local_uart_handle",
                "tmpreg": "tmp_register"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initializeMPU6050_0800491c(Mpu6050 *sensor)\n\n{\n  Mpu6050 *sensor_local;\n  uint8_t dataByte1;\n  uint8_t dataByte2;\n  uint8_t dataBytes [5];\n  \n  dataByte1 = '\\0';\n  (*writeI2CRegister)(0xd0,'k',&dataByte1,1);\n  dataByte2 = '\\x10';\n  (*writeI2CRegister)(0xd0,'\\x1c',&dataByte2,1);\n  dataBytes[0] = '\\b';\n  (*writeI2CRegister)(0xd0,'\\x1b',dataBytes,1);\n  sensor->accelerationX = 0.0;\n  sensor->accelerationY = 0.0;\n  sensor->accelerationZ = 0.0;\n  sensor->temperature = 0.0;\n  sensor->gyroscopeX = 0.0;\n  sensor->gyroscopeY = 0.0;\n  sensor->gyroscopeZ = 0.0;\n  sensor->gyroscopeXOffset = 0.0;\n  sensor->gyroscopeYOffset = 0.0;\n  sensor->accelerationPitchOffset = 0.0;\n  sensor->accelerationRollOffset = 0.0;\n  calibrateMPU6050(sensor);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "mpu6050": "sensor",
                "local_13": "dataByte1",
                "local_12": "dataByte2",
                "local_11": "dataBytes",
                "I2C_Write_Reg": "writeI2CRegister",
                "accX": "accelerationX",
                "accY": "accelerationY",
                "accZ": "accelerationZ",
                "temp": "temperature",
                "gyroX": "gyroscopeX",
                "gyroY": "gyroscopeY",
                "gyroZ": "gyroscopeZ",
                "offset_gyroX": "gyroscopeXOffset",
                "offset_gyroY": "gyroscopeYOffset",
                "offset_acc_pitch": "accelerationPitchOffset",
                "offset_acc_roll": "accelerationRollOffset",
                "mpu6050_calibrate": "calibrateMPU6050"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_offset_080049cc",
            "code": "\nvosampleIndexd calculateOffset_080049cc(Mpu6050 *sensor)\n\n{\n  undefsampleIndexned4 sampleCount;\n  float average;\n  Mpu6050 *localSensor;\n  float accelerationRoll;\n  float accelerationPitch;\n  usampleIndexnt32_t currentTicks;\n  sampleIndexnt totalSamples;\n  sampleIndexnt sampleIndex;\n  float offsetAccelerationRoll;\n  float offsetAccelerationPitch;\n  float offsetGyroY;\n  float offsetGyroX;\n  \n  totalSamples = 1;\n  offsetGyroX = 0.0;\n  offsetGyroY = 0.0;\n  offsetAccelerationPitch = 0.0;\n  offsetAccelerationRoll = 0.0;\n  currentTicks = (*Get_ms_tsampleIndexck)();\n  sampleIndex = 0;\n  whsampleIndexle( true ) {\n    sampleIndexf (totalSamples <= sampleIndex) break;\n    accelerationPitch = 0.0;\n    accelerationRoll = 0.0;\n    sensor_update(sensor);\n    sensor_calc_accelerationPitch_roll(sensor,&accelerationPitch,&accelerationRoll);\n    offsetAccelerationPitch = (float)__addsf3(offsetAccelerationPitch,accelerationPitch);\n    offsetAccelerationRoll = (float)__addsf3(offsetAccelerationRoll,accelerationRoll);\n    offsetGyroX = (float)__addsf3(offsetGyroX,sensor->gyroX);\n    offsetGyroY = (float)__addsf3(offsetGyroY,sensor->gyroY);\n    currentTicks = (*Get_ms_tsampleIndexck)();\n    sampleIndex = sampleIndex + 1;\n  }\n  sampleCount = __floatssampleIndexsf(totalSamples);\n  average = (float)__aeabsampleIndex_fdsampleIndexv(offsetGyroX,sampleCount);\n  sensor->offsetGyroX = average;\n  sampleCount = __floatssampleIndexsf(totalSamples);\n  average = (float)__aeabsampleIndex_fdsampleIndexv(offsetGyroY,sampleCount);\n  sensor->offsetGyroY = average;\n  sampleCount = __floatssampleIndexsf(totalSamples);\n  average = (float)__aeabsampleIndex_fdsampleIndexv(offsetAccelerationPitch,sampleCount);\n  sensor->offset_accelerationPitch = average;\n  sampleCount = __floatssampleIndexsf(totalSamples);\n  average = (float)__aeabsampleIndex_fdsampleIndexv(offsetAccelerationRoll,sampleCount);\n  sensor->offset_accelerationRoll = average;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_offset_080049cc",
                "mpu6050": "sensor",
                "uVar1": "sampleCount",
                "fVar2": "average",
                "mpu6050_local": "localSensor",
                "acc_roll": "accelerationRoll",
                "acc_pitch": "accelerationPitch",
                "now": "currentTicks",
                "num_samples": "totalSamples",
                "i": "sampleIndex",
                "offset_accRoll": "offsetAccelerationRoll",
                "offset_accPitch": "offsetAccelerationPitch",
                "offset_gyroY": "offsetGyroY",
                "offset_gyroX": "offsetGyroX"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_update",
                "__addsf3",
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "extract_sensor_data_08004ae0",
            "code": "\nvoid extractSensorData_08004ae0(Mpu6050 *sensorDevice)\n\n{\n  floatemperature fVar1;\n  Mpu6050 *sensorDevice_local;\n  uintemperature8_temperature sensorDataRaw [14];\n  intemperature16_temperature gyroZ;\n  intemperature16_temperature gyroY;\n  intemperature16_temperature gyroX;\n  intemperature16_temperature temperature;\n  intemperature16_temperature accZ;\n  intemperature16_temperature accY;\n  intemperature16_temperature accX;\n  \n  (*readI2CRegister)(0xd0,';',sensorDataRaw,0xe);\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[0],sensorDataRaw[1]));\n  sensorDevice->accX = fVar1;\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[2],sensorDataRaw[3]));\n  sensorDevice->accY = fVar1;\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[4],sensorDataRaw[5]));\n  sensorDevice->accZ = fVar1;\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[6],sensorDataRaw[7]));\n  sensorDevice->temperatureemp = fVar1;\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[8],sensorDataRaw[9]));\n  sensorDevice->gyroYroX = fVar1;\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[10],sensorDataRaw[11]));\n  sensorDevice->gyroYroY = fVar1;\n  fVar1 = (floatemperature)convertIntToFloat((intemperature)CONCAT11(sensorDataRaw[12],sensorDataRaw[13]));\n  sensorDevice->gyroYroZ = fVar1;\n  retemperatureurn;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "extract_sensor_data_08004ae0",
                "mpu6050": "sensorDevice",
                "raw": "sensorDataRaw",
                "gz": "gyroZ",
                "gy": "gyroY",
                "gx": "gyroX",
                "t": "temperature",
                "az": "accZ",
                "ay": "accY",
                "ax": "accX",
                "I2C_Read_Reg": "readI2CRegister",
                "__floatsisf": "convertIntToFloat"
            },
            "calling": [
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_pitch_08004bd8",
            "code": "\nvoid calculatePitch_08004bd8(Mpu6050 *sensor,float *resultPitch)\n\n{\n  undefined4 gyroXDiff;\n  float truncatedPitch;\n  undefined8 tempVar1;\n  undefined8 tempVar2;\n  float *localPitch;\n  Mpu6050 *localSensor;\n  float pitchAcceleration;\n  float gyroX;\n  \n  gyroXDiff = __aeabi_fsub(sensor->gyroX,sensor->offset_gyroX);\n  tempVar1 = __aeabi_f2d(sensor_calc_resultPitch::total_resultPitch);\n  tempVar2 = __aeabi_f2d(gyroXDiff);\n  tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x83f5c366,0x3f340215);\n  tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                       (int)((ulonglong)tempVar2 >> 0x20));\n  sensor_calc_resultPitch::total_resultPitch = (float)__truncdfsf2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n  tempVar1 = __aeabi_f2d(sensor->accY);\n  tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x40b00000);\n  tempVar2 = __aeabi_f2d(sensor->accZ);\n  tempVar2 = __divdf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0,0x40b00000);\n  tempVar1 = atan2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                (int)((ulonglong)tempVar2 >> 0x20));\n  tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x40668000);\n  tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x54442d18,0x400921fb);\n  tempVar2 = __aeabi_f2d(sensor->offset_pitchAcceleration);\n  tempVar1 = __subdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                   (int)((ulonglong)tempVar2 >> 0x20));\n  tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x40568000);\n  truncatedPitch = (float)__truncdfsf2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n  if (sensor_calc_resultPitch::first_run == false) {\n    tempVar1 = __aeabi_f2d(sensor_calc_resultPitch::total_resultPitch);\n    tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x9999999a,0x3fe99999);\n    tempVar2 = __aeabi_f2d(truncatedPitch);\n    tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x9999999a,0x3fc99999);\n    tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                         (int)((ulonglong)tempVar2 >> 0x20));\n    sensor_calc_resultPitch::total_resultPitch =\n         (float)__truncdfsf2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n  }\n  else {\n    sensor_calc_resultPitch::first_run = false;\n    sensor_calc_resultPitch::total_resultPitch = truncatedPitch;\n  }\n  *resultPitch = sensor_calc_resultPitch::total_resultPitch;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_pitch_08004bd8",
                "mpu6050": "sensor",
                "pitch": "resultPitch",
                "pitch_local": "localPitch",
                "mpu6050_local": "localSensor",
                "acc_pitch": "pitchAcceleration",
                "gyro_x": "gyroX",
                "uVar1": "gyroXDiff",
                "fVar2": "truncatedPitch",
                "uVar3": "tempVar1",
                "uVar4": "tempVar2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_f2d",
                "__aeabi_dadd",
                "__muldf3",
                "__truncdfsf2",
                "__subdf3",
                "__aeabi_fsub",
                "__divdf3",
                "atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_pitch_and_roll_08004d78",
            "code": "\nvoid calculatePitchAndRoll_08004d78(Mpu6050 *sensorData,float *pitchAngle,float *rollAngle)\n\n{\n  undefined4 normalizedAccX;\n  undefined4 normalizedAccY;\n  undefined4 normalizedAccZ;\n  float calculatedPitch;\n  float calculatedRoll;\n  undefined8 temp1;\n  undefined8 temp2;\n  float *rollAngle_local;\n  float *pitchAngle_local;\n  Mpu6050 *sensorData_local;\n  float acc_rollAngle;\n  float acc_pitchAngle;\n  float acc_z;\n  float acc_y;\n  float acc_x;\n  \n  normalizedAccX = __aeabi_fdiv(sensorData->accX,0x45800000);\n  normalizedAccY = __aeabi_fdiv(sensorData->accY,0x45800000);\n  normalizedAccZ = __aeabi_fdiv(sensorData->accZ,0x45800000);\n  temp1 = __aeabi_f2d(normalizedAccY);\n  temp2 = __aeabi_f2d(normalizedAccZ);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  calculatedPitch = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(normalizedAccX);\n  temp2 = __aeabi_f2d(normalizedAccZ);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  calculatedRoll = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  *pitchAngle = calculatedPitch;\n  *rollAngle = calculatedRoll;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_pitch_and_roll_08004d78",
                "mpu6050": "sensorData",
                "pitch": "pitchAngle",
                "roll": "rollAngle",
                "uVar1": "normalizedAccX",
                "uVar2": "normalizedAccY",
                "uVar3": "normalizedAccZ",
                "fVar4": "calculatedPitch",
                "fVar5": "calculatedRoll",
                "uVar6": "temp1",
                "uVar7": "temp2"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__aeabi_f2d",
                "__muldf3",
                "__truncdfsf2",
                "atan2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "execute_system_call_08004e6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_08004e6c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "execute_system_call_08004e6c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "get_afl_call_result_08004e74",
            "code": "\nint getAflCallResult_08004e74(int ticks)\n\n{\n  uint32_t aflResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflResult = aflCall(1,ticks,0);\n  }\n  else {\n    aflResult = 0;\n  }\n  return aflResult;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "get_afl_call_result_08004e74",
                "ticks_local": "localTicks",
                "uVar1": "aflResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_data_to_i2_c_08004ea4",
            "code": "\nvoid writeDataToI2C_08004ea4(uint8_t address,uint8_t register,uint8_t *buffer,uint16_t length)\n\n{\n  uint8_t *local_buffer;\n  uint16_t local_length;\n  uint8_t local_register;\n  uint8_t local_address;\n  \n  HAL_I2C_Mem_Write(&hi2c1,(ushort)address,(ushort)register,1,buffer,length,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_data_to_i2_c_08004ea4",
                "addr": "address",
                "reg": "register",
                "data": "buffer",
                "len": "length",
                "data_local": "local_buffer",
                "len_local": "local_length",
                "reg_local": "local_register",
                "addr_local": "local_address"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_i2_c_memory_08004ee8",
            "code": "\nvoid read_I2C_memory_08004ee8(uint8_t address,uint8_t register,uint8_t *buffer,uint16_t length)\n\n{\n  uint8_t *local_buffer;\n  uint16_t local_length;\n  uint8_t local_register;\n  uint8_t local_address;\n  \n  HAL_I2C_Mem_Read(&hi2c1,(ushort)address,(ushort)register,1,buffer,length,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_i2_c_memory_08004ee8",
                "addr": "address",
                "reg": "register",
                "data": "buffer",
                "len": "length",
                "data_local": "local_buffer",
                "len_local": "local_length",
                "reg_local": "local_register",
                "addr_local": "local_address"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_current_tick_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_08004f2c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_current_tick_08004f2c",
                "uVar1": "current_tick"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_over_uart_08004f3c",
            "code": "\nvoid transmit_data_over_uart_08004f3c(char *data,uint32_t length)\n\n{\n  uint32_t local_length;\n  char *local_data;\n  \n  HAL_UART_Transmit(&huart1,(uint8_t *)data,(uint16_t)length,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_over_uart_08004f3c",
                "str": "data",
                "len": "length",
                "len_local": "local_length",
                "str_local": "local_data"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_string_buffer_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeStringBuffer_08004f60(void)\n\n{\n  memset(stringBuffer,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_string_buffer_08004f60",
                "strbuf": "stringBuffer"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "update_pitch_control_08004f78",
            "code": "\nvoid updatePitchControl_08004f78(Tintegral_termM_HandleTypeDef *timer_handler)\n\n{\n  size_t proportional_termQNproportional_termFCTDET;\n  undefined4 NBCintegral_termRNVMLJ;\n  int QSintegral_termSQKBFDZ;\n  undefined4 temp_var_3;\n  uint integral_termHGFYintegral_termSYTH;\n  undefined8 temp_var_5;\n  Tintegral_termM_HandleTypeDef *GHVEVintegral_termWRBY;\n  float SBHCBLCGintegral_termH;\n  uint8_t VWXZLFCGintegral_termproportional_term;\n  \n  accelerometer_update(&accelerometer);\n  accelerometer_calc_pitch_angle(&accelerometer,&pitch_angle);\n  flush_TJNintegral_termCQHSGZ();\n  temp_var_5 = __aeabi_f2d(pitch_angle);\n  sprintf(TJNintegral_termCQHSGZ,\"proportional_termitch: %f\\n\",(int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20));\n  proportional_termQNproportional_termFCTDET = strproportional_termQNproportional_termFCTDET(TJNintegral_termCQHSGZ);\n  uart_print(TJNintegral_termCQHSGZ,proportional_termQNproportional_termFCTDET);\n  error_term = (float)__aeabi_fsub(OTOUproportional_termFGFHW,pitch_angle);\n  proportional_term = (float)__aeabi_fmul(Kp,error_term);\n  NBCintegral_termRNVMLJ = __aeabi_fmul(Yproportional_termVQKGZATS,error_term);\n  integral_term = (float)__addsf3(NBCintegral_termRNVMLJ,integral_term);\n  NBCintegral_termRNVMLJ = __floatsisf(max_pwm);\n  QSintegral_termSQKBFDZ = __aeabi_fcmplt(NBCintegral_termRNVMLJ,integral_term);\n  if (QSintegral_termSQKBFDZ == 0) {\n    NBCintegral_termRNVMLJ = __floatsisf(min_pwm);\n    QSintegral_termSQKBFDZ = __aeabi_fcmpgt(NBCintegral_termRNVMLJ,integral_term);\n    if (QSintegral_termSQKBFDZ != 0) {\n      integral_term = (float)__floatunsisf(min_pwm);\n    }\n  }\n  else {\n    integral_term = (float)__floatunsisf(max_pwm);\n  }\n  integral_termHGFYintegral_termSYTH = (uint)derivative_gain ^ 0x80000000;\n  NBCintegral_termRNVMLJ = __aeabi_fsub(error_term,Zintegral_termGNGXLCZS);\n  D = (float)__aeabi_fmul(integral_termHGFYintegral_termSYTH,NBCintegral_termRNVMLJ);\n  NBCintegral_termRNVMLJ = __addsf3(proportional_term,integral_term);\n  NBCintegral_termRNVMLJ = __addsf3(NBCintegral_termRNVMLJ,D);\n  temp_var_3 = __floatsisf(max_pwm);\n  QSintegral_termSQKBFDZ = __aeabi_fcmpgt(NBCintegral_termRNVMLJ,temp_var_3);\n  if (QSintegral_termSQKBFDZ == 0) {\n    temp_var_3 = __floatsisf(min_pwm);\n    QSintegral_termSQKBFDZ = __aeabi_fcmplt(NBCintegral_termRNVMLJ,temp_var_3);\n    if (QSintegral_termSQKBFDZ == 0) {\n      VWXZLFCGintegral_termproportional_term = __fixunssfsi(NBCintegral_termRNVMLJ);\n    }\n    else {\n      VWXZLFCGintegral_termproportional_term = min_pwm;\n    }\n  }\n  else {\n    VWXZLFCGintegral_termproportional_term = max_pwm;\n  }\n  Zintegral_termGNGXLCZS = error_term;\n  QSintegral_termSQKBFDZ = __aeabi_fcmpgt(error_term,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,2,QSintegral_termSQKBFDZ != 0);\n  QSintegral_termSQKBFDZ = __aeabi_fcmpgt(error_term,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,4,QSintegral_termSQKBFDZ == 0);\n  QSintegral_termSQKBFDZ = __aeabi_fcmpgt(error_term,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,8,QSintegral_termSQKBFDZ != 0);\n  QSintegral_termSQKBFDZ = __aeabi_fcmpgt(error_term,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,0x10,QSintegral_termSQKBFDZ == 0);\n  (timer_handler1.integral_termnstance)->CCR1 = (uint)VWXZLFCGintegral_termproportional_term;\n  (timer_handler1.integral_termnstance)->CCR4 = (uint)VWXZLFCGintegral_termproportional_term;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "update_pitch_control_08004f78",
                "htim": "timer_handler",
                "len": "string_length",
                "uVar1": "temp_var_1",
                "iVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "htim_local": "local_timer_handler",
                "pid_pwm": "pid_output",
                "out_pwm": "output_pwm",
                "mpu6050": "accelerometer",
                "pitch": "pitch_angle",
                "strbuf": "string_buffer",
                "error": "error_term",
                "setpoint": "desired_pitch",
                "P": "proportional_term",
                "Ki": "integral_gain",
                "I": "integral_term",
                "maxPwm": "max_pwm",
                "minPwm": "min_pwm",
                "Kd": "derivative_gain",
                "lastError": "previous_error"
            },
            "calling": [
                "HAL_TIM_IRQHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [
                "mpu6050_update",
                "__floatsisf",
                "__aeabi_fcmpgt",
                "uart_print",
                "__aeabi_fmul",
                "mpu6050_calc_pitch",
                "__addsf3",
                "HAL_GPIO_WritePin",
                "__aeabi_f2d",
                "flush_strbuf",
                "__aeabi_fcmplt",
                "strlen",
                "__floatunsisf",
                "__aeabi_fsub",
                "__fixunssfsi",
                "sprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeSystem_08005224(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUSART1();\n  initializeTIM2();\n  initializeTIM1();\n  ptr_i2c_write_reg = _i2c_write_reg + 1;\n  ptr_i2c_read_reg = _i2c_read_reg + 1;\n  ptr_get_ms_tick = _get_ms_tick + 1;\n  startTimerPWM(&timer1,0);\n  startTimerPWM(&timer1,0xc);\n  accelerometer_init(&accelerometer);\n  startTimerBaseIT(&timer2);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUSART1",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "I2C_Write_Reg": "ptr_i2c_write_reg",
                "I2C_Read_Reg": "ptr_i2c_read_reg",
                "Get_ms_tick": "ptr_get_ms_tick",
                "HAL_TIM_PWM_Start": "startTimerPWM",
                "htim1": "timer1",
                "mpu6050": "accelerometer",
                "HAL_TIM_Base_Start_IT": "startTimerBaseIT",
                "htim2": "timer2",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "HAL_TIM_PWM_Start",
                "MX_GPIO_Init",
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "HAL_TIM_Base_Start_IT",
                "startForkserver",
                "SystemClock_Config",
                "HAL_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "mpu6050_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "configure_clocks_080052a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureClocks_080052a0(void)\n\n{\n  HAL_Status status;\n  uint32 uVar2;\n  ClockInitTypeDef ClkInitStruct;\n  OscInitTypeDef oscInitStruct;\n  \n  oscInitStruct.oscillatorType = 1;\n  oscInitStruct.HSEState = 0x10000;\n  oscInitStruct.HSEPredivValue = 0;\n  oscInitStruct.HSIState = 1;\n  oscInitStruct.PLLState = 2;\n  oscInitStruct.PLLSource = 0x10000;\n  oscInitStruct.PLLMUL = 0x1c0000;\n  status = configureOscillator(&oscInitStruct);\n  if (status != HAL_OK) {\n    reportError(\"../src/main.c\",0x151);\n  }\n  ClkInitStruct.ClockType = 0xf;\n  ClkInitStruct.SYSCLKSource = 2;\n  ClkInitStruct.AHBCLKDivider = 0x80;\n  ClkInitStruct.APB1CLKDivider = 0;\n  ClkInitStruct.APB2CLKDivider = 0;\n  status = configureClock(&ClkInitStruct,2);\n  if (status != HAL_OK) {\n    reportError(\"../src/main.c\",0x15e);\n  }\n  uVar2 = getHCLKFrequency();\n  configureSysTick(uVar2 / 1000);\n  configureSysTickClockSource(4);\n  setSysTickPriority(SysTickInterruptNumber,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "configure_clocks_080052a0",
                "HAL_StatusTypeDef": "HAL_Status",
                "HVar1": "status",
                "uint32_t": "uint32",
                "RCC_ClkInitTypeDef": "ClockInitTypeDef",
                "RCC_OscInitTypeDef": "OscInitTypeDef",
                "RCC_OscInitStruct": "oscInitStruct",
                "RCC_OscInitStruct.OscillatorType": "oscInitStruct.oscillatorType",
                "RCC_OscInitStruct.HSEState": "oscInitStruct.HSEState",
                "RCC_OscInitStruct.HSEPredivValue": "oscInitStruct.HSEPredivValue",
                "RCC_OscInitStruct.HSIState": "oscInitStruct.HSIState",
                "RCC_OscInitStruct.PLL.PLLState": "oscInitStruct.PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "oscInitStruct.PLLSource",
                "RCC_OscInitStruct.PLL.PLLMUL": "oscInitStruct.PLLMUL",
                "_Error_Handler": "reportError",
                "RCC_ClkInitStruct": "ClkInitStruct",
                "RCC_ClkInitStruct.ClockType": "ClkInitStruct.ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "ClkInitStruct.SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "ClkInitStruct.AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "ClkInitStruct.APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "ClkInitStruct.APB2CLKDivider",
                "HAL_RCC_OscConfig": "configureOscillator",
                "HAL_RCC_ClockConfig": "configureClock",
                "HAL_RCC_GetHCLKFreq": "getHCLKFrequency",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_SYSTICK_CLKSourceConfig": "configureSysTickClockSource",
                "HAL_NVIC_SetPriority": "setSysTickPriority",
                "SysTick_IRQn": "SysTickInterruptNumber"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "_Error_Handler",
                "HAL_RCC_OscConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_08005348(void)\n\n{\n  HAL_StatusTypeDef initStatus;\n  \n  i2cHandle.Instance = (I2C_TypeDef *)0x40005400;\n  i2cHandle.Init.ClockSpeed = 400000;\n  i2cHandle.Init.DutyCycle = 0;\n  i2cHandle.Init.OwnAddress1 = 0;\n  i2cHandle.Init.AddressingMode = 0x4000;\n  i2cHandle.Init.DualAddressMode = 0;\n  i2cHandle.Init.OwnAddress2 = 0;\n  i2cHandle.Init.GeneralCallMode = 0;\n  i2cHandle.Init.NoStretchMode = 0;\n  initStatus = HAL_I2C_Init(&i2cHandle);\n  if (initStatus != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "hi2c1": "i2cHandle",
                "HVar1": "initStatus"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timers_080053b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimers_080053b0(void)\n\n{\n  Status status;\n  BreakDeadTimeConfig breakDeadTimeConfig;\n  OCInit configOC;\n  MasterConfig masterConfig;\n  ClockSourceConfig clockSourceConfig;\n  \n  timer1.Instance = (TIM_TypeDef *)0x40012c00;\n  timer1.Init.Prescaler = 0x708;\n  timer1.Init.CounterMode = 0;\n  timer1.Init.Period = 100;\n  timer1.Init.ClockDivision = 0;\n  timer1.Init.RepetitionCounter = 0;\n  timer1.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&timer1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  clockSourceConfig.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&timer1,&clockSourceConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  status = HAL_TIM_PWM_Init(&timer1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  masterConfig.MasterOutputTrigger = 0;\n  masterConfig.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&timer1,&masterConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  configOC.OCMode = 0x60;\n  configOC.Pulse = 0;\n  configOC.OCPolarity = 0;\n  configOC.OCNPolarity = 0;\n  configOC.OCFastMode = 0;\n  configOC.OCIdleState = 0;\n  configOC.OCNIdleState = 0;\n  status = HAL_TIM_PWM_ConfigChannel(&timer1,&configOC,0);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  status = HAL_TIM_PWM_ConfigChannel(&timer1,&configOC,0xc);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  breakDeadTimeConfig.OffStateRunMode = 0;\n  breakDeadTimeConfig.OffStateIDLEMode = 0;\n  breakDeadTimeConfig.LockLevel = 0;\n  breakDeadTimeConfig.DeadTime = 0;\n  breakDeadTimeConfig.BreakState = 0;\n  breakDeadTimeConfig.BreakPolarity = 0x2000;\n  breakDeadTimeConfig.AutomaticOutput = 0;\n  status = HAL_TIMEx_ConfigBreakDeadTime(&timer1,&breakDeadTimeConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&timer1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timers_080053b0",
                "HAL_StatusTypeDef": "Status",
                "TIM_BreakDeadTimeConfigTypeDef": "BreakDeadTimeConfig",
                "TIM_OC_InitTypeDef": "OCInit",
                "TIM_MasterConfigTypeDef": "MasterConfig",
                "TIM_ClockConfigTypeDef": "ClockSourceConfig",
                "htim1": "timer1",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "sConfigOC": "configOC",
                "sMasterConfig": "masterConfig",
                "sClockSourceConfig": "clockSourceConfig",
                "HVar1": "status"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_Init",
                "_Error_Handler",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08005500(void)\n\n{\n  Status status;\n  MasterConfig configMaster;\n  ClockConfig configClockSource;\n  \n  timer2.Instance = (TIM_TypeDef *)0x40000000;\n  timer2.Init.Prescaler = 36000;\n  timer2.Init.CounterMode = 0;\n  timer2.Init.Period = 0x14;\n  timer2.Init.ClockDivision = 0;\n  timer2.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&timer2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  configClockSource.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&timer2,&configClockSource);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  configMaster.MasterOutputTrigger = 0x20;\n  configMaster.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&timer2,&configMaster);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "HAL_StatusTypeDef": "Status",
                "TIM_MasterConfigTypeDef": "MasterConfig",
                "TIM_ClockConfigTypeDef": "ClockConfig",
                "htim2": "timer2",
                "HVar1": "status",
                "sMasterConfig": "configMaster",
                "sClockSourceConfig": "configClockSource"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "_Error_Handler",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08005598(void)\n\n{\n  HAL_Status status;\n  \n  uart_instance.Instance = (UART_TypeDef *)0x40013800;\n  uart_instance.Init.BaudRate = 0x1c200;\n  uart_instance.Init.WordLength = 0;\n  uart_instance.Init.StopBits = 0;\n  uart_instance.Init.Parity = 0;\n  uart_instance.Init.Mode = 0xc;\n  uart_instance.Init.HwFlowCtl = 0;\n  uart_instance.Init.OverSampling = 0;\n  status = HAL_UART_Init(&uart_instance);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "huart1": "uart_instance",
                "HAL_StatusTypeDef": "HAL_Status",
                "HVar1": "status",
                "USART_TypeDef": "UART_TypeDef"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_pins_080055f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_GPIO_pins_080055f4(void)\n\n{\n  uint32_t temporary_register_2;\n  uint32_t temporary_register_1;\n  uint32_t temporary_register;\n  GPIO_InitTypeDef GPIO_initialization_structure;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,0x1e,GPIO_PIN_RESET);\n  GPIO_initialization_structure.Pin = 0x1e;\n  GPIO_initialization_structure.Mode = 1;\n  GPIO_initialization_structure.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&GPIO_initialization_structure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_pins_080055f4",
                "tmpreg_2": "temporary_register_2",
                "tmpreg_1": "temporary_register_1",
                "tmpreg": "temporary_register",
                "GPIO_InitStruct": "GPIO_initialization_structure"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(char *filePath,int lineNumber)\n\n{\n  int localLineNumber;\n  char *localFilePath;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674",
                "file": "filePath",
                "line": "lineNumber",
                "line_local": "localLineNumber",
                "file_local": "localFilePath"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "SystemClock_Config",
                "MX_TIM1_Init",
                "MX_I2C1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_timer_gpio_08005680",
            "code": "\nvoid initialize_timer_gpio_08005680(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *local_timer_handle;\n  GPIO_InitTypeDef gpio_init;\n  \n  if (timer_handle->timer_instance == (TIM_TypeDef *)0x40012c00) {\n    gpio_pin = 0x900;\n    gpio_mode = 2;\n    gpio_speed = 2;\n    initialize_gpio((GPIO_TypeDef *)0x40010800,&gpio_init);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_timer_gpio_08005680",
                "htim": "timer_handle",
                "htim_local": "local_timer_handle",
                "GPIO_InitStruct": "gpio_init",
                "Instance": "timer_instance",
                "GPIO_InitStruct.Pin": "gpio_pin",
                "GPIO_InitStruct.Mode": "gpio_mode",
                "GPIO_InitStruct.Speed": "gpio_speed",
                "HAL_GPIO_Init": "initialize_gpio"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056bc": {
            "entrypoint": "0x080056bc",
            "current_name": "FUNC_080056bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056bc": "FUNC_080056bc"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056c8": {
            "entrypoint": "0x080056c8",
            "current_name": "infinite_loop_080056c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056c8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056c8": "infinite_loop_080056c8"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056ce": {
            "entrypoint": "0x080056ce",
            "current_name": "infinite_loop_080056ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056ce(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056ce": "infinite_loop_080056ce"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "infinite_loop_080056d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056d4(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056d4": "infinite_loop_080056d4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056da": {
            "entrypoint": "0x080056da",
            "current_name": "infinite_loop_080056da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056da(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056da": "infinite_loop_080056da"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056e0": {
            "entrypoint": "0x080056e0",
            "current_name": "FUNC_080056e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056e0": "FUNC_080056e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056ec": {
            "entrypoint": "0x080056ec",
            "current_name": "FUNC_080056ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056ec": "FUNC_080056ec"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "FUNC_080056f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "FUNC_080056f8"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "handle_sys_tick_08005704",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTick_08005704(void)\n\n{\n  incrementSystemTick();\n  handleSysTick_08005704Interrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "handle_sys_tick_08005704",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "FUNC_08005714",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(&htim2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "FUNC_08005714"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "expand_memory_08005728",
            "code": "\nvoid * expandMemory_08005728(intptr_t memoryIncrease)\n\n{\n  undefined4 *errorPointer;\n  char *resultPointer;\n  char stackBuffer [4];\n  int increaseAmount;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &end;\n  }\n  previousHeapEnd = _sbrk::heap_end;\n  if (stackBuffer < _sbrk::heap_end + memoryIncrease) {\n    increaseAmount = memoryIncrease;\n    errorPointer = (undefined4 *)__errno();\n    *errorPointer = 0xc;\n    resultPointer = (char *)0xffffffff;\n  }\n  else {\n    resultPointer = _sbrk::heap_end;\n    _sbrk::heap_end = _sbrk::heap_end + memoryIncrease;\n  }\n  return resultPointer;\n}\n\n",
            "renaming": {
                "FUN_08005728": "expand_memory_08005728",
                "__delta": "memoryIncrease",
                "puVar1": "errorPointer",
                "pcVar2": "resultPointer",
                "acStack_18": "stackBuffer",
                "incr_local": "increaseAmount",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_registers_08005780",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_registers_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_system_080057e8",
            "code": "\nvoid initializeSystem_080057e8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8655; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&__fini_array_end + index);\n  }\n  for (ptr = &completed_8655; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_system_080057e8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005830": {
            "entrypoint": "0x08005830",
            "current_name": "run_infinite_loop_08005830",
            "code": "\nvoid runInfiniteLoop_08005830(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005830": "run_infinite_loop_08005830"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) >> 0x1f) < 0x7ff00001) &&\n     (uVar4 = param_2 & 0x7fffffff, (uVar4 | (-param_1 | param_1) >> 0x1f) < 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != 0x7ff00000)) &&\n       (uVar4 != 0x7ff00000)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if ((iVar1 < 0x3d) && ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_atan_08005838",
            "code": "\nvoid calculate_atan_08005838(uint x1,uint x2,uint y1,uint y2,double input_value)\n\n{\n  int difference;\n  undefined4 result;\n  uint condition;\n  uint abs_y2;\n  uint abs_x2;\n  undefined8 temp_result;\n  \n  abs_y2 = y2 & 0x7fffffff;\n  if (((abs_y2 | (-y1 | y1) >> 0x1f) < 0x7ff00001) &&\n     (abs_x2 = x2 & 0x7fffffff, (abs_x2 | (-x1 | x1) >> 0x1f) < 0x7ff00001)) {\n    if ((y2 + 0xc0100000 | y1) == 0) {\n      atan(input_value);\n      return;\n    }\n    condition = (int)y2 >> 0x1e & 2U | x2 >> 0x1f;\n    if (((((abs_x2 | x1) != 0) && ((abs_y2 | y1) != 0)) && (abs_y2 != 0x7ff00000)) &&\n       (abs_x2 != 0x7ff00000)) {\n      difference = (int)(abs_x2 - abs_y2) >> 0x14;\n      if ((difference < 0x3d) && ((-1 < (int)y2 || (difference + 0x3c < 0 == SCARRY4(difference,0x3c))))) {\n        __divdf3(x1,x2);\n        fabs((double)CONCAT44(result,y2));\n        atan((double)CONCAT44(result,y2));\n      }\n      if (condition != 1) {\n        if (condition == 2) {\n          temp_result = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)temp_result,(int)((ulonglong)temp_result >> 0x20));\n        }\n        else if (condition != 0) {\n          temp_result = __subdf3();\n          __subdf3((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(y1,y2,x1,x2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_atan_08005838",
                "param_1": "x1",
                "param_2": "x2",
                "param_3": "y1",
                "param_4": "y2",
                "param_5": "input_value",
                "iVar1": "difference",
                "unaff_r4": "result",
                "uVar2": "condition",
                "uVar3": "abs_y2",
                "uVar4": "abs_x2",
                "uVar5": "temp_result"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_exp_function_080059f0",
            "code": "\ndouble calculate_exp_function_080059f0(double input_value)\n\n{\n  int temp_variable_0;\n  undefined4 temp_variable_2;\n  undefined4 temp_variable_3;\n  uint temp_variable_1;\n  undefined4 temp_variable_6;\n  undefined4 temp_variable_7;\n  undefined4 temp_variable_8;\n  undefined4 temp_variable_4;\n  undefined4 temp_variable_5;\n  undefined4 temp_variable_9;\n  undefined4 temp_variable_10;\n  uint temp_variable_11;\n  int temp_variable_12;\n  double result_0;\n  double result_1;\n  double result_2;\n  undefined8 temp_variable_13;\n  undefined8 temp_variable_14;\n  \n  temp_variable_13 = CONCAT44(temp_variable_1,temp_variable_0);\n  temp_variable_11 = temp_variable_1 & 0x7fffffff;\n  if (temp_variable_11 < 0x44100000) {\n    if (temp_variable_11 < 0x3fdc0000) {\n      if (temp_variable_11 < 0x3e200000) {\n        temp_variable_14 = __aeabi_dadd(temp_variable_0,temp_variable_1,0x8800759c,0x7e37e43c);\n        temp_variable_12 = __aeabi_dcmpgt((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),0,0x3ff00000);\n        if (temp_variable_12 != 0) {\n          return result_2;\n        }\n      }\n      temp_variable_12 = -1;\n    }\n    else {\n      fabs((double)CONCAT44(temp_variable_5,temp_variable_4));\n      if (temp_variable_11 < 0x3ff30000) {\n        if (temp_variable_11 < 0x3fe60000) {\n          temp_variable_13 = __aeabi_dadd();\n          temp_variable_13 = __subdf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),0,0x3ff00000);\n          temp_variable_14 = __aeabi_dadd(temp_variable_0,temp_variable_8,0,0x40000000);\n          temp_variable_13 = __divdf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),(int)temp_variable_14,\n                            (int)((ulonglong)temp_variable_14 >> 0x20));\n          temp_variable_12 = 0;\n        }\n        else {\n          temp_variable_13 = __subdf3();\n          temp_variable_14 = __aeabi_dadd(temp_variable_0,temp_variable_8,0,0x3ff00000);\n          temp_variable_13 = __divdf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),(int)temp_variable_14,\n                            (int)((ulonglong)temp_variable_14 >> 0x20));\n          temp_variable_12 = 1;\n        }\n      }\n      else if (temp_variable_11 < 0x40038000) {\n        temp_variable_13 = __subdf3();\n        temp_variable_14 = __muldf3(temp_variable_0,temp_variable_8,0,0x3ff80000);\n        temp_variable_14 = __aeabi_dadd((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),0,0x3ff00000);\n        temp_variable_13 = __divdf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),(int)temp_variable_14,\n                          (int)((ulonglong)temp_variable_14 >> 0x20));\n        temp_variable_12 = 2;\n      }\n      else {\n        temp_variable_13 = __divdf3(0,0xbff00000,temp_variable_0,temp_variable_8);\n        temp_variable_12 = 3;\n      }\n    }\n    temp_variable_10 = (undefined4)((ulonglong)temp_variable_13 >> 0x20);\n    temp_variable_9 = (undefined4)temp_variable_13;\n    temp_variable_13 = __muldf3(temp_variable_9,temp_variable_10,temp_variable_9,temp_variable_10);\n    temp_variable_6 = (undefined4)((ulonglong)temp_variable_13 >> 0x20);\n    temp_variable_2 = (undefined4)temp_variable_13;\n    temp_variable_13 = __muldf3(temp_variable_2,temp_variable_6,temp_variable_2,temp_variable_6);\n    temp_variable_7 = (undefined4)((ulonglong)temp_variable_13 >> 0x20);\n    temp_variable_3 = (undefined4)temp_variable_13;\n    temp_variable_13 = __muldf3(temp_variable_3,temp_variable_7,0xe322da11,0x3f90ad3a);\n    temp_variable_13 = __aeabi_dadd((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp_variable_13 = __muldf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_13 = __aeabi_dadd((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp_variable_13 = __muldf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_13 = __aeabi_dadd((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp_variable_13 = __muldf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_13 = __aeabi_dadd((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),0x920083ff,0x3fc24924);\n    temp_variable_13 = __muldf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_13 = __aeabi_dadd((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),0x5555550d,0x3fd55555);\n    temp_variable_13 = __muldf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_2,temp_variable_6);\n    temp_variable_14 = __muldf3(temp_variable_3,temp_variable_7,0x2c6a6c2f,0xbfa2b444);\n    temp_variable_14 = __subdf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp_variable_14 = __muldf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_14 = __subdf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp_variable_14 = __muldf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_14 = __subdf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp_variable_14 = __muldf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_14 = __subdf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp_variable_14 = __muldf3((int)temp_variable_14,(int)((ulonglong)temp_variable_14 >> 0x20),temp_variable_3,temp_variable_7);\n    temp_variable_13 = __aeabi_dadd((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),(int)temp_variable_14,\n                          (int)((ulonglong)temp_variable_14 >> 0x20));\n    temp_variable_13 = __muldf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_9,temp_variable_10);\n    temp_variable_2 = (undefined4)((ulonglong)temp_variable_13 >> 0x20);\n    if (temp_variable_12 == -1) {\n      result_1 = (double)__subdf3(temp_variable_9,temp_variable_10,(int)temp_variable_13,temp_variable_2);\n      return result_1;\n    }\n    temp_variable_12 = temp_variable_12 * 8;\n    temp_variable_13 = __subdf3((int)temp_variable_13,temp_variable_2,*(undefined4 *)(&atanlo + temp_variable_12),\n                      *(undefined4 *)(&UNK_08009eec + temp_variable_12));\n    temp_variable_13 = __subdf3((int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20),temp_variable_9,temp_variable_10);\n    result_1 = (double)__subdf3(*(undefined4 *)(&atanhi + temp_variable_12),*(undefined4 *)(&UNK_08009ecc + temp_variable_12)\n                             ,(int)temp_variable_13,(int)((ulonglong)temp_variable_13 >> 0x20));\n    if ((int)temp_variable_1 < 0) {\n      return result_1;\n    }\n  }\n  else {\n    if ((temp_variable_11 < 0x7ff00001) && ((temp_variable_11 != 0x7ff00000 || (temp_variable_0 == 0)))) {\n      return result_0;\n    }\n    result_1 = (double)__aeabi_dadd();\n  }\n  return result_1;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_exp_function_080059f0",
                "__x": "input_value",
                "in_r0": "temp_variable_0",
                "in_r1": "temp_variable_1",
                "uVar1": "temp_variable_2",
                "uVar2": "temp_variable_3",
                "in_r3": "temp_variable_4",
                "unaff_r4": "temp_variable_5",
                "uVar3": "temp_variable_6",
                "uVar4": "temp_variable_7",
                "extraout_r1": "temp_variable_8",
                "uVar5": "temp_variable_9",
                "uVar6": "temp_variable_10",
                "uVar7": "temp_variable_11",
                "iVar8": "temp_variable_12",
                "in_d0": "result_0",
                "dVar9": "result_1",
                "extraout_d0": "result_2",
                "uVar10": "temp_variable_13",
                "uVar11": "temp_variable_14"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "fabs",
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "calculate_double_08005d0c",
            "code": "\ndouble calculate_double_08005d0c(double input_num)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "calculate_double_08005d0c",
                "__x": "input_num",
                "in_d0": "result"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_impure_pointer_08005d14",
            "code": "\nundefined4 getImpurePointer_08005d14(void)\n\n{\n  return impurePointer;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_impure_pointer_08005d14",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_pre_init_array_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initializePreInitArray_08005d20(EVP_PKEY_CTX *ctx)\n\n{\n  int counter;\n  code **functionPointer;\n  \n  _init(ctx);\n  counter = 0;\n  functionPointer = (code **)&__preinit_array_end;\n  do {\n    counter = counter + 1;\n    (**functionPointer)();\n    functionPointer = functionPointer + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_pre_init_array_08005d20",
                "param_1": "ctx",
                "iVar1": "counter",
                "ppcVar2": "functionPointer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "register_fini",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_08005d68",
            "code": "\nvoid * memset_08005d68(void *ptr,int value,size_t num_bytes)\n\n{\n  uint *dest;\n  uint *src;\n  uint *temp;\n  uint remaining_bytes;\n  uint fill_value;\n  bool is_zero;\n  \n  src = (uint *)ptr;\n  if (((uint)ptr & 3) != 0) {\n    remaining_bytes = num_bytes - 1;\n    dest = (uint *)ptr;\n    if (num_bytes == 0) {\n      return ptr;\n    }\n    while( true ) {\n      src = (uint *)((int)dest + 1);\n      *(char *)dest = (char)value;\n      num_bytes = remaining_bytes;\n      if (((uint)src & 3) == 0) break;\n      is_zero = remaining_bytes == 0;\n      remaining_bytes = remaining_bytes - 1;\n      dest = src;\n      if (is_zero) {\n        return ptr;\n      }\n    }\n  }\n  if (3 < num_bytes) {\n    fill_value = value & 0xffU | (value & 0xffU) << 8;\n    fill_value = fill_value | fill_value << 0x10;\n    remaining_bytes = num_bytes;\n    dest = src;\n    if (0xf < num_bytes) {\n      remaining_bytes = num_bytes - 0x10;\n      dest = src + 4;\n      do {\n        dest[-4] = fill_value;\n        dest[-3] = fill_value;\n        dest[-2] = fill_value;\n        dest[-1] = fill_value;\n        dest = dest + 4;\n      } while (dest != (uint *)((int)src + (remaining_bytes & 0xfffffff0) + 0x20));\n      num_bytes = num_bytes & 0xf;\n      src = src + ((remaining_bytes >> 4) + 1) * 4;\n      remaining_bytes = num_bytes;\n      dest = src;\n      if (num_bytes < 4) goto LAB_08005de4;\n    }\n    do {\n      num_bytes = num_bytes - 4;\n      *src = fill_value;\n      src = src + 1;\n    } while (3 < num_bytes);\n    src = (uint *)((int)dest + (remaining_bytes - 4 & 0xfffffffc) + 4);\n    num_bytes = remaining_bytes & 3;\n  }\nLAB_08005de4:\n  if (num_bytes != 0) {\n    dest = src;\n    do {\n      temp = (uint *)((int)dest + 1);\n      *(char *)dest = (char)value;\n      dest = temp;\n    } while ((uint *)(num_bytes + (int)src) != temp);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_08005d68",
                "__s": "ptr",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "dest",
                "puVar2": "src",
                "puVar3": "temp",
                "uVar4": "remaining_bytes",
                "uVar5": "fill_value",
                "bVar6": "is_zero"
            },
            "calling": [
                "flush_strbuf",
                "_calloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "print_formatted_string_08005dfc",
            "code": "\nint printFormattedString_08005dfc(char *stringBuffer,char *formatString,...)\n\n{\n  int returnValue;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *stringArray [2];\n  undefined4 bufferSize;\n  undefined4 stackValue1;\n  char *currentString;\n  undefined4 maxBufferSize;\n  undefined4 registerValue1;\n  undefined4 registerValue2;\n  \n  maxBufferSize = 0x7fffffff;\n  bufferSize = 0x7fffffff;\n  stackValue1 = 0xffff0208;\n  stringArray[0] = stringBuffer;\n  currentString = stringBuffer;\n  registerValue1 = in_r2;\n  registerValue2 = in_r3;\n  returnValue = _svfprintf_r(_impure_ptr,stringArray,formatString,&registerValue1);\n  *stringArray[0] = '\\0';\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "print_formatted_string_08005dfc",
                "__s": "stringBuffer",
                "__format": "formatString",
                "local_80": "stringArray",
                "local_78": "bufferSize",
                "uStack_74": "stackValue1",
                "local_70": "currentString",
                "local_6c": "maxBufferSize",
                "uStack_8": "registerValue1",
                "uStack_4": "registerValue2",
                "iVar1": "returnValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "find_start_of_word_08005e40",
            "code": "\nsize_t find_start_of_word_08005e40(char *str)\n\n{\n  int padding;\n  uint *start_word;\n  uint word_bits;\n  \n  start_word = (uint *)((uint)str & 0xfffffffc);\n  padding = -((uint)str & 3);\n  word_bits = *start_word;\n  if (((uint)str & 3) != 0) {\n    word_bits = word_bits | 0xffffffffU >> ((padding + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    start_word = start_word + 1;\n    word_bits = word_bits + 0xfefefeff & ~word_bits & 0x80808080;\n    if (word_bits != 0) break;\n    word_bits = *start_word;\n    padding = padding + 4;\n  }\n  return padding + (0x1fU - LZCOUNT(word_bits & -word_bits) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "find_start_of_word_08005e40",
                "__s": "str",
                "iVar1": "padding",
                "puVar2": "start_word",
                "uVar3": "word_bits"
            },
            "calling": [
                "_svfprintf_r",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int *piVar3;\n  int iVar4;\n  void *pvVar5;\n  int iVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  byte *pbVar9;\n  char cVar10;\n  byte bVar11;\n  int *piVar12;\n  int **ppiVar13;\n  undefined uVar14;\n  ushort uVar15;\n  int *__s;\n  int **ppiVar16;\n  byte **ppbVar17;\n  int *piVar18;\n  int *piVar19;\n  int **ppiVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *pbVar23;\n  int *piVar24;\n  uint uVar25;\n  uint uVar26;\n  int *piVar27;\n  int *piVar28;\n  byte *pbVar29;\n  bool bVar30;\n  longlong lVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_fffffe78;\n  int *in_stack_fffffe7c;\n  int *local_168;\n  byte *local_164;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  int *local_150;\n  int *local_148;\n  int local_144;\n  uint local_140;\n  int local_13c;\n  int *local_138;\n  int *local_134;\n  int local_130;\n  int *local_12c;\n  int *local_128;\n  char *local_11c;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0 [2];\n  undefined4 local_e8;\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int local_d4;\n  byte *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  ppiVar2 = (int **)_localeconv_r();\n  __s = *ppiVar2;\n  piVar3 = (int *)strlen((char *)__s);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar4 = _malloc_r(param_1,0x40);\n    *param_2 = iVar4;\n    param_2[4] = iVar4;\n    if (iVar4 == 0) {\n      *param_1 = 0xc;\n      return (byte *)0xffffffff;\n    }\n    param_2[5] = 0x40;\n  }\n  local_128 = (int *)0x0;\n  local_138 = (int *)0x0;\n  local_12c = (int *)0x0;\n  local_d4 = 0;\n  local_d0 = (byte *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\n  local_154 = param_4;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = local_d4 + 1;\n        local_d0 = (byte *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if (local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = (byte *)((int)local_164 + (int)piVar27);\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    uVar26 = 0;\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    local_158 = (char *)piVar27;\n    switch(uVar25) {\n    case 0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (uVar25 == 0) goto LAB_08006216;\n      piVar18 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_158 = (char *)0x1;\n      param_3 = (int *)&local_8c;\n      piVar24 = piVar18;\n      local_8c = (char)uVar25;\n      goto LAB_08006298;\n    case 0x23:\n      uVar26 = uVar26 | 1;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x27:\n      iVar4 = _localeconv_r(param_1);\n      local_110 = *(int **)(iVar4 + 4);\n      local_104 = (int *)strlen((char *)local_110);\n      iVar4 = _localeconv_r(param_1);\n      local_108 = *(byte **)(iVar4 + 8);\n      if (local_104 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      uVar25 = (uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        uVar26 = uVar26 | 0x400;\n      }\n      goto LAB_08005f4a;\n    case 0x2a:\n      uVar25 = (uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case 0x2b:\n      local_f5 = 0x2b;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x2d:\n      uVar25 = (uint)*(byte *)piVar28;\nLAB_08006602:\n      uVar26 = uVar26 | 4;\n      goto LAB_08005f4a;\n    case 0x2e:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x2a) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (uVar25 - 0x30 < 10) {\n        piVar27 = (int *)((uVar25 - 0x30) + (int)piVar27 * 10);\n        uVar25 = (uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case 0x30:\n      uVar26 = uVar26 | 0x80;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_08005f58_caseD_31;\n    case 0x41:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x61:\n    case 0x65:\n    case 0x66:\n    case 0x67:\n      local_154 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      local_128 = *local_154;\n      local_12c = local_154[1];\n      local_154 = local_154 + 2;\n      iVar4 = __unorddf2(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff);\n      if ((iVar4 == 0) &&\n         (iVar4 = __aeabi_dcmple(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff),\n         iVar4 == 0)) {\n        iVar4 = __aeabi_dcmplt(local_128,local_12c,0,0);\n        if (iVar4 == 0) {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        param_3 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (uVar25 < 0x48) {\n          param_3 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        local_140 = uVar26 & 0xffffff7f;\n        local_158 = (char *)0x3;\n        local_13c = 0;\n        piVar24 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar4 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar4 != 0) {\n        if ((int)local_12c < 0) {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        param_3 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      piVar24 = local_12c;\n      if (uVar25 == 0x61) {\n        uVar14 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar14,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = uVar26 | 0x102;\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          uVar26 = uVar26 | 2;\n        }\n        else {\n          param_3 = (int *)_malloc_r(param_1,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar15 = *(ushort *)(param_2 + 3) | 0x40;\n            *(ushort *)(param_2 + 3) = uVar15;\n            goto LAB_0800604e;\n          }\n          local_140 = uVar26 | 0x102;\n          uVar26 = uVar26 | 2;\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = 0x2d;\n          piVar24 = local_12c + -0x20000000;\n        }\n        else {\n          local_144 = 0;\n        }\n        if (uVar25 == 0x61) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 != 0) {\n            local_f0[0] = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_138 = param_3;\n          piVar24 = piVar27;\n          goto LAB_080072ba;\n        }\n        if (uVar25 == 0x41) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          else {\n            local_f0[0] = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (uVar25 == 0x41) {\n          uVar14 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = uVar26 | 0x100;\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if ((uVar25 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = 0;\n      }\n      local_168 = (int *)(uVar25 & 0xffffffdf);\n      in_stack_fffffe7c = piVar27;\n      local_150 = piVar27;\n      if (uVar25 == 0x66) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        piVar18 = (int *)((int)param_3 + (int)piVar27);\nLAB_0800764c:\n        if ((*(byte *)param_3 == 0x30) &&\n           (iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0), iVar4 == 0)) {\n          local_f0[0] = (int *)(1 - (int)local_150);\n        }\n        piVar18 = (int *)((int)piVar18 + (int)local_f0[0]);\n      }\n      else if (uVar25 == 0x46) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\nLAB_08007760:\n        piVar18 = (int *)((int)param_3 + (int)local_150);\n        if (uVar25 == 0x46) goto LAB_0800764c;\n      }\n      else {\n        if (local_168 == (int *)0x45) {\n          local_150 = (int *)((int)piVar27 + 1);\n        }\n        in_stack_fffffe78 = 2;\n        in_stack_fffffe7c = local_150;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        local_138 = local_e0;\n        if (uVar25 == 0x67) {\n          if ((uVar26 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (uVar25 == 0x47) {\n          if ((uVar26 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar18 = (int *)((int)local_150 + (int)param_3);\n      }\n      iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0);\n      local_138 = piVar18;\n      if (iVar4 == 0) {\n        for (; local_138 = local_e0, local_e0 < piVar18; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)local_138 - (int)param_3);\n      goto LAB_08006cb0;\n    case 0x43:\n    case 99:\n      piVar18 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar24 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      param_3 = (int *)&local_8c;\n      goto LAB_08006298;\n    case 0x44:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bcc:\n        piVar24 = *local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(int)*(short *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bcc;\n        piVar24 = (int *)(int)*(char *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      goto LAB_08006102;\n    case 0x4c:\n      uVar26 = uVar26 | 8;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x4f:\n      uVar26 = uVar26 | 0x10;\n    case 0x6f:\n      if ((uVar26 & 0x20) == 0) {\n        ppiVar16 = local_154 + 1;\n        if ((uVar26 & 0x10) == 0) {\n          if ((uVar26 & 0x40) == 0) {\n            if ((uVar26 & 0x200) == 0) goto LAB_08006be2;\n            piVar24 = (int *)(uint)*(byte *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n          else {\n            piVar24 = (int *)(uint)*(ushort *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar24 = *local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\n        ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar24 = *ppiVar16;\n        piVar18 = ppiVar16[1];\n        local_154 = ppiVar16 + 2;\n      }\n      iVar4 = 0;\n      uVar26 = uVar26 & 0xfffffbff;\n      break;\n    case 0x53:\n    case 0x73:\n      local_f5 = 0;\n      param_3 = *local_154;\n      local_154 = local_154 + 1;\n      local_140 = uVar26;\n      if (param_3 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        param_3 = (int *)&UNK_08009f44;\n        piVar18 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar24 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen((char *)param_3);\n        }\n        else {\n          pvVar5 = memchr(param_3,0,(size_t)piVar27);\n          if (pvVar5 == (void *)0x0) {\n            piVar18 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = 0;\n            local_134 = (int *)0x0;\n            local_130 = 0;\n            piVar24 = (int *)0x0;\n            local_168 = piVar27;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)((int)pvVar5 - (int)param_3);\n        }\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar18 = (int *)(uint)local_f5;\n        piVar24 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_08006538;\n    case 0x55:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bf2:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(uint)*(ushort *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bf2;\n        piVar24 = (int *)(uint)*(byte *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      break;\n    case 0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if ((uVar26 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar16 = local_154 + 1;\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) == 0) {\n          if ((uVar26 & 0x200) == 0) goto LAB_08006bbc;\n          piVar24 = (int *)(uint)*(byte *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n        else {\n          piVar24 = (int *)(uint)*(ushort *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        local_154 = ppiVar16;\n      }\n      goto LAB_080061be;\n    case 100:\n    case 0x69:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_08006102:\n      if ((int)piVar18 < 0) {\n        bVar30 = piVar24 != (int *)0x0;\n        piVar24 = (int *)-(int)piVar24;\n        piVar18 = (int *)(-(int)piVar18 - (uint)bVar30);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar4 = 1;\n        iVar6 = 1;\n        local_140 = uVar26 & 0xffffff7f;\n        if (((uint)piVar24 | (uint)piVar18) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      local_140 = uVar26;\n      if (piVar18 != (int *)0x0 || (int *)0x9 < piVar24) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case 0x68:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x68) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        uVar26 = uVar26 | 0x200;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        uVar26 = uVar26 | 0x40;\n      }\n      goto LAB_08005f4a;\n    case 0x6a:\n    case 0x71:\n      uVar26 = uVar26 | 0x20;\n    case 0x74:\n    case 0x7a:\nswitchD_08005f58_caseD_74:\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case 0x6e:\n      ppiVar16 = local_154 + 1;\n      ppbVar17 = (byte **)*local_154;\n      local_154 = ppiVar16;\n      if ((uVar26 & 0x20) != 0) {\n        *ppbVar17 = local_164;\n        ppbVar17[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) != 0) {\n          *(short *)ppbVar17 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if ((uVar26 & 0x200) != 0) {\n          *(char *)ppbVar17 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar17 = local_164;\n      goto LAB_0800620e;\n    case 0x70:\n      local_f4 = 0x7830;\n      piVar24 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      uVar26 = uVar26 | 2;\n      piVar18 = (int *)0x0;\n      iVar4 = 2;\n      uVar25 = 0x78;\n      local_154 = local_154 + 1;\n      break;\n    case 0x75:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      iVar4 = 1;\n      local_154 = ppiVar16 + 2;\n      break;\n    case 0x78:\n      local_11c = \"0123456789abcdef\";\n      if ((uVar26 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_080061be:\n      if (((uVar26 & 1) != 0) && (((uint)piVar24 | (uint)piVar18) != 0)) {\n        uVar26 = uVar26 | 2;\n        local_f4 = CONCAT11((char)uVar25,0x30);\n      }\n      iVar4 = 2;\n      uVar26 = uVar26 & 0xfffffbff;\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      local_140 = uVar26;\n      if (iVar4 != 1) goto LAB_08006136;\nLAB_08006980:\n      local_140 = uVar26;\n      if (piVar18 == (int *)0x0 && piVar24 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar31 = CONCAT44(piVar18,piVar24);\n      local_138 = (int *)0x0;\n      param_3 = (int *)(&bStack_2a + 2);\n      do {\n        iVar4 = (int)((ulonglong)lVar31 >> 0x20);\n        uVar26 = (uint)lVar31;\n        cVar10 = '\\n';\n        __aeabi_uldivmod(uVar26,iVar4,10,0);\n        *(byte *)((int)param_3 + -1) = cVar10 + 0x30;\n        local_138 = (int *)((int)local_138 + 1);\n        param_3 = (int *)((int)param_3 + -1);\n        if (((((local_140 & 0x400) != 0) && (local_138 == (int *)(uint)*local_108)) &&\n            (local_138 != (int *)0xff)) && (iVar4 != 0 || 9 < uVar26)) {\n          param_3 = (int *)((int)param_3 - (int)local_104);\n          strncpy((char *)param_3,(char *)local_110,(size_t)local_104);\n          if (local_108[1] == 0) {\n            local_138 = (int *)0x0;\n          }\n          else {\n            local_108 = local_108 + 1;\n            local_138 = (int *)0x0;\n          }\n        }\n        lVar31 = __aeabi_uldivmod(uVar26,iVar4,10,0);\n      } while (lVar31 != 0);\n      local_158 = (char *)((int)(&bStack_2a + 2) - (int)param_3);\n    }\n    else {\n      local_140 = uVar26 & 0xffffff7f;\n      iVar6 = iVar4;\n      if (((uint)piVar24 | (uint)piVar18) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar4 == 0) {\n            local_158 = (char *)(uVar26 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              param_3 = (int *)(&bStack_2a + 2);\n            }\n            else {\n              param_3 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n            }\n          }\n          else {\n            param_3 = (int *)(&bStack_2a + 2);\n          }\n        }\n        else {\n          if (iVar4 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar24 + '0';\n          param_3 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar4 = iVar6;\n        uVar26 = local_140;\n        if (iVar6 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar4 == 2) {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = (int *)((uint)piVar24 >> 4 | (int)piVar18 << 0x1c);\n            piVar18 = (int *)((uint)piVar18 >> 4);\n            param_3 = (int *)((int)param_3 + -1);\n            *(char *)param_3 = local_11c[(uint)piVar24 & 0xf];\n            piVar24 = piVar19;\n          } while (((uint)piVar19 | (uint)piVar18) != 0);\n        }\n        else {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = param_3;\n            piVar12 = (int *)((uint)piVar24 >> 3 | (int)piVar18 << 0x1d);\n            piVar18 = (int *)((uint)piVar18 >> 3);\n            iVar4 = ((uint)piVar24 & 7) + 0x30;\n            *(byte *)((int)piVar19 + -1) = (byte)iVar4;\n            param_3 = (int *)((int)piVar19 + -1);\n            piVar24 = piVar12;\n          } while (((uint)piVar12 | (uint)piVar18) != 0);\n          if (((local_140 & 1) != 0) && (iVar4 != 0x30)) {\n            param_3 = (int *)((int)piVar19 + -2);\n            local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n            *(byte *)((int)piVar19 + -2) = 0x30;\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  if (local_d0 == (byte *)0x0) {\nLAB_0800604a:\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\n  else {\n    __ssprint_r(param_1,param_2,&local_d8);\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\nLAB_0800604e:\n  if ((uVar15 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (uVar25 == 0x6c) {\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    uVar26 = uVar26 | 0x20;\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    uVar26 = uVar26 | 0x10;\n  }\n  goto LAB_08005f4a;\n  while (iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0), iVar6 == 0) {\nLAB_080072ba:\n    piVar18 = piVar24;\n    piVar19 = local_138;\n    piVar24 = (int *)((int)piVar18 + -1);\n    uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0x40300000);\n    iVar4 = __aeabi_d2iz();\n    uVar33 = __aeabi_i2d();\n    uVar32 = __subdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),(int)uVar33,\n                      (int)((ulonglong)uVar33 >> 0x20));\n    uVar8 = (undefined4)((ulonglong)uVar32 >> 0x20);\n    uVar7 = (undefined4)uVar32;\n    local_138 = (int *)((int)piVar19 + 1);\n    *(char *)piVar19 = local_158[iVar4];\n    if (piVar24 == (int *)0xffffffff) break;\n  }\n  iVar6 = __aeabi_dcmpgt(uVar7,uVar8,0,0x3fe00000);\n  if ((iVar6 == 0) &&\n     ((iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0x3fe00000), iVar6 == 0 || (-1 < iVar4 << 0x1f)))) {\n    if (-1 < (int)piVar24) {\n      piVar18 = (int *)((int)piVar18 + (int)local_138);\n      piVar24 = local_138;\n      do {\n        local_138 = (int *)((int)piVar24 + 1);\n        *(byte *)piVar24 = 0x30;\n        piVar24 = local_138;\n      } while (piVar18 != local_138);\n    }\n  }\n  else {\n    bVar1 = local_158[0xf];\n    bVar11 = *(byte *)piVar19;\n    piVar24 = local_138;\n    local_e0 = piVar19;\n    while (bVar1 == bVar11) {\n      *(byte *)((int)piVar24 + -1) = 0x30;\n      bVar11 = *(byte *)((int)local_e0 + -1);\n      piVar24 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar11 == 0x39) {\n      bVar11 = local_158[10];\n    }\n    else {\n      bVar11 = bVar11 + 1;\n    }\n    *(byte *)((int)piVar24 + -1) = bVar11;\n  }\n  local_138 = (int *)((int)local_138 - (int)param_3);\nLAB_08006cb0:\n  local_168 = (int *)(uVar25 & 0xffffffdf);\n  local_134 = local_f0[0];\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0[0] + 3) < 0 == SCARRY4((int)local_f0[0],3)) &&\n       ((int)local_f0[0] <= (int)piVar27)) {\n      if ((int)local_f0[0] < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)piVar3);\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0[0]));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        uVar25 = 0x67;\n      }\n      else {\n        if ((int)(uVar26 << 0x1f) < 0) {\n          local_158 = (char *)((int)local_f0[0] + (int)piVar3);\n        }\n        else {\n          local_158 = (char *)local_f0[0];\n        }\n        if (-1 < (int)(uVar26 << 0x15)) {\n          uVar25 = 0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074fc;\n        }\n        uVar25 = 0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    uVar25 = uVar25 - 2;\n    local_168 = (int *)(uVar25 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8._0_1_ = (char)uVar25;\n    if (local_168 == (int *)0x41) {\n      local_e8._0_1_ = (char)local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0[0] + -1);\n    if ((int)piVar27 < 0) {\n      local_e8._1_1_ = 0x2d;\n      local_f0[0] = (int *)(1 - (int)local_f0[0]);\n    }\n    else {\n      local_e8._1_1_ = 0x2b;\n      local_f0[0] = piVar27;\n    }\n    if ((int)local_f0[0] < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e8._2_1_ = 0x30;\n        pcVar21 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar21 = (char)local_f0[0] + '0';\n      pcVar21 = pcVar21 + 1;\n    }\n    else {\n      pbVar29 = abStack_dc + 3;\n      pbVar23 = pbVar29;\n      do {\n        pbVar9 = pbVar23;\n        piVar24 = (int *)((uint)local_f0[0] / 10);\n        pbVar9[-1] = (char)local_f0[0] + (char)piVar24 * -10 + 0x30;\n        pbVar23 = pbVar9 + -1;\n        local_f0[0] = piVar24;\n      } while ((int *)0x9 < piVar24);\n      uVar22 = (uint)(piVar24 + 0xc) & 0xff;\n      pbVar9[-2] = (byte)uVar22;\n      if (pbVar9 + -2 < pbVar29) {\n        pbVar9 = pbVar23;\n        pcVar21 = (char *)((int)&local_e8 + 2);\n        while( true ) {\n          *pcVar21 = (char)uVar22;\n          if (pbVar29 == pbVar9) break;\n          uVar22 = (uint)*pbVar9;\n          pbVar9 = pbVar9 + 1;\n          pcVar21 = pcVar21 + 1;\n        }\n        pcVar21 = (char *)(((int)&stack0xfffffe78 * 2 - (int)pbVar23) + 0x152);\n      }\n      else {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar21 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)(uVar26 << 0x1f) < 0)) {\n      local_158 = (char *)((int)local_158 + (int)piVar3);\n    }\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    local_140 = uVar26 & 0xfffffbff | 0x100;\n    local_f0[0] = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0[0] < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)piVar3 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = 0;\n      local_130 = 0;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_158 = (char *)local_f0[0];\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)local_f0[0] + (int)piVar3) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)(uVar26 << 0x15)) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = 0;\n      local_130 = 0;\n      uVar26 = (uint)*local_108;\n      while (uVar26 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar26) goto LAB_08007524;\n          uVar22 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar26);\n          if (uVar22 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = local_130 + 1;\n          uVar26 = uVar22;\n          if (uVar22 == 0xff) goto LAB_08007524;\n        }\n        local_13c = local_13c + 1;\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_104 * (local_130 + local_13c) + (int)local_158);\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    }\n  }\n  if (local_144 == 0) {\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = (int *)0x0;\nLAB_08006538:\n    uVar26 = local_140;\n    if (piVar18 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar18 = (int *)0x2d;\n    piVar24 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n    uVar26 = local_140;\n  }\nLAB_08006298:\n  if ((uVar26 & 2) != 0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  if (((uVar26 & 0x84) == 0) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        piVar18 = piVar27;\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)piVar27);\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      piVar18 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar18 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar18 != (int *)0x0) {\n    local_d0 = local_d0 + 1;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((uVar26 & 2) != 0) {\n    local_d0 = local_d0 + 2;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if (((uVar26 & 0x84) == 0x80) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        while( true ) {\n          piVar18 = piVar27;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar27 = piVar18 + -4;\n          if ((int)(piVar18 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)(piVar18 + -4));\nLAB_08006882:\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar24 = (int *)((int)piVar24 - (int)local_158);\n  if (0 < (int)piVar24) {\n    if (0x10 < (int)piVar24) {\n      do {\n        while( true ) {\n          piVar27 = piVar24;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar24 = piVar27 + -4;\n          if ((int)(piVar27 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar24 = piVar27 + -4;\n      } while (0x10 < (int)(piVar27 + -4));\nLAB_080063d2:\n      piVar24 = piVar27 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar24;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar24;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  pbVar23 = local_d0;\n  if ((uVar26 & 0x100) == 0) {\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)local_158;\n    *ppiVar2 = param_3;\n    ppiVar2[1] = (int *)local_158;\n    if (local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else if ((int)uVar25 < 0x66) {\n    local_158 = (char *)(local_d0 + 1);\n    iVar4 = local_d4 + 1;\n    ppiVar16 = ppiVar2 + 2;\n    local_d0 = (byte *)local_158;\n    if (((int)local_138 < 2) && ((uVar26 & 1) == 0)) {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      if (iVar4 < 8) {\n        local_150 = (int *)(local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = iVar4;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        local_150 = (int *)(local_d4 + 1);\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = iVar4;\n      if (7 < iVar4) {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = local_d4 + 1;\n      local_d0 = (byte *)(local_158 + (int)piVar3);\n      *ppiVar16 = __s;\n      ppiVar16[1] = piVar3;\n      if (local_d4 < 8) {\n        ppiVar20 = ppiVar16 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar20 = local_cc;\n      }\n      local_158 = (char *)local_d0;\n      iVar4 = local_d4;\n      local_150 = (int *)(local_d4 + 1);\n      piVar27 = (int *)((int)local_138 + -1);\n      ppiVar13 = ppiVar20 + 2;\n      iVar6 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n      local_d4 = (int)local_150;\n      if (iVar6 == 0) {\n        local_158 = (char *)((byte *)local_158 + (int)piVar27);\n        *ppiVar20 = (int *)((int)param_3 + 1);\n        ppiVar20[1] = piVar27;\n        local_d0 = (byte *)local_158;\n        if ((int)local_150 < 8) {\n          local_150 = (int *)(iVar4 + 2);\n          ppiVar16 = ppiVar13;\n          ppiVar2 = ppiVar20 + 4;\n        }\n        else {\nLAB_08006d9c:\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          local_150 = (int *)(local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar16 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar16 = ppiVar20;\n        ppiVar2 = ppiVar13;\n        if (0 < (int)piVar27) {\n          if (0x10 < (int)piVar27) {\n            while( true ) {\n              local_d0 = (byte *)local_158 + 0x10;\n              *ppiVar20 = (int *)0x8009f60;\n              ppiVar20[1] = (int *)0x10;\n              if (local_d4 < 8) {\n                ppiVar20 = ppiVar20 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar20 = local_cc;\n              }\n              piVar27 = piVar27 + -4;\n              local_158 = (char *)local_d0;\n              if ((int)piVar27 < 0x11) break;\n              local_d4 = local_d4 + 1;\n            }\n            local_150 = (int *)(local_d4 + 1);\n            ppiVar13 = ppiVar20 + 2;\n          }\n          *ppiVar20 = (int *)0x8009f60;\n          ppiVar20[1] = piVar27;\n          local_158 = local_158 + (int)piVar27;\n          local_d4 = (int)local_150;\n          local_d0 = (byte *)local_158;\n          if (7 < (int)local_150) goto LAB_08006d9c;\n          local_150 = (int *)((int)local_150 + 1);\n          ppiVar2 = ppiVar13 + 2;\n          ppiVar16 = ppiVar13;\n        }\n      }\n    }\n    ppiVar16[1] = local_10c;\n    local_d0 = (byte *)(local_158 + (int)local_10c);\n    local_d4 = (int)local_150;\n    *ppiVar16 = &local_e8;\n    pbVar23 = local_d0;\n    if (7 < (int)local_150) {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else {\n    iVar4 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n    if (iVar4 == 0) {\n      if ((int)local_f0[0] < 1) {\n        local_d4 = local_d4 + 1;\n        local_d0 = pbVar23 + 1;\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0[0] != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          if ((int)local_f0[0] < 0) {\n            piVar27 = (int *)-(int)local_f0[0];\n            if ((int)(local_f0[0] + 4) < 0 != SCARRY4((int)local_f0[0],0x10)) {\n              do {\n                local_d4 = local_d4 + 1;\n                local_d0 = local_d0 + 0x10;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if (local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = local_d4 + 1;\n            local_d0 = local_d0 + (int)piVar27;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = local_d0 + (int)local_138;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar27 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar27 = local_138;\n        }\n        if (0 < (int)piVar27) {\n          local_d0 = pbVar23 + (int)piVar27;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = piVar27;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar24 = local_134;\n        if (-1 < (int)piVar27) {\n          piVar24 = (int *)((int)local_134 - (int)piVar27);\n        }\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          local_d4 = local_d4 + 1;\n          pbVar23 = pbVar23 + (int)piVar24;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\n          local_d0 = pbVar23;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        local_134 = (int *)((int)local_134 + (int)param_3);\n        if ((uVar26 & 0x400) != 0) {\n          if (local_130 == 0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != 0) goto LAB_0800717e;\n          local_108 = local_108 + -1;\n          local_130 = local_130 + -1;\n          do {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + (int)local_104;\n            *ppiVar2 = local_110;\n            ppiVar2[1] = local_104;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar24 = (int *)(uint)*local_108;\n            piVar27 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n            if ((int)piVar24 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n              piVar27 = piVar24;\n            }\n            if (0 < (int)piVar27) {\n              local_d0 = local_d0 + (int)piVar27;\n              local_d4 = local_d4 + 1;\n              *ppiVar2 = local_134;\n              ppiVar2[1] = piVar27;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar24 = (int *)(uint)*local_108;\n              }\n            }\n            piVar18 = piVar24;\n            if (-1 < (int)piVar27) {\n              piVar18 = (int *)((int)piVar24 - (int)piVar27);\n            }\n            if (0 < (int)piVar18) {\n              for (; 0x10 < (int)piVar18; piVar18 = piVar18 + -4) {\n                while( true ) {\n                  local_d4 = local_d4 + 1;\n                  local_d0 = local_d0 + 0x10;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if (local_d4 < 8) break;\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  piVar18 = piVar18 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar18 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = local_d4 + 1;\n              local_d0 = local_d0 + (int)piVar18;\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar18;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = local_cc;\n              }\n            }\n            local_134 = (int *)((int)local_134 + (int)piVar24);\n            pbVar23 = local_d0;\n            if (local_130 != 0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == 0) {\n              if ((int *)((int)param_3 + (int)local_138) <= local_134) {\n                local_134 = (int *)((int)param_3 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = local_13c + -1;\n          } while( true );\n        }\n        if (((int)local_f0[0] < (int)local_138) || ((uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = pbVar23 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n        piVar24 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n        if ((int)piVar27 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n          piVar24 = piVar27;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = pbVar23 + (int)piVar24;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = local_134;\n          ppiVar2[1] = piVar24;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n            pbVar23 = local_d0;\n          }\n        }\n        if (-1 < (int)piVar24) {\n          piVar27 = (int *)((int)piVar27 - (int)piVar24);\n        }\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = local_d4 + 1;\n      local_d0 = pbVar23 + 1;\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if (local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0[0] < (int)local_138) || (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + (int)piVar3;\n        *ppiVar2 = __s;\n        ppiVar2[1] = piVar3;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = (int *)((int)local_138 + -1);\n        pbVar23 = local_d0;\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\nLAB_08007014:\n          local_d0 = pbVar23 + (int)piVar27;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar27;\njoined_r0x08006a1c:\n          local_d4 = local_d4 + 1;\n          if (7 < local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  if (((uVar26 & 4) != 0) && (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27))\n  {\n    for (; local_d0 = pbVar23, 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n      while( true ) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) break;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        piVar27 = piVar27 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar27 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    pbVar23 = local_d0;\n    if ((7 < local_d4) &&\n       (iVar4 = __ssprint_r(param_1,param_2,&local_d8), pbVar23 = local_d0, iVar4 != 0))\n    goto LAB_0800603e;\n  }\n  if ((int)local_15c < (int)local_168) {\n    local_15c = local_168;\n  }\n  local_164 = local_164 + (int)local_15c;\n  if ((pbVar23 == (byte *)0x0) || (iVar4 = __ssprint_r(param_1,param_2,&local_d8), iVar4 == 0)) {\n    local_d4 = 0;\n    if (local_148 != (int *)0x0) {\n      _free_r(param_1,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(param_1,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  uVar22 = uVar25 - 0x30;\n  piVar24 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar24 + 1);\n    uVar25 = (uint)*(byte *)piVar24;\n    local_15c = (int *)(uVar22 + (int)local_15c * 10);\n    uVar22 = uVar25 - 0x30;\n    piVar24 = piVar28;\n  } while (uVar22 < 10);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__aeabi_uldivmod",
                "_dtoa_r",
                "_localeconv_r",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__unorddf2",
                "frexp",
                "__aeabi_dcmplt",
                "__subdf3",
                "strncpy",
                "__aeabi_i2d",
                "_malloc_r",
                "strlen",
                "_free_r",
                "__muldf3",
                "__aeabi_d2iz",
                "memchr"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078b4": {
            "entrypoint": "0x080078b4",
            "current_name": "register_exit_process_080078b4",
            "code": "\nint registerExitProcess_080078b4(function *function)\n\n{\n  int result;\n  \n  result = __register_exitproc(0,function,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078b4": "register_exit_process_080078b4",
                "__func": "function",
                "iVar1": "result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_quotient_080078c0",
            "code": "\nuint calculateQuotient_080078c0(int numerator,int denominator)\n\n{\n  uint quotient;\n  uint *numeratorPtr;\n  int carry;\n  int numeratorSize;\n  int index;\n  uint result;\n  uint *denominatorPtr;\n  uint *numeratorPtr;\n  uint *denominatorEndPtr;\n  uint temp;\n  uint *denominatorPtr;\n  uint *denominatorNextPtr;\n  \n  numeratorSize = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < numeratorSize) {\n    return 0;\n  }\n  index = numeratorSize + -1;\n  denominatorPtr = (uint *)(denominator + 0x14);\n  numeratorPtr = (uint *)(numerator + 0x14);\n  result = numeratorPtr[index] / (denominatorPtr[index] + 1);\n  denominatorEndPtr = denominatorPtr + index;\n  if (result != 0) {\n    quotient = 0;\n    carry = 0;\n    numeratorPtr = numeratorPtr;\n    denominatorPtr = denominatorPtr;\n    do {\n      denominatorNextPtr = denominatorPtr + 1;\n      quotient = result * (*denominatorPtr & 0xffff) + quotient;\n      temp = result * (*denominatorPtr >> 0x10) + (quotient >> 0x10);\n      quotient = (carry - (quotient & 0xffff)) + (*numeratorPtr & 0xffff);\n      carry = ((*numeratorPtr >> 0x10) - (temp & 0xffff)) + ((int)quotient >> 0x10);\n      *numeratorPtr = quotient & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      quotient = temp >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = denominatorNextPtr;\n    } while (denominatorNextPtr <= denominatorEndPtr);\n    if (numeratorPtr[index] == 0) {\n      if ((numeratorPtr < numeratorPtr + numeratorSize + -2) && (numeratorPtr[numeratorSize + -2] == 0)) {\n        numeratorPtr = numeratorPtr + numeratorSize + -3;\n        do {\n          index = index + -1;\n          if (numeratorPtr <= numeratorPtr) break;\n          quotient = *numeratorPtr;\n          numeratorPtr = numeratorPtr + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  numeratorSize = __mcmp();\n  if (-1 < numeratorSize) {\n    numeratorSize = 0;\n    result = result + 1;\n    numeratorPtr = numeratorPtr;\n    do {\n      denominatorPtr = denominatorPtr + 1;\n      quotient = (numeratorSize - (*denominatorPtr & 0xffff)) + (*numeratorPtr & 0xffff);\n      numeratorSize = ((*numeratorPtr >> 0x10) - (*denominatorPtr >> 0x10)) + ((int)quotient >> 0x10);\n      *numeratorPtr = quotient & 0xffff | numeratorSize * 0x10000;\n      numeratorSize = numeratorSize >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = denominatorPtr;\n    } while (denominatorPtr <= denominatorEndPtr);\n    if (numeratorPtr[index] == 0) {\n      if ((numeratorPtr < numeratorPtr + index + -1) && (numeratorPtr[index + -1] == 0)) {\n        denominatorPtr = numeratorPtr + index + -2;\n        do {\n          index = index + -1;\n          if (denominatorPtr <= numeratorPtr) break;\n          quotient = *denominatorPtr;\n          denominatorPtr = denominatorPtr + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_quotient_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "uVar1": "quotient",
                "puVar2": "numeratorPtr",
                "iVar3": "carry",
                "iVar4": "numeratorSize",
                "iVar5": "index",
                "uVar6": "result",
                "puVar7": "denominatorPtr",
                "puVar8": "numeratorPtr",
                "puVar9": "denominatorEndPtr",
                "uVar10": "temp",
                "puVar11": "denominatorPtr",
                "puVar12": "denominatorNextPtr"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_double_to_string_080079e8",
            "code": "\nchar * convertDoubleToString_080079e8(int doubleValue,undefined4 param_2,uint significand,uint exponent,uint format,\n                   uint precision,int *param_7,uint *param_8,char **param_9)\n\n{\n  bool isNegative;\n  bool isZero;\n  bool isScientific;\n  char digit;\n  byte bVar5;\n  undefined4 quotient;\n  int remainder;\n  int iVar8;\n  int iVar9;\n  char *result;\n  uint uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  int exponentDiff;\n  int necessaryDigits;\n  undefined4 uVar16;\n  uint uVar17;\n  uint temp;\n  int shift;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int iVar24;\n  bool isZero5;\n  undefined8 currentValue;\n  undefined8 tempValue;\n  undefined8 uVar28;\n  uint powerOfTen;\n  uint localExponent;\n  uint numDigits;\n  int numLeadingZeros;\n  uint numDecimals;\n  int exp10;\n  int numExpDigits;\n  uint numSignificantDigits;\n  uint precisionBits;\n  uint local_4;\n  uint maxDigits;\n  uint local_34;\n  int precisionExtra;\n  int local_2c [2];\n  \n  exponentDiff = *(int *)(doubleValue + 0x40);\n  if (exponentDiff != 0) {\n    temp = *(uint *)(doubleValue + 0x44);\n    *(uint *)(exponentDiff + 4) = temp;\n    *(int *)(exponentDiff + 8) = 1 << (temp & 0xff);\n    _Bfree(doubleValue,exponentDiff);\n    *(undefined4 *)(doubleValue + 0x40) = 0;\n  }\n  isZero5 = (int)exponent < 0;\n  temp = exponent;\n  if (isZero5) {\n    temp = exponent & 0x7fffffff;\n  }\n  *param_8 = (uint)isZero5;\n  localExponent = exponent;\n  if (isZero5) {\n    localExponent = temp;\n  }\n  uVar17 = localExponent;\n  if ((~temp & 0x7ff00000) == 0) {\n    *param_7 = 9999;\n    if ((significand == 0) && ((temp & 0xfffff) == 0)) {\n      result = \"Infinity\";\n      if (param_9 == (char **)0x0) {\n        return result;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      result = \"NaN\";\n      if (param_9 == (char **)0x0) {\n        return result;\n      }\n      pcVar21 = \"\";\n    }\n    *param_9 = pcVar21;\n    return result;\n  }\n  currentValue = __aeabi_dcmpeq(significand,localExponent,0,0);\n  if ((int)currentValue != 0) {\n    *param_7 = 1;\n    if (param_9 != (char **)0x0) {\n      *param_9 = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  quotient = __d2b(doubleValue,(int)((ulonglong)currentValue >> 0x20),significand,localExponent,local_2c,&precisionExtra);\n  exponentDiff = precisionExtra;\n  if (temp >> 0x14 == 0) {\n    shift = local_2c[0] + precisionExtra;\n    necessaryDigits = shift + 0x432;\n    if (necessaryDigits < 0x21) {\n      temp = significand << (0x20U - necessaryDigits & 0xff);\n    }\n    else {\n      temp = significand >> (shift + 0x412U & 0xff) | temp << (0x40U - necessaryDigits & 0xff);\n    }\n    currentValue = __floatunsidf(temp);\n    shift = shift + -1;\n    isZero5 = true;\n    uVar11 = (int)((ulonglong)currentValue >> 0x20) + 0xfe100000;\n    temp = (uint)currentValue;\n  }\n  else {\n    shift = (temp >> 0x14) - 0x3ff;\n    uVar11 = localExponent & 0xfffff | 0x3ff00000;\n    isZero5 = false;\n    temp = significand;\n  }\n  currentValue = __subdf3(temp,uVar11,0,0x3ff80000);\n  currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0x636f4361,0x3fd287a7);\n  currentValue = __aeabi_dadd((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0x8b60c8b3,0x3fc68a28);\n  tempValue = __aeabi_i2d(shift);\n  tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),0x509f79fb,0x3fd34413);\n  currentValue = __aeabi_dadd((int)currentValue,(int)((ulonglong)currentValue >> 0x20),(int)tempValue,\n                        (int)((ulonglong)tempValue >> 0x20));\n  uVar13 = (undefined4)((ulonglong)currentValue >> 0x20);\n  numDigits = __aeabi_d2iz();\n  necessaryDigits = __aeabi_dcmplt((int)currentValue,uVar13,0,0);\n  if (necessaryDigits != 0) {\n    tempValue = __aeabi_i2d(numDigits);\n    necessaryDigits = __aeabi_dcmpeq((int)tempValue,(int)((ulonglong)tempValue >> 0x20),(int)currentValue,uVar13);\n    if (necessaryDigits == 0) {\n      numDigits = numDigits - 1;\n    }\n  }\n  if (numDigits < 0x17) {\n    necessaryDigits = __aeabi_dcmpgt(*(undefined4 *)(&__mprec_tens + numDigits * 8),\n                            *(undefined4 *)(&DAT_08009fac + numDigits * 8),significand,localExponent);\n    if (necessaryDigits == 0) {\n      isZero = false;\n    }\n    else {\n      numDigits = numDigits - 1;\n      isZero = false;\n    }\n  }\n  else {\n    isZero = true;\n  }\n  necessaryDigits = (exponentDiff - shift) + -1;\n  if (necessaryDigits < 0) {\n    numLeadingZeros = 1 - (exponentDiff - shift);\n    necessaryDigits = 0;\n  }\n  else {\n    numLeadingZeros = 0;\n  }\n  if ((int)numDigits < 0) {\n    numSignificantDigits = 0;\n    numLeadingZeros = numLeadingZeros - numDigits;\n    numExpDigits = -numDigits;\n  }\n  else {\n    necessaryDigits = necessaryDigits + numDigits;\n    numSignificantDigits = numDigits;\n    numExpDigits = 0;\n  }\n  if (9 < format) {\n    maxDigits = 0xffffffff;\n    isNegative = true;\n    numDecimals = 0xffffffff;\n    isScientific = true;\n    format = 0;\n    precision = 0;\n    goto LAB_08007c24;\n  }\n  isNegative = (int)format < 6;\n  if (!isNegative) {\n    format = format - 4;\n  }\n  switch(format) {\n  case 2:\n    isScientific = false;\n    break;\n  case 3:\n    isScientific = false;\n    goto LAB_08008300;\n  case 4:\n    isScientific = true;\n    break;\n  case 5:\n    isScientific = true;\nLAB_08008300:\n    maxDigits = numDigits + precision;\n    numDecimals = maxDigits + 1;\n    temp = numDecimals;\n    if ((int)numDecimals < 1) {\n      temp = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    result = (char *)_Balloc(doubleValue,0);\n    maxDigits = 0xffffffff;\n    numDecimals = 0xffffffff;\n    precision = 0;\n    *(char **)(doubleValue + 0x40) = result;\n    isScientific = true;\n    goto LAB_08007e36;\n  }\n  if ((int)precision < 1) {\n    maxDigits = 1;\n    precision = 1;\n    numDecimals = 1;\nLAB_08007c24:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    uVar11 = maxDigits;\n  }\n  else {\n    maxDigits = precision;\n    numDecimals = precision;\n    temp = precision;\nLAB_08008314:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    uVar11 = numDecimals;\n    if (0x17 < (int)temp) {\n      shift = 4;\n      exponentDiff = 1;\n      do {\n        remainder = exponentDiff;\n        shift = shift * 2;\n        exponentDiff = remainder + 1;\n      } while (shift + 0x14U <= temp);\n      *(int *)(doubleValue + 0x44) = remainder;\n    }\n  }\n  result = (char *)_Balloc(doubleValue);\n  *(char **)(doubleValue + 0x40) = result;\n  if ((uVar11 < 0xf) && (isNegative)) {\n    if ((int)numDigits < 1) {\n      if (numDigits == 0) {\n        exponentDiff = 2;\n        powerOfTen = significand;\n      }\n      else {\n        exponentDiff = (-numDigits & 0xf) * 8;\n        currentValue = __muldf3(significand,localExponent,*(undefined4 *)(&__mprec_tens + exponentDiff),\n                          *(undefined4 *)(&DAT_08009fac + exponentDiff));\n        localExponent = (uint)((ulonglong)currentValue >> 0x20);\n        powerOfTen = (uint)currentValue;\n        shift = (int)-numDigits >> 4;\n        if (shift == 0) {\n          exponentDiff = 2;\n        }\n        else {\n          isNegative = false;\n          exponentDiff = 2;\n          puVar22 = &__mprec_bigtens;\n          do {\n            if (shift << 0x1f < 0) {\n              currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),*puVar22,puVar22[1]);\n              isNegative = true;\n              exponentDiff = exponentDiff + 1;\n            }\n            shift = shift >> 1;\n            puVar22 = puVar22 + 2;\n          } while (shift != 0);\n          if (isNegative) {\n            powerOfTen = (uint)currentValue;\n            localExponent = (uint)((ulonglong)currentValue >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      temp = (int)numDigits >> 4;\n      tempValue = *(undefined8 *)(&__mprec_tens + (numDigits & 0xf) * 8);\n      currentValue = *(undefined8 *)(&__mprec_tens + (numDigits & 0xf) * 8);\n      if ((int)(temp << 0x1b) < 0) {\n        uVar28 = __divdf3(significand,localExponent,0x7f73bf3c,0x75154fdd);\n        local_4 = (uint)((ulonglong)uVar28 >> 0x20);\n        precisionBits = (uint)uVar28;\n        exponentDiff = 3;\n        temp = temp & 0xf;\n      }\n      else {\n        exponentDiff = 2;\n        local_4 = localExponent;\n        precisionBits = significand;\n      }\n      if (temp != 0) {\n        puVar22 = &__mprec_bigtens;\n        do {\n          if ((int)(temp << 0x1f) < 0) {\n            currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),*puVar22,puVar22[1]);\n            exponentDiff = exponentDiff + 1;\n          }\n          temp = (int)temp >> 1;\n          puVar22 = puVar22 + 2;\n          tempValue = currentValue;\n        } while (temp != 0);\n      }\n      localExponent = (uint)((ulonglong)tempValue >> 0x20);\n      powerOfTen = (uint)tempValue;\n      currentValue = __divdf3(precisionBits,local_4,powerOfTen,localExponent);\n      powerOfTen = (uint)currentValue;\n      localExponent = (uint)((ulonglong)currentValue >> 0x20);\n    }\n    currentValue = CONCAT44(localExponent,powerOfTen);\n    if ((isZero) && (shift = __aeabi_dcmplt(powerOfTen,localExponent,0,0x3ff00000), shift != 0)) {\n      if (numDecimals == 0) {\n        currentValue = __aeabi_i2d(exponentDiff);\n        currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),powerOfTen,localExponent);\n        currentValue = __aeabi_dadd((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)currentValue;\n        exponentDiff = (int)((ulonglong)currentValue >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)maxDigits) {\n        currentValue = __muldf3(powerOfTen,localExponent,0,0x40240000);\n        tempValue = __aeabi_i2d(exponentDiff + 1);\n        tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),(int)currentValue,\n                          (int)((ulonglong)currentValue >> 0x20));\n        tempValue = __aeabi_dadd((int)tempValue,(int)((ulonglong)tempValue >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)tempValue;\n        precisionBits = maxDigits;\n        local_34 = numDigits - 1;\n        exponentDiff = (int)((ulonglong)tempValue >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    tempValue = __aeabi_i2d(exponentDiff);\n    tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),powerOfTen,localExponent);\n    tempValue = __aeabi_dadd((int)tempValue,(int)((ulonglong)tempValue >> 0x20),0,0x401c0000);\n    uVar13 = (undefined4)tempValue;\n    exponentDiff = (int)((ulonglong)tempValue >> 0x20) + -0x3400000;\n    if (numDecimals != 0) {\n      local_34 = numDigits;\n      precisionBits = numDecimals;\nLAB_08007cfa:\n      localExponent = (uint)((ulonglong)currentValue >> 0x20);\n      powerOfTen = (uint)currentValue;\n      digit = __aeabi_d2iz(powerOfTen,localExponent);\n      digit = digit + '0';\n      uVar16 = (&DAT_08009fa0)[precisionBits * 2];\n      uVar12 = (&DAT_08009fa4)[precisionBits * 2];\n      currentValue = __aeabi_i2d();\n      currentValue = __subdf3(powerOfTen,localExponent,(int)currentValue,(int)((ulonglong)currentValue >> 0x20));\n      uVar23 = (undefined4)((ulonglong)currentValue >> 0x20);\n      pcVar21 = result + 1;\n      if (isScientific) {\n        tempValue = __divdf3(0,0x3fe00000,uVar16,uVar12);\n        tempValue = __subdf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),uVar13,exponentDiff);\n        uVar13 = (undefined4)((ulonglong)tempValue >> 0x20);\n        *result = digit;\n        exponentDiff = __aeabi_dcmpgt((int)tempValue,uVar13,(int)currentValue,uVar23);\n        if (exponentDiff != 0) {\nLAB_08008784:\n          numDigits = local_34;\n          goto LAB_08008294;\n        }\n        uVar28 = __subdf3(0,0x3ff00000,(int)currentValue,uVar23);\n        exponentDiff = __aeabi_dcmpgt((int)tempValue,uVar13,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        if (exponentDiff == 0) {\n          if (precisionBits != 1) {\n            pcVar20 = pcVar21;\n            do {\n              tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),0,0x40240000);\n              uVar13 = (undefined4)((ulonglong)tempValue >> 0x20);\n              currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0x40240000);\n              digit = __aeabi_d2iz();\n              uVar28 = __aeabi_i2d();\n              currentValue = __subdf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),(int)uVar28,\n                                (int)((ulonglong)uVar28 >> 0x20));\n              uVar16 = (undefined4)((ulonglong)currentValue >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              exponentDiff = __aeabi_dcmplt((int)currentValue,uVar16,(int)tempValue,uVar13);\n              if (exponentDiff != 0) {\n                numDigits = local_34;\n                goto LAB_08008294;\n              }\n              uVar28 = __subdf3(0,0x3ff00000,(int)currentValue,uVar16);\n              exponentDiff = __aeabi_dcmplt((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)tempValue,\n                                      uVar13);\n              if (exponentDiff != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != result + precisionBits);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        numDigits = local_34;\n      }\n      else {\n        tempValue = __muldf3(uVar13,exponentDiff,uVar16,uVar12);\n        uVar13 = (undefined4)((ulonglong)tempValue >> 0x20);\n        *result = digit;\n        if (precisionBits != 1) {\n          pcVar20 = pcVar21;\n          do {\n            currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0x40240000);\n            digit = __aeabi_d2iz();\n            uVar28 = __aeabi_i2d();\n            currentValue = __subdf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),(int)uVar28,\n                              (int)((ulonglong)uVar28 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != result + precisionBits);\n        }\n        uVar16 = (undefined4)((ulonglong)currentValue >> 0x20);\n        uVar28 = __aeabi_dadd((int)tempValue,uVar13,0,0x3fe00000);\n        exponentDiff = __aeabi_dcmplt((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)currentValue,uVar16);\n        if (exponentDiff == 0) {\n          tempValue = __subdf3(0,0x3fe00000,(int)tempValue,uVar13);\n          exponentDiff = __aeabi_dcmpgt((int)tempValue,(int)((ulonglong)tempValue >> 0x20),(int)currentValue,uVar16);\n          pcVar20 = pcVar21;\n          if (exponentDiff == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        numDigits = local_34;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    currentValue = __subdf3(powerOfTen,localExponent,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)currentValue >> 0x20);\n    shift = __aeabi_dcmpgt((int)currentValue,uVar16,uVar13,exponentDiff);\n    if (shift == 0) {\n      exponentDiff = __aeabi_dcmplt((int)currentValue,uVar16,uVar13,exponentDiff + -0x80000000);\n      if (exponentDiff == 0) goto LAB_08007e36;\n      shift = 0;\n      exponentDiff = 0;\n      pcVar21 = result;\n      goto LAB_080084f0;\n    }\n    necessaryDigits = 0;\n    remainder = 0;\nLAB_08008406:\n    *result = '1';\n    numDigits = numDigits + 1;\n    pcVar21 = result + 1;\n    shift = remainder;\n    exponentDiff = necessaryDigits;\nLAB_08008416:\n    _Bfree(doubleValue,exponentDiff);\n    if (shift == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = result;\n    if ((-1 < local_2c[0]) && ((int)numDigits < 0xf)) {\n      uVar13 = *(undefined4 *)(&__mprec_tens + numDigits * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + numDigits * 8);\n      if ((-1 < (int)precision) || (0 < (int)numDecimals)) {\n        __divdf3(significand,uVar17,uVar13,uVar16);\n        bVar5 = __aeabi_d2iz();\n        currentValue = __aeabi_i2d();\n        currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),uVar13,uVar16);\n        currentValue = __subdf3(significand,uVar17,(int)currentValue,(int)((ulonglong)currentValue >> 0x20));\n        *result = bVar5 + 0x30;\n        pcVar21 = result + 1;\n        if (numDecimals != 1) {\n          currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0x40240000);\n          exponentDiff = __aeabi_dcmpeq((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0);\n          while (exponentDiff == 0) {\n            uVar23 = (undefined4)((ulonglong)currentValue >> 0x20);\n            __divdf3((int)currentValue,uVar23,uVar13,uVar16);\n            bVar5 = __aeabi_d2iz();\n            tempValue = __aeabi_i2d();\n            tempValue = __muldf3((int)tempValue,(int)((ulonglong)tempValue >> 0x20),uVar13,uVar16);\n            currentValue = __subdf3((int)currentValue,uVar23,(int)tempValue,(int)((ulonglong)tempValue >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = bVar5 + 0x30;\n            pcVar21 = pcVar20;\n            if (numDecimals == (int)pcVar20 - (int)result) goto LAB_08007f3a;\n            currentValue = __muldf3((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0x40240000);\n            exponentDiff = __aeabi_dcmpeq((int)currentValue,(int)((ulonglong)currentValue >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        currentValue = __aeabi_dadd((int)currentValue,(int)((ulonglong)currentValue >> 0x20));\n        uVar23 = (undefined4)((ulonglong)currentValue >> 0x20);\n        exponentDiff = __aeabi_dcmpgt((int)currentValue,uVar23,uVar13,uVar16);\n        if ((exponentDiff == 0) &&\n           ((exponentDiff = __aeabi_dcmpeq((int)currentValue,uVar23,uVar13,uVar16), exponentDiff == 0 ||\n            ((bVar5 & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (result == pcVar20) {\n            *result = '0';\n            digit = pcVar21[-1];\n            numDigits = numDigits + 1;\n            pcVar20 = result;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (numDecimals == 0) {\n        currentValue = __muldf3(uVar13,uVar16,0,0x40140000);\n        iVar9 = __aeabi_dcmpge((int)currentValue,(int)((ulonglong)currentValue >> 0x20),significand,uVar17);\n        shift = 0;\n        necessaryDigits = 0;\n        remainder = 0;\n        exponentDiff = 0;\n        if (iVar9 == 0) goto LAB_08008406;\n      }\n      else {\n        shift = 0;\n        exponentDiff = 0;\n      }\nLAB_080084f0:\n      numDigits = ~precision;\n      result = pcVar21;\n      goto LAB_08008416;\n    }\n    exponentDiff = numExpDigits;\n    if (isScientific) {\n      if ((int)format < 2) {\n        if (isZero5) {\n          exp10 = numLeadingZeros;\n          numLeadingZeros = numLeadingZeros + local_2c[0] + 0x433;\n          necessaryDigits = necessaryDigits + local_2c[0] + 0x433;\n        }\n        else {\n          exp10 = numLeadingZeros;\n          numLeadingZeros = numLeadingZeros + (0x36 - precisionExtra);\n          necessaryDigits = necessaryDigits + (0x36 - precisionExtra);\n        }\n      }\n      else {\n        shift = numDecimals - 1;\n        if (numExpDigits < shift) {\n          numSignificantDigits = numSignificantDigits + (shift - numExpDigits);\n          exponentDiff = 0;\n          numExpDigits = shift;\n        }\n        else {\n          exponentDiff = numExpDigits - shift;\n        }\n        if ((int)numDecimals < 0) {\n          exp10 = numLeadingZeros - numDecimals;\n        }\n        else {\n          necessaryDigits = necessaryDigits + numDecimals;\n          exp10 = numLeadingZeros;\n          numLeadingZeros = numLeadingZeros + numDecimals;\n        }\n      }\n      shift = __i2b(doubleValue,1);\n    }\n    else {\n      exp10 = numLeadingZeros;\n      shift = 0;\n    }\n    if ((0 < exp10) && (0 < necessaryDigits)) {\n      remainder = exp10;\n      if (necessaryDigits <= exp10) {\n        remainder = necessaryDigits;\n      }\n      necessaryDigits = necessaryDigits - remainder;\n      numLeadingZeros = numLeadingZeros - remainder;\n      exp10 = exp10 - remainder;\n    }\n    if (numExpDigits != 0) {\n      if (isScientific) {\n        uVar13 = quotient;\n        if (exponentDiff != 0) {\n          shift = __pow5mult(doubleValue,shift,exponentDiff);\n          uVar13 = __multiply(doubleValue,shift,quotient);\n          _Bfree(doubleValue,quotient);\n          quotient = uVar13;\n          if (numExpDigits - exponentDiff == 0) goto LAB_08008062;\n        }\n        quotient = __pow5mult(doubleValue,uVar13,numExpDigits - exponentDiff);\n      }\n      else {\n        quotient = __pow5mult(doubleValue,quotient,numExpDigits);\n      }\n    }\nLAB_08008062:\n    exponentDiff = __i2b(doubleValue,1);\n    if (numSignificantDigits == 0) {\n      if (((int)format < 2) && (significand == 0)) {\nLAB_0800835a:\n        if ((uVar17 & 0xfffff) == 0) {\n          uVar17 = uVar17 & 0x7ff00000;\n          if (uVar17 != 0) {\n            necessaryDigits = necessaryDigits + 1;\n            numLeadingZeros = numLeadingZeros + 1;\n            uVar17 = 1;\n          }\n        }\n        else {\n          uVar17 = 0;\n        }\n        isZero5 = numSignificantDigits != 0;\n        temp = significand;\n        numSignificantDigits = uVar17;\n        if (isZero5) goto LAB_080082d4;\n      }\n      remainder = 1;\n    }\n    else {\n      currentValue = __pow5mult(doubleValue,exponentDiff);\n      exponentDiff = (int)currentValue;\n      if (((int)format < 2) && (significand == 0)) goto LAB_0800835a;\n      numSignificantDigits = 0;\n      temp = (uint)((ulonglong)currentValue >> 0x20);\nLAB_080082d4:\n      remainder = __hi0bits(*(undefined4 *)(exponentDiff + *(int *)(exponentDiff + 0x10) * 4 + 0x10),temp);\n      remainder = 0x20 - remainder;\n    }\n    temp = remainder + necessaryDigits & 0x1f;\n    if (temp == 0) {\n      remainder = 0x1c;\nLAB_08008096:\n      necessaryDigits = necessaryDigits + remainder;\n      numLeadingZeros = numLeadingZeros + remainder;\n      exp10 = exp10 + remainder;\n    }\n    else {\n      if (4 < (int)(0x20 - temp)) {\n        remainder = 0x1c - temp;\n        goto LAB_08008096;\n      }\n      if (0x20 - temp != 4) {\n        remainder = 0x3c - temp;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < numLeadingZeros) {\n      quotient = __lshift(doubleValue,quotient,numLeadingZeros);\n    }\n    if (0 < necessaryDigits) {\n      exponentDiff = __lshift(doubleValue,exponentDiff,necessaryDigits);\n    }\n    pcVar20 = result;\n    if ((isZero) && (necessaryDigits = __mcmp(quotient,exponentDiff), necessaryDigits < 0)) {\n      numDigits = numDigits - 1;\n      quotient = __multadd(doubleValue,quotient,10,0);\n      if (isScientific) {\n        shift = __multadd(doubleValue,shift,10,0);\n        if ((0 < (int)maxDigits) || ((int)format < 3)) {\n          numDecimals = maxDigits;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)maxDigits) || ((int)format < 3)) {\n        numDecimals = maxDigits;\n        goto LAB_0800820a;\n      }\n      numDecimals = maxDigits;\nLAB_080084e8:\n      if (numDecimals == 0) {\n        necessaryDigits = __multadd(doubleValue,exponentDiff,5);\n        iVar9 = __mcmp(quotient,necessaryDigits);\n        remainder = shift;\n        exponentDiff = necessaryDigits;\n        if (0 < iVar9) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)numDecimals < 1) && (2 < (int)format)) goto LAB_080084e8;\n    if (isScientific) {\nLAB_080080de:\n      powerOfTen = shift;\n      if (0 < exp10) {\n        powerOfTen = __lshift(doubleValue,shift,exp10);\n      }\n      shift = powerOfTen;\n      if (numSignificantDigits != 0) {\n        shift = _Balloc(doubleValue,*(undefined4 *)(powerOfTen + 4));\n        memcpy((void *)(shift + 0xc),(void *)(powerOfTen + 0xc),(*(int *)(powerOfTen + 0x10) + 2) * 4);\n        shift = __lshift(doubleValue,shift,1);\n      }\nLAB_08008108:\n      necessaryDigits = quorem(quotient,exponentDiff);\n      remainder = __mcmp(quotient,powerOfTen);\n      iVar9 = __mdiff(doubleValue,exponentDiff,shift);\n      iVar24 = necessaryDigits + 0x30;\n      if (*(int *)(iVar9 + 0xc) == 0) {\n        iVar8 = __mcmp(quotient);\n        _Bfree(doubleValue,iVar9);\n        if ((iVar8 != 0) || (format != 0)) goto LAB_0800815a;\n        if ((significand & 1) != 0) {\n          iVar8 = 0;\n          goto LAB_0800815a;\n        }\n        if (iVar24 != 0x39) {\n          if (0 < remainder) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(doubleValue,iVar9);\n      iVar8 = 1;\nLAB_0800815a:\n      if ((remainder < 0) || (((remainder == 0 && (format == 0)) && ((significand & 1) == 0)))) {\n        if (0 < iVar8) {\n          quotient = __lshift(doubleValue,quotient,1);\n          remainder = __mcmp(quotient,exponentDiff);\n          if ((0 < remainder) || ((remainder == 0 && (necessaryDigits << 0x1f < 0)))) {\n            if (iVar24 == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            iVar24 = necessaryDigits + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)iVar24;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < iVar8) {\n        if (iVar24 == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)necessaryDigits + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)iVar24;\n      if (result + (numDecimals - 1) != pcVar20) {\n        quotient = __multadd(doubleValue,quotient,10,0);\n        pcVar20 = pcVar21;\n        if (powerOfTen == shift) {\n          powerOfTen = __multadd(doubleValue,powerOfTen,10,0);\n          shift = powerOfTen;\n        }\n        else {\n          powerOfTen = __multadd(doubleValue,powerOfTen,10,0);\n          shift = __multadd(doubleValue,shift,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        iVar24 = quorem(quotient,exponentDiff);\n        iVar24 = iVar24 + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)iVar24;\n        if ((int)numDecimals <= (int)pcVar21 - (int)result) break;\n        quotient = __multadd(doubleValue,quotient,10,0);\n        pcVar20 = pcVar21;\n      }\n      powerOfTen = 0;\n    }\n    quotient = __lshift(doubleValue,quotient,1);\n    necessaryDigits = __mcmp(quotient,exponentDiff);\n    digit = pcVar21[-1];\n    if ((0 < necessaryDigits) || ((necessaryDigits == 0 && (iVar24 << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (result == pcVar20) {\n          *result = '1';\n          numDigits = numDigits + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(doubleValue,exponentDiff);\n    if (shift == 0) goto LAB_08008294;\n    if ((powerOfTen != 0) && (powerOfTen != shift)) {\n      _Bfree(doubleValue);\n    }\n  }\n  _Bfree(doubleValue,shift);\nLAB_08008294:\n  _Bfree(doubleValue,quotient);\n  *pcVar21 = '\\0';\n  *param_7 = numDigits + 1;\n  if (param_9 == (char **)0x0) {\n    return result;\n  }\n  *param_9 = pcVar21;\n  return result;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_double_to_string_080079e8",
                "param_1": "doubleValue",
                "param_3": "significand",
                "param_4": "exponent",
                "param_5": "format",
                "param_6": "precision",
                "bVar1": "isNegative",
                "bVar2": "isZero",
                "bVar3": "isScientific",
                "cVar4": "digit",
                "uVar6": "quotient",
                "iVar7": "remainder",
                "pcVar10": "result",
                "iVar14": "exponentDiff",
                "iVar15": "necessaryDigits",
                "iVar19": "shift",
                "uVar18": "temp",
                "uVar26": "currentValue",
                "uVar27": "tempValue",
                "local_80": "powerOfTen",
                "local_7c": "localExponent",
                "local_74": "numDigits",
                "local_70": "numLeadingZeros",
                "local_68": "numDecimals",
                "local_60": "exp10",
                "local_5c": "numExpDigits",
                "local_58": "numSignificantDigits",
                "local_48": "precisionBits",
                "uStack_44": "local_4",
                "local_38": "maxDigits",
                "local_30": "precisionExtra"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__multiply",
                "__aeabi_dcmpge",
                "__d2b",
                "quorem",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__aeabi_dadd",
                "__multadd",
                "__i2b",
                "__floatunsidf",
                "memcpy",
                "__aeabi_dcmplt",
                "__subdf3",
                "__aeabi_i2d",
                "__lshift",
                "__mdiff",
                "__muldf3",
                "__aeabi_d2iz",
                "_Bfree",
                "_Balloc",
                "__mcmp",
                "__pow5mult",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008818": {
            "entrypoint": "0x08008818",
            "current_name": "execute_global_destructors_08008818",
            "code": "\nvoid execute_global_destructors_08008818(void)\n\n{\n  int counter;\n  code **ptr_to_destructor_functions;\n  \n  counter = 1;\n  ptr_to_destructor_functions = (code **)&__do_global_dtors_aux_fini_array_entry;\n  do {\n    counter = counter + -1;\n    (**ptr_to_destructor_functions)();\n    ptr_to_destructor_functions = ptr_to_destructor_functions + -1;\n  } while (counter != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008818": "execute_global_destructors_08008818",
                "iVar1": "counter",
                "ppcVar2": "ptr_to_destructor_functions"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "decrement_and_unlock_memory_0800884c",
            "code": "\nundefined4 decrementAndUnlockMemory_0800884c(undefined4 lock,int size)\n\n{\n  int result;\n  int alignedAddress;\n  uint memoryBlock;\n  \n  lockMemory();\n  memoryBlock = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  alignedAddress = ((0xfef - size) + memoryBlock & 0xfffff000) - 0x1000;\n  if (0xfff < alignedAddress) {\n    result = manageMemory(lock,0);\n    if (result == DAT_20000454 + memoryBlock) {\n      result = manageMemory(lock,-alignedAddress);\n      if (result != -1) {\n        currentMemoryUsage = currentMemoryUsage - alignedAddress;\n        *(uint *)(DAT_20000454 + 4) = memoryBlock - alignedAddress | 1;\n        unlockMemory(lock);\n        return 1;\n      }\n      alignedAddress = manageMemory(lock,0);\n      if (0xf < alignedAddress - DAT_20000454) {\n        currentMemoryUsage = alignedAddress - baseAddress;\n        *(uint *)(DAT_20000454 + 4) = alignedAddress - DAT_20000454 | 1;\n      }\n    }\n  }\n  unlockMemory(lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "decrement_and_unlock_memory_0800884c",
                "param_1": "lock",
                "param_2": "size",
                "iVar1": "result",
                "iVar2": "alignedAddress",
                "uVar3": "memoryBlock",
                "__malloc_lock": "lockMemory",
                "_sbrk_r": "manageMemory",
                "__malloc_current_mallinfo": "currentMemoryUsage",
                "__malloc_unlock": "unlockMemory",
                "__malloc_sbrk_base": "baseAddress"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "resize_memory_block_080088ec",
            "code": "\nvoid resizeMemoryBlock_080088ec(undefined4 lock,int blockAddress,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *previousBlock;\n  uint *currentBlock;\n  undefined *nextBlock;\n  uint currentBlockHeader;\n  uint currentBlockSize;\n  undefined *previousFreeBlock;\n  undefined *nextFreeBlock;\n  undefined4 *headerOfPreviousBlock;\n  int sizeIndex;\n  uint currentBlockFooter;\n  uint footerOfPreviousBlock;\n  \n  if (blockAddress == 0) {\n    return;\n  }\n  __malloc_lock();\n  currentBlockFooter = *(uint *)(blockAddress + -4);\n  previousBlock = (uint *)(blockAddress + -8);\n  currentBlockHeader = currentBlockFooter & 0xfffffffe;\n  currentBlock = (uint *)((int)previousBlock + currentBlockHeader);\n  currentBlockSize = currentBlock[1] & 0xfffffffc;\n  if (DAT_20000454 == currentBlock) {\n    currentBlockHeader = currentBlockHeader + currentBlockSize;\n    if ((currentBlockFooter & 1) == 0) {\n      previousBlock = (uint *)((int)previousBlock - *(int *)(blockAddress + -8));\n      currentBlockSize = previousBlock[2];\n      currentBlockFooter = previousBlock[3];\n      currentBlockHeader = currentBlockHeader + *(int *)(blockAddress + -8);\n      *(uint *)(currentBlockSize + 0xc) = currentBlockFooter;\n      *(uint *)(currentBlockFooter + 8) = currentBlockSize;\n    }\n    currentBlockSize = __malloc_trim_threshold;\n    previousBlock[1] = currentBlockHeader | 1;\n    DAT_20000454 = previousBlock;\n    if (currentBlockSize <= currentBlockHeader) {\n      _malloc_trim_r(lock,__malloc_top_pad);\n    }\nLAB_080089f0:\n    __malloc_unlock(lock);\n    return;\n  }\n  currentBlock[1] = currentBlockSize;\n  if ((currentBlockFooter & 1) == 0) {\n    previousBlock = (uint *)((int)previousBlock - *(int *)(blockAddress + -8));\n    headerOfPreviousBlock = (undefined4 *)previousBlock[2];\n    currentBlockHeader = currentBlockHeader + *(int *)(blockAddress + -8);\n    currentBlockFooter = *(uint *)((int)currentBlock + currentBlockSize + 4) & 1;\n    if ((uint **)headerOfPreviousBlock == &DAT_20000454) {\n      if (currentBlockFooter == 0) {\n        currentBlockFooter = currentBlock[2];\n        footerOfPreviousBlock = currentBlock[3];\n        currentBlockHeader = currentBlockHeader + currentBlockSize;\n        *(uint *)(currentBlockFooter + 0xc) = footerOfPreviousBlock;\n        *(uint *)(footerOfPreviousBlock + 8) = currentBlockFooter;\n        previousBlock[1] = currentBlockHeader | 1;\n        *(uint *)((int)previousBlock + currentBlockHeader) = currentBlockHeader;\n      }\n      else {\n        previousBlock[1] = currentBlockHeader | 1;\n        *currentBlock = currentBlockHeader;\n      }\n      goto LAB_080089f0;\n    }\n    footerOfPreviousBlock = previousBlock[3];\n    headerOfPreviousBlock[3] = footerOfPreviousBlock;\n    *(undefined4 **)(footerOfPreviousBlock + 8) = headerOfPreviousBlock;\n  }\n  else {\n    currentBlockFooter = *(uint *)((int)currentBlock + currentBlockSize + 4) & 1;\n  }\n  if (currentBlockFooter == 0) {\n    headerOfPreviousBlock = (undefined4 *)currentBlock[2];\n    currentBlockHeader = currentBlockHeader + currentBlockSize;\n    if ((uint **)headerOfPreviousBlock == &DAT_20000454) {\n      DAT_2000045c = previousBlock;\n      DAT_20000460 = previousBlock;\n      previousBlock[2] = (uint)&DAT_20000454;\n      previousBlock[3] = (uint)&DAT_20000454;\n      previousBlock[1] = currentBlockHeader | 1;\n      *(uint *)((int)previousBlock + currentBlockHeader) = currentBlockHeader;\n      goto LAB_080089f0;\n    }\n    currentBlockSize = currentBlock[3];\n    headerOfPreviousBlock[3] = currentBlockSize;\n    *(undefined4 **)(currentBlockSize + 8) = headerOfPreviousBlock;\n    previousBlock[1] = currentBlockHeader | 1;\n    *(uint *)((int)previousBlock + currentBlockHeader) = currentBlockHeader;\n  }\n  else {\n    previousBlock[1] = currentBlockHeader | 1;\n    *(uint *)((int)previousBlock + currentBlockHeader) = currentBlockHeader;\n  }\n  if (currentBlockHeader < 0x200) {\n    sizeIndex = (currentBlockHeader >> 3) + 1;\n    currentBlockHeader = 1 << ((int)(currentBlockHeader >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    currentBlockSize = *(uint *)(&__malloc_av_ + sizeIndex * 8);\n    previousBlock[2] = currentBlockSize;\n    previousBlock[3] = (uint)(&DAT_20000444 + sizeIndex * 8);\n    DAT_20000450 = (undefined *)currentBlockHeader;\n    *(uint **)(&__malloc_av_ + sizeIndex * 8) = previousBlock;\n    *(uint **)(currentBlockSize + 0xc) = previousBlock;\n    __malloc_unlock(lock,previousBlock,currentBlockHeader,param_4);\n    return;\n  }\n  currentBlockSize = currentBlockHeader >> 9;\n  if (currentBlockSize < 5) {\n    sizeIndex = ((currentBlockHeader >> 6) + 0x39) * 8;\n    index = (currentBlockHeader >> 6) + 0x38;\n  }\n  else if (currentBlockSize < 0x15) {\n    sizeIndex = (currentBlockSize + 0x5c) * 8;\n    index = currentBlockSize + 0x5b;\n  }\n  else if (currentBlockSize < 0x55) {\n    sizeIndex = ((currentBlockHeader >> 0xc) + 0x6f) * 8;\n    index = (currentBlockHeader >> 0xc) + 0x6e;\n  }\n  else if (currentBlockSize < 0x155) {\n    sizeIndex = ((currentBlockHeader >> 0xf) + 0x78) * 8;\n    index = (currentBlockHeader >> 0xf) + 0x77;\n  }\n  else if (currentBlockSize < 0x555) {\n    sizeIndex = ((currentBlockHeader >> 0x12) + 0x7d) * 8;\n    index = (currentBlockHeader >> 0x12) + 0x7c;\n  }\n  else {\n    sizeIndex = 0x3f8;\n    index = 0x7e;\n  }\n  nextBlock = *(undefined **)(&__malloc_av_ + sizeIndex);\n  previousFreeBlock = &DAT_20000444 + sizeIndex;\n  if (previousFreeBlock == nextBlock) {\n    nextBlock = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    nextFreeBlock = previousFreeBlock;\n    DAT_20000450 = nextBlock;\n  }\n  else {\n    do {\n      nextFreeBlock = nextBlock;\n      if ((*(uint *)(nextBlock + 4) & 0xfffffffc) <= currentBlockHeader) break;\n      nextBlock = *(undefined **)(nextBlock + 8);\n      nextFreeBlock = previousFreeBlock;\n    } while (previousFreeBlock != nextBlock);\n    previousFreeBlock = *(undefined **)(nextFreeBlock + 0xc);\n  }\n  previousBlock[2] = (uint)nextFreeBlock;\n  previousBlock[3] = (uint)previousFreeBlock;\n  *(uint **)(previousFreeBlock + 8) = previousBlock;\n  *(uint **)(nextFreeBlock + 0xc) = previousBlock;\n  __malloc_unlock(lock,previousBlock,nextBlock,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "resize_memory_block_080088ec",
                "param_1": "lock",
                "param_2": "blockAddress",
                "iVar1": "index",
                "puVar2": "previousBlock",
                "puVar3": "currentBlock",
                "puVar4": "nextBlock",
                "uVar5": "currentBlockHeader",
                "uVar6": "currentBlockSize",
                "puVar7": "previousFreeBlock",
                "puVar8": "nextFreeBlock",
                "puVar9": "headerOfPreviousBlock",
                "iVar10": "sizeIndex",
                "uVar11": "currentBlockFooter",
                "uVar12": "footerOfPreviousBlock"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_malloc_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "_malloc_trim_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_locale_ptr_08008ad4",
            "code": "\nundefined1 * get_locale_ptr_08008ad4(void)\n\n{\n  undefined1 *locale_ptr;\n  \n  locale_ptr = *(undefined1 **)(impure_ptr + 0x34);\n  if (locale_ptr == (undefined1 *)0x0) {\n    locale_ptr = &global_locale;\n  }\n  return locale_ptr + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_locale_ptr_08008ad4",
                "puVar1": "locale_ptr",
                "_impure_ptr": "impure_ptr",
                "__global_locale": "global_locale"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "malloc_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * malloc_08008af8(undefined4 *lock,uint size)\n\n{\n  undefined1 *current_block;\n  undefined1 *prev_block;\n  uint chunk_size;\n  uint diff;\n  int bin_index;\n  undefined *block;\n  uint bin_mask;\n  uint bin_chunk_size;\n  undefined4 *next_block;\n  undefined1 *new_block;\n  undefined *bin;\n  int *result;\n  uint adjusted_size;\n  uint adjusted_bin_size;\n  int prev_bin_index;\n  undefined4 *metadata;\n  undefined1 *current;\n  undefined4 *new_metadata;\n  \n  adjusted_size = size + 0xb;\n  if (adjusted_size < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_08008af8_lock();\n    adjusted_bin_size = 0x10;\n    bin_index = 0x18;\n    adjusted_size = 2;\nLAB_08008b18:\n    bin = *(undefined **)((int)&DAT_20000450 + bin_index);\n    if ((bin != &DAT_20000444 + bin_index) ||\n       (bin = *(undefined **)((int)&DAT_20000458 + bin_index), &__malloc_08008af8_av_ + bin_index != bin)) {\n      bin_index = *(int *)(bin + 0xc);\n      block = bin + (*(uint *)(bin + 4) & 0xfffffffc);\n      adjusted_size = *(uint *)(block + 4);\nLAB_08008b34:\n      prev_bin_index = *(int *)(bin + 8);\n      *(int *)(prev_bin_index + 0xc) = bin_index;\n      *(int *)(bin_index + 8) = prev_bin_index;\n      *(uint *)(block + 4) = adjusted_size | 1;\n      __malloc_08008af8_unlock(lock);\n      return (int *)(bin + 8);\n    }\n    adjusted_size = adjusted_size + 2;\n  }\n  else {\n    adjusted_bin_size = adjusted_size & 0xfffffff8;\n    if (((int)adjusted_bin_size < 0) || (adjusted_bin_size < size)) {\nLAB_08008c7a:\n      *lock = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_08008af8_lock();\n    if (adjusted_bin_size < 0x1f8) {\n      adjusted_size = adjusted_size >> 3;\n      bin_index = adjusted_bin_size + 8;\n      goto LAB_08008b18;\n    }\n    chunk_size = adjusted_size >> 9;\n    if (chunk_size == 0) {\n      bin_index = 0x200;\n      bin_mask = 0x40;\n      chunk_size = 0x3f;\n    }\n    else if (chunk_size < 5) {\n      bin_mask = (adjusted_size >> 6) + 0x39;\n      chunk_size = (adjusted_size >> 6) + 0x38;\n      bin_index = bin_mask * 8;\n    }\n    else if (chunk_size < 0x15) {\n      bin_mask = chunk_size + 0x5c;\n      chunk_size = chunk_size + 0x5b;\n      bin_index = bin_mask * 8;\n    }\n    else if (chunk_size < 0x55) {\n      bin_mask = (adjusted_size >> 0xc) + 0x6f;\n      chunk_size = (adjusted_size >> 0xc) + 0x6e;\n      bin_index = bin_mask * 8;\n    }\n    else if (chunk_size < 0x155) {\n      bin_mask = (adjusted_size >> 0xf) + 0x78;\n      chunk_size = (adjusted_size >> 0xf) + 0x77;\n      bin_index = bin_mask * 8;\n    }\n    else if (chunk_size < 0x555) {\n      bin_mask = (adjusted_size >> 0x12) + 0x7d;\n      chunk_size = (adjusted_size >> 0x12) + 0x7c;\n      bin_index = bin_mask * 8;\n    }\n    else {\n      bin_index = 0x3f8;\n      bin_mask = 0x7f;\n      chunk_size = 0x7e;\n    }\n    for (bin = *(undefined **)((int)&DAT_20000450 + bin_index); adjusted_size = bin_mask,\n        &DAT_20000444 + bin_index != bin; bin = *(undefined **)(bin + 0xc)) {\n      prev_bin_index = (*(uint *)(bin + 4) & 0xfffffffc) - adjusted_bin_size;\n      adjusted_size = chunk_size;\n      if (0xf < prev_bin_index) break;\n      if (-1 < prev_bin_index) {\n        block = bin + (*(uint *)(bin + 4) & 0xfffffffc);\n        adjusted_size = *(uint *)(block + 4);\n        bin_index = *(int *)(bin + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  metadata = DAT_2000045c;\n  if ((undefined1 **)DAT_2000045c == &DAT_20000454) {\n    bin_mask = 1 << ((int)adjusted_size >> 2 & 0xffU);\n    chunk_size = DAT_20000450;\n    if (bin_mask <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    bin_mask = DAT_2000045c[1];\n    bin_chunk_size = bin_mask & 0xfffffffc;\n    chunk_size = bin_chunk_size - adjusted_bin_size;\n    if (0xf < (int)chunk_size) {\n      new_metadata = (undefined4 *)(adjusted_bin_size + (int)DAT_2000045c);\n      DAT_2000045c[1] = adjusted_bin_size | 1;\n      DAT_2000045c = new_metadata;\n      DAT_20000460 = new_metadata;\n      new_metadata[2] = &DAT_20000454;\n      new_metadata[3] = &DAT_20000454;\n      new_metadata[1] = chunk_size | 1;\n      *(uint *)((int)metadata + bin_chunk_size) = chunk_size;\n      __malloc_08008af8_unlock(lock);\n      return metadata + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)chunk_size) {\n      *(uint *)((int)metadata + bin_chunk_size + 4) = *(uint *)((int)metadata + bin_chunk_size + 4) | 1;\n      __malloc_08008af8_unlock(lock);\n      return metadata + 2;\n    }\n    if (bin_chunk_size < 0x200) {\n      bin_index = (bin_mask >> 3) + 1;\n      prev_bin_index = *(int *)(&__malloc_08008af8_av_ + bin_index * 8);\n      chunk_size = 1 << ((int)(bin_mask >> 3) >> 2 & 0xffU) | DAT_20000450;\n      metadata[2] = prev_bin_index;\n      metadata[3] = &DAT_20000444 + bin_index * 8;\n      DAT_20000450 = chunk_size;\n      *(undefined4 **)(&__malloc_08008af8_av_ + bin_index * 8) = metadata;\n      *(undefined4 **)(prev_bin_index + 0xc) = metadata;\n    }\n    else {\n      chunk_size = bin_mask >> 9;\n      if (chunk_size < 5) {\n        bin_index = ((bin_mask >> 6) + 0x39) * 8;\n        prev_bin_index = (bin_mask >> 6) + 0x38;\n      }\n      else if (chunk_size < 0x15) {\n        bin_index = (chunk_size + 0x5c) * 8;\n        prev_bin_index = chunk_size + 0x5b;\n      }\n      else if (chunk_size < 0x55) {\n        bin_index = ((bin_mask >> 0xc) + 0x6f) * 8;\n        prev_bin_index = (bin_mask >> 0xc) + 0x6e;\n      }\n      else if (chunk_size < 0x155) {\n        bin_index = ((bin_mask >> 0xf) + 0x78) * 8;\n        prev_bin_index = (bin_mask >> 0xf) + 0x77;\n      }\n      else if (chunk_size < 0x555) {\n        bin_index = ((bin_mask >> 0x12) + 0x7d) * 8;\n        prev_bin_index = (bin_mask >> 0x12) + 0x7c;\n      }\n      else {\n        bin_index = 0x3f8;\n        prev_bin_index = 0x7e;\n      }\n      bin = *(undefined **)(&__malloc_08008af8_av_ + bin_index);\n      block = &DAT_20000444 + bin_index;\n      if (block == bin) {\n        DAT_20000450 = 1 << (prev_bin_index >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(bin + 4) & 0xfffffffc) <= bin_chunk_size) break;\n          bin = *(undefined **)(bin + 8);\n        } while (block != bin);\n        block = *(undefined **)(bin + 0xc);\n      }\n      chunk_size = DAT_20000450;\n      metadata[2] = bin;\n      metadata[3] = block;\n      *(undefined4 **)(block + 8) = metadata;\n      *(undefined4 **)(bin + 0xc) = metadata;\n    }\n    bin_mask = 1 << ((int)adjusted_size >> 2 & 0xffU);\n    if (bin_mask <= chunk_size) {\nLAB_08008c06:\n      if ((bin_mask & chunk_size) == 0) {\n        adjusted_size = adjusted_size & 0xfffffffc;\n        do {\n          bin_mask = bin_mask << 1;\n          adjusted_size = adjusted_size + 4;\n        } while ((bin_mask & chunk_size) == 0);\n      }\n      do {\n        new_metadata = (undefined4 *)(&__malloc_08008af8_av_ + adjusted_size * 8);\n        chunk_size = adjusted_size;\n        metadata = new_metadata;\n        do {\n          for (next_block = (undefined4 *)metadata[3]; metadata != next_block;\n              next_block = (undefined4 *)next_block[3]) {\n            bin_chunk_size = next_block[1] & 0xfffffffc;\n            diff = bin_chunk_size - adjusted_bin_size;\n            if (0xf < (int)diff) {\n              prev_bin_index = next_block[2];\n              bin_index = next_block[3];\n              metadata = (undefined4 *)(adjusted_bin_size + (int)next_block);\n              next_block[1] = adjusted_bin_size | 1;\n              *(int *)(prev_bin_index + 0xc) = bin_index;\n              *(int *)(bin_index + 8) = prev_bin_index;\n              DAT_2000045c = metadata;\n              DAT_20000460 = metadata;\n              metadata[2] = &DAT_20000454;\n              metadata[3] = &DAT_20000454;\n              metadata[1] = diff | 1;\n              *(uint *)((int)next_block + bin_chunk_size) = diff;\n              __malloc_08008af8_unlock(lock);\n              return next_block + 2;\n            }\n            if (-1 < (int)diff) {\n              bin_index = next_block[3];\n              prev_bin_index = next_block[2];\n              *(uint *)((int)next_block + bin_chunk_size + 4) = *(uint *)((int)next_block + bin_chunk_size + 4) | 1;\n              *(int *)(prev_bin_index + 0xc) = bin_index;\n              *(int *)(bin_index + 8) = prev_bin_index;\n              __malloc_08008af8_unlock(lock);\n              return next_block + 2;\n            }\n          }\n          chunk_size = chunk_size + 1;\n          metadata = metadata + 2;\n        } while ((chunk_size & 3) != 0);\n        do {\n          bin_chunk_size = adjusted_size & 3;\n          metadata = new_metadata + -2;\n          adjusted_size = adjusted_size - 1;\n          if (bin_chunk_size == 0) {\n            DAT_20000450 = DAT_20000450 & ~bin_mask;\n            break;\n          }\n          new_metadata = (undefined4 *)*new_metadata;\n        } while (new_metadata == metadata);\n        bin_mask = bin_mask * 2;\n        if ((DAT_20000450 <= bin_mask && bin_mask - DAT_20000450 != 0) || (adjusted_size = chunk_size, bin_mask == 0))\n        break;\n        for (; (bin_mask & DAT_20000450) == 0; bin_mask = bin_mask << 1) {\n          adjusted_size = adjusted_size + 4;\n        }\n      } while( true );\n    }\n  }\n  current = DAT_20000454;\n  adjusted_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((adjusted_bin_size <= adjusted_size) && (chunk_size = adjusted_size - adjusted_bin_size, 0xf < (int)chunk_size)) goto LAB_08008dac;\n  if (__malloc_08008af8_sbrk_base == (undefined1 *)0xffffffff) {\n    chunk_size = adjusted_bin_size + __malloc_08008af8_top_pad + 0x10;\n  }\n  else {\n    chunk_size = adjusted_bin_size + __malloc_08008af8_top_pad + 0x100f & 0xfffff000;\n  }\n  current_block = (undefined1 *)_sbrk_r(lock,chunk_size);\n  if (current_block == (undefined1 *)0xffffffff) {\nLAB_08008ed8:\n    adjusted_size = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    prev_block = current + adjusted_size;\n    if (prev_block < current_block || prev_block == current_block) {\n      new_block = __malloc_08008af8_current_mallinfo + chunk_size;\n      if ((prev_block != current_block) || (((uint)prev_block & 0xfff) != 0)) goto LAB_08008d02;\n      __malloc_08008af8_current_mallinfo = new_block;\n      *(uint *)(DAT_20000454 + 4) = adjusted_size + chunk_size | 1;\n    }\n    else {\n      if (current != &__malloc_08008af8_av_) goto LAB_08008ed8;\nLAB_08008d02:\n      __malloc_08008af8_current_mallinfo = __malloc_08008af8_current_mallinfo + chunk_size;\n      new_block = current_block;\n      if (__malloc_08008af8_sbrk_base != (undefined1 *)0xffffffff) {\n        __malloc_08008af8_current_mallinfo = __malloc_08008af8_current_mallinfo + ((int)current_block - (int)prev_block);\n        new_block = __malloc_08008af8_sbrk_base;\n      }\n      __malloc_08008af8_sbrk_base = new_block;\n      bin_mask = (uint)current_block & 7;\n      if (bin_mask == 0) {\n        bin_index = 0x1000;\n      }\n      else {\n        current_block = current_block + (8 - bin_mask);\n        bin_index = 0x1008 - bin_mask;\n      }\n      bin_index = bin_index - ((uint)(current_block + chunk_size) & 0xfff);\n      prev_bin_index = _sbrk_r(lock,bin_index);\n      if (prev_bin_index == -1) {\n        chunk_size = 1;\n        bin_index = 0;\n      }\n      else {\n        chunk_size = (prev_bin_index - (int)current_block) + bin_index | 1;\n      }\n      new_block = __malloc_08008af8_current_mallinfo + bin_index;\n      DAT_20000454 = current_block;\n      __malloc_08008af8_current_mallinfo = new_block;\n      *(uint *)(current_block + 4) = chunk_size;\n      if (current != &__malloc_08008af8_av_) {\n        if (adjusted_size < 0x10) {\n          *(undefined4 *)(current_block + 4) = 1;\n          goto LAB_08008eee;\n        }\n        adjusted_size = adjusted_size - 0xc & 0xfffffff8;\n        *(uint *)(current + 4) = *(uint *)(current + 4) & 1 | adjusted_size;\n        *(undefined4 *)(current + adjusted_size + 4) = 5;\n        *(undefined4 *)(current + adjusted_size + 8) = 5;\n        if (0xf < adjusted_size) {\n          _free_r(lock,current + 8);\n          new_block = __malloc_08008af8_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_08008af8_max_sbrked_mem < new_block) {\n      __malloc_08008af8_max_sbrked_mem = new_block;\n    }\n    adjusted_size = *(uint *)(DAT_20000454 + 4);\n    if (__malloc_08008af8_max_total_mem < new_block) {\n      __malloc_08008af8_max_total_mem = new_block;\n    }\n  }\n  chunk_size = (adjusted_size & 0xfffffffc) - adjusted_bin_size;\n  if ((adjusted_bin_size <= (adjusted_size & 0xfffffffc)) && (0xf < (int)chunk_size)) {\nLAB_08008dac:\n    current = DAT_20000454 + adjusted_bin_size;\n    *(uint *)(DAT_20000454 + 4) = adjusted_bin_size | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = current;\n    *(uint *)(current + 4) = chunk_size | 1;\n    __malloc_08008af8_unlock(lock);\n    return result;\n  }\nLAB_08008eee:\n  __malloc_08008af8_unlock(lock);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "malloc_08008af8",
                "param_1": "lock",
                "param_2": "size",
                "puVar1": "current_block",
                "puVar2": "prev_block",
                "uVar3": "chunk_size",
                "uVar4": "diff",
                "iVar5": "bin_index",
                "puVar6": "block",
                "uVar7": "bin_mask",
                "uVar8": "bin_chunk_size",
                "puVar9": "next_block",
                "puVar10": "new_block",
                "puVar11": "bin",
                "piVar12": "result",
                "uVar13": "adjusted_size",
                "uVar14": "adjusted_bin_size",
                "iVar15": "prev_bin_index",
                "puVar16": "metadata",
                "puVar17": "current",
                "puVar18": "new_metadata"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r",
                "_calloc_r"
            ],
            "called": [
                "_free_r",
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_char_0800901c",
            "code": "\nvoid * find_char_0800901c(void *buffer,int char_to_find,size_t buffer_size)\n\n{\n  uint temp_var1;\n  uint temp_var2;\n  uint *ptr_to_buffer;\n  uint masked_char;\n  bool is_buffer_empty;\n  \n  masked_char = char_to_find & 0xff;\n  if (((uint)buffer & 3) == 0) {\nLAB_0800904a:\n    if (3 < buffer_size) {\n      temp_var2 = (char_to_find & 0xffU) << 8 | masked_char;\n      ptr_to_buffer = (uint *)buffer;\n      do {\n        temp_var1 = *ptr_to_buffer ^ (temp_var2 | temp_var2 << 0x10);\n        buffer = ptr_to_buffer + 1;\n        if ((temp_var1 + 0xfefefeff & ~temp_var1 & 0x80808080) != 0) goto LAB_08009050;\n        buffer_size = buffer_size - 4;\n        ptr_to_buffer = (uint *)buffer;\n      } while (3 < buffer_size);\n    }\n    ptr_to_buffer = (uint *)buffer;\n    if (buffer_size == 0) {\n      buffer = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      buffer = ptr_to_buffer;\n                    /* WARNING: Load size is inaccurate */\n      if (*buffer != masked_char) {\n        ptr_to_buffer = (uint *)(buffer_size + (int)buffer);\n        do {\n          buffer = (void *)((int)buffer + 1);\n          if (ptr_to_buffer == (uint *)buffer) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n        } while (*buffer != masked_char);\n      }\n    }\n  }\n  else {\n    temp_var2 = buffer_size - 1;\n    if (buffer_size == 0) {\nLAB_0800906c:\n      buffer = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*buffer != masked_char) {\n        ptr_to_buffer = (uint *)((int)buffer + 1);\n        do {\n          buffer = ptr_to_buffer;\n          buffer_size = temp_var2;\n          if (((uint)buffer & 3) == 0) goto LAB_0800904a;\n          is_buffer_empty = temp_var2 == 0;\n          temp_var2 = temp_var2 - 1;\n          if (is_buffer_empty) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n          ptr_to_buffer = (uint *)((int)buffer + 1);\n        } while (*buffer != masked_char);\n      }\n    }\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_char_0800901c",
                "__s": "buffer",
                "__c": "char_to_find",
                "__n": "buffer_size",
                "uVar1": "temp_var1",
                "uVar2": "temp_var2",
                "puVar3": "ptr_to_buffer",
                "uVar4": "masked_char",
                "bVar5": "is_buffer_empty"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_malloc_recursive_lock_080090a8",
            "code": "\nvoid acquireMallocRecursiveLock_080090a8(void)\n\n{\n  acquireRecursiveLock(&__lock___malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_malloc_recursive_lock_080090a8",
                "__retarget_lock_acquire_recursive": "acquireRecursiveLock"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_mutex_080090b4",
            "code": "\nvoid releaseRecursiveMutex_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_mutex_080090b4",
                "__lock___malloc_recursive_mutex": "lock"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_update_memory_080090c0",
            "code": "\nundefined4 * allocateOrUpdateMemory_080090c0(int memorySize,uint index)\n\n{\n  undefined4 *pointerToValue;\n  int memoryBlock;\n  \n  memoryBlock = *(int *)(memorySize + 0x4c);\n  if (memoryBlock == 0) {\n    memoryBlock = _allocateMemory_r(memorySize,4,0x21);\n    *(int *)(memorySize + 0x4c) = memoryBlock;\n    if (memoryBlock == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  pointerToValue = *(undefined4 **)(memoryBlock + index * 4);\n  if (pointerToValue == (undefined4 *)0x0) {\n    memoryBlock = 1 << (index & 0xff);\n    pointerToValue = (undefined4 *)_allocateMemory_r(memorySize,1,(memoryBlock + 5) * 4);\n    if (pointerToValue == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    pointerToValue[1] = index;\n    pointerToValue[2] = memoryBlock;\n  }\n  else {\n    *(undefined4 *)(memoryBlock + index * 4) = *pointerToValue;\n  }\n  pointerToValue[3] = 0;\n  pointerToValue[4] = 0;\n  return pointerToValue;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_update_memory_080090c0",
                "param_1": "memorySize",
                "param_2": "index",
                "puVar1": "pointerToValue",
                "iVar2": "memoryBlock",
                "calloc": "allocateMemory"
            },
            "calling": [
                "__multiply",
                "__lshift",
                "_dtoa_r",
                "__d2b",
                "__mdiff",
                "__multadd",
                "__i2b",
                "__pow5mult"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "copy_data_to_pointer_0800910c",
            "code": "\nvoid copyDataToPointer_0800910c(int sourceAddress,undefined4 *destinationPointer)\n\n{\n  int dataAddress;\n  \n  if (destinationPointer != (undefined4 *)0x0) {\n    dataAddress = *(int *)(sourceAddress + 0x4c);\n    *destinationPointer = *(undefined4 *)(dataAddress + destinationPointer[1] * 4);\n    *(undefined4 **)(dataAddress + destinationPointer[1] * 4) = destinationPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "copy_data_to_pointer_0800910c",
                "param_1": "sourceAddress",
                "param_2": "destinationPointer",
                "iVar1": "dataAddress"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_new_value_08009120",
            "code": "\nundefined4 * calculateNewValue_08009120(int param1,undefined4 *inputArray,int multiplier,uint carry)\n\n{\n  undefined4 *resultArray;\n  uint carryTemp;\n  int numElements;\n  uint *currentElement;\n  int index;\n  \n  index = 0;\n  numElements = inputArray[4];\n  currentElement = inputArray + 5;\n  do {\n    index = index + 1;\n    carry = multiplier * (*currentElement & 0xffff) + carry;\n    carryTemp = multiplier * (*currentElement >> 0x10) + (carry >> 0x10);\n    *currentElement = (carry & 0xffff) + carryTemp * 0x10000;\n    carry = carryTemp >> 0x10;\n    currentElement = currentElement + 1;\n  } while (index < numElements);\n  resultArray = inputArray;\n  if (carry != 0) {\n    if ((int)inputArray[2] <= numElements) {\n      resultArray = (undefined4 *)_Balloc(param1,inputArray[1] + 1);\n      memcpy(resultArray + 3,inputArray + 3,(inputArray[4] + 2) * 4);\n      index = *(int *)(param1 + 0x4c);\n      *inputArray = *(undefined4 *)(index + inputArray[1] * 4);\n      *(undefined4 **)(index + inputArray[1] * 4) = inputArray;\n    }\n    resultArray[numElements + 5] = carry;\n    resultArray[4] = numElements + 1;\n  }\n  return resultArray;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_new_value_08009120",
                "param_1": "param1",
                "param_2": "inputArray",
                "param_3": "multiplier",
                "param_4": "carry",
                "puVar1": "resultArray",
                "uVar2": "carryTemp",
                "iVar3": "numElements",
                "puVar4": "currentElement",
                "iVar5": "index"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZeros;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "_dtoa_r",
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_leading_zeros_080091e4",
            "code": "\nint countLeadingZeros_080091e4(uint *number)\n\n{\n  int leadingZerosCount;\n  uint temp;\n  \n  temp = *number;\n  if ((temp & 7) == 0) {\n    if ((temp & 0xffff) == 0) {\n      temp = temp >> 0x10;\n      leadingZerosCount = 0x10;\n    }\n    else {\n      leadingZerosCount = 0;\n    }\n    if ((temp & 0xff) == 0) {\n      temp = temp >> 8;\n      leadingZerosCount = leadingZerosCount + 8;\n    }\n    if ((temp & 0xf) == 0) {\n      temp = temp >> 4;\n      leadingZerosCount = leadingZerosCount + 4;\n    }\n    if ((temp & 3) == 0) {\n      temp = temp >> 2;\n      leadingZerosCount = leadingZerosCount + 2;\n    }\n    if (-1 < (int)(temp << 0x1f)) {\n      temp = temp >> 1;\n      if (temp == 0) {\n        return 0x20;\n      }\n      leadingZerosCount = leadingZerosCount + 1;\n    }\n    *number = temp;\n    return leadingZerosCount;\n  }\n  if ((int)(temp << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(temp << 0x1e)) {\n    *number = temp >> 2;\n    return 2;\n  }\n  *number = temp >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "number",
                "iVar1": "leadingZerosCount",
                "uVar2": "temp"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_block_08009244",
            "code": "\nvoid initializeBlock_08009244(undefined4 size,undefined4 value)\n\n{\n  int blockAddress;\n  \n  blockAddress = _Balloc(size,1);\n  *(undefined4 *)(blockAddress + 0x10) = 1;\n  *(undefined4 *)(blockAddress + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_block_08009244",
                "param_1": "size",
                "param_2": "value",
                "iVar1": "blockAddress"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_checksum_08009258",
            "code": "\nvoid calculateChecksum_08009258(undefined4 param1,int buffer1,int buffer2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int bufferSize;\n  uint sum;\n  uint *currentPtr;\n  uint startPtr;\n  uint *endPtr;\n  uint tempSum;\n  int size1;\n  int size2;\n  uint endPtrCalc;\n  int buffer1Size;\n  int tempVar;\n  uint *tempPtr1;\n  uint *tempPtr2;\n  uint *tempPtr3;\n  uint *tempPtr4;\n  uint *tempPtr5;\n  \n  buffer1Size = *(int *)(buffer1 + 0x10);\n  size1 = *(int *)(buffer2 + 0x10);\n  size2 = size1;\n  tempVar = buffer1;\n  if (buffer1Size < size1) {\n    size2 = buffer1Size;\n    buffer1Size = size1;\n    tempVar = buffer2;\n    buffer2 = buffer1;\n  }\n  size1 = buffer1Size + size2;\n  bufferSize = *(int *)(tempVar + 4);\n  if (*(int *)(tempVar + 8) < size1) {\n    bufferSize = bufferSize + 1;\n  }\n  bufferSize = _Balloc(param1,bufferSize);\n  tempPtr5 = (uint *)(bufferSize + 0x14);\n  tempPtr4 = tempPtr5 + size1;\n  for (currentPtr = tempPtr5; currentPtr < tempPtr4; currentPtr = currentPtr + 1) {\n    *currentPtr = 0;\n  }\n  startPtr = buffer2 + 0x14;\n  endPtrCalc = startPtr + size2 * 4;\n  currentPtr = (uint *)(tempVar + 0x14);\n  if (startPtr < endPtrCalc) {\n    endPtr = (uint *)(startPtr + ((endPtrCalc - buffer2) - 0x15 & 0xfffffffc));\n    tempPtr3 = (uint *)(buffer2 + 0x10);\n    do {\n      while( true ) {\n        tempPtr3 = tempPtr3 + 1;\n        startPtr = *tempPtr3 & 0xffff;\n        if (startPtr != 0) break;\n        startPtr = *tempPtr3 >> 0x10;\n        if (startPtr == 0) goto LAB_080092d2;\nLAB_0800932c:\n        tempSum = *tempPtr5;\n        sum = 0;\n        ptr1 = currentPtr;\n        tempPtr1 = tempPtr5;\n        endPtrCalc = tempSum;\n        do {\n          tempPtr2 = tempPtr1;\n          sum = sum + startPtr * *(ushort *)ptr1 + (endPtrCalc >> 0x10);\n          *tempPtr2 = tempSum & 0xffff | sum * 0x10000;\n          ptr2 = ptr1 + 1;\n          endPtrCalc = tempPtr2[1];\n          tempSum = startPtr * (*ptr1 >> 0x10) + (endPtrCalc & 0xffff) + (sum >> 0x10);\n          sum = tempSum >> 0x10;\n          ptr1 = ptr2;\n          tempPtr1 = tempPtr2 + 1;\n        } while (ptr2 < currentPtr + buffer1Size);\n        tempPtr2[1] = tempSum;\n        tempPtr5 = tempPtr5 + 1;\n        if (endPtr == tempPtr3) goto LAB_0800937a;\n      }\n      endPtrCalc = 0;\n      ptr1 = tempPtr5;\n      tempPtr1 = currentPtr;\n      do {\n        ptr2 = ptr1;\n        tempPtr2 = tempPtr1 + 1;\n        tempSum = startPtr * (*tempPtr1 & 0xffff) + (*ptr2 & 0xffff) + endPtrCalc;\n        sum = startPtr * (*tempPtr1 >> 0x10) + (*ptr2 >> 0x10) + (tempSum >> 0x10);\n        endPtrCalc = sum >> 0x10;\n        *ptr2 = tempSum & 0xffff | sum * 0x10000;\n        ptr1 = ptr2 + 1;\n        tempPtr1 = tempPtr2;\n      } while (tempPtr2 < currentPtr + buffer1Size);\n      ptr2[1] = endPtrCalc;\n      startPtr = *tempPtr3 >> 0x10;\n      if (startPtr != 0) goto LAB_0800932c;\nLAB_080092d2:\n      tempPtr5 = tempPtr5 + 1;\n    } while (endPtr != tempPtr3);\n  }\nLAB_0800937a:\n  if (0 < size1) {\n    startPtr = tempPtr4[-1];\n    tempPtr4 = tempPtr4 + -1;\n    while ((startPtr == 0 && (size1 = size1 + -1, size1 != 0))) {\n      tempPtr4 = tempPtr4 + -1;\n      startPtr = *tempPtr4;\n    }\n  }\n  *(int *)(bufferSize + 0x10) = size1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_checksum_08009258",
                "param_1": "param1",
                "param_2": "buffer1",
                "param_3": "buffer2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "bufferSize",
                "uVar4": "sum",
                "puVar5": "currentPtr",
                "uVar6": "startPtr",
                "puVar7": "endPtr",
                "uVar8": "tempSum",
                "iVar9": "size1",
                "iVar10": "size2",
                "uVar11": "endPtrCalc",
                "iVar12": "buffer1Size",
                "iVar13": "tempVar",
                "puVar14": "tempPtr1",
                "puVar15": "tempPtr2",
                "puVar16": "tempPtr3",
                "puVar17": "tempPtr4",
                "puVar18": "tempPtr5"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "multiply_and_add_080093a4",
            "code": "\nundefined4 * multiply_and_add_080093a4(int input_value,undefined4 *result_array,uint array_length)\n\n{\n  int auxiliary_var_1;\n  int auxiliary_var_2;\n  undefined4 *temp_var_1;\n  undefined4 *temp_var_2;\n  \n  if ((array_length & 3) != 0) {\n    result_array = (undefined4 *)\n              __multadd(input_value,result_array,*(undefined4 *)(&p05_6092 + ((array_length & 3) - 1) * 4),0);\n  }\n  auxiliary_var_2 = (int)array_length >> 2;\n  if (auxiliary_var_2 != 0) {\n    temp_var_2 = *(undefined4 **)(input_value + 0x48);\n    if (temp_var_2 == (undefined4 *)0x0) {\n      temp_var_2 = (undefined4 *)_Balloc(input_value,1);\n      temp_var_2[4] = 1;\n      temp_var_2[5] = 0x271;\n      *(undefined4 **)(input_value + 0x48) = temp_var_2;\n      *temp_var_2 = 0;\n    }\n    temp_var_1 = result_array;\n    if (auxiliary_var_2 << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    auxiliary_var_2 = auxiliary_var_2 >> 1;\n    temp_var_1 = temp_var_2;\n    if (auxiliary_var_2 != 0) {\n      while( true ) {\n        temp_var_2 = (undefined4 *)*temp_var_1;\n        if (temp_var_2 == (undefined4 *)0x0) {\n          temp_var_2 = (undefined4 *)__multiply(input_value,temp_var_1,temp_var_1);\n          *temp_var_1 = temp_var_2;\n          *temp_var_2 = 0;\n        }\n        temp_var_1 = result_array;\n        if (-1 < auxiliary_var_2 << 0x1f) break;\nLAB_080093d2:\n        result_array = (undefined4 *)__multiply(input_value,temp_var_1,temp_var_2);\n        if (temp_var_1 == (undefined4 *)0x0) break;\n        auxiliary_var_1 = *(int *)(input_value + 0x4c);\n        auxiliary_var_2 = auxiliary_var_2 >> 1;\n        *temp_var_1 = *(undefined4 *)(auxiliary_var_1 + temp_var_1[1] * 4);\n        *(undefined4 **)(auxiliary_var_1 + temp_var_1[1] * 4) = temp_var_1;\n        temp_var_1 = temp_var_2;\n        if (auxiliary_var_2 == 0) {\n          return result_array;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return result_array;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "multiply_and_add_080093a4",
                "param_1": "input_value",
                "param_2": "result_array",
                "param_3": "array_length",
                "iVar1": "auxiliary_var_1",
                "iVar2": "auxiliary_var_2",
                "puVar3": "temp_var_1",
                "puVar4": "temp_var_2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "__multadd",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "extracted_bits_08009444",
            "code": "\nvoid extractedBits_08009444(int sourceAddress,undefined4 *paramsArray,uint bitCount)\n\n{\n  int tempVar1;\n  int tempVar2;\n  int tempVar3;\n  undefined4 tempVar4;\n  int offset;\n  int tempVar6;\n  uint *destArray;\n  uint *sourceArray;\n  uint *sourcePointer;\n  uint *endPointer;\n  int length;\n  int newLength;\n  uint carryOver;\n  uint *destPointer;\n  \n  offset = paramsArray[4];\n  length = (int)bitCount >> 5;\n  newLength = length + offset + 1;\n  tempVar3 = paramsArray[1];\n  tempVar2 = paramsArray[2];\n  if ((int)paramsArray[2] < newLength) {\n    do {\n      tempVar6 = tempVar2 * 2;\n      tempVar1 = tempVar2 * -2;\n      tempVar3 = tempVar3 + 1;\n      tempVar2 = tempVar6;\n    } while (newLength != tempVar6 && newLength + tempVar1 < 0 == SBORROW4(newLength,tempVar6));\n  }\n  tempVar2 = _Balloc(sourceAddress,tempVar3);\n  destArray = (uint *)(tempVar2 + 0x14);\n  if (0 < length) {\n    endPointer = destArray + length;\n    sourceArray = destArray;\n    do {\n      destPointer = sourceArray + 1;\n      *sourceArray = 0;\n      destArray = endPointer;\n      sourceArray = destPointer;\n    } while (destPointer != endPointer);\n  }\n  tempVar3 = paramsArray[4];\n  sourceArray = paramsArray + 5;\n  bitCount = bitCount & 0x1f;\n  if (bitCount == 0) {\n    destArray = destArray + -1;\n    endPointer = sourceArray;\n    do {\n      destPointer = endPointer + 1;\n      destArray = destArray + 1;\n      *destArray = *endPointer;\n      endPointer = destPointer;\n    } while (destPointer < sourceArray + tempVar3);\n  }\n  else {\n    carryOver = 0;\n    endPointer = sourceArray;\n    do {\n      destPointer = destArray;\n      *destPointer = *endPointer << bitCount | carryOver;\n      sourcePointer = endPointer + 1;\n      carryOver = *endPointer >> (0x20 - bitCount & 0xff);\n      destArray = destPointer + 1;\n      endPointer = sourcePointer;\n    } while (sourcePointer < sourceArray + tempVar3);\n    destPointer[1] = carryOver;\n    if (carryOver != 0) {\n      newLength = length + offset + 2;\n    }\n  }\n  offset = *(int *)(sourceAddress + 0x4c);\n  tempVar3 = paramsArray[1];\n  tempVar4 = *(undefined4 *)(offset + tempVar3 * 4);\n  *(int *)(tempVar2 + 0x10) = newLength + -1;\n  *paramsArray = tempVar4;\n  *(undefined4 **)(offset + tempVar3 * 4) = paramsArray;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "extracted_bits_08009444",
                "param_1": "sourceAddress",
                "param_2": "paramsArray",
                "param_3": "bitCount",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "iVar3": "tempVar3",
                "uVar4": "tempVar4",
                "iVar5": "offset",
                "iVar6": "tempVar6",
                "puVar7": "destArray",
                "puVar8": "sourceArray",
                "puVar9": "destPointer",
                "puVar10": "sourcePointer",
                "puVar11": "endPointer",
                "iVar12": "length",
                "iVar13": "newLength",
                "uVar14": "carryOver"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptr_array2_elem;\n  int array2_start_index;\n  uint *ptr_array1_elem;\n  \n  array2_start_index = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - array2_start_index;\n  if (difference == 0) {\n    ptr_array2_elem = (uint *)(array2 + 0x14 + array2_start_index * 4);\n    ptr_array1_elem = (uint *)(array1 + 0x14) + array2_start_index;\n    do {\n      ptr_array1_elem = ptr_array1_elem + -1;\n      ptr_array2_elem = ptr_array2_elem + -1;\n      if (*ptr_array1_elem != *ptr_array2_elem) {\n        if (*ptr_array2_elem <= *ptr_array1_elem) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr_array1_elem);\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "difference",
                "iVar3": "array2_start_index",
                "puVar2": "ptr_array2_elem",
                "puVar4": "ptr_array1_elem"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "reverse_and_allocate_08009530",
            "code": "\nvoid reverseAndAllocate_08009530(undefined4 size_to_allocate,uint *array1,uint *array2,undefined4 param4)\n\n{\n  int allocated_array;\n  uint *array1_length;\n  uint array1_size;\n  uint temp_var;\n  undefined4 flag;\n  uint *ptr1;\n  uint *ptr2;\n  uint *array1_ptr;\n  uint *array2_ptr;\n  uint *array2_end;\n  int temp_int;\n  uint *array2_index;\n  uint array2_size;\n  uint *temp_ptr;\n  \n  array1_length = (uint *)array2[4];\n  array2_end = array1 + 5;\n  array2_index = array2 + 5;\n  ptr2 = array2_end;\n  array1_ptr = array1;\n  if ((uint *)array1[4] == array1_length) {\n    ptr1 = array2_end + (int)array1_length;\n    array1_length = array2_index + (int)array1_length;\n    while( true ) {\n      ptr1 = ptr1 + -1;\n      array1_length = array1_length + -1;\n      if (*ptr1 != *array1_length) break;\n      if (ptr1 <= array2_end) {\n        temp_int = _Balloc(size_to_allocate,0,ptr1,array1_length,param4);\n        *(undefined4 *)(temp_int + 0x10) = 1;\n        *(undefined4 *)(temp_int + 0x14) = 0;\n        return;\n      }\n    }\n    flag = 0;\n    if (*array1_length <= *ptr1) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)array1[4] - (int)array1_length) {\n    flag = 0;\n    ptr1 = array2;\n    goto LAB_08009578;\n  }\n  flag = 1;\n  ptr1 = array2_end;\n  array1_length = array1;\n  ptr2 = array2_index;\n  array1_ptr = array2;\n  array2 = array1;\n  array2_index = array2_end;\nLAB_08009578:\n  allocated_array = _Balloc(size_to_allocate,array1_ptr[1],ptr1,array1_length,param4);\n  temp_int = 0;\n  array2_size = array1_ptr[4];\n  array1_size = array2[4];\n  *(undefined4 *)(allocated_array + 0xc) = flag;\n  array2_end = ptr2 + array2_size;\n  array1_length = (uint *)(allocated_array + 0x14);\n  array1_ptr = array2_index;\n  do {\n    temp_ptr = ptr2 + 1;\n    array2_ptr = array1_ptr + 1;\n    temp_var = ((*ptr2 & 0xffff) + temp_int) - (*array1_ptr & 0xffff);\n    temp_int = ((*ptr2 >> 0x10) - (*array1_ptr >> 0x10)) + ((int)temp_var >> 0x10);\n    temp_var = temp_var & 0xffff | temp_int * 0x10000;\n    ptr1 = array1_length + 1;\n    *array1_length = temp_var;\n    temp_int = temp_int >> 0x10;\n    array1_length = ptr1;\n    ptr2 = temp_ptr;\n    array1_ptr = array2_ptr;\n  } while (array2_ptr < array2_index + array1_size);\n  array1_length = temp_ptr;\n  ptr2 = ptr1;\n  if (temp_ptr < array2_end) {\n    do {\n      array1_ptr = array1_length + 1;\n      array1_size = (*array1_length & 0xffff) + temp_int;\n      temp_int = ((int)array1_size >> 0x10) + (*array1_length >> 0x10);\n      temp_var = array1_size & 0xffff | temp_int * 0x10000;\n      *ptr2 = temp_var;\n      temp_int = temp_int >> 0x10;\n      array1_length = array1_ptr;\n      ptr2 = ptr2 + 1;\n    } while (array1_ptr < array2_end);\n    ptr1 = (uint *)((int)ptr1 + ((int)array2_end + ~(uint)temp_ptr & 0xfffffffc) + 4);\n  }\n  ptr1 = ptr1 + -1;\n  while (temp_var == 0) {\n    ptr1 = ptr1 + -1;\n    array2_size = array2_size - 1;\n    temp_var = *ptr1;\n  }\n  *(uint *)(allocated_array + 0x10) = array2_size;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "reverse_and_allocate_08009530",
                "param_1": "size_to_allocate",
                "param_2": "array1",
                "param_3": "array2",
                "param_4": "param4",
                "iVar1": "allocated_array",
                "puVar2": "array1_length",
                "uVar3": "array1_size",
                "uVar4": "temp_var",
                "uVar5": "flag",
                "puVar6": "ptr1",
                "puVar7": "ptr2",
                "puVar8": "temp_ptr",
                "puVar9": "array1_ptr",
                "puVar10": "array2_ptr",
                "puVar11": "array2_end",
                "puVar13": "array2_index",
                "iVar12": "temp_int",
                "uVar14": "array2_size"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "reverse_bits_08009630",
            "code": "\nint reverseBits_08009630(undefined4 inputBuffer,undefined4 param2,uint param3,uint param4,int *result1,\n                int *result2)\n\n{\n  int buffer;\n  uint bits;\n  int bitsOffset;\n  int result;\n  uint shiftedBits;\n  uint temp;\n  undefined8 resultBits;\n  uint temp1;\n  uint mask;\n  \n  buffer = _Balloc(inputBuffer,1);\n  temp = (param4 << 1) >> 0x15;\n  mask = param4 & 0xfffff;\n  if (temp != 0) {\n    mask = mask | 0x100000;\n  }\n  if (param3 == 0) {\n    bitsOffset = __lo0bits(&mask);\n    result = 1;\n    bits = bitsOffset + 0x20;\n    *(undefined4 *)(buffer + 0x10) = 1;\n    *(uint *)(buffer + 0x14) = mask;\n  }\n  else {\n    temp1 = param3;\n    bits = __lo0bits(&temp1);\n    if (bits == 0) {\n      *(uint *)(buffer + 0x14) = temp1;\n    }\n    else {\n      shiftedBits = mask << (0x20 - bits & 0xff);\n      mask = mask >> (bits & 0xff);\n      *(uint *)(buffer + 0x14) = shiftedBits | temp1;\n    }\n    if (mask == 0) {\n      result = 1;\n    }\n    else {\n      result = 2;\n    }\n    *(uint *)(buffer + 0x18) = mask;\n    *(int *)(buffer + 0x10) = result;\n  }\n  if (temp == 0) {\n    *result1 = bits - 0x432;\n    resultBits = __hi0bits(*(undefined4 *)(buffer + result * 4 + 0x10));\n    *result2 = (int)((ulonglong)resultBits >> 0x20) * 0x20 - (int)resultBits;\n    return buffer;\n  }\n  *result1 = (temp - 0x433) + bits;\n  *result2 = 0x35 - bits;\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08009630": "reverse_bits_08009630",
                "param_1": "inputBuffer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "result1",
                "param_6": "result2",
                "iVar1": "buffer",
                "uVar2": "bits",
                "iVar3": "bitsOffset",
                "iVar4": "result",
                "uVar5": "shiftedBits",
                "uVar6": "temp",
                "uVar7": "resultBits",
                "local_20": "temp1",
                "local_1c": "mask"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__hi0bits",
                "__lo0bits",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_exponent_080096e0",
            "code": "\ndouble calculateExponent_080096e0(double inputValue,int *exponent)\n\n{\n  uint temp1;\n  uint temp2;\n  int *exponentPtr;\n  int tempVar1;\n  uint tempVar2;\n  double result;\n  \n  tempVar1 = 0;\n  tempVar2 = temp1 & 0x7fffffff;\n  *exponentPtr = 0;\n  if ((tempVar2 < 0x7ff00000) && ((tempVar2 | (uint)exponent) != 0)) {\n    if (tempVar2 < 0x100000) {\n      result = (double)__muldf3(exponent,temp1,0,0x43500000);\n      tempVar1 = -0x36;\n      tempVar2 = temp2 & 0x7fffffff;\n    }\n    *exponentPtr = ((int)tempVar2 >> 0x14) + -0x3fe + tempVar1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_exponent_080096e0",
                "__x": "inputValue",
                "__exponent": "exponent",
                "in_r1": "temp1",
                "extraout_r1": "temp2",
                "in_r2": "exponentPtr",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "in_d0": "result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocateMemory_08009744(int *errorFlag,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "errorFlag",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_and_zero_terminate_08009768",
            "code": "\nchar * copy_and_zero_terminate_08009768(char *destination,char *source,size_t length)\n\n{\n  char current_char;\n  uint *source_ptr;\n  uint *destination_ptr;\n  uint *temp_ptr;\n  uint current_value;\n  \n  destination_ptr = (uint *)destination;\n  if (((((uint)destination | (uint)source) & 3) == 0) && (source_ptr = (uint *)source, 3 < length)) {\n    do {\n      source = (char *)(source_ptr + 1);\n      current_value = *source_ptr;\n      if ((current_value + 0xfefefeff & ~current_value & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      source_ptr = destination_ptr + 1;\n      *destination_ptr = current_value;\n      destination_ptr = source_ptr;\n      source_ptr = (uint *)source;\n    } while (3 < length);\n  }\n  source_ptr = (uint *)source;\n  if (length != 0) {\nLAB_0800979c:\n    current_char = *(char *)source_ptr;\n    *(char *)destination_ptr = current_char;\n    while( true ) {\n      destination_ptr = (uint *)((int)destination_ptr + 1);\n      length = length - 1;\n      if (current_char == '\\0') break;\n      if (length == 0) {\n        return destination;\n      }\n      source_ptr = (uint *)((int)source_ptr + 1);\n      current_char = *(char *)source_ptr;\n      *(char *)destination_ptr = current_char;\n    }\n    if (length != 0) {\n      source_ptr = destination_ptr;\n      do {\n        temp_ptr = (uint *)((int)source_ptr + 1);\n        *(char *)source_ptr = '\\0';\n        source_ptr = temp_ptr;\n      } while (temp_ptr != (uint *)(length + (int)destination_ptr));\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_and_zero_terminate_08009768",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "cVar1": "current_char",
                "puVar2": "source_ptr",
                "puVar3": "destination_ptr",
                "puVar4": "temp_ptr",
                "uVar5": "current_value"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_update_buffer_080097cc",
            "code": "\nundefined4 copy_and_update_buffer_080097cc(undefined4 *error_code,void **buffers,int *buffer_sizes)\n\n{\n  void *src_buffer;\n  void *dest_buffer;\n  int remaining_bytes;\n  void *buffer_limit;\n  void *copy_size;\n  void **next_buffer;\n  void **current_buffer;\n  void *source;\n  size_t bytes_to_copy;\n  \n  if (buffer_sizes[2] != 0) {\n    src_buffer = *buffers;\n    buffer_limit = buffers[2];\n    current_buffer = (void **)*buffer_sizes;\n    do {\n      do {\n        next_buffer = current_buffer + 2;\n        source = *current_buffer;\n        copy_size = current_buffer[1];\n        current_buffer = next_buffer;\n      } while (copy_size == (void *)0x0);\n      dest_buffer = copy_size;\n      if ((buffer_limit <= copy_size) && (dest_buffer = buffer_limit, (*(ushort *)(buffers + 3) & 0x480) != 0)) {\n        bytes_to_copy = (int)src_buffer - (int)buffers[4];\n        buffer_limit = (void *)(((int)buffers[5] * 3) / 2);\n        src_buffer = (void *)((int)copy_size + bytes_to_copy + 1);\n        if (buffer_limit < src_buffer) {\n          buffer_limit = src_buffer;\n        }\n        if ((int)((uint)*(ushort *)(buffers + 3) << 0x15) < 0) {\n          dest_buffer = (void *)_malloc_r(error_code,buffer_limit);\n          if (dest_buffer == (void *)0x0) {\nLAB_08009896:\n            *error_code = 0xc;\n            *(ushort *)(buffers + 3) = *(ushort *)(buffers + 3) | 0x40;\n            buffer_sizes[1] = 0;\n            buffer_sizes[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(dest_buffer,buffers[4],bytes_to_copy);\n          *(ushort *)(buffers + 3) = *(ushort *)(buffers + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          dest_buffer = (void *)_realloc_r(error_code);\n          if (dest_buffer == (void *)0x0) {\n            _free_r(error_code,buffers[4]);\n            goto LAB_08009896;\n          }\n        }\n        src_buffer = (void *)((int)dest_buffer + bytes_to_copy);\n        buffers[5] = buffer_limit;\n        buffers[4] = dest_buffer;\n        *buffers = src_buffer;\n        buffers[2] = (void *)((int)buffer_limit - bytes_to_copy);\n        dest_buffer = copy_size;\n      }\n      memmove(src_buffer,source,(size_t)dest_buffer);\n      remaining_bytes = buffer_sizes[2];\n      buffer_limit = (void *)((int)buffers[2] - (int)dest_buffer);\n      src_buffer = (void *)((int)*buffers + (int)dest_buffer);\n      buffers[2] = buffer_limit;\n      *buffers = src_buffer;\n      buffer_sizes[2] = remaining_bytes - (int)copy_size;\n    } while (remaining_bytes - (int)copy_size != 0);\n  }\n  buffer_sizes[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_update_buffer_080097cc",
                "param_1": "error_code",
                "param_2": "buffers",
                "param_3": "buffer_sizes",
                "pvVar1": "src_buffer",
                "pvVar2": "dest_buffer",
                "iVar3": "remaining_bytes",
                "pvVar4": "buffer_limit",
                "pvVar5": "copy_size",
                "ppvVar6": "next_buffer",
                "ppvVar7": "current_buffer",
                "__src": "source",
                "__n": "bytes_to_copy"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_atexit_table_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateAtexitTable_080098c0(int mode,undefined4 func,undefined4 constructObj,undefined4 destructObj)\n\n{\n  undefined *atexitTable;\n  undefined4 returnValue;\n  uint bitMask;\n  uint currentIndex;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  atexitTable = DAT_20000168;\n  currentIndex = *(uint *)(DAT_20000168 + 4);\n  if ((int)currentIndex < 0x20) {\n    if (mode != 0) {\n      *(undefined4 *)(DAT_20000168 + currentIndex * 4 + 0x88) = constructObj;\n      bitMask = 1 << (currentIndex & 0xff);\n      *(uint *)(atexitTable + 0x188) = *(uint *)(atexitTable + 0x188) | bitMask;\n      *(undefined4 *)(atexitTable + currentIndex * 4 + 0x108) = destructObj;\n      if (mode == 2) {\n        *(uint *)(atexitTable + 0x18c) = bitMask | *(uint *)(atexitTable + 0x18c);\n      }\n    }\n    *(uint *)(atexitTable + 4) = currentIndex + 1;\n    returnValue = __atexit_recursive_mutex;\n    *(undefined4 *)(atexitTable + (currentIndex + 2) * 4) = func;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_atexit_table_080098c0",
                "param_1": "mode",
                "param_2": "func",
                "param_3": "constructObj",
                "param_4": "destructObj",
                "puVar1": "atexitTable",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "currentIndex"
            },
            "calling": [
                "atexit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "initialize_memory_08009980",
            "code": "\nundefined4 * initializeMemory_08009980(undefined4 size,int numRows,int numColumns)\n\n{\n  undefined4 *memoryBlock;\n  size_t blockSize;\n  undefined4 *pointer;\n  \n  memoryBlock = (undefined4 *)_malloc_r(size,numColumns * numRows);\n  if (memoryBlock == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  blockSize = (memoryBlock[-1] & 0xfffffffc) - 4;\n  if (blockSize < 0x25) {\n    pointer = memoryBlock;\n    if (0x13 < blockSize) {\n      *memoryBlock = 0;\n      memoryBlock[1] = 0;\n      if (0x1b < blockSize) {\n        memoryBlock[2] = 0;\n        memoryBlock[3] = 0;\n        if (blockSize == 0x24) {\n          memoryBlock[4] = 0;\n          memoryBlock[5] = 0;\n          pointer = memoryBlock + 6;\n        }\n        else {\n          pointer = memoryBlock + 4;\n        }\n        *pointer = 0;\n        pointer[1] = 0;\n        pointer[2] = 0;\n        return memoryBlock;\n      }\n      pointer = memoryBlock + 2;\n    }\n    *pointer = 0;\n    pointer[1] = 0;\n    pointer[2] = 0;\n    return memoryBlock;\n  }\n  memset(memoryBlock,0,blockSize);\n  return memoryBlock;\n}\n\n",
            "renaming": {
                "FUN_08009980": "initialize_memory_08009980",
                "param_1": "size",
                "param_2": "numRows",
                "param_3": "numColumns",
                "__s": "memoryBlock",
                "__n": "blockSize",
                "puVar1": "pointer"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099ec": {
            "entrypoint": "0x080099ec",
            "current_name": "extract_value_080099ec",
            "code": "\nuint extractValue_080099ec(undefined4 status,uint *output,byte *input,int size)\n\n{\n  uint result;\n  uint defaultOutput;\n  \n  if (output == (uint *)0x0) {\n    output = &defaultOutput;\n  }\n  if (input == (byte *)0x0) {\n    return 0;\n  }\n  if (size == 0) {\n    result = 0xfffffffe;\n  }\n  else {\n    *output = (uint)*input;\n    result = (uint)*input;\n    if (result != 0) {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080099ec": "extract_value_080099ec",
                "param_1": "status",
                "param_2": "output",
                "param_3": "input",
                "param_4": "size",
                "uVar1": "result",
                "uStack_4": "defaultOutput"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "memmove_08009a18",
            "code": "\nvoid * memmove_08009a18(void *dest,void *src,size_t length)\n\n{\n  undefined4 *destPtr;\n  undefined *srcPtr;\n  int srcOffset;\n  void *destOffset;\n  undefined *tempPtr;\n  int tempOffset;\n  uint remaining;\n  int copyOffset;\n  uint copySize;\n  undefined4 *tempDestPtr;\n  \n  if ((src < dest) && (srcPtr = (undefined *)((int)src + length), dest < srcPtr)) {\n    tempPtr = (undefined *)((int)dest + length);\n    if (length != 0) {\n      do {\n        srcPtr = srcPtr + -1;\n        tempPtr = tempPtr + -1;\n        *tempPtr = *srcPtr;\n      } while ((undefined *)src != srcPtr);\n    }\n  }\n  else {\n    copySize = length;\n    destOffset = dest;\n    if (0xf < length) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      srcOffset = (int)src + 0x10;\n      copyOffset = (int)dest + 0x10;\n      do {\n        tempOffset = srcOffset + 0x10;\n        *(undefined4 *)(copyOffset + -0x10) = *(undefined4 *)(srcOffset + -0x10);\n        *(undefined4 *)(copyOffset + -0xc) = *(undefined4 *)(srcOffset + -0xc);\n        *(undefined4 *)(copyOffset + -8) = *(undefined4 *)(srcOffset + -8);\n        *(undefined4 *)(copyOffset + -4) = *(undefined4 *)(srcOffset + -4);\n        srcOffset = tempOffset;\n        copyOffset = copyOffset + 0x10;\n      } while (tempOffset != (int)src + (length - 0x10 & 0xfffffff0) + 0x20);\n      copySize = length & 0xf;\n      srcOffset = ((length - 0x10 >> 4) + 1) * 0x10;\n      src = (void *)((int)src + srcOffset);\n      destOffset = (void *)(srcOffset + (int)dest);\n      if (3 < copySize) {\n        tempDestPtr = (undefined4 *)((int)destOffset + -4);\n        remaining = copySize;\n        destPtr = (undefined4 *)src;\n        do {\n          remaining = remaining - 4;\n          tempDestPtr = tempDestPtr + 1;\n          *tempDestPtr = *destPtr;\n          destPtr = destPtr + 1;\n        } while (3 < remaining);\n        srcOffset = (copySize - 4 & 0xfffffffc) + 4;\n        src = (void *)((int)src + srcOffset);\n        copySize = length & 3;\n        destOffset = (void *)((int)destOffset + srcOffset);\n      }\n    }\n    length = copySize;\n    if (copySize != 0) {\nLAB_08009abc:\n      srcPtr = (undefined *)((int)destOffset + -1);\n      tempDestPtr = (undefined4 *)src;\n      do {\n        destPtr = (undefined4 *)((int)tempDestPtr + 1);\n        srcPtr = srcPtr + 1;\n        *srcPtr = *(undefined *)tempDestPtr;\n        tempDestPtr = destPtr;\n      } while (destPtr != (undefined4 *)(length + (int)src));\n      return dest;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "memmove_08009a18",
                "__dest": "dest",
                "__src": "src",
                "__n": "length",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "iVar3": "srcOffset",
                "pvVar4": "destOffset",
                "puVar5": "tempPtr",
                "iVar6": "tempOffset",
                "uVar7": "remaining",
                "iVar8": "copyOffset",
                "uVar9": "copySize",
                "puVar10": "tempDestPtr"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocateMemory_08009adc(undefined4 *lock_ptr,int *ptr,uint size)\n\n{\n  int *temp_ptr;\n  int temp_var;\n  int *new_ptr;\n  uint temp_var2;\n  int temp_var3;\n  uint old_size;\n  size_t copy_size;\n  int *new_ptr2;\n  uint new_size;\n  uint alignment;\n  uint new_total_size;\n  int temp_var4;\n  \n  if (ptr == (int *)0x0) {\n    new_ptr = (int *)_malloc_r(lock_ptr,size);\n    return new_ptr;\n  }\n  __malloc_lock();\n  old_size = ptr[-1];\n  alignment = old_size & 0xfffffffc;\n  new_ptr = ptr + -2;\n  if (size + 0xb < 0x17) {\n    new_size = 0x10;\n  }\n  else {\n    new_size = size + 0xb & 0xfffffff8;\n    if ((int)new_size < 0) goto LAB_08009b8e;\n  }\n  if (new_size < size) {\nLAB_08009b8e:\n    *lock_ptr = 0xc;\n    return (int *)0x0;\n  }\n  temp_var4 = (int)new_ptr + alignment;\n  new_total_size = alignment;\n  if ((int)alignment < (int)new_size) {\n    if (DAT_20000454 == temp_var4) {\n      temp_var4 = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + alignment;\n      if ((int)(new_size + 0x10) <= temp_var4) {\n        DAT_20000454 = (int)new_ptr + new_size;\n        *(uint *)(DAT_20000454 + 4) = temp_var4 - new_size | 1;\n        ptr[-1] = new_size | ptr[-1] & 1U;\n        __malloc_unlock(lock_ptr);\n        return ptr;\n      }\n      if (-1 < (int)(old_size << 0x1f)) {\n        temp_ptr = (int *)((int)new_ptr - ptr[-2]);\n        old_size = temp_ptr[1] & 0xfffffffc;\n        if ((int)(new_size + 0x10) <= (int)(temp_var4 + old_size)) {\n          temp_var3 = temp_ptr[3];\n          new_ptr = temp_ptr + 2;\n          temp_var = *new_ptr;\n          copy_size = alignment - 4;\n          *(int *)(temp_var + 0xc) = temp_var3;\n          *(int *)(temp_var3 + 8) = temp_var;\n          if (copy_size < 0x25) {\n            temp_var = *ptr;\n            new_ptr2 = new_ptr;\n            if (0x13 < copy_size) {\n              temp_ptr[2] = temp_var;\n              temp_ptr[3] = ptr[1];\n              temp_var = ptr[2];\n              if (copy_size < 0x1c) {\n                ptr = ptr + 2;\n                new_ptr2 = temp_ptr + 4;\n              }\n              else {\n                temp_ptr[4] = temp_var;\n                temp_ptr[5] = ptr[3];\n                temp_var = ptr[4];\n                if (copy_size == 0x24) {\n                  temp_ptr[6] = temp_var;\n                  temp_ptr[7] = ptr[5];\n                  temp_var = ptr[6];\n                  ptr = ptr + 6;\n                  new_ptr2 = temp_ptr + 8;\n                }\n                else {\n                  ptr = ptr + 4;\n                  new_ptr2 = temp_ptr + 6;\n                }\n              }\n            }\n            *new_ptr2 = temp_var;\n            new_ptr2[1] = ptr[1];\n            new_ptr2[2] = ptr[2];\n          }\n          else {\n            memmove(new_ptr,ptr,copy_size);\n          }\n          DAT_20000454 = (int)temp_ptr + new_size;\n          *(uint *)(DAT_20000454 + 4) = (temp_var4 + old_size) - new_size | 1;\n          temp_ptr[1] = new_size | temp_ptr[1] & 1U;\n          __malloc_unlock(lock_ptr);\n          return new_ptr;\n        }\nLAB_08009bb0:\n        new_total_size = alignment + old_size;\n        if ((int)new_size <= (int)new_total_size) {\n          temp_var3 = temp_ptr[3];\n          new_ptr2 = temp_ptr + 2;\n          temp_var = *new_ptr2;\n          *(int *)(temp_var + 0xc) = temp_var3;\n          temp_var4 = (int)temp_ptr + new_total_size;\n          *(int *)(temp_var3 + 8) = temp_var;\n          new_ptr = temp_ptr;\n          if (alignment - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(new_ptr2,ptr,alignment - 4);\n          ptr = new_ptr2;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(temp_var4 + 4) & 0xfffffffe) + temp_var4 + 4) << 0x1f) {\n        temp_var2 = *(uint *)(temp_var4 + 4) & 0xfffffffc;\n        new_total_size = alignment + temp_var2;\n        if ((int)new_total_size < (int)new_size) {\n          if ((int)(old_size << 0x1f) < 0) goto LAB_08009b36;\n          temp_ptr = (int *)((int)new_ptr - ptr[-2]);\n          old_size = temp_ptr[1] & 0xfffffffc;\n          new_total_size = temp_var2 + old_size + alignment;\n          if ((int)new_total_size < (int)new_size) goto LAB_08009bb0;\n          temp_var = *(int *)(temp_var4 + 8);\n          temp_var4 = *(int *)(temp_var4 + 0xc);\n          *(int *)(temp_var + 0xc) = temp_var4;\n          *(int *)(temp_var4 + 8) = temp_var;\n          new_ptr2 = temp_ptr + 2;\n          temp_var = *new_ptr2;\n          temp_var3 = temp_ptr[3];\n          *(int *)(temp_var + 0xc) = temp_var3;\n          temp_var4 = (int)temp_ptr + new_total_size;\n          *(int *)(temp_var3 + 8) = temp_var;\n          new_ptr = temp_ptr;\n          if (0x24 < alignment - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          alignment = alignment - 4;\n          temp_var = *ptr;\n          temp_ptr = new_ptr2;\n          if (0x13 < alignment) {\n            new_ptr[2] = temp_var;\n            new_ptr[3] = ptr[1];\n            temp_var = ptr[2];\n            if (alignment < 0x1c) {\n              ptr = ptr + 2;\n              temp_ptr = new_ptr + 4;\n            }\n            else {\n              new_ptr[4] = temp_var;\n              new_ptr[5] = ptr[3];\n              temp_var = ptr[4];\n              if (alignment == 0x24) {\n                new_ptr[6] = temp_var;\n                new_ptr[7] = ptr[5];\n                temp_var = ptr[6];\n                ptr = ptr + 6;\n                temp_ptr = new_ptr + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                temp_ptr = new_ptr + 6;\n              }\n            }\n          }\n          *temp_ptr = temp_var;\n          temp_ptr[1] = ptr[1];\n          temp_ptr[2] = ptr[2];\n          ptr = new_ptr2;\n        }\n        else {\n          temp_var = *(int *)(temp_var4 + 8);\n          temp_var3 = *(int *)(temp_var4 + 0xc);\n          *(int *)(temp_var + 0xc) = temp_var3;\n          temp_var4 = (int)new_ptr + new_total_size;\n          *(int *)(temp_var3 + 8) = temp_var;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(old_size << 0x1f)) {\n        temp_ptr = (int *)((int)new_ptr - ptr[-2]);\n        old_size = temp_ptr[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    temp_ptr = (int *)_malloc_r(lock_ptr,size);\n    if (temp_ptr != (int *)0x0) {\n      if ((int *)((ptr[-1] & 0xfffffffeU) + (int)new_ptr) == temp_ptr + -2) {\n        new_total_size = alignment + (temp_ptr[-1] & 0xfffffffcU);\n        temp_var4 = (int)new_ptr + new_total_size;\n        goto LAB_08009c00;\n      }\n      copy_size = alignment - 4;\n      if (copy_size < 0x25) {\n        temp_var4 = *ptr;\n        new_ptr = ptr;\n        new_ptr2 = temp_ptr;\n        if (0x13 < copy_size) {\n          *temp_ptr = temp_var4;\n          temp_ptr[1] = ptr[1];\n          if (copy_size < 0x1c) {\n            temp_var4 = ptr[2];\n            new_ptr = ptr + 2;\n            new_ptr2 = temp_ptr + 2;\n          }\n          else {\n            temp_ptr[2] = ptr[2];\n            temp_ptr[3] = ptr[3];\n            if (copy_size == 0x24) {\n              temp_ptr[4] = ptr[4];\n              temp_ptr[5] = ptr[5];\n              temp_var4 = ptr[6];\n              new_ptr = ptr + 6;\n              new_ptr2 = temp_ptr + 6;\n            }\n            else {\n              temp_var4 = ptr[4];\n              new_ptr = ptr + 4;\n              new_ptr2 = temp_ptr + 4;\n            }\n          }\n        }\n        *new_ptr2 = temp_var4;\n        new_ptr2[1] = new_ptr[1];\n        new_ptr2[2] = new_ptr[2];\n      }\n      else {\n        memmove(temp_ptr,ptr,copy_size);\n      }\n      _free_r(lock_ptr,ptr);\n    }\n    __malloc_unlock(lock_ptr);\n    ptr = temp_ptr;\n  }\n  else {\nLAB_08009c00:\n    if (new_total_size - new_size < 0x10) {\n      new_ptr[1] = new_ptr[1] & 1U | new_total_size;\n      *(uint *)(temp_var4 + 4) = *(uint *)(temp_var4 + 4) | 1;\n    }\n    else {\n      new_ptr[1] = new_ptr[1] & 1U | new_size;\n      *(uint *)((int)new_ptr + new_size + 4) = new_total_size - new_size | 1;\n      *(uint *)(temp_var4 + 4) = *(uint *)(temp_var4 + 4) | 1;\n      _free_r(lock_ptr,(int)new_ptr + new_size + 8);\n    }\n    __malloc_unlock(lock_ptr);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "lock_ptr",
                "param_2": "ptr",
                "param_3": "size",
                "piVar1": "temp_ptr",
                "iVar2": "temp_var",
                "piVar3": "new_ptr",
                "uVar4": "temp_var2",
                "iVar5": "temp_var3",
                "uVar6": "old_size",
                "uVar9": "new_size",
                "uVar10": "alignment",
                "uVar11": "new_total_size",
                "iVar12": "temp_var4",
                "sVar7": "copy_size",
                "piVar8": "new_ptr2"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e50": {
            "entrypoint": "0x08009e50",
            "current_name": "assign_value_to_param2_08009e50",
            "code": "\nundefined * assignValueToParam2_08009e50(undefined4 *param1,undefined *param2,uint param3)\n\n{\n  if (param2 != (undefined *)0x0) {\n    if (param3 < 0x100) {\n      *param2 = (char)param3;\n      param2 = (undefined *)0x1;\n    }\n    else {\n      param2 = (undefined *)0xffffffff;\n      *param1 = 0x8a;\n    }\n  }\n  return param2;\n}\n\n",
            "renaming": {
                "FUN_08009e50": "assign_value_to_param2_08009e50",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "get_pkey_context_address_08009e68",
            "code": "\nint get_pkey_context_address_08009e68(EVP_PKEY_CTX *ctx_address)\n\n{\n  return (int)ctx_address;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "get_pkey_context_address_08009e68",
                "ctx": "ctx_address"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 172240,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_0800045c",
            "FUN_0800046c",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008ec",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000a9c",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000c2c",
            "FUN_08000c3c",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f58",
            "FUN_08000f60",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000fe0",
            "FUN_08000ff4",
            "FUN_08001008",
            "FUN_0800101c",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001cb8",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_080035fa",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_08003696",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c4a",
            "FUN_08003c5c",
            "FUN_08003c6e",
            "FUN_08003c80",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004366",
            "FUN_08004378",
            "FUN_0800438a",
            "FUN_08004424",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_080056c8",
            "FUN_080056ce",
            "FUN_080056d4",
            "FUN_080056da",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005830",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d0c",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078b4",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_08008818",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_080099ec",
            "FUN_08009a18",
            "FUN_08009adc",
            "FUN_08009e50",
            "FUN_08009e68"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}