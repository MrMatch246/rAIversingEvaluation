{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeFlag_000800f4(undefined4 flagValue)\n\n{\n  if ((char)completedFlag == '\\0') {\n    completedFlag._0_1_ = '\\x01';\n  }\n  return flagValue;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_flag_000800f4",
                "param_1": "flagValue",
                "completed_7857": "completedFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080148": {
            "entrypoint": "0x00080148",
            "current_name": "execute_interrupt_00080148",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_interrupt_00080148(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_00080148": "execute_interrupt_00080148"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008014c": {
            "entrypoint": "0x0008014c",
            "current_name": "execute_afl_call_0008014c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_0008014c(int inputTicks)\n\n{\n  uint32_t returnValue;\n  \n  if (noHyperCall == 0) {\n    returnValue = aflCall(1,inputTicks,0);\n    return returnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008014c": "execute_afl_call_0008014c",
                "ticks": "inputTicks",
                "uVar1": "returnValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_modbus_00080164",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusInstance, long baudRate) */\n\nvoid __modbusInstancecall Modbus::initializeModbus_00080164(Modbus *modbusInstance,long baudRate)\n\n{\n  int serialReadValue;\n  \n  modbusInstance->port = &Serial.super_HardwareSerial;\n  (**(code **)(Serial._0_4_ + 0x18))(&Serial);\n  if (1 < modbusInstance->u8txenpin) {\n    pinMode((uint)modbusInstance->u8txenpin,1);\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  do {\n    serialReadValue = (**(code **)(*(int *)modbusInstance->port + 0xc))();\n  } while (-1 < serialReadValue);\n  modbusInstance->u8BufferSize = '\\0';\n  modbusInstance->u8lastRec = '\\0';\n  modbusInstance->u16errCnt = 0;\n  modbusInstance->u16OutCnt = 0;\n  modbusInstance->u16InCnt = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_modbus_00080164",
                "this": "modbusInstance",
                "u32speed": "baudRate",
                "iVar1": "serialReadValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801b0": {
            "entrypoint": "0x000801b0",
            "current_name": "get_rx_buffer_000801b0",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer_000801b0(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::getRxBuffer_000801b0(Modbus *modbusInstance)\n\n{\n  bool bufferOverflow;\n  uchar dataByte;\n  uint8_t bufferSize;\n  int status;\n  byte currentBufferSize;\n  \n  if (1 < modbusInstance->transmitEnablePin) {\n    setTransmitEnablePin((uint)modbusInstance->transmitEnablePin,0);\n  }\n  bufferOverflow = false;\n  modbusInstance->bufferSize = '\\0';\n  if (modbusInstance->serialNumber < 4) {\n    while (status = (**(code **)(*(int *)modbusInstance->serialPort + 8))(), status != 0) {\n      currentBufferSize = modbusInstance->bufferSize;\n      dataByte = (**(code **)(*(int *)modbusInstance->serialPort + 0xc))();\n      bufferSize = modbusInstance->bufferSize;\n      modbusInstance->buffer[currentBufferSize] = dataByte;\n      currentBufferSize = bufferSize + 1;\n      modbusInstance->bufferSize = currentBufferSize;\n      if (0x3f < currentBufferSize) {\n        bufferOverflow = true;\n      }\n    }\n  }\n  modbusInstance->inputCount = modbusInstance->inputCount + 1;\n  if (bufferOverflow) {\n    bufferSize = 0xfd;\n    modbusInstance->errorCount = modbusInstance->errorCount + 1;\n  }\n  else {\n    bufferSize = modbusInstance->bufferSize;\n  }\n  return bufferSize;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "bVar1": "bufferOverflow",
                "uVar2": "dataByte",
                "uVar3": "bufferSize",
                "iVar4": "status",
                "bVar5": "currentBufferSize",
                "u8txenpin": "transmitEnablePin",
                "digitalWrite": "setTransmitEnablePin",
                "u8BufferSize": "bufferSize",
                "u8serno": "serialNumber",
                "port": "serialPort",
                "au8Buffer": "buffer",
                "u16InCnt": "inputCount",
                "u16errCnt": "errorCount",
                "FUN_000801b0": "get_rx_buffer_000801b0"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008021c": {
            "entrypoint": "0x0008021c",
            "current_name": "calculate_crc_0008021c",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbusInstance, uint8_t dataLength) */\n\nuint16_t __modbusInstancecall Modbus::calculateCRC_0008021c(Modbus *modbusInstance,uint8_t dataLength)\n\n{\n  Modbus *currentPointer;\n  uint crc;\n  char bitCounter;\n  uint lsbBit;\n  uint tempVariable;\n  \n  crc = 0xffff;\n  for (currentPointer = modbusInstance; ((int)currentPointer - (int)modbusInstance & 0xffU) < (uint)dataLength;\n      currentPointer = (Modbus *)((int)&currentPointer->port + 1)) {\n    crc = crc ^ currentPointer->au8Buffer[0];\n    bitCounter = '\\b';\n    do {\n      lsbBit = crc & 1;\n      crc = crc >> 1;\n      if (lsbBit != 0) {\n        crc = crc ^ 0xa001;\n      }\n      bitCounter = bitCounter + -1;\n    } while (bitCounter != '\\0');\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u8length": "dataLength",
                "pMVar1": "currentPointer",
                "uVar2": "crc",
                "cVar3": "bitCounter",
                "uVar4": "lsbBit",
                "flag": "tempVariable",
                "FUN_0008021c": "calculate_crc_0008021c"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080258": {
            "entrypoint": "0x00080258",
            "current_name": "send_tx_buffer_00080258",
            "code": "\n/* DWARF original prototype: void  sendTxBuffer_00080258(Modbus * this) */\n\nvoid __thiscall Modbus::sendTxBuffer_00080258(Modbus *this)\n\n{\n  byte bufferLength;\n  uint16_t calculatedCRC;\n  uint16_t crcValue;\n  uint32_t currentTime;\n  int loopVariable;\n  \n  bufferLength = this->bufferSize;\n  calculatedCRC = calcCRC(this,bufferLength);\n  this->dataBuffer[bufferLength] = (uchar)(calculatedCRC >> 8);\n  this->dataBuffer[bufferLength + 1 & 0xff] = (uchar)calculatedCRC;\n  this->bufferSize = bufferLength + 2;\n  if (1 < this->txenPin) {\n    digitalWrite((uint)this->txenPin,1);\n  }\n  if (this->serialNumber < 4) {\n    (**(code **)(*(int *)this->serialPort + 4))(this->serialPort,this->dataBuffer,this->bufferSize);\n  }\n  if (1 < this->txenPin) {\n    digitalWrite((uint)this->txenPin,0);\n  }\n  if (this->serialNumber < 4) {\n    do {\n      loopVariable = (**(code **)(*(int *)this->serialPort + 0xc))();\n    } while (-1 < loopVariable);\n  }\n  this->bufferSize = '\\0';\n  currentTime = millis();\n  this->timeOutValue = currentTime + this->timeOutDuration;\n  this->outCount = this->outCount + 1;\n  return;\n}\n\n",
            "renaming": {
                "u8length": "bufferLength",
                "uVar1": "calculatedCRC",
                "u16crc": "crcValue",
                "uVar2": "currentTime",
                "iVar3": "loopVariable",
                "u8BufferSize": "bufferSize",
                "u8txenpin": "txenPin",
                "u8serno": "serialNumber",
                "au8Buffer": "dataBuffer",
                "port": "serialPort",
                "u16timeOut": "timeOutDuration",
                "u32timeOut": "timeOutValue",
                "u16OutCnt": "outCount",
                "FUN_00080258": "send_tx_buffer_00080258"
            },
            "calling": [
                "query"
            ],
            "called": [
                "millis",
                "digitalWrite",
                "calcCRC"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000802da": {
            "entrypoint": "0x000802da",
            "current_name": "process_modbus_telegram_000802da",
            "code": "\n/* DWARF original prototype: int  query(ModbusDevice * device, ModbusTelegram telegram) */\n\nint __devicecall ModbusDevice::processModbusTelegram_000802da(ModbusDevice *device,ModbusTelegram telegram)\n\n{\n  uchar uVar1;\n  uint data;\n  uint numBytes;\n  byte byteVar;\n  ushort address;\n  ushort *pointerVar4;\n  uint uVar5;\n  ushort uVar6;\n  ushort *pointerVar3;\n  uint uVar7;\n  ushort *pointerVar8;\n  uchar lowerData;\n  uchar upperData;\n  uchar uVar2;\n  \n  lowerData = (uchar)data;\n  upperData = (uchar)(data >> 8);\n  uVar7 = (uint)address;\n  if (device->u8id != '\\0') {\n    return -2;\n  }\n  if (device->u8state != '\\0') {\n    return -1;\n  }\n  if (0xf6 < ((data & 0xff) - 1 & 0xff)) {\n    return -3;\n  }\n  device->au8Buffer[0] = lowerData;\n  device->au8Buffer[1] = upperData;\n  device->au16regs = pointerVar3;\n  device->au8Buffer[2] = (uchar)(data >> 0x18);\n  device->au8Buffer[3] = (uchar)(data >> 0x10);\n  uVar1 = (uchar)address;\n  uVar2 = (uchar)(address >> 8);\n  switch(upperData) {\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n    device->au8Buffer[4] = uVar2;\n    break;\n  case '\\x05':\n    uVar6 = *pointerVar3;\n    if (uVar6 != 0) {\n      uVar6 = 1;\n    }\n    device->au8Buffer[4] = -(char)uVar6;\n    uVar7 = 0;\n    break;\n  case '\\x06':\n    device->au8Buffer[4] = (uchar)(*pointerVar3 >> 8);\n    uVar7 = (uint)*pointerVar3;\n    break;\n  default:\n    goto switchD_0008031e_caseD_7;\n  case '\\x0f':\n    byteVar = (byte)(address >> 3) & 0xfe;\n    if ((address & 0xf) != 0) {\n      byteVar = byteVar + 1;\n    }\n    device->au8Buffer[5] = uVar1;\n    device->au8Buffer[4] = uVar2;\n    device->au8Buffer[6] = byteVar;\n    uVar5 = '\\a';\n    goto LAB_0008034a;\n  case '\\x10':\n    device->au8Buffer[4] = uVar2;\n    device->au8Buffer[5] = uVar1;\n    pointerVar4 = pointerVar3 + -1;\n    device->au8Buffer[6] = uVar1 * '\\x02';\n    device->u8BufferSize = '\\a';\n    pointerVar8 = pointerVar4 + uVar7;\n    while (pointerVar4 != pointerVar8) {\n      byteVar = device->u8BufferSize;\n      device->au8Buffer[byteVar] = (uchar)(pointerVar4[1] >> 8);\n      uVar7 = byteVar + 1 & 0xff;\n      device->u8BufferSize = (uint)uVar7;\n      pointerVar4 = pointerVar4 + 1;\n      device->au8Buffer[uVar7] = (uchar)*pointerVar4;\n      device->u8BufferSize = byteVar + 2;\n    }\n    goto switchD_0008031e_caseD_7;\n  }\n  device->au8Buffer[5] = (uchar)uVar7;\n  uVar5 = '\\x06';\nLAB_0008034a:\n  device->u8BufferSize = uVar5;\nswitchD_0008031e_caseD_7:\n  sendTxBuffer(device);\n  device->u8state = '\\x01';\n  return '\\0';\n}\n\n",
            "renaming": {
                "Modbus": "ModbusDevice",
                "int8_t": "int",
                "modbus_t": "ModbusTelegram",
                "this": "device",
                "in_r1": "data",
                "u8bytesno": "numBytes",
                "bVar3": "byteVar",
                "in_r2": "address",
                "puVar4": "pointerVar4",
                "in_r3": "pointerVar3",
                "puVar8": "pointerVar8",
                "local_1c": "lowerData",
                "local_1b": "upperData",
                "FUN_000802da": "process_modbus_telegram_000802da"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803d4": {
            "entrypoint": "0x000803d4",
            "current_name": "validate_answer_000803d4",
            "code": "\n/* DWARF orindexgindexnal prototype: uindexnt8_t  valindexdateAnswer(Modbus * modbusInstance) */\n\nuindexnt8_t __modbusInstancecall Modbus::validateAnswer_000803d4(Modbus *modbusInstance)\n\n{\n  uindexnt8_t index;\n  indexnt comparisonResult;\n  \n  indexf ((indexnt)((uindexnt)modbusInstance->au8Buffer[1] << 0x18) < 0) {\n    modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n    return 0xfb;\n  }\n  comparisonResult = 0;\n  do {\n    indexf (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[comparisonResult] == modbusInstance->au8Buffer[1]) {\n      return '\\0';\n    }\n    comparisonResult = comparisonResult + 1;\n  } whindexle (comparisonResult != 8);\n  modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n  return '\\x01';\n}\n\n",
            "renaming": {
                "FUN_000803d4": "validate_answer_000803d4",
                "this": "modbusInstance",
                "i": "index",
                "iVar1": "comparisonResult"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080410": {
            "entrypoint": "0x00080410",
            "current_name": "update_registers_00080410",
            "code": "\n/* DWARF original prototype: void  get_FC3(Modbus * modbusInstance) */\n\nvoid __modbusInstancecall Modbus::updateRegisters_00080410(Modbus *modbusInstance)\n\n{\n  uint16_t wordValue;\n  uint tempIndex;\n  byte counter;\n  uint convertedCounter;\n  uint16_t *registerArray;\n  \n  counter = 0;\n  while( true ) {\n    convertedCounter = (uint)counter;\n    counter = counter + 1;\n    tempIndex = convertedCounter * 2 + 3 & 0xff;\n    if (modbusInstance->au8Buffer[2] >> 1 <= convertedCounter) break;\n    registerArray = modbusInstance->au16regs;\n    wordValue = makeWord(modbusInstance->au8Buffer[tempIndex],modbusInstance->au8Buffer[tempIndex + 1]);\n    registerArray[convertedCounter] = wordValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080410": "update_registers_00080410",
                "this": "modbusInstance",
                "uVar1": "wordValue",
                "uVar2": "tempIndex",
                "bVar3": "counter",
                "uVar4": "convertedCounter",
                "puVar5": "registerArray"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008043e": {
            "entrypoint": "0x0008043e",
            "current_name": "poll_modbus_0008043e",
            "code": "\n/* DWARF original prototype: int8_t  poll(modbusObj * this) */\n\nint __thiscall modbusObj::pollModbus_0008043e(modbusObj *this,pollfd *pollFileDescriptors,nfds_t numFileDescriptors,int timeout)\n\n{\n  byte serialNumber;\n  uint8_t exceptionFlag;\n  uint8_t exceptionCount;\n  uint32_t currentTime;\n  uint8_t currentByte;\n  uint byteValue;\n  \n  if (this->serialNumber < 4) {\n    serialNumber = (**(code **)(*(int *)this->modbusPort + 8))();\n    byteValue = (uint)serialNumber;\n  }\n  currentTime = millis();\n  if (this->timeout < currentTime) {\n    this->lastError = 0xff;\n    this->state = '\\0';\n    this->errorCount = this->errorCount + 1;\n  }\n  else if (7 < byteValue) {\n    retrieveRxBuffer(this);\n    exceptionFlag = checkAnswerValidity(this);\n    if (exceptionFlag == '\\0') {\n      if (this->buffer[1] - 3 < 2) {\n        fetch_FC3(this);\n      }\n      this->state = '\\0';\n      exceptionFlag = this->u8BufferSize;\n    }\n    else {\n      this->state = '\\0';\n    }\n    goto LAB_000804a2;\n  }\n  exceptionFlag = '\\0';\nLAB_000804a2:\n  return (int)(char)exceptionFlag;\n}\n\n",
            "renaming": {
                "Modbus": "modbusObj",
                "__fds": "pollFileDescriptors",
                "__nfds": "numFileDescriptors",
                "__timeout": "timeout",
                "bVar1": "serialNumber",
                "uVar2": "exceptionFlag",
                "u8exception": "exceptionCount",
                "uVar3": "currentTime",
                "u8current": "currentByte",
                "unaff_r6": "byteValue",
                "u8serno": "serialNumber",
                "port": "modbusPort",
                "u8lastError": "lastError",
                "u8state": "state",
                "u16errCnt": "errorCount",
                "u32timeOut": "timeout",
                "getRxBuffer": "retrieveRxBuffer",
                "validateAnswer": "checkAnswerValidity",
                "au8Buffer": "buffer",
                "get_FC3": "fetch_FC3",
                "FUN_0008043e": "poll_modbus_0008043e"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "getRxBuffer",
                "get_FC3",
                "validateAnswer",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000804a8": {
            "entrypoint": "0x000804a8",
            "current_name": "initialize_modbus_000804a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbus_000804a8(void)\n\n{\n  uint32_t uVar1;\n  \n  setPinMode(1,0);\n  setPinMode(6,1);\n  setPinMode(0,1);\n  setPinMode(1,1);\n  writePinDigital(0,0);\n  writePinDigital(1,0);\n  modbusTelegram[1].registerAddress = 0x13;\n  modbusTelegram[1].numberofCoils = 10;\n  modbusTelegram[1].registerArray = au16data + 0x13;\n  modbusTelegram[0].functionCode = '\\x03';\n  modbusTelegram[2].functionCode = '\\x03';\n  modbusTelegram[2].registerAddress = 0x14;\n  modbusTelegram[3].numberofCoils = 3;\n  modbusTelegram[0].numberofCoils = 0x10;\n  modbusTelegram[0].registerArray = au16data;\n  modbusTelegram[1].functionCode = '\\x10';\n  modbusTelegram[2].numberofCoils = 0xc;\n  modbusTelegram[3].functionCode = '\\x10';\n  modbusTelegram[4].numberofCoils = 8;\n  modbusTelegram[3].registerAddress = 0x1c;\n  modbusTelegram[3].registerArray = au16data + 0x1c;\n  modbusTelegram[4].deviceID = '\\x02';\n  modbusTelegram[4].functionCode = '\\x02';\n  modbusTelegram[4].registerArray = data8024;\n  modbusTelegram[5].deviceID = '\\x02';\n  modbusTelegram[0].deviceID = '\\x01';\n  modbusTelegram[1].deviceID = '\\x01';\n  modbusTelegram[2].deviceID = '\\x01';\n  modbusTelegram[3].deviceID = '\\x01';\n  modbusTelegram[5].registerAddress = 1;\n  modbusTelegram[5].numberofCoils = 1;\n  modbusTelegram[0].registerAddress = 0;\n  modbusTelegram[2].registerArray = au16data + 0x14;\n  modbusTelegram[4].registerAddress = 0;\n  modbusTelegram[5].functionCode = '\\x05';\n  modbusTelegram[5].registerArray = data8024 + 1;\n  modbusBegin(&master,0x4b00);\n  master.timeoutValue = 2000;\n  waitTime = getCurrentMillis();\n  uVar1 = getCurrentMillis();\n  pid1Time = uVar1 + 1000;\n  uVar1 = getCurrentMillis();\n  dutyHigh1 = uVar1 + 1000;\n  uVar1 = getCurrentMillis();\n  dutyLow1 = uVar1 + 1000;\n  uVar1 = getCurrentMillis();\n  clock = uVar1 + 1000;\n  state = '\\0';\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000804a8": "initialize_modbus_000804a8",
                "pinMode": "setPinMode",
                "digitalWrite": "writePinDigital",
                "telegram": "modbusTelegram",
                "u16RegAdd": "registerAddress",
                "u16CoilsNo": "numberofCoils",
                "au16reg": "registerArray",
                "u8fct": "functionCode",
                "u8id": "deviceID",
                "u16timeOut": "timeoutValue",
                "u32wait": "waitTime",
                "tiempopid1": "pid1Time",
                "dutyalto1": "dutyHigh1",
                "dutybajo1": "dutyLow1",
                "reloj": "clock",
                "u8state": "state",
                "Modbus::begin": "modbusBegin",
                "millis": "getCurrentMillis",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "pinMode",
                "millis",
                "startForkserver",
                "digitalWrite",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805d0": {
            "entrypoint": "0x000805d0",
            "current_name": "process_modbus_data_000805d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processModbusData_000805d0(void)\n\n{\n  ModbusData modbusTelegram;\n  ModbusData modbusTelegram0;\n  ModbusData modbusTelegram1;\n  ModbusData modbusTelegram2;\n  uint32_t currentMillis;\n  undefined4 tempFloat;\n  float temperatureDiff;\n  float proportionalPart;\n  float derivativePart;\n  int comparisonResult;\n  modbusPollfd *pollfdPointer;\n  nfds_t nfds_tValue;\n  int *intPointer;\n  uint timeout;\n  undefined4 var1;\n  undefined4 var2;\n  float *tempFloatPointer1;\n  undefined4 var3;\n  ulong *ulongPointer;\n  float *tempFloatPointer2;\n  \n  timeout = (uint)currentState;\n  switch(timeout) {\n  case 0:\n    currentMillis = getCurrentMillis();\n    if (previousMillis < currentMillis) goto LAB_000806ca;\n    break;\n  case 1:\n    Modbus::modbusPoll(&master,pollfdPointer,nfds_tValue,timeout);\n    if (master.currentState == '\\0') {\n      modbusTelegram._4_4_ = var2;\n      modbusTelegram.slaveAddress = (char)var1;\n      modbusTelegram.functionCode = (char)((uint)var1 >> 8);\n      modbusTelegram.registerAddress = (short)((uint)var1 >> 0x10);\n      modbusTelegram.registerValues = (uint16_t *)var3;\n      Modbus::modbusQuery(&master,modbusTelegram);\n      currentState = currentState + '\\x01';\n      previousMillis = getCurrentMillis();\n      temp1 = (int)dataArray[1];\n      temp2 = (int)dataArray[2];\n      kp1 = (float)unsignedIntToFloat(dataArray[6]);\n      ki1 = (float)intToFloat(dataArray[7] / 10);\n      kd1 = (float)unsignedIntToFloat(dataArray[8]);\n      dutyCycle2 = (int)dataArray[12];\n      dutyCycle1 = (int)dataArray[9];\n      minutes = (int)dataArray[14];\n      seconds = (int)dataArray[15];\n    }\n    break;\n  case 2:\n  case 4:\n  case 6:\n  case 8:\n    Modbus::modbusPoll(&master,pollfdPointer,nfds_tValue,timeout);\n    if (master.currentState == '\\0') {\n      currentState = currentState + '\\x01';\n      previousMillis = getCurrentMillis();\n    }\n    break;\n  case 3:\n    Modbus::modbusPoll(&master,pollfdPointer,nfds_tValue,timeout);\n    if (master.currentState == '\\0') {\n      modbusTelegram0._4_4_ = var2;\n      modbusTelegram0.slaveAddress = (char)var1;\n      modbusTelegram0.functionCode = (char)((uint)var1 >> 8);\n      modbusTelegram0.registerAddress = (short)((uint)var1 >> 0x10);\n      modbusTelegram0.registerValues = (uint16_t *)var3;\n      Modbus::modbusQuery(&master,modbusTelegram0);\n      currentState = currentState + '\\x01';\n      previousMillis = getCurrentMillis();\n      tiempo_espera = (int)dataArray[30];\n      estado = (int)dataArray[29];\n    }\n    break;\n  case 5:\n    Modbus::modbusPoll(&master,pollfdPointer,nfds_tValue,timeout);\n    if (master.currentState == '\\0') {\nLAB_000806c4:\n      modbusTelegram1._4_4_ = var2;\n      modbusTelegram1.slaveAddress = (char)var1;\n      modbusTelegram1.functionCode = (char)((uint)var1 >> 8);\n      modbusTelegram1.registerAddress = (short)((uint)var1 >> 0x10);\n      modbusTelegram1.registerValues = (uint16_t *)var3;\n      Modbus::modbusQuery(&master,modbusTelegram1);\n      goto LAB_000806ca;\n    }\n    break;\n  case 7:\n    Modbus::modbusPoll(&master,pollfdPointer,nfds_tValue,timeout);\n    if ((endCycle == 1) && (master.currentState == '\\0')) {\n      dataArray[29] = 0;\n      endCycle = 0;\n      goto LAB_000806c4;\n    }\nLAB_000806ca:\n    currentState = currentState + '\\x01';\n    break;\n  case 9:\n    Modbus::modbusPoll(&master,pollfdPointer,nfds_tValue,timeout);\n    if (master.currentState == '\\0') {\n      modbusTelegram2._4_4_ = var2;\n      modbusTelegram2.slaveAddress = (char)var1;\n      modbusTelegram2.functionCode = (char)((uint)var1 >> 8);\n      modbusTelegram2.registerAddress = (short)((uint)var1 >> 0x10);\n      modbusTelegram2.registerValues = (uint16_t *)var3;\n      Modbus::modbusQuery(&master,modbusTelegram2);\n      previousMillis = getCurrentMillis();\n    }\n    currentState = '\\0';\n  }\n  minutesDiff = minutes - mmres;\n  if (minutesDiff < 0) {\n    minutesDiff = minutesDiff + 0x3c;\n  }\n  secondsDiff = seconds - ssres;\n  if (secondsDiff < 0) {\n    minutesDiff = minutesDiff + -1;\n    secondsDiff = secondsDiff + 0x3c;\n  }\n  dataArray[27] = (ushort)minutesDiff;\n  dataArray[28] = (ushort)secondsDiff;\n  if ((minutesDiff == 0) && (secondsDiff == 0)) {\n    endCycle = 1;\n    mmres = secondsDiff;\n    ssres = secondsDiff;\n  }\n  if (minutesp == minutes) {\n    secondsp = 1 - seconds;\n    if (1 < (uint)seconds) {\n      secondsp = 0;\n    }\n    if (secondsp != 0) goto LAB_00080a08;\n  }\n  else {\nLAB_00080a08:\n    secondsp = seconds;\n    mmres = 0;\n    ssres = 0;\n    espera_plancha = 0;\n    minutesp = minutes;\n  }\n  if (estado == 0) {\n    mmres = estado;\n    ssres = estado;\n    intPointer = &espera_plancha;\nLAB_000808f2:\n    *intPointer = ssres;\n  }\n  else {\n    if (estado != 1) goto LAB_000808f4;\n    if ((espera_plancha < tiempo_espera) && (currentMillis = getCurrentMillis(), clock < currentMillis)) {\n      espera_plancha = espera_plancha + 1;\n      ulongPointer = &clock;\n      currentMillis = getCurrentMillis();\n      *ulongPointer = currentMillis + 1000;\n    }\n    if (espera_plancha < tiempo_espera) goto LAB_000808f4;\n    espera_plancha = tiempo_espera + 1;\n    if (mmres < minutes) {\n      currentMillis = getCurrentMillis();\n      if (clock < currentMillis) {\n        ssres = ssres + 1;\n        currentMillis = getCurrentMillis();\n        clock = currentMillis + 1000;\n      }\n    }\n    else {\n      if (mmres != minutes) goto LAB_000808f4;\n      if (seconds < ssres) {\n        intPointer = &mmres;\n        ssres = 0;\n        goto LAB_000808f2;\n      }\n      currentMillis = getCurrentMillis();\n      if (clock < currentMillis) {\n        ssres = ssres + 1;\n        currentMillis = getCurrentMillis();\n        clock = currentMillis + 1000;\n      }\n    }\n    if (0x3b < ssres) {\n      ssres = 0;\n      mmres = mmres + 1;\n    }\n  }\nLAB_000808f4:\n  currentMillis = getCurrentMillis();\n  if (pidTimer1 < currentMillis) {\n    tempFloat = intToFloat(temp1);\n    temperatureDiff = (float)floatSubtract(tempFloat,temperature1);\n    tempFloatPointer1 = &error1;\n    e1 = temperatureDiff;\n    derivativePart = error1;\n    tempFloat = floatAdd(temperatureDiff,error1);\n    tempFloat = floatMultiply(tempFloat,ki1);\n    proportionalPart = (float)floatAdd(tempFloat,integralPart1);\n    ki1 = proportionalPart;\n    tempFloat = floatSubtract(temperatureDiff,derivativePart);\n    tempFloat = floatMultiply(tempFloat,kd1);\n    tempFloatPointer2 = &derivativePart1;\n    derivativePart = (float)floatSubtract(tempFloat,derivativePart1);\n    kd1 = derivativePart;\n    tempFloat = floatMultiply(temperatureDiff,kp1);\n    tempFloat = floatAdd(tempFloat,proportionalPart);\n    floatAdd(tempFloat,derivativePart);\n    pidOutput1 = floatToInt();\n    output = (float)intToFloat();\n    *tempFloatPointer1 = temperatureDiff;\n    increment = 0;\n    integralPart1 = proportionalPart;\n    *tempFloatPointer2 = derivativePart;\n    currentMillis = getCurrentMillis();\n    pidTimer1 = currentMillis + dutyCycle1;\n  }\n  derivativePart = (float)intToFloat(dutyCycle1);\n  comparisonResult = floatCompareGreaterOrEqual(output,derivativePart);\n  if (comparisonResult != 0) {\n    output = derivativePart;\n  }\n  comparisonResult = floatCompareLessOrEqual(output,0);\n  if (comparisonResult != 0) {\n    output = 0.0;\n  }\n  dataArray[21] = floatToUnsignedInt(output);\n  increment = increment + 1;\n  input1 = data8024[0] & 1 ^ 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805d0": "process_modbus_data_000805d0",
                "modbus_t": "ModbusData",
                "uVar1": "currentMillis",
                "uVar2": "tempFloat",
                "fVar3": "temperatureDiff",
                "fVar4": "proportionalPart",
                "fVar5": "derivativePart",
                "iVar6": "comparisonResult",
                "in_r1": "pollfdPointer",
                "in_r2": "nfds_tValue",
                "piVar7": "intPointer",
                "__timeout": "timeout",
                "in_stack_ffffffc8": "var1",
                "in_stack_ffffffcc": "var2",
                "pfVar8": "tempFloatPointer1",
                "in_stack_ffffffd0": "var3",
                "puVar9": "ulongPointer",
                "pfVar10": "tempFloatPointer2",
                "u32wait": "previousMillis",
                "u8state": "currentState",
                "tempe_z1": "temp1",
                "tempe_z2": "temp2",
                "kpa1": "kp1",
                "kia1": "ki1",
                "kda1": "kd1",
                "duty2": "dutyCycle2",
                "duty1": "dutyCycle1",
                "minutos": "minutes",
                "segundos": "seconds",
                "telegram": "modbusTelegram",
                "telegram_00": "modbusTelegram0",
                "telegram_01": "modbusTelegram1",
                "telegram_02": "modbusTelegram2",
                "au16reg": "registerValues",
                "u8id": "slaveAddress",
                "u8fct": "functionCode",
                "u16RegAdd": "registerAddress",
                "__floatunsisf": "unsignedIntToFloat",
                "__floatsisf": "intToFloat",
                "__addsf3": "floatAdd",
                "__aeabi_fsub": "floatSubtract",
                "__aeabi_fmul": "floatMultiply",
                "__aeabi_f2iz": "floatToInt",
                "__fixunssfsi": "floatToUnsignedInt",
                "__aeabi_fcmpge": "floatCompareGreaterOrEqual",
                "__aeabi_fcmple": "floatCompareLessOrEqual",
                "millis": "getCurrentMillis",
                "poll": "modbusPoll",
                "query": "modbusQuery",
                "au16data": "dataArray",
                "mmt": "minutesDiff",
                "sst": "secondsDiff",
                "terminar_ciclo": "endCycle",
                "temperatura1": "temperature1",
                "ep1": "error1",
                "kip1": "integralPart1",
                "kdp1": "derivativePart1",
                "pid1": "pidOutput1",
                "YN": "output",
                "tiempopid1": "pidTimer1",
                "reloj": "clock",
                "incre": "increment",
                "in1": "input1"
            },
            "calling": [
                "main"
            ],
            "called": [
                "__floatunsisf",
                "__aeabi_fmul",
                "__aeabi_fcmple",
                "__addsf3",
                "__floatsisf",
                "query",
                "__aeabi_fsub",
                "__aeabi_fcmpge",
                "poll",
                "millis",
                "__fixunssfsi",
                "__aeabi_f2iz"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a68": {
            "entrypoint": "0x00080a68",
            "current_name": "initialize_master_00080a68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMaster_00080a68(void)\n\n{\n  String::String(&emptyString,\"\");\n  registerAtExit(&emptyString,0x815ff,&dsoHandle);\n  masterId = '\\0';\n  masterSerialNumber = '\\0';\n  masterTxEnablePin = '\\x06';\n  masterTimeout = 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a68": "initialize_master_00080a68",
                "RxString": "emptyString",
                "__aeabi_atexit": "registerAtExit",
                "__dso_handle": "dsoHandle",
                "master.u8id": "masterId",
                "master.u8serno": "masterSerialNumber",
                "master.u8txenpin": "masterTxEnablePin",
                "master.u16timeOut": "masterTimeout"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit",
                "String"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "FUNC_00080aa8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080aa8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "FUNC_00080aa8"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080aac": {
            "entrypoint": "0x00080aac",
            "current_name": "handle_serial_irq_00080aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialIRQ_00080aac(void)\n\n{\n  UARTClass::IrqHandler(serialObj);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aac": "handle_serial_irq_00080aac",
                "&Serial": "serialObj"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ab8": {
            "entrypoint": "0x00080ab8",
            "current_name": "FUNC_00080ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080ab8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ab8": "FUNC_00080ab8"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080aba": {
            "entrypoint": "0x00080aba",
            "current_name": "FUNC_00080aba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080aba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aba": "FUNC_00080aba"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080abc": {
            "entrypoint": "0x00080abc",
            "current_name": "FUNC_00080abc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080abc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080abc": "FUNC_00080abc"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080ac0": {
            "entrypoint": "0x00080ac0",
            "current_name": "handle_serial1_irq_00080ac0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial1IRQ_00080ac0(void)\n\n{\n  invokeIRQHandler(&serial1Handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ac0": "handle_serial1_irq_00080ac0",
                "Serial1.super_UARTClass": "serial1Handler",
                "UARTClass::IrqHandler": "invokeIRQHandler"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080acc": {
            "entrypoint": "0x00080acc",
            "current_name": "handle_serial2_interrupt_00080acc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial2Interrupt_00080acc(void)\n\n{\n  UARTClass::IrqHandler(serial2Instance);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080acc": "handle_serial2_interrupt_00080acc",
                "&Serial2.super_UARTClass": "serial2Instance"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ad8": {
            "entrypoint": "0x00080ad8",
            "current_name": "handle_serial3_irq_00080ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial3Irq_00080ad8(void)\n\n{\n  UARTClass::IrqHandler(&serial3Object);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ad8": "handle_serial3_irq_00080ad8",
                "Serial3.super_UARTClass": "serial3Object"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ae4": {
            "entrypoint": "0x00080ae4",
            "current_name": "initialize_hardware_00080ae4",
            "code": "\n\n\nint initializeHardware_00080ae4(EVP_PKEY_CTX *context)\n\n{\n  int iVar1;\n  uint32_t pin;\n  uint32_t nextPin;\n  \n  SystemInit();\n  _DAT_e000e014 = SystemCoreClock / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  __libc_init_array();\n  pin = 0;\n  do {\n    nextPin = pin + 1;\n    digitalWrite(pin,0);\n    pin = nextPin;\n  } while (nextPin != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  PIO_Configure(&DAT_400e0e00,1,0x300,0);\n  digitalWrite(0,1);\n  PIO_Configure(&DAT_400e0e00,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,0x3000,0);\n  PIO_Configure(&DAT_400e1400,2,0x30,0);\n  PIO_Configure(&DAT_400e1000,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,3,0);\n  PIO_Configure(&DAT_400e1000,1,0xc000,0);\n  pmc_enable_periph_clk(0x25);\n  adc_init(0x400c0000,SystemCoreClock,20000000,0xc);\n  adc_configure_timing(0x400c0000,0,0x300000,1);\n  adc_configure_trigger(0x400c0000,0,0);\n  adc_disable_interrupt(0x400c0000,0xffffffff);\n  iVar1 = adc_disable_all_channel(0x400c0000);\n  analogOutputInit();\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00080ae4": "initialize_hardware_00080ae4",
                "ctx": "context",
                "ulPin": "pin",
                "uVar2": "nextPin"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PIO_Configure",
                "SystemInit",
                "adc_configure_trigger",
                "adc_disable_interrupt",
                "analogOutputInit",
                "adc_configure_timing",
                "digitalWrite",
                "__libc_init_array",
                "pmc_enable_periph_clk",
                "adc_disable_all_channel",
                "adc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c0c": {
            "entrypoint": "0x00080c0c",
            "current_name": "initialize_serial_communication_00080c0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_00080c0c(void)\n\n{\n  RingBuffer::RingBuffer(&rxBuffer1);\n  RingBuffer::RingBuffer(&txBuffer1);\n  UARTClass::UARTClass(&serialPort,(UartProtocol *)0x400e0800,UART_Interrupt,8,&rxBuffer1,&txBuffer1);\n  RingBuffer::RingBuffer(&rxBuffer2);\n  RingBuffer::RingBuffer(&rxBuffer3);\n  RingBuffer::RingBuffer(&rxBuffer4);\n  RingBuffer::RingBuffer(&txBuffer2);\n  RingBuffer::RingBuffer(&txBuffer3);\n  RingBuffer::RingBuffer(&txBuffer4);\n  USARTClass::USARTClass(&serialPort1,(UsartProtocol *)0x40098000,USART0_Interrupt,0x11,&rxBuffer2,&txBuffer2);\n  USARTClass::USARTClass(&serialPort2,(UsartProtocol *)0x4009c000,USART1_Interrupt,0x12,&rxBuffer3,&txBuffer3);\n  USARTClass::USARTClass(&serialPort3,(UsartProtocol *)0x400a4000,USART3_Interrupt,0x14,&rxBuffer4,&txBuffer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080c0c": "initialize_serial_communication_00080c0c",
                "rx_buffer1": "rxBuffer1",
                "tx_buffer1": "txBuffer1",
                "rx_buffer2": "rxBuffer2",
                "rx_buffer3": "rxBuffer3",
                "rx_buffer4": "rxBuffer4",
                "tx_buffer2": "txBuffer2",
                "tx_buffer3": "txBuffer3",
                "tx_buffer4": "txBuffer4",
                "Serial": "serialPort",
                "Serial1": "serialPort1",
                "Serial2": "serialPort2",
                "Serial3": "serialPort3",
                "Uart": "UartProtocol",
                "Usart": "UsartProtocol",
                "UART_IRQn": "UART_Interrupt",
                "USART0_IRQn": "USART0_Interrupt",
                "USART1_IRQn": "USART1_Interrupt",
                "USART3_IRQn": "USART3_Interrupt"
            },
            "calling": [],
            "called": [
                "UARTClass",
                "RingBuffer",
                "USARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ce0": {
            "entrypoint": "0x00080ce0",
            "current_name": "process_serial_events_00080ce0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processSerialEvents_00080ce0(void)\n\n{\n  int availableCount;\n  \n  availableCount = UARTClass::available(&Serial);\n  if (availableCount != 0) {\n    serialEvent();\n  }\n  availableCount = UARTClass::available(&Serial1.super_UARTClass);\n  if (availableCount != 0) {\n    serialEvent1();\n  }\n  availableCount = UARTClass::available(&Serial2.super_UARTClass);\n  if (availableCount != 0) {\n    serialEvent2();\n  }\n  availableCount = UARTClass::available(&Serial3.super_UARTClass);\n  if (availableCount != 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ce0": "process_serial_events_00080ce0",
                "iVar1": "availableCount"
            },
            "calling": [
                "main"
            ],
            "called": [
                "serialEvent2",
                "serialEvent3",
                "serialEvent1",
                "serialEvent",
                "available"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d24": {
            "entrypoint": "0x00080d24",
            "current_name": "assign_value_to_offset_00080d24",
            "code": "\nvoid assignValueToOffset_00080d24(int baseAddress,undefined4 value,int flag)\n\n{\n  if (flag != 0) {\n    *(undefined4 *)(baseAddress + 100) = value;\n    return;\n  }\n  *(undefined4 *)(baseAddress + 0x60) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d24": "assign_value_to_offset_00080d24",
                "param_1": "baseAddress",
                "param_2": "value",
                "param_3": "flag"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d2e": {
            "entrypoint": "0x00080d2e",
            "current_name": "update_data_00080d2e",
            "code": "\nvoid updateData_00080d2e(int dataPointer,undefined4 condition,uint newValue)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(dataPointer + 0x44) = newValue;\n  switch(condition) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(dataPointer + 0x70) & *(uint *)(dataPointer + 0x70) & ~newValue;\n    break;\n  case 2:\n    updatedValue = *(uint *)(dataPointer + 0x70) | newValue;\n    break;\n  default:\n    goto switchD_00080d34_caseD_6;\n  }\n  *(uint *)(dataPointer + 0x70) = updatedValue;\nswitchD_00080d34_caseD_6:\n  *(uint *)(dataPointer + 4) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d2e": "update_data_00080d2e",
                "param_1": "dataPointer",
                "param_2": "condition",
                "param_3": "newValue",
                "uVar1": "updatedValue"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d54": {
            "entrypoint": "0x00080d54",
            "current_name": "update_parameters_00080d54",
            "code": "\nvoid updateParameters_00080d54(undefined4 *parameters,undefined4 value,uint flags)\n\n{\n  bool isNegative;\n  \n  isNegative = (int)(flags << 0x1f) < 0;\n  parameters[0x11] = value;\n  if (isNegative) {\n    parameters[0x19] = value;\n  }\n  if (!isNegative) {\n    parameters[0x18] = value;\n  }\n  isNegative = (flags & 10) != 0;\n  if (isNegative) {\n    parameters[8] = value;\n  }\n  if (!isNegative) {\n    parameters[9] = value;\n  }\n  if (((int)(flags << 0x1e) < 0) || ((int)(flags << 0x1c) < 0)) {\n    parameters[0x20] = value;\n  }\n  parameters[5] = value;\n  *parameters = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d54": "update_parameters_00080d54",
                "param_1": "parameters",
                "param_2": "value",
                "param_3": "flags",
                "bVar1": "isNegative"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d7a": {
            "entrypoint": "0x00080d7a",
            "current_name": "update_parameters_00080d7a",
            "code": "\nvoid updateParameters_00080d7a(undefined4 *array,undefined4 value,int condition1,int condition2,int condition3)\n\n{\n  array[0x11] = value;\n  if (condition3 == 0) {\n    array[0x18] = value;\n  }\n  else {\n    array[0x19] = value;\n  }\n  if (condition2 == 0) {\n    array[0x15] = value;\n  }\n  else {\n    array[0x14] = value;\n  }\n  if (condition1 == 0) {\n    array[0xd] = value;\n  }\n  else {\n    array[0xc] = value;\n  }\n  array[4] = value;\n  *array = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d7a": "update_parameters_00080d7a",
                "param_1": "array",
                "param_2": "value",
                "param_3": "condition1",
                "param_4": "condition2",
                "param_5": "condition3"
            },
            "calling": [
                "PIO_Configure",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080da0": {
            "entrypoint": "0x00080da0",
            "current_name": "set_peripheral_00080da0",
            "code": "\nundefined4 setPeripheral_00080da0(int device,int mode,undefined4 peripheral,uint bitmask)\n\n{\n  bool isNegative;\n  \n  switch(mode) {\n  case 1:\n  case 2:\n    setPeripheral_00080da0Mode(device,mode,peripheral);\n    isNegative = (int)(bitmask << 0x1f) < 0;\n    *(undefined4 *)(device + 0x44) = peripheral;\n    if (isNegative) {\n      *(undefined4 *)(device + 100) = peripheral;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(device + 0x60) = peripheral;\n    }\n    break;\n  case 3:\n    setInput(device,peripheral,bitmask,0x80d55,device);\n    break;\n  case 4:\n  case 5:\n    setOutput(device,peripheral,mode == 5,(bitmask << 0x1d) >> 0x1f,bitmask & 1,mode,peripheral\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080da0": "set_peripheral_00080da0",
                "param_1": "device",
                "param_2": "mode",
                "param_3": "peripheral",
                "param_4": "bitmask",
                "bVar1": "isNegative",
                "PIO_SetPeripheral": "setPeripheralMode",
                "PIO_SetInput": "setInput",
                "PIO_SetOutput": "setOutput"
            },
            "calling": [
                "pinMode",
                "init"
            ],
            "called": [
                "PIO_SetOutput",
                "PIO_SetInput",
                "PIO_SetPeripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e04": {
            "entrypoint": "0x00080e04",
            "current_name": "check_intersection_00080e04",
            "code": "\nuint checkIntersection_00080e04(int pointer,uint mask)\n\n{\n  uint intersection;\n  \n  intersection = *(uint *)(pointer + 8) & mask;\n  if (intersection != 0) {\n    if ((mask & *(uint *)(pointer + 0x18)) == 0) {\n      intersection = 0;\n    }\n    else {\n      intersection = 1;\n    }\n  }\n  return intersection;\n}\n\n",
            "renaming": {
                "FUN_00080e04": "check_intersection_00080e04",
                "param_1": "pointer",
                "param_2": "mask",
                "uVar1": "intersection"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e18": {
            "entrypoint": "0x00080e18",
            "current_name": "check_and_update_bit_00080e18",
            "code": "\n\n\nundefined4 checkAndUpdateBit_00080e18(uint value)\n\n{\n  uint bitMask;\n  \n  if (value < 0x2d) {\n    if (value < 0x20) {\n      bitMask = 1 << (value & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (value - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080e18": "check_and_update_bit_00080e18",
                "param_1": "value",
                "uVar1": "bitMask"
            },
            "calling": [
                "pinMode",
                "init",
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e5c": {
            "entrypoint": "0x00080e5c",
            "current_name": "check_and_update_bit_00080e5c",
            "code": "\n\n\nundefined4 check_and_update_bit_00080e5c(uint bit_number)\n\n{\n  uint bit_mask;\n  uint bit_result;\n  \n  if (bit_number < 0x2d) {\n    if (bit_number < 0x20) {\n      bit_mask = 1 << (bit_number & 0xff);\n      bit_result = _DAT_400e0618 & bit_mask;\n      if (bit_result == bit_mask) {\n        _DAT_400e0614 = bit_result;\n      }\n    }\n    else {\n      bit_mask = 1 << (bit_number - 0x20 & 0xff);\n      bit_result = _DAT_400e0708 & bit_mask;\n      if (bit_result == bit_mask) {\n        _DAT_400e0704 = bit_result;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080e5c": "check_and_update_bit_00080e5c",
                "param_1": "bit_number",
                "uVar1": "bit_mask",
                "uVar2": "bit_result"
            },
            "calling": [
                "pinMode",
                "end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e9c": {
            "entrypoint": "0x00080e9c",
            "current_name": "initialize_system_clock_00080e9c",
            "code": "\n\n\nvoid initializeSystemClock_00080e9c(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  systemClock = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e9c": "initialize_system_clock_00080e9c",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f24": {
            "entrypoint": "0x00080f24",
            "current_name": "initialize_memory_00080f24",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080f6e) */\n\n\nvoid initializeMemory_00080f24(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  \n  for (index = 0; banzai + index < &completedBlock; index = index + 4) {\n    *(undefined4 *)(banzai + index) = *(undefined4 *)(&startText + index);\n  }\n  for (pointer = &completedBlock; pointer < &endBlock; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  main();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080f24": "initialize_memory_00080f24",
                "iVar1": "index",
                "puVar2": "pointer",
                "_etext": "startText",
                "completed_7857": "completedBlock",
                "_ebss": "endBlock"
            },
            "calling": [],
            "called": [
                "banzai",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f9c": {
            "entrypoint": "0x00080f9c",
            "current_name": "find_optimal_value_00080f9c",
            "code": "\nundefined4 findOptimalValue_00080f9c(undefined4 *outputArray,uint inputValue,int factorA,int factorB)\n\n{\n  uint quotient;\n  uint index;\n  uint thresholdArray [16];\n  \n  thresholdArray[0] = 0;\n  thresholdArray[1] = 8;\n  thresholdArray[2] = 0x10;\n  thresholdArray[3] = 0x18;\n  thresholdArray[4] = 0x40;\n  thresholdArray[5] = 0x50;\n  thresholdArray[6] = 0x60;\n  thresholdArray[7] = 0x70;\n  thresholdArray[8] = 0x200;\n  thresholdArray[9] = 0x240;\n  thresholdArray[10] = 0x280;\n  thresholdArray[11] = 0x2c0;\n  thresholdArray[12] = 0x300;\n  thresholdArray[13] = 0x340;\n  thresholdArray[14] = 0x380;\n  thresholdArray[15] = 0x3c0;\n  *outputArray = 1;\n  outputArray[1] = 0;\n  outputArray[0x48] = 0x202;\n  outputArray[0x41] = 0;\n  outputArray[0x45] = 0;\n  quotient = inputValue / (uint)(factorA * 2);\n  if (inputValue == factorA * 2 * quotient) {\n    quotient = quotient - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(factorB * (int)(((ulonglong)inputValue / (ulonglong)((quotient + 1) * 2)) / 1000000)) <=\n        thresholdArray[index]) {\n      outputArray[1] = (index & 0xf) << 0x10 | (quotient & 0xff) << 8 | outputArray[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080f9c": "find_optimal_value_00080f9c",
                "param_1": "outputArray",
                "param_2": "inputValue",
                "param_3": "factorA",
                "param_4": "factorB",
                "local_58": "thresholdArray",
                "uVar1": "quotient",
                "uVar2": "index"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081034": {
            "entrypoint": "0x00081034",
            "current_name": "update_flags_00081034",
            "code": "\nvoid updateFlags_00081034(int baseAddress,uint value1,uint value2)\n\n{\n  *(uint *)(baseAddress + 4) = value1 | *(uint *)(baseAddress + 4) | (value2 & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081034": "update_flags_00081034",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081042": {
            "entrypoint": "0x00081042",
            "current_name": "update_parameter_value_00081042",
            "code": "\nvoid updateParameterValue_00081042(int pointer,uint value1,uint value2,uint value3)\n\n{\n  *(uint *)(pointer + 4) =\n       value2 | *(uint *)(pointer + 4) | (value1 & 0xf) << 0x18 | (value3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081042": "update_parameter_value_00081042",
                "param_1": "pointer",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008105c": {
            "entrypoint": "0x0008105c",
            "current_name": "set_bit_0008105c",
            "code": "\nvoid setBit_0008105c(int baseAddress,uint bitPosition)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008105c": "set_bit_0008105c",
                "param_1": "baseAddress",
                "param_2": "bitPosition"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081066": {
            "entrypoint": "0x00081066",
            "current_name": "initialize_value_00081066",
            "code": "\nvoid initializeValue_00081066(int baseAddress)\n\n{\n  *(undefined4 *)(baseAddress + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081066": "initialize_value_00081066",
                "param_1": "baseAddress"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008106e": {
            "entrypoint": "0x0008106e",
            "current_name": "set_param_value_0008106e",
            "code": "\nvoid setParamValue_0008106e(int objectAddress,undefined4 parameterValue)\n\n{\n  *(undefined4 *)(objectAddress + 0x28) = parameterValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008106e": "set_param_value_0008106e",
                "param_1": "objectAddress",
                "param_2": "parameterValue"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081074": {
            "entrypoint": "0x00081074",
            "current_name": "execute_isr_00081074",
            "code": "\nvoid execute_isr_00081074(void)\n\n{\n  if (isr_function != (code *)0x0) {\n    (*isr_function)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081074": "execute_isr_00081074",
                "gpf_isr": "isr_function"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081084": {
            "entrypoint": "0x00081084",
            "current_name": "process_interrupts_00081084",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_00081084(void)\n\n{\n  uint8_t leadingZeros;\n  uint32_t interruptStatus;\n  uint remainingBits;\n  \n  for (interruptStatus = _DAT_400e0e4c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << remainingBits)) {\n    remainingBits = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioA[remainingBits] != (interruptCB)0x0) {\n      (*callbacksPioA[remainingBits])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081084": "process_interrupts_00081084",
                "isr": "interruptStatus",
                "leading_zeros": "leadingZeros",
                "uVar1": "remainingBits"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810bc": {
            "entrypoint": "0x000810bc",
            "current_name": "process_interrupts_000810bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_000810bc(void)\n\n{\n  uint8_t count;\n  uint32_t interruptStatus;\n  uint shift;\n  \n  for (interruptStatus = _DAT_400e104c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shift)) {\n    shift = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (interruptCallbacks[shift] != (interruptCB)0x0) {\n      (*interruptCallbacks[shift])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810bc": "process_interrupts_000810bc",
                "leading_zeros": "count",
                "isr": "interruptStatus",
                "uVar1": "shift",
                "callbacksPioB": "interruptCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810f4": {
            "entrypoint": "0x000810f4",
            "current_name": "process_interrupts_000810f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_000810f4(void)\n\n{\n  uint8_t countLeadingZeros;\n  uint32_t interruptStatus;\n  uint shiftAmount;\n  \n  for (interruptStatus = _DAT_400e124c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioC[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioC[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810f4": "process_interrupts_000810f4",
                "isr": "interruptStatus",
                "leading_zeros": "countLeadingZeros",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008112c": {
            "entrypoint": "0x0008112c",
            "current_name": "process_interrupts_0008112c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_0008112c(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t interruptStatus;\n  uint leadingZerosCount;\n  \n  for (interruptStatus = _DAT_400e144c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << leadingZerosCount)) {\n    leadingZerosCount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (interruptCallbacks[leadingZerosCount] != (interruptCB)0x0) {\n      (*interruptCallbacks[leadingZerosCount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008112c": "process_interrupts_0008112c",
                "isr": "interruptStatus",
                "uVar1": "leadingZerosCount",
                "callbacksPioD": "interruptCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081164": {
            "entrypoint": "0x00081164",
            "current_name": "do_nothing_loop_00081164",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid doNothingLoop_00081164(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081164": "do_nothing_loop_00081164"
            },
            "calling": [
                "__halt"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081166": {
            "entrypoint": "0x00081166",
            "current_name": "do_nothing_loop_00081166",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid doNothingLoop_00081166(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081166": "do_nothing_loop_00081166"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008116a": {
            "entrypoint": "0x0008116a",
            "current_name": "infinite_loop_0008116a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_0008116a(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0008116a": "infinite_loop_0008116a"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008116e": {
            "entrypoint": "0x0008116e",
            "current_name": "reset_time_tick_0008116e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetTimeTick_0008116e(void)\n\n{\n  int isFalse;\n  \n  isFalse = __false();\n  if (isFalse == 0) {\n    resetTick();\n    incrementTimeTick();\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008116e": "reset_time_tick_0008116e",
                "iVar1": "isFalse",
                "tickReset": "resetTick",
                "TimeTick_Increment": "incrementTimeTick"
            },
            "calling": [],
            "called": [
                "TimeTick_Increment",
                "__false",
                "tickReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081184": {
            "entrypoint": "0x00081184",
            "current_name": "initialize_00081184",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initialize_00081184(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081184": "initialize_00081184"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081188": {
            "entrypoint": "0x00081188",
            "current_name": "infinite_loop_00081188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00081188(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081188": "infinite_loop_00081188"
            },
            "calling": [
                "__halt",
                "SVC_Handler",
                "PendSV_Handler"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008118c": {
            "entrypoint": "0x0008118c",
            "current_name": "allocate_memory_0008118c",
            "code": "\nvoid * allocateMemory_0008118c(intptr_t memoryDelta)\n\n{\n  uchar *previousHeap;\n  uchar *previousHeap;\n  \n  if (currentHeap == (uchar *)0x0) {\n    currentHeap = &endOfBssSection;\n  }\n  previousHeap = currentHeap;\n  currentHeap = currentHeap + memoryDelta;\n  return previousHeap;\n}\n\n",
            "renaming": {
                "FUN_0008118c": "allocate_memory_0008118c",
                "__delta": "memoryDelta",
                "puVar1": "previousHeap",
                "prev_heap": "previousHeap",
                "_sbrk::heap": "currentHeap",
                "_ebss": "endOfBssSection"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811a8": {
            "entrypoint": "0x000811a8",
            "current_name": "reverse_strings_000811a8",
            "code": "\nint reverseStrings_000811a8(char *sourceString,char *targetString)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811a8": "reverse_strings_000811a8",
                "__from": "sourceString",
                "__to": "targetString"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ae": {
            "entrypoint": "0x000811ae",
            "current_name": "check_file_descriptor_000811ae",
            "code": "\nint checkFileDescriptor_000811ae(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811ae": "check_file_descriptor_000811ae",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b4": {
            "entrypoint": "0x000811b4",
            "current_name": "set_file_attributes_000811b4",
            "code": "\nint setFileAttributes_000811b4(int fileDescriptor,stat *fileStatusBuffer)\n\n{\n  *(undefined4 *)((int)&fileStatusBuffer->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811b4": "set_file_attributes_000811b4",
                "__fd": "fileDescriptor",
                "__buf": "fileStatusBuffer"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811be": {
            "entrypoint": "0x000811be",
            "current_name": "check_file_status_000811be",
            "code": "\nint checkFileStatus_000811be(int fileDescriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000811be": "check_file_status_000811be",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811c2": {
            "entrypoint": "0x000811c2",
            "current_name": "get_offset_000811c2",
            "code": "\n__off_t getOffset_000811c2(int fileDescriptor,__off_t offset,int referencePoint)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811c2": "get_offset_000811c2",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "referencePoint"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811c6": {
            "entrypoint": "0x000811c6",
            "current_name": "process_file_000811c6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_000811c6(int file_descriptor,char *buffer_pointer,int buffer_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811c6": "process_file_000811c6",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer_pointer",
                "len_UNUSED": "buffer_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811cc": {
            "entrypoint": "0x000811cc",
            "current_name": "process_data_000811cc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint processData_000811cc(int fileDescriptor,char *data,int length)\n\n{\n  int index;\n  \n  for (index = 0; index < length; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)(byte)data[index];\n  }\n  return length & ~(length >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_000811cc": "process_data_000811cc",
                "file_UNUSED": "fileDescriptor",
                "ptr": "data",
                "len": "length",
                "iVar1": "index"
            },
            "calling": [
                "_write_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811f0": {
            "entrypoint": "0x000811f0",
            "current_name": "exit_with_status_000811f0",
            "code": "\nvoid exitWithStatus_000811f0(int status)\n\n{\n  iprintf(\"Exiting with status %d.\\n\",status);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000811f0": "exit_with_status_000811f0",
                "__status": "status"
            },
            "calling": [],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081200": {
            "entrypoint": "0x00081200",
            "current_name": "FUNC_00081200",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00081200(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081200": "FUNC_00081200"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081202": {
            "entrypoint": "0x00081202",
            "current_name": "get_pid_00081202",
            "code": "\n\n\n__pid_t get_pid_00081202(void)\n\n{\n  pid -1;\n}\n\n",
            "renaming": {
                "FUN_00081202": "get_pid_00081202",
                "return": "pid"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081208": {
            "entrypoint": "0x00081208",
            "current_name": "get_tick_count_00081208",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_00081208(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00081208": "get_tick_count_00081208",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "sendTxBuffer",
                "setup",
                "poll",
                "loop"
            ],
            "called": [
                "GetTickCount"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008120c": {
            "entrypoint": "0x0008120c",
            "current_name": "FUNC_0008120c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008120c(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008120c": "FUNC_0008120c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008120e": {
            "entrypoint": "0x0008120e",
            "current_name": "FUNC_0008120e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008120e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008120e": "FUNC_0008120e"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081210": {
            "entrypoint": "0x00081210",
            "current_name": "configure_pin_00081210",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00081210(uint32_t pinNumber,uint32_t mode)\n\n{\n  undefined4 pinConfiguration;\n  byte pinStatusLowerNibble;\n  byte pinStatus;\n  Pio_conflict *pinPort;\n  \n  if (pinDescriptionArray[pinNumber].pinNumberType != PIO_NOT_PIN) {\n    if ((pinStatusArray[pinNumber] & 0xf) == 4) {\n      adc_disable_channel(0x400c0000,pinDescriptionArray[pinNumber].adcChannelNumber);\n    }\n    pinStatus = pinStatusArray[pinNumber];\n    pinStatusLowerNibble = pinStatus & 0xf;\n    if ((pinStatusLowerNibble < 3) && (pinStatus != 0)) {\n      if (pinStatusLowerNibble == 2) {\n        if (mode == 0) {\n          return;\n        }\n      }\n      else if (pinStatusLowerNibble == 1) {\n        if (mode == 2) {\n          return;\n        }\n      }\n      else if (pinStatusLowerNibble == 3) {\n        if (mode == 1) {\n          return;\n        }\n        goto LAB_0008126c;\n      }\n    }\n    if (mode != 1) {\nLAB_0008126c:\n      if (mode == 0) {\n        enablePeripheralClock(pinDescriptionArray[pinNumber].peripheralId);\n        configurePIO(pinDescriptionArray[pinNumber].port,3,pinDescriptionArray[pinNumber].pinNumber,0);\n        pinStatus = pinStatusArray[pinNumber] & 0xf0 | 2;\n      }\n      else {\n        if (mode != 2) {\n          return;\n        }\n        enablePeripheralClock(pinDescriptionArray[pinNumber].peripheralId);\n        configurePIO(pinDescriptionArray[pinNumber].port,3,pinDescriptionArray[pinNumber].pinNumber,1);\n        pinStatus = pinStatusArray[pinNumber] & 0xf0 | 1;\n      }\n      pinStatusArray[pinNumber] = pinStatus;\n      return;\n    }\n    pinPort = pinDescriptionArray[pinNumber].port;\n    if (pinStatus >> 4 == 0) {\n      pinConfiguration = 4;\n    }\n    else {\n      pinConfiguration = 5;\n    }\n    configurePIO(pinPort,pinConfiguration,pinDescriptionArray[pinNumber].pinNumber,\n                  pinDescriptionArray[pinNumber].pinConfiguration);\n    pinStatusArray[pinNumber] = pinStatusArray[pinNumber] & 0xf0 | 3;\n    if (pinPort->PIO_OSR == 0xffffffff) {\n      disablePeripheralClock(pinDescriptionArray[pinNumber].peripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081210": "configure_pin_00081210",
                "ulPin": "pinNumber",
                "ulMode": "mode",
                "uVar1": "pinConfiguration",
                "bVar2": "pinStatusLowerNibble",
                "bVar3": "pinStatus",
                "pPVar4": "pinPort",
                "pmc_enable_periph_clk": "enablePeripheralClock",
                "pmc_disable_periph_clk": "disablePeripheralClock",
                "PIO_Configure": "configurePIO",
                "g_APinDescription": "pinDescriptionArray",
                "PIO_NOT_A_PIN": "PIO_NOT_PIN",
                "g_pinStatus": "pinStatusArray",
                "ulADCChannelNumber": "adcChannelNumber",
                "ulPeripheralId": "peripheralId",
                "pPort": "port",
                "ulPinConfiguration": "pinConfiguration"
            },
            "calling": [
                "setup",
                "begin",
                "digitalWrite"
            ],
            "called": [
                "PIO_Configure",
                "pmc_disable_periph_clk",
                "adc_disable_channel",
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081318": {
            "entrypoint": "0x00081318",
            "current_name": "configure_pin_00081318",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00081318(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  int outputStatus;\n  uint32_t pin;\n  Pio_conflict *port;\n  uint32_t value;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    value = pinValue;\n    if ((g_pinStatus[pinNumber] & 0xf) == 5) {\n      pinMode(pinNumber,1);\n    }\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf | (byte)(pinValue << 4);\n    port = g_APinDescription[pinNumber].pPort;\n    pin = g_APinDescription[pinNumber].pinNumber;\n    outputStatus = PIO_GetOutputDataStatus(port,pin);\n    if (outputStatus == 0) {\n      PIO_PullUp(port,pin,pinValue);\n      return;\n    }\n    PIO_SetOutput(port,pin,pinValue,0,1,value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081318": "configure_pin_00081318",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "iVar1": "outputStatus",
                "uVar2": "pin",
                "pPVar3": "port",
                "uVar4": "value"
            },
            "calling": [
                "getRxBuffer",
                "sendTxBuffer",
                "setup",
                "init",
                "begin"
            ],
            "called": [
                "pinMode",
                "PIO_SetOutput",
                "PIO_PullUp",
                "PIO_GetOutputDataStatus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081388": {
            "entrypoint": "0x00081388",
            "current_name": "check_and_ban_00081388",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkAndBan_00081388(void)\n\n{\n  if ((ticks != -1) && (ticks = ticks + -1, ticks == 0)) {\n    triggerBanzai();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081388": "check_and_ban_00081388",
                "banzai": "triggerBanzai"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "banzai"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813a8": {
            "entrypoint": "0x000813a8",
            "current_name": "initialize_ring_buffer_000813a8",
            "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * ringBuffer) */\n\nRingBuffer * __ringBuffercall RingBuffer::initializeRingBuffer_000813a8(RingBuffer *ringBuffer)\n\n{\n  memset(ringBuffer,0,0x80);\n  ringBuffer->headIndex = 0;\n  ringBuffer->tailIndex = 0;\n  return ringBuffer;\n}\n\n",
            "renaming": {
                "FUN_000813a8": "initialize_ring_buffer_000813a8",
                "this": "ringBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813c2": {
            "entrypoint": "0x000813c2",
            "current_name": "store_char_000813c2",
            "code": "\n/* DWARF orhead_indexghead_indexnal prototype: vohead_indexd  store_char_000813c2(Rhead_indexngBuffer * buffer, uhead_indexnt8_t c) */\n\nvohead_indexd __buffercall Rhead_indexngBuffer::store_char_000813c2(Rhead_indexngBuffer *buffer,uhead_indexnt8_t c)\n\n{\n  head_indexnt head_index;\n  uhead_indexnt next_index;\n  \n  head_index = buffer->head;\n  next_index = head_index + 1U & 0x7f;\n  head_indexf (next_index != buffer->tail) {\n    buffer->data_buffer[buffer->head] = c;\n    buffer->head = next_index;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "buffer",
                "i": "head_index",
                "uVar1": "next_index",
                "_iHead": "head",
                "_iTail": "tail",
                "_aucBuffer": "data_buffer",
                "FUN_000813c2": "store_char_000813c2"
            },
            "calling": [
                "IrqHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e0": {
            "entrypoint": "0x000813e0",
            "current_name": "is_uart_active_000813e0",
            "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * uartObject) */\n\nbool __uartObjectcall UARTClass::isUARTActive_000813e0(UARTClass *uartObject)\n\n{\n  return true;\n}\n\n",
            "renaming": {
                "FUN_000813e0": "is_uart_active_000813e0",
                "this": "uartObject"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e4": {
            "entrypoint": "0x000813e4",
            "current_name": "get_available_data_size_000813e4",
            "code": "\n/* DWARF original prototype: int  available(UARTClass * uartInstance) */\n\nint __uartInstancecall UARTClass::getAvailableDataSize_000813e4(UARTClass *uartInstance)\n\n{\n  return uartInstance->receiveBuffer->headIndex - uartInstance->receiveBuffer->tailIndex & 0x7f;\n}\n\n",
            "renaming": {
                "FUN_000813e4": "get_available_data_size_000813e4",
                "this": "uartInstance",
                "_rx_buffer": "receiveBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813f6": {
            "entrypoint": "0x000813f6",
            "current_name": "peek_000813f6",
            "code": "\n/* DWARF original prototype: int  peek_000813f6(UARTClass * uart) */\n\nint __uartcall UARTClass::peek_000813f6(UARTClass *uart)\n\n{\n  uint value;\n  RingBuffer *ringBuffer;\n  \n  ringBuffer = uart->rxBuffer;\n  if (ringBuffer->headIndex == ringBuffer->tailIndex) {\n    value = 0xffffffff;\n  }\n  else {\n    value = (uint)ringBuffer->bufferData[ringBuffer->tailIndex];\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_000813f6": "peek_000813f6",
                "this": "uart",
                "pRVar2": "ringBuffer",
                "uVar1": "value",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "bufferData"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081412": {
            "entrypoint": "0x00081412",
            "current_name": "read_serial_data_00081412",
            "code": "\n/* DWARF original prototype: int  read(UARTClass * this) */\n\nssize_t UARTClass UARTClass::readSerialData_00081412(UARTClass *this,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  Byte bVar1;\n  UnsignedInt8 uc;\n  CircularBuffer *pRVar2;\n  \n  pRVar2 = this->receiveBuffer;\n  if (pRVar2->inputHead != pRVar2->inputTail) {\n    bVar1 = pRVar2->bufferArray[pRVar2->inputTail];\n    pRVar2->inputTail = pRVar2->inputTail + 1U & 0x7f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081412": "read_serial_data_00081412",
                "__thiscall": "UARTClass",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "byte": "Byte",
                "uint8_t": "UnsignedInt8",
                "RingBuffer": "CircularBuffer",
                "_rx_buffer": "receiveBuffer",
                "_iHead": "inputHead",
                "_iTail": "inputTail",
                "_aucBuffer": "bufferArray"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008143c": {
            "entrypoint": "0x0008143c",
            "current_name": "wait_until_tx_buffer_is_empty_0008143c",
            "code": "\n/* DWARF original prototype: void  flush(UARTClass * uartObject) */\n\nvoid __uartObjectcall UARTClass::waitUntilTxBufferIsEmpty_0008143c(UARTClass *uartObject)\n\n{\n  do {\n  } while (uartObject->transmitBuffer->headIndex != uartObject->transmitBuffer->tailIndex);\n  do {\n  } while (-1 < (int)(uartObject->uartPeripheral->UART_SR << 0x16));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008143c": "wait_until_tx_buffer_is_empty_0008143c",
                "this": "uartObject",
                "_tx_buffer": "transmitBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_pUart": "uartPeripheral"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081454": {
            "entrypoint": "0x00081454",
            "current_name": "write_uart_data_00081454",
            "code": "\n/* DWARF original prototype: size_t  write(UARTClass * uart_instance, uint8_t uc_data) */\n\nssize_t __uart_instancecall UARTClass::write_uart_data_00081454(UARTClass *uart_instance,int data_byte,void *buffer,size_t buffer_length)\n\n{\n  RingBuffer *ring_buffer;\n  uint new_iHead;\n  \n  ring_buffer = uart_instance->_tx_buffer;\n  if (((int)(uart_instance->_pUart->UART_SR << 0x1e) < 0) && (ring_buffer->_iTail == ring_buffer->_iHead)) {\n    uart_instance->_pUart->UART_THR = data_byte;\n  }\n  else {\n    new_iHead = ring_buffer->_iHead + 1U & 0x8000007f;\n    if ((int)new_iHead < 0) {\n      new_iHead = (new_iHead - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (ring_buffer->_iTail == new_iHead);\n    ring_buffer->_aucBuffer[ring_buffer->_iHead] = (uchar)data_byte;\n    uart_instance->_tx_buffer->_iHead = new_iHead;\n    uart_instance->_pUart->UART_IER = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081454": "write_uart_data_00081454",
                "this": "uart_instance",
                "__fd": "data_byte",
                "__buf": "buffer",
                "__n": "buffer_length",
                "pRVar1": "ring_buffer",
                "uVar2": "new_iHead"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814a8": {
            "entrypoint": "0x000814a8",
            "current_name": "reset_uart_000814a8",
            "code": "\n/* DWARF original prototype: void  end(UARTClass * uart) */\n\nvoid __uartcall UARTClass::resetUART_000814a8(UARTClass *uart)\n\n{\n  uart->_rx_buffer->_iHead = uart->_rx_buffer->_iTail;\n  (**(code **)(*(int *)uart + 0x14))();\n  *(int *)((((uint)(int)uart->_dwIrq >> 5) + 0x20) * 4 + -0x1fff1f00) =\n       1 << (uint)(byte)(uart->_dwIrq & 0x1f);\n  disablePeripheralClock(uart->_dwId);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000814a8": "reset_uart_000814a8",
                "this": "uart",
                "pmc_disable_periph_clk": "disablePeripheralClock"
            },
            "calling": [],
            "called": [
                "pmc_disable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814e4": {
            "entrypoint": "0x000814e4",
            "current_name": "initialize_uart_000814e4",
            "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * uartInstance, Uart * uartPointer, IRQn_Type interruptType,\n   uint32_t identificationNumber, RingBuffer * rxBuffer, RingBuffer * txBuffer) */\n\nUARTClass * __uartInstancecall\nUARTClass::initializeUART_000814e4(UARTClass *uartInstance,Uart *uartPointer,IRQn_Type interruptType,uint32_t identificationNumber,RingBuffer *rxBuffer,\n          RingBuffer *txBuffer)\n\n{\n  *(undefined4 *)&uartInstance->field4 = 0;\n  *(undefined4 *)&uartInstance->field8 = 1000;\n  uartInstance->pUart = uartPointer;\n  *(undefined ***)uartInstance = &PTR_write_1_000857a8;\n  uartInstance->dwIrq = interruptType;\n  uartInstance->rxBuffer = rxBuffer;\n  uartInstance->dwId = identificationNumber;\n  uartInstance->txBuffer = txBuffer;\n  return uartInstance;\n}\n\n",
            "renaming": {
                "FUN_000814e4": "initialize_uart_000814e4",
                "this": "uartInstance",
                "pUart": "uartPointer",
                "dwIrq": "interruptType",
                "dwId": "identificationNumber",
                "pRx_buffer": "rxBuffer",
                "pTx_buffer": "txBuffer",
                "field_0x4": "field4",
                "field_0x8": "field8",
                "_pUart": "pUart",
                "_dwIrq": "dwIrq",
                "_rx_buffer": "rxBuffer",
                "_dwId": "dwId",
                "_tx_buffer": "txBuffer"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription",
                "USARTClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081508": {
            "entrypoint": "0x00081508",
            "current_name": "initialize_uart_00081508",
            "code": "\n/* DWARF original prototype: void  init(UARTClass * uartInstance, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __uartInstancecall UARTClass::initializeUART_00081508(UARTClass *uartInstance,EVP_PKEY_CTX *context)\n\n{\n  uint irqIndex;\n  RingBuffer *rxBuffer;\n  RwReg modeRegister;\n  Uart *uartReg;\n  \n  enablePeripheralClock(uartInstance->id);\n  uartReg = uartInstance->uart;\n  uartReg->UART_PTCR = 0x202;\n  uartReg->UART_CR = 0xac;\n  uartReg->UART_MR = modeRegister;\n  uartReg->UART_BRGR = systemClock / (uint)context >> 4;\n  uartReg->UART_IDR = 0xffffffff;\n  uartReg->UART_IER = 0x61;\n  irqIndex = (uint)(int)uartInstance->irq >> 5;\n  *(int *)(irqIndex * 4 + -0x1fff1f00) = 1 << (uint)(byte)(uartInstance->irq & 0x1f);\n  rxBuffer = uartInstance->receiveBuffer;\n  rxBuffer->_iTail = 0;\n  rxBuffer->_iHead = 0;\n  rxBuffer = uartInstance->transmitBuffer;\n  rxBuffer->_iTail = 0;\n  rxBuffer->_iHead = 0;\n  uartReg->UART_CR = 0x50;\n  return irqIndex;\n}\n\n",
            "renaming": {
                "FUN_00081508": "initialize_uart_00081508",
                "this": "uartInstance",
                "ctx": "context",
                "uVar1": "irqIndex",
                "pRVar2": "rxBuffer",
                "in_r2": "modeRegister",
                "pUVar3": "uartReg",
                "pmc_enable_periph_clk": "enablePeripheralClock",
                "SystemCoreClock": "systemClock",
                "_dwId": "id",
                "_pUart": "uart",
                "_dwIrq": "irq",
                "_rx_buffer": "receiveBuffer",
                "_tx_buffer": "transmitBuffer"
            },
            "calling": [
                "begin",
                "begin"
            ],
            "called": [
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081578": {
            "entrypoint": "0x00081578",
            "current_name": "initialize_uart_00081578",
            "code": "\n/* DWARF original prototype: void  begin(UARTClass * uart, uint32_t baudRate) */\n\nvoid __uartcall UARTClass::initializeUART_00081578(UARTClass *uart,uint32_t baudRate)\n\n{\n  initializeCommunication(uart,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081578": "initialize_uart_00081578",
                "this": "uart",
                "dwBaudRate": "baudRate",
                "init": "initializeCommunication"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081580": {
            "entrypoint": "0x00081580",
            "current_name": "handle_interrupt_00081580",
            "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * uartObject) */\n\nvoid __uartObjectcall UARTClass::handleInterrupt_00081580(UARTClass *uartObject)\n\n{\n  Buffer *txBuffer;\n  uint32_t uartStatus;\n  RoReg uartSR;\n  \n  uartSR = uartObject->_pUart->UART_SR;\n  if ((int)(uartSR << 0x1f) < 0) {\n    Buffer::store_char(uartObject->_rx_buffer,(uint8_t)uartObject->_pUart->UART_RHR);\n  }\n  if ((int)(uartSR << 0x1e) < 0) {\n    txBuffer = uartObject->_tx_buffer;\n    if (txBuffer->_iTail != txBuffer->_iHead) {\n      uartObject->_pUart->UART_THR = (uint)txBuffer->_aucBuffer[txBuffer->_iTail];\n      txBuffer->_iTail = txBuffer->_iTail + 1U & 0x7f;\n      return;\n    }\n    uartObject->_pUart->UART_IDR = 2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "uartObject",
                "RingBuffer": "Buffer",
                "pRVar1": "txBuffer",
                "status": "uartStatus",
                "RVar2": "uartSR",
                "FUN_00081580": "handle_interrupt_00081580"
            },
            "calling": [
                "USART1_Handler",
                "UART_Handler",
                "USART3_Handler",
                "USART0_Handler"
            ],
            "called": [
                "store_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815ca": {
            "entrypoint": "0x000815ca",
            "current_name": "initialize_uart_000815ca",
            "code": "\n/* DWARF original prototype: void  begin(USARTClass * uart, uint32_t baudRate) */\n\nvoid __uartcall USARTClass::initializeUART_000815ca(USARTClass *uart,uint32_t baudRate)\n\n{\n  UARTClass::init(&uart->super_UARTClass,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "this": "uart",
                "dwBaudRate": "baudRate",
                "FUN_000815ca": "initialize_uart_000815ca"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815d4": {
            "entrypoint": "0x000815d4",
            "current_name": "initialize_usart_class_000815d4",
            "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * usartObject, Usart * usartPointer, IRQn_Type\n   interrupt, uint32_t id, RingBuffer * rxBuffer, RingBuffer * txBuffer) */\n\nUSARTClass * __usartObjectcall\nUSARTClass::initializeUSARTClass_000815d4(USARTClass *usartObject,Usart *usartPointer,IRQn_Type interrupt,uint32_t id,RingBuffer *rxBuffer,\n          RingBuffer *txBuffer)\n\n{\n  UARTClass::UARTClass(&usartObject->super_UARTClass,(Uart *)usartPointer,interrupt,id,rxBuffer,txBuffer);\n  *(undefined ***)&usartObject->super_UARTClass = &PTR_write_1_000857d8;\n  usartObject->usartPointer = usartPointer;\n  return usartObject;\n}\n\n",
            "renaming": {
                "FUN_000815d4": "initialize_usart_class_000815d4",
                "this": "usartObject",
                "pUsart": "usartPointer",
                "dwIrq": "interrupt",
                "dwId": "id",
                "pRx_buffer": "rxBuffer",
                "pTx_buffer": "txBuffer",
                "_pUsart": "usartPointer"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "UARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815f8": {
            "entrypoint": "0x000815f8",
            "current_name": "concatenate_bytes_000815f8",
            "code": "\n/* WARNING: Unknown calowBytelowByteing convention */\n\nuint16_t concatenateBytes_000815f8(uint8_t highByte,uint8_t lowByte)\n\n{\n  return CONCAT11(highByte,lowByte);\n}\n\n",
            "renaming": {
                "FUN_000815f8": "concatenate_bytes_000815f8",
                "h": "highByte",
                "l": "lowByte"
            },
            "calling": [
                "get_FC3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815fe": {
            "entrypoint": "0x000815fe",
            "current_name": "deallocate_string_buffer_000815fe",
            "code": "\n/* DWARF original prototype: void *  ~String(String * stringObject, int chargeFlag) */\n\nvoid * __stringObjectcall String::deallocateStringBuffer_000815fe(String *stringObject,int chargeFlag)\n\n{\n  free(stringObject->buffer);\n  return stringObject;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "__in_chrg": "chargeFlag",
                "FUN_000815fe": "deallocate_string_buffer_000815fe"
            },
            "calling": [],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008160c": {
            "entrypoint": "0x0008160c",
            "current_name": "clear_string_0008160c",
            "code": "\n/* DWARF original prototype: void  invalidate(String * stringObj) */\n\nvoid __stringObjcall String::clearString_0008160c(String *stringObj)\n\n{\n  if (stringObj->buffer != (char *)0x0) {\n    free(stringObj->buffer);\n  }\n  stringObj->buffer = (char *)0x0;\n  stringObj->len = 0;\n  stringObj->capacity = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "stringObj",
                "FUN_0008160c": "clear_string_0008160c"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081622": {
            "entrypoint": "0x00081622",
            "current_name": "resize_buffer_00081622",
            "code": "\n/* DWARF original prototype: uchar  changeBuffer(Buffer * this, uint newSize) */\n\nuchar __thiscall Buffer::resizeBuffer_00081622(Buffer *this,uint newSize)\n\n{\n  char *newBuffer;\n  char *newbuffer;\n  \n  newBuffer = (char *)realloc(this->buffer,newSize + 1);\n  if (newBuffer != (char *)0x0) {\n    this->buffer = newBuffer;\n    this->capacity = newSize;\n    newBuffer = (char *)0x1;\n  }\n  return (uchar)newBuffer;\n}\n\n",
            "renaming": {
                "String": "Buffer",
                "maxStrLen": "newSize",
                "pcVar1": "newBuffer",
                "FUN_00081622": "resize_buffer_00081622"
            },
            "calling": [
                "reserve"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008163a": {
            "entrypoint": "0x0008163a",
            "current_name": "reserve_memory_0008163a",
            "code": "\n/* DWARF original prototype: uchar  reserve(String * str, uint newSize) */\n\nuchar __strcall String::reserveMemory_0008163a(String *str,uint newSize)\n\n{\n  uchar success;\n  \n  if ((str->buffer == (char *)0x0) || (str->capacity < newSize)) {\n    success = changeBuffer(str,newSize);\n    if (success == '\\0') {\n      return '\\0';\n    }\n    if (str->len == 0) {\n      *str->buffer = '\\0';\n    }\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "this": "str",
                "size": "newSize",
                "uVar1": "success",
                "FUN_0008163a": "reserve_memory_0008163a"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "changeBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008165c": {
            "entrypoint": "0x0008165c",
            "current_name": "copy_string_buffer_0008165c",
            "code": "\n/* DWARF original prototype: String *  copy(String * stringObj, char * cstr, uint length) */\n\nint __stringObjcall String::copyStringBuffer_0008165c(String *stringObj,EVP_PKEY_CTX *destinationContext,EVP_PKEY_CTX *sourceContext)\n\n{\n  uchar reserveSuccess;\n  \n  reserveSuccess = reserve(stringObj,(uint)sourceContext);\n  if (reserveSuccess == '\\0') {\n    invalidate(stringObj);\n  }\n  else {\n    stringObj->len = (uint)sourceContext;\n    strcpy(stringObj->buffer,(char *)destinationContext);\n  }\n  return (int)stringObj;\n}\n\n",
            "renaming": {
                "this": "stringObj",
                "dst": "destinationContext",
                "src": "sourceContext",
                "uVar1": "reserveSuccess",
                "FUN_0008165c": "copy_string_buffer_0008165c"
            },
            "calling": [
                "String"
            ],
            "called": [
                "reserve",
                "invalidate",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081682": {
            "entrypoint": "0x00081682",
            "current_name": "initialize_string_00081682",
            "code": "\n/* DWARF original prototype: String *  String(String * str, char * inputString) */\n\nString * __strcall String::initializeString_00081682(String *str,char *inputString)\n\n{\n  EVP_PKEY_CTX *stringLength;\n  \n  str->buffer = (char *)0x0;\n  str->capacity = 0;\n  str->len = 0;\n  if (inputString != (char *)0x0) {\n    stringLength = (EVP_PKEY_CTX *)strlen(inputString);\n    copy(str,(EVP_PKEY_CTX *)inputString,stringLength);\n  }\n  return str;\n}\n\n",
            "renaming": {
                "this": "str",
                "cstr": "inputString",
                "src": "stringLength",
                "FUN_00081682": "initialize_string_00081682"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "strlen",
                "copy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816a6": {
            "entrypoint": "0x000816a6",
            "current_name": "FUNC_000816a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_000816a6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816a6": "FUNC_000816a6"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000816a8": {
            "entrypoint": "0x000816a8",
            "current_name": "run_application_000816a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runApplication_000816a8(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  setupWatchdog();\n  initialize(ctx);\n  initializeVariant();\n  wait(1);\n  configure();\n  while {\n    performTask();\n    processSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816a8": "run_application_000816a8",
                "in_r0": "ctx",
                "_watchdogDefaultSetup": "setupWatchdog",
                "init": "initialize",
                "initVariant": "initializeVariant",
                "delay": "wait",
                "setup": "configure",
                "do": "while",
                "loop": "performTask",
                "serialEventRun": "processSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "initVariant",
                "_watchdogDefaultSetup",
                "serialEventRun",
                "setup",
                "loop",
                "init",
                "delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d4": {
            "entrypoint": "0x000816d4",
            "current_name": "disable_watchdog_timer_000816d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_watchdog_timer_000816d4(void)\n\n{\n  WDT_Disable(0x400e1a50);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816d4": "disable_watchdog_timer_000816d4"
            },
            "calling": [
                "main"
            ],
            "called": [
                "WDT_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816e0": {
            "entrypoint": "0x000816e0",
            "current_name": "write_to_file_000816e0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000816f6 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * print_object, uint8_t * buffer, size_t size) */\n\nssize_t __print_objectcall Print::write_to_file_000816e0(Print *print_object,int file_descriptor,void *buffer,size_t buffer_size)\n\n{\n  Print *print_result;\n  void *current_position;\n  \n  current_position = (void *)0x0;\n  print_result = print_object;\n  while ((current_position != buffer &&\n         (print_result = (Print *)(**print_object->_vptr_Print)(print_result,(uint)*(byte *)(file_descriptor + (int)current_position)),\n         print_result != (Print *)0x0))) {\n    current_position = (void *)((int)current_position + 1);\n  }\n  return (ssize_t)current_position;\n}\n\n",
            "renaming": {
                "this": "print_object",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "pvVar2": "current_position",
                "pPVar1": "print_result",
                "FUN_000816e0": "write_to_file_000816e0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081704": {
            "entrypoint": "0x00081704",
            "current_name": "increment_tick_count_00081704",
            "code": "\nvoid incrementTickCount_00081704(void)\n\n{\n  tickCounter = tickCounter + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081704": "increment_tick_count_00081704",
                "_dwTickCount": "tickCounter"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081714": {
            "entrypoint": "0x00081714",
            "current_name": "get_tick_count_00081714",
            "code": "\nundefined4 getTickCount_00081714(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00081714": "get_tick_count_00081714",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "millis"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081720": {
            "entrypoint": "0x00081720",
            "current_name": "initialize_memory_00081720",
            "code": "\nvoid initializeMemory_00081720(int memoryAddress)\n\n{\n  *(undefined4 *)(memoryAddress + 4) = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081720": "initialize_memory_00081720",
                "param_1": "memoryAddress"
            },
            "calling": [
                "_watchdogDefaultSetup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081728": {
            "entrypoint": "0x00081728",
            "current_name": "convert_to_negative_00081728",
            "code": "\nvoid convertToNegative_00081728(uint inputValue)\n\n{\n  subtractFromZero(inputValue ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081728": "convert_to_negative_00081728",
                "param_1": "inputValue",
                "__addsf3": "subtractFromZero"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081730": {
            "entrypoint": "0x00081730",
            "current_name": "calculate_float_00081730",
            "code": "\nuint calculateFloat_00081730(uint input_1,uint input_2,undefined4 input_3,uint input_4)\n\n{\n  int shifted_input_1;\n  int shifted_input_2;\n  uint xor_1;\n  uint xor_2;\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  bool is_true;\n  \n  xor_1 = input_2 ^ 0x80000000;\n  temp_1 = input_1 << 1;\n  is_true = temp_1 == 0;\n  if (!is_true) {\n    input_4 = input_2 << 1;\n    is_true = input_4 == 0;\n  }\n  if (!is_true) {\n    is_true = temp_1 == input_4;\n  }\n  shifted_input_1 = (int)temp_1 >> 0x18;\n  if (!is_true) {\n    is_true = shifted_input_1 == -1;\n  }\n  if (!is_true) {\n    is_true = (int)input_4 >> 0x18 == -1;\n  }\n  if (is_true) {\n    shifted_input_2 = (int)(input_2 << 1) >> 0x18;\n    if (shifted_input_1 == -1 || shifted_input_2 == -1) {\n      temp_1 = xor_1;\n      if (shifted_input_1 == -1) {\n        temp_1 = input_1;\n      }\n      if (shifted_input_1 != -1 || shifted_input_2 != -1) {\n        xor_1 = temp_1;\n      }\n      is_true = (temp_1 & 0x7fffff) == 0;\n      if (is_true) {\n        is_true = (xor_1 & 0x7fffff) == 0;\n      }\n      if (is_true) {\n        is_true = temp_1 == xor_1;\n      }\n      if (!is_true) {\n        temp_1 = temp_1 | 0x400000;\n      }\n      return temp_1;\n    }\n    if (((input_1 ^ xor_1) & 0x7fffffff) != 0) {\n      if (temp_1 == 0) {\n        input_1 = xor_1;\n      }\n      return input_1;\n    }\n    if (input_1 != xor_1) {\n      return 0;\n    }\n    if ((temp_1 & 0xff000000) == 0) {\n      xor_1 = input_1 << 1;\n      if ((input_1 & 0x80000000) != 0) {\n        xor_1 = xor_1 | 0x80000000;\n      }\n      return xor_1;\n    }\n    if (temp_1 < 0xfe000000) {\n      return input_1 + 0x800000;\n    }\n    input_1 = input_1 & 0x80000000;\nLAB_0008186a:\n    return input_1 | 0x7f800000;\n  }\n  temp_1 = temp_1 >> 0x18;\n  input_4 = input_4 >> 0x18;\n  temp_3 = input_4 - temp_1;\n  is_true = temp_3 != 0;\n  temp_2 = temp_1;\n  if (is_true && temp_1 <= input_4) {\n    temp_2 = temp_1 + temp_3;\n  }\n  if (is_true && temp_1 <= input_4) {\n    xor_1 = xor_1 ^ input_1;\n  }\n  if (is_true && temp_1 <= input_4) {\n    input_1 = input_1 ^ xor_1;\n  }\n  if (is_true && temp_1 <= input_4) {\n    xor_1 = xor_1 ^ input_1;\n  }\n  if (input_4 < temp_1) {\n    temp_3 = -temp_3;\n  }\n  if (0x19 < temp_3) {\n    return input_1;\n  }\n  temp_1 = input_1 & 0xffffff | 0x800000;\n  if ((input_1 & 0x80000000) != 0) {\n    temp_1 = -temp_1;\n  }\n  xor_2 = xor_1 & 0xffffff | 0x800000;\n  if ((xor_1 & 0x80000000) != 0) {\n    xor_2 = -xor_2;\n  }\n  if (temp_2 == temp_3) {\n    xor_2 = xor_2 ^ 0x800000;\n    if (temp_2 == 0) {\n      temp_1 = temp_1 ^ 0x800000;\n      temp_2 = 1;\n    }\n    else {\n      temp_3 = temp_3 - 1;\n    }\n  }\n  temp_1 = temp_1 + ((int)xor_2 >> (temp_3 & 0xff));\n  xor_2 = xor_2 << (0x20 - temp_3 & 0xff);\n  input_1 = temp_1 & 0x80000000;\n  if ((int)temp_1 < 0) {\n    is_true = xor_2 != 0;\n    xor_2 = -xor_2;\n    temp_1 = -temp_1 - (uint)is_true;\n  }\n  if (temp_1 < 0x800000) {\n    xor_1 = xor_2 & 0x80000000;\n    xor_2 = xor_2 << 1;\n    temp_1 = temp_1 * 2 + (uint)(xor_1 != 0);\n    xor_1 = temp_2 - 2;\n    if ((temp_1 & 0x800000) == 0) {\n      temp_3 = LZCOUNT(temp_1) - 8;\n      temp_1 = temp_1 << (temp_3 & 0xff);\n      if ((int)xor_1 < (int)temp_3) {\n        temp_1 = temp_1 >> (-(xor_1 - temp_3) & 0xff);\n      }\n      else {\n        temp_1 = temp_1 + (xor_1 - temp_3) * 0x800000;\n      }\n      return temp_1 | input_1;\n    }\n  }\n  else {\n    xor_1 = temp_2 - 1;\n    if (0xffffff < temp_1) {\n      xor_1 = temp_1 & 1;\n      temp_1 = temp_1 >> 1;\n      xor_2 = (uint)(xor_1 != 0) << 0x1f | xor_2 >> 1;\n      xor_1 = temp_2;\n      if (0xfd < temp_2) goto LAB_0008186a;\n    }\n  }\n  temp_1 = temp_1 + xor_1 * 0x800000 + (uint)(0x7fffffff < xor_2);\n  if (xor_2 == 0x80000000) {\n    temp_1 = temp_1 & 0xfffffffe;\n  }\n  return temp_1 | input_1;\n}\n\n",
            "renaming": {
                "FUN_00081730": "calculate_float_00081730",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shifted_input_1",
                "iVar2": "shifted_input_2",
                "uVar3": "xor_1",
                "uVar4": "xor_2",
                "uVar5": "temp_1",
                "uVar6": "temp_2",
                "uVar7": "temp_3",
                "bVar8": "is_true"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081734": {
            "entrypoint": "0x00081734",
            "current_name": "calculate_float_00081734",
            "code": "\nuint calculateFloat_00081734(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftedInput1;\n  int shiftedInput2;\n  uint result1;\n  uint shiftedResult1;\n  uint result2;\n  uint difference;\n  bool isEqual;\n  \n  shiftedResult1 = input1 << 1;\n  isEqual = shiftedResult1 == 0;\n  if (!isEqual) {\n    input4 = input2 << 1;\n    isEqual = input4 == 0;\n  }\n  if (!isEqual) {\n    isEqual = shiftedResult1 == input4;\n  }\n  shiftedInput1 = (int)shiftedResult1 >> 0x18;\n  if (!isEqual) {\n    isEqual = shiftedInput1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)input4 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    shiftedInput2 = (int)(input2 << 1) >> 0x18;\n    if (shiftedInput1 == -1 || shiftedInput2 == -1) {\n      shiftedResult1 = input2;\n      if (shiftedInput1 == -1) {\n        shiftedResult1 = input1;\n      }\n      if (shiftedInput1 != -1 || shiftedInput2 != -1) {\n        input2 = shiftedResult1;\n      }\n      isEqual = (shiftedResult1 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (input2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = shiftedResult1 == input2;\n      }\n      if (!isEqual) {\n        shiftedResult1 = shiftedResult1 | 0x400000;\n      }\n      return shiftedResult1;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (shiftedResult1 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((shiftedResult1 & 0xff000000) == 0) {\n      shiftedResult1 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        shiftedResult1 = shiftedResult1 | 0x80000000;\n      }\n      return shiftedResult1;\n    }\n    if (shiftedResult1 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_0008186a:\n    return input1 | 0x7f800000;\n  }\n  shiftedResult1 = shiftedResult1 >> 0x18;\n  input4 = input4 >> 0x18;\n  difference = input4 - shiftedResult1;\n  isEqual = difference != 0;\n  result2 = shiftedResult1;\n  if (isEqual && shiftedResult1 <= input4) {\n    result2 = shiftedResult1 + difference;\n  }\n  if (isEqual && shiftedResult1 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (isEqual && shiftedResult1 <= input4) {\n    input1 = input1 ^ input2;\n  }\n  if (isEqual && shiftedResult1 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (input4 < shiftedResult1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input1;\n  }\n  shiftedResult1 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    shiftedResult1 = -shiftedResult1;\n  }\n  result1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    result1 = -result1;\n  }\n  if (result2 == difference) {\n    result1 = result1 ^ 0x800000;\n    if (result2 == 0) {\n      shiftedResult1 = shiftedResult1 ^ 0x800000;\n      result2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shiftedResult1 = shiftedResult1 + ((int)result1 >> (difference & 0xff));\n  result1 = result1 << (0x20 - difference & 0xff);\n  input1 = shiftedResult1 & 0x80000000;\n  if ((int)shiftedResult1 < 0) {\n    isEqual = result1 != 0;\n    result1 = -result1;\n    shiftedResult1 = -shiftedResult1 - (uint)isEqual;\n  }\n  if (shiftedResult1 < 0x800000) {\n    difference = result1 & 0x80000000;\n    result1 = result1 << 1;\n    shiftedResult1 = shiftedResult1 * 2 + (uint)(difference != 0);\n    difference = result2 - 2;\n    if ((shiftedResult1 & 0x800000) == 0) {\n      result2 = LZCOUNT(shiftedResult1) - 8;\n      shiftedResult1 = shiftedResult1 << (result2 & 0xff);\n      if ((int)difference < (int)result2) {\n        shiftedResult1 = shiftedResult1 >> (-(difference - result2) & 0xff);\n      }\n      else {\n        shiftedResult1 = shiftedResult1 + (difference - result2) * 0x800000;\n      }\n      return shiftedResult1 | input1;\n    }\n  }\n  else {\n    difference = result2 - 1;\n    if (0xffffff < shiftedResult1) {\n      difference = shiftedResult1 & 1;\n      shiftedResult1 = shiftedResult1 >> 1;\n      result1 = (uint)(difference != 0) << 0x1f | result1 >> 1;\n      difference = result2;\n      if (0xfd < result2) goto LAB_0008186a;\n    }\n  }\n  shiftedResult1 = shiftedResult1 + difference * 0x800000 + (uint)(0x7fffffff < result1);\n  if (result1 == 0x80000000) {\n    shiftedResult1 = shiftedResult1 & 0xfffffffe;\n  }\n  return shiftedResult1 | input1;\n}\n\n",
            "renaming": {
                "FUN_00081734": "calculate_float_00081734",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput1",
                "iVar2": "shiftedInput2",
                "uVar3": "result1",
                "uVar4": "shiftedResult1",
                "uVar5": "result2",
                "uVar6": "difference",
                "bVar7": "isEqual"
            },
            "calling": [
                "loop",
                "__aeabi_frsub"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081894": {
            "entrypoint": "0x00081894",
            "current_name": "calculate_hash_00081894",
            "code": "\nuint calculateHash_00081894(uint input)\n\n{\n  uint finalResult;\n  uint maskCheck;\n  int shiftedInput;\n  uint mask;\n  \n  if (input == 0) {\n    return 0;\n  }\n  finalResult = LZCOUNT(input);\n  maskCheck = finalResult - 8;\n  shiftedInput = maskCheck * -0x800000 + 0x4a800000;\n  if (7 < finalResult) {\n    mask = 0 << (maskCheck & 0xff);\n    finalResult = shiftedInput + (input << (maskCheck & 0xff)) +\n            (0U >> (0x20 - maskCheck & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      finalResult = finalResult & 0xfffffffe;\n    }\n    return finalResult;\n  }\n  maskCheck = input << finalResult + 0x18;\n  finalResult = shiftedInput + ((input >> (0x20 - (finalResult + 0x18) & 0xff)) - ((int)maskCheck >> 0x1f));\n  if ((maskCheck & 0x7fffffff) == 0) {\n    finalResult = finalResult & ~(maskCheck >> 0x1f);\n  }\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_00081894": "calculate_hash_00081894",
                "param_1": "input",
                "uVar1": "finalResult",
                "uVar2": "maskCheck",
                "iVar3": "shiftedInput",
                "uVar4": "mask"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008189c": {
            "entrypoint": "0x0008189c",
            "current_name": "calculate_offset_0008189c",
            "code": "\nuint calculateOffset_0008189c(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftedValue;\n  uint signBit;\n  int offset;\n  \n  signBit = inputValue & 0x80000000;\n  if ((int)signBit < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftedValue = leadingZeros - 8;\n  offset = ((signBit | 0x4b000000) - 0x800000) + shiftedValue * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftedValue & 0xff);\n    signBit = offset + (inputValue << (shiftedValue & 0xff)) +\n            (0U >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftedValue = inputValue << leadingZeros + 0x18;\n  signBit = offset + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n  if ((shiftedValue & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftedValue >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_0008189c": "calculate_offset_0008189c",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftedValue",
                "uVar3": "signBit",
                "iVar4": "offset"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000818b8": {
            "entrypoint": "0x000818b8",
            "current_name": "calculate_000818b8",
            "code": "\nuint calculate_000818b8(uint input1,uint input2)\n\n{\n  uint result1;\n  uint output;\n  uint shift_count;\n  uint shifted_value;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  result1 = input1;\n  output = input2;\n  if (input2 == 0) {\n    result1 = 0;\n    output = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  shift_count = LZCOUNT(output);\n  shifted_value = shift_count - 8;\n  constant = constant + -0x800000 + shifted_value * -0x800000;\n  if (shift_count < 8) {\n    shifted_value = output << shift_count + 0x18;\n    output = constant + ((output >> (0x20 - (shift_count + 0x18) & 0xff)) - ((int)shifted_value >> 0x1f));\n    if ((result1 | shifted_value << 1) == 0) {\n      output = output & ~(shifted_value >> 0x1f);\n    }\n    return output;\n  }\n  shift_count = result1 << (shifted_value & 0xff);\n  output = constant + (output << (shifted_value & 0xff)) +\n          (result1 >> (0x20 - shifted_value & 0xff)) + (uint)(0x7fffffff < shift_count);\n  if (shift_count == 0x80000000) {\n    output = output & 0xfffffffe;\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_000818b8": "calculate_000818b8",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "output",
                "uVar3": "shift_count",
                "uVar4": "shifted_value",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000818c8": {
            "entrypoint": "0x000818c8",
            "current_name": "calculate_checksum_000818c8",
            "code": "\nuint calculateChecksum_000818c8(uint input1,uint input2)\n\n{\n  uint temp1;\n  uint temp2;\n  uint bitCount;\n  uint shift;\n  uint signBit;\n  int offset;\n  bool isPositive;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  signBit = input2 & 0x80000000;\n  if ((int)signBit < 0) {\n    isPositive = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)isPositive;\n  }\n  temp2 = input1;\n  temp1 = input2;\n  if (input2 == 0) {\n    temp2 = 0;\n    temp1 = input1;\n  }\n  signBit = signBit | 0x5b000000;\n  if (input2 == 0) {\n    signBit = signBit + 0xf0000000;\n  }\n  bitCount = LZCOUNT(temp1);\n  shift = bitCount - 8;\n  offset = (signBit - 0x800000) + shift * -0x800000;\n  if (bitCount < 8) {\n    shift = temp1 << bitCount + 0x18;\n    signBit = offset + ((temp1 >> (0x20 - (bitCount + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((temp2 | shift << 1) == 0) {\n      signBit = signBit & ~(shift >> 0x1f);\n    }\n    return signBit;\n  }\n  bitCount = temp2 << (shift & 0xff);\n  signBit = offset + (temp1 << (shift & 0xff)) +\n          (temp2 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < bitCount);\n  if (bitCount == 0x80000000) {\n    signBit = signBit & 0xfffffffe;\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_000818c8": "calculate_checksum_000818c8",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "bitCount",
                "uVar4": "shift",
                "uVar5": "signBit",
                "iVar6": "offset",
                "bVar7": "isPositive"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081944": {
            "entrypoint": "0x00081944",
            "current_name": "calculate_float32_number_00081944",
            "code": "\nuint calculateFloat32Number_00081944(uint input1,uint input2,undefined4 bits1,uint bits2)\n\n{\n  longlong temp1;\n  uint result;\n  uint bits1Value;\n  int sumOfBits;\n  int bitDifference;\n  uint temp2;\n  int remainingBits;\n  uint combinedBits;\n  bool isZeroBits1;\n  bool isNegativeSum;\n  \n  bits1Value = input1 >> 0x17 & 0xff;\n  isZeroBits1 = bits1Value == 0;\n  if (!isZeroBits1) {\n    bits2 = input2 >> 0x17 & 0xff;\n    isZeroBits1 = bits2 == 0;\n  }\n  if (!isZeroBits1) {\n    isZeroBits1 = bits1Value == 0xff;\n  }\n  if (!isZeroBits1) {\n    isZeroBits1 = bits2 == 0xff;\n  }\n  if (isZeroBits1) {\n    bits2 = input2 >> 0x17 & 0xff;\n    if (bits1Value == 0xff || bits2 == 0xff) {\n      isZeroBits1 = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZeroBits1 = input2 == 0;\n        result = input1;\n      }\n      if (!isZeroBits1) {\n        isZeroBits1 = input2 == 0x80000000;\n      }\n      combinedBits = result;\n      if (((isZeroBits1) || ((bits1Value == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((bits2 == 0xff && (combinedBits = input2, (input2 & 0x7fffff) != 0)))) {\n        return combinedBits | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_00081a94;\n    }\n    isZeroBits1 = (input1 & 0x7fffffff) == 0;\n    if (!isZeroBits1) {\n      isZeroBits1 = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZeroBits1) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZeroBits1 = bits1Value == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isZeroBits1) {\n        input1 = input1 << 1;\n        isZeroBits1 = (input1 & 0x800000) == 0;\n      }\n      if (!isZeroBits1) break;\n      bits1Value = bits1Value - 1;\n    }\n    input1 = input1 | result;\n    isZeroBits1 = bits2 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isZeroBits1) {\n        input2 = input2 << 1;\n        isZeroBits1 = (input2 & 0x800000) == 0;\n      }\n      if (!isZeroBits1) break;\n      bits2 = bits2 - 1;\n    }\n    input2 = input2 | result;\n  }\n  sumOfBits = bits1Value + bits2;\n  combinedBits = input1 ^ input2;\n  bits1Value = input1 << 9;\n  isZeroBits1 = bits1Value == 0;\n  if (!isZeroBits1) {\n    input2 = input2 << 9;\n    isZeroBits1 = input2 == 0;\n  }\n  if (isZeroBits1) {\n    if (bits1Value == 0) {\n      input2 = input2 << 9;\n    }\n    result = combinedBits & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    isNegativeSum = SBORROW4(sumOfBits,0x7f);\n    bitDifference = sumOfBits + -0x7f;\n    isZeroBits1 = bitDifference == 0;\n    remainingBits = bitDifference;\n    if (!isZeroBits1 && 0x7e < sumOfBits) {\n      isNegativeSum = SBORROW4(0xff,bitDifference);\n      remainingBits = 0xff - bitDifference;\n      isZeroBits1 = bitDifference == 0xff;\n    }\n    if (!isZeroBits1 && remainingBits < 0 == isNegativeSum) {\n      result = result | bitDifference * 0x800000;\n    }\n    if (!isZeroBits1 && remainingBits < 0 == isNegativeSum) {\n      return result;\n    }\n    result = result | 0x800000;\n    temp2 = 0;\n    isNegativeSum = SBORROW4(bitDifference,1);\n    combinedBits = sumOfBits - 0x80;\n    isZeroBits1 = combinedBits == 0;\n    bits1Value = combinedBits;\n  }\n  else {\n    temp1 = (ulonglong)(bits1Value >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    temp2 = (uint)temp1;\n    result = (uint)((ulonglong)temp1 >> 0x20);\n    isZeroBits1 = result < 0x800000;\n    if (isZeroBits1) {\n      result = result << 1;\n    }\n    if (isZeroBits1) {\n      result = result | temp2 >> 0x1f;\n      temp2 = temp2 << 1;\n    }\n    result = combinedBits & 0x80000000 | result;\n    combinedBits = (sumOfBits + -0x7f) - (uint)isZeroBits1;\n    isNegativeSum = SBORROW4(combinedBits,0xfd);\n    isZeroBits1 = combinedBits == 0xfd;\n    bits1Value = combinedBits - 0xfd;\n    if (combinedBits < 0xfe) {\n      result = result + combinedBits * 0x800000 + (uint)(0x7fffffff < temp2);\n      if (temp2 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZeroBits1 || (int)bits1Value < 0 != isNegativeSum) {\n    isZeroBits1 = (int)(combinedBits + 0x19) < 0;\n    if (combinedBits == 0xffffffe7 || isZeroBits1 != SCARRY4(combinedBits,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (combinedBits != 0xffffffe7 && isZeroBits1 == SCARRY4(combinedBits,0x19)) {\n      bits1Value = (result << 1) >> (-combinedBits & 0xff);\n      combinedBits = result << (combinedBits + 0x20 & 0xff);\n      bits1Value = ((uint)((result & 0x80000000) != 0) << 0x1f | bits1Value >> 1) + (uint)((byte)bits1Value & 1);\n      if ((temp2 | combinedBits << 1) == 0) {\n        bits1Value = bits1Value & ~(combinedBits >> 0x1f);\n      }\n      return bits1Value;\n    }\n    return result;\n  }\nLAB_00081a94:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_00081944": "calculate_float32_number_00081944",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "bits1",
                "param_4": "bits2",
                "lVar1": "temp1",
                "uVar2": "result",
                "uVar3": "bits1Value",
                "iVar4": "sumOfBits",
                "iVar5": "bitDifference",
                "uVar6": "temp2",
                "iVar7": "remainingBits",
                "uVar8": "combinedBits",
                "bVar9": "isZeroBits1",
                "bVar10": "isNegativeSum"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081aac": {
            "entrypoint": "0x00081aac",
            "current_name": "calculate_float_00081aac",
            "code": "\nuint calculateFloat_00081aac(uint input_1,uint input_2,undefined4 input_3,uint input_4)\n\n{\n  uint dividend;\n  uint divisor;\n  int diff;\n  uint result;\n  int temp;\n  uint output;\n  bool isZero;\n  bool isDiffZero;\n  bool carry;\n  \n  divisor = input_1 >> 0x17 & 0xff;\n  isZero = divisor == 0;\n  if (!isZero) {\n    input_4 = input_2 >> 0x17 & 0xff;\n    isZero = input_4 == 0;\n  }\n  if (!isZero) {\n    isZero = divisor == 0xff;\n  }\n  if (!isZero) {\n    isZero = input_4 == 0xff;\n  }\n  if (isZero) {\n    input_4 = input_2 >> 0x17 & 0xff;\n    output = input_1;\n    if (divisor == 0xff) {\n      if (((input_1 & 0x7fffff) != 0) || (output = input_2, input_4 == 0xff)) {\nLAB_00081aa2:\n        return output | 0x7fc00000;\n      }\n    }\n    else {\n      if (input_4 == 0xff) {\n        output = input_2;\n        if ((input_2 & 0x7fffff) == 0) {\nLAB_00081a58:\n          return (input_1 ^ input_2) & 0x80000000;\n        }\n        goto LAB_00081aa2;\n      }\n      isZero = (input_1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (input_2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = divisor == 0;\n        output = input_1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            input_1 = input_1 << 1;\n            isZero = (input_1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          divisor = divisor - 1;\n        }\n        input_1 = input_1 | output;\n        isZero = input_4 == 0;\n        output = input_2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            input_2 = input_2 << 1;\n            isZero = (input_2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          input_4 = input_4 - 1;\n        }\n        input_2 = input_2 | output;\n        goto LAB_00081ac4;\n      }\n      if ((input_1 & 0x7fffffff) == 0) {\n        if ((input_2 & 0x7fffffff) != 0) goto LAB_00081a58;\n        goto LAB_00081aa2;\n      }\n    }\n    input_1 = input_1 ^ input_2;\n  }\n  else {\nLAB_00081ac4:\n    diff = divisor - input_4;\n    if (input_2 << 9 == 0) {\n      input_1 = (input_1 ^ input_2) & 0x80000000 | input_1 & 0x7fffff;\n      carry = signedOverflow(diff,0x7f);\n      temp = diff + 0x7f;\n      isZero = temp < 0;\n      isDiffZero = temp == 0;\n      if (!isDiffZero && isZero == carry) {\n        carry = signedBorrow(0xff,temp);\n        isZero = 0xff - temp < 0;\n        isDiffZero = temp == 0xff;\n      }\n      if (!isDiffZero && isZero == carry) {\n        input_1 = input_1 | temp * 0x800000;\n      }\n      if (!isDiffZero && isZero == carry) {\n        return input_1;\n      }\n      input_1 = input_1 | 0x800000;\n      divisor = 0;\n      isDiffZero = signedBorrow(temp,1);\n      result = diff + 0x7e;\n      isZero = result == 0;\n      output = result;\n    }\n    else {\n      dividend = (input_2 << 9) >> 4 | 0x10000000;\n      divisor = (input_1 << 9) >> 4 | 0x10000000;\n      input_1 = (input_1 ^ input_2) & 0x80000000;\n      isZero = dividend <= divisor;\n      if (!isZero) {\n        divisor = divisor << 1;\n      }\n      result = diff + 0x7d + (uint)isZero;\n      output = 0x800000;\n      do {\n        if (dividend <= divisor) {\n          divisor = divisor - dividend;\n          input_1 = input_1 | output;\n        }\n        isZero = dividend >> 1 <= divisor;\n        if (isZero) {\n          divisor = divisor - (dividend >> 1);\n        }\n        if (isZero) {\n          input_1 = input_1 | output >> 1;\n        }\n        isZero = dividend >> 2 <= divisor;\n        if (isZero) {\n          divisor = divisor - (dividend >> 2);\n        }\n        if (isZero) {\n          input_1 = input_1 | output >> 2;\n        }\n        isZero = dividend >> 3 <= divisor;\n        if (isZero) {\n          divisor = divisor - (dividend >> 3);\n        }\n        if (isZero) {\n          input_1 = input_1 | output >> 3;\n        }\n        divisor = divisor * 0x10;\n        isZero = divisor == 0;\n        if (!isZero) {\n          output = output >> 4;\n          isZero = output == 0;\n        }\n      } while (!isZero);\n      isDiffZero = signedBorrow(result,0xfd);\n      isZero = result == 0xfd;\n      output = result - 0xfd;\n      if (result < 0xfe) {\n        input_1 = input_1 + result * 0x800000 + (uint)(dividend <= divisor);\n        if (divisor - dividend == 0) {\n          input_1 = input_1 & 0xfffffffe;\n        }\n        return input_1;\n      }\n    }\n    if (isZero || (int)output < 0 != isDiffZero) {\n      isZero = (int)(result + 0x19) < 0;\n      if (result == 0xffffffe7 || isZero != signedOverflow(result,0x19)) {\n        input_1 = input_1 & 0x80000000;\n      }\n      if (result == 0xffffffe7 || isZero != signedOverflow(result,0x19)) {\n        return input_1;\n      }\n      output = (input_1 << 1) >> (-result & 0xff);\n      result = input_1 << (result + 0x20 & 0xff);\n      output = ((uint)((input_1 & 0x80000000) != 0) << 0x1f | output >> 1) + (uint)((byte)output & 1);\n      if ((divisor | result << 1) == 0) {\n        output = output & ~(result >> 0x1f);\n      }\n      return output;\n    }\n  }\n  return input_1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_00081aac": "calculate_float_00081aac",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "dividend",
                "uVar2": "divisor",
                "iVar3": "diff",
                "uVar4": "result",
                "iVar5": "temp",
                "uVar6": "output",
                "bVar7": "isZero",
                "bVar8": "isDiffZero",
                "bVar9": "carry",
                "SCARRY4": "signedOverflow",
                "SBORROW4": "signedBorrow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081be4": {
            "entrypoint": "0x00081be4",
            "current_name": "calculate_result_00081be4",
            "code": "\nuint calculate_result_00081be4(uint input_value_1,uint input_value_2)\n\n{\n  bool is_negative;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined;\n  bool is_zero;\n  \n  double_input_1 = input_value_1 * 2;\n  double_input_2 = input_value_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_value_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_value_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined = double_input_1 | input_value_2 & 0x7fffffff;\n  is_zero = combined == 0;\n  if (!is_zero) {\n    combined = input_value_1 ^ input_value_2;\n    is_zero = combined == 0;\n  }\n  is_negative = -1 < (int)combined;\n  if (is_negative) {\n    input_value_1 = double_input_1 + input_value_2 * -2;\n    is_zero = input_value_1 == 0;\n  }\n  if ((is_negative && double_input_2 <= double_input_1) && !is_zero) {\n    input_value_1 = (int)input_value_2 >> 0x1f;\n  }\n  if (!is_negative || double_input_2 > double_input_1) {\n    input_value_1 = ~((int)input_value_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_value_1 = input_value_1 | 1;\n  }\n  return input_value_1;\n}\n\n",
            "renaming": {
                "FUN_00081be4": "calculate_result_00081be4",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "bVar1": "is_negative",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081bec": {
            "entrypoint": "0x00081bec",
            "current_name": "calculate_result_00081bec",
            "code": "\nuint calculateResult_00081bec(uint input1,uint input2)\n\n{\n  bool isNegative;\n  uint input1TimesTwo;\n  uint input2TimesTwo;\n  uint combinedInputs;\n  bool isCombinedZero;\n  \n  input1TimesTwo = input1 * 2;\n  input2TimesTwo = input2 * 2;\n  if (((int)input1TimesTwo >> 0x18 == -1 || (int)input2TimesTwo >> 0x18 == -1) &&\n     ((((int)input1TimesTwo >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2TimesTwo >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combinedInputs = input1TimesTwo | input2 & 0x7fffffff;\n  isCombinedZero = combinedInputs == 0;\n  if (!isCombinedZero) {\n    combinedInputs = input1 ^ input2;\n    isCombinedZero = combinedInputs == 0;\n  }\n  isNegative = -1 < (int)combinedInputs;\n  if (isNegative) {\n    input1 = input1TimesTwo + input2 * -2;\n    isCombinedZero = input1 == 0;\n  }\n  if ((isNegative && input2TimesTwo <= input1TimesTwo) && !isCombinedZero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!isNegative || input2TimesTwo > input1TimesTwo) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!isCombinedZero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_00081bec": "calculate_result_00081bec",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "isNegative",
                "uVar2": "input1TimesTwo",
                "uVar3": "input2TimesTwo",
                "uVar4": "combinedInputs",
                "bVar5": "isCombinedZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081bf4": {
            "entrypoint": "0x00081bf4",
            "current_name": "calculate_bitwise_operation_00081bf4",
            "code": "\nuint calculate_bitwise_operation_00081bf4(uint num1,uint num2)\n\n{\n  bool is_negative;\n  uint num1_shifted;\n  uint num2_shifted;\n  uint combined_nums;\n  bool is_zero;\n  \n  num1_shifted = num1 * 2;\n  num2_shifted = num2 * 2;\n  if (((int)num1_shifted >> 0x18 == -1 || (int)num2_shifted >> 0x18 == -1) &&\n     ((((int)num1_shifted >> 0x18 == -1 && ((num1 & 0x7fffff) != 0)) ||\n      (((int)num2_shifted >> 0x18 == -1 && ((num2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_nums = num1_shifted | num2 & 0x7fffffff;\n  is_zero = combined_nums == 0;\n  if (!is_zero) {\n    combined_nums = num1 ^ num2;\n    is_zero = combined_nums == 0;\n  }\n  is_negative = -1 < (int)combined_nums;\n  if (is_negative) {\n    num1 = num1_shifted + num2 * -2;\n    is_zero = num1 == 0;\n  }\n  if ((is_negative && num2_shifted <= num1_shifted) && !is_zero) {\n    num1 = (int)num2 >> 0x1f;\n  }\n  if (!is_negative || num2_shifted > num1_shifted) {\n    num1 = ~((int)num2 >> 0x1f);\n  }\n  if (!is_zero) {\n    num1 = num1 | 1;\n  }\n  return num1;\n}\n\n",
            "renaming": {
                "FUN_00081bf4": "calculate_bitwise_operation_00081bf4",
                "param_1": "num1",
                "param_2": "num2",
                "bVar1": "is_negative",
                "uVar2": "num1_shifted",
                "uVar3": "num2_shifted",
                "uVar4": "combined_nums",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c54": {
            "entrypoint": "0x00081c54",
            "current_name": "compare_floats_00081c54",
            "code": "\nvoid compareFloats_00081c54(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081c54": "compare_floats_00081c54",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c5c": {
            "entrypoint": "0x00081c5c",
            "current_name": "concatenate_integers_00081c5c",
            "code": "\nundefined8 concatenateIntegers_00081c5c(undefined4 firstInteger,undefined4 secondInteger)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondInteger,firstInteger);\n}\n\n",
            "renaming": {
                "FUN_00081c5c": "concatenate_integers_00081c5c",
                "param_1": "firstInteger",
                "param_2": "secondInteger"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c6c": {
            "entrypoint": "0x00081c6c",
            "current_name": "check_comparison_result_00081c6c",
            "code": "\nbool check_comparison_result_00081c6c(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cfcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081c6c": "check_comparison_result_00081c6c",
                "in_ZR": "comparison_result"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c80": {
            "entrypoint": "0x00081c80",
            "current_name": "check_carry_00081c80",
            "code": "\nbool check_carry_00081c80(void)\n\n{\n  char carry_flag;\n  \n  __aeabi_cfcmpeq();\n  return carry_flag == '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081c80": "check_carry_00081c80",
                "in_CY": "carry_flag"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c94": {
            "entrypoint": "0x00081c94",
            "current_name": "compare_floats_00081c94",
            "code": "\nbool compareFloats_00081c94(void)\n\n{\n  undefined isZeroFlag;\n  undefined isCarryFlag;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCarryFlag || (bool)isZeroFlag;\n}\n\n",
            "renaming": {
                "FUN_00081c94": "compare_floats_00081c94",
                "in_ZR": "isZeroFlag",
                "in_CY": "isCarryFlag"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081ca8": {
            "entrypoint": "0x00081ca8",
            "current_name": "check_conditions_00081ca8",
            "code": "\nbool check_conditions_00081ca8(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  __aeabi_cfrcmple();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_00081ca8": "check_conditions_00081ca8",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081cbc": {
            "entrypoint": "0x00081cbc",
            "current_name": "check_string_is_empty_00081cbc",
            "code": "\nbool checkStringIsEmpty_00081cbc(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cfrcmple();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081cbc": "check_string_is_empty_00081cbc",
                "in_CY": "inputChar"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081cd0": {
            "entrypoint": "0x00081cd0",
            "current_name": "extract_number_00081cd0",
            "code": "\nuint extract_number_00081cd0(uint maximum_positive)\n\n{\n  uint computed_number;\n  uint difference;\n  \n  if (maximum_positive << 1 < 0x7f000000) {\n    return 0;\n  }\n  computed_number = (maximum_positive << 1) >> 0x18;\n  difference = 0x9e - computed_number;\n  if (computed_number < 0x9f && difference != 0) {\n    computed_number = (maximum_positive << 8 | 0x80000000) >> (difference & 0xff);\n    if ((maximum_positive & 0x80000000) != 0) {\n      computed_number = -computed_number;\n    }\n    return computed_number;\n  }\n  if ((difference == 0xffffff9f) && ((maximum_positive & 0x7fffff) != 0)) {\n    return 0;\n  }\n  maximum_positive = maximum_positive & 0x80000000;\n  if (maximum_positive == 0) {\n    maximum_positive = 0x7fffffff;\n  }\n  return maximum_positive;\n}\n\n",
            "renaming": {
                "FUN_00081cd0": "extract_number_00081cd0",
                "param_1": "maximum_positive",
                "uVar1": "computed_number",
                "uVar2": "difference"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d1c": {
            "entrypoint": "0x00081d1c",
            "current_name": "calculate_shifted_value_00081d1c",
            "code": "\nuint calculate_shifted_value_00081d1c(uint input_value)\n\n{\n  uint shift_amount;\n  \n  if (((input_value & 0x80000000) != 0) || (input_value << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((input_value << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (input_value << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081d1c": "calculate_shifted_value_00081d1c",
                "param_1": "input_value",
                "uVar1": "shift_amount"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d5c": {
            "entrypoint": "0x00081d5c",
            "current_name": "register_at_exit_handler_00081d5c",
            "code": "\nvoid registerAtExitHandler_00081d5c(undefined4 handlerFunction,undefined4 handlerObject)\n\n{\n  __cxa_atexit(handlerObject,handlerFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d5c": "register_at_exit_handler_00081d5c",
                "param_1": "handlerFunction",
                "param_2": "handlerObject"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d68": {
            "entrypoint": "0x00081d68",
            "current_name": "register_exit_proc_00081d68",
            "code": "\nvoid registerExitProc_00081d68(undefined4 exitProcType,undefined4 param_1,undefined4 param_2)\n\n{\n  __register_exitproc(2,exitProcType,param_1,param_2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d68": "register_exit_proc_00081d68",
                "param_1": "exitProcType",
                "param_2": "param_1",
                "param_3": "param_2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d7c": {
            "entrypoint": "0x00081d7c",
            "current_name": "initialize_and_execute_functions_00081d7c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081d88) */\n/* WARNING: Removing unreachable block (ram,0x00081d8c) */\n/* WARNING: Removing unreachable block (ram,0x00081db8) */\n\nvoid initialize_and_execute_functions_00081d7c(void)\n\n{\n  int iteration_count;\n  code **function_pointers;\n  \n  _init();\n  function_pointers = (code **)0x85860;\n  iteration_count = 0;\n  do {\n    iteration_count = iteration_count + 1;\n    function_pointers = function_pointers + 1;\n    (**function_pointers)();\n  } while (iteration_count != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d7c": "initialize_and_execute_functions_00081d7c",
                "ppcVar2": "function_pointers",
                "iVar1": "iteration_count"
            },
            "calling": [
                "init"
            ],
            "called": [
                "register_fini",
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081dcc": {
            "entrypoint": "0x00081dcc",
            "current_name": "print_formatted_string_00081dcc",
            "code": "\nvoid print_formatted_string_00081dcc(undefined4 format_string,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 arg1_copy;\n  undefined4 arg2_copy;\n  undefined4 arg3_copy;\n  \n  arg1_copy = arg1;\n  arg2_copy = arg2;\n  arg3_copy = arg3;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),format_string,&arg1_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081dcc": "print_formatted_string_00081dcc",
                "param_1": "format_string",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_c": "arg1_copy",
                "uStack_8": "arg2_copy",
                "uStack_4": "arg3_copy"
            },
            "calling": [
                "_exit"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081df4": {
            "entrypoint": "0x00081df4",
            "current_name": "allocate_memory_00081df4",
            "code": "\nvoid * allocateMemory_00081df4(size_t memorySize)\n\n{\n  void *allocatedMemory;\n  \n  allocatedMemory = (void *)_malloc_r(_impure_ptr,memorySize);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_00081df4": "allocate_memory_00081df4",
                "__size": "memorySize",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e04": {
            "entrypoint": "0x00081e04",
            "current_name": "free_memory_00081e04",
            "code": "\nvoid freeMemory_00081e04(void *memoryBlock)\n\n{\n  _free_r(_impure_ptr,memoryBlock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e04": "free_memory_00081e04",
                "__ptr": "memoryBlock"
            },
            "calling": [
                "~String",
                "invalidate"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e14": {
            "entrypoint": "0x00081e14",
            "current_name": "allocate_memory_00081e14",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocateMemory_00081e14(undefined4 *paramPtr,uint size)\n\n{\n  undefined1 *ptr1;\n  int var1;\n  uint var2;\n  uint var3;\n  int var4;\n  uint var5;\n  uint var6;\n  uint var7;\n  undefined4 *ptr2;\n  undefined1 *ptr3;\n  undefined1 *ptr4;\n  undefined1 *ptr5;\n  uint alignedSize;\n  undefined4 *resultPtr;\n  undefined4 *tempPtr;\n  undefined1 *ptr6;\n  \n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n    if (0x10 < size) goto LAB_00081e7a;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if (((int)alignedSize < 0) || (alignedSize < size)) {\nLAB_00081e7a:\n      *paramPtr = 0xc;\n      return (int *)0x0;\n    }\n  }\n  __malloc_lock(paramPtr);\n  resultPtr = DAT_20070474;\n  if (alignedSize < 0x1f8) {\n    ptr5 = *(undefined1 **)((int)&DAT_20070470 + alignedSize);\n    if ((ptr5 != &__malloc_av_ + alignedSize) ||\n       (ptr4 = ptr5 + 8, ptr5 = *(undefined1 **)(ptr5 + 0x14), ptr4 != ptr5)) {\n      var7 = *(uint *)(ptr5 + 4);\n      var4 = *(int *)(ptr5 + 0xc);\n      alignedSize = *(uint *)(ptr5 + (var7 & 0xfffffffc) + 4);\n      var1 = *(int *)(ptr5 + 8);\n      *(int *)(var1 + 0xc) = var4;\n      *(int *)(var4 + 8) = var1;\n      *(uint *)(ptr5 + (var7 & 0xfffffffc) + 4) = alignedSize | 1;\n      __malloc_unlock(paramPtr);\n      return (int *)(ptr5 + 8);\n    }\n    var7 = (alignedSize >> 3) + 2;\n  }\n  else {\n    var7 = alignedSize >> 9;\n    if (var7 == 0) {\n      var4 = 0x7e;\n      var1 = 0x3f;\n    }\n    else if (var7 < 5) {\n      var1 = (alignedSize >> 6) + 0x38;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x15) {\n      var1 = var7 + 0x5b;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x55) {\n      var1 = (alignedSize >> 0xc) + 0x6e;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x155) {\n      var1 = (alignedSize >> 0xf) + 0x77;\n      var4 = var1 * 2;\n    }\n    else if (var7 < 0x555) {\n      var1 = (alignedSize >> 0x12) + 0x7c;\n      var4 = var1 * 2;\n    }\n    else {\n      var4 = 0xfc;\n      var1 = 0x7e;\n    }\n    for (ptr5 = (undefined1 *)(&DAT_20070470)[var4]; &__malloc_av_ + var4 * 4 != ptr5;\n        ptr5 = *(undefined1 **)(ptr5 + 0xc)) {\n      var7 = *(uint *)(ptr5 + 4) & 0xfffffffc;\n      if (0xf < (int)(var7 - alignedSize)) {\n        var1 = var1 + -1;\n        break;\n      }\n      if (-1 < (int)(var7 - alignedSize)) {\n        alignedSize = *(uint *)(ptr5 + var7 + 4);\n        var4 = *(int *)(ptr5 + 0xc);\n        var1 = *(int *)(ptr5 + 8);\n        *(int *)(var1 + 0xc) = var4;\n        *(int *)(var4 + 8) = var1;\n        *(uint *)(ptr5 + var7 + 4) = alignedSize | 1;\n        __malloc_unlock(paramPtr);\n        return (int *)(ptr5 + 8);\n      }\n    }\n    var7 = var1 + 1;\n  }\n  var2 = DAT_20070468;\n  if ((undefined1 **)DAT_20070474 != &DAT_2007046c) {\n    var2 = DAT_20070474[1];\n    var3 = var2 & 0xfffffffc;\n    var5 = var3 - alignedSize;\n    if (0xf < (int)var5) {\n      tempPtr = (undefined4 *)(alignedSize + (int)DAT_20070474);\n      DAT_20070474[1] = alignedSize | 1;\n      DAT_20070474 = tempPtr;\n      DAT_20070478 = tempPtr;\n      tempPtr[3] = &DAT_2007046c;\n      tempPtr[2] = &DAT_2007046c;\n      tempPtr[1] = var5 | 1;\n      *(uint *)((int)tempPtr + var5) = var5;\n      __malloc_unlock(paramPtr);\n      return resultPtr + 2;\n    }\n    DAT_20070478 = &DAT_2007046c;\n    DAT_20070474 = &DAT_2007046c;\n    if (-1 < (int)var5) {\n      *(uint *)((int)resultPtr + var3 + 4) = *(uint *)((int)resultPtr + var3 + 4) | 1;\n      __malloc_unlock(paramPtr);\n      return resultPtr + 2;\n    }\n    if (var3 < 0x200) {\n      var3 = var2 & 0xfffffff8;\n      var1 = *(int *)((int)&DAT_2007046c + var3);\n      var2 = 1 << ((int)(var2 >> 3) >> 2 & 0xffU) | DAT_20070468;\n      resultPtr[2] = var1;\n      resultPtr[3] = &__malloc_av_ + var3;\n      DAT_20070468 = var2;\n      *(undefined4 **)((int)&DAT_2007046c + var3) = resultPtr;\n      *(undefined4 **)(var1 + 0xc) = resultPtr;\n    }\n    else {\n      var5 = var2 >> 9;\n      if (var5 < 5) {\n        var4 = (var2 >> 6) + 0x38;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x15) {\n        var4 = var5 + 0x5b;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x55) {\n        var4 = (var2 >> 0xc) + 0x6e;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x155) {\n        var4 = (var2 >> 0xf) + 0x77;\n        var1 = var4 * 2;\n      }\n      else if (var5 < 0x555) {\n        var4 = (var2 >> 0x12) + 0x7c;\n        var1 = var4 * 2;\n      }\n      else {\n        var1 = 0xfc;\n        var4 = 0x7e;\n      }\n      ptr5 = (&DAT_2007046c)[var1];\n      if (ptr5 == &__malloc_av_ + var1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (var4 >> 2 & 0xffU);\n        ptr4 = ptr5;\n      }\n      else {\n        do {\n          ptr4 = ptr5;\n          if ((*(uint *)(ptr5 + 4) & 0xfffffffc) <= var3) break;\n          ptr5 = *(undefined1 **)(ptr5 + 8);\n          ptr4 = ptr5;\n        } while (&__malloc_av_ + var1 * 4 != ptr5);\n        ptr5 = *(undefined1 **)(ptr4 + 0xc);\n      }\n      var2 = DAT_20070468;\n      resultPtr[3] = ptr5;\n      resultPtr[2] = ptr4;\n      *(undefined4 **)(ptr5 + 8) = resultPtr;\n      *(undefined4 **)(ptr4 + 0xc) = resultPtr;\n    }\n  }\n  ptr5 = DAT_2007046c;\n  var3 = 1 << ((int)var7 >> 2 & 0xffU);\n  if (var3 <= var2) {\n    if ((var2 & var3) == 0) {\n      var7 = var7 & 0xfffffffc;\n      do {\n        var3 = var3 << 1;\n        var7 = var7 + 4;\n      } while ((var2 & var3) == 0);\n    }\n    do {\n      tempPtr = (undefined4 *)(&__malloc_av_ + var7 * 8);\n      resultPtr = tempPtr;\n      var2 = var7;\n      do {\n        for (ptr2 = (undefined4 *)resultPtr[3]; resultPtr != ptr2; ptr2 = (undefined4 *)ptr2[3])\n        {\n          var5 = ptr2[1] & 0xfffffffc;\n          var6 = var5 - alignedSize;\n          if (0xf < (int)var6) {\n            var4 = ptr2[2];\n            var1 = ptr2[3];\n            resultPtr = (undefined4 *)(alignedSize + (int)ptr2);\n            ptr2[1] = alignedSize | 1;\n            *(int *)(var4 + 0xc) = var1;\n            *(int *)(var1 + 8) = var4;\n            DAT_20070474 = resultPtr;\n            DAT_20070478 = resultPtr;\n            resultPtr[3] = &DAT_2007046c;\n            resultPtr[2] = &DAT_2007046c;\n            resultPtr[1] = var6 | 1;\n            *(uint *)((int)resultPtr + var6) = var6;\n            __malloc_unlock(paramPtr);\n            return ptr2 + 2;\n          }\n          if (-1 < (int)var6) {\n            var1 = ptr2[2];\n            var4 = ptr2[3];\n            *(uint *)((int)ptr2 + var5 + 4) = *(uint *)((int)ptr2 + var5 + 4) | 1;\n            *(int *)(var1 + 0xc) = var4;\n            *(int *)(var4 + 8) = var1;\n            __malloc_unlock(paramPtr);\n            return ptr2 + 2;\n          }\n        }\n        var2 = var2 + 1;\n        resultPtr = resultPtr + 2;\n      } while ((var2 & 3) != 0);\n      do {\n        var5 = var7 & 3;\n        resultPtr = tempPtr + -2;\n        var7 = var7 - 1;\n        if (var5 == 0) {\n          DAT_20070468 = DAT_20070468 & ~var3;\n          break;\n        }\n        tempPtr = (undefined4 *)*tempPtr;\n      } while (tempPtr == resultPtr);\n      var3 = var3 * 2;\n      if ((DAT_20070468 <= var3 && var3 - DAT_20070468 != 0) || (var7 = var2, var3 == 0))\n      break;\n      for (; (DAT_20070468 & var3) == 0; var3 = var3 << 1) {\n        var7 = var7 + 4;\n      }\n    } while( true );\n  }\n  var7 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  if ((alignedSize <= var7) && (var2 = var7 - alignedSize, ptr4 = DAT_2007046c, 0xf < (int)var2))\n  goto LAB_0008211e;\n  ptr6 = DAT_2007046c + var7;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    var2 = alignedSize + __malloc_top_pad + 0x10;\n  }\n  else {\n    var2 = alignedSize + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  ptr4 = (undefined1 *)_sbrk_r(paramPtr,var2);\n  if ((ptr4 == (undefined1 *)0xffffffff) || ((ptr4 < ptr6 && (ptr5 != &__malloc_av_))))\n  {\n    var7 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    ptr4 = DAT_2007046c;\n  }\n  else {\n    ptr3 = __malloc_current_mallinfo + var2;\n    __malloc_current_mallinfo = ptr3;\n    if ((ptr6 == ptr4) && (((uint)ptr6 & 0xfff) == 0)) {\n      *(uint *)(DAT_2007046c + 4) = var2 + var7 | 1;\n    }\n    else {\n      ptr1 = ptr4;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        ptr1 = __malloc_sbrk_base;\n        __malloc_current_mallinfo = ptr3 + ((int)ptr4 - (int)ptr6);\n      }\n      __malloc_sbrk_base = ptr1;\n      var3 = (uint)ptr4 & 7;\n      if (var3 == 0) {\n        var1 = 0x1000;\n      }\n      else {\n        ptr4 = ptr4 + (8 - var3);\n        var1 = 0x1008 - var3;\n      }\n      var1 = var1 - ((uint)(ptr4 + var2) & 0xfff);\n      var4 = _sbrk_r(paramPtr,var1);\n      if (var4 == -1) {\n        var2 = 1;\n        var1 = 0;\n      }\n      else {\n        var2 = (var4 - (int)ptr4) + var1 | 1;\n      }\n      ptr3 = __malloc_current_mallinfo + var1;\n      DAT_2007046c = ptr4;\n      __malloc_current_mallinfo = ptr3;\n      *(uint *)(ptr4 + 4) = var2;\n      if (ptr5 != &__malloc_av_) {\n        if (var7 < 0x10) {\n          *(undefined4 *)(ptr4 + 4) = 1;\n          var7 = 0;\n          goto LAB_00082108;\n        }\n        var7 = var7 - 0xc & 0xfffffff8;\n        *(uint *)(ptr5 + 4) = var7 | *(uint *)(ptr5 + 4) & 1;\n        *(undefined4 *)(ptr5 + var7 + 4) = 5;\n        *(undefined4 *)(ptr5 + var7 + 8) = 5;\n        if (0xf < var7) {\n          _free_r(paramPtr,ptr5 + 8);\n          ptr3 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < ptr3) {\n      __malloc_max_sbrked_mem = ptr3;\n    }\n    if (__malloc_max_total_mem < ptr3) {\n      __malloc_max_total_mem = ptr3;\n    }\n    var7 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    ptr4 = DAT_2007046c;\n  }\nLAB_00082108:\n  var2 = var7 - alignedSize;\n  if ((var7 < alignedSize) || ((int)var2 < 0x10)) {\n    __malloc_unlock(paramPtr);\n    return (int *)0x0;\n  }\nLAB_0008211e:\n  DAT_2007046c = ptr4 + alignedSize;\n  *(uint *)(ptr4 + 4) = alignedSize | 1;\n  *(uint *)(DAT_2007046c + 4) = var2 | 1;\n  __malloc_unlock(paramPtr);\n  return (int *)(ptr4 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081e14": "allocate_memory_00081e14",
                "param_1": "paramPtr",
                "param_2": "size",
                "puVar1": "ptr1",
                "iVar2": "var1",
                "uVar3": "var2",
                "uVar4": "var3",
                "iVar5": "var4",
                "uVar6": "var5",
                "uVar7": "var6",
                "uVar8": "var7",
                "puVar9": "ptr2",
                "puVar10": "ptr3",
                "puVar11": "ptr4",
                "puVar12": "ptr5",
                "uVar13": "alignedSize",
                "puVar14": "resultPtr",
                "puVar15": "tempPtr",
                "puVar16": "ptr6"
            },
            "calling": [
                "malloc",
                "__sfvwrite_r",
                "_realloc_r",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008234c": {
            "entrypoint": "0x0008234c",
            "current_name": "copy_memory_0008234c",
            "code": "\nvoid * copyMemory_0008234c(void *destination,void *source,size_t numBytes)\n\n{\n  undefined *destByte;\n  undefined4 *destDword;\n  undefined4 *destDwordPtr;\n  undefined *srcByte;\n  undefined4 *srcDword;\n  undefined *srcBytePtr;\n  uint remainingBytes;\n  uint bytesToCopy;\n  bool hasRemainingBytes;\n  \n  destDwordPtr = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (numBytes < 8) {\n      bytesToCopy = numBytes - 4;\n      destByte = (undefined *)destination;\n      if (3 < numBytes) {\n        do {\n          srcBytePtr = (undefined *)source;\n          srcByte = destByte;\n          hasRemainingBytes = bytesToCopy != 0;\n          bytesToCopy = bytesToCopy - 1;\n          *srcByte = *srcBytePtr;\n          destByte = srcByte + 1;\n          source = srcBytePtr + 1;\n        } while (hasRemainingBytes);\n        srcByte[1] = srcBytePtr[1];\n        srcByte[2] = srcBytePtr[2];\n        srcByte[3] = srcBytePtr[3];\n        return destination;\n      }\n      goto LAB_000823d0;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      bytesToCopy = 4 - ((uint)destination & 3);\n      numBytes = numBytes - bytesToCopy;\n      destDword = (undefined4 *)destination;\n      srcDword = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcDword = (undefined4 *)((int)source + 1);\n        destDword = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destDwordPtr = destDword;\n      source = srcDword;\n      if ((bytesToCopy & 2) != 0) {\n        source = (void *)((int)srcDword + 2);\n        destDwordPtr = (undefined4 *)((int)destDword + 2);\n        *(undefined2 *)destDword = *(undefined2 *)srcDword;\n      }\n    }\n  }\n  while (0x3f < numBytes) {\n                    /* WARNING: Load size is inaccurate */\n    *destDwordPtr = *source;\n    destDwordPtr[1] = *(undefined4 *)((int)source + 4);\n    destDwordPtr[2] = *(undefined4 *)((int)source + 8);\n    destDwordPtr[3] = *(undefined4 *)((int)source + 0xc);\n    destDwordPtr[4] = *(undefined4 *)((int)source + 0x10);\n    destDwordPtr[5] = *(undefined4 *)((int)source + 0x14);\n    destDwordPtr[6] = *(undefined4 *)((int)source + 0x18);\n    destDwordPtr[7] = *(undefined4 *)((int)source + 0x1c);\n    destDwordPtr[8] = *(undefined4 *)((int)source + 0x20);\n    destDwordPtr[9] = *(undefined4 *)((int)source + 0x24);\n    destDwordPtr[10] = *(undefined4 *)((int)source + 0x28);\n    destDwordPtr[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destDwordPtr[0xc] = *(undefined4 *)((int)source + 0x30);\n    destDwordPtr[0xd] = *(undefined4 *)((int)source + 0x34);\n    destDwordPtr[0xe] = *(undefined4 *)((int)source + 0x38);\n    destDwordPtr[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destDwordPtr = destDwordPtr + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    numBytes = numBytes - 0x40;\n  }\n  remainingBytes = numBytes - 0x10;\n  if (0xffffffcf < numBytes - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destDwordPtr = *source;\n      destDwordPtr[1] = *(undefined4 *)((int)source + 4);\n      destDwordPtr[2] = *(undefined4 *)((int)source + 8);\n      destDwordPtr[3] = *(undefined4 *)((int)source + 0xc);\n      destDwordPtr = destDwordPtr + 4;\n      source = (void *)((int)source + 0x10);\n      hasRemainingBytes = 0xf < remainingBytes;\n      remainingBytes = remainingBytes - 0x10;\n    } while (hasRemainingBytes);\n  }\n  bytesToCopy = remainingBytes + 0xc;\n  srcDword = destDwordPtr;\n  destDword = (undefined4 *)source;\n  if (0xfffffff3 < remainingBytes) {\n    do {\n      source = destDword + 1;\n      *srcDword = *destDword;\n      hasRemainingBytes = 3 < bytesToCopy;\n      bytesToCopy = bytesToCopy - 4;\n      destDwordPtr = srcDword + 1;\n      srcDword = srcDword + 1;\n      destDword = (undefined4 *)source;\n    } while (hasRemainingBytes);\n  }\nLAB_000823d0:\n  if (bytesToCopy + 4 != 0) {\n    destDword = destDwordPtr;\n    srcDword = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((bytesToCopy & 1) != 0) {\n      srcDword = (undefined4 *)((int)source + 1);\n      destDword = (undefined4 *)((int)destDwordPtr + 1);\n      *(undefined *)destDwordPtr = *source;\n    }\n    if ((bytesToCopy + 4 & 2) != 0) {\n      *(undefined2 *)destDword = *(undefined2 *)srcDword;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_0008234c": "copy_memory_0008234c",
                "__dest": "destination",
                "__src": "source",
                "__n": "numBytes",
                "puVar1": "destByte",
                "puVar2": "destDword",
                "puVar3": "destDwordPtr",
                "puVar4": "srcByte",
                "puVar5": "srcDword",
                "puVar6": "srcBytePtr",
                "uVar7": "remainingBytes",
                "uVar8": "bytesToCopy",
                "bVar9": "hasRemainingBytes"
            },
            "calling": [
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082438": {
            "entrypoint": "0x00082438",
            "current_name": "copy_memory_00082438",
            "code": "\nvoid * copyMemory_00082438(void *destination,void *source,size_t length)\n\n{\n  int iteration;\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *tempPtr;\n  undefined *endSrcPtr;\n  uint remainingLength;\n  undefined *endDestPtr;\n  uint partialLength;\n  \n  if ((source < destination) && (endSrcPtr = (undefined *)((int)source + length), destination < endSrcPtr)) {\n    endDestPtr = (undefined *)((int)destination + length);\n    iteration = length - 1;\n    if (length != 0) {\n      do {\n        endSrcPtr = endSrcPtr + -1;\n        iteration = iteration + -1;\n        endDestPtr = endDestPtr + -1;\n        *endDestPtr = *endSrcPtr;\n      } while (iteration != -1);\n    }\n    return destination;\n  }\n  destPtr = (undefined4 *)destination;\n  if (length < 0x10) {\n    if (length == 0) {\n      return destination;\n    }\n  }\n  else if ((((uint)destination | (uint)source) & 3) == 0) {\n    srcPtr = (undefined4 *)source;\n    do {\n      tempPtr = destPtr + 4;\n      *destPtr = *srcPtr;\n      destPtr[1] = srcPtr[1];\n      destPtr[2] = srcPtr[2];\n      destPtr[3] = srcPtr[3];\n      destPtr = tempPtr;\n      srcPtr = srcPtr + 4;\n    } while (tempPtr != (undefined4 *)((int)destination + (length - 0x10 & 0xfffffff0) + 0x10));\n    partialLength = length & 0xf;\n    iteration = ((length - 0x10 >> 4) + 1) * 0x10;\n    source = (void *)((int)source + iteration);\n    destPtr = (undefined4 *)(iteration + (int)destination);\n    remainingLength = partialLength;\n    srcPtr = destPtr;\n    tempPtr = (undefined4 *)source;\n    if (3 < partialLength) {\n      do {\n        remainingLength = remainingLength - 4;\n        *srcPtr = *tempPtr;\n        srcPtr = srcPtr + 1;\n        tempPtr = tempPtr + 1;\n      } while (3 < remainingLength);\n      iteration = (partialLength - 4 & 0xfffffffc) + 4;\n      destPtr = (undefined4 *)((int)destPtr + iteration);\n      source = (void *)((int)source + iteration);\n      partialLength = length & 3;\n    }\n    length = partialLength;\n    if (length == 0) {\n      return destination;\n    }\n  }\n  srcPtr = destPtr;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    tempPtr = (undefined4 *)((int)srcPtr + 1);\n    *(undefined *)srcPtr = *source;\n    source = (undefined4 *)((int)source + 1);\n    srcPtr = tempPtr;\n  } while (tempPtr != (undefined4 *)(length + (int)destPtr));\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00082438": "copy_memory_00082438",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "iVar1": "iteration",
                "puVar2": "destPtr",
                "puVar3": "srcPtr",
                "puVar4": "tempPtr",
                "puVar5": "endSrcPtr",
                "puVar7": "endDestPtr",
                "uVar6": "remainingLength",
                "uVar8": "partialLength"
            },
            "calling": [
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082504": {
            "entrypoint": "0x00082504",
            "current_name": "memset_00082504",
            "code": "\nvoid * memset_00082504(void *dest,int ch,size_t count)\n\n{\n  uint *dest_ptr;\n  uint *data_ptr;\n  uint *temp_ptr;\n  uint val;\n  uint remaining;\n  bool is_empty;\n  \n  data_ptr = (uint *)dest;\n  if (((uint)dest & 3) != 0) {\n    is_empty = count == 0;\n    dest_ptr = (uint *)dest;\n    count = count - 1;\n    if (is_empty) {\n      return dest;\n    }\n    while( true ) {\n      data_ptr = (uint *)((int)dest_ptr + 1);\n      *(char *)dest_ptr = (char)ch;\n      if (((uint)data_ptr & 3) == 0) break;\n      is_empty = count == 0;\n      dest_ptr = data_ptr;\n      count = count - 1;\n      if (is_empty) {\n        return dest;\n      }\n    }\n  }\n  if (3 < count) {\n    val = ch & 0xffU | (ch & 0xffU) << 8;\n    val = val | val << 0x10;\n    remaining = count;\n    dest_ptr = data_ptr;\n    if (0xf < count) {\n      remaining = count - 0x10;\n      do {\n        *dest_ptr = val;\n        dest_ptr[1] = val;\n        dest_ptr[2] = val;\n        dest_ptr[3] = val;\n        dest_ptr = dest_ptr + 4;\n      } while (dest_ptr != (uint *)((int)data_ptr + (remaining & 0xfffffff0) + 0x10));\n      count = count & 0xf;\n      data_ptr = data_ptr + ((remaining >> 4) + 1) * 4;\n      remaining = count;\n      dest_ptr = data_ptr;\n      if (count < 4) goto LAB_00082580;\n    }\n    do {\n      count = count - 4;\n      *data_ptr = val;\n      data_ptr = data_ptr + 1;\n    } while (3 < count);\n    data_ptr = (uint *)((int)dest_ptr + (remaining - 4 & 0xfffffffc) + 4);\n    count = remaining & 3;\n  }\nLAB_00082580:\n  if (count != 0) {\n    dest_ptr = data_ptr;\n    do {\n      temp_ptr = (uint *)((int)dest_ptr + 1);\n      *(char *)dest_ptr = (char)ch;\n      dest_ptr = temp_ptr;\n    } while (temp_ptr != (uint *)(count + (int)data_ptr));\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00082504": "memset_00082504",
                "__s": "dest",
                "__c": "ch",
                "__n": "count",
                "puVar1": "dest_ptr",
                "puVar2": "data_ptr",
                "puVar3": "temp_ptr",
                "uVar4": "val",
                "uVar5": "remaining",
                "bVar6": "is_empty"
            },
            "calling": [
                "RingBuffer",
                "__sinit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082598": {
            "entrypoint": "0x00082598",
            "current_name": "FUNC_00082598",
            "code": "\nvoid FUNC_00082598(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00082598": "FUNC_00082598"
            },
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "_malloc_trim_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008259c": {
            "entrypoint": "0x0008259c",
            "current_name": "FUNC_0008259c",
            "code": "\nvoid FUNC_0008259c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008259c": "FUNC_0008259c"
            },
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "_malloc_trim_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000825a0": {
            "entrypoint": "0x000825a0",
            "current_name": "resize_memory_000825a0",
            "code": "\nvoid * resizeMemory_000825a0(void *oldMemory,size_t newSize)\n\n{\n  void *newMemory;\n  \n  newMemory = (void *)_realloc_r(_impure_ptr,oldMemory,newSize);\n  return newMemory;\n}\n\n",
            "renaming": {
                "FUN_000825a0": "resize_memory_000825a0",
                "__ptr": "oldMemory",
                "__size": "newSize",
                "pvVar1": "newMemory"
            },
            "calling": [
                "changeBuffer"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825b0": {
            "entrypoint": "0x000825b0",
            "current_name": "allocate_memory_000825b0",
            "code": "\nint * allocateMemory_000825b0(undefined4 *param_ptr,int *ptr,uint size)\n\n{\n  int temp1;\n  int *result;\n  uint temp2;\n  size_t length;\n  uint flags;\n  int temp3;\n  int *tempPtr;\n  uint prevSize;\n  uint alignedSize;\n  int *newPtr;\n  \n  if (ptr == (int *)0x0) {\n    result = (int *)_malloc_r(param_ptr,size);\n    return result;\n  }\n  __malloc_lock();\n  flags = ptr[-1];\n  prevSize = flags & 0xfffffffc;\n  result = ptr + -2;\n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if ((int)alignedSize < 0) goto LAB_0008267c;\n  }\n  if (alignedSize < size) {\nLAB_0008267c:\n    *param_ptr = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)prevSize < (int)alignedSize) {\n    temp1 = (int)result + prevSize;\n    if (DAT_2007046c == temp1) {\n      temp2 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n      temp1 = DAT_2007046c;\n      if ((int)(alignedSize + 0x10) <= (int)(temp2 + prevSize)) {\n        DAT_2007046c = (int)result + alignedSize;\n        *(uint *)(DAT_2007046c + 4) = (temp2 + prevSize) - alignedSize | 1;\n        ptr[-1] = alignedSize | ptr[-1] & 1U;\n        __malloc_unlock(param_ptr);\n        return ptr;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp1 + 4) & 0xfffffffe) + temp1 + 4) & 1) == 0) {\n      temp2 = *(uint *)(temp1 + 4) & 0xfffffffc;\n      if ((int)alignedSize <= (int)(temp2 + prevSize)) {\n        temp3 = *(int *)(temp1 + 0xc);\n        temp1 = *(int *)(temp1 + 8);\n        *(int *)(temp1 + 0xc) = temp3;\n        *(int *)(temp3 + 8) = temp1;\n        prevSize = temp2 + prevSize;\n        goto LAB_0008268c;\n      }\n    }\n    else {\n      temp2 = 0;\n      temp1 = 0;\n    }\n    if (-1 < (int)(flags << 0x1f)) {\n      newPtr = (int *)((int)result - ptr[-2]);\n      flags = (newPtr[1] & 0xfffffffcU) + prevSize;\n      if (temp1 != 0) {\n        if (temp1 == DAT_2007046c) {\n          if ((int)(alignedSize + 0x10) <= (int)(temp2 + flags)) {\n            result = newPtr + 2;\n            temp1 = *result;\n            temp3 = newPtr[3];\n            length = prevSize - 4;\n            *(int *)(temp1 + 0xc) = temp3;\n            *(int *)(temp3 + 8) = temp1;\n            if (length < 0x25) {\n              tempPtr = result;\n              if (0x13 < length) {\n                newPtr[2] = *ptr;\n                newPtr[3] = ptr[1];\n                if (length < 0x1c) {\n                  ptr = ptr + 2;\n                  tempPtr = newPtr + 4;\n                }\n                else {\n                  newPtr[4] = ptr[2];\n                  newPtr[5] = ptr[3];\n                  if (length == 0x24) {\n                    newPtr[6] = ptr[4];\n                    tempPtr = ptr + 5;\n                    ptr = ptr + 6;\n                    newPtr[7] = *tempPtr;\n                    tempPtr = newPtr + 8;\n                  }\n                  else {\n                    ptr = ptr + 4;\n                    tempPtr = newPtr + 6;\n                  }\n                }\n              }\n              *tempPtr = *ptr;\n              tempPtr[1] = ptr[1];\n              tempPtr[2] = ptr[2];\n            }\n            else {\n              memmove(result,ptr,length);\n            }\n            DAT_2007046c = (int)newPtr + alignedSize;\n            *(uint *)(DAT_2007046c + 4) = (temp2 + flags) - alignedSize | 1;\n            newPtr[1] = alignedSize | newPtr[1] & 1U;\n            __malloc_unlock(param_ptr);\n            return result;\n          }\n        }\n        else {\n          temp2 = temp2 + flags;\n          if ((int)alignedSize <= (int)temp2) {\n            temp3 = *(int *)(temp1 + 0xc);\n            temp1 = *(int *)(temp1 + 8);\n            *(int *)(temp1 + 0xc) = temp3;\n            *(int *)(temp3 + 8) = temp1;\n            tempPtr = newPtr + 2;\n            temp1 = *tempPtr;\n            temp3 = newPtr[3];\n            length = prevSize - 4;\n            *(int *)(temp1 + 0xc) = temp3;\n            *(int *)(temp3 + 8) = temp1;\n            prevSize = temp2;\n            if (length < 0x25) {\n              result = tempPtr;\n              if (0x13 < length) {\n                newPtr[2] = *ptr;\n                newPtr[3] = ptr[1];\n                if (length < 0x1c) {\n                  ptr = ptr + 2;\n                  result = newPtr + 4;\n                }\n                else {\n                  newPtr[4] = ptr[2];\n                  newPtr[5] = ptr[3];\n                  if (length == 0x24) {\n                    newPtr[6] = ptr[4];\n                    result = ptr + 5;\n                    ptr = ptr + 6;\n                    newPtr[7] = *result;\n                    result = newPtr + 8;\n                  }\n                  else {\n                    ptr = ptr + 4;\n                    result = newPtr + 6;\n                  }\n                }\n              }\n              *result = *ptr;\n              result[1] = ptr[1];\n              result[2] = ptr[2];\n              flags = newPtr[1];\n              result = newPtr;\n              ptr = tempPtr;\n            }\n            else {\n              memmove(tempPtr,ptr,length);\n              flags = newPtr[1];\n              result = newPtr;\n              ptr = tempPtr;\n            }\n            goto LAB_0008268c;\n          }\n        }\n      }\n      if ((int)alignedSize <= (int)flags) {\n        tempPtr = newPtr + 2;\n        temp1 = *tempPtr;\n        temp3 = newPtr[3];\n        length = prevSize - 4;\n        *(int *)(temp1 + 0xc) = temp3;\n        *(int *)(temp3 + 8) = temp1;\n        prevSize = flags;\n        if (length < 0x25) {\n          result = tempPtr;\n          if (0x13 < length) {\n            newPtr[2] = *ptr;\n            newPtr[3] = ptr[1];\n            if (length < 0x1c) {\n              ptr = ptr + 2;\n              result = newPtr + 4;\n            }\n            else {\n              newPtr[4] = ptr[2];\n              newPtr[5] = ptr[3];\n              if (length == 0x24) {\n                newPtr[6] = ptr[4];\n                result = ptr + 5;\n                ptr = ptr + 6;\n                newPtr[7] = *result;\n                result = newPtr + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                result = newPtr + 6;\n              }\n            }\n          }\n          *result = *ptr;\n          result[1] = ptr[1];\n          result[2] = ptr[2];\n          flags = newPtr[1];\n          result = newPtr;\n          ptr = tempPtr;\n        }\n        else {\n          memmove(tempPtr,ptr,length);\n          flags = newPtr[1];\n          result = newPtr;\n          ptr = tempPtr;\n        }\n        goto LAB_0008268c;\n      }\n    }\n    newPtr = (int *)_malloc_r(param_ptr,size);\n    if (newPtr == (int *)0x0) goto LAB_000826a4;\n    flags = ptr[-1];\n    if (newPtr + -2 != (int *)((flags & 0xfffffffe) + (int)result)) {\n      length = prevSize - 4;\n      if (length < 0x25) {\n        result = ptr;\n        tempPtr = newPtr;\n        if (0x13 < length) {\n          *newPtr = *ptr;\n          newPtr[1] = ptr[1];\n          if (length < 0x1c) {\n            result = ptr + 2;\n            tempPtr = newPtr + 2;\n          }\n          else {\n            newPtr[2] = ptr[2];\n            newPtr[3] = ptr[3];\n            if (length == 0x24) {\n              newPtr[4] = ptr[4];\n              newPtr[5] = ptr[5];\n              result = ptr + 6;\n              tempPtr = newPtr + 6;\n            }\n            else {\n              result = ptr + 4;\n              tempPtr = newPtr + 4;\n            }\n          }\n        }\n        *tempPtr = *result;\n        tempPtr[1] = result[1];\n        tempPtr[2] = result[2];\n      }\n      else {\n        memmove(newPtr,ptr,length);\n      }\n      _free_r(param_ptr,ptr);\n      goto LAB_000826a4;\n    }\n    prevSize = prevSize + (newPtr[-1] & 0xfffffffcU);\n  }\nLAB_0008268c:\n  temp2 = prevSize - alignedSize;\n  newPtr = ptr;\n  if (temp2 < 0x10) {\n    result[1] = flags & 1 | prevSize;\n    *(uint *)((int)result + prevSize + 4) = *(uint *)((int)result + prevSize + 4) | 1;\n  }\n  else {\n    result[1] = flags & 1 | alignedSize;\n    *(uint *)((int)result + alignedSize + 4) = temp2 | 1;\n    *(uint *)((int)result + temp2 + alignedSize + 4) = *(uint *)((int)result + temp2 + alignedSize + 4) | 1;\n    _free_r(param_ptr,(int)result + alignedSize + 8);\n  }\nLAB_000826a4:\n  __malloc_unlock(param_ptr);\n  return newPtr;\n}\n\n",
            "renaming": {
                "FUN_000825b0": "allocate_memory_000825b0",
                "param_1": "param_ptr",
                "param_2": "ptr",
                "param_3": "size",
                "iVar1": "temp1",
                "piVar2": "result",
                "uVar3": "temp2",
                "sVar4": "length",
                "uVar5": "flags",
                "iVar6": "temp3",
                "piVar7": "tempPtr",
                "uVar8": "prevSize",
                "uVar9": "alignedSize",
                "piVar10": "newPtr"
            },
            "calling": [
                "__sfvwrite_r",
                "realloc"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_malloc_r",
                "_free_r",
                "memmove"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082970": {
            "entrypoint": "0x00082970",
            "current_name": "allocate_memory_00082970",
            "code": "\nvoid allocateMemory_00082970(int *errorCode,intptr_t size)\n\n{\n  void *memoryBlock;\n  \n  errno = 0;\n  memoryBlock = _sbrk(size);\n  if ((memoryBlock == (void *)0xffffffff) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00082970": "allocate_memory_00082970",
                "param_1": "errorCode",
                "param_2": "size",
                "pvVar1": "memoryBlock"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082994": {
            "entrypoint": "0x00082994",
            "current_name": "copy_and_replace_00082994",
            "code": "\nchar * copy_and_replace_00082994(char *destination,char *source)\n\n{\n  char current_char;\n  ushort current_short;\n  uint *ptr_to_next;\n  uint *ptr_to_source;\n  uint current_uint;\n  uint temp_uint;\n  uint *ptr_to_destination;\n  uint *temp_ptr;\n  char *current_ptr;\n  bool is_zero;\n  \n  current_ptr = destination;\n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      current_char = *source;\n      *current_ptr = current_char;\n      source = source + 1;\n      current_ptr = current_ptr + 1;\n    } while (current_char != '\\0');\n    return destination;\n  }\n  temp_ptr = (uint *)destination;\n  if (((uint)source & 3) != 0) {\n    ptr_to_source = (uint *)source;\n    if (((uint)source & 1) != 0) {\n      ptr_to_source = (uint *)(source + 1);\n      current_char = *source;\n      temp_ptr = (uint *)(destination + 1);\n      *destination = current_char;\n      if (current_char == '\\0') {\n        return destination;\n      }\n    }\n    source = (char *)ptr_to_source;\n    if (((uint)ptr_to_source & 2) != 0) {\n      source = (char *)((int)ptr_to_source + 2);\n      current_short = *(ushort *)ptr_to_source;\n      is_zero = (current_short & 0xff) == 0;\n      if (is_zero) {\n        *(char *)temp_ptr = (char)current_short;\n      }\n      else {\n        *(ushort *)temp_ptr = current_short;\n        is_zero = (current_short & 0xff00) == 0;\n        temp_ptr = (uint *)((int)temp_ptr + 2);\n      }\n      if (is_zero) {\n        return destination;\n      }\n    }\n  }\n  current_uint = *(uint *)source;\n  ptr_to_source = (uint *)((int)source + 4);\n  ptr_to_destination = temp_ptr;\n  if (((uint)source & 4) != 0) {\n    if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) goto LAB_000829f8;\n    ptr_to_destination = temp_ptr + 1;\n    *temp_ptr = current_uint;\n    ptr_to_source = (uint *)((int)source + 8);\n    current_uint = *(uint *)((int)source + 4);\n  }\n  while( true ) {\n    ptr_to_next = ptr_to_source + 1;\n    temp_uint = *ptr_to_source;\n    temp_ptr = ptr_to_destination;\n    if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) break;\n    temp_ptr = ptr_to_destination + 1;\n    *ptr_to_destination = current_uint;\n    current_uint = temp_uint;\n    if ((temp_uint + 0xfefefeff & ~temp_uint & 0x80808080) != 0) break;\n    ptr_to_source = ptr_to_source + 2;\n    current_uint = *ptr_to_next;\n    ptr_to_destination = ptr_to_destination + 2;\n    *temp_ptr = temp_uint;\n  }\nLAB_000829f8:\n  do {\n    *(char *)temp_ptr = (char)current_uint;\n    temp_uint = current_uint & 0xff;\n    current_uint = current_uint >> 8 | current_uint << 0x18;\n    temp_ptr = (uint *)((int)temp_ptr + 1);\n  } while (temp_uint != 0);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00082994": "copy_and_replace_00082994",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "uVar2": "current_short",
                "puVar3": "ptr_to_next",
                "puVar4": "ptr_to_source",
                "uVar5": "current_uint",
                "uVar6": "temp_uint",
                "puVar7": "ptr_to_destination",
                "puVar8": "temp_ptr",
                "pcVar9": "current_ptr",
                "bVar10": "is_zero"
            },
            "calling": [
                "copy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082a50": {
            "entrypoint": "0x00082a50",
            "current_name": "count_leading_zero_bytes_00082a50",
            "code": "\nsize_t count_leading_zero_bytes_00082a50(char *str)\n\n{\n  size_t leading_zero_count;\n  uint *ptr;\n  uint value;\n  bool is_zero;\n  \n  ptr = (uint *)((uint)str & 0xfffffffc);\n  leading_zero_count = -((uint)str & 3);\n  value = *ptr;\n  if (((uint)str & 3) != 0) {\n    value = value | bit_mask >> ((leading_zero_count + 4 & 0x1f) << 3);\n  }\n  while (ptr = ptr + 1, (value + 0xfefefeff & ~value & 0x80808080) == 0) {\n    leading_zero_count = leading_zero_count + 4;\n    value = *ptr;\n  }\n  is_zero = (value & 0xff) == 0;\n  if (!is_zero) {\n    leading_zero_count = leading_zero_count + 1;\n    is_zero = (value & 0xff00) == 0;\n  }\n  if (!is_zero) {\n    leading_zero_count = leading_zero_count + 1;\n    is_zero = (value & 0xff0000) == 0;\n  }\n  if (!is_zero) {\n    leading_zero_count = leading_zero_count + 1;\n  }\n  return leading_zero_count;\n}\n\n",
            "renaming": {
                "FUN_00082a50": "count_leading_zero_bytes_00082a50",
                "__s": "str",
                "sVar1": "leading_zero_count",
                "puVar2": "ptr",
                "uVar3": "value",
                "bVar4": "is_zero",
                "0xffffffffU": "bit_mask"
            },
            "calling": [
                "String",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082ab0": {
            "entrypoint": "0x00082ab0",
            "current_name": "send_signal_00082ab0",
            "code": "\nint sendSignal_00082ab0(processID_t processID,int signalNumber)\n\n{\n  int result;\n  \n  result = _kill_r(_impure_ptr,processID,signalNumber);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082ab0": "send_signal_00082ab0",
                "__pid": "processID",
                "__sig": "signalNumber",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082ac0": {
            "entrypoint": "0x00082ac0",
            "current_name": "write_to_file_00082ac0",
            "code": "\nint writeToFile_00082ac0(undefined4 fileDescriptor,int bufferSize,int **fileData)\n\n{\n  int *filePtr;\n  int result;\n  int *remainingData;\n  uint writeStatus;\n  undefined4 *currentChunk;\n  uint chunkSize;\n  uint fullChunks;\n  \n  if (-1 < *(int *)(bufferSize + 100) << 0x12) {\n    result = __sfvwrite_r();\n    fileData[2] = (int *)0x0;\n    fileData[1] = (int *)0x0;\n    return result;\n  }\n  remainingData = fileData[2];\n  filePtr = *fileData;\n  while (remainingData != (int *)0x0) {\n    chunkSize = filePtr[1];\n    fullChunks = chunkSize >> 2;\n    if (fullChunks != 0) {\n      currentChunk = (undefined4 *)(*filePtr + -4);\n      writeStatus = 0;\n      do {\n        currentChunk = currentChunk + 1;\n        result = _fputwc_r(fileDescriptor,*currentChunk,bufferSize);\n        writeStatus = writeStatus + 1;\n        if (result == -1) goto LAB_00082b00;\n      } while (fullChunks != writeStatus);\n      remainingData = fileData[2];\n    }\n    remainingData = (int *)((int)remainingData - (chunkSize & 0xfffffffc));\n    fileData[2] = remainingData;\n    filePtr = filePtr + 2;\n  }\n  result = 0;\nLAB_00082b00:\n  fileData[2] = (int *)0x0;\n  fileData[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082ac0": "write_to_file_00082ac0",
                "param_1": "fileDescriptor",
                "param_2": "bufferSize",
                "param_3": "fileData",
                "piVar1": "filePtr",
                "iVar2": "result",
                "piVar3": "remainingData",
                "uVar4": "writeStatus",
                "puVar5": "currentChunk",
                "uVar6": "chunkSize",
                "uVar7": "fullChunks"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_fputwc_r",
                "__sfvwrite_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082b38": {
            "entrypoint": "0x00082b38",
            "current_name": "format_string_00082b38",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint formatString_00082b38(int str,int format,int *******args,int **argptr)\n\n{\n  bool hasLengthModifier;\n  bool hasPlusFlag;\n  bool hasAlternateForm;\n  char signChar;\n  bool hasZeroPad;\n  void *ptrVar;\n  int ********strChunks;\n  int *intVar;\n  int result;\n  char charVar;\n  int *******currentChunk;\n  uint digit;\n  int **ptrVarPtr;\n  uint flags;\n  uint ch;\n  int newResult;\n  int ********tempChunks;\n  int tempResult;\n  int *******tempCurrentChunk;\n  int *paramValue;\n  int *******tempChunkPtr;\n  uint uVar;\n  int *presultSign;\n  int *******pppppppiVar24;\n  undefined4 tempDiv;\n  int ********outStr;\n  bool valueIsNegative;\n  longlong quotient;\n  int *******maxDecimalDigits;\n  int *******remainingArgs;\n  int **argptrStart;\n  int totalLength;\n  char *percentChar;\n  char paddingChar;\n  undefined alternateChar;\n  undefined precisionChar;\n  int ********resultChunks;\n  int chunkIndex;\n  int *******totalChunks;\n  undefined zeroPadChar;\n  char zeroChar;\n  undefined firstChar;\n  undefined tempStrArray [4];\n  int *******tempStrArrayArray [16];\n  \n  if ((str != 0) && (*(int *)(str + 0x38) == 0)) {\n    outStrinit();\n  }\n  flags = (uint)*(ushort *)(format + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(format + 0xc) << 0x12)) {\n    flags = flags | 0x2000;\n    *(short *)(format + 0xc) = (short)flags;\n    *(uint *)(format + 100) = *(uint *)(format + 100) & 0xffffdfff;\n  }\n  if (((int)(flags << 0x1c) < 0) && (*(int *)(format + 0x10) != 0)) {\n    if ((flags & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  else {\n    result = outStrwsetup_r(str,format);\n    if (result != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(format + 0xc) & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  if (-1 < *(short *)(format + 0xe)) {\n    result = outStrbprintf(str,format,args,argptr);\n    return result;\n  }\nLAB_00082b8a:\n  percentChar = (char *)0x0;\n  totalChunks = (int *******)0x0;\n  chunkIndex = 0;\n  totalLength = 0;\n  strChunks = (int ********)tempStrArray;\n  argptrStart = argptr;\n  resultChunks = (int ********)tempStrArray;\nLAB_00082b9e:\n  currentChunk = args;\n  if ((*(char *)args != '\\0') && (*(char *)args != '%')) {\n    do {\n      currentChunk = (int *******)((int)currentChunk + 1);\n      if (*(char *)currentChunk == '\\0') break;\n    } while (*(char *)currentChunk != '%');\n    tempChunkPtr = (int *******)((int)currentChunk - (int)args);\n    if (tempChunkPtr != (int *******)0x0) {\n      chunkIndex = chunkIndex + 1;\n      totalChunks = (int *******)((int)totalChunks + (int)tempChunkPtr);\n      *strChunks = args;\n      strChunks[1] = tempChunkPtr;\n      if (chunkIndex < 8) {\n        strChunks = strChunks + 2;\n      }\n      else {\n        if (totalChunks == (int *******)0x0) {\n          totalLength = totalLength + (int)tempChunkPtr;\n          chunkIndex = 0;\n          strChunks = (int ********)tempStrArray;\n          goto LAB_00082bee;\n        }\n        result = outStrprint_r_part_0(str,format,&resultChunks);\n        strChunks = (int ********)tempStrArray;\n        if (result != 0) goto LAB_000833de;\n      }\n      totalLength = totalLength + (int)tempChunkPtr;\n    }\n  }\nLAB_00082bee:\n  if (*(char *)currentChunk != '\\0') {\n    paddingChar = '\\0';\n    ch = (uint)*(byte *)((int)currentChunk + 1);\n    flags = 0;\n    hasZeroPad = false;\n    hasPlusFlag = false;\n    hasLengthModifier = false;\n    hasAlternateForm = false;\n    valueIsNegative = false;\n    tempChunkPtr = (int *******)0x0;\n    remainingArgs = (int *******)0xffffffff;\n    args = (int *******)((int)currentChunk + 1);\nLAB_00082c12:\n    args = (int *******)((int)args + 1);\nLAB_00082c16:\n    switch(ch) {\n    case 0x20:\n      goto switchD_00082c20_caseD_20;\n    default:\n      if (ch != 0) {\n        maxDecimalDigits = (int *******)0x1;\n        remainingArgs = (int *******)0x1;\n        outStr = (int ********)&zeroPadChar;\n        zeroPadChar = (char)ch;\n        goto LAB_00083012;\n      }\n      goto LAB_000833d0;\n    case 0x23:\n      hasAlternateForm = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082c12;\n    case 0x2a:\n      tempChunkPtr = (int *******)*argptrStart;\n      argptrStart = argptrStart + 1;\n      if ((int)tempChunkPtr < 0) {\n        tempChunkPtr = (int *******)-(int)tempChunkPtr;\n        goto switchD_00082c20_caseD_2d;\n      }\n      ch = (uint)*(byte *)args;\n      goto LAB_00082c12;\n    case 0x2b:\n      ch = (uint)*(byte *)args;\n      paddingChar = '+';\n      goto LAB_00082c12;\n    case 0x2d:\nswitchD_00082c20_caseD_2d:\n      flags = flags | 4;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082c12;\n    case 0x2e:\n      ch = (uint)*(byte *)args;\n      currentChunk = (int *******)((int)args + 1);\n      if (ch == 0x2a) {\n        ch = (uint)*(byte *)((int)args + 1);\n        remainingArgs = (int *******)*argptrStart;\n        argptrStart = argptrStart + 1;\n        args = currentChunk;\n        if ((int)remainingArgs < 0) {\n          remainingArgs = (int *******)0xffffffff;\n        }\n        goto LAB_00082c12;\n      }\n      digit = ch - 0x30;\n      if (digit < 10) {\n        uVar = 0;\n        do {\n          args = (int *******)((int)currentChunk + 1);\n          ch = (uint)*(byte *)currentChunk;\n          uVar = digit + uVar * 10;\n          digit = ch - 0x30;\n          currentChunk = args;\n        } while (digit < 10);\n        remainingArgs = (int *******)(uVar | (int)uVar >> 0x1f);\n      }\n      else {\n        remainingArgs = (int *******)0x0;\n        args = currentChunk;\n      }\n      goto LAB_00082c16;\n    case 0x30:\n      flags = flags | 0x80;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082c12;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082c20_caseD_31;\n    case 0x44:\n      hasPlusFlag = true;\n      if (hasLengthModifier == false) goto LAB_00083028;\nLAB_00082e98:\n      argptrStart = (int **)((int)argptrStart + 7U & 0xfffffff8);\n      paramValue = *argptrStart;\n      presultSign = argptrStart[1];\n      argptrStart = argptrStart + 2;\n      goto LAB_00082eac;\n    case 0x4f:\n      hasPlusFlag = true;\n      if (hasLengthModifier != false) goto LAB_00082d42;\nLAB_00082f2a:\n      result = (uint)hasPlusFlag << 4;\n      newResult = (uint)hasLengthModifier << 5;\n      if ((hasPlusFlag == 0) && (newResult = (uint)valueIsNegative << 6, valueIsNegative != 0)) {\n        paramValue = (int *)(uint)*(ushort *)argptrStart;\n        argptrStart = argptrStart + 1;\n        presultSign = (int *)0x0;\n      }\n      else {\n        result = newResult;\n        paramValue = *argptrStart;\n        argptrStart = argptrStart + 1;\n        presultSign = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      hasPlusFlag = true;\n      if (hasLengthModifier != false) goto LAB_00082e62;\nLAB_00082f7c:\n      if ((hasPlusFlag) || (valueIsNegative == false)) {\n        result = 1;\n        paramValue = *argptrStart;\n        argptrStart = argptrStart + 1;\n        presultSign = (int *)0x0;\n      }\n      else {\n        presultSign = (int *)0x0;\n        paramValue = (int *)(uint)*(ushort *)argptrStart;\n        argptrStart = argptrStart + 1;\n        result = 1;\n      }\n      break;\n    case 0x58:\n      percentChar = \"0123456789ABCDEF\";\n      if (hasLengthModifier == false) goto LAB_00083196;\nLAB_00082fb6:\n      ptrVarPtr = (int **)((int)argptrStart + 7U & 0xfffffff8);\n      argptrStart = ptrVarPtr + 2;\n      paramValue = *ptrVarPtr;\n      presultSign = ptrVarPtr[1];\n      goto LAB_00082fca;\n    case 99:\n      paramValue = *argptrStart;\n      argptrStart = argptrStart + 1;\n      maxDecimalDigits = (int *******)0x1;\n      zeroPadChar = SUB41(paramValue,0);\n      remainingArgs = (int *******)0x1;\n      outStr = (int ********)&zeroPadChar;\n      goto LAB_00083012;\n    case 100:\n    case 0x69:\n      if (hasLengthModifier != false) goto LAB_00082e98;\nLAB_00083028:\n      if ((hasPlusFlag == false) && (valueIsNegative != false)) {\n        paramValue = (int *)(int)*(short *)argptrStart;\n        argptrStart = argptrStart + 1;\n        presultSign = (int *)((int)paramValue >> 0x1f);\n      }\n      else {\n        paramValue = *argptrStart;\n        argptrStart = argptrStart + 1;\n        presultSign = (int *)((int)paramValue >> 0x1f);\n      }\nLAB_00082eac:\n      if ((int)presultSign < 0) {\n        valueIsNegative = paramValue != (int *)0x0;\n        paramValue = (int *)-(int)paramValue;\n        presultSign = (int *)(-(int)presultSign - (uint)valueIsNegative);\n        paddingChar = '-';\n        signChar = '-';\n        result = 1;\n        goto LAB_00082d6a;\n      }\n      if (-1 < (int)remainingArgs) {\n        flags = flags & 0xffffff7f;\n      }\n      hasZeroPad = false;\n      ch = (uint)paramValue | (uint)presultSign;\n      result = 1;\n      signChar = paddingChar;\n      goto joined_r0x00082d78;\n    case 0x68:\n      valueIsNegative = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082c12;\n    case 0x6c:\n      ch = (uint)*(byte *)args;\n      if (ch == 0x6c) {\n        hasLengthModifier = true;\n        ch = (uint)*(byte *)((int)args + 1);\n        args = (int *******)((int)args + 1);\n      }\n      else {\n        hasPlusFlag = true;\n      }\n      goto LAB_00082c12;\n    case 0x6e:\n      if (hasLengthModifier == false) {\n        if (hasPlusFlag == false) {\n          if (valueIsNegative) {\n            paramValue = *argptrStart;\n            argptrStart = argptrStart + 1;\n            *(short *)paramValue = (short)totalLength;\n          }\n          else {\n            paramValue = *argptrStart;\n            argptrStart = argptrStart + 1;\n            *paramValue = totalLength;\n          }\n        }\n        else {\n          paramValue = *argptrStart;\n          argptrStart = argptrStart + 1;\n          *paramValue = totalLength;\n        }\n      }\n      else {\n        paramValue = *argptrStart;\n        argptrStart = argptrStart + 1;\n        *paramValue = totalLength;\n        paramValue[1] = totalLength >> 0x1f;\n      }\n      goto LAB_00082b9e;\n    case 0x6f:\n      if (hasLengthModifier == false) goto LAB_00082f2a;\nLAB_00082d42:\n      ptrVarPtr = (int **)((int)argptrStart + 7U & 0xfffffff8);\n      argptrStart = ptrVarPtr + 2;\n      paramValue = *ptrVarPtr;\n      presultSign = ptrVarPtr[1];\n      result = 0;\n      break;\n    case 0x70:\n      paramValue = *argptrStart;\n      argptrStart = argptrStart + 1;\n      precisionChar = 0x78;\n      hasZeroPad = true;\n      presultSign = (int *)0x0;\n      alternateChar = 0x30;\n      percentChar = \"0123456789abcdef\";\n      result = 2;\n      break;\n    case 0x71:\n      hasLengthModifier = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082c12;\n    case 0x73:\n      outStr = (int ********)*argptrStart;\n      paddingChar = '\\0';\n      argptrStart = argptrStart + 1;\n      if (outStr != (int ********)0x0) {\n        if ((int)remainingArgs < 0) {\n          remainingArgs = (int *******)strlen((char *)outStr);\n          currentChunk = (int *******)0x0;\n          signChar = paddingChar;\n        }\n        else {\n          ptrVar = memchr(outStr,0,(size_t)remainingArgs);\n          signChar = paddingChar;\n          if (ptrVar == (void *)0x0) {\n            currentChunk = (int *******)0x0;\n          }\n          else {\n            tempCurrentChunk = (int *******)((int)ptrVar - (int)outStr);\n            if ((int)remainingArgs <= (int)(int *******)((int)ptrVar - (int)outStr)) {\n              tempCurrentChunk = remainingArgs;\n            }\n            currentChunk = (int *******)0x0;\n            remainingArgs = tempCurrentChunk;\n          }\n        }\n        goto LAB_00082da0;\n      }\n      if ((int *******)0x5 < remainingArgs) {\n        remainingArgs = (int *******)0x6;\n      }\n      maxDecimalDigits = (int *******)((uint)remainingArgs & ~((int)remainingArgs >> 0x1f));\n      outStr = (int ********)&UNK_00085840;\nLAB_00083012:\n      paddingChar = '\\0';\n      currentChunk = (int *******)0x0;\n      goto LAB_00082dba;\n    case 0x75:\n      if (!hasLengthModifier) goto LAB_00082f7c;\nLAB_00082e62:\n      ptrVarPtr = (int **)((int)argptrStart + 7U & 0xfffffff8);\n      argptrStart = ptrVarPtr + 2;\n      paramValue = *ptrVarPtr;\n      presultSign = ptrVarPtr[1];\n      result = 1;\n      break;\n    case 0x78:\n      percentChar = \"0123456789abcdef\";\n      if (hasLengthModifier != false) goto LAB_00082fb6;\nLAB_00083196:\n      if ((hasPlusFlag == false) && (valueIsNegative != false)) {\n        presultSign = (int *)0x0;\n        paramValue = (int *)(uint)*(ushort *)argptrStart;\n        argptrStart = argptrStart + 1;\n      }\n      else {\n        paramValue = *argptrStart;\n        argptrStart = argptrStart + 1;\n        presultSign = (int *)0x0;\n      }\nLAB_00082fca:\n      if ((hasAlternateForm) && (((uint)paramValue | (uint)presultSign) != 0)) {\n        hasZeroPad = true;\n        alternateChar = 0x30;\n        result = 2;\n        precisionChar = (char)ch;\n      }\n      else {\n        result = 2;\n      }\n    }\n    paddingChar = '\\0';\n    signChar = '\\0';\nLAB_00082d6a:\n    if (-1 < (int)remainingArgs) {\n      flags = flags & 0xffffff7f;\n    }\n    ch = (uint)paramValue | (uint)presultSign;\njoined_r0x00082d78:\n    quotient = CONCAT44(presultSign,paramValue);\n    currentChunk = remainingArgs;\n    if ((ch == 0) && (remainingArgs == (int *******)0x0)) {\n      outStr = (int ********)tempStrArray;\n      if ((result != 0) || (!hasAlternateForm)) goto LAB_00082da0;\n      outStr = (int ********)(&zeroChar + 1);\n      firstChar = '0';\n      goto LAB_00082d9a;\n    }\n    if (result == 1) {\n      if (presultSign != (int *)0x0 || (int *)0x9 < paramValue) {\n        tempChunks = (int ********)(&zeroChar + 1);\n        do {\n          outStr = tempChunks;\n          tempDiv = (undefined4)((ulonglong)quotient >> 0x20);\n          charVar = '\\n';\n          __aeabi_uldivmod((int)quotient,tempDiv,10,0);\n          *(char *)outStr = charVar + '0';\n          quotient = __aeabi_uldivmod((int)quotient,tempDiv,10,0);\n          tempChunks = (int ********)((int)outStr + -1);\n        } while (quotient != 0);\n        remainingArgs = (int *******)((int)tempStrArray - (int)outStr);\n        goto LAB_00082da0;\n      }\n      firstChar = (char)paramValue + '0';\n      outStr = (int ********)(&zeroChar + 1);\n      goto LAB_0008351e;\n    }\n    tempChunks = (int ********)(&zeroChar + 1);\n    if (result != 2) goto LAB_0008337e;\n    do {\n      outStr = tempChunks;\n      ch = (uint)paramValue & 0xf;\n      paramValue = (int *)((uint)paramValue >> 4 | (int)presultSign << 0x1c);\n      presultSign = (int *)((uint)presultSign >> 4);\n      *(char *)outStr = percentChar[ch];\n      tempChunks = (int ********)((int)outStr + -1);\n    } while (((uint)paramValue | (uint)presultSign) != 0);\n    remainingArgs = (int *******)((int)tempStrArray - (int)outStr);\n    goto LAB_00082da0;\n  }\nLAB_000833d0:\n  if (totalChunks != (int *******)0x0) {\n    outStrprint_r_part_0(str,format,&resultChunks);\n  }\nLAB_000833de:\n  if ((int)((uint)*(ushort *)(format + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return totalLength;\nLAB_0008337e:\n  do {\n    outStr = tempChunks;\n    intVar = (int *)((uint)paramValue >> 3 | (int)presultSign << 0x1d);\n    presultSign = (int *)((uint)presultSign >> 3);\n    result = ((uint)paramValue & 7) + 0x30;\n    *(char *)outStr = (char)result;\n    tempChunks = (int ********)((int)outStr + -1);\n    paramValue = intVar;\n  } while (((uint)intVar | (uint)presultSign) != 0);\n  if (hasAlternateForm) {\n    if (result == 0x30) {\nLAB_00082d9a:\n      remainingArgs = (int *******)((int)tempStrArray - (int)outStr);\n    }\n    else {\n      *(undefined *)((int)outStr + -1) = 0x30;\n      outStr = tempChunks;\n      remainingArgs = (int *******)((int)tempStrArray - (int)tempChunks);\n    }\n  }\n  else {\nLAB_0008351e:\n    remainingArgs = (int *******)((int)tempStrArray - (int)outStr);\n  }\nLAB_00082da0:\n  maxDecimalDigits = remainingArgs;\n  if ((int)remainingArgs < (int)currentChunk) {\n    maxDecimalDigits = currentChunk;\n  }\n  if (signChar != '\\0') {\n    maxDecimalDigits = (int *******)((int)maxDecimalDigits + 1);\n  }\nLAB_00082dba:\n  if (hasZeroPad) {\n    maxDecimalDigits = (int *******)((int)maxDecimalDigits + 2);\n  }\n  if ((flags == 0) &&\n     (tempCurrentChunk = (int *******)((int)tempChunkPtr - (int)maxDecimalDigits), 0 < (int)tempCurrentChunk)) {\n    if ((int)tempCurrentChunk < 0x11) {\n      chunkIndex = chunkIndex + 1;\n    }\n    else {\n      do {\n        pppppppiVar24 = tempCurrentChunk;\n        result = chunkIndex + 1;\n        totalChunks = totalChunks + 4;\n        *strChunks = (int *******)0x85808;\n        strChunks[1] = (int *******)0x10;\n        if (result < 8) {\n          newResult = chunkIndex + 2;\n          strChunks = strChunks + 2;\n          chunkIndex = result;\n        }\n        else if (totalChunks == (int *******)0x0) {\n          newResult = 1;\n          strChunks = (int ********)tempStrArray;\n          chunkIndex = 0;\n        }\n        else {\n          chunkIndex = result;\n          result = outStrprint_r_part_0(str,format,&resultChunks);\n          if (result != 0) goto LAB_000833de;\n          newResult = chunkIndex + 1;\n          strChunks = (int ********)tempStrArray;\n        }\n        tempCurrentChunk = pppppppiVar24 + -4;\n      } while (0x10 < (int)tempCurrentChunk);\n      tempCurrentChunk = pppppppiVar24 + -4;\n      chunkIndex = newResult;\n    }\n    totalChunks = (int *******)((int)totalChunks + (int)tempCurrentChunk);\n    *strChunks = (int *******)0x85808;\n    strChunks[1] = tempCurrentChunk;\n    if (chunkIndex < 8) {\n      result = chunkIndex + 1;\n      strChunks = strChunks + 2;\n    }\n    else if (totalChunks == (int *******)0x0) {\n      result = 1;\n      chunkIndex = 0;\n      strChunks = (int ********)tempStrArray;\n    }\n    else {\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n      result = chunkIndex + 1;\n      strChunks = (int ********)tempStrArray;\n    }\n  }\n  else {\n    result = chunkIndex + 1;\n  }\n  newResult = result;\n  if (paddingChar != '\\0') {\n    totalChunks = (int *******)((int)totalChunks + 1);\n    newResult = 1;\n    *strChunks = (int *******)&paddingChar;\n    strChunks[1] = (int *******)0x1;\n    chunkIndex = result;\n    if (result < 8) {\n      newResult = result + 1;\n      strChunks = strChunks + 2;\n    }\n    else if (totalChunks == (int *******)0x0) {\n      chunkIndex = 0;\n      strChunks = (int ********)tempStrArray;\n    }\n    else {\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n      newResult = chunkIndex + 1;\n      strChunks = (int ********)tempStrArray;\n    }\n  }\n  result = newResult;\n  tempResult = chunkIndex;\n  if (hasZeroPad) {\n    totalChunks = (int *******)((int)totalChunks + 2);\n    *strChunks = (int *******)&alternateChar;\n    strChunks[1] = (int *******)0x2;\n    if (newResult < 8) {\n      result = newResult + 1;\n      tempResult = newResult;\n      strChunks = strChunks + 2;\n    }\n    else if (totalChunks == (int *******)0x0) {\n      result = 1;\n      tempResult = 0;\n      strChunks = (int ********)tempStrArray;\n    }\n    else {\n      chunkIndex = newResult;\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n      result = chunkIndex + 1;\n      tempResult = chunkIndex;\n      strChunks = (int ********)tempStrArray;\n    }\n  }\n  chunkIndex = tempResult;\n  if ((flags == 0x80) &&\n     (tempCurrentChunk = (int *******)((int)tempChunkPtr - (int)maxDecimalDigits), 0 < (int)tempCurrentChunk)) {\n    if (0x10 < (int)tempCurrentChunk) {\n      do {\n        while( true ) {\n          pppppppiVar24 = tempCurrentChunk;\n          chunkIndex = tempResult + 1;\n          totalChunks = totalChunks + 4;\n          *strChunks = (int *******)&zeroes_6718;\n          strChunks[1] = (int *******)0x10;\n          if (7 < chunkIndex) break;\n          result = tempResult + 2;\n          strChunks = strChunks + 2;\nLAB_0008348e:\n          tempResult = chunkIndex;\n          tempCurrentChunk = pppppppiVar24 + -4;\n          if ((int)(pppppppiVar24 + -4) < 0x11) goto LAB_000834b4;\n        }\n        if (totalChunks != (int *******)0x0) {\n          result = outStrprint_r_part_0(str,format,&resultChunks);\n          if (result == 0) {\n            result = chunkIndex + 1;\n            strChunks = (int ********)tempStrArray;\n            goto LAB_0008348e;\n          }\n          goto LAB_000833de;\n        }\n        result = 1;\n        tempResult = 0;\n        tempCurrentChunk = pppppppiVar24 + -4;\n        strChunks = (int ********)tempStrArray;\n      } while (0x10 < (int)(pppppppiVar24 + -4));\nLAB_000834b4:\n      tempCurrentChunk = pppppppiVar24 + -4;\n    }\n    totalChunks = (int *******)((int)totalChunks + (int)tempCurrentChunk);\n    *strChunks = (int *******)&zeroes_6718;\n    strChunks[1] = tempCurrentChunk;\n    chunkIndex = result;\n    if (result < 8) {\n      result = result + 1;\n      strChunks = strChunks + 2;\n    }\n    else if (totalChunks == (int *******)0x0) {\n      result = 1;\n      chunkIndex = 0;\n      strChunks = (int ********)tempStrArray;\n    }\n    else {\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n      result = chunkIndex + 1;\n      strChunks = (int ********)tempStrArray;\n    }\n  }\n  currentChunk = (int *******)((int)currentChunk - (int)remainingArgs);\n  tempChunks = (int ********)tempStrArray;\n  if ((int)currentChunk < 1) {\nLAB_000832c6:\n    totalChunks = (int *******)((int)totalChunks + (int)remainingArgs);\n    *strChunks = (int *******)outStr;\n    strChunks[1] = remainingArgs;\n    remainingArgs = totalChunks;\n    chunkIndex = result;\n    if (result < 8) goto LAB_0008345a;\n    if (totalChunks == (int *******)0x0) {\n      chunkIndex = 0;\n    }\n    else {\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n    }\n  }\n  else {\n    newResult = chunkIndex;\n    if (0x10 < (int)currentChunk) {\n      do {\n        while( true ) {\n          tempCurrentChunk = currentChunk;\n          chunkIndex = newResult + 1;\n          totalChunks = totalChunks + 4;\n          *strChunks = (int *******)&zeroes_6718;\n          strChunks[1] = (int *******)0x10;\n          if (7 < chunkIndex) break;\n          result = newResult + 2;\n          strChunks = strChunks + 2;\nLAB_00083282:\n          newResult = chunkIndex;\n          currentChunk = tempCurrentChunk + -4;\n          if ((int)(tempCurrentChunk + -4) < 0x11) goto LAB_000832aa;\n        }\n        if (totalChunks != (int *******)0x0) {\n          result = outStrprint_r_part_0(str,format,&resultChunks);\n          if (result == 0) {\n            result = chunkIndex + 1;\n            strChunks = (int ********)tempStrArray;\n            goto LAB_00083282;\n          }\n          goto LAB_000833de;\n        }\n        result = 1;\n        strChunks = (int ********)tempStrArray;\n        newResult = 0;\n        currentChunk = tempCurrentChunk + -4;\n      } while (0x10 < (int)(tempCurrentChunk + -4));\nLAB_000832aa:\n      currentChunk = tempCurrentChunk + -4;\n    }\n    totalChunks = (int *******)((int)totalChunks + (int)currentChunk);\n    *strChunks = (int *******)&zeroes_6718;\n    strChunks[1] = currentChunk;\n    if (result < 8) {\n      result = result + 1;\n      strChunks = strChunks + 2;\n      goto LAB_000832c6;\n    }\n    if (totalChunks != (int *******)0x0) {\n      chunkIndex = result;\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n      result = chunkIndex + 1;\n      strChunks = (int ********)tempStrArray;\n      goto LAB_000832c6;\n    }\n    tempStrArrayArray[0] = remainingArgs;\n    chunkIndex = 1;\n    strChunks = (int ********)tempStrArray;\n    tempStrArray = (undefined  [4])outStr;\nLAB_0008345a:\n    tempChunks = strChunks + 2;\n    totalChunks = remainingArgs;\n  }\n  if (((flags & 4) != 0) &&\n     (currentChunk = (int *******)((int)tempChunkPtr - (int)maxDecimalDigits), 0 < (int)currentChunk)) {\n    result = chunkIndex;\n    if ((int)currentChunk < 0x11) {\n      newResult = chunkIndex + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          chunkIndex = result + 1;\n          totalChunks = totalChunks + 4;\n          *tempChunks = (int *******)0x85808;\n          tempChunks[1] = (int *******)0x10;\n          if (7 < chunkIndex) break;\n          newResult = result + 2;\n          tempChunks = tempChunks + 2;\nLAB_00083316:\n          currentChunk = currentChunk + -4;\n          result = chunkIndex;\n          if ((int)currentChunk < 0x11) goto LAB_0008333e;\n        }\n        if (totalChunks != (int *******)0x0) {\n          result = outStrprint_r_part_0(str,format,&resultChunks);\n          if (result == 0) {\n            newResult = chunkIndex + 1;\n            tempChunks = (int ********)tempStrArray;\n            goto LAB_00083316;\n          }\n          goto LAB_000833de;\n        }\n        currentChunk = currentChunk + -4;\n        newResult = 1;\n        result = 0;\n        tempChunks = (int ********)tempStrArray;\n      } while (0x10 < (int)currentChunk);\n    }\nLAB_0008333e:\n    totalChunks = (int *******)((int)totalChunks + (int)currentChunk);\n    *tempChunks = (int *******)0x85808;\n    tempChunks[1] = currentChunk;\n    chunkIndex = newResult;\n    if (7 < newResult) {\n      if (totalChunks == (int *******)0x0) {\n        if ((int)maxDecimalDigits < (int)tempChunkPtr) {\n          maxDecimalDigits = tempChunkPtr;\n        }\n        totalLength = totalLength + (int)maxDecimalDigits;\n        goto LAB_00083422;\n      }\n      result = outStrprint_r_part_0(str,format,&resultChunks);\n      if (result != 0) goto LAB_000833de;\n    }\n  }\n  if ((int)maxDecimalDigits < (int)tempChunkPtr) {\n    maxDecimalDigits = tempChunkPtr;\n  }\n  totalLength = totalLength + (int)maxDecimalDigits;\n  if ((totalChunks != (int *******)0x0) &&\n     (result = outStrprint_r_part_0(str,format,&resultChunks), result != 0)) goto LAB_000833de;\nLAB_00083422:\n  chunkIndex = 0;\n  strChunks = (int ********)tempStrArray;\n  goto LAB_00082b9e;\nswitchD_00082c20_caseD_31:\n  digit = ch - 0x30;\n  tempChunkPtr = (int *******)0x0;\n  currentChunk = args;\n  do {\n    args = (int *******)((int)currentChunk + 1);\n    ch = (uint)*(byte *)currentChunk;\n    tempChunkPtr = (int *******)(digit + (int)tempChunkPtr * 10);\n    digit = ch - 0x30;\n    currentChunk = args;\n  } while (digit < 10);\n  goto LAB_00082c16;\nswitchD_00082c20_caseD_20:\n  ch = (uint)*(byte *)args;\n  if (paddingChar == '\\0') {\n    paddingChar = ' ';\n  }\n  goto LAB_00082c12;\n}\n\n",
            "renaming": {
                "FUN_00082b38": "format_string_00082b38",
                "param_1": "str",
                "param_2": "format",
                "param_3": "args",
                "param_4": "argptr",
                "bVar1": "hasLengthModifier",
                "bVar2": "hasPlusFlag",
                "bVar3": "hasAlternateForm",
                "cVar4": "signChar",
                "bVar5": "hasZeroPad",
                "pvVar6": "ptrVar",
                "ppppppppiVar7": "strChunks",
                "piVar8": "intVar",
                "iVar9": "result",
                "cVar10": "charVar",
                "pppppppiVar11": "currentChunk",
                "uVar12": "digit",
                "ppiVar13": "ptrVarPtr",
                "uVar14": "flags",
                "uVar15": "ch",
                "uVar22": "uVar",
                "iVar16": "newResult",
                "ppppppppiVar17": "tempChunks",
                "iVar18": "tempResult",
                "pppppppiVar19": "tempCurrentChunk",
                "piVar20": "paramValue",
                "iVar23": "resultSign",
                "pppppppiVar21": "tempChunkPtr",
                "uVar25": "tempDiv",
                "__s": "outStr",
                "bVar26": "valueIsNegative",
                "lVar27": "quotient",
                "local_dc": "maxDecimalDigits",
                "local_d4": "remainingArgs",
                "local_c8": "argptrStart",
                "local_c4": "totalLength",
                "local_c0": "percentChar",
                "local_a1": "paddingChar",
                "local_a0": "alternateChar",
                "local_9f": "precisionChar",
                "local_9c": "resultChunks",
                "local_98": "chunkIndex",
                "local_94": "totalChunks",
                "local_90": "zeroPadChar",
                "cStack_6a": "zeroChar",
                "local_69": "firstChar",
                "local_68": "tempStrArray",
                "local_64": "tempStrArrayArray"
            },
            "calling": [
                "__sbprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__sbprintf",
                "__swsetup_r",
                "__sprint_r.part.0",
                "strlen",
                "__sinit",
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008378c": {
            "entrypoint": "0x0008378c",
            "current_name": "print_formatted_string_0008378c",
            "code": "\nint printFormattedString_0008378c(undefined4 buffer,int data)\n\n{\n  int printResult;\n  int flushResult;\n  undefined *localBuffers [2];\n  undefined4 bufferSize1;\n  ushort shortValue;\n  undefined2 shortVar;\n  undefined *bufferPtr;\n  undefined4 bufferSize2;\n  undefined4 zeroVal;\n  undefined4 paramValue1;\n  undefined4 paramValue2;\n  undefined4 paramValue3;\n  undefined stackBuffer [1024];\n  \n  paramValue3 = *(undefined4 *)(data + 100);\n  paramValue1 = *(undefined4 *)(data + 0x1c);\n  shortVar = *(undefined2 *)(data + 0xe);\n  paramValue2 = *(undefined4 *)(data + 0x24);\n  localBuffers[0] = stackBuffer;\n  shortValue = *(ushort *)(data + 0xc) & 0xfffd;\n  bufferSize1 = 0x400;\n  bufferSize2 = 0x400;\n  zeroVal = 0;\n  bufferPtr = localBuffers[0];\n  printResult = _vfiprintf_r(buffer,localBuffers);\n  if ((-1 < printResult) && (flushResult = _fflush_r(buffer,localBuffers), flushResult != 0)) {\n    printResult = -1;\n  }\n  if ((int)((uint)shortValue << 0x19) < 0) {\n    *(ushort *)(data + 0xc) = *(ushort *)(data + 0xc) | 0x40;\n  }\n  return printResult;\n}\n\n",
            "renaming": {
                "FUN_0008378c": "print_formatted_string_0008378c",
                "param_1": "buffer",
                "param_2": "data",
                "iVar1": "printResult",
                "iVar2": "flushResult",
                "local_488": "localBuffers",
                "local_480": "bufferSize1",
                "local_47c": "shortValue",
                "local_47a": "shortVar",
                "local_478": "bufferPtr",
                "local_474": "bufferSize2",
                "local_470": "zeroVal",
                "local_46c": "paramValue1",
                "local_464": "paramValue2",
                "local_424": "paramValue3",
                "auStack_420": "stackBuffer"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_vfiprintf_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083808": {
            "entrypoint": "0x00083808",
            "current_name": "initialize_buffer_00083808",
            "code": "\nundefined4 initializeBuffer_00083808(undefined4 *outputStatus,int *buffer)\n\n{\n  int returnValue;\n  int tempVar1;\n  uint tempVar2;\n  ushort tempVar3;\n  \n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x38) == 0)) {\n    __sinit();\n  }\n  tempVar3 = *(ushort *)(buffer + 3);\n  tempVar2 = (uint)tempVar3;\n  if ((int)(tempVar2 << 0x1c) < 0) {\n    tempVar1 = buffer[4];\n  }\n  else {\n    if (-1 < (int)(tempVar2 << 0x1b)) {\n      *outputStatus = 9;\n      *(ushort *)(buffer + 3) = tempVar3 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(tempVar2 << 0x1d) < 0) {\n      if ((int *)buffer[0xc] != (int *)0x0) {\n        if ((int *)buffer[0xc] != buffer + 0x10) {\n          _free_r(outputStatus);\n          tempVar3 = *(ushort *)(buffer + 3);\n        }\n        buffer[0xc] = 0;\n      }\n      tempVar1 = buffer[4];\n      tempVar3 = tempVar3 & 0xffdb;\n      *buffer = tempVar1;\n      buffer[1] = 0;\n    }\n    else {\n      tempVar1 = buffer[4];\n    }\n    *(ushort *)(buffer + 3) = tempVar3 | 8;\n    tempVar2 = (uint)(tempVar3 | 8);\n  }\n  if ((tempVar1 == 0) && ((tempVar2 & 0x280) != 0x200)) {\n    __smakebuf_r(outputStatus,buffer);\n    tempVar2 = (uint)*(ushort *)(buffer + 3);\n    tempVar1 = buffer[4];\n  }\n  if ((tempVar2 & 1) == 0) {\n    returnValue = 0;\n    if (-1 < (int)(tempVar2 << 0x1e)) {\n      returnValue = buffer[5];\n    }\n    buffer[2] = returnValue;\n  }\n  else {\n    buffer[6] = -buffer[5];\n    buffer[2] = 0;\n  }\n  if ((tempVar1 == 0) && ((int)((uint)*(ushort *)(buffer + 3) << 0x18) < 0)) {\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083808": "initialize_buffer_00083808",
                "param_1": "outputStatus",
                "param_2": "buffer",
                "iVar1": "returnValue",
                "iVar2": "tempVar1",
                "uVar3": "tempVar2",
                "uVar4": "tempVar3"
            },
            "calling": [
                "__swbuf_r",
                "__sfvwrite_r",
                "_vfiprintf_r"
            ],
            "called": [
                "_free_r",
                "__sinit",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000838cc": {
            "entrypoint": "0x000838cc",
            "current_name": "update_data_000838cc",
            "code": "\nundefined4 updateData_000838cc(int flag,undefined4 value,undefined4 data1,undefined4 data2)\n\n{\n  undefined4 *dataPtr;\n  uint index;\n  uint bitMask;\n  \n  if (DAT_20070180 == (undefined4 *)0x0) {\n    DAT_20070180 = (undefined4 *)&DAT_20070184;\n  }\n  index = DAT_20070180[1];\n  dataPtr = DAT_20070180;\n  if (0x1f < (int)index) {\n    dataPtr = (undefined4 *)malloc(400);\n    if (dataPtr == (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *dataPtr = DAT_20070180;\n    dataPtr[1] = 0;\n    index = 0;\n    DAT_20070180 = dataPtr;\n    dataPtr[0x62] = 0;\n    dataPtr[99] = 0;\n  }\n  if (flag != 0) {\n    bitMask = 1 << (index & 0xff);\n    dataPtr[index + 0x22] = data1;\n    dataPtr[0x62] = dataPtr[0x62] | bitMask;\n    dataPtr[index + 0x42] = data2;\n    if (flag == 2) {\n      dataPtr[99] = bitMask | dataPtr[99];\n    }\n  }\n  dataPtr[1] = index + 1;\n  dataPtr[index + 2] = value;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000838cc": "update_data_000838cc",
                "param_1": "flag",
                "param_2": "value",
                "param_3": "data1",
                "param_4": "data2",
                "puVar1": "dataPtr",
                "uVar2": "index",
                "uVar3": "bitMask"
            },
            "calling": [
                "atexit",
                "__cxa_atexit"
            ],
            "called": [
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083974": {
            "entrypoint": "0x00083974",
            "current_name": "FUNC_00083974",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083978) */\n\nvoid FUNC_00083974(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083974": "FUNC_00083974"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083988": {
            "entrypoint": "0x00083988",
            "current_name": "register_exit_proc_00083988",
            "code": "\nint register_exit_proc_00083988(function_ptr *function_ptr)\n\n{\n  int exit_proc_result;\n  \n  exit_proc_result = __register_exitproc(0,function_ptr,0,0);\n  return exit_proc_result;\n}\n\n",
            "renaming": {
                "FUN_00083988": "register_exit_proc_00083988",
                "__func": "function_ptr",
                "iVar1": "exit_proc_result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083994": {
            "entrypoint": "0x00083994",
            "current_name": "decompress_data_00083994",
            "code": "\nundefined4 decompress_data_00083994(int *input_data,int *output_data)\n\n{\n  int *temp_ptr;\n  int remaining_size;\n  ushort flags;\n  uint combined_flags;\n  int bytes_processed;\n  code *decompression_handler;\n  int temp_var;\n  \n  flags = *(ushort *)(output_data + 3);\n  if ((int)((uint)flags << 0x1c) < 0) {\n    temp_var = output_data[4];\n    if (temp_var == 0) {\n      return 0;\n    }\n    remaining_size = *output_data;\n    if ((flags & 3) == 0) {\n      bytes_processed = output_data[5];\n    }\n    else {\n      bytes_processed = 0;\n    }\n    *output_data = temp_var;\n    remaining_size = remaining_size - temp_var;\n    output_data[2] = bytes_processed;\n    do {\n      if (remaining_size < 1) {\n        return 0;\n      }\n      bytes_processed = (*(code *)output_data[9])(input_data,output_data[7],temp_var,remaining_size);\n      remaining_size = remaining_size - bytes_processed;\n      temp_var = temp_var + bytes_processed;\n    } while (0 < bytes_processed);\nLAB_00083a54:\n    *(ushort *)(output_data + 3) = *(ushort *)(output_data + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(output_data + 3) = flags | 0x800;\n  if ((output_data[1] < 1) && (output_data[0xf] < 1)) {\n    return 0;\n  }\n  decompression_handler = (code *)output_data[10];\n  if (decompression_handler == (code *)0x0) {\n    return 0;\n  }\n  combined_flags = (uint)(flags | 0x800);\n  temp_var = *input_data;\n  *input_data = 0;\n  if ((flags & 0x1000) == 0) {\n    remaining_size = (*decompression_handler)(input_data,output_data[7],combined_flags & 0x1000,1);\n    if ((remaining_size == -1) && (bytes_processed = *input_data, bytes_processed != 0)) {\n      if ((bytes_processed == 0x1d) || (bytes_processed == 0x16)) {\n        *input_data = temp_var;\n        return 0;\n      }\n      goto LAB_00083a54;\n    }\n    combined_flags = (uint)*(ushort *)(output_data + 3);\n    decompression_handler = (code *)output_data[10];\n  }\n  else {\n    remaining_size = output_data[0x14];\n  }\n  if (((int)(combined_flags << 0x1d) < 0) && (remaining_size = remaining_size - output_data[1], output_data[0xc] != 0)) {\n    remaining_size = remaining_size - output_data[0xf];\n  }\n  remaining_size = (*decompression_handler)(input_data,output_data[7],remaining_size,0);\n  if (remaining_size == -1) {\n    bytes_processed = *input_data;\n    if (bytes_processed != 0) {\n      if ((bytes_processed != 0x1d) && (bytes_processed != 0x16)) {\n        *(ushort *)(output_data + 3) = *(ushort *)(output_data + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(output_data + 3) = *(ushort *)(output_data + 3) & 0xf7ff;\n      *output_data = output_data[4];\n      output_data[1] = 0;\n      goto LAB_00083a00;\n    }\n    flags = *(ushort *)(output_data + 3) & 0xf7ff;\n    output_data[1] = 0;\n    *(ushort *)(output_data + 3) = flags;\n    *output_data = output_data[4];\n  }\n  else {\n    flags = *(ushort *)(output_data + 3) & 0xf7ff;\n    *output_data = output_data[4];\n    *(ushort *)(output_data + 3) = flags;\n    output_data[1] = 0;\n  }\n  if ((int)((uint)flags << 0x13) < 0) {\n    output_data[0x14] = remaining_size;\n  }\nLAB_00083a00:\n  temp_ptr = (int *)output_data[0xc];\n  *input_data = temp_var;\n  if (temp_ptr == (int *)0x0) {\n    return 0;\n  }\n  if (temp_ptr != output_data + 0x10) {\n    _free_r(input_data);\n  }\n  output_data[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083994": "decompress_data_00083994",
                "param_1": "input_data",
                "param_2": "output_data",
                "piVar1": "temp_ptr",
                "iVar2": "remaining_size",
                "uVar3": "flags",
                "uVar4": "combined_flags",
                "iVar5": "bytes_processed",
                "pcVar6": "decompression_handler",
                "iVar7": "temp_var"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083adc": {
            "entrypoint": "0x00083adc",
            "current_name": "check_and_flush_stream_00083adc",
            "code": "\nvoid checkAndFlushStream_00083adc(int streamPtr,int bufferPtr)\n\n{\n  if ((streamPtr != 0) && (*(int *)(streamPtr + 0x38) == 0)) {\n    __sinit();\n  }\n  if (*(short *)(bufferPtr + 0xc) == 0) {\n    return;\n  }\n  __sflush_r(streamPtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083adc": "check_and_flush_stream_00083adc",
                "param_1": "streamPtr",
                "param_2": "bufferPtr"
            },
            "calling": [
                "__swbuf_r",
                "__sbprintf",
                "__sfvwrite_r",
                "_fclose_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b08": {
            "entrypoint": "0x00083b08",
            "current_name": "walk_function_00083b08",
            "code": "\nvoid walkFunction_00083b08(undefined4 param)\n\n{\n  fileWalk(param,0x846a5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b08": "walk_function_00083b08",
                "param_1": "param",
                "_fwalk": "fileWalk"
            },
            "calling": [],
            "called": [
                "_fwalk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b14": {
            "entrypoint": "0x00083b14",
            "current_name": "initialize_data_structures_00083b14",
            "code": "\nvoid initializeDataStructures_00083b14(int structureAddress)\n\n{\n  undefined4 *firstPointer;\n  undefined4 *secondPointer;\n  \n  if (*(int *)(structureAddress + 0x38) == 0) {\n    firstPointer = *(undefined4 **)(structureAddress + 4);\n    *(undefined4 *)(structureAddress + 0x3c) = 0x83b09;\n    *(undefined4 *)(structureAddress + 0x2e4) = 3;\n    *(int *)(structureAddress + 0x2e8) = structureAddress + 0x2ec;\n    *(undefined4 *)(structureAddress + 0x2e0) = 0;\n    *(undefined2 *)(firstPointer + 3) = 4;\n    *firstPointer = 0;\n    firstPointer[1] = 0;\n    firstPointer[2] = 0;\n    firstPointer[0x19] = 0;\n    *(undefined2 *)((int)firstPointer + 0xe) = 0;\n    firstPointer[4] = 0;\n    firstPointer[5] = 0;\n    firstPointer[6] = 0;\n    memset(firstPointer + 0x17,0,8);\n    secondPointer = *(undefined4 **)(structureAddress + 8);\n    firstPointer[7] = firstPointer;\n    firstPointer[8] = 0x84441;\n    firstPointer[9] = 0x84465;\n    firstPointer[10] = 0x8449d;\n    firstPointer[0xb] = 0x844bd;\n    *(undefined2 *)((int)secondPointer + 0xe) = 1;\n    *(undefined2 *)(secondPointer + 3) = 9;\n    *secondPointer = 0;\n    secondPointer[1] = 0;\n    secondPointer[2] = 0;\n    secondPointer[0x19] = 0;\n    secondPointer[4] = 0;\n    secondPointer[5] = 0;\n    secondPointer[6] = 0;\n    memset(secondPointer + 0x17,0,8);\n    firstPointer = *(undefined4 **)(structureAddress + 0xc);\n    secondPointer[7] = secondPointer;\n    secondPointer[8] = 0x84441;\n    secondPointer[9] = 0x84465;\n    secondPointer[10] = 0x8449d;\n    secondPointer[0xb] = 0x844bd;\n    *(undefined2 *)(firstPointer + 3) = 0x12;\n    *(undefined2 *)((int)firstPointer + 0xe) = 2;\n    *firstPointer = 0;\n    firstPointer[1] = 0;\n    firstPointer[2] = 0;\n    firstPointer[0x19] = 0;\n    firstPointer[4] = 0;\n    firstPointer[5] = 0;\n    firstPointer[6] = 0;\n    memset(firstPointer + 0x17,0,8);\n    firstPointer[7] = firstPointer;\n    firstPointer[8] = 0x84441;\n    firstPointer[9] = 0x84465;\n    firstPointer[10] = 0x8449d;\n    firstPointer[0xb] = 0x844bd;\n    *(undefined4 *)(structureAddress + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b14": "initialize_data_structures_00083b14",
                "param_1": "structureAddress",
                "puVar1": "firstPointer",
                "puVar2": "secondPointer"
            },
            "calling": [
                "__swbuf_r",
                "__swsetup_r",
                "_vfiprintf_r",
                "_fflush_r",
                "_fclose_r"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083c08": {
            "entrypoint": "0x00083c08",
            "current_name": "FUNC_00083c08",
            "code": "\nvoid FUNC_00083c08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c08": "FUNC_00083c08"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083c0c": {
            "entrypoint": "0x00083c0c",
            "current_name": "FUNC_00083c0c",
            "code": "\nvoid FUNC_00083c0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c0c": "FUNC_00083c0c"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083c10": {
            "entrypoint": "0x00083c10",
            "current_name": "execute_fini_functions_00083c10",
            "code": "\nvoid executeFiniFunctions_00083c10(void)\n\n{\n  int iterationCount;\n  code **functionPointer;\n  \n  iterationCount = 1;\n  functionPointer = (code **)&finiArrayEnd;\n  do {\n    iterationCount = iterationCount + -1;\n    functionPointer = functionPointer + -1;\n    (**functionPointer)();\n  } while (iterationCount != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c10": "execute_fini_functions_00083c10",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointer",
                "__fini_array_end": "finiArrayEnd"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083c40": {
            "entrypoint": "0x00083c40",
            "current_name": "convert_and_print_string_00083c40",
            "code": "\nuint convertAndPrintString_00083c40(undefined4 locale,uint size,byte **string)\n\n{\n  int maxBytes;\n  uint result;\n  uint currentChar;\n  byte *bytePointer;\n  uint index;\n  byte tempChar;\n  byte tempArray [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(string + 3) << 0x12)) {\n    *(ushort *)(string + 3) = *(ushort *)(string + 3) | 0x2000;\n    string[0x19] = (byte *)((uint)string[0x19] | 0x2000);\n  }\n  maxBytes = __locale_mb_cur_max();\n  if ((maxBytes == 1) && (size - 1 < 0xff)) {\n    currentChar = size & 0xff;\n    tempChar = (byte)currentChar;\n    result = 1;\n  }\n  else {\n    result = _wcrtomb_r(locale,&tempChar,size,string + 0x17);\n    if (result == 0xffffffff) {\n      *(ushort *)(string + 3) = *(ushort *)(string + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (result == 0) {\n      return size;\n    }\n    currentChar = (uint)tempChar;\n  }\n  index = 0;\n  do {\n    bytePointer = string[2] + -1;\n    string[2] = bytePointer;\n    if ((int)bytePointer < 0) {\n      if ((int)string[6] <= (int)bytePointer) {\n        **string = (byte)currentChar;\n        bytePointer = *string;\n        currentChar = (uint)*bytePointer;\n        if (currentChar != 10) goto LAB_00083c90;\n      }\n      maxBytes = __swbuf_r(locale,currentChar,string);\n      if (maxBytes == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **string = (byte)currentChar;\n      bytePointer = *string;\nLAB_00083c90:\n      *string = bytePointer + 1;\n    }\n    if (result <= index + 1) {\n      return size;\n    }\n    currentChar = (uint)tempArray[index];\n    index = index + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00083c40": "convert_and_print_string_00083c40",
                "param_1": "locale",
                "param_2": "size",
                "param_3": "string",
                "iVar1": "maxBytes",
                "uVar2": "result",
                "uVar3": "currentChar",
                "pbVar4": "bytePointer",
                "uVar5": "index",
                "local_1c": "tempChar",
                "abStack_1b": "tempArray"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "__swbuf_r",
                "__locale_mb_cur_max",
                "_wcrtomb_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083d00": {
            "entrypoint": "0x00083d00",
            "current_name": "allocate_memory_00083d00",
            "code": "\nundefined4 allocate_memory_00083d00(undefined4 lock,int size)\n\n{\n  int current_chunk_end;\n  uint mem_chunk_size;\n  int aligned_chunk_start;\n  \n  __malloc_lock();\n  mem_chunk_size = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  aligned_chunk_start = ((mem_chunk_size - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < aligned_chunk_start) {\n    current_chunk_end = _sbrk_r(lock,0);\n    if (current_chunk_end == DAT_2007046c + mem_chunk_size) {\n      current_chunk_end = _sbrk_r(lock,-aligned_chunk_start);\n      if (current_chunk_end != -1) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo - aligned_chunk_start;\n        *(uint *)(DAT_2007046c + 4) = mem_chunk_size - aligned_chunk_start | 1;\n        __malloc_unlock(lock);\n        return 1;\n      }\n      aligned_chunk_start = _sbrk_r(lock,0);\n      if (0xf < aligned_chunk_start - DAT_2007046c) {\n        __malloc_current_mallinfo = aligned_chunk_start - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) = aligned_chunk_start - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083d00": "allocate_memory_00083d00",
                "param_1": "lock",
                "param_2": "size",
                "iVar1": "current_chunk_end",
                "uVar2": "mem_chunk_size",
                "iVar3": "aligned_chunk_start"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083d9c": {
            "entrypoint": "0x00083d9c",
            "current_name": "deallocate_memory_00083d9c",
            "code": "\nvoid deallocateMemory_00083d9c(undefined4 memoryLock,int ptrToMemory)\n\n{\n  undefined4 *pointer1;\n  bool bVar2;\n  uint lowerBits;\n  int tempVar1;\n  int tempVar2;\n  undefined1 *pointer2;\n  uint upperBits;\n  undefined1 *pointer3;\n  int tempVar3;\n  uint trimThreshold;\n  \n  if (ptrToMemory == 0) {\n    return;\n  }\n  __lockMemory();\n  lowerBits = *(uint *)(ptrToMemory + -4);\n  tempVar3 = ptrToMemory + -8;\n  upperBits = lowerBits & 0xfffffffe;\n  tempVar2 = tempVar3 + upperBits;\n  trimThreshold = *(uint *)(tempVar2 + 4) & 0xfffffffc;\n  if (DAT_2007046c == tempVar2) {\n    trimThreshold = trimThreshold + upperBits;\n    if (-1 < (int)(lowerBits << 0x1f)) {\n      tempVar3 = tempVar3 - *(int *)(ptrToMemory + -8);\n      tempVar1 = *(int *)(tempVar3 + 0xc);\n      tempVar2 = *(int *)(tempVar3 + 8);\n      trimThreshold = trimThreshold + *(int *)(ptrToMemory + -8);\n      *(int *)(tempVar2 + 0xc) = tempVar1;\n      *(int *)(tempVar1 + 8) = tempVar2;\n    }\n    lowerBits = __trimThreshold;\n    *(uint *)(tempVar3 + 4) = trimThreshold | 1;\n    DAT_2007046c = tempVar3;\n    if (lowerBits <= trimThreshold) {\n      _trimMalloc_r(memoryLock,__topPad);\n    }\n  }\n  else {\n    *(uint *)(tempVar2 + 4) = trimThreshold;\n    if ((lowerBits & 1) == 0) {\n      tempVar3 = tempVar3 - *(int *)(ptrToMemory + -8);\n      pointer1 = *(undefined4 **)(tempVar3 + 8);\n      upperBits = upperBits + *(int *)(ptrToMemory + -8);\n      if (pointer1 == &DAT_2007046c) {\n        bVar2 = true;\n      }\n      else {\n        tempVar1 = *(int *)(tempVar3 + 0xc);\n        pointer1[3] = tempVar1;\n        *(undefined4 **)(tempVar1 + 8) = pointer1;\n        bVar2 = false;\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (-1 < *(int *)(tempVar2 + trimThreshold + 4) << 0x1f) {\n      upperBits = upperBits + trimThreshold;\n      pointer1 = *(undefined4 **)(tempVar2 + 8);\n      if ((!bVar2) && (pointer1 == &DAT_2007046c)) {\n        DAT_20070474 = tempVar3;\n        DAT_20070478 = tempVar3;\n        *(int **)(tempVar3 + 0xc) = &DAT_2007046c;\n        *(int **)(tempVar3 + 8) = &DAT_2007046c;\n        *(uint *)(tempVar3 + 4) = upperBits | 1;\n        *(uint *)(tempVar3 + upperBits) = upperBits;\n        goto LAB_00083e30;\n      }\n      tempVar2 = *(int *)(tempVar2 + 0xc);\n      pointer1[3] = tempVar2;\n      *(undefined4 **)(tempVar2 + 8) = pointer1;\n    }\n    *(uint *)(tempVar3 + 4) = upperBits | 1;\n    *(uint *)(tempVar3 + upperBits) = upperBits;\n    if (!bVar2) {\n      if (upperBits < 0x200) {\n        lowerBits = upperBits & 0xfffffff8;\n        tempVar2 = *(int *)((int)&DAT_2007046c + lowerBits);\n        DAT_20070468 = DAT_20070468 | 1 << ((int)(upperBits >> 3) >> 2 & 0xffU);\n        *(int *)(tempVar3 + 8) = tempVar2;\n        *(undefined1 **)(tempVar3 + 0xc) = &__memory + lowerBits;\n        *(int *)((int)&DAT_2007046c + lowerBits) = tempVar3;\n        *(int *)(tempVar2 + 0xc) = tempVar3;\n        __malloc_unlock(memoryLock);\n        return;\n      }\n      lowerBits = upperBits >> 9;\n      if (lowerBits < 5) {\n        tempVar2 = (upperBits >> 6) + 0x38;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (lowerBits < 0x15) {\n        tempVar2 = lowerBits + 0x5b;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (lowerBits < 0x55) {\n        tempVar2 = (upperBits >> 0xc) + 0x6e;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (lowerBits < 0x155) {\n        tempVar2 = (upperBits >> 0xf) + 0x77;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (lowerBits < 0x555) {\n        tempVar2 = (upperBits >> 0x12) + 0x7c;\n        tempVar1 = tempVar2 * 2;\n      }\n      else {\n        tempVar1 = 0xfc;\n        tempVar2 = 0x7e;\n      }\n      pointer2 = (undefined1 *)(&DAT_2007046c)[tempVar1];\n      if (pointer2 == &__memory + tempVar1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (tempVar2 >> 2 & 0xffU);\n        pointer3 = pointer2;\n      }\n      else {\n        do {\n          if ((*(uint *)(pointer2 + 4) & 0xfffffffc) <= upperBits) break;\n          pointer2 = *(undefined1 **)(pointer2 + 8);\n        } while (&__memory + tempVar1 * 4 != pointer2);\n        pointer3 = *(undefined1 **)(pointer2 + 0xc);\n      }\n      *(undefined1 **)(tempVar3 + 0xc) = pointer3;\n      *(undefined1 **)(tempVar3 + 8) = pointer2;\n      *(int *)(pointer3 + 8) = tempVar3;\n      *(int *)(pointer2 + 0xc) = tempVar3;\n    }\n  }\nLAB_00083e30:\n  __malloc_unlock(memoryLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083d9c": "deallocate_memory_00083d9c",
                "param_1": "memoryLock",
                "param_2": "ptrToMemory",
                "puVar1": "pointer1",
                "uVar3": "lowerBits",
                "iVar4": "tempVar1",
                "iVar5": "tempVar2",
                "puVar6": "pointer2",
                "uVar7": "upperBits",
                "puVar8": "pointer3",
                "iVar9": "tempVar3",
                "uVar10": "trimThreshold",
                "__malloc_lock": "__lockMemory",
                "__malloc_trim_threshold": "__trimThreshold",
                "__malloc_top_pad": "__topPad",
                "_malloc_trim_r": "_trimMalloc_r",
                "__malloc_av_": "__memory",
                "&__malloc_av_": "&__memory"
            },
            "calling": [
                "__swsetup_r",
                "__sfvwrite_r",
                "_malloc_r",
                "_realloc_r",
                "__sflush_r",
                "_fclose_r",
                "free"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_malloc_trim_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083f34": {
            "entrypoint": "0x00083f34",
            "current_name": "process_data_00083f34",
            "code": "\nundefined4 processData_00083f34(undefined4 *error_code,void **data_buffer,undefined4 *data_length)\n\n{\n  void **temp_pointer_1;\n  int status;\n  void *temp_pointer_2;\n  void *temp_pointer_3;\n  void *temp_pointer_4;\n  void *temp_pointer_5;\n  ushort flags;\n  uint flags_value;\n  int remaining_length;\n  void **source_buffer;\n  void *source_pointer;\n  void *source_data;\n  void *temp_pointer_6;\n  size_t temp_value;\n  void *temp_variable;\n  \n  if (data_length[2] != 0) {\n    flags = *(ushort *)(data_buffer + 3);\n    flags_value = (uint)flags;\n    if (((int)(flags_value << 0x1c) < 0) && (data_buffer[4] != (void *)0x0)) {\n      source_buffer = (void **)*data_length;\n    }\n    else {\n      status = __swsetup_r(error_code,data_buffer);\n      if (status != 0) {\n        return 0xffffffff;\n      }\n      flags = *(ushort *)(data_buffer + 3);\n      flags_value = (uint)flags;\n      source_buffer = (void **)*data_length;\n    }\n    if ((flags & 2) == 0) {\n      temp_pointer_4 = (void *)(flags_value & 2);\n      source_data = temp_pointer_4;\n      source_pointer = temp_pointer_4;\n      temp_variable = temp_pointer_4;\n      if ((flags_value & 1) == 0) {\n        temp_pointer_4 = (void *)0x0;\n        source_data = (void *)0x0;\n        while( true ) {\n          while (temp_pointer_4 == (void *)0x0) {\n            source_data = *source_buffer;\n            temp_pointer_1 = source_buffer + 1;\n            source_buffer = source_buffer + 2;\n            temp_pointer_4 = *temp_pointer_1;\n          }\n          source_pointer = data_buffer[2];\n          if ((int)(flags_value << 0x16) < 0) {\n            if (temp_pointer_4 < source_pointer) {\n              temp_pointer_2 = *data_buffer;\n              source_pointer = temp_pointer_4;\n            }\n            else if ((flags_value & 0x480) == 0) {\n              temp_pointer_2 = *data_buffer;\n            }\n            else {\n              temp_value = (int)*data_buffer - (int)data_buffer[4];\n              source_pointer = (void *)(temp_value + 1 + (int)temp_pointer_4);\n              temp_pointer_2 = (void *)(((int)data_buffer[5] * 3) / 2);\n              if (source_pointer <= temp_pointer_2) {\n                source_pointer = temp_pointer_2;\n              }\n              if ((int)(flags_value << 0x15) < 0) {\n                temp_pointer_3 = (void *)_malloc_r(error_code,source_pointer);\n                if (temp_pointer_3 == (void *)0x0) {\n                  *error_code = 0xc;\n                  flags = *(ushort *)(data_buffer + 3);\n                  goto LAB_00084030;\n                }\n                memcpy(temp_pointer_3,data_buffer[4],temp_value);\n                *(ushort *)(data_buffer + 3) = *(ushort *)(data_buffer + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                temp_pointer_3 = (void *)_realloc_r(error_code);\n                if (temp_pointer_3 == (void *)0x0) {\n                  _free_r(error_code,data_buffer[4]);\n                  flags = *(ushort *)(data_buffer + 3) & 0xff7f;\n                  *error_code = 0xc;\n                  goto LAB_00084030;\n                }\n              }\n              temp_pointer_2 = (void *)((int)temp_pointer_3 + temp_value);\n              data_buffer[4] = temp_pointer_3;\n              data_buffer[5] = source_pointer;\n              *data_buffer = temp_pointer_2;\n              data_buffer[2] = (void *)((int)source_pointer - temp_value);\n              source_pointer = temp_pointer_4;\n            }\n            memmove(temp_pointer_2,source_data,(size_t)source_pointer);\n            data_buffer[2] = (void *)((int)data_buffer[2] - (int)source_pointer);\n            *data_buffer = (void *)((int)*data_buffer + (int)source_pointer);\n            source_pointer = temp_pointer_4;\n          }\n          else if ((data_buffer[4] < *data_buffer) || (temp_pointer_2 = data_buffer[5], temp_pointer_4 < temp_pointer_2)) {\n            if (temp_pointer_4 < source_pointer) {\n              source_pointer = temp_pointer_4;\n            }\n            memmove(*data_buffer,source_data,(size_t)source_pointer);\n            temp_pointer_2 = data_buffer[2];\n            data_buffer[2] = (void *)((int)temp_pointer_2 - (int)source_pointer);\n            *data_buffer = (void *)((int)*data_buffer + (int)source_pointer);\n            if (((void *)((int)temp_pointer_2 - (int)source_pointer) == (void *)0x0) &&\n               (status = _fflush_r(error_code,data_buffer), status != 0)) goto LAB_0008402e;\n          }\n          else {\n            source_pointer = (void *)0x7fffffff;\n            if (temp_pointer_4 < (void *)0x7fffffff) {\n              source_pointer = temp_pointer_4;\n            }\n            source_pointer = (void *)(*(code *)data_buffer[9])\n                                        (error_code,data_buffer[7],source_data,\n                                         ((uint)source_pointer / (uint)temp_pointer_2) * (int)temp_pointer_2);\n            if ((int)source_pointer < 1) goto LAB_0008402e;\n          }\n          status = data_length[2];\n          source_data = (void *)((int)source_data + (int)source_pointer);\n          temp_pointer_4 = (void *)((int)temp_pointer_4 - (int)source_pointer);\n          data_length[2] = status - (int)source_pointer;\n          if (status - (int)source_pointer == 0) break;\n          flags_value = (uint)*(ushort *)(data_buffer + 3);\n        }\n      }\n      else {\n        do {\n          while (temp_pointer_4 == (void *)0x0) {\n            source_pointer = *source_buffer;\n            temp_pointer_4 = source_buffer[1];\n            temp_variable = (void *)0x0;\n            source_buffer = source_buffer + 2;\n          }\n          if (temp_variable == (void *)0x0) {\n            source_data = memchr(source_pointer,10,(size_t)temp_pointer_4);\n            if (source_data == (void *)0x0) {\n              source_data = (void *)((int)temp_pointer_4 + 1);\n              temp_variable = (void *)0x1;\n            }\n            else {\n              source_data = (void *)((int)source_data + (1 - (int)source_pointer));\n              temp_variable = (void *)0x1;\n            }\n          }\n          temp_pointer_3 = *data_buffer;\n          temp_pointer_2 = source_data;\n          if (temp_pointer_4 <= source_data) {\n            temp_pointer_2 = temp_pointer_4;\n          }\n          temp_pointer_5 = data_buffer[5];\n          if ((data_buffer[4] < temp_pointer_3) &&\n             (temp_pointer_6 = (void *)((int)data_buffer[2] + (int)temp_pointer_5), (int)temp_pointer_6 < (int)temp_pointer_2)) {\n            memmove(temp_pointer_3,source_pointer,(size_t)temp_pointer_6);\n            *data_buffer = (void *)((int)*data_buffer + (int)temp_pointer_6);\n            status = _fflush_r(error_code,data_buffer);\n            if (status != 0) goto LAB_0008402e;\n          }\n          else if ((int)temp_pointer_2 < (int)temp_pointer_5) {\n            memmove(temp_pointer_3,source_pointer,(size_t)temp_pointer_2);\n            data_buffer[2] = (void *)((int)data_buffer[2] - (int)temp_pointer_2);\n            *data_buffer = (void *)((int)temp_pointer_2 + (int)*data_buffer);\n            temp_pointer_6 = temp_pointer_2;\n          }\n          else {\n            temp_pointer_6 = (void *)(*(code *)data_buffer[9])(error_code,data_buffer[7],source_pointer,temp_pointer_5);\n            if ((int)temp_pointer_6 < 1) goto LAB_0008402e;\n          }\n          source_data = (void *)((int)source_data - (int)temp_pointer_6);\n          if (source_data == (void *)0x0) {\n            status = _fflush_r(error_code,data_buffer);\n            if (status != 0) goto LAB_0008402e;\n            temp_variable = (void *)0x0;\n          }\n          status = data_length[2];\n          source_pointer = (void *)((int)source_pointer + (int)temp_pointer_6);\n          temp_pointer_4 = (void *)((int)temp_pointer_4 - (int)temp_pointer_6);\n          data_length[2] = status - (int)temp_pointer_6;\n        } while (status - (int)temp_pointer_6 != 0);\n      }\n    }\n    else {\n      source_data = (void *)0x0;\n      temp_pointer_4 = (void *)0x0;\n      do {\n        while( true ) {\n          source_pointer = temp_pointer_4;\n          if ((void *)0x7ffffbff < temp_pointer_4) {\n            source_pointer = (void *)0x7ffffc00;\n          }\n          if (temp_pointer_4 != (void *)0x0) break;\n          source_data = *source_buffer;\n          temp_pointer_4 = source_buffer[1];\n          source_buffer = source_buffer + 2;\n        }\n        status = (*(code *)data_buffer[9])(error_code,data_buffer[7],source_data,source_pointer);\n        if (status < 1) {\nLAB_0008402e:\n          flags = *(ushort *)(data_buffer + 3);\nLAB_00084030:\n          *(ushort *)(data_buffer + 3) = flags | 0x40;\n          return 0xffffffff;\n        }\n        remaining_length = data_length[2];\n        source_data = (void *)((int)source_data + status);\n        temp_pointer_4 = (void *)((int)temp_pointer_4 - status);\n        data_length[2] = remaining_length - status;\n      } while (remaining_length - status != 0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083f34": "process_data_00083f34",
                "param_1": "error_code",
                "param_2": "data_buffer",
                "param_3": "data_length",
                "ppvVar1": "temp_pointer_1",
                "iVar2": "status",
                "pvVar3": "temp_pointer_2",
                "pvVar4": "temp_pointer_3",
                "pvVar5": "temp_pointer_4",
                "pvVar6": "temp_pointer_5",
                "uVar7": "flags",
                "uVar8": "flags_value",
                "iVar9": "remaining_length",
                "ppvVar10": "source_buffer",
                "pvVar11": "source_pointer",
                "pvVar12": "source_data",
                "__n": "temp_pointer_6",
                "__n_00": "temp_value",
                "local_2c": "temp_variable"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r",
                "memcpy",
                "_fflush_r",
                "memmove"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084248": {
            "entrypoint": "0x00084248",
            "current_name": "process_parameters_00084248",
            "code": "\nuint processParameters_00084248(int baseAddress,code *callbackFunction)\n\n{\n  uint result;\n  int currentAddress;\n  int remainingIterations;\n  uint combinedResults;\n  int *paramPointer;\n  \n  paramPointer = (int *)(baseAddress + 0x2e0);\n  if (paramPointer != (int *)0x0) {\n    combinedResults = 0;\n    do {\n      currentAddress = paramPointer[2];\n      remainingIterations = paramPointer[1] + -1;\n      if (-1 < remainingIterations) {\n        do {\n          remainingIterations = remainingIterations + -1;\n          if ((1 < *(ushort *)(currentAddress + 0xc)) && (*(short *)(currentAddress + 0xe) != -1)) {\n            result = (*callbackFunction)(currentAddress);\n            combinedResults = combinedResults | result;\n          }\n          currentAddress = currentAddress + 0x68;\n        } while (remainingIterations != -1);\n      }\n      paramPointer = (int *)*paramPointer;\n    } while (paramPointer != (int *)0x0);\n    return combinedResults;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084248": "process_parameters_00084248",
                "param_1": "baseAddress",
                "param_2": "callbackFunction",
                "uVar1": "result",
                "iVar2": "currentAddress",
                "iVar3": "remainingIterations",
                "uVar4": "combinedResults",
                "piVar5": "paramPointer"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084290": {
            "entrypoint": "0x00084290",
            "current_name": "get_charset_00084290",
            "code": "\nchar * getCharset_00084290(void)\n\n{\n  return charset;\n}\n\n",
            "renaming": {
                "FUN_00084290": "get_charset_00084290",
                "lc_ctype_charset": "charset"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084298": {
            "entrypoint": "0x00084298",
            "current_name": "get_max_multi_byte_character_length_00084298",
            "code": "\nundefined4 getMaxMultiByteCharacterLength_00084298(void)\n\n{\n  return maxCharacterLength;\n}\n\n",
            "renaming": {
                "FUN_00084298": "get_max_multi_byte_character_length_00084298",
                "__mb_cur_max": "maxCharacterLength"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "initialize_file_000842a4",
            "code": "\nvoid initializeFile_000842a4(int fileDescriptor,int *fileInfo)\n\n{\n  ushort filePermissions;\n  int fileStatus;\n  int allocatedMemory;\n  uint tempPermissions;\n  bool isTerminal;\n  undefined statBuffer [4];\n  uint statResult;\n  \n  filePermissions = *(ushort *)(fileInfo + 3);\n  tempPermissions = (uint)filePermissions;\n  if ((int)(tempPermissions << 0x1e) < 0) {\n    *fileInfo = (int)fileInfo + 0x43;\n    fileInfo[4] = (int)fileInfo + 0x43;\n    fileInfo[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)fileInfo + 0xe)) {\n    fileStatus = _fstat_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe),statBuffer);\n    if (-1 < fileStatus) {\n      isTerminal = (statResult & 0xf000) == 0x2000;\n      if (((statResult & 0xf000) == 0x8000) && (fileInfo[10] == 0x8449d)) {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x400;\n        fileInfo[0x13] = 0x400;\n      }\n      else {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x800;\n      }\n      goto LAB_00084300;\n    }\n    filePermissions = *(ushort *)(fileInfo + 3);\n    tempPermissions = (uint)filePermissions;\n  }\n  *(ushort *)(fileInfo + 3) = filePermissions | 0x800;\n  if ((tempPermissions & 0x80) == 0) {\n    fileStatus = 0x400;\n  }\n  else {\n    fileStatus = 0x40;\n  }\n  isTerminal = false;\nLAB_00084300:\n  allocatedMemory = _malloc_r(fileDescriptor,fileStatus);\n  filePermissions = *(ushort *)(fileInfo + 3);\n  if (allocatedMemory == 0) {\n    if (-1 < (int)((uint)filePermissions << 0x16)) {\n      *(ushort *)(fileInfo + 3) = filePermissions | 2;\n      *fileInfo = (int)fileInfo + 0x43;\n      fileInfo[4] = (int)fileInfo + 0x43;\n      fileInfo[5] = 1;\n    }\n  }\n  else {\n    *(undefined4 *)(fileDescriptor + 0x3c) = 0x83b09;\n    *(ushort *)(fileInfo + 3) = filePermissions | 0x80;\n    *fileInfo = allocatedMemory;\n    fileInfo[4] = allocatedMemory;\n    fileInfo[5] = fileStatus;\n    if ((isTerminal) && (fileStatus = _isatty_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe)), fileStatus != 0)) {\n      *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "initialize_file_000842a4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "uVar1": "filePermissions",
                "iVar2": "fileStatus",
                "iVar3": "allocatedMemory",
                "uVar4": "tempPermissions",
                "bVar5": "isTerminal",
                "auStack_54": "statBuffer",
                "local_50": "statResult"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "_malloc_r",
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084384": {
            "entrypoint": "0x00084384",
            "current_name": "find_byte_sequence_00084384",
            "code": "\nvoid * find_byte_sequence_00084384(void *buffer,int target_byte,size_t buffer_length)\n\n{\n  uint target_byte_value;\n  uint temp_value;\n  int index;\n  uint *buffer_ptr;\n  uint temp_result;\n  bool is_last_byte;\n  \n  target_byte_value = target_byte & 0xff;\n  if (((uint)buffer & 3) == 0) {\nLAB_000843b4:\n    if (3 < buffer_length) {\n      temp_result = target_byte_value | target_byte_value << 8;\n      buffer_ptr = (uint *)buffer;\n      do {\n        temp_value = *buffer_ptr ^ (temp_result | temp_result << 0x10);\n        buffer = buffer_ptr;\n        if ((temp_value + 0xfefefeff & ~temp_value & 0x80808080) != 0) break;\n        buffer_length = buffer_length - 4;\n        buffer = buffer_ptr + 1;\n        buffer_ptr = buffer_ptr + 1;\n      } while (3 < buffer_length);\n    }\n    if (buffer_length == 0) {\n      buffer = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*buffer != target_byte_value) {\n        index = 0;\n        do {\n          buffer = (void *)((int)buffer + 1);\n          is_last_byte = index == buffer_length - 1;\n          index = index + 1;\n          if (is_last_byte) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        } while (*buffer != target_byte_value);\n      }\n    }\n  }\n  else if (buffer_length == 0) {\nLAB_000843dc:\n    buffer = (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*buffer != target_byte_value) {\n      buffer_ptr = (uint *)((int)buffer + 1);\n      buffer_length = buffer_length - 1;\n      do {\n        buffer = buffer_ptr;\n        if (((uint)buffer & 3) == 0) goto LAB_000843b4;\n        if (buffer_length == 0) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        buffer_ptr = (uint *)((int)buffer + 1);\n        buffer_length = buffer_length - 1;\n      } while (*buffer != target_byte_value);\n    }\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_00084384": "find_byte_sequence_00084384",
                "__s": "buffer",
                "__c": "target_byte",
                "__n": "buffer_length",
                "uVar1": "target_byte_value",
                "uVar2": "temp_value",
                "uVar5": "temp_result",
                "iVar3": "index",
                "puVar4": "buffer_ptr",
                "bVar6": "is_last_byte"
            },
            "calling": [
                "__sfvwrite_r",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084418": {
            "entrypoint": "0x00084418",
            "current_name": "execute_system_call_00084418",
            "code": "\nvoid executeSystemCall_00084418(int *errorCode,int processID,int signal)\n\n{\n  errorNumber = 0;\n  _kill(processID,signal);\n  if ((processID == -1) && (errorNumber != 0)) {\n    *errorCode = errorNumber;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084418": "execute_system_call_00084418",
                "param_1": "errorCode",
                "param_2": "processID",
                "param_3": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "kill"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084440": {
            "entrypoint": "0x00084440",
            "current_name": "update_total_00084440",
            "code": "\nvoid updateTotal_00084440(undefined4 arg1,int arg2)\n\n{\n  int readBytes;\n  \n  readBytes = _read_r(arg1,(int)*(short *)(arg2 + 0xe));\n  if (-1 < readBytes) {\n    *(int *)(arg2 + 0x50) = *(int *)(arg2 + 0x50) + readBytes;\n    return;\n  }\n  *(ushort *)(arg2 + 0xc) = *(ushort *)(arg2 + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084440": "update_total_00084440",
                "param_1": "arg1",
                "param_2": "arg2",
                "iVar1": "readBytes"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084464": {
            "entrypoint": "0x00084464",
            "current_name": "update_file_content_00084464",
            "code": "\nvoid updateFileContent_00084464(undefined4 fileDescriptor,int dataAddress,undefined4 buffer,undefined4 count)\n\n{\n  ushort dataValue;\n  \n  dataValue = *(ushort *)(dataAddress + 0xc);\n  if ((int)((uint)dataValue << 0x17) < 0) {\n    moveFilePointerToOffset(fileDescriptor,(int)*(short *)(dataAddress + 0xe),0,2);\n    dataValue = *(ushort *)(dataAddress + 0xc);\n  }\n  *(ushort *)(dataAddress + 0xc) = dataValue & 0xefff;\n  writeToFile(fileDescriptor,(int)*(short *)(dataAddress + 0xe),buffer,count);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084464": "update_file_content_00084464",
                "param_1": "fileDescriptor",
                "param_2": "dataAddress",
                "param_3": "buffer",
                "param_4": "count",
                "uVar1": "dataValue",
                "_lseek_r": "moveFilePointerToOffset",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008449c": {
            "entrypoint": "0x0008449c",
            "current_name": "update_seek_position_0008449c",
            "code": "\nvoid updateSeekPosition_0008449c(undefined4 fileDescriptor,int structAddress)\n\n{\n  int seekResult;\n  ushort updatedFlag;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structAddress + 0xe));\n  if (seekResult == -1) {\n    updatedFlag = *(ushort *)(structAddress + 0xc) & 0xefff;\n  }\n  else {\n    updatedFlag = *(ushort *)(structAddress + 0xc) | 0x1000;\n  }\n  if (seekResult != -1) {\n    *(int *)(structAddress + 0x50) = seekResult;\n  }\n  *(ushort *)(structAddress + 0xc) = updatedFlag;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008449c": "update_seek_position_0008449c",
                "param_1": "fileDescriptor",
                "param_2": "structAddress",
                "iVar1": "seekResult",
                "uVar2": "updatedFlag"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "close_file_000844bc",
            "code": "\nvoid closeFile_000844bc(undefined4 fileDescriptor,int memoryAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(memoryAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "close_file_000844bc",
                "param_1": "fileDescriptor",
                "param_2": "memoryAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844c4": {
            "entrypoint": "0x000844c4",
            "current_name": "decode_and_write_byte_000844c4",
            "code": "\nuint decode_and_write_byte_000844c4(int file_ptr,uint byte_value,undefined4 *stream_ptr,undefined4 stream_length)\n\n{\n  ushort stream_flags;\n  uint stream_flags_as_int;\n  undefined *write_ptr;\n  int file_offset;\n  \n  if ((file_ptr != 0) && (*(int *)(file_ptr + 0x38) == 0)) {\n    initialize_stream();\n  }\n  stream_flags = *(ushort *)(stream_ptr + 3);\n  stream_flags_as_int = (uint)stream_flags;\n  stream_ptr[2] = stream_ptr[6];\n  if ((-1 < (int)(stream_flags_as_int << 0x1c)) || (file_offset = stream_ptr[4], file_offset == 0)) {\n    file_offset = setup_stream(file_ptr,stream_ptr,stream_flags,stream_flags_as_int,stream_length);\n    if (file_offset != 0) {\n      return 0xffffffff;\n    }\n    stream_flags = *(ushort *)(stream_ptr + 3);\n    file_offset = stream_ptr[4];\n    stream_flags_as_int = (uint)stream_flags;\n  }\n  byte_value = byte_value & 0xff;\n  if ((int)(stream_flags_as_int << 0x12) < 0) {\n    write_ptr = (undefined *)*stream_ptr;\n    file_offset = (int)write_ptr - file_offset;\n    if (file_offset < (int)stream_ptr[5]) {\nLAB_000844f6:\n      file_offset = file_offset + 1;\n      goto LAB_000844f8;\n    }\n  }\n  else {\n    stream_ptr[0x19] = stream_ptr[0x19] & 0xffffdfff;\n    write_ptr = (undefined *)*stream_ptr;\n    *(ushort *)(stream_ptr + 3) = stream_flags | 0x2000;\n    file_offset = (int)write_ptr - file_offset;\n    if (file_offset < (int)stream_ptr[5]) goto LAB_000844f6;\n  }\n  file_offset = flush_stream(file_ptr,stream_ptr);\n  if (file_offset != 0) {\n    return 0xffffffff;\n  }\n  write_ptr = (undefined *)*stream_ptr;\n  file_offset = 1;\nLAB_000844f8:\n  stream_ptr[2] = stream_ptr[2] + -1;\n  *stream_ptr = write_ptr + 1;\n  *write_ptr = (char)byte_value;\n  if (((stream_ptr[5] == file_offset) ||\n      (((int)((uint)*(ushort *)(stream_ptr + 3) << 0x1f) < 0 && (byte_value == 10)))) &&\n     (file_offset = flush_stream(file_ptr,stream_ptr), file_offset != 0)) {\n    return 0xffffffff;\n  }\n  return byte_value;\n}\n\n",
            "renaming": {
                "FUN_000844c4": "decode_and_write_byte_000844c4",
                "param_1": "file_ptr",
                "param_2": "byte_value",
                "param_3": "stream_ptr",
                "param_4": "stream_length",
                "uVar1": "stream_flags",
                "uVar2": "stream_flags_as_int",
                "puVar3": "write_ptr",
                "iVar4": "file_offset",
                "__sinit": "initialize_stream",
                "__swsetup_r": "setup_stream",
                "_fflush_r": "flush_stream"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008456c": {
            "entrypoint": "0x0008456c",
            "current_name": "convert_to_character_0008456c",
            "code": "\nvoid convertToCharacter_0008456c(undefined4 *outputString,int inputLength,undefined4 conversionFlag,undefined4 *errorFlag)\n\n{\n  code *conversionFunction;\n  undefined4 charset;\n  int result;\n  undefined tempBuffer [12];\n  \n  conversionFunction = __wctomb;\n  if (inputLength == 0) {\n    charset = __locale_charset();\n    result = (*conversionFunction)(outputString,tempBuffer,0,charset,errorFlag);\n  }\n  else {\n    charset = __locale_charset();\n    result = (*conversionFunction)(outputString,inputLength,conversionFlag,charset,errorFlag);\n  }\n  if (result == -1) {\n    *errorFlag = 0;\n    *outputString = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008456c": "convert_to_character_0008456c",
                "param_1": "outputString",
                "param_2": "inputLength",
                "param_3": "conversionFlag",
                "param_4": "errorFlag",
                "pcVar1": "conversionFunction",
                "uVar2": "charset",
                "iVar3": "result",
                "auStack_24": "tempBuffer"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__locale_charset",
                "__ascii_wctomb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845bc": {
            "entrypoint": "0x000845bc",
            "current_name": "write_integer_to_memory_000845bc",
            "code": "\nundefined4 write_integer_to_memory_000845bc(undefined4 *memory_address,undefined *value,uint integer)\n\n{\n  if (value == (undefined *)0x0) {\n    return 0;\n  }\n  if (integer < 0x100) {\n    *value = (char)integer;\n    return 1;\n  }\n  *memory_address = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000845bc": "write_integer_to_memory_000845bc",
                "param_1": "memory_address",
                "param_2": "value",
                "param_3": "integer"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845d8": {
            "entrypoint": "0x000845d8",
            "current_name": "write_to_stream_000845d8",
            "code": "\nvoid writeToStream_000845d8(int *errorFlag,int streamDescriptor,char *data,int size)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(streamDescriptor,data,size);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000845d8": "write_to_stream_000845d8",
                "param_1": "errorFlag",
                "param_2": "streamDescriptor",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084600": {
            "entrypoint": "0x00084600",
            "current_name": "close_file_00084600",
            "code": "\nvoid closeFile_00084600(int *error,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errorNumber = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errorNumber != 0)) {\n    *error = errorNumber;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084600": "close_file_00084600",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "errno": "errorNumber",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084624": {
            "entrypoint": "0x00084624",
            "current_name": "flush_file_and_free_resources_00084624",
            "code": "\nundefined4 flushFileAndFreeResources_00084624(int fileHandle,int stream)\n\n{\n  undefined4 result;\n  int status;\n  \n  if (stream != 0) {\n    if ((fileHandle != 0) && (*(int *)(fileHandle + 0x38) == 0)) {\n      __sinit();\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      result = _fflush_r(fileHandle,stream);\n      if ((*(code **)(stream + 0x2c) != (code *)0x0) &&\n         (status = (**(code **)(stream + 0x2c))(fileHandle,*(undefined4 *)(stream + 0x1c)), status < 0)\n         ) {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x18) < 0) {\n        _free_r(fileHandle,*(undefined4 *)(stream + 0x10));\n      }\n      if (*(int *)(stream + 0x30) != 0) {\n        if (*(int *)(stream + 0x30) != stream + 0x40) {\n          _free_r(fileHandle);\n        }\n        *(undefined4 *)(stream + 0x30) = 0;\n      }\n      if (*(int *)(stream + 0x44) != 0) {\n        _free_r(fileHandle);\n        *(undefined4 *)(stream + 0x44) = 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(stream + 0xc) = 0;\n      __sfp_lock_release();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084624": "flush_file_and_free_resources_00084624",
                "param_1": "fileHandle",
                "param_2": "stream",
                "uVar1": "result",
                "iVar2": "status"
            },
            "calling": [
                "fclose"
            ],
            "called": [
                "__sfp_lock_release",
                "_free_r",
                "__sfp_lock_acquire",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846a4": {
            "entrypoint": "0x000846a4",
            "current_name": "close_file_000846a4",
            "code": "\nint closeFile_000846a4(FILE *file)\n\n{\n  int result;\n  \n  result = _fclose_r(_impure_ptr,file);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000846a4": "close_file_000846a4",
                "__stream": "file",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_fclose_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846b4": {
            "entrypoint": "0x000846b4",
            "current_name": "get_file_status_000846b4",
            "code": "\nvoid get_file_status_000846b4(int *error_code,int file_descriptor,stat *stat_buffer)\n\n{\n  int status;\n  \n  system_error = 0;\n  status = _fstat(file_descriptor,stat_buffer);\n  if ((status == -1) && (system_error != 0)) {\n    *error_code = system_error;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000846b4": "get_file_status_000846b4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "stat_buffer",
                "iVar1": "status",
                "errno": "system_error"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846dc": {
            "entrypoint": "0x000846dc",
            "current_name": "check_terminal_io_status_000846dc",
            "code": "\nvoid checkTerminalIOStatus_000846dc(int *errorCode,int fileDescriptor)\n\n{\n  int terminalStatus;\n  \n  errorNumber = 0;\n  terminalStatus = _isatty(fileDescriptor);\n  if ((terminalStatus == -1) && (errorNumber != 0)) {\n    *errorCode = errorNumber;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000846dc": "check_terminal_io_status_000846dc",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "terminalStatus",
                "errno": "errorNumber"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084700": {
            "entrypoint": "0x00084700",
            "current_name": "set_file_pointer_00084700",
            "code": "\nvoid setFilePointer_00084700(int *errorCode,int fileDescriptor,__off_t offset,int origin)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,origin);\n  if ((result == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084700": "set_file_pointer_00084700",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084728": {
            "entrypoint": "0x00084728",
            "current_name": "read_into_buffer_00084728",
            "code": "\nvoid readIntoBuffer_00084728(int *error,int fileDescriptor,char *buffer,int bufferSize)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,bufferSize);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084728": "read_into_buffer_00084728",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "bufferSize",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084750": {
            "entrypoint": "0x00084750",
            "current_name": "divmod_00084750",
            "code": "\nvoid divmod_00084750(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend);\n    return;\n  }\n  __gnu_uldivmod_00084750_helper();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084750": "divmod_00084750",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__gnu_uldivmod_helper",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008477c": {
            "entrypoint": "0x0008477c",
            "current_name": "subtract_values_0008477c",
            "code": "\nvoid subtractValues_0008477c(uint value1,int value2,undefined4 param3,undefined4 param4,int *resultArray)\n\n{\n  uint result;\n  longlong product;\n  \n  product = __divdi3();\n  product = product * CONCAT44(param4,param3);\n  result = (uint)product;\n  *resultArray = value1 - result;\n  resultArray[1] = (value2 - (int)((ulonglong)product >> 0x20)) - (uint)(value1 < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008477c": "subtract_values_0008477c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "resultArray",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [],
            "called": [
                "__divdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000847ac": {
            "entrypoint": "0x000847ac",
            "current_name": "subtract_and_assign_000847ac",
            "code": "\nvoid subtractAndAssign_000847ac(uint inputParam,int count,undefined4 low,undefined4 high,int *outputParams)\n\n{\n  uint result;\n  longlong product;\n  \n  product = __udivdi3();\n  product = product * CONCAT44(high,low);\n  result = (uint)product;\n  *outputParams = inputParam - result;\n  outputParams[1] = (count - (int)((ulonglong)product >> 0x20)) - (uint)(inputParam < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000847ac": "subtract_and_assign_000847ac",
                "param_1": "inputParam",
                "param_2": "count",
                "param_3": "low",
                "param_4": "high",
                "param_5": "outputParams",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [
                "__udivdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000847dc": {
            "entrypoint": "0x000847dc",
            "current_name": "FUNC_000847dc",
            "code": "\nvoid FUNC_000847dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000847dc": "FUNC_000847dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000847e0": {
            "entrypoint": "0x000847e0",
            "current_name": "calculate_quotient_remainder_000847e0",
            "code": "\nundefined8 calculateQuotientRemainder_000847e0(uint dividend,uint dividend_upper,uint divisor,uint divisor_upper)\n\n{\n  longlong multiplication_result;\n  uint temp_quotient_combined;\n  uint temp_quotient_upper;\n  uint temp_quotient_lower;\n  uint temp_divisor_shifted;\n  int shift_amount;\n  uint temp_divisor;\n  uint temp_multiplication_result;\n  uint temp_temp_quotient_combined;\n  uint remainder_combined;\n  uint temp_multiplication_result_shifted;\n  uint temp_temp_quotient_upper;\n  bool carry_flag;\n  \n  if ((int)dividend_upper < 0) {\n    carry_flag = dividend != 0;\n    dividend = -dividend;\n    dividend_upper = -dividend_upper - (uint)carry_flag;\n    temp_temp_quotient_combined = 0xffffffff;\n  }\n  else {\n    temp_temp_quotient_combined = 0;\n  }\n  if ((int)divisor_upper < 0) {\n    temp_temp_quotient_combined = ~temp_temp_quotient_combined;\n    carry_flag = divisor != 0;\n    divisor = -divisor;\n    divisor_upper = -divisor_upper - (uint)carry_flag;\n  }\n  if (divisor_upper == 0) {\n    if (dividend_upper < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount != 0) {\n        temp_quotient_upper = dividend >> (0x20U - shift_amount & 0xff);\n        divisor = divisor << shift_amount;\n        dividend = dividend << shift_amount;\n        dividend_upper = dividend_upper << shift_amount | temp_quotient_upper;\n      }\n      temp_quotient_combined = divisor >> 0x10;\n      temp_quotient_lower = dividend_upper / temp_quotient_combined;\n      temp_divisor = (divisor & 0xffff) * temp_quotient_lower;\n      remainder_combined = dividend >> 0x10 | (dividend_upper - temp_quotient_combined * temp_quotient_lower) * 0x10000;\n      temp_quotient_upper = temp_quotient_lower;\n      if (remainder_combined <= temp_divisor && temp_divisor - remainder_combined != 0) {\n        carry_flag = CARRY4(remainder_combined,divisor);\n        remainder_combined = remainder_combined + divisor;\n        temp_quotient_upper = temp_quotient_lower - 1;\n        if ((carry_flag == false) && (remainder_combined <= temp_divisor && temp_divisor - remainder_combined != 0)) {\n          temp_quotient_upper = temp_quotient_lower - 2;\n          remainder_combined = remainder_combined + divisor;\n        }\n      }\n      temp_multiplication_result = (remainder_combined - temp_divisor) / temp_quotient_combined;\n      temp_quotient_lower = (divisor & 0xffff) * temp_multiplication_result;\n      temp_divisor = dividend & 0xffff | ((remainder_combined - temp_divisor) - temp_quotient_combined * temp_multiplication_result) * 0x10000;\n      temp_quotient_combined = temp_multiplication_result;\n      if (temp_divisor <= temp_quotient_lower && temp_quotient_lower - temp_divisor != 0) {\n        temp_quotient_combined = temp_multiplication_result - 1;\n        if ((CARRY4(temp_divisor,divisor) == false) &&\n           (temp_divisor + divisor <= temp_quotient_lower && temp_quotient_lower - (temp_divisor + divisor) != 0)) {\n          temp_quotient_combined = temp_multiplication_result - 2;\n        }\n      }\n      temp_quotient_combined = temp_quotient_combined | temp_quotient_upper << 0x10;\n      temp_quotient_upper = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        dividend_upper = dividend_upper - divisor;\n        temp_quotient_lower = divisor >> 0x10;\n        temp_temp_quotient_upper = divisor & 0xffff;\n        temp_quotient_upper = 1;\n      }\n      else {\n        divisor = divisor << shift_amount;\n        temp_quotient_upper = dividend_upper >> (0x20U - shift_amount & 0xff);\n        temp_quotient_lower = divisor >> 0x10;\n        remainder_combined = temp_quotient_upper / temp_quotient_lower;\n        temp_temp_quotient_upper = divisor & 0xffff;\n        temp_divisor = temp_temp_quotient_upper * remainder_combined;\n        temp_multiplication_result = dividend >> (0x20U - shift_amount & 0xff) | dividend_upper << shift_amount;\n        temp_quotient_upper = temp_multiplication_result >> 0x10 | (temp_quotient_upper - temp_quotient_lower * remainder_combined) * 0x10000;\n        dividend = dividend << shift_amount;\n        temp_quotient_combined = remainder_combined;\n        if (temp_quotient_upper <= temp_divisor && temp_divisor - temp_quotient_upper != 0) {\n          carry_flag = CARRY4(temp_quotient_upper,divisor);\n          temp_quotient_upper = temp_quotient_upper + divisor;\n          temp_quotient_combined = remainder_combined - 1;\n          if ((carry_flag == false) && (temp_quotient_upper <= temp_divisor && temp_divisor - temp_quotient_upper != 0)) {\n            temp_quotient_combined = remainder_combined - 2;\n            temp_quotient_upper = temp_quotient_upper + divisor;\n          }\n        }\n        temp_divisor_shifted = (temp_quotient_upper - temp_divisor) / temp_quotient_lower;\n        remainder_combined = temp_temp_quotient_upper * temp_divisor_shifted;\n        dividend_upper = temp_multiplication_result & 0xffff | ((temp_quotient_upper - temp_divisor) - temp_quotient_lower * temp_divisor_shifted) * 0x10000;\n        temp_quotient_upper = temp_divisor_shifted;\n        if (dividend_upper <= remainder_combined && remainder_combined - dividend_upper != 0) {\n          carry_flag = CARRY4(dividend_upper,divisor);\n          dividend_upper = dividend_upper + divisor;\n          temp_quotient_upper = temp_divisor_shifted - 1;\n          if ((carry_flag == false) && (dividend_upper <= remainder_combined && remainder_combined - dividend_upper != 0)) {\n            temp_quotient_upper = temp_divisor_shifted - 2;\n            dividend_upper = dividend_upper + divisor;\n          }\n        }\n        dividend_upper = dividend_upper - remainder_combined;\n        temp_quotient_upper = temp_quotient_upper | temp_quotient_combined << 0x10;\n      }\n      temp_quotient_combined = dividend_upper / temp_quotient_lower;\n      remainder_combined = temp_temp_quotient_upper * temp_quotient_combined;\n      temp_multiplication_result = dividend >> 0x10 | (dividend_upper - temp_quotient_lower * temp_quotient_combined) * 0x10000;\n      temp_divisor = temp_quotient_combined;\n      if (temp_multiplication_result <= remainder_combined && remainder_combined - temp_multiplication_result != 0) {\n        carry_flag = CARRY4(temp_multiplication_result,divisor);\n        temp_multiplication_result = temp_multiplication_result + divisor;\n        temp_divisor = temp_quotient_combined - 1;\n        if ((carry_flag == false) && (temp_multiplication_result <= remainder_combined && remainder_combined - temp_multiplication_result != 0)) {\n          temp_divisor = temp_quotient_combined - 2;\n          temp_multiplication_result = temp_multiplication_result + divisor;\n        }\n      }\n      temp_divisor_shifted = (temp_multiplication_result - remainder_combined) / temp_quotient_lower;\n      temp_temp_quotient_upper = temp_temp_quotient_upper * temp_divisor_shifted;\n      temp_quotient_lower = dividend & 0xffff | ((temp_multiplication_result - remainder_combined) - temp_quotient_lower * temp_divisor_shifted) * 0x10000;\n      temp_quotient_combined = temp_divisor_shifted;\n      if (temp_quotient_lower <= temp_temp_quotient_upper && temp_temp_quotient_upper - temp_quotient_lower != 0) {\n        temp_quotient_combined = temp_divisor_shifted - 1;\n        if ((CARRY4(temp_quotient_lower,divisor) == false) &&\n           (temp_quotient_lower + divisor <= temp_temp_quotient_upper && temp_temp_quotient_upper - (temp_quotient_lower + divisor) != 0)) {\n          temp_quotient_combined = temp_divisor_shifted - 2;\n        }\n      }\n      temp_quotient_combined = temp_quotient_combined | temp_divisor << 0x10;\n    }\n  }\n  else if (dividend_upper < divisor_upper) {\n    temp_quotient_upper = 0;\n    temp_quotient_combined = 0;\n  }\n  else {\n    shift_amount = LZCOUNT(divisor_upper);\n    if (shift_amount == 0) {\n      if ((divisor_upper < dividend_upper) || (divisor <= dividend)) {\n        temp_quotient_upper = 0;\n        temp_quotient_combined = 1;\n      }\n      else {\n        temp_quotient_combined = 0;\n        temp_quotient_upper = 0;\n      }\n    }\n    else {\n      temp_quotient_upper = 0x20 - shift_amount;\n      temp_quotient_lower = dividend_upper >> (temp_quotient_upper & 0xff);\n      temp_temp_quotient_upper = divisor >> (temp_quotient_upper & 0xff) | divisor_upper << shift_amount;\n      remainder_combined = temp_temp_quotient_upper >> 0x10;\n      temp_quotient_combined = temp_quotient_lower / remainder_combined;\n      temp_multiplication_result = (temp_temp_quotient_upper & 0xffff) * temp_quotient_combined;\n      temp_divisor = dividend_upper << shift_amount | dividend >> (temp_quotient_upper & 0xff);\n      temp_quotient_lower = temp_divisor >> 0x10 | (temp_quotient_lower - remainder_combined * temp_quotient_combined) * 0x10000;\n      temp_quotient_upper = temp_quotient_combined;\n      if (temp_quotient_lower <= temp_multiplication_result && temp_multiplication_result - temp_quotient_lower != 0) {\n        carry_flag = CARRY4(temp_quotient_lower,temp_temp_quotient_upper);\n        temp_quotient_lower = temp_quotient_lower + temp_temp_quotient_upper;\n        temp_quotient_upper = temp_quotient_combined - 1;\n        if ((carry_flag == false) && (temp_quotient_lower <= temp_multiplication_result && temp_multiplication_result - temp_quotient_lower != 0)) {\n          temp_quotient_upper = temp_quotient_combined - 2;\n          temp_quotient_lower = temp_quotient_lower + temp_temp_quotient_upper;\n        }\n      }\n      temp_divisor_shifted = (temp_quotient_lower - temp_multiplication_result) / remainder_combined;\n      temp_multiplication_result_shifted = (temp_temp_quotient_upper & 0xffff) * temp_divisor_shifted;\n      temp_quotient_lower = temp_divisor & 0xffff | ((temp_quotient_lower - temp_multiplication_result) - remainder_combined * temp_divisor_shifted) * 0x10000;\n      temp_quotient_combined = temp_divisor_shifted;\n      if (temp_quotient_lower <= temp_multiplication_result_shifted && temp_multiplication_result_shifted - temp_quotient_lower != 0) {\n        carry_flag = CARRY4(temp_quotient_lower,temp_temp_quotient_upper);\n        temp_quotient_lower = temp_quotient_lower + temp_temp_quotient_upper;\n        temp_quotient_combined = temp_divisor_shifted - 1;\n        if ((carry_flag == false) && (temp_quotient_lower <= temp_multiplication_result_shifted && temp_multiplication_result_shifted - temp_quotient_lower != 0)) {\n          temp_quotient_combined = temp_divisor_shifted - 2;\n          temp_quotient_lower = temp_quotient_lower + temp_temp_quotient_upper;\n        }\n      }\n      temp_quotient_combined = temp_quotient_combined | temp_quotient_upper << 0x10;\n      multiplication_result = (ulonglong)temp_quotient_combined * (ulonglong)(divisor << shift_amount);\n      temp_divisor = (uint)((ulonglong)multiplication_result >> 0x20);\n      temp_quotient_upper = 0;\n      if ((temp_quotient_lower - temp_multiplication_result_shifted < temp_divisor) ||\n         ((temp_quotient_lower - temp_multiplication_result_shifted == temp_divisor && (dividend << shift_amount < (uint)multiplication_result)))) {\n        temp_quotient_combined = temp_quotient_combined - 1;\n        temp_quotient_upper = 0;\n      }\n    }\n  }\n  if (temp_temp_quotient_combined != 0) {\n    carry_flag = temp_quotient_combined != 0;\n    temp_quotient_combined = -temp_quotient_combined;\n    temp_quotient_upper = -temp_quotient_upper - (uint)carry_flag;\n  }\n  return CONCAT44(temp_quotient_upper,temp_quotient_combined);\n}\n\n",
            "renaming": {
                "FUN_000847e0": "calculate_quotient_remainder_000847e0",
                "param_1": "dividend",
                "param_2": "dividend_upper",
                "param_3": "divisor",
                "param_4": "divisor_upper",
                "lVar1": "multiplication_result",
                "uVar2": "temp_quotient_combined",
                "uVar3": "temp_quotient_upper",
                "uVar4": "temp_quotient_lower",
                "uVar5": "temp_divisor_shifted",
                "iVar6": "shift_amount",
                "uVar7": "temp_divisor",
                "uVar8": "temp_multiplication_result",
                "uVar9": "temp_temp_quotient_combined",
                "uVar10": "remainder_combined",
                "uVar11": "temp_multiplication_result_shifted",
                "uVar12": "temp_temp_quotient_upper",
                "bVar13": "carry_flag"
            },
            "calling": [
                "__gnu_ldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084a80": {
            "entrypoint": "0x00084a80",
            "current_name": "calculate_unsigned_division_with_remainder_00084a80",
            "code": "\nulonglong calculateUnsignedDivisionWithRemainder_00084a80(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong product;\n  uint q1;\n  uint q2;\n  uint q3;\n  uint q4;\n  uint q5;\n  uint q6;\n  uint u1;\n  uint u2;\n  int bitShift;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      bitShift = leadingZeroCount(quotient);\n      if (bitShift == 0) {\n        divisor = divisor - quotient;\n        q2 = quotient >> 0x10;\n        q4 = quotient & 0xffff;\n        q1 = 1;\n      }\n      else {\n        quotient = quotient << bitShift;\n        u1 = divisor >> (0x20U - bitShift & 0xff);\n        q2 = quotient >> 0x10;\n        u2 = u1 / q2;\n        q4 = quotient & 0xffff;\n        q1 = q4 * u2;\n        q5 = dividend >> (0x20U - bitShift & 0xff) | divisor << bitShift;\n        q3 = q5 >> 0x10 | (u1 - q2 * u2) * 0x10000;\n        dividend = dividend << bitShift;\n        u1 = u2;\n        if (q3 <= q1 && q1 - q3 != 0) {\n          carryFlag = carryOverflowCheck(q3,quotient);\n          q3 = q3 + quotient;\n          u1 = u2 - 1;\n          if ((carryFlag == false) && (q3 <= q1 && q1 - q3 != 0)) {\n            u1 = u2 - 2;\n            q3 = q3 + quotient;\n          }\n        }\n        q6 = (q3 - q1) / q2;\n        u2 = q4 * q6;\n        divisor = q5 & 0xffff | ((q3 - q1) - q2 * q6) * 0x10000;\n        q1 = q6;\n        if (divisor <= u2 && u2 - divisor != 0) {\n          carryFlag = carryOverflowCheck(divisor,quotient);\n          divisor = divisor + quotient;\n          q1 = q6 - 1;\n          if ((carryFlag == false) && (divisor <= u2 && u2 - divisor != 0)) {\n            q1 = q6 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - u2;\n        q1 = q1 | u1 << 0x10;\n      }\n      u2 = divisor / q2;\n      q3 = q4 * u2;\n      q5 = dividend >> 0x10 | (divisor - q2 * u2) * 0x10000;\n      u1 = u2;\n      if (q5 <= q3 && q3 - q5 != 0) {\n        carryFlag = carryOverflowCheck(q5,quotient);\n        q5 = q5 + quotient;\n        u1 = u2 - 1;\n        if ((carryFlag == false) && (q5 <= q3 && q3 - q5 != 0)) {\n          u1 = u2 - 2;\n          q5 = q5 + quotient;\n        }\n      }\n      u2 = (q5 - q3) / q2;\n      q4 = q4 * u2;\n      q5 = dividend & 0xffff | ((q5 - q3) - q2 * u2) * 0x10000;\n      q2 = u2;\n      if (q5 <= q4 && q4 - q5 != 0) {\n        q2 = u2 - 1;\n        if ((carryOverflowCheck(q5,quotient) == false) &&\n           (q5 + quotient <= q4 && q4 - (q5 + quotient) != 0)) {\n          q2 = u2 - 2;\n        }\n      }\n      return CONCAT44(q1,q2 | u1 << 0x10);\n    }\n    bitShift = leadingZeroCount(quotient);\n    if (bitShift != 0) {\n      u1 = dividend >> (0x20U - bitShift & 0xff);\n      quotient = quotient << bitShift;\n      dividend = dividend << bitShift;\n      divisor = u1 | divisor << bitShift;\n    }\n    q1 = quotient >> 0x10;\n    q2 = divisor / q1;\n    q4 = (quotient & 0xffff) * q2;\n    u2 = dividend >> 0x10 | (divisor - q1 * q2) * 0x10000;\n    u1 = q2;\n    if (u2 <= q4 && q4 - u2 != 0) {\n      carryFlag = carryOverflowCheck(u2,quotient);\n      u2 = u2 + quotient;\n      u1 = q2 - 1;\n      if ((carryFlag == false) && (u2 <= q4 && q4 - u2 != 0)) {\n        u1 = q2 - 2;\n        u2 = u2 + quotient;\n      }\n    }\n    q5 = (u2 - q4) / q1;\n    q2 = (quotient & 0xffff) * q5;\n    q4 = dividend & 0xffff | ((u2 - q4) - q1 * q5) * 0x10000;\n    q1 = q5;\n    if (q4 <= q2 && q2 - q4 != 0) {\n      q1 = q5 - 1;\n      if ((carryOverflowCheck(q4,quotient) == false) &&\n         (q4 + quotient <= q2 && q2 - (q4 + quotient) != 0)) {\n        q1 = q5 - 2;\n      }\n    }\n    q1 = q1 | u1 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    bitShift = leadingZeroCount(remainder);\n    if (bitShift == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      q1 = 0;\n    }\n    else {\n      q1 = 0x20 - bitShift;\n      u1 = divisor >> (q1 & 0xff);\n      q2 = remainder << bitShift | quotient >> (q1 & 0xff);\n      q4 = q2 >> 0x10;\n      q3 = u1 / q4;\n      u2 = (q2 & 0xffff) * q3;\n      q5 = dividend >> (q1 & 0xff) | divisor << bitShift;\n      q1 = q5 >> 0x10 | (u1 - q4 * q3) * 0x10000;\n      u1 = q3;\n      if (q1 <= u2 && u2 - q1 != 0) {\n        carryFlag = carryOverflowCheck(q1,q2);\n        q1 = q1 + q2;\n        u1 = q3 - 1;\n        if ((carryFlag == false) && (q1 <= u2 && u2 - q1 != 0)) {\n          u1 = q3 - 2;\n          q1 = q1 + q2;\n        }\n      }\n      q3 = (q1 - u2) / q4;\n      q6 = (q2 & 0xffff) * q3;\n      q4 = q5 & 0xffff | ((q1 - u2) - q4 * q3) * 0x10000;\n      q1 = q3;\n      if (q4 <= q6 && q6 - q4 != 0) {\n        carryFlag = carryOverflowCheck(q4,q2);\n        q4 = q4 + q2;\n        q1 = q3 - 1;\n        if ((carryFlag == false) && (q4 <= q6 && q6 - q4 != 0)) {\n          q1 = q3 - 2;\n          q4 = q4 + q2;\n        }\n      }\n      q1 = q1 | u1 << 0x10;\n      product = (ulonglong)q1 * (ulonglong)(quotient << bitShift);\n      u1 = (uint)((ulonglong)product >> 0x20);\n      if ((q4 - q6 < u1) || ((q4 - q6 == u1 && (dividend << bitShift < (uint)product)))\n         ) {\n        q1 = q1 - 1;\n      }\n    }\n  }\n  return (ulonglong)q1;\n}\n\n",
            "renaming": {
                "FUN_00084a80": "calculate_unsigned_division_with_remainder_00084a80",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "product",
                "uVar2": "q1",
                "uVar3": "q2",
                "uVar4": "q3",
                "uVar5": "q4",
                "uVar6": "q5",
                "uVar7": "q6",
                "uVar8": "u1",
                "uVar9": "u2",
                "iVar10": "bitShift",
                "bVar11": "carryFlag",
                "LZCOUNT": "leadingZeroCount",
                "CARRY4": "carryOverflowCheck"
            },
            "calling": [
                "__gnu_uldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085858": {
            "entrypoint": "0x00085858",
            "current_name": "FUNC_00085858",
            "code": "\nvoid FUNC_00085858(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085858": "FUNC_00085858"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00085874": {
            "entrypoint": "0x00085874",
            "current_name": "FUNC_00085874",
            "code": "\nvoid FUNC_00085874(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085874": "FUNC_00085874"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_20070000": {
            "entrypoint": "0x20070000",
            "current_name": "disable_interrupts_20070000",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_interrupts_20070000(void)\n\n{\n  disableIRQinterrupts();\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) = DAT_20070020;\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *DAT_20070028 = DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_20070000": "disable_interrupts_20070000"
            },
            "calling": [
                "tickReset",
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 115158,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080148",
            "FUN_0008014c",
            "FUN_00080164",
            "FUN_000801b0",
            "FUN_0008021c",
            "FUN_00080258",
            "FUN_000802da",
            "FUN_000803d4",
            "FUN_00080410",
            "FUN_0008043e",
            "FUN_000804a8",
            "FUN_000805d0",
            "FUN_00080a68",
            "FUN_00080aac",
            "FUN_00080ac0",
            "FUN_00080acc",
            "FUN_00080ad8",
            "FUN_00080ae4",
            "FUN_00080c0c",
            "FUN_00080ce0",
            "FUN_00080d24",
            "FUN_00080d2e",
            "FUN_00080d54",
            "FUN_00080d7a",
            "FUN_00080da0",
            "FUN_00080e04",
            "FUN_00080e18",
            "FUN_00080e5c",
            "FUN_00080e9c",
            "FUN_00080f24",
            "FUN_00080f9c",
            "FUN_00081034",
            "FUN_00081042",
            "FUN_0008105c",
            "FUN_00081066",
            "FUN_0008106e",
            "FUN_00081074",
            "FUN_00081084",
            "FUN_000810bc",
            "FUN_000810f4",
            "FUN_0008112c",
            "FUN_00081164",
            "FUN_00081166",
            "FUN_0008116a",
            "FUN_0008116e",
            "FUN_00081184",
            "FUN_00081188",
            "FUN_0008118c",
            "FUN_000811a8",
            "FUN_000811ae",
            "FUN_000811b4",
            "FUN_000811be",
            "FUN_000811c2",
            "FUN_000811c6",
            "FUN_000811cc",
            "FUN_000811f0",
            "FUN_00081202",
            "FUN_00081208",
            "FUN_00081210",
            "FUN_00081318",
            "FUN_00081388",
            "FUN_000813a8",
            "FUN_000813c2",
            "FUN_000813e0",
            "FUN_000813e4",
            "FUN_000813f6",
            "FUN_00081412",
            "FUN_0008143c",
            "FUN_00081454",
            "FUN_000814a8",
            "FUN_000814e4",
            "FUN_00081508",
            "FUN_00081578",
            "FUN_00081580",
            "FUN_000815ca",
            "FUN_000815d4",
            "FUN_000815f8",
            "FUN_000815fe",
            "FUN_0008160c",
            "FUN_00081622",
            "FUN_0008163a",
            "FUN_0008165c",
            "FUN_00081682",
            "FUN_000816a8",
            "FUN_000816d4",
            "FUN_000816e0",
            "FUN_00081704",
            "FUN_00081714",
            "FUN_00081720",
            "FUN_00081728",
            "FUN_00081730",
            "FUN_00081734",
            "FUN_00081894",
            "FUN_0008189c",
            "FUN_000818b8",
            "FUN_000818c8",
            "FUN_00081944",
            "FUN_00081aac",
            "FUN_00081be4",
            "FUN_00081bec",
            "FUN_00081bf4",
            "FUN_00081c54",
            "FUN_00081c5c",
            "FUN_00081c6c",
            "FUN_00081c80",
            "FUN_00081c94",
            "FUN_00081ca8",
            "FUN_00081cbc",
            "FUN_00081cd0",
            "FUN_00081d1c",
            "FUN_00081d5c",
            "FUN_00081d68",
            "FUN_00081d7c",
            "FUN_00081dcc",
            "FUN_00081df4",
            "FUN_00081e04",
            "FUN_00081e14",
            "FUN_0008234c",
            "FUN_00082438",
            "FUN_00082504",
            "FUN_000825a0",
            "FUN_000825b0",
            "FUN_00082970",
            "FUN_00082994",
            "FUN_00082a50",
            "FUN_00082ab0",
            "FUN_00082ac0",
            "FUN_00082b38",
            "FUN_0008378c",
            "FUN_00083808",
            "FUN_000838cc",
            "FUN_00083988",
            "FUN_00083994",
            "FUN_00083adc",
            "FUN_00083b08",
            "FUN_00083b14",
            "FUN_00083c10",
            "FUN_00083c40",
            "FUN_00083d00",
            "FUN_00083d9c",
            "FUN_00083f34",
            "FUN_00084248",
            "FUN_00084290",
            "FUN_00084298",
            "FUN_000842a4",
            "FUN_00084384",
            "FUN_00084418",
            "FUN_00084440",
            "FUN_00084464",
            "FUN_0008449c",
            "FUN_000844bc",
            "FUN_000844c4",
            "FUN_0008456c",
            "FUN_000845bc",
            "FUN_000845d8",
            "FUN_00084600",
            "FUN_00084624",
            "FUN_000846a4",
            "FUN_000846b4",
            "FUN_000846dc",
            "FUN_00084700",
            "FUN_00084728",
            "FUN_00084750",
            "FUN_0008477c",
            "FUN_000847ac",
            "FUN_000847e0",
            "FUN_00084a80",
            "FUN_20070000"
        ]
    ],
    "locked_functions": []
}