{
    "functions": {
        "FUN_080006b4": {
            "renaming": {
                "FUN_080006b4": "receive_data_080006b4",
                "this": "self",
                "bVar1": "buffer_full",
                "iVar2": "character",
                "bVar3": "buffer_index",
                "u8txenpin": "transmission_enable_pin",
                "u8BufferSize": "buffer_size",
                "u8serno": "serial_number",
                "au8Buffer": "buffer",
                "u16InCnt": "input_count",
                "u16errCnt": "error_count"
            },
            "code": "int8_t __thiscall receive_data_080006b4(Modbus *self) {\n    bool buffer_full = false;\n    int character;\n    byte buffer_index;\n    if (self->transmission_enable_pin > 1) {\n        digitalWrite((uint)self->transmission_enable_pin, LOW);\n    }\n    self->buffer_size = 0;\n    if (self->serial_number < 4) {\n        while (character = (*(self->port->super_Stream).super_Print._vptr_Print[2])(), character != 0) {\n            buffer_index = self->buffer_size;\n            character = (*(self->port->super_Stream).super_Print._vptr_Print[3])();\n            self->buffer[buffer_index] = (uint8_t)character;\n            buffer_index = self->buffer_size + 1;\n            self->buffer_size = buffer_index;\n            if (buffer_index > 63) {\n                buffer_full = true;\n            }\n        }\n    }\n    if (buffer_full) {\n        self->error_count++;\n        return -3;\n    }\n    self->input_count++;\n    return self->buffer_size;\n}",
            "called": [
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006b4",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "receive_data_080006b4"
        },
        "FUN_080034da": {
            "renaming": {
                "FUN_080034da": "find_peripheral_from_pin_080034da",
                "pin": "pin",
                "map": "pin_map",
                "PinName_conflict": "PinName_conflict",
                "PinMap_conflict": "PinMap_conflict",
                "NC": "NC",
                "(void *)0x0": "(void *)0x0",
                "peripheral": "peripheral"
            },
            "code": "void * find_peripheral_from_pin_080034da(PinName_conflict pin, PinMap_conflict *pin_map) {\n  while(true) {\n    if (pin_map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (pin_map->pin == pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return pin_map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034da",
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_from_pin_080034da"
        },
        "FUN_080035fc": {
            "renaming": {
                "FUN_080035fc": "set_timer_bit_080035fc",
                "*htim": "*timer_handle",
                "Instance": "timer_handle->Instance",
                "DAT_08003718": "0x08003718",
                "DAT_0800371C": "0x0800371C",
                "DAT_08003720": "0x08003720",
                "DAT_08003724": "0x08003724",
                "DAT_08003728": "0x08003728",
                "DAT_0800372C": "0x0800372C",
                "DAT_08003730": "0x08003730",
                "DAT_08003734": "0x08003734",
                "DAT_08003738": "0x08003738",
                "DAT_0800373C": "0x0800373C",
                "DAT_08003740": "0x08003740",
                "DAT_08003744": "0x08003744",
                "DAT_08003748": "0x08003748",
                "uint": "uint32_t",
                "*(uint *)": "*(uint32_t *)",
                "&= 0xfffffffe": "&= ~(1 << 0x01)",
                "&= 0xfffffffd": "&= ~(1 << 0x01); *timer_reg |= (1 << 0x01)",
                "&= 0xfffffffb": "&= ~(1 << 0x01); *timer_reg |= (1 << 0x02)",
                "&= 0xfffffff7": "&= ~(1 << 0x01); *timer_reg |= (1 << 0x03)",
                "&= 0xffffffef": "&= ~(1 << 0x01); *timer_reg |= (1 << 0x04)",
                "&= 0xffffffdf": "&= ~(1 << 0x01); *timer_reg |= (1 << 0x05)",
                "&= 0xfffeffff": "&= ~(1 << 0x10)",
                "&= 0xfffdffff": "&= ~(1 << 0x0F)",
                "&= 0xfffbffff": "&= ~(1 << 0x0D)",
                "&= 0xffffffbf": "&= ~(1 << 0x06)",
                "&= 0xffffff7f": "&= ~(1 << 0x07)",
                "&= 0xfffffeff": "&= ~(1 << 0x08)"
            },
            "code": "void set_timer_bit_080035fc(TIM_HandleTypeDef *timer_handle)\n{\n    uint32_t *timer_reg = (uint32_t *)0x0800374C;\n    switch((uint32_t)timer_handle->Instance)\n    {\n        case DAT_08003718:\n            *timer_reg &= ~(1 << 0x01);\n            break;\n        case 0x40000000:\n            *timer_reg &= ~(1 << 0x00);\n            break;\n        case DAT_0800371C:\n            *timer_reg &= ~(1 << 0x01);\n            *timer_reg |= (1 << 0x00);\n            break;\n        case DAT_08003720:\n            *timer_reg &= ~(1 << 0x01);\n            *timer_reg |= (1 << 0x02);\n            break;\n        case DAT_08003724:\n            *timer_reg &= ~(1 << 0x01);\n            *timer_reg |= (1 << 0x03);\n            break;\n        case DAT_08003728:\n            *timer_reg &= ~(1 << 0x01);\n            *timer_reg |= (1 << 0x04);\n            break;\n        case DAT_0800372C:\n            *timer_reg &= ~(1 << 0x01);\n            *timer_reg |= (1 << 0x05);\n            break;\n        case DAT_08003730:\n            *timer_reg &= ~(1 << 0x01);\n            *timer_reg |= (1 << 0x01);\n            break;\n        case DAT_08003734:\n            *timer_reg &= ~(1 << 0x10);\n            break;\n        case DAT_08003738:\n            *timer_reg &= ~(1 << 0x0F);\n            break;\n        case DAT_0800373C:\n            *timer_reg &= ~(1 << 0x0D);\n            break;\n        case DAT_08003740:\n            *timer_reg &= ~(1 << 0x06);\n            break;\n        case DAT_08003744:\n            *timer_reg &= ~(1 << 0x07);\n            break;\n        case DAT_08003748:\n            *timer_reg &= ~(1 << 0x08);\n            break;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035fc",
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "imported": false,
            "current_name": "set_timer_bit_080035fc"
        },
        "FUN_08003dd0": {
            "renaming": {
                "FUN_08003dd0": "is_uart_transmitting_08003dd0",
                "obj": "serial",
                "HVar1": "uart_state",
                "PTR_uart_handlers_08003df0": "PTR_uart_handlers",
                "uint8_t": "bool"
            },
            "code": "bool is_uart_transmitting_08003dd0(serial_t *serial) {\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003df0_08003df0 + (uint)serial->index * 4));\n  return (uart_state & 0x22U) == 0x22;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003dd0",
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "is_uart_transmitting_08003dd0"
        },
        "FUN_08000c8c": {
            "renaming": {
                "FUN_08000c8c": "configure_clocks_08000c8c",
                "DAT_08000d30": "ptr_data_1",
                "DAT_08000d34": "ptr_data_2",
                "DAT_08000d38": "ptr_data_3",
                "RCC_OscInitTypeDef": "osc_init",
                "RCC_ClkInitTypeDef": "clk_init",
                "RCC_OscInitStruct": "osc_init",
                "RCC_ClkInitStruct": "clk_init",
                "RCC_OscInitStruct.OscillatorType": "osc_init.OscillatorType",
                "RCC_OscInitStruct.HSEState": "osc_init.HSEState",
                "RCC_OscInitStruct.PLL.PLLState": "osc_init.PLL.PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "osc_init.PLL.PLLSource",
                "RCC_OscInitStruct.PLL.PLLM": "osc_init.PLL.PLLM",
                "RCC_OscInitStruct.PLL.PLLN": "osc_init.PLL.PLLN",
                "RCC_OscInitStruct.PLL.PLLP": "osc_init.PLL.PLLP",
                "RCC_OscInitStruct.PLL.PLLQ": "osc_init.PLL.PLLQ",
                "HAL_RCC_OscConfig": "HAL_RCC_OscConfig",
                "HAL_PWREx_EnableOverDrive": "HAL_PWREx_EnableOverDrive",
                "RCC_ClkInitStruct.ClockType": "clk_init.ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "clk_init.SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "clk_init.AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "clk_init.APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "clk_init.APB2CLKDivider",
                "HAL_RCC_ClockConfig": "HAL_RCC_ClockConfig",
                "HAL_RCC_GetSysClockFreq": "HAL_RCC_GetSysClockFreq",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "HAL_SYSTICK_CLKSourceConfig": "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "SysTick_IRQn": "SysTick_IRQn"
            },
            "code": "void configure_clocks_08000c8c(void)\n{\n  uint32_t sys_clk_freq, hclk_freq;\n  RCC_OscInitTypeDef osc_init;\n  RCC_ClkInitTypeDef clk_init;\n  // Enable HSI\n  RCC_OscInitTypeDef osc_init = {0};\n  osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  osc_init.HSIState = RCC_HSI_ON;\n  osc_init.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;\n  osc_init.PLL.PLLState = RCC_PLL_ON;\n  osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  osc_init.PLL.PLLM = 8;\n  osc_init.PLL.PLLN = 160;\n  osc_init.PLL.PLLP = RCC_PLLP_DIV2;\n  osc_init.PLL.PLLQ = 4;\n  if (HAL_RCC_OscConfig(&osc_init) != HAL_OK)\n  {\n    // Error Handler\n  }\n  // OverDrive\n  if (HAL_PWREx_EnableOverDrive() != HAL_OK)\n  {\n    // Error Handler\n  }\n  // Configure the clocks\n  clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n  clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clk_init.APB1CLKDivider = RCC_HCLK_DIV4;\n  clk_init.APB2CLKDivider = RCC_HCLK_DIV2;\n  if (HAL_RCC_ClockConfig(&clk_init, FLASH_LATENCY_5) != HAL_OK)\n  {\n    // Error Handler\n  }\n  // Get the clock frequencies\n  sys_clk_freq = HAL_RCC_GetSysClockFreq();\n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  // Configure SysTick to generate an interrupt every 1ms\n  HAL_SYSTICK_Config(sys_clk_freq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c8c",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "configure_clocks_08000c8c"
        },
        "FUN_08000a4e": {
            "renaming": {
                "FUN_08000a4e": "update_register_08000a4e",
                "this": "modbus_obj",
                "regs": "register_array",
                "u8size": "array_size",
                "uVar1": "register_address",
                "uVar2": "register_value"
            },
            "code": "int8_t __thiscall update_register_08000a4e(Modbus *modbus_obj, uint16_t *register_array, uint8_t array_size)\n{\n  uint16_t register_address;\n  uint16_t register_value;\n  register_address = makeWord(modbus_obj->au8Buffer[2], modbus_obj->au8Buffer[3]);\n  register_value = makeWord(modbus_obj->au8Buffer[4], modbus_obj->au8Buffer[5]);\n  register_array[(byte)register_address] = register_value;\n  modbus_obj->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus_obj);\n  return '\b';\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a4e",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "update_register_08000a4e"
        },
        "FUN_08004774": {
            "renaming": {
                "FUN_08004774": "handle_external_interrupt_08004774",
                "PTR_EXTI_LINE_4": "external_interrupt_line"
            },
            "code": "void handle_external_interrupt_08004774(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(PTR_EXTI_LINE_4);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004774",
            "calling": [],
            "imported": false,
            "current_name": "handle_external_interrupt_08004774"
        },
        "FUN_08004658": {
            "renaming": {
                "FUN_08004658": "run_program_08004658",
                "initVariant": "initialize_variant",
                "setup": "setup_environment",
                "loop": "execute_loop",
                "serialEventRun": "run_serial_event"
            },
            "code": "void run_program_08004658(void)\n{\n  initialize_variant();\n  setup_environment();\n  do {\n    do {\n      execute_loop();\n    } while (DAT_08004674 == 0);\n    run_serial_event();\n  } while( true );\n}",
            "called": [
                "loop",
                "initVariant",
                "setup",
                "serialEventRun"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004658",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "run_program_08004658"
        },
        "FUN_080034f4": {
            "renaming": {
                "FUN_080034f4": "find_peripheral_080034f4",
                "PinName_conflict": "pin",
                "PinMap_conflict": "map",
                "pvVar1": "peripheral_address"
            },
            "code": "void* find_peripheral_080034f4(PinName_conflict pin, PinMap_conflict* map) {\n  void* peripheral_address;\n  if (pin != NC) {\n    peripheral_address = pinmap_find_peripheral_080034f4(pin, map);\n    return peripheral_address;\n  }\n  return (void*)0x0;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034f4",
            "calling": [
                "uart_debug_init",
                "uart_init",
                "dac_stop",
                "uart_debug_write",
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "find_peripheral_080034f4"
        },
        "FUN_0800476a": {
            "renaming": {
                "FUN_0800476a": "handle_gpio_exti_interrupt_0800476a",
                "PTR_": "<unchanged>",
                "DAT_": "<unchanged>"
            },
            "code": "void handle_gpio_exti_interrupt_0800476a(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800476a",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_0800476a"
        },
        "FUN_0800355e": {
            "renaming": {
                "FUN_0800355e": "check_pin_validity_0800355e",
                "pin": "pin_name",
                "map": "pin_map",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NotConnected",
                "true": "True",
                "false": "False"
            },
            "code": "_Bool check_pin_validity_0800355e(PinName_conflict pin, PinMap_conflict *pin_map) {\n    if (pin == NC) {\n        return false;\n    }\n    while (true) {\n        if (pin_map->pin == NC) {\n            return false;\n        }\n        if (pin == pin_map->pin) {\n            break;\n        }\n        pin_map++;\n    }\n    return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800355e",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "check_pin_validity_0800355e"
        },
        "FUN_0800573c": {
            "renaming": {
                "FUN_0800573c": "read_file_0800573c",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_file_0800573c(int* error_code, int file_descriptor, char* buffer, int buffer_size) {\n    int read_result;\n    int* errno_ptr = PTR_errno_0800575c;\n    *errno_ptr = 0;\n    read_result = _read(file_descriptor, buffer, buffer_size);\n    if (read_result == -1 && *errno_ptr != 0) {\n        *error_code = *errno_ptr;\n    }\n    return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800573c",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_file_0800573c"
        },
        "FUN_08003e54": {
            "renaming": {
                "FUN_08003e54": "receive_data_08003e54",
                "obj": "serial_obj",
                "callback": "rx_callback",
                "uVar2": "rx_active",
                "bVar1": "index"
            },
            "code": "void receive_data_08003e54(serial_t *serial_obj, _func_void_serial_t_ptr *rx_callback)\n{\n    byte index;\n    uint8_t rx_active;\n\n    if (serial_obj != NULL) {\n        rx_active = serial_rx_active(serial_obj);\n        if (rx_active == 0) {\n            index = serial_obj->index;\n            *(serial_t **)(PTR_rx_callback_obj_08003ea4 + (uint)index * 4) = serial_obj;\n            *(_func_void_serial_t_ptr **)(PTR_rx_callback_08003ea0 + (uint)index * 4) = rx_callback;\n            HAL_NVIC_SetPriority(serial_obj->irq, 0, 1);\n            HAL_NVIC_EnableIRQ(serial_obj->irq);\n            HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003ea8 + (uint)serial_obj->index * 4), &serial_obj->recv, 1);\n        }\n    }\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e54",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "receive_data_08003e54"
        },
        "FUN_08004fdc": {
            "renaming": {
                "FUN_08004fdc": "format_string_08004fdc",
                "__format": "format",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "impure_ptr",
                "pcVar2": "format_string",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int format_string_08004fdc(char *format, ...)\n{\n    int impure_ptr = *(int *)PTR__impure_ptr_08005008;\n    char *format_string_08004fdc = format;\n    undefined4 arg1 = in_r1;\n    undefined4 arg2 = in_r2;\n    undefined4 arg3 = in_r3;\n    if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n        __sinit(impure_ptr);\n    }\n    int result = _vfformat_string_08004fdc_r(impure_ptr, *(undefined4 *)(impure_ptr + 8), format, &arg1, format_string_08004fdc, &arg1);\n    return result;\n}",
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004fdc",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "format_string_08004fdc"
        },
        "FUN_080056d4": {
            "renaming": {
                "FUN_080056d4": "stat_error_handler_080056d4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_stats",
                "puVar1": "errno_ptr",
                "iVar2": "stat_result"
            },
            "code": "void stat_error_handler_080056d4(int *error_code, int file_descriptor, struct stat *file_stats)\n{\n  int stat_result = 0;\n  int *errno_ptr = PTR_errno_080056f4;\n  *errno_ptr = 0;\n  stat_result = _fstat(file_descriptor, file_stats);\n  if ((stat_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056d4",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "stat_error_handler_080056d4"
        },
        "FUN_080033d8": {
            "renaming": {
                "FUN_080033d8": "dac_handle_stop_and_deinit_080033d8",
                "pin": "pin_name",
                "Channel": "channel",
                "DacHandle": "dac_handle",
                "PTR_PinMap_DAC_08003408": "PTR_PinMap_DAC_08003408",
                "DAC_TypeDef": "DAC_TypeDef",
                "get_dac_channel": "get_dac_channel"
            },
            "code": "void dac_handle_stop_and_deinit_080033d8(PinName_conflict pin)\n{\n  uint32_t channel;\n  DAC_HandleTypeDef dac_handle;\n  dac_handle.Instance = (DAC_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_DAC_08003408);\n  if ((dac_handle.Instance != (DAC_TypeDef *)0x0) && ((channel = get_dac_channel(pin), channel == 0 || (channel == 0x10)))) {\n    HAL_DAC_Stop(&dac_handle, channel);\n    HAL_DAC_DeInit(&dac_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_DAC_Stop",
                "HAL_DAC_DeInit",
                "get_dac_channel",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033d8",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "dac_handle_stop_and_deinit_080033d8"
        },
        "FUN_080029c8": {
            "renaming": {
                "FUN_080029c8": "FUNC_080029c8"
            },
            "code": "\nvoid FUNC_080029c8(UART_HandleTypeDef *huart)\n\n{\n  ulonglong uVar1;\n  uint uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  uint32_t uVar10;\n  uint32_t uVar11;\n  USART_TypeDef *pUVar12;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       huart->Instance->CR1 & 0xffff69f3 |\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       (huart->Init).OverSampling;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  if ((huart->Init).OverSampling == 0x8000) {\n    pUVar12 = huart->Instance;\n    if ((pUVar12 != (USART_TypeDef *)0x40011000) && (pUVar12 != (USART_TypeDef *)0x40011400)) {\n      uVar3 = HAL_RCC_GetPCLK1Freq();\n      uVar2 = DAT_08002d08;\n      uVar8 = (huart->Init).BaudRate;\n      uVar1 = (ulonglong)DAT_08002d08;\n      uVar4 = HAL_RCC_GetPCLK1Freq();\n      uVar9 = (huart->Init).BaudRate;\n      uVar5 = HAL_RCC_GetPCLK1Freq();\n      uVar10 = (huart->Init).BaudRate;\n      uVar6 = HAL_RCC_GetPCLK1Freq();\n      uVar11 = (huart->Init).BaudRate;\n      uVar7 = HAL_RCC_GetPCLK1Freq();\n      pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                   (ulonglong)\n                                   (((uVar6 * 0x19) / (uVar11 << 1) +\n                                    (uint)((ulonglong)uVar2 *\n                                           ((ulonglong)(uVar7 * 0x19) /\n                                           (ulonglong)((huart->Init).BaudRate << 1)) >> 0x25) * -100\n                                    ) * 8 + 0x32) >> 0x20) << 0x18) >> 0x1d) +\n                     ((uint)((ulonglong)uVar2 *\n                             (ulonglong)\n                             (((uVar4 * 0x19) / (uVar9 << 1) +\n                              (uint)((ulonglong)uVar2 *\n                                     ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 1)) >> 0x25)\n                              * -100) * 8 + 0x32) >> 0x25) & 0xf8) * 2 +\n                     (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 1)) >> 0x25) *\n                     0x10;\n      return;\n    }\n    uVar3 = HAL_RCC_GetPCLK2Freq();\n    uVar2 = DAT_08002d08;\n    uVar8 = (huart->Init).BaudRate;\n    uVar1 = (ulonglong)DAT_08002d08;\n    uVar4 = HAL_RCC_GetPCLK2Freq();\n    uVar9 = (huart->Init).BaudRate;\n    uVar5 = HAL_RCC_GetPCLK2Freq();\n    uVar10 = (huart->Init).BaudRate;\n    uVar6 = HAL_RCC_GetPCLK2Freq();\n    uVar11 = (huart->Init).BaudRate;\n    uVar7 = HAL_RCC_GetPCLK2Freq();\n    pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                 (ulonglong)\n                                 (((uVar6 * 0x19) / (uVar11 << 1) +\n                                  (uint)((ulonglong)uVar2 *\n                                         ((ulonglong)(uVar7 * 0x19) /\n                                         (ulonglong)((huart->Init).BaudRate << 1)) >> 0x25) * -100)\n                                  * 8 + 0x32) >> 0x20) << 0x18) >> 0x1d) +\n                   ((uint)((ulonglong)uVar2 *\n                           (ulonglong)\n                           (((uVar4 * 0x19) / (uVar9 << 1) +\n                            (uint)((ulonglong)uVar2 *\n                                   ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 1)) >> 0x25) *\n                            -100) * 8 + 0x32) >> 0x25) & 0xf8) * 2 +\n                   (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 1)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  pUVar12 = huart->Instance;\n  if ((pUVar12 != DAT_08002d04) && (pUVar12 != (USART_TypeDef *)&DAT_08002d04[0x24].CR2)) {\n    uVar3 = HAL_RCC_GetPCLK1Freq();\n    uVar2 = DAT_08002d08;\n    uVar8 = (huart->Init).BaudRate;\n    uVar1 = (ulonglong)DAT_08002d08;\n    uVar4 = HAL_RCC_GetPCLK1Freq();\n    uVar9 = (huart->Init).BaudRate;\n    uVar5 = HAL_RCC_GetPCLK1Freq();\n    uVar10 = (huart->Init).BaudRate;\n    uVar6 = HAL_RCC_GetPCLK1Freq();\n    uVar11 = (huart->Init).BaudRate;\n    uVar7 = HAL_RCC_GetPCLK1Freq();\n    pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                 (ulonglong)\n                                 (((uVar6 * 0x19) / (uVar11 << 2) +\n                                  (uint)((ulonglong)uVar2 *\n                                         ((ulonglong)(uVar7 * 0x19) /\n                                         (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100)\n                                  * 0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                   ((uint)((ulonglong)uVar2 *\n                           (ulonglong)\n                           (((uVar4 * 0x19) / (uVar9 << 2) +\n                            (uint)((ulonglong)uVar2 *\n                                   ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                            -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                   (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  uVar3 = HAL_RCC_GetPCLK2Freq();\n  uVar2 = DAT_08002d08;\n  uVar8 = (huart->Init).BaudRate;\n  uVar1 = (ulonglong)DAT_08002d08;\n  uVar4 = HAL_RCC_GetPCLK2Freq();\n  uVar9 = (huart->Init).BaudRate;\n  uVar5 = HAL_RCC_GetPCLK2Freq();\n  uVar10 = (huart->Init).BaudRate;\n  uVar6 = HAL_RCC_GetPCLK2Freq();\n  uVar11 = (huart->Init).BaudRate;\n  uVar7 = HAL_RCC_GetPCLK2Freq();\n  pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                               (ulonglong)\n                               (((uVar6 * 0x19) / (uVar11 << 2) +\n                                (uint)((ulonglong)uVar2 *\n                                       ((ulonglong)(uVar7 * 0x19) /\n                                       (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100) *\n                                0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                 ((uint)((ulonglong)uVar2 *\n                         (ulonglong)\n                         (((uVar4 * 0x19) / (uVar9 << 2) +\n                          (uint)((ulonglong)uVar2 *\n                                 ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                          -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                 (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                 0x10;\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080029c8",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "FUNC_080029c8"
        },
        "FUN_08002488": {
            "renaming": {
                "FUN_08002488": "set_clock_config_08002488",
                "RCC_ClkInitStruct_conflict": "clock_init_struct",
                "FLatency": "flash_latency",
                "puVar1": "flash_latency_ptr",
                "uVar2": "sys_clk_freq",
                "uVar3": "timeout_elapsed",
                "uVar4": "sys_clk_source",
                "DAT_080025d0": "flash_latency_ptr",
                "DAT_080025d4": "rcc_cfgr_ptr",
                "PTR_SystemCoreClock_080025dc": "SYS_CLOCK_FREQ_080025DC",
                "PTR_AHBPrescTable_080025d8": "AHB_PRESCALER_TABLE_080025D8",
                "HAL_StatusTypeDef": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef set_clock_config_08002488(RCC_ClkInitTypeDef_conflict *clock_init_struct, uint32_t flash_latency) {\n  uint32_t *DAT_080025d0;\n  uint32_t sys_clk_freq;\n  uint32_t timeout_start;\n  uint32_t timeout_elapsed;\n  uint32_t ahb_clk_divider;\n  uint32_t apb1_clk_divider;\n  uint32_t apb2_clk_divider;\n  uint32_t sys_clk_source;\n  uint32_t *DAT_080025d4;\n  if (clock_init_struct == NULL) {\n    return HAL_ERROR;\n  }\n  DAT_080025d0 = (uint32_t*)0x080025D0;\n  if ((*DAT_080025d0 & 0xF) < flash_latency) {\n    *DAT_080025d0 = (*DAT_080025d0 & 0xFFFFFFF0) | flash_latency;\n    if ((*DAT_080025d0 & 0xF) != flash_latency) {\n      return HAL_ERROR;\n    }\n  }\n  DAT_080025d4 = (uint32_t*)0x080025D4;\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\n    sys_clk_source = clock_init_struct->SYSCLKSource;\n    if (sys_clk_source == RCC_SYSCLKSOURCE_PLLCLK) {\n      if ((*DAT_080025d4 & RCC_CFGR_SWS_PLL) != RCC_CFGR_SWS_PLL) {\n        return HAL_ERROR;\n      }\n    }\n    else if (sys_clk_source == RCC_SYSCLKSOURCE_HSE) {\n      if ((*DAT_080025d4 & RCC_CFGR_SWS_HSE) != RCC_CFGR_SWS_HSE) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((*DAT_080025d4 & RCC_CFGR_SWS_HSI) != RCC_CFGR_SWS_HSI) {\n      return HAL_ERROR;\n    }\n    ahb_clk_divider = clock_init_struct->AHBCLKDivider;\n    *DAT_080025d4 = (*DAT_080025d4 & 0xFFFFFFFC) | sys_clk_source;\n    timeout_start = HAL_GetTick();\n    while (((*DAT_080025d4 & RCC_CFGR_SWS) >> 2) != sys_clk_source) {\n      timeout_elapsed = HAL_GetTick() - timeout_start;\n      if (timeout_elapsed > 5000) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_HCLK) != 0) {\n    ahb_clk_divider = clock_init_struct->AHBCLKDivider;\n    *DAT_080025d4 = (*DAT_080025d4 & 0xFFFFF0FF) | (ahb_clk_divider << 4);\n  }\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_PCLK1) != 0) {\n    apb1_clk_divider = clock_init_struct->APB1CLKDivider;\n    *DAT_080025d4 = (*DAT_080025d4 & 0xFFFFE3FF) | (apb1_clk_divider << 10);\n  }\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_PCLK2) != 0) {\n    apb2_clk_divider = clock_init_struct->APB2CLKDivider;\n    *DAT_080025d4 = (*DAT_080025d4 & 0xFFFF1FFF) | (apb2_clk_divider << 13);\n  }\n  sys_clk_freq = HAL_RCC_GetSysClockFreq();\n  *(uint32_t*)PTR_SystemCoreClock_080025dc = sys_clk_freq >> PTR_AHBPrescTable_080025d8[(*DAT_080025d4 >> 0x18) & 0xF];\n  HAL_InitTick(0xF);\n  return HAL_OK;\n}\n",
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002488",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_config_08002488"
        },
        "FUN_08004788": {
            "renaming": {
                "FUN_08004788": "handle_gpio_exti_interrupt_08004788",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_gpio_exti_interrupt_08004788(void)\n{\n  const uint32_t gpio_pin = GPIO_PIN_4;\n  HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004788",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_08004788"
        },
        "FUN_08004544": {
            "renaming": {
                "FUN_08004544::FUN_08004544": "IPv4Address::IPv4Address",
                "this": "this",
                "first_octet": "first_octet",
                "second_octet": "second_octet",
                "third_octet": "third_octet",
                "fourth_octet": "fourth_octet",
                "super_Printable": "Printable",
                "_vptr_Printable": "_vptr_Printable",
                "_address": "address",
                "bytes": "bytes",
                "FUN_08004544": "print_08004544"
            },
            "code": "class Printable {\npublic:\n    virtual void print_08004544() = 0;\n};\nclass IPv4Address : public Printable {\npublic:\n    IPv4Address(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet) {\n        address.bytes[0] = first_octet;\n        address.bytes[1] = second_octet;\n        address.bytes[2] = third_octet;\n        address.bytes[3] = fourth_octet;\n    }\n    void print_08004544() {\n        print_08004544f(\"%d.%d.%d.%d\", address.bytes[0], address.bytes[1], address.bytes[2], address.bytes[3]);\n    }\nprivate:\n    struct {\n        uint8_t bytes[4];\n    } address;\n};\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004544",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "print_08004544"
        },
        "FUN_08003cc8": {
            "renaming": {
                "FUN_08003cc8": "initialize_uart_08003cc8",
                "PinName_conflict pin": "PinName_conflict uart_tx_pin",
                "undefined *obj": "undefined *serial_obj",
                "PinName_conflict PVar1": "PinName_conflict uart_rx_pin",
                "void *pvVar2": "void *peripheral"
            },
            "code": "void initialize_uart_08003cc8(void)\n{\n  PinName_conflict uart_tx_pin;\n  undefined *serial_obj;\n  PinName_conflict uart_rx_pin;\n  void *peripheral;\n  \n  uart_tx_pin = *(PinName_conflict *)(PTR_digitalPin_08003d08 + 0x9a);\n  peripheral = pinmap_peripheral(uart_tx_pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08003d0c);\n  if (peripheral != (void *)0x0) {\n    peripheral = pinmap_peripheral(uart_tx_pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08003d0c);\n    uart_rx_pin = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_08003d10);\n    serial_obj = PTR_serial_debug_08003d14;\n    *(PinName_conflict *)(PTR_serial_debug_08003d14 + 0x5a) = uart_rx_pin;\n    *(PinName_conflict *)(serial_obj + 0x58) = uart_tx_pin;\n    *(undefined4 *)(serial_obj + 0x48) = 0x2580;\n    *(undefined4 *)(serial_obj + 0x54) = 0;\n    *(undefined4 *)(serial_obj + 0x4c) = 0;\n    *(undefined4 *)(serial_obj + 0x50) = 0;\n    uart_init((serial_t *)serial_obj);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003cc8",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_08003cc8"
        },
        "FUN_08002d70": {
            "renaming": {
                "FUN_08002d70": "do_nothing_08002d70"
            },
            "code": "\nvoid do_nothing_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d70",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08002d70"
        },
        "FUN_08000fb4": {
            "renaming": {
                "FUN_08000fb4": "configure_gpio_pins_08000fb4",
                "GPIOx": "gpio_port",
                "GPIO_Init": "gpio_init",
                "puVar1": "tmp1",
                "puVar2": "tmp2",
                "uVar3": "tmp3",
                "uVar4": "tmp4",
                "uVar5": "pin_index",
                "uVar6": "pin_mask",
                "uVar7": "tmp5",
                "iVar8": "port_index",
                "uVar9": "tmp6",
                "iVar10": "af_index",
                "tmpreg": "tmp7"
            },
            "code": "void configure_gpio_pins_08000fb4(GPIO_TypeDef *gpio_port, GPIO_InitTypeDef *gpio_init)\n{\n    uint32_t pin_mask;\n    uint32_t pin_mode_mask;\n    uint32_t pin_speed_mask;\n    uint32_t pin_pupd_mask;\n    uint32_t alternate_mask;\n    uint8_t pin_index;\n    uint8_t af_index;\n    uint8_t port_index;\n    uint32_t tmpreg;\n\n    for (pin_index = 0; pin_index < 0x10; pin_index++) {\n        pin_mask = 1 << (pin_index & 0xff);\n        if (pin_mask & gpio_init->Pin) {\n            if ((gpio_init->Mode == GPIO_MODE_AF_PP) || (gpio_init->Mode == GPIO_MODE_AF_OD)) {\n                af_index = (pin_index & 7) << 2;\n                gpio_port->AFR[pin_index >> 3] =\n                    gpio_port->AFR[pin_index >> 3] & ~(0xf << af_index) | gpio_init->Alternate << af_index;\n            }\n            port_index = pin_index << 1;\n            pin_mode_mask = ~(3 << (port_index & 0xff));\n            gpio_port->MODER = gpio_port->MODER & pin_mode_mask |\n                (gpio_init->Mode & 3) << (port_index & 0xff);\n            tmpreg = gpio_init->Mode;\n            if (((tmpreg - 1 < 2) || (tmpreg == GPIO_MODE_ANALOG)) || (tmpreg == GPIO_MODE_IT_RISING_FALLING)) {\n                pin_speed_mask = gpio_port->OSPEEDR & pin_mode_mask | gpio_init->Speed << (port_index & 0xff);\n                gpio_port->OSPEEDR = pin_speed_mask;\n                gpio_port->OTYPER = gpio_port->OTYPER & ~pin_mask |\n                    ((gpio_init->Mode << 0x1b) >> 0x1f) << (pin_index & 0xff);\n            }\n            pin_pupd_mask = pin_mode_mask & gpio_port->PUPDR | gpio_init->Pull << (port_index & 0xff);\n            gpio_port->PUPDR = pin_pupd_mask;\n            if ((gpio_init->Mode & GPIO_MODE_IT) != 0) {\n                *(uint32_t *)(PTR_DAT_0800118c + 0x44) = *(uint32_t *)(PTR_DAT_0800118c + 0x44) | 0x4000;\n                af_index = (pin_index & 3) << 2;\n                if (gpio_port == PTR_DAT_08001190) {\n                    port_index = 0;\n                }\n                else if (gpio_port == PTR_DAT_08001194) {\n                    port_index = 1;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)&PTR_DAT_08001194[0x19].BSRR) {\n                    port_index = 2;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)&PTR_DAT_08001194[0x33].OSPEEDR) {\n                    port_index = 3;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)PTR_DAT_08001194[0x4c].AFR) {\n                    port_index = 4;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)&PTR_DAT_08001194[0x66].IDR) {\n                    port_index = 5;\n                }\n                else if (gpio_port == PTR_DAT_08001194 + 0x80) {\n                    port_index = 6;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)&PTR_DAT_08001194[0x99].BSRR) {\n                    port_index = 7;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)&PTR_DAT_08001194[0xb3].OSPEEDR) {\n                    port_index = 8;\n                }\n                else if (gpio_port == (GPIO_TypeDef *)PTR_DAT_08001194[0xcc].AFR) {\n                    port_index = 9;\n                }\n                else {\n                    port_index = 10;\n                }\n                *(uint32_t *)(PTR_DAT_08001184 + ((pin_index >> 2) + 2) * 4) =\n                    *(uint32_t *)(PTR_DAT_08001184 + ((pin_index >> 2) + 2) * 4) & ~(0xf << af_index) | port_index << af_index;\n                tmpreg = ~pin_mask;\n                pin_mode_mask = *PTR_DAT_08001188 & tmpreg;\n                if ((gpio_init->Mode & GPIO_MODE_IT_RISING) != 0) {\n                    pin_mode_mask = pin_mask | *PTR_DAT_08001188;\n                }\n                *PTR_DAT_08001188 = pin_mode_mask;\n                pin_mode_mask = tmpreg & PTR_DAT_08001188[1];\n                if ((gpio_init->Mode & GPIO_MODE_IT_FALLING) != 0) {\n                    pin_mode_mask = pin_mask | PTR_DAT_08001188[1];\n                }\n                PTR_DAT_08001188[1] = pin_mode_mask;\n                pin_mode_mask = tmpreg & PTR_DAT_08001188[2];\n                if ((gpio_init->Mode & GPIO_MODE_EVT_RISING) != 0) {\n                    pin_mode_mask = pin_mask | PTR_DAT_08001188[2];\n                }\n                PTR_DAT_08001188[2] = pin_mode_mask;\n                tmpreg = tmpreg & PTR_DAT_08001188[3];\n                if ((gpio_init->Mode & GPIO_MODE_EVT_FALLING) != 0) {\n                    tmpreg = pin_mask | PTR_DAT_08001188[3];\n                }\n                PTR_DAT_08001188[3] = tmpreg;\n            }\n        }\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000fb4",
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pins_08000fb4"
        },
        "FUN_08001bfc": {
            "renaming": {
                "FUN_08001bfc": "process_I2C_request_08001bfc",
                "*hi2c": "*i2c_handler",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "puVar3": "buffer_ptr",
                "tmpreg": "tmp_register"
            },
            "code": "HAL_StatusTypeDef process_I2C_request_08001bfc(I2C_HandleTypeDef *i2c_handler) {\n  HAL_I2C_StateTypeDef i2c_state;\n  I2C_TypeDef *i2c_instance;\n  uint8_t *buffer_ptr;\n  uint32_t tmp_register;\n  i2c_state = i2c_handler->State;\n  i2c_handler->Instance->CR2 = i2c_handler->Instance->CR2 & 0xfffff8ff;\n  i2c_handler->Instance->CR1 = i2c_handler->Instance->CR1 | 1;\n  i2c_handler->Instance->CR1 = i2c_handler->Instance->CR1 & 0xfffffbff;\n  i2c_instance = i2c_handler->Instance;\n  if ((i2c_instance->CR2 & 0x800) != 0) {\n    if ((i2c_handler->State == HAL_I2C_STATE_BUSY_RX) || (i2c_handler->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handler->XferCount = (uint16_t)i2c_handler->hdmarx->Instance->NDTR;\n    }\n    else {\n      i2c_handler->XferCount = (uint16_t)i2c_handler->hdmatx->Instance->NDTR;\n    }\n  }\n  if (i2c_handler->XferCount != 0) {\n    if ((i2c_instance->SR1 & 4) != 0) {\n      buffer_ptr = i2c_handler->pBuffPtr;\n      i2c_handler->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)i2c_instance->DR;\n      i2c_handler->XferCount = i2c_handler->XferCount - 1;\n    }\n    if ((i2c_handler->Instance->SR1 & 0x40) != 0) {\n      buffer_ptr = i2c_handler->pBuffPtr;\n      i2c_handler->pBuffPtr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)i2c_handler->Instance->DR;\n      i2c_handler->XferCount = i2c_handler->XferCount - 1;\n    }\n    i2c_handler->ErrorCode = i2c_handler->ErrorCode | 4;\n  }\n  if (i2c_handler->ErrorCode == 0) {\n    if (((i2c_state == HAL_I2C_STATE_LISTEN) || (i2c_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handler->XferOptions = DAT_08001cfc;\n      i2c_handler->PreviousState = 0;\n      i2c_handler->State = HAL_I2C_STATE_READY;\n      i2c_handler->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2c_handler);\n    }\n    else if ((i2c_handler->PreviousState == 0x22) || (i2c_state == HAL_I2C_STATE_BUSY_RX)) {\n      i2c_handler->PreviousState = 0;\n      i2c_handler->State = HAL_I2C_STATE_READY;\n      i2c_handler->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handler);\n    }\n  }\n  else {\n    I2C_ITError(i2c_handler);\n  }\n  return HAL_OK;\n}",
            "called": [
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bfc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_I2C_request_08001bfc"
        },
        "FUN_08001718": {
            "renaming": {
                "FUN_08001718": "do_nothing_08001718"
            },
            "code": "\nvoid do_nothing_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001718",
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_08001718"
        },
        "FUN_08002d72": {
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "*huart": "*uart_handle",
                "huart": "uart_handle",
                "HAL_UART_StateTypeDef": "HAL_StatusTypeDef",
                "HAL_UART_MspInit": "HAL_UART_MspInit",
                "gState": "global_state",
                "Lock": "lock",
                "Instance": "instance",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "ErrorCode": "error_code",
                "RxState": "receive_state"
            },
            "code": "HAL_StatusTypeDef initialize_uart_08002d72(UART_HandleTypeDef *uart_handle) {\n  if (uart_handle != NULL) {\n    if (uart_handle->gState == HAL_UART_STATE_RESET) {\n      uart_handle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uart_handle);\n    }\n    uart_handle->gState = HAL_UART_STATE_BUSY;\n    uart_handle->Instance->CR1 &= ~(1 << 13);\n    UART_SetConfig(uart_handle);\n    uart_handle->Instance->CR2 &= ~(1 << 11);\n    uart_handle->Instance->CR3 &= ~(1 << 2);\n    uart_handle->Instance->CR1 |= (1 << 13);\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_READY;\n    uart_handle->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d72",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_08002d72"
        },
        "FUN_080007f0": {
            "renaming": {
                "FUN_080007f0": "validate_request_080007f0",
                "uVar2": "start_address",
                "uVar3": "num_registers",
                "uVar4": "i",
                "bVar1": "is_valid_request",
                "PTR_fctsupported_080008c8": "supported_functions",
                "this->u16errCnt": "this->error_count",
                "this->au8Buffer[1]": "this->function_code",
                "this->au8Buffer[2]": "this->address_hi",
                "this->au8Buffer[3]": "this->address_lo",
                "this->au8Buffer[4]": "this->num_regs_hi",
                "this->au8Buffer[5]": "this->num_regs_lo",
                "this->u8regsize": "this->register_size"
            },
            "code": "uint8_t __thiscall validate_request_080007f0(Modbus *this)\n{\n    bool is_valid_request = false;\n    uint16_t start_address = 0;\n    uint16_t num_registers = 0;\n\n    for (int i = 0; i < 8; i++) {\n        if (PTR_fctsupported_080008c8[i] == this->au8Buffer[1]) {\n            is_valid_request = true;\n            break;\n        }\n    }\n\n    if (!is_valid_request) {\n        this->u16errCnt++;\n        return 0x01;\n    }\n\n    switch (this->au8Buffer[1]) {\n        case READ_COILS:\n        case READ_DISCRETE_INPUTS:\n        case READ_HOLDING_REGISTERS:\n        case READ_INPUT_REGISTERS:\n            start_address = makeWord(this->au8Buffer[2], this->au8Buffer[3]);\n            num_registers = makeWord(this->au8Buffer[4], this->au8Buffer[5]);\n            if (this->u8regsize < num_registers) {\n                return 0x02;\n            }\n            break;\n        case WRITE_SINGLE_COIL:\n            start_address = makeWord(this->au8Buffer[2], this->au8Buffer[3]);\n            if (this->u8regsize < start_address) {\n                return 0x02;\n            }\n            break;\n        case WRITE_SINGLE_REGISTER:\n            start_address = makeWord(this->au8Buffer[2], this->au8Buffer[3]);\n            if (this->u8regsize < start_address) {\n                return 0x02;\n            }\n            break;\n        default:\n            break;\n    }\n\n    return 0x00;\n}\n",
            "called": [
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080007f0",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "validate_request_080007f0"
        },
        "FUN_0800477e": {
            "renaming": {
                "FUN_0800477e": "handle_gpio_exti_interrupt_0800477e",
                "PTR_": "",
                "DAT_": "",
                "8": "GPIO_PIN_8"
            },
            "code": "void handle_gpio_exti_interrupt_0800477e(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800477e",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_0800477e"
        },
        "FUN_0800562a": {
            "renaming": {
                "FUN_0800562a": "write_to_file_at_offset_if_flag_set_0800562a",
                "param_1": "file",
                "param_2": "buffer_offset",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "flag": "buffer_flag",
                "offset": "buffer_offset_value"
            },
            "code": "void write_to_file_at_offset_if_flag_set_0800562a(void* file, int buffer_offset, void* buffer, int buffer_size) {\n    int flag = *(ushort *)(buffer_offset + 0xc);\n    if ((int)((uint)flag << 0x17) < 0) {\n        int offset = (int)*(short *)(buffer_offset + 0xe);\n        _lseek_r(file, offset, 0, 2);\n    }\n    *(ushort *)(buffer_offset + 0xc) = flag & 0xefff;\n    _write_r(file, (int)*(short *)(buffer_offset + 0xe), buffer, buffer_size);\n    return;\n}",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800562a",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_at_offset_if_flag_set_0800562a"
        },
        "FUN_080044d8": {
            "renaming": {
                "FUN_080044d8": "initialize_priority_080044d8",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level"
            },
            "code": "void initialize_priority_080044d8(int should_initialize, int priority_level)\n{\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    HardwareSerial::HardwareSerial((HardwareSerial *)PTR_Serial3_080044f8,DAT_080044f4);\n  }\n  return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044d8",
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "imported": false,
            "current_name": "initialize_priority_080044d8"
        },
        "FUN_08003df4": {
            "renaming": {
                "FUN_08003df4": "is_uart_transmitting_08003df4",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "PTR_uart_handlers_08003e14": "PTR_uart_handlers_08003e14",
                "UART_HandleTypeDef": "UART_HandleTypeDef",
                "uint8_t": "bool"
            },
            "code": "bool is_uart_transmitting_08003df4(serial_t *serial_object) {\n    UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef**)(PTR_uart_handlers_08003e14 + (uint)serial_object->index * 4);\n    HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handler);\n    return (uart_state & 0x21U) == 0x21;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003df4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmitting_08003df4"
        },
        "FUN_08005400": {
            "renaming": {
                "FUN_08005400": "initialize_file_stream_08005400",
                "param_1": "error_code_ptr",
                "piVar1": "stream_pointer",
                "piVar2": "current_file",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "file_list"
            },
            "code": "int * initialize_file_stream_08005400(undefined4 *error_code_ptr)\n{\n  int *stream_pointer;\n  int *current_file;\n  int global_impure_ptr = *(int *)PTR__global_impure_ptr_08005474;\n  if (*(int *)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  int **file_list = (int **)(global_impure_ptr + 0x48);\n  do {\n    current_file = file_list[2];\n    stream_pointer = file_list[1];\n    while (stream_pointer = (int *)((int)stream_pointer + -1), -1 < (int)stream_pointer) {\n      if (*(short *)(current_file + 3) == 0) {\n        *(undefined2 *)((int)current_file + 0xe) = 0xffff;\n        *(undefined2 *)(current_file + 3) = 1;\n        current_file[0x19] = 0;\n        *current_file = 0;\n        current_file[2] = 0;\n        current_file[1] = 0;\n        current_file[4] = 0;\n        current_file[5] = 0;\n        current_file[6] = 0;\n        memset(current_file + 0x17,0,8);\n        current_file[0xd] = 0;\n        current_file[0xe] = 0;\n        current_file[0x12] = 0;\n        current_file[0x13] = 0;\n        return current_file;\n      }\n      current_file = current_file + 0x1a;\n    }\n    if (*file_list == (int *)0x0) {\n      stream_pointer = (int *)__sfmoreglue(error_code_ptr,4);\n      *file_list = stream_pointer;\n      if (stream_pointer == (int *)0x0) {\n        *error_code_ptr = 0xc;\n        return (int *)0x0;\n      }\n    }\n    file_list = (int **)*file_list;\n  } while( true );\n}",
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005400",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_file_stream_08005400"
        },
        "FUN_08003582": {
            "renaming": {
                "FUN_08003582": "combine_pointers_08003582",
                "a": "first_ptr",
                "b": "second_ptr"
            },
            "code": "void* combine_pointers_08003582(void* first_ptr, void* second_ptr) {\n  if (first_ptr != second_ptr) {\n    if (first_ptr == NULL) {\n      return second_ptr;\n    }\n    if (second_ptr == NULL) {\n      return first_ptr;\n    }\n    first_ptr = NULL;\n  }\n  return first_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003582",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "combine_pointers_08003582"
        },
        "FUN_08004792": {
            "renaming": {
                "FUN_08004792": "handle_gpio_exti_interrupts_08004792",
                "uVar1": "gpio_pin",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void handle_gpio_exti_interrupts_08004792(void)\n{\n  uint16_t gpio_pin = 0x20;\n  uint16_t last_gpio_pin = 0x200;\n  while(gpio_pin <= last_gpio_pin) {\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n    gpio_pin = gpio_pin << 1;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004792",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupts_08004792"
        },
        "FUN_08005760": {
            "renaming": {
                "std::FUN_08005760": "abort_program",
                "FUN_08005760": "abort_program_08005760"
            },
            "code": "void abort_program_08005760(void)\n{\n  abort();\n}",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005760",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_program_08005760"
        },
        "FUN_08004678": {
            "renaming": {
                "FUN_08004678": "count_bits_set_08004678",
                "pin": "input_pin",
                "uVar1": "temp_pin",
                "uVar2": "count"
            },
            "code": "uint8_t count_bits_set_08004678(uint16_t input_pin)\n{\n  uint16_t pin = input_pin;\n  uint8_t count = 0;\n  while (pin != 0)\n  {\n    count++;\n    pin &= (pin - 1);\n  }\n  return count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004678",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "count_bits_set_08004678"
        },
        "FUN_08003900": {
            "renaming": {
                "FUN_08003900": "enable_i2c_listen_mode_08003900",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "get_i2c_obj": "get_i2c_object",
                "isMaster": "is_master"
            },
            "code": "void enable_i2c_listen_mode_08003900(I2C_HandleTypeDef *i2c_handle)\\n{\\n  i2c_t *i2c_obj = get_i2c_object(i2c_handle);\\n  if (i2c_obj->is_master == \"\\0\") {\\n    HAL_I2C_EnableListen_IT(i2c_handle);\\n  }\\n  return;\\n}",
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003900",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_mode_08003900"
        },
        "FUN_08005768": {
            "renaming": {
                "std::ctype_byname<char>::FUN_08005768": "set_ptr_id_values_to_1",
                "PTR_id_080057fc": "ptr_id_1",
                "PTR_id_08005800": "ptr_id_2",
                "PTR_id_08005804": "ptr_id_3",
                "PTR_id_08005808": "ptr_id_4",
                "PTR_id_0800580c": "ptr_id_5",
                "PTR_id_08005810": "ptr_id_6",
                "PTR_id_08005814": "ptr_id_7",
                "PTR_id_08005818": "ptr_id_8",
                "PTR_id_0800581c": "ptr_id_9",
                "PTR_id_08005820": "ptr_id_10",
                "PTR_id_08005824": "ptr_id_11",
                "FUN_08005768": "set_ptr_id_values_to_1_08005768"
            },
            "code": "void set_ptr_id_values_to_1_08005768(void)\n{\n  if (*(int *)PTR_id_080057fc < 0) {\n    *(undefined4 *)PTR_id_080057fc = 1;\n  }\n  if (*(int *)PTR_id_08005800 < 0) {\n    *(undefined4 *)PTR_id_08005800 = 1;\n  }\n  if (*(int *)PTR_id_08005804 < 0) {\n    *(undefined4 *)PTR_id_08005804 = 1;\n  }\n  if (*(int *)PTR_id_08005808 < 0) {\n    *(undefined4 *)PTR_id_08005808 = 1;\n  }\n  if (*(int *)PTR_id_0800580c < 0) {\n    *(undefined4 *)PTR_id_0800580c = 1;\n  }\n  if (*(int *)PTR_id_08005810 < 0) {\n    *(undefined4 *)PTR_id_08005810 = 1;\n  }\n  if (*(int *)PTR_id_08005814 < 0) {\n    *(undefined4 *)PTR_id_08005814 = 1;\n  }\n  if (*(int *)PTR_id_08005818 < 0) {\n    *(undefined4 *)PTR_id_08005818 = 1;\n  }\n  if (*(int *)PTR_id_0800581c < 0) {\n    *(undefined4 *)PTR_id_0800581c = 1;\n  }\n  if (*(int *)PTR_id_08005820 < 0) {\n    *(undefined4 *)PTR_id_08005820 = 1;\n  }\n  if (*(int *)PTR_id_08005824 < 0) {\n    *(undefined4 *)PTR_id_08005824 = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005768",
            "calling": [],
            "imported": false,
            "current_name": "set_ptr_id_values_to_1_08005768"
        },
        "FUN_08000f0c": {
            "renaming": {
                "FUN_08000f0c": "set_interrupt_enable_bit_08000f0c",
                "IRQn_Type_conflict": "irq_number",
                "uVar1": "irq_number_casted",
                "DAT_08000f28": "interrupt_enable_register_address",
                "word_offset": "interrupt_enable_word_offset",
                "bit_offset": "interrupt_enable_bit_offset"
            },
            "code": "void set_interrupt_enable_bit_08000f0c(IRQn_Type_conflict irq_number)\n{\n  uint32_t irq_number_casted = (uint32_t)irq_number;\n  if (irq_number_casted >= 0)\n  {\n    uint32_t word_offset = (irq_number_casted >> 5) + 0x60;\n    uint32_t bit_offset = irq_number_casted & 0x1f;\n    *(int *)(DAT_08000f28 + word_offset * 4) = 1 << bit_offset;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f0c",
            "calling": [
                "UART4_IRQHandler",
                "USART2_IRQHandler",
                "UART7_IRQHandler",
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "USART1_IRQHandler",
                "UART5_IRQHandler",
                "UART8_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_08000f0c"
        },
        "FUN_08000998": {
            "renaming": {
                "__thiscall Modbus::FUN_08000998": "assemble_response_packet",
                "this": "self",
                "regs": "register_values",
                "u8size": "num_registers",
                "bVar1": "byte_var_1",
                "uVar2": "uint8_var_1",
                "uVar3": "start_address",
                "uVar4": "num_bytes",
                "uVar5": "i",
                "FUN_08000998": "Modbus::assemble_response_packet_08000998"
            },
            "code": "int8_t __thiscall Modbus::assemble_response_packet_08000998(Modbus *this, uint16_t *register_values, uint8_t num_registers)\n{\n  byte byte_var_1;\n  uint8_t uint8_var_1;\n  uint16_t start_address = makeWord(this->au8Buffer[2], this->au8Buffer[3]);\n  uint16_t num_bytes = makeWord(this->au8Buffer[4], this->au8Buffer[5]);\n  this->au8Buffer[2] = (byte)num_bytes << 1;\n  this->u8BufferSize = 3;\n  for (uint i = start_address; i < start_address + num_bytes; i++) {\n    byte_var_1 = this->u8BufferSize;\n    this->au8Buffer[byte_var_1] = (uint8_t)(register_values[i] >> 8);\n    uint8_var_1 = (byte_var_1 + 1) & 0xff;\n    this->u8BufferSize = uint8_var_1;\n    this->au8Buffer[uint8_var_1] = *(uint8_t *)(register_values + i);\n    this->u8BufferSize = uint8_var_1 + 1;\n  }\n  uint8_t response_length = this->u8BufferSize;\n  sendTxBuffer(this);\n  return response_length + 2;\n}\n",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000998",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "Modbus::assemble_response_packet_08000998"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "receive_data_from_uart_08003f94",
                "huart": "uart_handler",
                "tmpval": "temp_value"
            },
            "code": "void receive_data_from_uart_08003f94(UART_HandleTypeDef *uart_handler)\n{\n  uint32_t temp_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_from_uart_08003f94"
        },
        "FUN_080055d0": {
            "renaming": {
                "FUN_080055d0": "call_function_with_signal_080055d0",
                "__sig": "signal_number",
                "iVar1": "return_value",
                "_FUN_080055d0_r": "_call_function_with_signal_r"
            },
            "code": "int call_function_with_signal_080055d0(int signal_number)\n{\n  int return_value;\n  return_value = _call_function_with_signal_080055d0_r(*(undefined4 *)PTR__impure_ptr_080055dc, signal_number);\n  return return_value;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055d0",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "call_function_with_signal_080055d0"
        },
        "FUN_080056f8": {
            "renaming": {
                "FUN_080056f8": "check_if_terminal_080056f8",
                "param_1": "errno_ptr",
                "param_2": "file_descriptor",
                "puVar1": "errno_loc",
                "iVar2": "is_terminal"
            },
            "code": "void check_if_terminal_080056f8(int *errno_ptr, int file_descriptor) {\n    undefined *errno_loc;\n    int is_terminal;\n\n    errno_loc = PTR_errno_08005714;\n    *(undefined4 *)PTR_errno_08005714 = 0;\n    is_terminal = _isatty(file_descriptor);\n    if ((is_terminal == -1) && (*(int *)errno_loc != 0)) {\n        *errno_ptr = *(int *)errno_loc;\n    }\n    return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056f8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_if_terminal_080056f8"
        },
        "FUN_080054b4": {
            "renaming": {
                "FUN_080054b4": "check_file_permissions_080054b4",
                "param_1": "file_descriptor",
                "param_2": "file_info_address",
                "param_3": "output_result",
                "param_4": "output_permissions",
                "iVar1": "file_status",
                "uVar2": "permissions",
                "auStack_4c": "file_status_buffer",
                "local_48": "file_mode"
            },
            "code": "int check_file_permissions_080054b4(int file_descriptor, int file_info_address, int* output_result, unsigned int* output_permissions) {\n    int file_status;\n    unsigned int permissions = 0;\n    if (*(short *)(file_info_address + 0xe) < 0 || _fstat_r(file_descriptor, (int)*(short *)(file_info_address + 0xe), &file_status) < 0) {\n        *output_result = 0;\n        if ((int)((uint)*(ushort *)(file_info_address + 0xc) << 0x18) < 0) {\n            permissions = 0x40;\n            goto LAB_080054f4;\n        }\n    }\n    else {\n        *output_result = (unsigned int)((file_status & 0xf000) == 0x2000);\n    }\n    permissions = 0x400;\nLAB_080054f4:\n    *output_permissions = permissions;\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080054b4",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permissions_080054b4"
        },
        "FUN_0800171a": {
            "renaming": {
                "FUN_0800171a": "i2c_transfer_0800171a",
                "*hi2c": "*handle",
                "HVar1": "state",
                "pbVar2": "buffer",
                "uVar3": "options"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_0800171a(I2C_HandleTypeDef *handle)\n{\n    HAL_I2C_StateTypeDef state = handle->State;\n    uint32_t options = handle->XferOptions;\n    if (handle->XferSize == 0 && state == HAL_I2C_STATE_BUSY_TX) {\n        if (options == 4 || options == 8 || options == 0xffff0000) {\n            handle->Instance->CR2 &= 0xfffff8ff;\n            handle->Instance->CR1 |= 0x200;\n            handle->PreviousState = 0;\n            handle->State = HAL_I2C_STATE_READY;\n            if (handle->Mode == HAL_I2C_MODE_MEM) {\n                handle->Mode = HAL_I2C_MODE_NONE;\n                HAL_I2C_MemTxCpltCallback(handle);\n            }\n            else {\n                handle->Mode = HAL_I2C_MODE_NONE;\n                HAL_I2C_MasterTxCpltCallback(handle);\n            }\n        }\n        else {\n            handle->Instance->CR2 &= 0xfffff8ff;\n            handle->PreviousState = 0x11;\n            handle->Mode = HAL_I2C_MODE_NONE;\n            handle->State = HAL_I2C_STATE_READY;\n            HAL_I2C_MasterTxCpltCallback(handle);\n        }\n    }\n    else if (state == HAL_I2C_STATE_BUSY_TX || (handle->Mode == HAL_I2C_MODE_MEM && state == HAL_I2C_STATE_BUSY_RX)) {\n        if (handle->XferCount == 0) {\n            handle->Instance->CR2 &= 0xfffffbff;\n        }\n        else if (handle->Mode == HAL_I2C_MODE_MEM) {\n            if (handle->EventCount == 0) {\n                if (handle->MemaddSize == 1) {\n                    handle->Instance->DR = handle->Memaddress & 0xff;\n                    handle->EventCount += 2;\n                }\n                else {\n                    handle->Instance->DR = (handle->Memaddress << 0x10) >> 0x18;\n                    handle->EventCount++;\n                }\n            }\n            else if (handle->EventCount == 1) {\n                handle->Instance->DR = handle->Memaddress & 0xff;\n                handle->EventCount++;\n            }\n            else if (handle->EventCount == 2) {\n                if (handle->State == HAL_I2C_STATE_BUSY_RX) {\n                    handle->Instance->CR1 |= 0x100;\n                }\n                else if (handle->State == HAL_I2C_STATE_BUSY_TX) {\n                    uint8_t *buffer = handle->pBuffPtr;\n                    handle->pBuffPtr++;\n                    handle->Instance->DR = (uint)*buffer;\n                    handle->XferCount--;\n                }\n            }\n        }\n        else {\n            uint8_t *buffer = handle->pBuffPtr;\n            handle->pBuffPtr++;\n            handle->Instance->DR = (uint)*buffer;\n            handle->XferCount--;\n        }\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800171a",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_0800171a"
        },
        "FUN_08004560": {
            "renaming": {
                "FUN_08004560": "initialize_priority_08004560",
                "__initialize_p": "is_initialize",
                "__priority": "priority"
            },
            "code": "void initialize_priority_08004560(int is_initialize, int priority) {\n  if (is_initialize == 1 && priority == 0xffff) {\n    IPAddress::IPAddress((IPAddress *)PTR_INADDR_NONE_08004588, '\\0', '\\0', '\\0', '\\0');\n    return;\n  }\n  return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004560",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initialize_priority_08004560"
        },
        "FUN_08000a7a": {
            "renaming": {
                "__thiscall Modbus::FUN_08000a7a": "modbus_update_registers",
                "this": "modbus",
                "regs": "registers",
                "u8size": "register_count",
                "uVar1": "starting_address",
                "uVar2": "data_length",
                "uVar3": "i",
                "uVar4": "bit_shift",
                "uVar5": "bit_index",
                "uVar6": "register_index",
                "uVar7": "buffer_index",
                "FUN_08000a7a": "modbus_update_registers_08000a7a"
            },
            "code": "int8_t __thiscall modbus_update_registers_08000a7a(Modbus *modbus,uint16_t *registers,uint8_t register_count) {\n  uint16_t starting_address = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  uint16_t data_length = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  uint bit_shift = 0;\n  uint buffer_index = 7;\n  for (uint i = 0; i < data_length; i++) {\n    uint register_index = (i + starting_address) / 16;\n    uint bit_index = (i + starting_address) % 16;\n    if (((int)(uint)modbus->au8Buffer[buffer_index] >> bit_shift & 1U) == 0) {\n      registers[register_index] = registers[register_index] & ~(ushort)(1 << bit_index);\n    }\n    else {\n      registers[register_index] = (ushort)(1 << bit_index) | registers[register_index];\n    }\n    bit_shift = (bit_shift + 1) % 8;\n    if (bit_shift == 0) {\n      buffer_index = (buffer_index + 1) % 256;\n    }\n  }\n  modbus->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus);\n  return '\b';\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a7a",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "modbus_update_registers_08000a7a"
        },
        "FUN_08003474": {
            "renaming": {
                "FUN_08003474": "do_nothing_08003474"
            },
            "code": "\nvoid do_nothing_08003474(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08003474"
        },
        "FUN_08004cb0": {
            "renaming": {
                "FUN_08004cb0": "count_chars_08004cb0",
                "param_1": "param_1",
                "param_2": "src",
                "param_3": "dst",
                "param_4": "param_4",
                "param_5": "callback",
                "iVar1": "status",
                "uVar2": "max_length",
                "uVar3": "count",
                "bVar4": "is_count_4"
            },
            "code": "undefined4 count_chars_08004cb0(uint32_t param_1, uint32_t *src, uint32_t *dst, uint32_t param_4, code *callback) {\n  int status = 0;\n  uint32_t max_length = src[4] < src[2] ? src[2] : src[4];\n  *dst = max_length;\n  if (*(char *)((int)src + 0x43) != '\\0') {\n    *dst = max_length + 1;\n  }\n  if ((int)(*src << 0x1a) < 0) {\n    *dst += 2;\n  }\n  uint32_t count = *src & 6;\n  if (count == 0) {\n    while ((int)count < (int)(src[3] - *dst)) {\n      status = (*callback)(param_1, param_4, (int)src + 0x19, 1);\n      if (status == -1) {\n        return 0xffffffff;\n      }\n      count++;\n    }\n  }\n  uint32_t add_1 = (uint32_t)*(byte *)((int)src + 0x43);\n  if (add_1 != 0) {\n    add_1 = 1;\n  }\n  if ((int)(*src << 0x1a) < 0) {\n    *(undefined *)((int)src + add_1 + 0x43) = 0x30;\n    *(undefined *)((int)src + add_1 + 0x44) = *(undefined *)((int)src + 0x45);\n    add_1 += 2;\n  }\n  status = (*callback)(param_1, param_4, (int)src + 0x43, add_1);\n  if (status != -1) {\n    uint32_t remaining = src[3];\n    bool is_count_4 = (*src & 6) == 4;\n    if (is_count_4) {\n      remaining -= *dst;\n    }\n    if (is_count_4) {\n      remaining &= ~((int)remaining >> 0x1f);\n    } else {\n      remaining = 0;\n    }\n    if (src[4] < src[2]) {\n      remaining += (src[2] - src[4]);\n    }\n    uint32_t i = 0;\n    while (i != remaining) {\n      status = (*callback)(param_1, param_4, (int)src + 0x1a, 1);\n      if (status == -1) {\n        return 0xffffffff;\n      }\n      i++;\n    }\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004cb0",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "count_chars_08004cb0"
        },
        "FUN_08003594": {
            "renaming": {
                "FUN_08003594": "call_rtc_user_callback_08003594",
                "hrtc": "rtc_handler",
                "PTR_RTCUserCallback_080035a4": "callback_ptr",
                "PTR_callbackUserData_080035a8": "user_data_ptr"
            },
            "code": "void call_rtc_user_callback_08003594(RTC_HandleTypeDef *rtc_handler) {\n  code** PTR_RTCUserCallback_080035a4 = *(code***)PTR_RTCUserCallback_080035a4;\n  if (*PTR_RTCUserCallback_080035a4 != NULL) {\n    (*PTR_RTCUserCallback_080035a4)(*(uint32_t*)PTR_callbackUserData_080035a8);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003594",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "call_rtc_user_callback_08003594"
        },
        "FUN_08002940": {
            "renaming": {
                "FUN_08002940": "reset_uart_state_08002940",
                "*huart": "*uart_handle",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state",
                "HAL_UART_STATE_READY": "ready_state"
            },
            "code": "void reset_uart_state_08002940(UART_HandleTypeDef *uart_handle) {\n  uart_handle->Instance->CR1 &= ~(1 << 13);\n  uart_handle->Instance->CR3 &= ~1;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002940",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_state_08002940"
        },
        "FUN_08004204": {
            "renaming": {
                "FUN_08004204": "get_current_milli_seconds_08004204",
                "uVar1": "current_milli_seconds"
            },
            "code": "uint32_t get_current_milli_seconds_08004204(void)\n{\n  uint32_t current_milli_seconds = GetCurrentMilli();\n  return current_milli_seconds;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004204",
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "imported": false,
            "current_name": "get_current_milli_seconds_08004204"
        },
        "FUN_08003476": {
            "renaming": {
                "FUN_08003476": "tick_handler_08003476",
                "noOsSystickHandler": "no_os_systick_handler"
            },
            "code": "void tick_handler_08003476(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  no_os_systick_handler_08003476();\n  return;\n}",
            "called": [
                "HAL_IncTick",
                "noOsSystickHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003476",
            "calling": [],
            "imported": false,
            "current_name": "tick_handler_08003476"
        },
        "FUN_08004444": {
            "renaming": {
                "FUN_08004444": "set_rx_pin_08004444",
                "_rx": "rx_pin_index",
                "PVar1": "rx_pin"
            },
            "code": "void __thiscall set_rx_pin_08004444(HardwareSerial *this, uint32_t rx_pin_index)\n{\n  PinName rx_pin;\n  if (rx_pin_index < 0x60) {\n    rx_pin = *(PinName *)(PTR_digitalPin_0800445c + rx_pin_index * 2);\n  }\n  else {\n    rx_pin = NC;\n  }\n  (this->_serial).pin_rx = rx_pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004444",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_rx_pin_08004444"
        },
        "FUN_080055e0": {
            "renaming": {
                "FUN_080055e0": "kill_process_if_exists_080055e0",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "puVar1": "error_ptr",
                "iVar2": "kill_result"
            },
            "code": "void kill_process_if_exists_080055e0(int *error_code, int process_id, int signal_number)\n{\n  undefined *error_ptr;\n  int kill_result;\n  error_ptr = PTR_errno_08005600;\n  *(undefined4 *)PTR_errno_08005600 = 0;\n  kill_result = _kill(process_id, signal_number);\n  if ((kill_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080055e0",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_if_exists_080055e0"
        },
        "FUN_0800346c": {
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_0800346c(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800346c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_0800346c"
        },
        "FUN_080053a0": {
            "renaming": {
                "FUN_080053a0": "initialize_param_080053a0",
                "param_1": "param",
                "uVar1": "return_value",
                "iVar2": "global_impure_ptr",
                "bVar3": "is_current_param_global_impure_ptr"
            },
            "code": "void initialize_param_080053a0(int param)\n{\n  if (*(int *)(param + 0x18) == 0) {\n    int global_impure_ptr = *(int *)PTR__global_impure_ptr_080053f8;\n    int is_current_param_global_impure_ptr = (param == global_impure_ptr);\n    if (is_current_param_global_impure_ptr) {\n      *(int *)(param + 0x18) = 1;\n    }\n    else {\n      *(undefined4 *)(param + 0x48) = 0;\n      *(undefined4 *)(param + 0x4c) = 0;\n      *(undefined4 *)(param + 0x50) = 0;\n      *(undefined4 *)(param + 0x28) = DAT_080053fc;\n      *(int *)(param + 0x18) = 1;\n      *(undefined4 *)(param + 4) = __sfp();\n      *(undefined4 *)(param + 8) = __sfp(param);\n      *(undefined4 *)(param + 0xc) = __sfp(param);\n      std_isra_0(*(undefined4 *)(param + 4),4,0);\n      std_isra_0(*(undefined4 *)(param + 8),9,1);\n      std_isra_0(*(undefined4 *)(param + 0xc),0x12,2);\n    }\n  }\n}",
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053a0",
            "calling": [
                "__swbuf_r",
                "__swsetup_r",
                "_vfiprintf_r",
                "_fflush_r",
                "__sfp",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_param_080053a0"
        },
        "FUN_08003918": {
            "renaming": {
                "FUN_08003918": "handle_i2c_event_08003918",
                "PTR_i2c_handles_08003924": "PTR_i2c_handles",
                "*PTR_i2c_handles_08003924": "i2c_handle",
                "HAL_I2C_EV_IRQHandler": "handle_i2c_event_interrupt"
            },
            "code": "void handle_i2c_event_08003918(void)\n{\n  I2C_HandleTypeDef **PTR_i2c_handles_08003924 = *(I2C_HandleTypeDef **)PTR_*PTR_i2c_handles_08003924s_08003924_08003924;\n  HAL_I2C_EV_IRQHandler(*PTR_i2c_handles_08003924);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003918",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_08003918"
        },
        "FUN_0800201c": {
            "renaming": {
                "FUN_0800201c": "FUNC_0800201c"
            },
            "code": "\nHAL_StatusTypeDef FUNC_0800201c(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  HAL_StatusTypeDef HVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  bool bVar5;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_080022d0;\n  if (RCC_OscInitStruct == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_080022d0[2] & 0xc) == 4) ||\n       (((DAT_080022d0[2] & 0xc) == 8 && ((DAT_080022d0[1] & 0x400000) != 0)))) {\n      if (((*DAT_080022d0 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (RCC_OscInitStruct->HSEState == 0x10000) {\n        *DAT_080022d0 = *DAT_080022d0 | 0x10000;\n      }\n      else if (RCC_OscInitStruct->HSEState == 0x50000) {\n        *DAT_080022d0 = *DAT_080022d0 | 0x40000;\n        *puVar1 = *puVar1 | 0x10000;\n      }\n      else {\n        *DAT_080022d0 = *DAT_080022d0 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar3 = HAL_GetTick();\n        while ((*DAT_080022d0 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar3 = HAL_GetTick();\n        while ((*DAT_080022d0 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_080022d0[2] & 0xc) == 0) ||\n       (((DAT_080022d0[2] & 0xc) == 8 && ((DAT_080022d0[1] & 0x400000) == 0)))) {\n      if (((*DAT_080022d0 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_080022d0 = *DAT_080022d0 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_080022d4 = 0;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_080022d0 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_080022d4 = 1;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_080022d0 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_080022d0 = *DAT_080022d0 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_080022d8 = 0;\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1d] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_080022d8 = 1;\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1d] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar5 = (DAT_080022d0[0x10] & 0x10000000) == 0;\n    if (bVar5) {\n      DAT_080022d0[0x10] = DAT_080022d0[0x10] | 0x10000000;\n    }\n    if ((*DAT_080022dc & 0x100) == 0) {\n      *DAT_080022dc = *DAT_080022dc | 0x100;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_080022dc & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar1 = DAT_080022d0;\n    if (RCC_OscInitStruct->LSEState == 1) {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] | 1;\n    }\n    else if (RCC_OscInitStruct->LSEState == 5) {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] | 4;\n      puVar1[0x1c] = puVar1[0x1c] | 1;\n    }\n    else {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] & 0xfffffffe;\n      puVar1[0x1c] = puVar1[0x1c] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1c] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1c] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar5) {\n      DAT_080023ac[0x10] = DAT_080023ac[0x10] & 0xefffffff;\n    }\n  }\n  uVar3 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar3 == 0) {\n    HVar2 = HAL_OK;\n  }\n  else if ((DAT_080023ac[2] & 0xc) == 8) {\n    HVar2 = HAL_ERROR;\n  }\n  else if (uVar3 == 2) {\n    *DAT_080023b0 = 0;\n    uVar3 = HAL_GetTick();\n    do {\n      if ((*DAT_080023ac & 0x2000000) == 0) {\n        DAT_080023ac[1] =\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLM |\n             (RCC_OscInitStruct->PLL).PLLN << 6 |\n             (((RCC_OscInitStruct->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (RCC_OscInitStruct->PLL).PLLQ << 0x18;\n        *DAT_080023b0 = 1;\n        uVar3 = HAL_GetTick();\n        do {\n          if ((*DAT_080023ac & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar3 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar3 < 3);\n    HVar2 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_080023b0 = 0;\n    uVar3 = HAL_GetTick();\n    do {\n      if ((*DAT_080023ac & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar3 < 3);\n    HVar2 = HAL_TIMEOUT;\n  }\n  return HVar2;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800201c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_0800201c"
        },
        "FUN_080028d4": {
            "renaming": {
                "FUN_080028d4": "update_channel_state_080028d4",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "new_channel_state",
                "CCER": "channel_control_register",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void update_channel_state_080028d4(TIM_TypeDef *timer, uint32_t channel, uint32_t new_channel_state) {\n  uint32_t channel_mask = 4 << (channel & 0xff);\n  timer->CCER &= ~channel_mask;\n  timer->CCER |= new_channel_state << (channel & 0xff);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028d4",
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "update_channel_state_080028d4"
        },
        "FUN_0800293c": {
            "renaming": {
                "FUN_0800293c": "do_nothing_0800293c"
            },
            "code": "\nvoid do_nothing_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800293c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800293c"
        },
        "FUN_080040ec": {
            "renaming": {
                "FUN_080040ec": "uart_debug_080040ec",
                "file_UNUSED": "file_unused",
                "ptr": "data",
                "len": "length",
                "sVar1": "num_bytes_sent"
            },
            "code": "uint32_t uart_debug_080040ec(uint8_t *data, size_t length) {\n  size_t num_bytes_sent = uart_debug_080040ec_helper(data, length);\n  return num_bytes_sent;\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040ec",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "uart_debug_080040ec"
        },
        "FUN_08001460": {
            "renaming": {
                "FUN_08001460": "i2c_handle_listen_08001460",
                "*hi2c": "*i2c_handle",
                "*pData": "*data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "*pIVar2": "*i2c_instance",
                "tmpreg": "temp_register"
            },
            "code": "HAL_StatusTypeDef i2c_handle_listen_08001460(I2C_HandleTypeDef *i2c_handle, uint8_t *data, uint16_t size, uint32_t transfer_options) {\n    HAL_StatusTypeDef status;\n    I2C_TypeDef *i2c_instance;\n    uint32_t temp_register;\n\n    if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n        if (data == NULL || size == 0 || i2c_handle->Lock == HAL_LOCKED) {\n            status = HAL_ERROR;\n        }\n        else {\n            i2c_handle->Lock = HAL_LOCKED;\n            i2c_instance = i2c_handle->Instance;\n            if ((i2c_instance->CR1 & 1) == 0) {\n                i2c_instance->CR1 |= 1;\n            }\n            i2c_handle->Instance->CR1 &= 0xfffff7ff;\n            i2c_handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n            i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n            status = HAL_OK;\n            i2c_handle->ErrorCode = 0;\n            i2c_handle->pBuffPtr = data;\n            i2c_handle->XferCount = size;\n            i2c_handle->XferOptions = transfer_options;\n            i2c_handle->XferSize = i2c_handle->XferCount;\n            i2c_handle->Lock = HAL_UNLOCKED;\n            i2c_handle->Instance->CR2 |= 0x700;\n        }\n    }\n    else {\n        status = HAL_BUSY;\n    }\n    return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001460",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_handle_listen_08001460"
        },
        "FUN_08004298": {
            "renaming": {
                "FUN_08004298": "wait_until_transmission_complete_08004298",
                "this": "serial_instance",
                "_written": "has_unwritten_data",
                "_serial": "serial_data",
                "tx_head": "transmit_head",
                "tx_tail": "transmit_tail"
            },
            "code": "void __thiscall wait_until_transmission_complete_08004298(HardwareSerial *serial_instance)\n{\n  if (serial_instance->has_unwritten_data) {\n    do {\n    } while ((serial_instance->tx_head) != (serial_instance->tx_tail));\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004298",
            "calling": [],
            "imported": false,
            "current_name": "wait_until_transmission_complete_08004298"
        },
        "FUN_08003880": {
            "renaming": {
                "FUN_08003880": "i2c_transfer_08003880",
                "hi2c": "handle",
                "TransferDirection": "direction",
                "AddrMatchCode": "address",
                "piVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "tx_rx_buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT": "HAL_I2C_Slave_Sequential_Receive_IT"
            },
            "code": "void i2c_transfer_08003880(I2C_HandleTypeDef *handle, uint8_t direction, uint16_t address)\\n{\\n  i2c_t *i2c_object = get_i2c_object(handle);\\n  if ((uint)address == (handle->Init).OwnAddress1) {\\n    if (direction == \"\\0\") {\\n      i2c_object->tx_rx_buffer_size = \"\\0\";\\n      i2c_object->slave_mode = \"\\0\";\\n      if (i2c_object->on_slave_transmit != (_func_void *)0x0) {\\n        (*i2c_object->on_slave_transmit)();\\n      }\\n      HAL_I2C_Slave_Sequential_Transmit_IT(handle, i2c_object->tx_rx_buffer, (ushort)i2c_object->tx_rx_buffer_size, 8);\\n      return;\\n    }\\n    i2c_object->slave_mode = \"\\x01\";\\n    HAL_I2C_Slave_Sequential_Receive_IT(handle, i2c_object->tx_rx_buffer, 0x20, 8);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003880",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08003880"
        },
        "FUN_08003fd4": {
            "renaming": {
                "FUN_08003fd4": "handle_usart1_interrupt_08003fd4",
                "PTR_uart_handlers_08003fe8": "uart_handlers_ptr"
            },
            "code": "void handle_usart1_interrupt_08003fd4(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*PTR_uart_handlers_08003fe8);\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd4",
            "calling": [],
            "imported": false,
            "current_name": "handle_usart1_interrupt_08003fd4"
        },
        "FUN_08002f4c": {
            "renaming": {
                "FUN_08002f4c": "reset_uart_08002f4c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "gState": "global_state",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_UART_TxCpltCallback": "UART_transmission_complete_callback",
                "HAL_OK": "HAL_operation_successful",
                "0xffffffbf": "(1 << USART_CR1_UE)"
            },
            "code": "HAL_StatusTypeDef reset_uart_08002f4c(UART_HandleTypeDef *uart_handle)\n{\n    uart_handle->Instance->CR1 &= ~(1 << USART_CR1_UE);\n    uart_handle->gState = HAL_UART_STATE_READY;\n    HAL_UART_TxCpltCallback(uart_handle);\n    return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f4c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_08002f4c"
        },
        "FUN_080035bc": {
            "renaming": {
                "FUN_080035bc": "set_bit_and_clear_flags_080035bc",
                "puVar1": "bit_flag_ptr"
            },
            "code": "void set_bit_and_clear_flags_080035bc(void)\n{\n  uint32_t *bit_flag_ptr;\n  bit_flag_ptr = DAT_080035f0;\n  *DAT_080035f0 |= 0b00000001;\n  bit_flag_ptr[2] = 0;\n  *bit_flag_ptr &= 0b1111111011110110;\n  bit_flag_ptr[1] = DAT_080035f4;\n  *bit_flag_ptr &= 0b1111111111111011;\n  bit_flag_ptr[3] = 0;\n  *(uint32_t *)(DAT_080035f8 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035bc",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_flags_080035bc"
        },
        "FUN_08000c4c": {
            "renaming": {
                "FUN_08000c4c": "initialize_modbus_slave_08000c4c",
                "PTR_slave_08000c60": "PTR_slave",
                "startForkserver": "start_forkserver",
                "Modbus::begin": "Modbus_begin"
            },
            "code": "void initialize_modbus_slave_08000c4c(void)\n{\n  start_forkserver(0);\n  Modbus::begin((Modbus *)PTR_slave_08000c60_08000c60, 0x4b00);\n  return;\n}",
            "called": [
                "begin",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c4c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_modbus_slave_08000c4c"
        },
        "FUN_080025ec": {
            "renaming": {
                "FUN_080025ec": "calculate_HCLK_frequency_080025ec",
                "DAT_08002604": "data_08002604",
                "PTR_APBPrescTable_08002608": "apb_prescaler_table",
                "uVar1": "hclk_freq",
                "apb_prescaler_index": "apb_prescaler_index",
                "apb_prescaler_value": "apb_prescaler_value"
            },
            "code": "uint32_t calculate_HCLK_frequency_080025ec(void)\n{\n  uint32_t hclk_freq = HAL_RCC_GetHCLKFreq();\n  uint32_t apb_prescaler_index = (uint)(*(int *)(DAT_08002604 + 8) << 0x13) >> 0x1d;\n  uint32_t apb_prescaler_value = PTR_APBPrescTable_08002608[apb_prescaler_index];\n  return hclk_freq >> apb_prescaler_value;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ec",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "calculate_HCLK_frequency_080025ec"
        },
        "FUN_080037fc": {
            "renaming": {
                "FUN_080037fc": "handle_timer_interrupt_080037fc",
                "PTR_timer_handles_0800380c": "PTR_timer_handles",
                "TIM_HandleTypeDef": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_tim_interrupt_request"
            },
            "code": "void handle_timer_interrupt_080037fc(void)\n{\n  TIM_HandleTypeDef *timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_0800380c_0800380c + 0x18);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037fc",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037fc"
        },
        "FUN_08004a60": {
            "renaming": {
                "FUN_08004a60": "put_chars_to_stream_08004a60",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "size",
                "puVar2": "buffer_end",
                "iVar3": "chars_written",
                "iVar1": "result"
            },
            "code": "int put_chars_to_stream_08004a60(int stream, int character, void *buffer, int size) {\n  int chars_written = 0;\n  void *buffer_end = buffer + size;\n  while (size != 0) {\n    if (buffer == buffer_end) {\n      return 0;\n    }\n    int result = __sfputc_r(stream, *buffer, character, size, chars_written);\n    size = result + 1;\n    buffer = buffer + 1;\n  }\n  return result;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a60",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "put_chars_to_stream_08004a60"
        },
        "FUN_080050d0": {
            "renaming": {
                "FUN_080050d0": "validate_input_080050d0",
                "param_1": "status",
                "param_2": "input_stream",
                "uVar1": "stream_status",
                "uVar2": "stream_flags",
                "iVar3": "impure_ptr"
            },
            "code": "uint validate_input_080050d0(uint *status, uint *input_stream) {\n  uint stream_status;\n  ushort stream_flags;\n  int impure_ptr = *(int *)PTR__impure_ptr_0800519c;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (input_stream == (uint *)PTR___sf_fake_stdin_080051a0) {\n    input_stream = *(uint **)(impure_ptr + 4);\n  }\n  else if (input_stream == (uint *)PTR___sf_fake_stdout_080051a4) {\n    input_stream = *(uint **)(impure_ptr + 8);\n  }\n  else if (input_stream == (uint *)PTR___sf_fake_stderr_080051a8) {\n    input_stream = *(uint **)(impure_ptr + 0xc);\n  }\n  stream_flags = *(ushort *)(input_stream + 3);\n  stream_status = (uint)stream_flags;\n  if (-1 < (int)(stream_status << 0x1c)) {\n    if (-1 < (int)(stream_status << 0x1b)) {\n      *status = 9;\n      goto LAB_08005100;\n    }\n    if ((uint *)input_stream[0xd] != (uint *)0x0) {\n      if ((uint *)input_stream[0xd] != input_stream + 0x11) {\n        _free_r(status);\n      }\n      input_stream[0xd] = 0;\n    }\n    *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) & 0xffdb;\n    input_stream[1] = 0;\n    *input_stream = input_stream[4];\n  }\n  *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) | 8;\n  if ((input_stream[4] == 0) && ((*(ushort *)(input_stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(status,input_stream);\n  }\n  stream_flags = *(ushort *)(input_stream + 3);\n  stream_status = stream_flags & 1;\n  if ((stream_flags & 1) == 0) {\n    if (-1 < (int)((uint)stream_flags << 0x1e)) {\n      stream_status = input_stream[5];\n    }\n    input_stream[2] = stream_status;\n  }\n  else {\n    input_stream[2] = 0;\n    input_stream[6] = -input_stream[5];\n  }\n  if (input_stream[4] == 0) {\n    stream_flags = *(ushort *)(input_stream + 3);\n    stream_status = (int)(short)stream_flags & 0x80;\n    if (stream_status != 0) {\n      *(ushort *)(input_stream + 3) = stream_flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    stream_status = 0;\n  }\n  return stream_status;\n}",
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080050d0",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "validate_input_080050d0"
        },
        "FUN_08004978": {
            "renaming": {
                "FUN_08004978": "allocate_memory_block_08004978",
                "param_1": "out_size",
                "param_2": "requested_size",
                "puVar1": "current_brk",
                "uVar2": "new_brk",
                "puVar3": "current_free_list",
                "iVar4": "block_size",
                "uVar5": "free_block_size",
                "puVar6": "prev_free_list",
                "puVar7": "current_free_list",
                "uVar8": "aligned_size"
            },
            "code": "uint allocate_memory_block_08004978(undefined4 *out_size, uint requested_size)\n{\n  uint aligned_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < requested_size)) {\n    *out_size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void* current_brk = PTR___malloc_sbrk_start_08004a30;\n    uint* current_free_list = *(uint **)PTR___malloc_free_list_08004a2c;\n    uint* prev_free_list = *(uint **)PTR___malloc_free_list_08004a2c;\n    while (current_free_list != (uint *)0x0) {\n      uint free_block_size = *current_free_list - aligned_size;\n      if (-1 < (int)free_block_size) {\n        if (free_block_size < 0xc) {\n          if (prev_free_list == current_free_list) {\n            aligned_size = prev_free_list[1];\n          }\n          else {\n            aligned_size = current_free_list[1];\n          }\n          if (prev_free_list == current_free_list) {\n            *(uint *)PTR___malloc_free_list_08004a2c = aligned_size;\n            current_free_list = prev_free_list;\n          }\n          else {\n            prev_free_list[1] = aligned_size;\n          }\n        }\n        else {\n          *current_free_list = free_block_size;\n          *(uint *)((int)current_free_list + free_block_size) = aligned_size;\n          current_free_list = (uint *)((int)current_free_list + free_block_size);\n        }\n        goto end;\n      }\n      prev_free_list = current_free_list;\n      current_free_list = (uint *)current_free_list[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08004a30 == 0) {\n      uint new_brk = _sbrk_r(out_size);\n      *(void **)current_brk = new_brk;\n    }\n    current_free_list = (uint *)_sbrk_r(out_size, aligned_size);\n    if ((current_free_list != (uint *)0xffffffff) && ((current_free_list = (uint *)((int)current_free_list + 3U & 0xfffffffc), current_free_list == (uint *)((int)current_free_list + 3U & 0xfffffffc) || (_sbrk_r(out_size, (int)current_free_list - (int)current_brk) != -1)))) {\n      *current_free_list = aligned_size;\nend:\n      __malloc_unlock(out_size);\n      uint block_end = (int)current_free_list + 0xbU & 0xfffffff8;\n      int block_size = block_end - (int)(current_free_list + 1);\n      if (block_size != 0) {\n        *(int *)((int)current_free_list + block_size) = -block_size;\n        return block_end;\n      }\n      return block_end;\n    }\n    *out_size = 0xc;\n    __malloc_unlock(out_size);\n  }\n  return 0;\n}",
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004978",
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08004978"
        },
        "FUN_08002d0c": {
            "renaming": {
                "FUN_08002d0c": "check_uart_flag_08002d0c",
                "huart": "uart_handle",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "start_time",
                "Timeout": "timeout",
                "uVar1": "current_time"
            },
            "code": "HAL_StatusTypeDef check_uart_flag_08002d0c(UART_HandleTypeDef *uart_handle, uint32_t flag, FlagStatus status, uint32_t start_time, uint32_t timeout)\n{\n  uint32_t current_time;\n  do {\n    if (((flag & ~uart_handle->Instance->SR) == 0) != (bool)status) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) || ((timeout != 0 && (current_time = HAL_GetTick(), current_time - start_time <= timeout))));\n  uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xfffffe5f;\n  uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffffe;\n  uart_handle->gState = HAL_UART_STATE_READY;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  uart_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d0c",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_uart_flag_08002d0c"
        },
        "FUN_0800404c": {
            "renaming": {
                "FUN_0800404c": "handle_uart_interrupt_0800404c",
                "PTR_uart_handlers_08004060": "PTR_uart_handlers",
                "USART6_IRQn": "USART6_interrupt",
                "UART_HandleTypeDef": "UART_handler",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14)": "uart_handler"
            },
            "code": "void handle_uart_interrupt_0800404c(UART_HandleTypeDef* *(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14))\n{\n  HAL_NVIC_ClearPendingIRQ(USART6_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14));\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800404c",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_0800404c"
        },
        "FUN_08001902": {
            "renaming": {
                "FUN_08001902": "do_nothing_08001902"
            },
            "code": "\nvoid do_nothing_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001902",
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_08001902"
        },
        "FUN_08001904": {
            "renaming": {
                "FUN_08001904": "receive_data_from_i2c_08001904",
                "*hi2c": "*i2c_handler",
                "puVar1": "buffer_pointer",
                "hi2c->State": "i2c_handler->State",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_BUSY_RX",
                "hi2c->XferCount": "i2c_handler->XferCount",
                "hi2c->Instance->CR1": "i2c_handler->Instance->CR1",
                "hi2c->Instance->CR2": "i2c_handler->Instance->CR2",
                "hi2c->pBuffPtr": "i2c_handler->pBuffPtr",
                "(uint8_t)hi2c->Instance->DR": "(uint8_t)i2c_handler->Instance->DR",
                "hi2c->State = HAL_I2C_STATE_READY": "i2c_handler->State = HAL_I2C_STATE_READY",
                "hi2c->PreviousState = 0": "i2c_handler->PreviousState = 0",
                "hi2c->Mode == HAL_I2C_MODE_MEM": "i2c_handler->Mode == HAL_I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_MemRxCpltCallback(hi2c)": "HAL_I2C_MemRxCpltCallback(i2c_handler)",
                "HAL_I2C_MasterRxCpltCallback(hi2c)": "HAL_I2C_MasterRxCpltCallback(i2c_handler)",
                "hi2c->Mode = HAL_I2C_MODE_NONE": "i2c_handler->Mode = HAL_I2C_MODE_NONE"
            },
            "code": "HAL_StatusTypeDef receive_data_from_i2c_08001904(I2C_HandleTypeDef *i2c_handler)\n{\n    uint8_t *buffer_pointer;\n    if (i2c_handler->State == HAL_I2C_STATE_BUSY_RX) {\n        if (i2c_handler->XferCount < 4) {\n            if (i2c_handler->XferCount < 2) {\n                i2c_handler->Instance->CR1 &= 0xfffffbff;\n                i2c_handler->Instance->CR2 &= 0xfffff8ff;\n                buffer_pointer = i2c_handler->pBuffPtr;\n                i2c_handler->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)i2c_handler->Instance->DR;\n                i2c_handler->XferCount--;\n                i2c_handler->State = HAL_I2C_STATE_READY;\n                i2c_handler->PreviousState = 0;\n                if (i2c_handler->Mode == HAL_I2C_MODE_MEM) {\n                    i2c_handler->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MemRxCpltCallback(i2c_handler);\n                }\n                else {\n                    i2c_handler->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MasterRxCpltCallback(i2c_handler);\n                }\n            }\n        }\n        else {\n            buffer_pointer = i2c_handler->pBuffPtr;\n            i2c_handler->pBuffPtr = buffer_pointer + 1;\n            *buffer_pointer = (uint8_t)i2c_handler->Instance->DR;\n            i2c_handler->XferCount--;\n            if (i2c_handler->XferCount == 3) {\n                i2c_handler->Instance->CR2 &= 0xfffffbff;\n            }\n        }\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001904",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_from_i2c_08001904"
        },
        "FUN_08000c64": {
            "renaming": {
                "FUN_08000c64": "modbus_poll_slave_data_08000c64",
                "PTR_slave_08000c78": "slave_device_ptr",
                "PTR_au16data_08000c74": "data_array_ptr"
            },
            "code": "void modbus_poll_slave_data_08000c64(void)\n{\n  Modbus::poll((Modbus *)PTR_slave_08000c78,(uint16_t *)PTR_au16data_08000c74,16);\n  return;\n}",
            "called": [
                "poll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c64",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "modbus_poll_slave_data_08000c64"
        },
        "FUN_08002ffc": {
            "renaming": {
                "FUN_08002ffc": "receive_transmit_uart_data_08002ffc",
                "*huart": "*uart_handle",
                "HVar1": "status",
                "uVar2": "cr1_reg",
                "pUVar3": "usart_instance",
                "uVar4": "cr3_bit",
                "uVar5": "sr_reg",
                "UART_Receive_IT": "UART_Receive_IT",
                "UART_Transmit_IT": "UART_Transmit_IT",
                "UART_EndTransmit_IT": "UART_EndTransmit_IT",
                "huart->ErrorCode": "error_code",
                "huart->Instance": "usart_instance",
                "HAL_UART_ErrorCallback": "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer": "UART_EndRxTransfer",
                "huart->hdmarx": "dma_rx_handle",
                "HAL_DMA_Abort_IT": "HAL_DMA_Abort_IT",
                "huart->hdmarx->XferAbortCallback": "uart_data_transfer_abort_callback"
            },
            "code": "void receive_transmit_uart_data_08002ffc(UART_HandleTypeDef *uart_handle)\n{\n  HAL_StatusTypeDef status;\n  uint32_t sr_reg;\n  USART_TypeDef *usart_instance;\n  uint32_t cr1_reg;\n  uint32_t cr3_reg;\n  uint32_t error_code = 0;\n\n  usart_instance = uart_handle->Instance;\n  sr_reg = usart_instance->SR;\n  cr1_reg = usart_instance->CR1;\n  cr3_reg = usart_instance->CR3;\n\n  if (((sr_reg & 0xF) == 0) && ((sr_reg & 0x20) != 0) && ((cr1_reg & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n\n  if (((sr_reg & 0xF) == 0) || ((cr3_reg & 1) == 0 && ((cr1_reg & 0x120) == 0))) {\n    if (((sr_reg & 0x80) != 0) && ((cr1_reg & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n\n    if (((sr_reg & 0x40) != 0) && ((cr1_reg & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr_reg & 1) != 0) && ((cr1_reg & 0x100) != 0)) {\n      error_code |= 1;\n    }\n\n    if (((sr_reg & 4) != 0) && ((cr3_reg & 1) == 0)) {\n      error_code |= 2;\n    }\n\n    if (((sr_reg & 2) != 0) && ((cr3_reg & 1) == 0)) {\n      error_code |= 4;\n    }\n\n    if (((sr_reg & 8) != 0) && ((cr3_reg & 1) == 0)) {\n      error_code |= 8;\n    }\n\n    if (error_code != 0) {\n      if (((sr_reg & 0x20) != 0) && ((cr1_reg & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n\n      if (((error_code & 8) == 0) && ((usart_instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        error_code = 0;\n        return;\n      }\n\n      UART_EndRxTransfer(uart_handle);\n      usart_instance = uart_handle->Instance;\n\n      if ((usart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n\n      usart_instance->CR3 &= 0xFFFFFFBF;\n\n      if (uart_handle->hdmarx == NULL) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n\n      uart_handle->hdmarx->XferAbortCallback = uart_data_transfer_abort_callback;\n      status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n\n      if (status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "UART_EndRxTransfer",
                "HAL_UART_ErrorCallback",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT",
                "HAL_DMA_Abort_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ffc",
            "calling": [
                "UART4_IRQHandler",
                "USART2_IRQHandler",
                "UART7_IRQHandler",
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "USART1_IRQHandler",
                "UART5_IRQHandler",
                "UART8_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_transmit_uart_data_08002ffc"
        },
        "FUN_0800387c": {
            "renaming": {
                "FUN_0800387c": "get_i2c_struct_from_handle_0800387c",
                "hi2c": "i2c_handle",
                "i2c_t": "i2c_struct",
                "EventCount": "event_count"
            },
            "code": "typedef struct i2c_struct { uint32_t EventCount; } i2c_t; \n\ni2c_t * get_i2c_struct_from_handle_0800387c(I2C_HandleTypeDef *i2c_handle) \n{\n  return (i2c_t *)&i2c_handle[-1].EventCount;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800387c",
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_struct_from_handle_0800387c"
        },
        "FUN_0800351e": {
            "renaming": {
                "FUN_0800351e": "find_pin_for_peripheral_0800351e",
                "*map": "*pin_map",
                "PVar1": "pin_name"
            },
            "code": "PinName_conflict find_pin_for_peripheral_0800351e(void *peripheral, PinMap_conflict *pin_map) {\\n\\\n    PinName_conflict pin_name;\\n\\\n    if (peripheral != (void *)0x0) {\\n\\\n        pin_name = pinmap_find_pin(peripheral, pin_map);\\n\\\n        return pin_name;\\n\\\n    }\\n\\\n    return NC;\\n\\\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800351e",
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_0800351e"
        },
        "FUN_080059f8": {
            "renaming": {
                "FUN_080059f8": "do_nothing_080059f8"
            },
            "code": "\nvoid do_nothing_080059f8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f8",
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "do_nothing_080059f8"
        },
        "FUN_08002f66": {
            "renaming": {
                "FUN_08002f66": "receive_data_08002f66",
                "*huart": "*uart",
                "pbVar1": "rx_byte",
                "uVar2": "rx_xfer_count",
                "puVar3": "rx_buffer_ptr"
            },
            "code": "HAL_StatusTypeDef receive_data_08002f66(UART_HandleTypeDef *uart)\n{\n  uint8_t *rx_buffer_ptr;\n  uint16_t rx_xfer_count;\n\n  if (uart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n\n  if ((uart->Init).WordLength == UART_WORDLENGTH_9B) {\n    if ((uart->Init).Parity == UART_PARITY_NONE) {\n      *(uint16_t *)uart->pRxBuffPtr = (uint16_t)((uart->Instance->DR << 0x17) >> 0x17);\n      uart->pRxBuffPtr += 2;\n    }\n    else {\n      *(uint16_t *)uart->pRxBuffPtr = (uint16_t)uart->Instance->DR & 0xff;\n      uart->pRxBuffPtr += 1;\n    }\n  }\n  else if ((uart->Init).Parity == UART_PARITY_NONE) {\n    rx_buffer_ptr = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = rx_buffer_ptr + 1;\n    *rx_buffer_ptr = (uint8_t)uart->Instance->DR;\n  }\n  else {\n    rx_buffer_ptr = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = rx_buffer_ptr + 1;\n    *rx_buffer_ptr = (uint8_t)uart->Instance->DR & 0x7f;\n  }\n\n  rx_xfer_count = uart->RxXferCount - 1;\n  uart->RxXferCount = rx_xfer_count;\n\n  if (rx_xfer_count != 0) {\n    return HAL_OK;\n  }\n\n  uart->Instance->CR1 &= 0xfffffedf;\n  uart->Instance->CR3 &= 0xfffffffe;\n  uart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f66",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_08002f66"
        },
        "FUN_080034b6": {
            "renaming": {
                "FUN_080034b6": "set_gpio_pin_state_080034b6",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "val": "state",
                "GPIO_PIN_RESET": "GPIO_PIN_STATE_RESET",
                "GPIO_PIN_SET": "GPIO_PIN_STATE_SET"
            },
            "code": "void set_gpio_pin_state_080034b6(GPIO_TypeDef *gpio_port, uint32_t gpio_pin, uint32_t state) {\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin, GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port, (uint16_t)gpio_pin, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034b6",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080034b6"
        },
        "FUN_08003eac": {
            "renaming": {
                "FUN_08003eac": "set_serial_callback_08003eac",
                "*obj": "serial_object",
                "*callback": "callback_function",
                "bVar1": "index",
                "PTR_tx_callback_08003ef4": "callback_pointer",
                "PTR_tx_callback_obj_08003ef8": "object_pointer",
                "obj->irq": "serial_object->irq",
                "HAL_NVIC_SetPriority": "HAL_NVIC_Set_IRQ_Priority",
                "HAL_NVIC_EnableIRQ": "HAL_NVIC_Enable_IRQ",
                "PTR_uart_handlers_08003efc": "handler_pointer",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08003efc + (uint)obj->index * 4)": "*(UART_HandleTypeDef **)(handler_pointer + index * 4)",
                "obj->tx_buff + obj->tx_tail": "serial_object->tx_buff + serial_object->tx_tail"
            },
            "code": "void set_serial_callback_08003eac(serial_t *serial_object, _func_int_serial_t_ptr *callback_function)\n{\n  if (serial_object != NULL) {\n    uint8_t index = serial_object->index;\n    _func_int_serial_t_ptr **callback_ptr = (_func_int_serial_t_ptr **)(PTR_tx_callback_08003ef4 + index * 4);\n    *callback_ptr = callback_function;\n    serial_t **object_ptr = (serial_t **)(PTR_tx_callback_obj_08003ef8 + index * 4);\n    *object_ptr = serial_object;\n    HAL_NVIC_SetPriority(serial_object->irq, 0, 2);\n    HAL_NVIC_EnableIRQ(serial_object->irq);\n    UART_HandleTypeDef **handler_ptr = (UART_HandleTypeDef **)(PTR_uart_handlers_08003efc + index * 4);\n    HAL_UART_Transmit_IT(*handler_ptr, serial_object->tx_buff + serial_object->tx_tail, 1);\n  }\n}\n",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003eac",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "set_serial_callback_08003eac"
        },
        "FUN_08004064": {
            "renaming": {
                "FUN_08004064": "handle_uart_interrupt_08004064",
                "UART7_IRQn": "UART7_Interrupt",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18)": "uart_handle",
                "PTR_uart_handlers_08004078": "PTR_uart_handlers_08004078"
            },
            "code": "void handle_uart_interrupt_08004064(UART_HandleTypeDef* *(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18))\n{\n  HAL_NVIC_ClearPendingIRQ(UART7_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18));\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004064",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_08004064"
        },
        "FUN_08003e18": {
            "renaming": {
                "FUN_08003e18": "receive_from_serial_08003e18",
                "obj": "serial_obj",
                "c": "received_char",
                "uVar1": "is_rx_active"
            },
            "code": "int receive_from_serial_08003e18(serial_t *serial_obj, uchar *received_char) {\n  uint8_t is_rx_active;\n  if (serial_obj == NULL) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_obj);\n  if (is_rx_active == 0) {\n    *received_char = serial_obj->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **) (PTR_uart_handlers_08003e50 + (uint) serial_obj->index * 4), &serial_obj->recv, 1);\n    return 0;\n  }\n  return -1;\n}",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e18",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_from_serial_08003e18"
        },
        "FUN_080040fc": {
            "renaming": {
                "FUN_080040fc": "set_errno_to_22_080040fc",
                "pid_UNUSED": "pid_unused",
                "sig_UNUSED": "sig_unused",
                "PTR_errno_08004108": "PTR_errno_08004108"
            },
            "code": "int set_errno_to_22_080040fc(int pid_unused, int sig_unused) {\n    *(undefined4 *)PTR_errno_08004108 = 0x16;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040fc",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_22_080040fc"
        },
        "FUN_08002dd0": {
            "renaming": {
                "FUN_08002dd0": "send_data_via_uart_08002dd0",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "start_time"
            },
            "code": "HAL_StatusTypeDef send_data_via_uart_08002dd0(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  \n  if (uart_handle->gState != HAL_UART_STATE_READY) {\n    status = HAL_BUSY;\n  }\n  else if (data == NULL || size == 0 || uart_handle->Lock == HAL_LOCKED) {\n    status = HAL_ERROR;\n  }\n  else {\n    uart_handle->Lock = HAL_LOCKED;\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_BUSY_TX;\n    start_time = HAL_GetTick();\n    uart_handle->TxXferSize = size;\n    uart_handle->TxXferCount = size;\n    while (uart_handle->TxXferCount != 0) {\n      uart_handle->TxXferCount--;\n      if (uart_handle->Init.WordLength == UART_WORDLENGTH_9B) {\n        status = UART_WaitOnFlagUntilTimeout(uart_handle, UART_FLAG_TXE, RESET, start_time, timeout);\n        if (status != HAL_OK) {\n          return HAL_TIMEOUT;\n        }\n        uart_handle->Instance->DR = *(uint16_t *)data & 0x1FF;\n        if (uart_handle->Init.Parity == UART_PARITY_NONE) {\n          data += 2;\n        }\n        else {\n          data++;\n        }\n      }\n      else {\n        status = UART_WaitOnFlagUntilTimeout(uart_handle, UART_FLAG_TXE, RESET, start_time, timeout);\n        if (status != HAL_OK) {\n          return HAL_TIMEOUT;\n        }\n        uart_handle->Instance->DR = *data;\n        data++;\n      }\n    }\n    status = UART_WaitOnFlagUntilTimeout(uart_handle, UART_FLAG_TC, RESET, start_time, timeout);\n    if (status == HAL_OK) {\n      uart_handle->gState = HAL_UART_STATE_READY;\n      uart_handle->Lock = HAL_UNLOCKED;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dd0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "send_data_via_uart_08002dd0"
        },
        "FUN_08004860": {
            "renaming": {
                "FUN_08004860": "calculate_formatted_output_08004860",
                "__stream": "file_pointer",
                "__format": "format_string",
                "iVar1": "return_value",
                "in_r2": "in_register_2",
                "in_r3": "in_register_3",
                "uStack_8": "stack_parameter_1",
                "uStack_4": "stack_parameter_2"
            },
            "code": "int calculate_formatted_output_08004860(FILE *file_pointer, char *format_string, ...) {\n    int return_value;\n    undefined4 in_register_2;\n    undefined4 in_register_3;\n    undefined4 stack_parameter_1;\n    undefined4 stack_parameter_2;\n  \n    stack_parameter_1 = in_register_2;\n    stack_parameter_2 = in_register_3;\n    return_value = _vcalculate_formatted_output_08004860_r(*(undefined4 *)PTR__impure_ptr_08004880, file_pointer, format_string, &stack_parameter_1, file_pointer, &stack_parameter_2);\n    return return_value;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004860",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "calculate_formatted_output_08004860"
        },
        "FUN_08004622": {
            "renaming": {
                "__thiscall Print::FUN_08004622": "print_number",
                "this": "print",
                "n": "number",
                "base": "base",
                "sVar1": "result",
                "FUN_08004622Number": "print_number_base",
                "FUN_08004622": "print_number_08004622"
            },
            "code": "size_t __thiscall print_number_08004622(Print *print, ulong number, int base) {\n  size_t result;\n  if (base != 0) {\n    result = print_number_08004622_base(print, number, (uint8_t)base);\n  } else {\n    result = (**print->_vptr_Print)(print, number & 0xff);\n  }\n  return result;\n}",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004622",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_08004622"
        },
        "FUN_08003414": {
            "renaming": {
                "FUN_08003414": "stop_PWM_signal_08003414",
                "pin": "pin",
                "Channel": "channel_number",
                "uVar1": "function",
                "timHandle": "timHandle"
            },
            "code": "void stop_PWM_signal_08003414(PinName_conflict pin)\n{\n    uint32_t channel_number;\n    uint32_t function;\n    TIM_HandleTypeDef timHandle;\n\n    timHandle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_PWM_08003468);\n\n    if ((timHandle.Instance != (TIM_TypeDef *)0x0) && ((channel_number = get_pwm_channel(pin),\n                                                      channel_number == 0 || channel_number == 4 ||\n                                                      channel_number == 8 || channel_number == 0xc ||\n                                                      channel_number == 0x18)))\n    {\n        function = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08003468);\n\n        if ((function & 0x100000) == 0)\n        {\n            HAL_TIM_PWM_Stop(&timHandle, channel_number);\n        }\n        else\n        {\n            HAL_TIMEx_PWMN_Stop(&timHandle, channel_number);\n        }\n\n        HAL_TIM_PWM_DeInit(&timHandle);\n    }\n}\n",
            "called": [
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "HAL_TIM_PWM_Stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003414",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_PWM_signal_08003414"
        },
        "FUN_08005718": {
            "renaming": {
                "FUN_08005718": "seek_file_08005718",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "error_ptr",
                "iVar2": "result"
            },
            "code": "void seek_file_08005718(int *error_code, int file_descriptor, int offset, int whence) {\n    int result = lseek(file_descriptor, offset, whence);\n    if (result == -1 && *PTR_errno_08005738 != 0) {\n        *error_code = *PTR_errno_08005738;\n    }\n    return;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005718",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "seek_file_08005718"
        },
        "FUN_080011c0": {
            "renaming": {
                "FUN_080011c0": "i2c_handle_mem_mode_080011c0",
                "*hi2c": "*handle",
                "hi2c": "handle",
                "Mode": "mode",
                "EventCount": "event_count",
                "Instance": "instance",
                "DR": "data_register",
                "Devaddress": "dev_address",
                "Init": "init",
                "AddressingMode": "addressing_mode",
                "State": "state",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TRANSMITTING"
            },
            "code": "HAL_StatusTypeDef i2c_handle_mem_mode_080011c0(I2C_HandleTypeDef *handle)\n{\n    if (handle->Mode == HAL_I2C_MODE_MEM) {\n        if (handle->EventCount == 0) {\n            handle->Instance->DR = handle->Devaddress & 0xfe;\n        }\n        else {\n            handle->Instance->DR = handle->Devaddress & 0xff | 1;\n        }\n    }\n    else if ((handle->Init).AddressingMode == 0x4000) {\n        if (handle->State == HAL_I2C_STATE_BUSY_TX) {\n            handle->Instance->DR = handle->Devaddress & 0xfe;\n        }\n        else {\n            handle->Instance->DR = handle->Devaddress & 0xff | 1;\n        }\n    }\n    else if (handle->EventCount == 0) {\n        handle->Instance->DR = (handle->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n    }\n    else if (handle->EventCount == 1) {\n        handle->Instance->DR = (handle->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n    }\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011c0",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_mem_mode_080011c0"
        },
        "FUN_080047f0": {
            "renaming": {
                "FUN_080047f0": "initialize_static_data_080047f0"
            },
            "code": "void initialize_static_data_080047f0(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_080047f0"
        },
        "FUN_0800502c": {
            "renaming": {
                "FUN_0800502c": "encode_input_0800502c",
                "param_1": "input_length",
                "param_2": "input_value",
                "param_3": "stream",
                "param_4": "param_4",
                "iVar1": "status",
                "uVar2": "output_value",
                "puVar3": "output_byte"
            },
            "code": "uint encode_input_0800502c(int input_length, uint input_value, int *stream, undefined4 param_4)\n{\n  int status;\n  uint output_value;\n  undefined *output_byte;\n\n  if ((input_length != 0) && (*(int *)(input_length + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (int *)PTR___sf_fake_stdin_080050c4) {\n    stream = *(int **)(input_length + 4);\n  }\n  else if (stream == (int *)PTR___sf_fake_stdout_080050c8) {\n    stream = *(int **)(input_length + 8);\n  }\n  else if (stream == (int *)PTR___sf_fake_stderr_080050cc) {\n    stream = *(int **)(input_length + 0xc);\n  }\n  stream[2] = stream[6];\n  output_value = (uint)*(ushort *)(stream + 3);\n  status = output_value << 0x1c;\n  if (((status < 0) && (output_value = stream[4], output_value != 0)) ||\n     (status = __swsetup_r(input_length,stream,status,output_value,param_4), status == 0)) {\n    status = *stream - stream[4];\n    input_value = input_value & 0xff;\n    if ((status < stream[5]) || (status = _fflush_r(input_length,stream), status == 0)) {\n      stream[2] = stream[2] + -1;\n      output_byte = (undefined *)*stream;\n      *stream = (int)(output_byte + 1);\n      *output_byte = (char)input_value;\n      if (status + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return input_value;\n        }\n        if (input_value != 10) {\n          return input_value;\n        }\n      }\n      status = _fflush_r(input_length,stream);\n      if (status == 0) {\n        return input_value;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800502c",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "encode_input_0800502c"
        },
        "FUN_08000b54": {
            "renaming": {
                "__thiscall Modbus::FUN_08000b54": "modbus_process_request",
                "this": "modbus_instance",
                "regs": "registers",
                "u8size": "register_count",
                "uVar1": "exception_code",
                "u8exception": "exception_code",
                "uVar2": "serial_port_byte",
                "uVar3": "current_time",
                "unaff_r5": "receive_buffer_byte",
                "au16regs": "registers",
                "u8regsize": "register_count",
                "u8serno": "serial_number",
                "port": "serial_port",
                "getRxBuffer": "get_receive_buffer_byte",
                "au8Buffer": "receive_buffer",
                "u8lastError": "last_error",
                "u8id": "id",
                "validateRequest": "validate_request",
                "millis": "current_time_millis",
                "u32timeOut": "timeout",
                "u16timeOut": "timeout_interval",
                "process_FC1": "process_function_code_1_or_2",
                "process_FC3": "process_function_code_3_or_4",
                "process_FC5": "process_function_code_5",
                "process_FC6": "process_function_code_6",
                "process_FC15": "process_function_code_15",
                "process_FC16": "process_function_code_16",
                "buildException": "build_exception_response",
                "sendTxBuffer": "send_transmit_buffer",
                "FUN_08000b54": "modbus_process_request_08000b54"
            },
            "code": "int8_t __thiscall modbus_process_request_08000b54(Modbus *modbus_instance, uint16_t *registers, uint8_t register_count) {\n    uint8_t exception_code;\n    uint8_t serial_port_byte;\n    uint8_t receive_buffer_byte;\n    uint32_t current_time;\n\n    modbus_instance->registers = registers;\n    modbus_instance->register_count = register_count;\n\n    if (modbus_instance->serial_number < 4) {\n        serial_port_byte = (*(modbus_instance->port->super_Stream).super_Print._vptr_Print[2])();\n        receive_buffer_byte = serial_port_byte & 0xff;\n    }\n\n    if (receive_buffer_byte == 0) {\n        exception_code = 0;\n    }\n    else if ((int)receive_buffer_byte < 8) {\n        exception_code = 0;\n    }\n    else {\n        receive_buffer_byte = get_receive_buffer_byte(modbus_instance);\n        modbus_instance->last_error = receive_buffer_byte;\n\n        if (modbus_instance->receive_buffer[0] == modbus_instance->id) {\n            exception_code = validate_request(modbus_instance);\n\n            if (exception_code == 0) {\n                current_time = millis();\n                modbus_instance->timeout = modbus_instance->timeout_interval + current_time;\n                modbus_instance->last_error = 0;\n\n                switch(modbus_instance->receive_buffer[1]) {\n                    case 0x01:\n                    case 0x02:\n                        exception_code = process_function_code_1_or_2(modbus_instance, registers, register_count);\n                        break;\n                    case 0x03:\n                    case 0x04:\n                        exception_code = process_function_code_3_or_4(modbus_instance, registers, register_count);\n                        break;\n                    case 0x05:\n                        exception_code = process_function_code_5(modbus_instance, registers, register_count);\n                        break;\n                    case 0x06:\n                        exception_code = process_function_code_6(modbus_instance, registers, register_count);\n                        break;\n                    case 0x0f:\n                        exception_code = process_function_code_15(modbus_instance, registers, register_count);\n                        break;\n                    case 0x10:\n                        exception_code = process_function_code_16(modbus_instance, registers, register_count);\n                        break;\n                }\n            }\n            else {\n                if (exception_code != 0xff) {\n                    build_exception_response(modbus_instance, exception_code);\n                    send_transmit_buffer(modbus_instance);\n                }\n                modbus_instance->last_error = exception_code;\n            }\n        }\n        else {\n            exception_code = 0;\n        }\n    }\n\n    return exception_code;\n}",
            "called": [
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "process_FC3",
                "millis",
                "sendTxBuffer",
                "process_FC1",
                "buildException",
                "process_FC6",
                "process_FC15",
                "process_FC16"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000b54",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "modbus_process_request_08000b54"
        },
        "FUN_08000d96": {
            "renaming": {
                "FUN_08000d96": "do_nothing_08000d96"
            },
            "code": "\nvoid do_nothing_08000d96(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d96",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08000d96"
        },
        "FUN_0800376e": {
            "renaming": {
                "FUN_0800376e": "handle_timer_interrupt_0800376e",
                "htim": "timer_handle",
                "psVar1": "timer_object",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "interrupt_handler"
            },
            "code": "void handle_timer_interrupt_0800376e(TIM_HandleTypeDef *timer_handle)\n{\n  stimer_t *timer_object;\n  timer_object = get_timer_object(timer_handle);\n  if (timer_object->interrupt_handler != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_object->interrupt_handler)(timer_object);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376e",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800376e"
        },
        "FUN_08000d98": {
            "renaming": {
                "FUN_08000d98": "configure_systick_08000d98",
                "TickPriority": "tick_priority",
                "uVar1": "syst_tick_config",
                "PTR_SystemCoreClock_08000ddc": "clock_frequency",
                "PTR_uwTickFreq_08000dd8": "tick_frequency",
                "SysTick_IRQn": "SysTick_IRQn",
                "PTR_uwTickPrio_08000de0": "uwTickPrio"
            },
            "code": "HAL_StatusTypeDef configure_systick_08000d98(uint32_t tick_priority)\n{\n  uint32_t PTR_SystemCoreClock_08000ddc = *(uint *)PTR_SystemCoreClock_08000ddc;\n  uint32_t PTR_uwTickFreq_08000dd8 = (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08000dd8);\n  uint32_t syst_tick_config = HAL_SYSTICK_Config((uint32_t)((ulonglong)PTR_SystemCoreClock_08000ddc / PTR_uwTickFreq_08000dd8));\n  if (syst_tick_config != 0) {\n    return HAL_ERROR;\n  }\n  if (tick_priority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn, tick_priority, 0);\n  *(uint32_t *)PTR_PTR_uwTickPrio_08000de0_08000de0 = tick_priority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d98",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configure_systick_08000d98"
        },
        "FUN_08003f48": {
            "renaming": {
                "FUN_08003f48": "transmit_uart_data_08003f48",
                "*huart": "*uart_handler",
                "bVar1": "uart_index",
                "iVar3": "callback_result",
                "iVar4": "tx_callback_obj",
                "uVar2": "uart_index_uint",
                "PTR_tx_callback_obj_08003f88": "PTR_tx_callback_obj",
                "PTR_tx_callback_08003f8c": "PTR_tx_callback",
                "PTR_uart_handlers_08003f90": "PTR_uart_handlers"
            },
            "code": "void transmit_uart_data_08003f48(UART_HandleTypeDef *uart_handler) {\n  uint8_t uart_index = uart_handler->Instance->USARTx_BASE - USART1_BASE;\n  if (uart_index < 10) {\n    uint32_t tx_callback_obj = *(uint32_t *)(PTR_tx_callback_08003f8c_obj_08003f88_08003f88 + uart_index * 4);\n    uint32_t tx_callback = *(uint32_t *)(PTR_tx_callback_08003f8c_08003f8c + uart_index * 4);\n    uint32_t callback_result = (*(void (**)(void))(tx_callback))(tx_callback_obj);\n    if (callback_result != -1) {\n      uint8_t *tx_buffer = (uint8_t *)(*(uint32_t *)(tx_callback_obj + 0x68) + *(uint16_t *)(tx_callback_obj + 0x6e));\n      HAL_UART_Transmit_IT((UART_HandleTypeDef *)(*(uint32_t *)(PTR_uart_handlers_08003f90_08003f90 + *(uint8_t *)(tx_callback_obj + 0x44) * 4)), tx_buffer, 1);\n    }\n  }\n}",
            "called": [
                "uart_index",
                "HAL_UART_Transmit_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f48",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_uart_data_08003f48"
        },
        "FUN_0800340c": {
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_0800340c(TIM_HandleTypeDef *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800340c",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_0800340c"
        },
        "FUN_0800352e": {
            "renaming": {
                "FUN_0800352e": "find_pin_function_0800352e",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "uint32_t find_pin_function_0800352e(PinName_conflict target_pin, PinMap_conflict *pin_map) {\n    while (true) {\n        if (pin_map->pin == NC) {\n            return 0xffffffff;\n        }\n        if (pin_map->pin == target_pin) {\n            break;\n        }\n        pin_map++;\n    }\n    return pin_map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800352e",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800352e"
        },
        "FUN_0800582c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800582c": "set_flags_of_pointers",
                "PTR_id_080058c0": "pointer_1",
                "PTR_id_080058c4": "pointer_2",
                "PTR_id_080058c8": "pointer_3",
                "PTR_id_080058cc": "pointer_4",
                "PTR_id_080058d0": "pointer_5",
                "PTR_id_080058d4": "pointer_6",
                "PTR_id_080058d8": "pointer_7",
                "PTR_id_080058dc": "pointer_8",
                "PTR_id_080058e0": "pointer_9",
                "PTR_id_080058e4": "pointer_10",
                "PTR_id_080058e8": "pointer_11",
                "PTR_id_080058ec": "pointer_12",
                "FUN_0800582c": "set_flags_of_pointers_0800582c"
            },
            "code": "void set_flags_of_pointers_0800582c(void)\n{\n    if (*(int *)PTR_id_080058c0 < 0)\n    {\n        *(undefined4 *)PTR_id_080058c0 = 1;\n    }\n    if (*(int *)PTR_id_080058c4 < 0)\n    {\n        *(undefined4 *)PTR_id_080058c4 = 1;\n    }\n    if (*(int *)PTR_id_080058c8 < 0)\n    {\n        *(undefined4 *)PTR_id_080058c8 = 1;\n    }\n    if (*(int *)PTR_id_080058cc < 0)\n    {\n        *(undefined4 *)PTR_id_080058cc = 1;\n    }\n    if (*(int *)PTR_id_080058d0 < 0)\n    {\n        *(undefined4 *)PTR_id_080058d0 = 1;\n    }\n    if (*(int *)PTR_id_080058d4 < 0)\n    {\n        *(undefined4 *)PTR_id_080058d4 = 1;\n    }\n    if (*(int *)PTR_id_080058d8 < 0)\n    {\n        *(undefined4 *)PTR_id_080058d8 = 1;\n    }\n    if (*(int *)PTR_id_080058dc < 0)\n    {\n        *(undefined4 *)PTR_id_080058dc = 1;\n    }\n    if (*(int *)PTR_id_080058e0 < 0)\n    {\n        *(undefined4 *)PTR_id_080058e0 = 1;\n    }\n    if (*(int *)PTR_id_080058e4 < 0)\n    {\n        *(undefined4 *)PTR_id_080058e4 = 1;\n    }\n    if (*(int *)PTR_id_080058e8 < 0)\n    {\n        *(undefined4 *)PTR_id_080058e8 = 1;\n    }\n    if (*(int *)PTR_id_080058ec < 0)\n    {\n        *(undefined4 *)PTR_id_080058ec = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800582c",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_of_pointers_0800582c"
        },
        "FUN_08001ab0": {
            "renaming": {
                "FUN_08001ab0": "i2c_handle_08001ab0",
                "hi2c": "handle",
                "HVar1": "status",
                "puVar2": "buff_ptr",
                "pIVar3": "instance"
            },
            "code": "void i2c_handle_08001ab0(I2C_HandleTypeDef *handle)\n{\n  HAL_StatusTypeDef status;\n  uint8_t *buff_ptr;\n  I2C_TypeDef *instance;\n  if ((uint8_t)handle->State - 0x29 < 2) {\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((handle->State != HAL_I2C_STATE_ABORT) && ((handle->Instance->CR2 & 0x800) == 0)) {\n      handle->State = HAL_I2C_STATE_READY;\n    }\n    handle->PreviousState = 0;\n    handle->Mode = HAL_I2C_MODE_NONE;\n  }\n  handle->Instance->CR1 &= 0xfffff7ff;\n  instance = handle->Instance;\n  if ((instance->CR2 & 0x800) == 0) {\n    if (handle->State == HAL_I2C_STATE_ABORT) {\n      handle->State = HAL_I2C_STATE_READY;\n      handle->ErrorCode = 0;\n      if ((instance->SR1 & 0x40) != 0) {\n        buff_ptr = handle->pBuffPtr;\n        handle->pBuffPtr = buff_ptr + 1;\n        *buff_ptr = (uint8_t)instance->DR;\n      }\n      handle->Instance->CR1 &= 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(handle);\n    }\n    else {\n      if ((instance->SR1 & 0x40) != 0) {\n        buff_ptr = handle->pBuffPtr;\n        handle->pBuffPtr = buff_ptr + 1;\n        *buff_ptr = (uint8_t)instance->DR;\n      }\n      HAL_I2C_ErrorCallback(handle);\n    }\n  }\n  else {\n    instance->CR2 &= 0xfffff7ff;\n    if (handle->hdmatx->State == HAL_DMA_STATE_READY) {\n      handle->hdmarx->XferAbortCallback = handle->hdmatx->XferAbortCallback;\n      status = HAL_DMA_Abort_IT(handle->hdmarx);\n      if (status != HAL_OK) {\n        if ((handle->Instance->SR1 & 0x40) != 0) {\n          buff_ptr = handle->pBuffPtr;\n          handle->pBuffPtr = buff_ptr + 1;\n          *buff_ptr = (uint8_t)handle->Instance->DR;\n        }\n        handle->Instance->CR1 &= 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmarx->XferAbortCallback)(handle->hdmarx);\n      }\n    }\n    else {\n      handle->hdmatx->XferAbortCallback = handle->hdmarx->XferAbortCallback;\n      status = HAL_DMA_Abort_IT(handle->hdmatx);\n      if (status != HAL_OK) {\n        handle->Instance->CR1 &= 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmatx->XferAbortCallback)(handle->hdmatx);\n      }\n    }\n  }\n  if ((handle->State == HAL_I2C_STATE_LISTEN) && ((handle->ErrorCode & 4) != 0)) {\n    handle->XferOptions = handle->XferOptions;\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_READY;\n    handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(handle);\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_DMA_Abort_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ab0",
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_08001ab0"
        },
        "FUN_08001f9c": {
            "renaming": {
                "FUN_08001f9c": "wait_for_flag_08001f9c",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "tmpreg": "flag_mask",
                "flag_register": "flag_register",
                "control_register": "control_register",
                "DAT_0800200c": "DAT_0800200c",
                "DAT_08002010": "DAT_08002010",
                "DAT_08002014": "DAT_08002014",
                "DAT_08002018": "DAT_08002018"
            },
            "code": "HAL_StatusTypeDef wait_for_flag_08001f9c(void)\n{\n  uint32_t start_time = HAL_GetTick();\n  uint32_t current_time;\n  uint32_t timeout = 1000;\n  uint32_t *flag_register = (uint32_t *)(DAT_08002014 + 4);\n  uint32_t flag_mask = 0x20000;\n  uint32_t *control_register = (uint32_t *)(DAT_0800200c + 0x40);\n  uint32_t control_mask = 0x10000000;\n  *control_register |= control_mask;\n  *DAT_08002010 = 1;\n  while (1) {\n    if ((*flag_register & flag_mask) != 0) {\n      return HAL_OK;\n    }\n    current_time = HAL_GetTick();\n    if (current_time - start_time >= timeout) {\n      return HAL_TIMEOUT;\n    }\n  }\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f9c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "wait_for_flag_08001f9c"
        },
        "FUN_08000d8c": {
            "renaming": {
                "FUN_08000d8c": "do_nothing_loop_08000d8c"
            },
            "code": "void do_nothing_loop_08000d8c(void)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d8c",
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_loop_08000d8c"
        },
        "FUN_08000d8e": {
            "renaming": {
                "FUN_08000d8e": "hardware_config_08000d8e",
                "ctx": "context",
                "hw_config_FUN_08000d8e": "configure_hardware"
            },
            "code": "int hardware_config_08000d8e(EVP_PKEY_CTX *context) {\n  configure_hardware();\n  return (int)context;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d8e",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "hardware_config_08000d8e"
        },
        "FUN_08004638": {
            "renaming": {
                "FUN_08004638": "print_value_with_base_08004638",
                "b": "value",
                "base": "base",
                "sVar1": "length"
            },
            "code": "size_t __thiscall print_value_with_base_08004638(Print *this, uchar value, int base) {\n    size_t length;\n    length = print_value_with_base_08004638(this, (uint)value, base);\n    return length;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004638",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_value_with_base_08004638"
        },
        "FUN_08005604": {
            "renaming": {
                "FUN_08005604": "always_returns_one_08005604"
            },
            "code": "__pid_t always_returns_one_08005604(void)\n{\n    return 1;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005604",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "always_returns_one_08005604"
        },
        "FUN_080008cc": {
            "renaming": {
                "FUN_080008cc": "modbus_response_modification_080008cc",
                "this": "modbus_instance",
                "u8exception": "exception_code",
                "bVar1": "second_byte"
            },
            "code": "void __thiscall modbus_response_modification_080008cc(Modbus *modbus_instance, uint8_t exception_code) {\n  byte second_byte = modbus_instance->au8Buffer[1];\n  modbus_instance->au8Buffer[0] = modbus_instance->u8id;\n  modbus_instance->au8Buffer[1] = second_byte ^ 0x80;\n  modbus_instance->au8Buffer[2] = exception_code;\n  modbus_instance->u8BufferSize = '\\x03';\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008cc",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "modbus_response_modification_080008cc"
        },
        "FUN_08004a84": {
            "renaming": {
                "FUN_08004a84": "FUNC_08004a84"
            },
            "code": "\nint FUNC_08004a84(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08004c90) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08004c98) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08004c9c) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_08004ac6:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08004c70;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__08004c94,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08004ca0;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__08004c94 & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08004ba0;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08004ba0:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      param_3 = param_3 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar8 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08004ca0,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n    param_3 = param_3 + 1;\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_08004ca4,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_08004cac,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_08004ca8 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_08004c22;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08004c70;\nLAB_08004c22:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_08004ac6;\n}\n\n",
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004a84",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_08004a84"
        },
        "FUN_08005608": {
            "renaming": {
                "FUN_08005608": "read_and_update_file_offset_08005608",
                "param_1": "file_descriptor",
                "param_2": "file_data_offset_address",
                "iVar1": "read_result",
                "uVar2": "updated_offset",
                "bVar3": "read_success"
            },
            "code": "void read_and_update_file_offset_08005608(int file_descriptor,int file_data_offset_address)\n{\n  int read_result;\n  uint updated_offset;\n  bool read_success;\n  \n  read_result = _read_r(file_descriptor,(int)*(short *)(file_data_offset_address + 0xe));\n  read_success = read_result >= 0;\n  if (read_success) {\n    updated_offset = *(int *)(file_data_offset_address + 0x54) + read_result;\n  }\n  else {\n    updated_offset = *(ushort *)(file_data_offset_address + 0xc) & 0xffffefff;\n  }\n  if (read_success) {\n    *(uint *)(file_data_offset_address + 0x54) = updated_offset;\n  }\n  if (!read_success) {\n    *(short *)(file_data_offset_address + 0xc) = (short)updated_offset;\n  }\n  return;\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005608",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_file_offset_08005608"
        },
        "FUN_08002efa": {
            "renaming": {
                "FUN_08002efa": "receive_data_08002efa",
                "*huart": "*uart_handle",
                "*pData": "*data",
                "Size": "size"
            },
            "code": "HAL_StatusTypeDef receive_data_08002efa(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size)\n{\n    if (uart_handle->RxState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == (uint8_t *)0x0) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (uart_handle->Lock != HAL_LOCKED) {\n        uart_handle->pRxBuffPtr = data;\n        uart_handle->RxXferSize = size;\n        uart_handle->RxXferCount = size;\n        uart_handle->ErrorCode = 0;\n        uart_handle->RxState = HAL_UART_STATE_BUSY_RX;\n        uart_handle->Lock = HAL_UNLOCKED;\n        uart_handle->Instance->CR3 = uart_handle->Instance->CR3 | 1;\n        uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x120;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efa",
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "imported": false,
            "current_name": "receive_data_08002efa"
        },
        "FUN_0800268c": {
            "renaming": {
                "FUN_0800268c": "do_nothing_0800268c"
            },
            "code": "\nvoid do_nothing_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800268c",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800268c"
        },
        "FUN_080058f0": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_080058f0": "set_pointers_to_one",
                "FUN_080058f0": "set_pointers_to_one_080058f0"
            },
            "code": "void set_pointers_to_one_080058f0(void)\n{\n    if (-1 < *(int *)PTR_id_08005954 << 0x1f) {\n        *(undefined4 *)PTR_id_08005954 = 1;\n    }\n    if (-1 < *(int *)PTR_id_08005958 << 0x1f) {\n        *(undefined4 *)PTR_id_08005958 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800595c << 0x1f) {\n        *(undefined4 *)PTR_id_0800595c = 1;\n    }\n    if (-1 < *(int *)PTR_id_08005960 << 0x1f) {\n        *(undefined4 *)PTR_id_08005960 = 1;\n    }\n    if (-1 < *(int *)PTR_id_08005964 << 0x1f) {\n        *(undefined4 *)PTR_id_08005964 = 1;\n    }\n    if (-1 < *(int *)PTR_id_08005968 << 0x1f) {\n        *(undefined4 *)PTR_id_08005968 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800596c << 0x1f) {\n        *(undefined4 *)PTR_id_0800596c = 1;\n    }\n    if (-1 < *(int *)PTR_id_08005970 << 0x1f) {\n        *(undefined4 *)PTR_id_08005970 = 1;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058f0",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_080058f0"
        },
        "FUN_08001aac": {
            "renaming": {
                "FUN_08001aac": "do_nothing_08001aac"
            },
            "code": "\nvoid do_nothing_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001aac",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "do_nothing_08001aac"
        },
        "FUN_080056b4": {
            "renaming": {
                "FUN_080056b4": "close_file_and_set_errno_080056b4",
                "param_1": "err_num",
                "param_2": "fd",
                "puVar1": "errno_ptr",
                "iVar2": "close_result"
            },
            "code": "void close_file_and_set_errno_080056b4(int *err_num, int fd) {\n  undefined *errno_ptr;\n  int close_result;\n  errno_ptr = PTR_errno_080056d0;\n  *(undefined4 *)PTR_errno_080056d0 = 0;\n  close_result = _close(fd);\n  if ((close_result == -1) && (*(int *)errno_ptr != 0)) {\n    *err_num = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080056b4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_and_set_errno_080056b4"
        },
        "FUN_0800450a": {
            "renaming": {
                "FUN_0800450a": "print_address_0800450a",
                "this": "ip_address",
                "p": "printer",
                "iVar3": "i",
                "iVar4": "total_bytes_printed",
                "sVar1": "bytes_printed",
                "sVar2": "dot_printed"
            },
            "code": "size_t __thiscall print_address_0800450a(IPAddress *this, Print *printer) {\n  size_t total_bytes_printed = 0;\n  for (int i = 0; i < 3; i++) {\n    size_t bytes_printed = Print::print(printer, (this->_address).bytes[i], 10);\n    size_t dot_printed = Print::print(printer, '.');\n    total_bytes_printed += bytes_printed + dot_printed;\n  }\n  total_bytes_printed += Print::print(printer, (this->_address).bytes[3], 10);\n  return total_bytes_printed;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800450a",
            "calling": [],
            "imported": false,
            "current_name": "print_address_0800450a"
        },
        "FUN_0800377c": {
            "renaming": {
                "FUN_0800377c": "handle_timer_interrupts_0800377c",
                "PTR_timer_handles_08003794": "PTR_timer_handles_08003794",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler",
                "timer_handle_1": "timer_handle_1",
                "timer_handle_2": "timer_handle_2"
            },
            "code": "void handle_timer_interrupts_0800377c(void)\n{\n  TIM_HandleTypeDef* timer_handle_1 = *(TIM_HandleTypeDef**)PTR_timer_handles_08003794;\n  TIM_HandleTypeDef* timer_handle_2 = *(TIM_HandleTypeDef**)(PTR_timer_handles_08003794 + 0x24);\n  if (timer_handle_1 != NULL) {\n    HAL_TIM_IRQHandler(timer_handle_1);\n  }\n  if (timer_handle_2 != NULL) {\n    HAL_TIM_IRQHandler(timer_handle_2);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800377c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupts_0800377c"
        },
        "FUN_08003fec": {
            "renaming": {
                "FUN_08003fec": "handle_uart_interrupt_08003fec",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4)": "uart_handler",
                "PTR_uart_handlers_08004000": "PTR_uart_handlers_08004000",
                "HAL_NVIC_ClearPendingIRQ": "HAL_NVIC_ClearPendingIRQ",
                "USART2_IRQn": "USART2_IRQn",
                "HAL_UART_IRQHandler": "HAL_UART_IRQHandler"
            },
            "code": "void handle_uart_interrupt_08003fec(UART_HandleTypeDef* *(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4))\n{\n    HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n    HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4));\n    return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fec",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_08003fec"
        },
        "FUN_0800268e": {
            "renaming": {
                "FUN_0800268e": "reset_tim_state_0800268e",
                "htim": "tim_handle",
                "HAL_TIM_STATE_BUSY": "TIM_BUSY",
                "HAL_TIM_STATE_RESET": "TIM_RESET",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "pTVar1": "tim_instance",
                "TIM_TypeDef": "tim_instance_type",
                "CCER": "capture_compare_enable_register",
                "CR1": "control_register_1",
                "HAL_TIM_PWM_MspDeInit": "deinitialize_tim_pwm"
            },
            "code": "HAL_StatusTypeDef reset_tim_state_0800268e(TIM_HandleTypeDef *tim_handle)\n{\n  TIM_TypeDef *tim_instance;\n  tim_handle->State = HAL_TIM_STATE_BUSY;\n  tim_instance = tim_handle->Instance;\n  if (((tim_instance->CCER & 0x1111) == 0) && ((tim_instance->CCER & 0x444) == 0)) {\n    tim_instance->CR1 &= 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(tim_handle);\n  tim_handle->State = HAL_TIM_STATE_RESET;\n  tim_handle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800268e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "reset_tim_state_0800268e"
        },
        "FUN_080008e2": {
            "renaming": {
                "FUN_080008e2": "decode_modbus_request_080008e2",
                "regs": "data_registers",
                "u8size": "num_registers",
                "uVar1": "starting_address",
                "uVar2": "num_bits",
                "uVar3": "i",
                "uVar4": "bit_index",
                "uVar5": "num_bytes"
            },
            "code": "int8_t __thiscall decode_modbus_request_080008e2(Modbus *this, uint16_t *data_registers, uint8_t num_registers)\n{\n  uint16_t starting_address = makeWord(this->au8Buffer[2], this->au8Buffer[3]);\n  uint16_t num_bits = makeWord(this->au8Buffer[4], this->au8Buffer[5]);\n  uint8_t num_bytes = (uint8_t)(((uint)num_bits << 0x15) >> 0x18);\n  if ((num_bits & 7) != 0) {\n    num_bytes++;\n  }\n  this->au8Buffer[2] = num_bytes;\n  this->u8BufferSize = 3;\n  uint8_t bit_index = 0;\n  for (uint16_t i = 0; i < num_bits; i++) {\n    uint16_t reg_index = (i + starting_address) * 0x100000 >> 0x18;\n    if (((int)(uint)data_registers[reg_index] >> (i + starting_address & 0xf) & 1U) == 0) {\n      this->au8Buffer[this->u8BufferSize] &= ~(byte)(1 << bit_index);\n    }\n    else {\n      this->au8Buffer[this->u8BufferSize] |= (byte)(1 << bit_index);\n    }\n    bit_index = (bit_index + 1) % 8;\n    if (bit_index == 0) {\n      this->u8BufferSize++;\n    }\n  }\n  if ((num_bits & 7) != 0) {\n    this->u8BufferSize++;\n  }\n  num_bytes = this->u8BufferSize;\n  sendTxBuffer(this);\n  return num_bytes + 2;\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008e2",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "decode_modbus_request_080008e2"
        },
        "FUN_080045c8": {
            "renaming": {
                "__thiscall Print::FUN_080045c8": "print_number_in_given_base",
                "this": "print_instance",
                "n": "number",
                "base": "base",
                "cVar1": "current_digit",
                "sVar2": "length_of_string",
                "sVar3": "return_value",
                "uVar4": "current_remainder",
                "uVar5": "base_as_uint",
                "uVar6": "current_quotient",
                "__s": "current_char_pointer",
                "buf": "string_buffer",
                "FUN_080045c8": "print_number_in_given_base_080045c8"
            },
            "code": "size_t __thiscall print_number_in_given_base_080045c8(Print *print_instance, ulong number, uint8_t base) {\n  char current_digit;\n  size_t length_of_string;\n  size_t return_value;\n  uint current_quotient;\n  uint current_remainder;\n  char string_buffer [33];\n  uint base_as_uint = (uint)base;\n  string_buffer[32] = '\\0';\n  if (base_as_uint < 2) {\n    base_as_uint = 10;\n  }\n  char *current_char_pointer = string_buffer + 0x20;\n  do {\n    current_quotient = number / base_as_uint;\n    current_remainder = (number & 0xff) - ((int)(short)current_quotient * (int)(short)base_as_uint & 0xffU) & 0xff;\n    current_char_pointer = current_char_pointer + -1;\n    if (current_remainder < 10) {\n      current_digit = current_remainder + '0';\n    }\n    else {\n      current_digit = current_remainder + '7';\n    }\n    *current_char_pointer = current_digit;\n    number = current_quotient;\n  } while (current_quotient != 0);\n  if (current_char_pointer == (char *)0x0) {\n    length_of_string = 0;\n  }\n  else {\n    length_of_string = strlen(current_char_pointer);\n    return_value = (*print_instance->_vptr_Print[1])(length_of_string,current_char_pointer,length_of_string);\n  }\n  return length_of_string;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c8",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "print_number_in_given_base_080045c8"
        },
        "FUN_08003d18": {
            "renaming": {
                "FUN_08003d18": "transmit_data_via_uart_08003d18",
                "data": "data_buffer",
                "size": "data_size",
                "pin": "digital_pin",
                "HVar1": "status",
                "uVar2": "start_time",
                "pvVar3": "peripheral",
                "uVar4": "current_time",
                "uVar5": "uart_handler_index",
                "PinName_conflict": "PinName_conflict",
                "PinMap_conflict": "PinMap_conflict",
                "PTR_digitalPin_08003dc0": "PTR_digitalPin_08003dc0",
                "PTR_PinMap_UART_TX_08003dc4": "PTR_PinMap_UART_TX_08003dc4",
                "PTR_uart_handlers_08003dc8": "PTR_uart_handlers_08003dc8",
                "PTR_serial_debug_08003dcc": "PTR_serial_debug_08003dcc",
                "HAL_GetTick": "HAL_GetTick",
                "pinmap_peripheral": "pinmap_peripheral",
                "HAL_UART_Transmit": "HAL_UART_Transmit",
                "byte": "byte"
            },
            "code": "size_t transmit_data_via_uart_08003d18(PinName_conflict digital_pin, uint8_t *data, uint32_t size)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time = HAL_GetTick();\n  void *peripheral;\n  uint uart_handler_index;\n  PinMap_conflict *uart_tx_pin_map = (PinMap_conflict *)PTR_PinMap_UART_TX_08003dc4;\n  UART_HandleTypeDef **uart_handlers = (UART_HandleTypeDef **)PTR_uart_handlers_08003dc8;\n  uint8_t *serial_debug = PTR_serial_debug_08003dcc;\n  PinName_conflict *digital_pin_ptr = (PinName_conflict *)(PTR_digitalPin_08003dc0 + 0x9a);\n  PinName_conflict pin = *digital_pin_ptr;\n  peripheral = pinmap_peripheral(pin, uart_tx_pin_map);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  uart_handler_index = 0;\n  while ((uart_handler_index < 10 && ((*(int *)(uart_handlers + uart_handler_index) == 0 || (peripheral = pinmap_peripheral(pin, uart_tx_pin_map), **(void ***)uart_handlers[uart_handler_index] != peripheral))))) {\n    uart_handler_index = (uart_handler_index + 1) & 0xff;\n  }\n  if (9 < (byte)serial_debug[0x44]) {\n    uart_debug_init();\n    if (9 < (byte)serial_debug[0x44]) {\n      return 0;\n    }\n    uart_handler_index = (uint)(byte)serial_debug[0x44];\n  }\n  do {\n    status = HAL_UART_Transmit(*(uart_handlers + uart_handler_index), data, (uint16_t)size, 1000);\n    if (status == HAL_OK) {\n      return size;\n    }\n  } while (HAL_GetTick() - start_time < 1000);\n  return 0;\n}",
            "called": [
                "uart_debug_init",
                "HAL_UART_Transmit",
                "HAL_GetTick",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003d18",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmit_data_via_uart_08003d18"
        },
        "FUN_08004640": {
            "renaming": {
                "FUN_08004640": "concatenate_bytes_08004640",
                "h": "high_byte",
                "l": "low_byte"
            },
            "code": "uint16_t concatenate_bytes_08004640(uint8_t high_byte, uint8_t low_byte)\n{\n  return CONCAT11(high_byte, low_byte);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004640",
            "calling": [
                "process_FC5",
                "validateRequest",
                "process_FC3",
                "process_FC1",
                "process_FC6",
                "process_FC15",
                "process_FC16"
            ],
            "imported": false,
            "current_name": "concatenate_bytes_08004640"
        },
        "FUN_08000c7c": {
            "renaming": {
                "FUN_08000c7c": "initialize_static_variables_and_destructors_08000c7c"
            },
            "code": "void initialize_static_variables_and_destructors_08000c7c(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c7c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_and_destructors_08000c7c"
        },
        "FUN_08004760": {
            "renaming": {
                "FUN_08004760": "handle_gpio_exti_interrupt_08004760"
            },
            "code": "void handle_gpio_exti_interrupt_08004760(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004760",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_08004760"
        },
        "FUN_080034ce": {
            "renaming": {
                "FUN_080034ce": "initialize_system_080034ce"
            },
            "code": "void initialize_system_080034ce(void)\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}",
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080034ce",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_system_080034ce"
        },
        "FUN_08003798": {
            "renaming": {
                "FUN_08003798": "handle_timer_event_08003798",
                "PTR_timer_handles_080037a8": "PTR_timer_handles_080037a8",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler",
                "current_timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_event_08003798(void)\n{\n  TIM_HandleTypeDef* current_timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_080037a8 + 4);\n  if (current_timer_handle != NULL) {\n    HAL_TIM_IRQHandler(current_timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003798",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_event_08003798"
        },
        "FUN_080047fe": {
            "renaming": {
                "FUN_080047fe": "register_exit_function_080047fe",
                "param_1": "exit_function",
                "param_2": "arg"
            },
            "code": "void register_exit_function_080047fe(void (*exit_function)(void*), void* arg) {\n  __cxa_atexit(exit_function, arg);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047fe",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_exit_function_080047fe"
        },
        "FUN_08005974": {
            "renaming": {
                "std::ctype_byname<char>::FUN_08005974": "set_flags",
                "PTR_id_080059d8": "ptr_id_d8",
                "PTR_id_080059dc": "ptr_id_dc",
                "PTR_id_080059e0": "ptr_id_e0",
                "PTR_id_080059e4": "ptr_id_e4",
                "PTR_id_080059e8": "ptr_id_e8",
                "PTR_id_080059ec": "ptr_id_ec",
                "PTR_id_080059f0": "ptr_id_f0",
                "PTR_id_080059f4": "ptr_id_f4",
                "FUN_08005974": "set_flags_08005974"
            },
            "code": "void set_flags_08005974(){\n  if (*(int *)PTR_id_080059d8 < 0) {\n    *(int *)PTR_id_080059d8 = 1;\n  }\n  if (*(int *)PTR_id_080059dc < 0) {\n    *(int *)PTR_id_080059dc = 1;\n  }\n  if (*(int *)PTR_id_080059e0 < 0) {\n    *(int *)PTR_id_080059e0 = 1;\n  }\n  if (*(int *)PTR_id_080059e4 < 0) {\n    *(int *)PTR_id_080059e4 = 1;\n  }\n  if (*(int *)PTR_id_080059e8 < 0) {\n    *(int *)PTR_id_080059e8 = 1;\n  }\n  if (*(int *)PTR_id_080059ec < 0) {\n    *(int *)PTR_id_080059ec = 1;\n  }\n  if (*(int *)PTR_id_080059f0 < 0) {\n    *(int *)PTR_id_080059f0 = 1;\n  }\n  if (*(int *)PTR_id_080059f4 < 0) {\n    *(int *)PTR_id_080059f4 = 1;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005974",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_08005974"
        },
        "FUN_08001256": {
            "renaming": {
                "FUN_08001256": "i2c_handle_state_08001256",
                "hi2c": "handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef i2c_handle_state_08001256(I2C_HandleTypeDef *handle)\n{\n  uint32_t transfer_options = handle->XferOptions;\n  I2C_TypeDef *i2c_instance = handle->Instance;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  \n  if ((handle->State == HAL_I2C_STATE_BUSY_RX) && ((handle->EventCount != 0 || (handle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((handle->EventCount == 0) && ((handle->Init).AddressingMode == I2C_ADDRESSINGMODE_10BIT)) {\n      i2c_instance->CR1 = i2c_instance->CR1 | I2C_CR1_POS;\n      handle->EventCount += 1;\n    }\n    else {\n      if (handle->XferCount == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | I2C_CR1_STOP;\n      }\n      else if (handle->XferCount == 1) {\n        if (transfer_options == I2C_FIRST_FRAME) {\n          i2c_instance->CR1 &= ~I2C_CR1_ACK;\n          if ((i2c_instance->CR2 & I2C_CR2_LAST) == 0) {\n            i2c_instance->CR1 |= I2C_CR1_START;\n          }\n          else {\n            i2c_instance->CR1 &= ~I2C_CR1_START;\n          }\n        }\n        else if (((transfer_options == I2C_NEXT_FRAME) || (transfer_options == I2C_FIRST_AND_LAST_FRAME)) || (handle->PreviousState == I2C_STATE_ADDR_10BIT)) {\n          i2c_instance->CR1 &= ~I2C_CR1_ACK;\n          i2c_instance->CR1 |= I2C_CR1_STOP;\n        }\n        else if (handle->XferOptions == I2C_NO_OPTION_FRAME) {\n          i2c_instance->CR1 |= I2C_CR1_ACK;\n        }\n        else {\n          i2c_instance->CR1 &= ~I2C_CR1_ACK;\n        }\n      }\n      else if (handle->XferCount == 2) {\n        if (handle->XferOptions == I2C_NO_OPTION_FRAME) {\n          i2c_instance->CR1 |= I2C_CR1_ACK;\n        }\n        else {\n          i2c_instance->CR1 &= ~I2C_CR1_ACK;\n          i2c_instance->CR1 |= I2C_CR1_POS;\n        }\n        if ((i2c_instance->CR2 & I2C_CR2_LAST) != 0) {\n          i2c_instance->CR2 |= I2C_CR2_RELOAD;\n        }\n      }\n      else {\n        i2c_instance->CR1 |= I2C_CR1_ACK;\n        if ((i2c_instance->CR2 & I2C_CR2_LAST) != 0) {\n          i2c_instance->CR2 |= I2C_CR2_RELOAD;\n        }\n      }\n      handle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001256",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_state_08001256"
        },
        "FUN_08004884": {
            "renaming": {
                "FUN_08004884": "execute_global_destructors_08004884",
                "puVar1": "preinit_array_end",
                "puVar2": "preinit_array_start",
                "puVar3": "dtors_array_entry",
                "iVar4": "preinit_array_size",
                "iVar5": "i",
                "**(code **)(puVar1 + iVar5 * 4)": "function_ptr",
                "(int)PTR___preinit_array_end_080048c0 - (int)PTR___preinit_array_end_080048bc": "preinit_array_size",
                "(int)dtors_array_entry - (int)preinit_array_start": "dtors_array_size"
            },
            "code": "void execute_global_destructors_08004884(void)\n{\n  void **preinit_array_end = PTR___preinit_array_end_080048bc;\n  void **preinit_array_start = PTR___preinit_array_end_080048c4;\n  void **dtors_array_entry = PTR___do_global_dtors_aux_fini_array_entry_080048c8;\n  int (int)PTR___preinit_array_end_080048c0 - (int)PTR___preinit_array_end_080048bc = (int)PTR___preinit_array_end_080048c0 - (int)PTR___preinit_array_end_080048bc;\n  int dtors_array_size = (int)dtors_array_entry - (int)preinit_array_start;\n  for (int i = 0; i < (int)PTR___preinit_array_end_080048c0 - (int)PTR___preinit_array_end_080048bc / sizeof(void*); ++i) {\n    void (*function_ptr)(void) = (void (*)(void))(preinit_array_end[i]);\n    function_ptr();\n  }\n  _init();\n  for (int i = 0; i < dtors_array_size / sizeof(void*); ++i) {\n    void (*function_ptr)(void) = (void (*)(void))(preinit_array_start[i]);\n    function_ptr();\n  }\n}",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004884",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_global_destructors_08004884"
        },
        "FUN_08004648": {
            "renaming": {
                "FUN_08004648": "initialize_evp_pkey_context_08004648",
                "ctx": "context"
            },
            "code": "void initialize_evp_pkey_context_08004648(EVP_PKEY_CTX *context){\n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004648",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_evp_pkey_context_08004648"
        },
        "FUN_08000600": {
            "renaming": {
                "__thiscall Modbus::FUN_08000600": "set_serial_port",
                "this": "self",
                "u32speed": "speed",
                "uVar1": "serno",
                "iVar2": "loop_var",
                "u8serno": "serial_number",
                "port": "port",
                "HardwareSerial": "HardwareSerial",
                "PTR_Serial3_08000668": "PTR_Serial3_08000668",
                "u8txenpin": "txen_pin",
                "pinMode": "pinMode",
                "digitalWrite": "digitalWrite",
                "u8BufferSize": "buffer_size",
                "u8lastRec": "last_received",
                "u16errCnt": "error_count",
                "u16OutCnt": "outgoing_count",
                "u16InCnt": "incoming_count",
                "FUN_08000600": "Modbus::set_serial_port_08000600"
            },
            "code": "void __thiscall Modbus::set_serial_port_08000600(Modbus *this,long speed)\n{\n  uint8_t serno = this->serial_number;\n  HardwareSerial *port;\n  if (serno == 2) {\n    port = (HardwareSerial *)PTR_Serial3_08000668;\n  }\n  else if (serno == 3) {\n    port = (HardwareSerial *)PTR_Serial3_08000668;\n  }\n  else if (serno == 1) {\n    port = (HardwareSerial *)PTR_Serial3_08000668;\n  }\n  else {\n    port = (HardwareSerial *)PTR_Serial3_08000668;\n  }\n  HardwareSerial::begin(port, speed, SERIAL_8N1);\n  if (this->txen_pin > 1) {\n    pinMode((uint)this->txen_pin, OUTPUT);\n    digitalWrite((uint)this->txen_pin, LOW);\n  }\n  while ((*(this->port->super_Stream).super_Print._vptr_Print[3])() >= 0);\n  this->buffer_size = 0;\n  this->last_received = 0;\n  this->error_count = 0;\n  this->outgoing_count = 0;\n  this->incoming_count = 0;\n  return;\n}",
            "called": [
                "digitalWrite",
                "pinMode",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000600",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "Modbus::set_serial_port_08000600"
        },
        "FUN_080045be": {
            "renaming": {
                "__thiscall Print::FUN_080045be": "print_character",
                "this": "print_object",
                "c": "character",
                "sVar1": "character_size",
                "FUN_080045be": "print_character_080045be"
            },
            "code": "size_t __thiscall print_character_080045be(Print *print_object, char character) {\n  size_t character_size = (**print_object->_vptr_Print)(print_object, (int)character);\n  return character_size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045be",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_character_080045be"
        },
        "FUN_08004646": {
            "renaming": {
                "FUN_08004646": "do_nothing_08004646"
            },
            "code": "\nvoid do_nothing_08004646(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004646",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08004646"
        },
        "FUN_0800407c": {
            "renaming": {
                "FUN_0800407c": "handle_uart_interrupt_0800407c",
                "PTR_uart_handlers_08004090": "PTR_uart_handlers",
                "UART8_IRQn": "UART8_Interrupt",
                "UART_HandleTypeDef": "UART_Handler",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004090 + 0x1c)": "uart_handler"
            },
            "code": "void handle_uart_interrupt_0800407c(UART_HandleTypeDef* *(UART_HandleTypeDef **)(PTR_uart_handlers_08004090 + 0x1c))\n{\n  HAL_NVIC_ClearPendingIRQ(UART8_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004090 + 0x1c));\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800407c",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_0800407c"
        },
        "FUN_08000728": {
            "renaming": {
                "FUN_08000728": "calculate_crc_08000728",
                "this": "modbus",
                "u8length": "length",
                "uVar2": "crc",
                "uVar3": "bit",
                "uVar4": "i",
                "bVar1": "j"
            },
            "code": "uint16_t __thiscall calculate_crc_08000728(Modbus *this,uint8_t length)\n{\n  uint16_t crc = 0xFFFF;\n  for (uint8_t i = 0; i < length; i++) {\n    crc ^= this->data[i];\n    for (uint8_t j = 0; j < 8; j++) {\n      if (crc & 0x0001) {\n        crc = (crc >> 1) ^ 0xA001;\n      } else {\n        crc >>= 1;\n      }\n    }\n  }\n  return (crc << 8) | (crc >> 8);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000728",
            "calling": [
                "sendTxBuffer"
            ],
            "imported": false,
            "current_name": "calculate_crc_08000728"
        },
        "FUN_0800354a": {
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_index"
            },
            "code": "uint32_t find_pin_function_0800354a(PinName_conflict pin, PinMap_conflict *map)\n{\n  uint32_t function_index;\n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  function_index = pinmap_find_function(pin, map);\n  return function_index;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800354a",
            "calling": [
                "get_pwm_channel",
                "uart_init",
                "get_dac_channel",
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800354a"
        },
        "FUN_0800124a": {
            "renaming": {
                "FUN_0800124a": "set_i2c_device_address_0800124a",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address"
            },
            "code": "HAL_StatusTypeDef set_i2c_device_address_0800124a(I2C_HandleTypeDef *i2c_handle)\n{\n  i2c_handle->Instance->DR = i2c_handle->Devaddress & 0xff;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800124a",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_i2c_device_address_0800124a"
        },
        "FUN_08004094": {
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "incr": "increment_size",
                "pcVar1": "current_pointer",
                "pcVar2": "new_pointer"
            },
            "code": "caddr_t allocate_memory_08004094(int increment_size)\n{\n  caddr_t current_pointer;\n  caddr_t new_pointer;\n  \n  if (*(int *)PTR_heap_end_080040c4 == 0) {\n    *(undefined **)PTR_heap_end_080040c4 = PTR__ebss_080040c8;\n  }\n  current_pointer = *(caddr_t *)PTR_heap_end_080040c4;\n  new_pointer = current_pointer + increment_size;\n  if (new_pointer <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_080040c4 = new_pointer;\n    return current_pointer;\n  }\n  *(undefined4 *)PTR_errno_080040cc = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004094",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08004094"
        },
        "FUN_080033c8": {
            "renaming": {
                "FUN_080033c8": "clear_dac_buffer_080033c8",
                "*hdac": "*dac_handle",
                "PTR_DAT_080033d4": "dac_buffer_ptr"
            },
            "code": "void clear_dac_buffer_080033c8(DAC_HandleTypeDef *dac_handle)\n{\n  uint32_t *PTR_DAT_080033d4 = (uint32_t *)(DAT_080033d4 + 0x40);\n  *PTR_DAT_080033d4 = (*PTR_DAT_080033d4) & 0xdfffffff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033c8",
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "imported": false,
            "current_name": "clear_dac_buffer_080033c8"
        },
        "FUN_080031fc": {
            "renaming": {
                "FUN_080031fc": "get_gpio_080031fc",
                "port_idx": "port_index",
                "pGVar1": "gpio",
                "tmpreg": "gpio_reg"
            },
            "code": "GPIO_TypeDef * get_gpio_080031fc(uint32_t port_index) {\n  GPIO_TypeDef *gpio;\n  uint32_t gpio_reg = *(uint *)(DAT_08003350 + 0x30);\n  switch(port_index) {\n    case 0:\n      gpio_reg |= 1;\n      gpio = DAT_08003354;\n      break;\n    case 1:\n      gpio_reg |= 2;\n      gpio = DAT_08003358;\n      break;\n    case 2:\n      gpio_reg |= 4;\n      gpio = DAT_0800335c;\n      break;\n    case 3:\n      gpio_reg |= 8;\n      gpio = DAT_08003360;\n      break;\n    case 4:\n      gpio_reg |= 0x10;\n      gpio = DAT_08003364;\n      break;\n    case 5:\n      gpio_reg |= 0x20;\n      gpio = DAT_08003368;\n      break;\n    case 6:\n      gpio_reg |= 0x40;\n      gpio = DAT_0800336c;\n      break;\n    case 7:\n      gpio_reg |= 0x80;\n      gpio = DAT_08003370;\n      break;\n    case 8:\n      gpio_reg |= 0x100;\n      gpio = DAT_08003374;\n      break;\n    case 9:\n      gpio_reg |= 0x200;\n      gpio = DAT_08003378;\n      break;\n    case 10:\n      gpio_reg |= 0x400;\n      gpio = DAT_0800337c;\n      break;\n    default:\n      gpio = (GPIO_TypeDef *)0x0;\n  }\n  *(uint *)(DAT_08003350 + 0x30) = gpio_reg;\n  return gpio;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031fc",
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "imported": false,
            "current_name": "get_gpio_080031fc"
        },
        "FUN_08005580": {
            "renaming": {
                "FUN_08005580": "process_request_08005580",
                "param_1": "request_status",
                "param_2": "request_num",
                "param_3": "param_3",
                "param_4": "param_4",
                "_Var1": "pid",
                "uVar2": "status",
                "iVar3": "handler"
            },
            "code": "int process_request_08005580(int* request_status, uint request_num, int param_3, int param_4) {\n  __pid_t pid;\n  int status;\n  code* handler;\n  if (request_num > 31) {\n    *request_status = 22;\n    return -1;\n  }\n  handler = *(code**)(request_status + 0x44);\n  if ((handler != NULL) && (handler != (code*)1)) {\n    if (handler == (code*)-1) {\n      *request_status = 22;\n      return 1;\n    }\n    *(undefined4*)(request_status + request_num * 4 + 0x44) = 0;\n    (*handler)(request_num);\n    return 0;\n  }\n  pid = _getpid_r();\n  status = _kill_r(request_status, pid, request_num, param_4);\n  return status;\n}",
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005580",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "process_request_08005580"
        },
        "FUN_08000690": {
            "renaming": {
                "FUN_08000690": "initialize_modbus_08000690",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level"
            },
            "code": "void initialize_modbus_08000690(int should_initialize, int priority_level)\n{\n    if (should_initialize != 1) {\n        return;\n    }\n    if (priority_level == 0xffff) {\n        Modbus::Modbus((Modbus *)PTR_slave_080006b0, '\\x01', '\\0', '\\0');\n    }\n    return;\n}",
            "called": [
                "Modbus"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000690",
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "imported": false,
            "current_name": "initialize_modbus_08000690"
        },
        "FUN_08004254": {
            "renaming": {
                "FUN_08004254": "read_next_byte_08004254",
                "this": "serial",
                "_serial": "serial_data",
                "uVar1": "rx_tail"
            },
            "code": "int __thiscall read_next_byte_08004254(HardwareSerial *serial) {\n  uint rx_tail = (uint)(serial->_serial).rx_tail;\n  if ((serial->_serial).rx_head != rx_tail) {\n    return (uint)(serial->_serial).rx_buff[rx_tail];\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004254",
            "calling": [],
            "imported": false,
            "current_name": "read_next_byte_08004254"
        },
        "FUN_080054fc": {
            "renaming": {
                "FUN_080054fc": "decode_and_allocate_080054fc",
                "param_1": "memory_pool",
                "param_2": "buffer",
                "uVar1": "decoded_value",
                "iVar2": "size",
                "local_18": "memory_size",
                "local_14": "local_buffer",
                "DAT_08005578": "undefined_datum"
            },
            "code": "void decode_and_allocate_080054fc(int param_1, int* buffer){\n    ushort decoded_value;\n    int size;\n    int* local_buffer;\n\n    if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x1e)) {\n        local_buffer = buffer;\n        decoded_value = __swhatbuf_r(param_1, buffer, &size, &local_buffer);\n        int* allocated_buffer = _malloc_r(param_1, size);\n        if (allocated_buffer != 0) {\n            *(undefined4 *)(param_1 + 0x28) = DAT_08005578;\n            *buffer = (int)allocated_buffer;\n            *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x80;\n            buffer[5] = size;\n            buffer[4] = (int)allocated_buffer;\n            if ((local_buffer != (int *)0x0) && (_isatty_r(param_1,(int)*(short *)((int)buffer + 0xe)) != 0)) {\n                *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(buffer + 3) = decoded_value | *(ushort *)(buffer + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(buffer + 3) << 0x16 < 0) {\n            return;\n        }\n        *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 2;\n    }\n    *buffer = (int)buffer + 0x47;\n    buffer[4] = (int)buffer + 0x47;\n    buffer[5] = 1;\n    return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080054fc",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "decode_and_allocate_080054fc"
        },
        "FUN_08001420": {
            "renaming": {
                "FUN_08001420": "read_next_byte_from_i2c_buffer_08001420",
                "hi2c": "i2c_handle",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "pbVar1": "N/A"
            },
            "code": "HAL_StatusTypeDef read_next_byte_from_i2c_buffer_08001420(I2C_HandleTypeDef *hi2c)\n{\n  byte *buffer_pointer;\n  \n  if (hi2c->XferCount != 0) {\n    buffer_pointer = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = buffer_pointer + 1;\n    hi2c->Instance->DR = (uint)*buffer_pointer;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001420",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "read_next_byte_from_i2c_buffer_08001420"
        },
        "FUN_080026ca": {
            "renaming": {
                "FUN_080026ca": "do_nothing_080026ca"
            },
            "code": "\nvoid do_nothing_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026ca",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080026ca"
        },
        "FUN_08000de4": {
            "renaming": {
                "FUN_08000de4": "initialize_system_08000de4",
                "FUN_08000de4Tick": "initialize_system_tick",
                "DAT_08000e14": "dat_08000e14",
                "puVar1": "ptr_dat_08000e14"
            },
            "code": "HAL_StatusTypeDef initialize_system_08000de4(void)\n{\n  uint32_t *ptr_DAT_08000e14;\n\n  ptr_DAT_08000e14 = DAT_08000e14;\n  *DAT_08000e14 |= 0x200;\n  *ptr_DAT_08000e14 |= 0x400;\n  *ptr_DAT_08000e14 |= 0x100;\n  HAL_NVIC_SetPriorityGrouping(3);\n  initialize_system_08000de4_tick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000de4",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initialize_system_08000de4"
        },
        "FUN_08003840": {
            "renaming": {
                "FUN_08003840": "handle_timer_interrupt_08003840",
                "PTR_timer_handles_08003850": "PTR_timer_handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08003840(void)\n{\n    TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_08003850_08003850 + 0x28);\n    if (timer_handle != NULL)\n    {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003840",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003840"
        },
        "FUN_080026ce": {
            "renaming": {
                "FUN_080026ce": "process_timer_interrupts_080026ce",
                "htim": "timer_handle",
                "pTVar1": "timer_instance",
                "SR": "status_register",
                "DIER": "interrupt_enable_register",
                "HAL_TIM_ACTIVE_CHANNEL_1": "TIM_CHANNEL_1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "TIM_CHANNEL_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "TIM_CHANNEL_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "TIM_CHANNEL_4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "TIM_CHANNEL_NONE",
                "CCMR1": "capture_compare_mode_register_1",
                "CCMR2": "capture_compare_mode_register_2",
                "CC1S": "capture_compare_1_selection",
                "CC2S": "capture_compare_2_selection",
                "CC3S": "capture_compare_3_selection",
                "CC4S": "capture_compare_4_selection",
                "TIM_FLAG_CC1": "TIM_SR_CC1IF",
                "TIM_FLAG_CC2": "TIM_SR_CC2IF",
                "TIM_FLAG_CC3": "TIM_SR_CC3IF",
                "TIM_FLAG_CC4": "TIM_SR_CC4IF",
                "TIM_FLAG_UPDATE": "TIM_SR_UIF",
                "TIM_FLAG_BREAK": "TIM_SR_BIF",
                "TIM_FLAG_TRIGGER": "TIM_SR_TIF",
                "TIM_FLAG_COM": "TIM_SR_COMIF",
                "TIM_IT_CC1": "TIM_DIER_CC1IE",
                "TIM_IT_CC2": "TIM_DIER_CC2IE",
                "TIM_IT_CC3": "TIM_DIER_CC3IE",
                "TIM_IT_CC4": "TIM_DIER_CC4IE",
                "TIM_IT_UPDATE": "TIM_DIER_UIE",
                "TIM_IT_BREAK": "TIM_DIER_BIE",
                "TIM_IT_TRIGGER": "TIM_DIER_TIE",
                "TIM_IT_COM": "TIM_DIER_COMIE",
                "HAL_TIM_OC_DelayElapsedCallback": "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback": "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback": "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback": "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback": "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback": "HAL_TIM_TriggerCallback",
                "HAL_TIMEx_CommutationCallback": "HAL_TIMEx_CommutationCallback"
            },
            "code": "void process_timer_interrupts_080026ce(TIM_HandleTypeDef *timer_handle)\n{\n    TIM_TypeDef *timer_instance;\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_CC1) != 0) && ((timer_instance->DIER & TIM_IT_CC1) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_CC1);\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n        if ((timer_handle->Instance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timer_handle);\n            HAL_TIM_PWM_PulseFinishedCallback(timer_handle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timer_handle);\n        }\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_CC2) != 0) && ((timer_instance->DIER & TIM_IT_CC2) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_CC2);\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n        if ((timer_handle->Instance->CCMR1 & TIM_CCMR1_CC2S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timer_handle);\n            HAL_TIM_PWM_PulseFinishedCallback(timer_handle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timer_handle);\n        }\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_CC3) != 0) && ((timer_instance->DIER & TIM_IT_CC3) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_CC3);\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n        if ((timer_handle->Instance->CCMR2 & TIM_CCMR2_CC3S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timer_handle);\n            HAL_TIM_PWM_PulseFinishedCallback(timer_handle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timer_handle);\n        }\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_CC4) != 0) && ((timer_instance->DIER & TIM_IT_CC4) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_CC4);\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n        if ((timer_handle->Instance->CCMR2 & TIM_CCMR2_CC4S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(timer_handle);\n            HAL_TIM_PWM_PulseFinishedCallback(timer_handle);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(timer_handle);\n        }\n        timer_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_UPDATE) != 0) && ((timer_instance->DIER & TIM_IT_UPDATE) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_UPDATE);\n        HAL_TIM_PeriodElapsedCallback(timer_handle);\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_BREAK) != 0) && ((timer_instance->DIER & TIM_IT_BREAK) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_BREAK);\n        HAL_TIMEx_BreakCallback(timer_handle);\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_TRIGGER) != 0) && ((timer_instance->DIER & TIM_IT_TRIGGER) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_TRIGGER);\n        HAL_TIM_TriggerCallback(timer_handle);\n    }\n\n    timer_instance = timer_handle->Instance;\n\n    if (((timer_instance->SR & TIM_FLAG_COM) != 0) && ((timer_instance->DIER & TIM_IT_COM) != 0)) {\n        timer_instance->SR = ~(TIM_FLAG_COM);\n        HAL_TIMEx_CommutationCallback(timer_handle);\n    }\n\n    return;\n}",
            "called": [
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026ce",
            "calling": [
                "TIM1_UP_TIM10_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler",
                "TIM2_IRQHandler",
                "TIM7_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM3_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM4_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_timer_interrupts_080026ce"
        },
        "FUN_080026cc": {
            "renaming": {
                "FUN_080026cc": "do_nothing_080026cc"
            },
            "code": "\nvoid do_nothing_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026cc",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080026cc"
        },
        "FUN_08001f3c": {
            "renaming": {
                "FUN_08001f3c": "reset_i2c_bus_08001f3c",
                "*hdma": "*dma_handle",
                "*hi2c": "*i2c_handle",
                "CR1": "control_register_1",
                "XferCount": "transfer_count",
                "hdmatx": "dma_tx_handle",
                "hdmarx": "dma_rx_handle",
                "State": "i2c_state",
                "Mode": "i2c_mode",
                "ErrorCode": "error_code",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_ErrorCallback": "i2c_error_callback",
                "HAL_I2C_AbortCpltCallback": "i2c_abort_complete_callback"
            },
            "code": "void reset_i2c_bus_08001f3c(DMA_HandleTypeDef *dma_handle)\n{\n  I2C_HandleTypeDef *i2c_handle;\n  i2c_handle = (I2C_HandleTypeDef *)dma_handle->Parent;\n  i2c_handle->Instance->CR1 &= ~(1 << 10);\n  i2c_handle->XferCount = 0;\n  i2c_handle->hdmatx->XferAbortCallback = NULL;\n  i2c_handle->hdmarx->XferAbortCallback = NULL;\n  if (i2c_handle->State != HAL_I2C_STATE_ABORT) {\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    i2c_handle->Instance->CR1 &= ~(1 << 0);\n    HAL_I2C_ErrorCallback(i2c_handle);\n    return;\n  }\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Mode = HAL_I2C_MODE_NONE;\n  i2c_handle->ErrorCode = 0;\n  i2c_handle->Instance->CR1 &= ~(1 << 0);\n  HAL_I2C_AbortCpltCallback(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f3c",
            "calling": [],
            "imported": false,
            "current_name": "reset_i2c_bus_08001f3c"
        },
        "FUN_08000218": {
            "renaming": {
                "FUN_08000218": "calculate_string_length_08000218",
                "__s": "str",
                "cVar1": "current_char",
                "pcVar2": "current_pos",
                "pcVar3": "current_pos"
            },
            "code": "size_t calculate_string_length_08000218(char* str) {\n    char current_char;\n    char* current_pos = str;\n    while (current_char = *(current_pos++)) {};\n    return (size_t)(current_pos - str - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000218",
            "calling": [
                "printNumber"
            ],
            "imported": false,
            "current_name": "calculate_string_length_08000218"
        },
        "FUN_0800339c": {
            "renaming": {
                "FUN_0800339c": "calculate_pwm_value_0800339c",
                "pin": "pin",
                "uVar1": "pwm_function",
                "uVar2": "pwm_value",
                "PTR_PinMap_PWM_080033c4": "PTR_PinMap_PWM_080033c4"
            },
            "code": "uint32_t calculate_pwm_value_0800339c(PinName_conflict pin)\n{\n  uint32_t pwm_function = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_080033c4);\n  uint32_t pwm_value = (pwm_function << 12) >> 27;\n  if (pwm_value == 3) {\n    return 8;\n  }\n  if (pwm_value == 4) {\n    return 12;\n  }\n  if (pwm_value == 2) {\n    return 4;\n  }\n  return 0;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800339c",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "calculate_pwm_value_0800339c"
        },
        "FUN_08003968": {
            "renaming": {
                "FUN_08003968": "handle_i2c_error_interrupt_08003968",
                "PTR_i2c_handles_08003974": "PTR_i2c_handles",
                "i2c_handle_ptr": "i2c_handle",
                "HAL_I2C_ER_IRQHandler": "handle_i2c_error",
                "I2C_HandleTypeDef": "i2c_handle"
            },
            "code": "void handle_i2c_error_interrupt_08003968(void)\n{\n  I2C_HandleTypeDef* i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003974_08003974 + 8);\n  HAL_I2C_ER_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003968",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08003968"
        },
        "FUN_0800557e": {
            "renaming": {
                "FUN_0800557e": "do_nothing_0800557e"
            },
            "code": "\nvoid do_nothing_0800557e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800557e",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800557e"
        },
        "FUN_08000e60": {
            "renaming": {
                "FUN_08000e60": "set_interrupt_priority_08000e60",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_num",
                "uVar2": "group_priority_bits",
                "uVar3": "group_priority",
                "DAT_08000ebc": "dat_08000ebc",
                "DAT_08000ec0": "dat_08000ec0"
            },
            "code": "void set_interrupt_priority_08000e60(IRQn_Type_conflict irq, uint32_t preempt_priority, uint32_t sub_priority) {\n  uint8_t irq_num = (uint8_t)irq;\n  uint8_t group_priority_bits = (uint8_t)(*(int *)(DAT_08000ebc + 0xc) << 0x15) >> 0x1d;\n  uint8_t group_priority = 7 - group_priority_bits;\n  if (group_priority > 3) {\n    group_priority = 4;\n  }\n  if (group_priority_bits + 4 < 7) {\n    group_priority_bits = 0;\n  }\n  else {\n    group_priority_bits -= 3;\n  }\n  uint32_t priority_bits = (preempt_priority & ((1 << (group_priority & 0xff)) - 1U)) << (group_priority_bits & 0xff) | ((1 << (group_priority_bits & 0xff)) - 1U & sub_priority);\n  if ((int)irq_num < 0) {\n    *(char *)(DAT_08000ec0 + (irq_num & 0xf)) = (char)(priority_bits << 4);\n  }\n  else {\n    *(char *)(irq_num + 0xe000e400) = (char)(priority_bits << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e60",
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08000e60"
        },
        "FUN_0800557c": {
            "renaming": {
                "FUN_0800557c": "do_nothing_0800557c"
            },
            "code": "\nvoid do_nothing_0800557c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800557c",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800557c"
        },
        "FUN_0800165a": {
            "renaming": {
                "FUN_0800165a": "i2c_address_match_callback_0800165a",
                "*hi2c": "*i2c_handle",
                "AddrMatchCode": "address_match_code",
                "hi2c->Instance->SR2": "i2c_handle->Instance->SR2",
                "hi2c->Init": "i2c_handle->Init",
                "hi2c->Init.OwnAddress1": "i2c_handle->Init.OwnAddress1",
                "hi2c->Init.OwnAddress2": "i2c_handle->Init.OwnAddress2",
                "HAL_I2C_AddrCallback": "HAL_I2C_AddrCallback",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef i2c_address_match_callback_0800165a(I2C_HandleTypeDef *i2c_handle)\n{\n    uint16_t address_match_code;\n    if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n        address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n    }\n    else {\n        address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n    }\n    HAL_I2C_AddrCallback(i2c_handle, (i2c_handle->Instance->SR2 & 4) == 0, address_match_code);\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800165a",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_address_match_callback_0800165a"
        },
        "FUN_080037d4": {
            "renaming": {
                "FUN_080037d4": "handle_timer_interrupt_080037d4",
                "PTR_timer_handles_080037e4": "PTR_timer_handles_080037e4",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "current_timer_handle": "current_timer_handle",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler"
            },
            "code": "void handle_timer_interrupt_080037d4(void)\n{\n  TIM_HandleTypeDef* current_timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_080037e4 + 0x10);\n  if (current_timer_handle != NULL)\n  {\n    HAL_TIM_IRQHandler(current_timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037d4"
        },
        "FUN_08000b04": {
            "renaming": {
                "FUN_08000b04": "modbus_read_registers_08000b04",
                "this": "modbus",
                "regs": "registers",
                "u8size": "num_registers",
                "bVar1": "start_address",
                "bVar2": "num_bytes",
                "uVar3": "i",
                "uVar4": "current_value",
                "uVar5": "counter"
            },
            "code": "int8_t __thiscall modbus_read_registers_08000b04(Modbus *modbus, uint16_t *registers, uint8_t num_registers)\n{\n  byte num_bytes;\n  byte start_address;\n  uint8_t i;\n  uint16_t current_value;\n  uint counter;\n\n  start_address = modbus->au8Buffer[3];\n  num_bytes = modbus->au8Buffer[5];\n  modbus->au8Buffer[4] = '\\0';\n  modbus->au8Buffer[5] = num_bytes;\n  modbus->u8BufferSize = 6;\n  for (counter = 0; counter < num_bytes; counter++) {\n    current_value = makeWord(modbus->au8Buffer[counter * 2 + 7], modbus->au8Buffer[counter * 2 + 8]);\n    registers[start_address + counter] = current_value;\n  }\n  i = modbus->u8BufferSize;\n  sendTxBuffer(modbus);\n  return i + 2;\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000b04",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "modbus_read_registers_08000b04"
        },
        "FUN_0800262c": {
            "renaming": {
                "FUN_0800262c": "handle_rtc_interrupts_0800262c",
                "hrtc": "rtc",
                "RTC_ISR_ALRAF": "RTC_ISR_ALARM_A_FLAG",
                "RTC_ISR_ALRBF": "RTC_ISR_ALARM_B_FLAG",
                "RTC_CR_ALRAIE": "RTC_CR_ALARM_A_INTERRUPT_ENABLE",
                "RTC_CR_ALRBIE": "RTC_CR_ALARM_B_INTERRUPT_ENABLE",
                "RTC_ISR_INIT": "RTC_ISR_INITIAL_VALUE",
                "RTC_STATE_READY": "RTC_STATE_READY",
                "HAL_RTC_AlarmAEventCallback": "handle_alarm_a_event",
                "HAL_RTCEx_AlarmBEventCallback": "handle_alarm_b_event"
            },
            "code": "void handle_rtc_interrupts_0800262c(RTC_HandleTypeDef *rtc)\n{\n    if (((rtc->Instance->ISR & RTC_ISR_ALRAF) != 0) && ((rtc->Instance->CR & RTC_CR_ALRAIE) != 0)) {\n        HAL_RTC_AlarmAEventCallback(rtc);\n        rtc->Instance->ISR = (rtc->Instance->ISR & 0xff) | RTC_ISR_INIT;\n    }\n    if (((rtc->Instance->ISR & RTC_ISR_ALRBF) != 0) && ((rtc->Instance->CR & RTC_CR_ALRBIE) != 0)) {\n        HAL_RTCEx_AlarmBEventCallback(rtc);\n        rtc->Instance->ISR = (rtc->Instance->ISR & 0xff) | RTC_ISR_INIT;\n    }\n    *(uint32_t *)(DAT_08002688 + 0x14) = RTC_STATE_READY;\n    rtc->State = HAL_RTC_STATE_READY;\n    return;\n}",
            "called": [
                "HAL_RTCEx_AlarmBEventCallback",
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800262c",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_rtc_interrupts_0800262c"
        },
        "FUN_080047a8": {
            "renaming": {
                "FUN_080047a8": "handle_gpio_exti_irq_080047a8",
                "uVar1": "pin_number"
            },
            "code": "void handle_gpio_exti_irq_080047a8(void)\n{\n  uint16_t pin_number;\n  for (pin_number = 0x400; pin_number < 0x8001; pin_number = pin_number << 1) {\n    HAL_GPIO_EXTI_IRQHandler(pin_number);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047a8",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_080047a8"
        },
        "FUN_08004388": {
            "renaming": {
                "FUN_08004388": "configure_serial_08004388",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "config_mask",
                "iVar2": "databits",
                "_serial": "serial_config",
                "PTR_s__home_bo__arduino15_packages_STM_08004440": "ASSERTION_MESSAGE",
                "PTR___PRETTY_FUNCTION___0800443c": "ASSERTION_FUNCTION",
                "PTR_s_databits__0_08004438": "ASSERTION_EXPRESSION"
            },
            "code": "void __thiscall configure_serial_08004388(HardwareSerial *serial, ulong baudrate, byte config) {\n  byte config_mask = config & 7;\n  int databits = 0;\n  int parity = 0;\n  int stopbits = 0;\n  int uart_databits = 0;\n  \n  (serial->_serial).baudrate = baudrate;\n  serial->_config = config;\n  \n  if (config_mask == 4) {\n    databits = 7;\n  }\n  else if (config_mask == 6) {\n    databits = 8;\n  }\n  else if (config_mask == 2) {\n    databits = 6;\n  }\n  \n  if ((config & 0x30) == 0x30) {\n    parity = 0x600;\n    databits++;\n  }\n  else if ((config & 0x20) == 0) {\n    parity = 0;\n  }\n  else {\n    parity = 0x400;\n    databits++;\n  }\n  \n  if ((config & 8) == 0) {\n    stopbits = 0;\n  }\n  else {\n    stopbits = 0x2000;\n  }\n  \n  if (databits == 8) {\n    uart_databits = 0;\n  }\n  else if (databits == 9) {\n    uart_databits = 0x1000;\n  }\n  \n  if (uart_databits != 0) {\n    (serial->_serial).databits = uart_databits;\n    (serial->_serial).parity = parity;\n    (serial->_serial).stopbits = stopbits;\n    uart_init((serial_t *)&serial->_serial);\n    uart_attach_rx_callback((serial_t *)&serial->_serial, HardwareSerial::rx_callback);\n    return;\n  }\n  \n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08004440,299,PTR___PRETTY_FUNCTION___0800443c,PTR_s_databits__0_08004438);\n}",
            "called": [
                "uart_init",
                "__assert_func",
                "uart_attach_rx_callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004388",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "configure_serial_08004388"
        },
        "FUN_080051ac": {
            "renaming": {
                "FUN_080051ac": "raise_signal_6_and_exit_080051ac",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void raise_signal_6_and_exit_080051ac(void)\n{\n  raise(SIGABRT);\n  _exit(EXIT_FAILURE);\n}",
            "called": [
                "raise",
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051ac",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "raise_signal_6_and_exit_080051ac"
        },
        "FUN_080052cc": {
            "renaming": {
                "FUN_080052cc": "flush_if_buffer_not_empty_080052cc",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "mode",
                "param_4": "flags",
                "uVar1": "result",
                "PTR___sf_fake_stdin_08005314": "PTR___sf_fake_stdin_08005314",
                "PTR___sf_fake_stdout_08005318": "PTR___sf_fake_stdout_08005318",
                "PTR___sf_fake_stderr_0800531c": "PTR___sf_fake_stderr_0800531c",
                "stream_buffer": "stream_buffer"
            },
            "code": "int flush_if_buffer_not_empty_080052cc(int file_descriptor, void *stream, int mode, int flags) {\n  int result;\n  int *stream_buffer = (int *)(stream + 16);\n  if (*stream_buffer != 0) {\n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 24) == 0)) {\n      __sinit();\n    }\n    if (stream == PTR___sf_fake_stdin_08005314) {\n      stream = *(void **)(file_descriptor + 4);\n    }\n    else if (stream == PTR___sf_fake_stdout_08005318) {\n      stream = *(void **)(file_descriptor + 8);\n    }\n    else if (stream == PTR___sf_fake_stderr_0800531c) {\n      stream = *(void **)(file_descriptor + 12);\n    }\n    if (*(short *)(stream + 12) != 0) {\n      result = __sflush_r(file_descriptor, stream, mode, flags);\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052cc",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_buffer_not_empty_080052cc"
        },
        "FUN_08002eb2": {
            "renaming": {
                "FUN_08002eb2": "transmit_data_08002eb2",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_BUSY": "BUSY",
                "HAL_ERROR": "ERROR",
                "HAL_UNLOCKED": "UNLOCKED",
                "pTxBuffPtr": "tx_buffer_pointer",
                "TxXferSize": "tx_transfer_size",
                "TxXferCount": "tx_transfer_count",
                "ErrorCode": "error_code",
                "gState": "global_state",
                "Instance": "instance",
                "CR1": "control_register_1"
            },
            "code": "HAL_StatusTypeDef transmit_data_08002eb2(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size) {\n  if (uart_handle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == NULL) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uart_handle->Lock != HAL_LOCKED) {\n    uart_handle->pTxBuffPtr = data;\n    uart_handle->TxXferSize = size;\n    uart_handle->TxXferCount = size;\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_BUSY_TX;\n    uart_handle->Lock = HAL_UNLOCKED;\n    uart_handle->Instance->CR1 |= 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002eb2",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "transmit_data_08002eb2"
        },
        "FUN_08005478": {
            "renaming": {
                "FUN_08005478": "count_of_bigger_than_one_08005478",
                "param_1": "input_data_address",
                "param_2": "func_ptr",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "func_result",
                "iVar2": "item_length_plus_one",
                "piVar3": "current_item",
                "iVar4": "item_address",
                "uVar5": "result",
                "iVar6": "item_length"
            },
            "code": "uint count_of_bigger_than_one_08005478(int param_1, code *func_ptr, undefined4 param_3, undefined4 param_4) {\n  uint result = 0;\n  int *current_item = (int *)(param_1 + 0x48);\n  int item_address, item_length;\n  while (current_item != (int *)0x0) {\n    item_address = current_item[2];\n    item_length = current_item[1];\n    while (item_length > 0) {\n      if (*(ushort *)(item_address + 0xc) > 1 && *(short *)(item_address + 0xe) + 1 != 0) {\n        uint func_result = (*func_ptr)(param_1, item_address, param_3, *(short *)(item_address + 0xe) + 1, param_4);\n        result |= func_result;\n      }\n      item_address += 0x68;\n      item_length--;\n    }\n    current_item = (int *)*current_item;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005478",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "count_of_bigger_than_one_08005478"
        },
        "FUN_08000d3c": {
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "i",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "UNRECOVERED_JUMPTABLE",
                "PTR_completed_8667_08000d84": "PTR_completed_8667_08000d84",
                "PTR___dso_handle_08000d7c": "PTR___dso_handle_08000d7c",
                "PTR_completed_8667_08000d80": "PTR_completed_8667_08000d80",
                "PTR__sidata_08000d78": "PTR__sidata_08000d78",
                "PTR__ebss_08000d88": "PTR__ebss_08000d88"
            },
            "code": "void initialize_system_08000d3c(void)\n{\n  int i;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8667_08000d84;\n  undefined4 *dso_handle_ptr = (undefined4 *)PTR___dso_handle_08000d7c;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (i = 0; dso_handle_ptr + i < (undefined4 *)PTR_completed_8667_08000d80; i += 4) {\n    *(undefined4 *)(dso_handle_ptr + i) = *(undefined4 *)(PTR__sidata_08000d78 + i);\n  }\n  \n  for (; completed_ptr < (undefined4 *)PTR__ebss_08000d88; completed_ptr++) {\n    *completed_ptr = 0;\n  }\n  \n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x8000d72;\n  main();\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "main",
                "SystemInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000d3c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08000d3c"
        },
        "FUN_08003978": {
            "renaming": {
                "FUN_08003978": "FUNC_08003978"
            },
            "code": "\nvoid FUNC_08003978(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  USART_TypeDef *pUVar4;\n  USART_TypeDef *pUVar5;\n  USART_TypeDef *pUVar6;\n  USART_TypeDef *pUVar7;\n  USART_TypeDef *pUVar8;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar9;\n  GPIO_TypeDef *pGVar10;\n  uint32_t uVar11;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08003c58);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08003c5c);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08003c84);\n    }\n    else {\n      pUVar9 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar9;\n      pUVar8 = DAT_08003c7c;\n      pUVar7 = DAT_08003c78;\n      pUVar6 = DAT_08003c74;\n      pUVar5 = DAT_08003c70;\n      pUVar4 = DAT_08003c6c;\n      pUVar3 = DAT_08003c68;\n      pUVar2 = DAT_08003c64;\n      pUVar1 = DAT_08003c60;\n      if (pUVar9 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_08003c88);\n      }\n      else {\n        if (pUVar9 == DAT_08003c60) {\n          DAT_08003c60[0xa93].CR2 = DAT_08003c60[0xa93].CR2 | 0x10;\n          pUVar1[0xa93].CR2 = pUVar1[0xa93].CR2 & 0xffffffef;\n          pUVar1[0xa94].CR3 = pUVar1[0xa94].CR3 | 0x10;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c64) {\n          DAT_08003c64[0x11dc].CR2 = DAT_08003c64[0x11dc].CR2 | 0x20000;\n          pUVar2[0x11dc].CR2 = pUVar2[0x11dc].CR2 & 0xfffdffff;\n          pUVar2[0x11dd].CR3 = pUVar2[0x11dd].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c68) {\n          DAT_08003c68[0x11b8].SR = DAT_08003c68[0x11b8].SR | 0x40000;\n          pUVar3[0x11b8].SR = pUVar3[0x11b8].SR & 0xfffbffff;\n          pUVar3[0x11b9].DR = pUVar3[0x11b9].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c6c) {\n          DAT_08003c6c[0x1193].CR1 = DAT_08003c6c[0x1193].CR1 | 0x80000;\n          pUVar4[0x1193].CR1 = pUVar4[0x1193].CR1 & 0xfff7ffff;\n          pUVar4[0x1194].CR2 = pUVar4[0x1194].CR2 | 0x80000;\n          obj->index = '\\x03';\n          obj->irq = UART4_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c70) {\n          DAT_08003c70[0x116e].GTPR = DAT_08003c70[0x116e].GTPR | 0x100000;\n          pUVar5[0x116e].GTPR = pUVar5[0x116e].GTPR & 0xffefffff;\n          pUVar5[0x1170].SR = pUVar5[0x1170].SR | 0x100000;\n          obj->index = '\\x04';\n          obj->irq = UART5_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c74) {\n          DAT_08003c74[0xa6f].SR = DAT_08003c74[0xa6f].SR | 0x20;\n          pUVar6[0xa6f].SR = pUVar6[0xa6f].SR & 0xffffffdf;\n          pUVar6[0xa70].DR = pUVar6[0xa70].DR | 0x20;\n          obj->index = '\\x05';\n          obj->irq = USART6_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c78) {\n          DAT_08003c78[0x1001].DR = DAT_08003c78[0x1001].DR | 0x40000000;\n          pUVar7[0x1001].DR = pUVar7[0x1001].DR & 0xbfffffff;\n          pUVar7[0x1002].BRR = pUVar7[0x1002].BRR | 0x40000000;\n          obj->index = '\\x06';\n          obj->irq = UART7_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c7c) {\n          DAT_08003c7c[0xfdc].CR2 = DAT_08003c7c[0xfdc].CR2 | 0x80000000;\n          pUVar8[0xfdc].CR2 = pUVar8[0xfdc].CR2 & 0x7fffffff;\n          pUVar8[0xfdd].CR3 = pUVar8[0xfdd].CR3 | 0x80000000;\n          obj->index = '\\a';\n          obj->irq = UART8_IRQn;\n        }\n        pGVar10 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar11 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08003c5c);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar11 >> 3 & 1) << 4 | uVar11 & 7;\n        GPIO_InitStruct.Pull = (uVar11 << 0x1a) >> 0x1e;\n        GPIO_InitStruct.Alternate = (uVar11 << 0x11) >> 0x19;\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar10,&GPIO_InitStruct);\n        pGVar10 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar11 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08003c58);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar11 >> 3 & 1) << 4 | uVar11 & 7;\n        GPIO_InitStruct.Pull = (uVar11 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar10,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08003c80 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "HAL_UART_Init",
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "pinmap_merge_peripheral",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003978",
            "calling": [
                "uart_debug_init",
                "begin"
            ],
            "imported": false,
            "current_name": "FUNC_08003978"
        },
        "FUN_08003854": {
            "renaming": {
                "FUN_08003854": "handle_timer_interrupt_08003854",
                "PTR_timer_handles_08003864": "PTR_timer_handles_08003864",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler",
                "current_timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08003854(void)\n{\n  TIM_HandleTypeDef* current_timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003864 + 0x2c);\n  if (current_timer_handle != NULL) {\n    HAL_TIM_IRQHandler(current_timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003854",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003854"
        },
        "FUN_0800316c": {
            "renaming": {
                "FUN_0800316c": "update_map_at_pin_0800316c",
                "pin": "pin_name",
                "uVar1": "pin_num",
                "map": "map",
                "mask": "mask"
            },
            "code": "void update_map_at_pin_0800316c(PinName_conflict pin_name, uint32_t *map) {\n    uint32_t pin_num = ((uint32_t)pin_name << 24) >> 28;\n    uint32_t mask = ~(1 << (pin_name & 0xF));\n    map[pin_num] &= mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800316c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "update_map_at_pin_0800316c"
        },
        "FUN_080040d0": {
            "renaming": {
                "FUN_080040d0": "return_error_080040d0",
                "file_UNUSED": "file_unused"
            },
            "code": "int return_error_080040d0(int file_unused)\n{\n    return -1;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040d0",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "return_error_080040d0"
        },
        "FUN_0800401c": {
            "renaming": {
                "FUN_0800401c": "handle_uart_interrupt_0800401c",
                "UART4_IRQn": "UART4_Interrupt",
                "PTR_uart_handlers_08004030": "uart_handlers_ptr",
                "uart_handler_ptr": "uart_handler"
            },
            "code": "void handle_uart_interrupt_0800401c(void)\n{\n  HAL_NVIC_ClearPendingIRQ(UART4_IRQn);\n  UART_HandleTypeDef* uart_handler_ptr = *(UART_HandleTypeDef **)(PTR_uart_handlers_08004030 + 0xc);\n  HAL_UART_IRQHandler(uart_handler_ptr);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800401c",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_0800401c"
        },
        "FUN_080040d6": {
            "renaming": {
                "FUN_080040d6": "set_default_mode_080040d6",
                "file_UNUSED": "file_unused",
                "st": "file_stats",
                "st_mode": "file_stats->st_mode"
            },
            "code": "int set_default_mode_080040d6(int file_unused, stat* file_stats)\n{\n  file_stats->st_mode = S_IFREG | 0644;\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040d6",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_default_mode_080040d6"
        },
        "FUN_08004a34": {
            "renaming": {
                "FUN_08004a34": "write_byte_to_stream_08004a34",
                "param_1": "stream",
                "param_2": "byte_to_write",
                "param_3": "stream_buffer",
                "uVar1": "status_code",
                "pbVar2": "last_byte",
                "next_byte": "next_byte"
            },
            "code": "uint write_byte_to_stream_08004a34(undefined4 stream, byte byte_to_write, byte **stream_buffer){\n  uint status_code;\n  byte *last_byte = stream_buffer[2] - 1;\n  stream_buffer[2] = last_byte;\n  if (((int)last_byte < 0) && (((int)last_byte < (int)stream_buffer[6] || (byte_to_write == 10)))) {\n    status_code = __swbuf_r();\n    return status_code;\n  }\n  byte *next_byte = *stream_buffer;\n  *stream_buffer = next_byte + 1;\n  *next_byte = byte_to_write;\n  return (uint)byte_to_write;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a34",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_byte_to_stream_08004a34"
        },
        "FUN_080002d0": {
            "renaming": {
                "FUN_080002d0": "divide_numbers_080002d0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "quotient",
                "__aeabi_idiv0": "throw_divide_by_zero_exception",
                "__udivmoddi4": "unsigned_division"
            },
            "code": "void divide_numbers_080002d0(int dividend, int divisor, int remainder, int quotient) {\n    if (divisor == 0 && remainder == 0) {\n        if (dividend != 0 || quotient != 0) {\n            divisor = -1;\n            dividend = -1;\n        }\n        __aeabi_idiv0(dividend, divisor);\n        return;\n    }\n    __udivmoddi4();\n}",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002d0",
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "imported": false,
            "current_name": "divide_numbers_080002d0"
        },
        "FUN_08003f00": {
            "renaming": {
                "FUN_08003f00": "find_uart_handler_index_08003f00",
                "*huart": "huart",
                "uVar1": "index",
                "PTR_uart_handlers_08003f20": "PTR_uart_handlers_08003f20"
            },
            "code": "uint8_t find_uart_handler_index_08003f00(UART_HandleTypeDef *huart)\n{\n  uint8_t index;\n  if (huart == NULL) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while (index < 10) {\n      if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_08003f20 + index * 4)) {\n        break;\n      }\n      index++;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f00",
            "calling": [
                "HAL_UART_RxCpltCallback",
                "HAL_UART_TxCpltCallback"
            ],
            "imported": false,
            "current_name": "find_uart_handler_index_08003f00"
        },
        "FUN_08004270": {
            "renaming": {
                "FUN_08004270": "read_byte_08004270",
                "__fd": "fd",
                "__buf": "buffer",
                "__nbytes": "nbytes",
                "uVar2": "rx_tail",
                "bVar1": "byte_to_return"
            },
            "code": "ssize_t __thiscall read_byte_08004270(HardwareSerial *this,int fd,void *buffer,size_t nbytes)\n{\n  byte byte_to_return;\n  ushort rx_tail = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)rx_tail) {\n    byte_to_return = (this->_serial).rx_buff[rx_tail];\n    (this->_serial).rx_tail = (rx_tail + 1) & 0x3f;\n    return (uint)byte_to_return;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004270",
            "calling": [],
            "imported": false,
            "current_name": "read_byte_08004270"
        },
        "FUN_08005a04": {
            "renaming": {
                "FUN_08005a04": "do_nothing_08005a04"
            },
            "code": "\nvoid do_nothing_08005a04(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a04",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08005a04"
        },
        "FUN_080037e8": {
            "renaming": {
                "FUN_080037e8": "handle_timer_interrupt_080037e8",
                "PTR_timer_handles_080037f8": "PTR_timer_handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "timer_handle": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "code": "void handle_timer_interrupt_080037e8(void)\n{\n    TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_080037f8_080037f8 + 0x14);\n    if (timer_handle != NULL)\n    {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037e8",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037e8"
        },
        "FUN_08001440": {
            "renaming": {
                "FUN_08001440": "receive_byte_08001440",
                "*hi2c": "*i2c",
                "puVar1": "buffer_pointer",
                "hi2c->pBuffPtr": "i2c->pBuffPtr",
                "puVar1 + 1": "buffer_pointer + 1",
                "*puVar1": "*buffer_pointer",
                "hi2c->XferCount": "i2c->XferCount",
                "hi2c->Instance->DR": "i2c->Instance->DR",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef receive_byte_08001440(I2C_HandleTypeDef *i2c)\n{\n  uint8_t *buffer_pointer;\n  \n  if (i2c->XferCount != 0) {\n    buffer_pointer = i2c->pBuffPtr;\n    i2c->pBuffPtr = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c->Instance->DR;\n    i2c->XferCount = i2c->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001440",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_byte_08001440"
        },
        "FUN_08000230": {
            "renaming": {
                "FUN_08000230": "reverse_find_byte_08000230",
                "__s": "buffer",
                "__c": "byte_to_find",
                "__n": "buffer_size",
                "bVar1": "byte_value",
                "cVar2": "bit_0",
                "cVar3": "bit_8",
                "cVar4": "bit_16",
                "cVar5": "bit_24",
                "pbVar6": "byte_ptr1",
                "puVar7": "uint_ptr",
                "pbVar8": "byte_ptr2",
                "uVar9": "byte_to_find_u8",
                "uVar10": "alignment_offset",
                "uVar11": "buffer_size_aligned",
                "uVar12": "value_low_bits",
                "uVar13": "value_high_bits",
                "bVar14": "value_low_bits_nonzero",
                "bVar15": "value_low_bits_nonzero_8",
                "bVar16": "value_low_bits_nonzero_16",
                "bVar17": "value_low_bits_nonzero_24"
            },
            "code": "void reverse_find_byte_08000230(void *buffer, int byte_to_find, size_t buffer_size) {\n    uint8_t *buffer_ptr = buffer;\n    uint8_t byte_to_find_u8 = byte_to_find & 0xff;\n    if (buffer_size < 0x10) {\n        while (buffer_size--) {\n            if (*buffer_ptr++ == byte_to_find_u8) {\n                return buffer_ptr - 1;\n            }\n        }\n        return NULL;\n    }\n    uint8_t *buffer_ptr_end = buffer_ptr + buffer_size;\n    uint64_t byte_to_find_u64 = byte_to_find_u8;\n    byte_to_find_u64 |= byte_to_find_u64 << 8;\n    byte_to_find_u64 |= byte_to_find_u64 << 16;\n    byte_to_find_u64 |= byte_to_find_u64 << 32;\n    uint8_t *buffer_ptr_aligned = (uint8_t *)(((uintptr_t)buffer_ptr + 7) & ~7);\n    uint64_t *buffer_ptr_aligned_u64 = (uint64_t *)buffer_ptr_aligned;\n    uint64_t *buffer_ptr_end_u64 = (uint64_t *)buffer_ptr_end;\n    while (buffer_ptr_aligned_u64 < buffer_ptr_end_u64) {\n        uint64_t value = *buffer_ptr_aligned_u64++ ^ byte_to_find_u64;\n        if (value) {\n            uint64_t mask = 0x0101010101010101ULL;\n            uint64_t low_mask = mask - 1;\n            uint64_t high_mask = ~low_mask;\n            uint64_t low_bits = value & low_mask;\n            uint64_t high_bits = value & high_mask;\n            if (low_bits) {\n                return (void *)(buffer_ptr_aligned_u64 - 1) + __builtin_ctzll(low_bits) / 8;\n            }\n            if (high_bits) {\n                return (void *)(buffer_ptr_aligned_u64 - 1) + __builtin_ctzll(high_bits) / 8 + 7;\n            }\n        }\n    }\n    buffer_size &= 0x7;\n    while (buffer_size--) {\n        if (*buffer_ptr++ == byte_to_find_u8) {\n            return buffer_ptr - 1;\n        }\n    }\n    return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000230",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "reverse_find_byte_08000230"
        },
        "FUN_080051bc": {
            "renaming": {
                "FUN_080051bc": "decode_data_080051bc",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "num_blocks",
                "piVar2": "block_data_ptr",
                "uVar3": "num_blocks_as_uint",
                "uVar4": "flags",
                "iVar5": "block_size_offset",
                "pcVar6": "block_func",
                "iVar7": "block_offset",
                "uVar8": "original_data_size",
                "bVar9": "is_dynamic_block_size",
                "block_func_offset": "block_func_offset",
                "block_func_result": "block_func_result",
                "total_size": "total_size",
                "block_size": "block_size",
                "remaining_data_size": "remaining_data_size"
            },
            "code": "uint32_t decode_data_080051bc(uint32_t *data, int *params) {\n    int num_blocks = (int)(*(uint16_t *)(params + 3));\n    uint32_t block_size;\n    uint32_t total_size = 0;\n    int block_offset;\n    int remaining_data_size = *params - params[4];\n    int block_func_offset = params[10];\n    int block_func_result;\n    uint16_t flags = *(uint16_t *)(params + 3);\n\n    if ((num_blocks << 0x1c) < 0) {\n        int block_size_offset = params[5];\n        bool is_dynamic_block_size = (num_blocks << 0x1e) == 0;\n        int block_offset = *params;\n\n        if (params[4] != 0) {\n            *params = params[4];\n            if (!is_dynamic_block_size) {\n                block_size_offset = 0;\n            }\n            params[2] = block_size_offset;\n\n            while (block_offset > params[4]) {\n                block_size = (*(code *)block_func_offset)(data, params[8], params[4], block_offset);\n                if (block_size < 1) {\n                    flags = *(uint16_t *)(params + 3);\n                    goto error;\n                }\n                params[4] += block_size;\n            }\n        }\n    }\n    else {\n        if ((params[1] > 0 || params[0x10] > 0) && block_func_offset != 0) {\n            uint32_t original_data_size = *data;\n            *data = 0;\n            if ((flags & 0x1000) == 0) {\n                block_func_result = (*(code *)block_func_offset)(data, params[8], flags & 0x1000, 1);\n                if (block_func_result == -1 && *data != 0) {\n                    if (*data != 0x1d && *data != 0x16) {\n                        flags = *(uint16_t *)(params + 3);\n                        goto error;\n                    }\n                    *data = original_data_size;\n                    return 0;\n                }\n            }\n            else {\n                block_func_result = params[0x15];\n            }\n            if ((flags << 0x1d) < 0 && params[0xd] != 0) {\n                block_func_result -= params[1];\n                if (params[0xd] != 0) {\n                    block_func_result -= params[0x10];\n                }\n            }\n            block_func_result = (*(code *)block_func_offset)(data, params[8], block_func_result, 0);\n            if (block_func_result == -1 && (*data > 0x1d || (DAT_080052c8 >> (*data & 0xff)) << 0x1f)) {\n                flags = *(uint16_t *)(params + 3);\n                goto error;\n            }\n            params[1] = 0;\n            *params = params[4];\n            if ((flags << 0x13) < 0 && (block_func_result != -1 || *data == 0)) {\n                params[0x15] = block_func_result;\n            }\n            int *block_data_ptr = (int *)params[0xd];\n            *data = original_data_size;\n            if (block_data_ptr != 0) {\n                if (block_data_ptr != params + 0x11) {\n                    _free_r(data);\n                }\n                params[0xd] = 0;\n                return 0;\n            }\n        }\n    }\n    return 0;\n\n    error:\n    *(uint16_t *)(params + 3) = flags | 0x40;\n    return 0xffffffff;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051bc",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "decode_data_080051bc"
        },
        "FUN_08004034": {
            "renaming": {
                "FUN_08004034": "handle_uart_interrupt_08004034",
                "UART5_IRQn": "UART5_Interrupt",
                "PTR_uart_handlers_08004048": "PTR_uart_handlers",
                "*(UART_HandleTypeDef **)(PTR_uart_handlers_08004048 + 0x10)": "uart_handler"
            },
            "code": "void handle_uart_interrupt_08004034(UART_HandleTypeDef **(UART_HandleTypeDef **)(PTR_uart_handlers_08004048 + 0x10))\n{\n  HAL_NVIC_ClearPendingIRQ(UART5_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004048 + 0x10));\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004034",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_08004034"
        },
        "FUN_08000f8c": {
            "renaming": {
                "FUN_08000f8c": "abort_dma_transfer_08000f8c",
                "*hdma": "*dma_handle",
                "hdma->State": "dma_handle->State",
                "hdma->ErrorCode": "dma_handle->ErrorCode",
                "hdma->Instance->CR": "dma_handle->Instance->CR",
                "0x80": "HAL_DMA_ERROR_CODE",
                "HAL_DMA_STATE_BUSY": "HAL_DMA_BUSY",
                "HAL_DMA_STATE_ABORT": "HAL_DMA_ABORTED",
                "& 0xfffffffe": "& ~(1)"
            },
            "code": "HAL_StatusTypeDef abort_dma_transfer_08000f8c(DMA_HandleTypeDef *dma_handle)\n{\n    if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n        dma_handle->ErrorCode = 0x80;\n        return HAL_ERROR;\n    }\n    dma_handle->State = HAL_DMA_STATE_ABORT;\n    dma_handle->Instance->CR &= ~(1);\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f8c",
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "abort_dma_transfer_08000f8c"
        },
        "FUN_08001684": {
            "renaming": {
                "FUN_08001684": "i2c_handler_08001684",
                "*hi2c": "*i2c_handle",
                "XferOptions": "XFER_OPTIONS",
                "State": "HAL_I2C_STATE",
                "DAT_08001714": "DAT_08001714",
                "CR2": "CR2",
                "Instance": "Instance",
                "SR1": "SR1",
                "CR1": "CR1",
                "PreviousState": "PREVIOUS_STATE",
                "Mode": "MODE",
                "HAL_I2C_LISTEN_COMPLETE_CB_ID": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SLAVE_TX_COMPLETE_CB_ID": "HAL_I2C_SlaveTxCpltCallback",
                "BUSY_TX_STATE": "0x21",
                "CLEAR_CR2_BIT_10": "0xfffff8ff",
                "CLEAR_SR1_BIT_10": "0xfffffbff",
                "CLEAR_CR1_BIT_10": "0xfffffbff"
            },
            "code": "HAL_StatusTypeDef i2c_handler_08001684(I2C_HandleTypeDef *i2c_handle)\n{\n    if (((i2c_handle->XferOptions == 4) || (i2c_handle->XferOptions == 8)) && (i2c_handle->State == HAL_I2C_STATE_LISTEN)) {\n        i2c_handle->XferOptions = XFER_OPTIONS;\n        i2c_handle->Instance->CR2 &= CLEAR_CR2_BIT_10;\n        i2c_handle->Instance->SR1 &= CLEAR_SR1_BIT_10;\n        i2c_handle->Instance->CR1 &= CLEAR_CR1_BIT_10;\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(i2c_handle);\n    }\n    else if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n        i2c_handle->XferOptions = XFER_OPTIONS;\n        i2c_handle->PreviousState = BUSY_TX_STATE;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        i2c_handle->Instance->CR2 &= CLEAR_CR2_BIT_10;\n        i2c_handle->Instance->SR1 &= CLEAR_SR1_BIT_10;\n        i2c_handle->Instance->CR1 &= CLEAR_CR1_BIT_10;\n        HAL_I2C_SlaveTxCpltCallback(i2c_handle);\n    }\n    else {\n        i2c_handle->Instance->SR1 &= CLEAR_SR1_BIT_10;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001684",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handler_08001684"
        },
        "FUN_080001ac": {
            "renaming": {
                "FUN_080001ac": "check_init_completed_080001ac",
                "param_1": "input_str",
                "*PTR_completed_8667_080001c4": "is_completed",
                "DAT_080001c8": "is_init",
                "PTR__init_080001cc": "init_value"
            },
            "code": "char* check_init_completed_080001ac(char* input_str){\\n  if (*PTR_completed_8667_080001c4 == \"\\0\") {\\n    if (DAT_080001c8 != 0) {\\n      input_str = PTR__init_080001cc;\\n    }\\n    *PTR_completed_8667_080001c4 = 1;\\n  }\\n  return input_str;\\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ac",
            "calling": [],
            "imported": false,
            "current_name": "check_init_completed_080001ac"
        },
        "FUN_080040e0": {
            "renaming": {
                "FUN_080040e0": "calculate_result_080040e0",
                "file_UNUSED": "file_descriptor"
            },
            "code": "int calculate_result_080040e0(int file_descriptor)\n{\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e0",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "calculate_result_080040e0"
        },
        "FUN_08003868": {
            "renaming": {
                "FUN_08003868": "handle_timer_interrupt_08003868",
                "PTR_timer_handles_08003878": "PTR_timer_handles",
                "current_timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08003868(void)\n{\n  TIM_HandleTypeDef* current_timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003878_08003878 + 0x34);\n  if (current_timer_handle != NULL) {\n    HAL_TIM_IRQHandler(current_timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003868",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003868"
        },
        "FUN_080048cc": {
            "renaming": {
                "FUN_080048cc": "fill_memory_with_value_080048cc",
                "__s": "memory",
                "__c": "value",
                "__n": "size",
                "puVar1": "current_byte",
                "(undefined *)": "(unsigned char *)",
                "(char)": "(unsigned char)",
                "(int)": "(size_t)"
            },
            "code": "void * fill_memory_with_value_080048cc(void *memory, int value, size_t size) {\n  unsigned char *current_byte;\n  unsigned char *end_byte = (unsigned char *)(memory + size);\n  for (current_byte = (unsigned char *)memory; current_byte != end_byte; current_byte++) {\n    *current_byte = (unsigned char)value;\n  }\n  return memory;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048cc",
            "calling": [
                "std.isra.0",
                "__sfmoreglue",
                "__sfp"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_080048cc"
        },
        "FUN_080040e4": {
            "renaming": {
                "FUN_080040e4": "zero_return_080040e4",
                "file_UNUSED": "file_unused",
                "ptr_UNUSED": "ptr_unused",
                "dir_UNUSED": "dir_unused"
            },
            "code": "int zero_return_080040e4(int file_unused, int ptr_unused, int dir_unused)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e4",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "zero_return_080040e4"
        },
        "FUN_08003506": {
            "renaming": {
                "FUN_08003506": "find_pin_name_08003506",
                "PinName_conflict": "PinName_conflict",
                "void *peripheral": "void *peripheral",
                "PinMap_conflict *map": "PinMap_conflict *map",
                "NC": "NC",
                "map": "map",
                "peripheral": "peripheral"
            },
            "code": "PinName_conflict find_pin_name_08003506(void *peripheral, PinMap_conflict *map){\n    while( true ) {\n        if (map->peripheral == (void *)0x0) {\n            return NC;\n        }\n        if (map->peripheral == peripheral) {\n            break;\n        }\n        map++;\n    }\n    return map->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003506",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_08003506"
        },
        "FUN_080025e0": {
            "renaming": {
                "FUN_080025e0": "system_core_clock_080025e0",
                "PTR_SystemCoreClock_080025e8": "system_core_clock_ptr"
            },
            "code": "uint32_t system_core_clock_080025e0(void)\n{\n    return *(uint32_t *)PTR_SystemCoreClock_080025e8;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e0",
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "system_core_clock_080025e0"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "count_bytes_080040e8",
                "file_UNUSED": "file",
                "ptr_UNUSED": "buffer",
                "len_UNUSED": "length"
            },
            "code": "int count_bytes_080040e8(int file, char *buffer, int length) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "count_bytes_080040e8"
        },
        "FUN_08000a00": {
            "renaming": {
                "__thiscall Modbus::FUN_08000a00": "modbus_handle_bit",
                "*this": "modbus",
                "*regs": "registers",
                "u8size": "num_registers",
                "uVar1": "buffer_word",
                "uVar2": "bit_index",
                "uVar3": "register_index",
                "FUN_08000a00": "modbus_handle_bit_08000a00"
            },
            "code": "int8_t __thiscall modbus_handle_bit_08000a00(Modbus *modbus, uint16_t *registers, uint8_t num_registers)\n{\n    uint16_t buffer_word = makeWord(modbus->au8Buffer[2], modbus->au8Buffer[3]);\n    uint register_index = ((uint)buffer_word << 0x14) >> 0x18;\n    uint bit_index = buffer_word & 0xf;\n    if (modbus->au8Buffer[4] == 0xff)\n    {\n        registers[register_index] = (ushort)(1 << bit_index) | registers[register_index];\n    }\n    else\n    {\n        registers[register_index] = registers[register_index] & ~(ushort)(1 << bit_index);\n    }\n    modbus->u8BufferSize = '\\x06';\n    sendTxBuffer(modbus);\n    return '\b';\n}",
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a00",
            "calling": [
                "poll"
            ],
            "imported": false,
            "current_name": "modbus_handle_bit_08000a00"
        },
        "FUN_080047c0": {
            "renaming": {
                "__thiscall std::function<void()>::operator__": "FUN_invoke_function_if_possible",
                "this": "function_ptr",
                "super__Function_base": "function_base",
                "_M_manager": "manager_type",
                "_M_invoker": "invoker",
                "_Any_data": "any_data",
                "__throw_bad_function_call": "throw_bad_function_call",
                "FUN_080047c0": "invoke_function_if_possible_080047c0"
            },
            "code": "void invoke_function_if_possible_080047c0(function_void___ *function_ptr)\n{\n    if ((function_ptr->super__Function_base)._M_manager != (_Manager_type)0x0) {\n        (*function_ptr->_M_invoker)((_Any_data *)function_ptr);\n        return;\n    }\n    __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047c0",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "invoke_function_if_possible_080047c0"
        },
        "FUN_08005374": {
            "renaming": {
                "FUN_08005374": "allocate_memory_and_initialize_to_zero_08005374",
                "param_1": "size",
                "param_2": "num_elements",
                "puVar1": "memory_ptr",
                "iVar2": "total_size"
            },
            "code": "undefined4 allocate_memory_and_initialize_to_zero_08005374(undefined4 size, int num_elements)\n{\n    undefined4 *memory_ptr;\n    int total_size = (num_elements - 1) * 0x68;\n    \n    memory_ptr = (undefined4 *)_malloc_r(size, total_size + 0x74);\n    \n    if (memory_ptr != (undefined4 *)0x0) {\n        *memory_ptr = 0;\n        memory_ptr[1] = num_elements;\n        memory_ptr[2] = memory_ptr + 3;\n        memset(memory_ptr + 3, 0, total_size + 0x68);\n    }\n    return memory_ptr;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005374",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_and_initialize_to_zero_08005374"
        },
        "FUN_08004d9c": {
            "renaming": {
                "FUN_08004d9c": "FUNC_08004d9c"
            },
            "code": "\nuint FUNC_08004d9c(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08004f56;\n          if (bVar1 != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_08004fd8;\nLAB_08004ee6:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_08004dcc;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_08004dec;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_08004dec:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_08004fd8;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_08004ec2;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08004e2c:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_08004e52:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_08004e60;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_08004e60:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_08004fd8;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            puVar6 = PTR_s_0123456789abcdef_08004fd4;\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_08004e52;\n          if (bVar1 == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08004e2c;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_08004f42;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_08004f42:\n    *puVar3 = uVar7;\n  }\nLAB_08004f56:\n  param_2[4] = 0;\nLAB_08004ec2:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_08004ed6:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_08004ed6;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "memchr",
                "_printf_common"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004d9c",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_08004d9c"
        },
        "FUN_08003750": {
            "renaming": {
                "FUN_08003750": "get_stimer_from_timer_handle_08003750",
                "htim": "timer_handle",
                "stimer_t": "stimer",
                "previous_timer_handle": "previous_timer_handle"
            },
            "code": "stimer_t * get_stimer_from_timer_handle_08003750(TIM_HandleTypeDef *timer_handle)\n{\n    TIM_HandleTypeDef *previous_timer_handle = timer_handle - 1;\n    return (stimer_t *)&previous_timer_handle->Lock;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003750",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_from_timer_handle_08003750"
        },
        "FUN_080014ec": {
            "renaming": {
                "FUN_080014ec": "i2c_slave_listen_080014ec",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "cr1_value"
            },
            "code": "HAL_StatusTypeDef i2c_slave_listen_080014ec(I2C_HandleTypeDef *handle, uint8_t *data, uint16_t size, uint32_t transfer_options) {\n  HAL_StatusTypeDef status = HAL_ERROR;\n  I2C_TypeDef *instance;\n  uint32_t cr1_value;\n  if (handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || handle->Lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      instance = handle->Instance;\n      cr1_value = instance->CR1;\n      if ((cr1_value & 1) == 0) {\n        instance->CR1 = cr1_value | 1;\n      }\n      instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = transfer_options;\n      handle->XferSize = handle->XferCount;\n      handle->Lock = HAL_UNLOCKED;\n      instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014ec",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_slave_listen_080014ec"
        },
        "FUN_080048dc": {
            "renaming": {
                "FUN_080048dc": "allocate_memory_080048dc",
                "*param_1": "*error_code",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "free_list_ptr",
                "piVar2": "ptr2",
                "extraout_r1": "ptr3",
                "ppiVar3": "ptr3",
                "ppiVar4": "ptr4",
                "ppiVar5": "ptr5",
                "ppiVar6": "ptr6",
                "ppiVar7": "ptr7",
                "bVar8": "is_ptr5_equals_ptr4"
            },
            "code": "void allocate_memory_080048dc(int* error_code, int size, int arg3, int arg4)\n{\n    if (size == 0) {\n        return;\n    }\n    int** ptr7 = (int**)(size - 4);\n    if (*(int*)(size - 4) < 0) {\n        ptr7 = (int**)((int)ptr7 + *(int*)(size - 4));\n    }\n    __malloc_lock();\n    void* free_list_ptr = PTR___malloc_free_list_08004974;\n    int** ptr5 = *(int***)(PTR___malloc_free_list_08004974);\n    if (ptr5 == (int**)0x0) {\n        ptr7[1] = (int*)0x0;\n        *(int***)free_list_ptr = ptr7;\n        int** ptr3 = (int**)extraout_r1;\n        int** ptr4 = (int**)free_list_ptr;\n    }\n    else if (ptr7 < ptr5) {\n        int** ptr3 = (int**)*ptr7;\n        int** ptr4 = (int**)((int)ptr7 + (int)ptr3);\n        bool is_ptr5_equals_ptr4 = ptr5 == ptr4;\n        if (is_ptr5_equals_ptr4) {\n            ptr4 = (int**)*ptr5;\n            ptr5 = (int**)ptr5[1];\n        }\n        ptr7[1] = (int*)ptr5;\n        if (is_ptr5_equals_ptr4) {\n            ptr4 = (int**)((int)ptr4 + (int)ptr3);\n            *ptr7 = (int*)ptr4;\n        }\n        *(int***)free_list_ptr = ptr7;\n    }\n    else {\n        do {\n            int** ptr6 = ptr5;\n            int** ptr4 = (int**)ptr6[1];\n            if (ptr4 == (int**)0x0) break;\n            ptr5 = ptr4;\n        } while (ptr4 <= ptr7);\n        int** ptr3 = (int**)*ptr6;\n        if ((int**)((int)ptr6 + (int)ptr3) == ptr7) {\n            ptr3 = (int**)((int)ptr3 + (int)*ptr7);\n            *ptr6 = (int*)ptr3;\n            if (ptr4 == (int**)((int)ptr6 + (int)ptr3)) {\n                int* ptr2 = *ptr4;\n                ptr4 = (int**)ptr4[1];\n                ptr6[1] = (int*)ptr4;\n                ptr3 = (int**)((int)ptr3 + (int)ptr2);\n                *ptr6 = (int*)ptr3;\n            }\n        }\n        else if (ptr7 < (int**)((int)ptr6 + (int)ptr3)) {\n            *error_code = 0xc;\n        }\n        else {\n            ptr3 = (int**)((int)ptr7 + (int)*ptr7);\n            bool is_ptr4_equals_ptr3 = ptr4 == ptr3;\n            if (is_ptr4_equals_ptr3) {\n                ptr3 = (int**)*ptr4;\n                ptr4 = (int**)ptr4[1];\n            }\n            ptr7[1] = (int*)ptr4;\n            if (is_ptr4_equals_ptr3) {\n                ptr3 = (int**)((int)ptr3 + (int)*ptr7);\n                *ptr7 = (int*)ptr3;\n            }\n            ptr6[1] = (int*)ptr7;\n        }\n    }\n    __malloc_unlock(error_code, ptr3, ptr4, arg4);\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048dc",
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080048dc"
        },
        "FUN_08003754": {
            "renaming": {
                "FUN_08003754": "handle_timer_interrupt_08003754",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandleOC": "irq_handle_output_compare"
            },
            "code": "void handle_timer_interrupt_08003754(TIM_HandleTypeDef *timer_handle)\n{\n  stimer_t *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->irq_handle_output_compare != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->irq_handle_output_compare)(timer_obj,0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003754",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08003754"
        },
        "FUN_08001578": {
            "renaming": {
                "FUN_08001578": "set_i2c_to_listen_mode_08001578",
                "hi2c": "i2c_handle",
                "pIVar1": "i2c_instance",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "HAL_StatusTypeDef set_i2c_to_listen_mode_08001578(I2C_HandleTypeDef *i2c_handle) {\n  I2C_TypeDef *i2c_instance;\n  \n  if (i2c_handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  i2c_handle->State = HAL_I2C_STATE_LISTEN;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 |= 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001578",
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "imported": false,
            "current_name": "set_i2c_to_listen_mode_08001578"
        },
        "FUN_080035ac": {
            "renaming": {
                "FUN_080035ac": "handle_rtc_alarm_interrupt_080035ac",
                "PTR_RtcHandle_080035b8": "PTR_RtcHandle"
            },
            "code": "void handle_rtc_alarm_interrupt_080035ac(void)\n{\n  HAL_RTC_AlarmIRQHandler((RTC_HandleTypeDef *)PTR_RtcHandle_080035b8_080035b8);\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035ac",
            "calling": [],
            "imported": false,
            "current_name": "handle_rtc_alarm_interrupt_080035ac"
        },
        "FUN_08004844": {
            "renaming": {
                "FUN_08004844": "calculate_result_08004844",
                "param_1": "is_flag_set",
                "param_2": "input_value",
                "DAT_0800485c": "flag_value"
            },
            "code": "longlong calculate_result_08004844(undefined4 is_flag_set, uint input_value)\n{\n  if (DAT_0800485c != 0) {\n    return CONCAT44(is_flag_set, 2);\n  }\n  return (ulonglong)input_value << 0x20;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004844",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "calculate_result_08004844"
        },
        "FUN_0800318c": {
            "renaming": {
                "FUN_0800318c": "get_gpio_type_def_0800318c",
                "port_idx": "port_index",
                "DAT_080031d0": "ptr_dat_080031d0",
                "DAT_080031f8": "ptr_dat_080031f8",
                "DAT_080031d4": "ptr_dat_080031d4",
                "DAT_080031d8": "ptr_dat_080031d8",
                "DAT_080031dc": "ptr_dat_080031dc",
                "DAT_080031e0": "ptr_dat_080031e0",
                "DAT_080031e4": "ptr_dat_080031e4",
                "DAT_080031e8": "ptr_dat_080031e8",
                "DAT_080031ec": "ptr_dat_080031ec",
                "DAT_080031f0": "ptr_dat_080031f0",
                "DAT_080031f4": "ptr_dat_080031f4"
            },
            "code": "GPIO_TypeDef* get_gpio_type_def_0800318c(uint32_t port_index) {\n    switch(port_index) {\n        case 0:\n            return DAT_080031d0;\n        case 1:\n            return DAT_080031f8;\n        case 2:\n            return DAT_080031d4;\n        case 3:\n            return DAT_080031d8;\n        case 4:\n            return DAT_080031dc;\n        case 5:\n            return DAT_080031e0;\n        case 6:\n            return DAT_080031e4;\n        case 7:\n            return DAT_080031e8;\n        case 8:\n            return DAT_080031ec;\n        case 9:\n            return DAT_080031f0;\n        case 10:\n            return DAT_080031f4;\n        default:\n            return (GPIO_TypeDef*)0x0;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800318c",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "get_gpio_type_def_0800318c"
        },
        "FUN_080001d0": {
            "renaming": {
                "FUN_080001d0": "execute_function_if_completed_080001d0",
                "PTR_completed_8667_08000210": "completed_ptr",
                "DAT_08000214": "function_ptr",
                "PTR_object_8672_0800020c": "object_ptr",
                "DAT_08000204": "data"
            },
            "code": "void execute_function_if_completed_080001d0(){\n  int* PTR_completed_8667_08000210 = (int*)PTR_completed_8667_08000210;\n  code* DAT_08000214 = DAT_08000214;\n\n  if (DAT_08000204 == 0) {\n    return;\n  }\n\n  if (*PTR_completed_8667_08000210 != 0 && DAT_08000214 != (code *)0x0) {\n    (*DAT_08000214)(PTR_completed_8667_08000210,PTR_object_8672_0800020c);\n    return;\n  }\n\n  if (*PTR_completed_8667_08000210 != 0 && DAT_08000214 != (code *)0x0) {\n    (*DAT_08000214)();\n    return;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001d0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_completed_080001d0"
        },
        "FUN_080047d0": {
            "renaming": {
                "FUN_080047d0": "handle_gpio_irq_080047d0",
                "GPIO_Pin": "pin_number",
                "bVar1": "pin_id"
            },
            "code": "void handle_gpio_irq_080047d0(uint16_t pin_number)\n{\n  uint8_t pin_id = get_pin_id(pin_number);\n  if (*(int *)(PTR_gpio_irq_conf_080047ec + (uint)pin_id * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__((function_void___ *)(PTR_gpio_irq_conf_080047ec + (uint)pin_id * 0x14 + 4));\n  }\n  return;\n}",
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047d0",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_irq_080047d0"
        },
        "FUN_080040f8": {
            "renaming": {
                "FUN_080040f8": "infinite_loop_080040f8",
                "status_UNUSED": "status"
            },
            "code": "void infinite_loop_080040f8(int status_UNUSED)\n{\n  while(true)\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040f8",
            "calling": [
                "_exit",
                "abort"
            ],
            "imported": false,
            "current_name": "infinite_loop_080040f8"
        },
        "FUN_0800500c": {
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "error_ptr",
                "pcVar2": "memory_ptr",
                "PTR_errno_08005028": "errno_ptr"
            },
            "code": "void allocate_memory_0800500c(int *error_code, int size)\n{\n  undefined *error_ptr;\n  caddr_t memory_ptr;\n  error_ptr = PTR_errno_08005028;\n  *(undefined4 *)PTR_errno_08005028 = 0;\n  memory_ptr = _sbrk(size);\n  if ((memory_ptr == (caddr_t)0xffffffff) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800500c",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_0800500c"
        },
        "FUN_080023b4": {
            "renaming": {
                "FUN_080023b4": "calculate_time_in_seconds_080023b4",
                "DAT_0800247c": "time_data",
                "DAT_08002480": "time_error",
                "DAT_08002484": "time_default",
                "uVar1": "time_type",
                "uVar2": "time_value"
            },
            "code": "uint32_t calculate_time_in_seconds_080023b4(void)\n{\n  uint32_t result;\n  uint32_t DAT_0800247c = *(uint32_t *)(DAT_0800247c + 8);\n  uint32_t time_type = DAT_0800247c & 0xc;\n  if (time_type == 4) {\n    result = DAT_08002484;\n  }\n  else if (time_type != 8) {\n    result = DAT_08002480;\n  }\n  else {\n    uint32_t time_value = DAT_0800247c & 0x3f;\n    if ((DAT_0800247c & 0x400000) == 0) {\n      uint32_t time_calc = time_value * 16000000;\n      uint32_t time_divisor = ((((time_value * 0x20) < time_value) ? -0x3f : 0) - (((time_value * 0x7c0) < (time_value * 0x1f)) ? 1 : 0)) * 8 + ((time_value * 0x3d08) + time_value) * 0x400 | (time_value * 0x3d09) >> 0x16;\n      result = __aeabi_uldivmod(time_calc, time_divisor, 0, 0);\n    }\n    else {\n      uint32_t time_calc = time_value * 8000000;\n      uint32_t time_divisor = ((((time_value * 0x20) < time_value) ? -0x3f : 0) - (((time_value * 0x7c0) < (time_value * 0x1f)) ? 1 : 0)) * 8 + ((time_value * 0x3d08) + time_value) * 0x200;\n      result = __aeabi_uldivmod(time_calc, time_divisor, 0, 0);\n    }\n    result /= ((((DAT_0800247c << 0xe) >> 0x1e) + 1) * 2);\n  }\n  return result;\n}",
            "called": [
                "__aeabi_uldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080023b4",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_time_in_seconds_080023b4"
        },
        "FUN_080011a4": {
            "renaming": {
                "FUN_080011a4": "update_gpio_pin_state_080011a4",
                "GPIO_Pin": "gpio_pin",
                "DAT_080011bc": "gpio_pin_state_data",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void update_gpio_pin_state_080011a4(uint16_t gpio_pin) {\n  uint* gpio_pin_state_ptr = (uint*)(DAT_080011bc + 0x14);\n  uint current_gpio_pin_state = *gpio_pin_state_ptr;\n  if((current_gpio_pin_state & (uint)gpio_pin) != 0) {\n    *gpio_pin_state_ptr = (uint)gpio_pin;\n    HAL_GPIO_EXTI_Callback(gpio_pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011a4",
            "calling": [
                "EXTI0_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI4_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_gpio_pin_state_080011a4"
        },
        "FUN_08001e68": {
            "renaming": {
                "FUN_08001e68": "i2c_handle_errors_08001e68",
                "*hi2c": "*i2c_handler",
                "HVar1": "current_state",
                "*pIVar2": "*i2c_instance",
                "uVar3": "sr1_value",
                "uVar4": "cr2_value",
                "DAT_08001f38": "I2C_SR1_ARLO",
                "0x100": "I2C_CR2_ITEVTEN",
                "0x10200": "I2C_SR1_AF",
                "0x10400": "I2C_SR1_BERR",
                "HAL_I2C_MODE_SLAVE": "HAL_I2C_MODE_SLAVE",
                "HAL_I2C_MODE_MASTER": "HAL_I2C_MODE_MASTER",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "0x21": "0x21",
                "I2C_Slave_AF": "I2C_Slave_AF",
                "HAL_I2C_ERROR_ARLO": "HAL_I2C_ERROR_ARLO",
                "HAL_I2C_ERROR_AF": "HAL_I2C_ERROR_AF",
                "HAL_I2C_ERROR_BERR": "HAL_I2C_ERROR_BERR",
                "HAL_I2C_ERROR_OVR": "HAL_I2C_ERROR_OVR",
                "I2C_ITError": "I2C_ITError"
            },
            "code": "void i2c_handle_errors_08001e68(I2C_HandleTypeDef *i2c_handler) {\n  HAL_I2C_StateTypeDef current_state;\n  I2C_TypeDef *i2c_instance;\n  uint8_t sr1_value;\n  uint8_t cr2_value;\n\n  i2c_instance = i2c_handler->Instance;\n  sr1_value = i2c_instance->SR1;\n  cr2_value = i2c_instance->CR2;\n\n  if (((sr1_value & DAT_08001f38) != 0) && ((cr2_value & I2C_CR2_ITEVTEN) != 0)) {\n    i2c_handler->ErrorCode |= HAL_I2C_ERROR_ARLO;\n    i2c_instance->SR1 = 0xfffffeff;\n  }\n  if (((sr1_value & I2C_SR1_AF) != 0) && ((cr2_value & I2C_CR2_ITEVTEN) != 0)) {\n    i2c_handler->ErrorCode |= HAL_I2C_ERROR_AF;\n    i2c_instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1_value & I2C_SR1_BERR) != 0) && ((cr2_value & I2C_CR2_ITEVTEN) != 0)) {\n    current_state = i2c_handler->State;\n    if (((i2c_handler->Mode == HAL_I2C_MODE_SLAVE) && (i2c_handler->XferCount == 0)) && (((current_state == HAL_I2C_STATE_BUSY_TX) || (current_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((current_state == HAL_I2C_STATE_LISTEN) && (i2c_handler->PreviousState == 0x21)))) {\n      I2C_Slave_AF(i2c_handler);\n    }\n    else {\n      i2c_handler->ErrorCode |= HAL_I2C_ERROR_BERR;\n      if (i2c_handler->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_instance->CR1 |= I2C_CR1_STOP;\n      }\n      i2c_instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1_value & I2C_SR1_OVR) != 0) && ((cr2_value & I2C_CR2_ITEVTEN) != 0)) {\n    i2c_handler->ErrorCode |= HAL_I2C_ERROR_OVR;\n    i2c_instance->SR1 = 0xfffff7ff;\n  }\n  if (i2c_handler->ErrorCode != 0) {\n    I2C_ITError(i2c_handler);\n  }\n  return;\n}",
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e68",
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C3_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_errors_08001e68"
        },
        "FUN_080019a0": {
            "renaming": {
                "FUN_080019a0": "receive_data_from_I2C_080019a0",
                "*hi2c": "*i2c_handle",
                "puVar1": "buffer_pointer",
                "hi2c->XferCount": "i2c_handle->XferCount",
                "hi2c->Instance->CR2": "i2c_handle->Instance->CR2",
                "hi2c->pBuffPtr": "i2c_handle->pBuffPtr",
                "(uint8_t)hi2c->Instance->DR": "(uint8_t)i2c_handle->Instance->DR",
                "hi2c->Instance->CR1": "i2c_handle->Instance->CR1",
                "hi2c->XferOptions": "i2c_handle->XferOptions",
                "hi2c->State": "i2c_handle->State",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "hi2c->PreviousState": "i2c_handle->PreviousState",
                "hi2c->Mode": "i2c_handle->Mode",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_MemRxCpltCallback": "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback": "HAL_I2C_MasterRxCpltCallback"
            },
            "code": "HAL_StatusTypeDef receive_data_from_I2C_080019a0(I2C_HandleTypeDef *i2c_handle)\n{\n    uint8_t *buffer_pointer;\n\n    if (i2c_handle->XferCount == 4) {\n        i2c_handle->Instance->CR2 &= 0xfffffbff;\n        buffer_pointer = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n    }\n    else if (i2c_handle->XferCount == 3) {\n        i2c_handle->Instance->CR2 &= 0xfffffbff;\n        i2c_handle->Instance->CR1 &= 0xfffffbff;\n        buffer_pointer = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n    }\n    else if (i2c_handle->XferCount == 2) {\n        if (i2c_handle->XferOptions - 1 < 2) {\n            i2c_handle->Instance->CR1 &= 0xfffffbff;\n            i2c_handle->Instance->CR1 |= 0x100;\n        }\n        else {\n            i2c_handle->Instance->CR1 |= 0x200;\n        }\n        buffer_pointer = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n        buffer_pointer = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n        i2c_handle->Instance->CR2 &= 0xfffffcff;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->PreviousState = 0;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n            i2c_handle->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MemRxCpltCallback(i2c_handle);\n        }\n        else {\n            i2c_handle->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MasterRxCpltCallback(i2c_handle);\n        }\n    }\n    else {\n        buffer_pointer = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n        i2c_handle->XferCount--;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080019a0",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_from_I2C_080019a0"
        },
        "FUN_08003f24": {
            "renaming": {
                "FUN_08003f24": "process_uart_data_08003f24",
                "*huart": "*uart_handle",
                "bVar1": "uart_index_value",
                "uVar2": "callback_index",
                "PTR_rx_callback_08003f40": "rx_callback_ptr_08003f40",
                "PTR_rx_callback_obj_08003f44": "rx_callback_obj_ptr_08003f44"
            },
            "code": "void process_uart_data_08003f24(UART_HandleTypeDef *uart_handle) {\n  byte uart_index_value;\n  uint8_t callback_index;\n  uart_index_value = get_uart_index(uart_handle);\n  callback_index = (uint8_t)uart_index_value;\n  if (callback_index < 10) {\n    (**(code **)(PTR_rx_callback_08003f40 + callback_index * 4))(*(undefined4 *)(PTR_rx_callback_obj_08003f44 + callback_index * 4));\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f24",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "process_uart_data_08003f24"
        },
        "FUN_080046b4": {
            "renaming": {
                "FUN_080046b4": "configure_gpio_irq_080046b4",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "puVar1": "gpio_irq_conf_ptr"
            },
            "code": "void configure_gpio_irq_080046b4(int should_initialize, int priority)\n{\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    uint8_t* gpio_irq_conf_ptr = PTR_gpio_irq_conf_08004754;\n    gpio_irq_conf_ptr[0] = 6;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0xc) = 0;\n    gpio_irq_conf_ptr[0x14] = 7;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x20) = 0;\n    gpio_irq_conf_ptr[0x28] = 8;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x34) = 0;\n    gpio_irq_conf_ptr[0x3c] = 9;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x48) = 0;\n    gpio_irq_conf_ptr[0x50] = 10;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x5c) = 0;\n    gpio_irq_conf_ptr[100] = 0x17;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x70) = 0;\n    gpio_irq_conf_ptr[0x78] = 0x17;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x84) = 0;\n    gpio_irq_conf_ptr[0x8c] = 0x17;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x98) = 0;\n    gpio_irq_conf_ptr[0xa0] = 0x17;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0xac) = 0;\n    gpio_irq_conf_ptr[0xb4] = 0x17;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0xc0) = 0;\n    gpio_irq_conf_ptr[200] = 0x28;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0xd4) = 0;\n    gpio_irq_conf_ptr[0xdc] = 0x28;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0xe8) = 0;\n    gpio_irq_conf_ptr[0xf0] = 0x28;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0xfc) = 0;\n    gpio_irq_conf_ptr[0x104] = 0x28;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x110) = 0;\n    gpio_irq_conf_ptr[0x118] = 0x28;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x124) = 0;\n    gpio_irq_conf_ptr[300] = 0x28;\n    *(uint32_t *)(gpio_irq_conf_ptr + 0x138) = 0;\n    __aeabi_atexit(0, DAT_0800475c, PTR___dso_handle_08004758);\n  }\n}",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046b4",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "configure_gpio_irq_080046b4"
        },
        "FUN_0800160c": {
            "renaming": {
                "FUN_0800160c": "do_nothing_0800160c"
            },
            "code": "\nvoid do_nothing_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800160c",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_0800160c"
        },
        "FUN_0800160e": {
            "renaming": {
                "FUN_0800160e": "receive_byte_from_i2c_0800160e",
                "hi2c": "i2c_handle",
                "HVar1": "current_state",
                "puVar2": "buffer_pointer"
            },
            "code": "HAL_StatusTypeDef receive_byte_from_i2c_0800160e(I2C_HandleTypeDef *i2c_handle)\n{\n  HAL_I2C_StateTypeDef current_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0) {\n    uint8_t *buffer_pointer = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount--;\n    if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->Instance->CR2 &= 0xfffffbff;\n      i2c_handle->PreviousState = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800160e",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_byte_from_i2c_0800160e"
        },
        "FUN_0800293e": {
            "renaming": {
                "FUN_0800293e": "do_nothing_0800293e"
            },
            "code": "\nvoid do_nothing_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800293e",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800293e"
        },
        "FUN_08000e18": {
            "renaming": {
                "FUN_08000e18": "update_uw_tick_08000e18",
                "PTR_uwTick_08000e28": "tick_ptr",
                "PTR_uwTickFreq_08000e2c": "tick_freq"
            },
            "code": "void update_uw_tick_08000e18(void)\n{\n    uint8_t PTR_uwTickFreq_08000e2c = *PTR_uwTickFreq_08000e2c;\n    uint32_t* PTR_uwTick_08000e28 = (uint32_t*)PTR_uwTick_08000e28;\n    *PTR_uwTick_08000e28 += PTR_uwTickFreq_08000e2c;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e18",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_uw_tick_08000e18"
        },
        "FUN_08003486": {
            "renaming": {
                "FUN_08003486": "configure_gpio_pin_08003486",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "GPIOx": "gpio_port",
                "GPIO_InitStructure": "gpio_init_struct",
                "GPIO_InitStructure.Pin": "gpio_init_struct.Pin",
                "GPIO_InitStructure.Speed": "gpio_init_struct.Speed",
                "GPIO_InitStructure.Mode": "gpio_init_struct.Mode",
                "GPIO_InitStructure.Pull": "gpio_init_struct.Pull"
            },
            "code": "void configure_gpio_pin_08003486(PinName_conflict pin, uint32_t mode, uint32_t pull)\n{\n  GPIO_TypeDef *gpio_port;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  gpio_port = set_GPIO_Port_Clock((uint)((int)pin << 0x18) >> 0x1c);\n  gpio_init_struct.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;\n  gpio_init_struct.Mode = mode;\n  gpio_init_struct.Pull = pull;\n  HAL_GPIO_Init(gpio_port, &gpio_init_struct);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003486",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_08003486"
        },
        "FUN_08005662": {
            "renaming": {
                "FUN_08005662": "seek_and_update_status_08005662",
                "param_1": "file_descriptor",
                "param_2": "status_info",
                "iVar1": "seek_result",
                "uVar2": "new_status",
                "bVar3": "seek_failed"
            },
            "code": "void seek_and_update_status_08005662(int file_descriptor, int* status_info) {\n    int seek_result = _lseek_r(file_descriptor, (int)*(short *)(status_info + 0xe));\n    bool seek_failed = seek_result == -1;\n    ushort new_status = *(ushort *)(status_info + 0xc);\n    if (seek_failed) {\n        new_status &= 0xefff;\n    }\n    else {\n        *(int *)(status_info + 0x54) = seek_result;\n        new_status |= 0x1000;\n    }\n    *(ushort *)(status_info + 0xc) = new_status;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005662",
            "calling": [],
            "imported": false,
            "current_name": "seek_and_update_status_08005662"
        },
        "FUN_080042ac": {
            "renaming": {
                "HardwareSerial::FUN_080042ac": "read_serial_data",
                "*obj": "*serial_data",
                "iVar1": "uart_read_result",
                "uVar2": "next_rx_head",
                "c": "received_char",
                "rx_head": "serial_data->rx_head",
                "rx_tail": "serial_data->rx_tail",
                "rx_buff": "serial_data->rx_buff",
                "FUN_080042ac": "HardwareSerial::read_serial_data_080042ac"
            },
            "code": "void HardwareSerial::read_serial_data_080042ac(serial_t_conflict *serial_data)\n{\n    int uart_read_result;\n    ushort next_rx_head;\n    uchar received_char;\n\n    uart_read_result = uart_getc((serial_t *)serial_data, &received_char);\n    if ((uart_read_result == 0) && ((next_rx_head = serial_data->rx_head + 1 & 0x3f) != serial_data->rx_tail)) {\n        serial_data->rx_buff[serial_data->rx_head] = received_char;\n        serial_data->rx_head = next_rx_head;\n    }\n    return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042ac",
            "calling": [],
            "imported": false,
            "current_name": "HardwareSerial::read_serial_data_080042ac"
        },
        "FUN_08001864": {
            "renaming": {
                "FUN_08001864": "i2c_transfer_08001864",
                "*hi2c": "*handle",
                "uVar1": "transfer_options",
                "pbVar2": "buffer_ptr"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08001864(I2C_HandleTypeDef *handle)\n{\n  uint32_t transfer_options = handle->XferOptions;\n  if (handle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (handle->XferCount == 0) {\n      if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n        handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n        handle->Instance->CR1 = handle->Instance->CR1 | 0x200;\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        if (handle->Mode == HAL_I2C_MODE_MEM) {\n          handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(handle);\n        }\n        else {\n          handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(handle);\n        }\n      }\n      else {\n        handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n        handle->PreviousState = 0x11;\n        handle->Mode = HAL_I2C_MODE_NONE;\n        handle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(handle);\n      }\n    }\n    else {\n      uint8_t *buffer_ptr = handle->pBuffPtr;\n      handle->pBuffPtr = buffer_ptr + 1;\n      handle->Instance->DR = (uint)*buffer_ptr;\n      handle->XferCount = handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001864",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08001864"
        },
        "FUN_08000f2c": {
            "renaming": {
                "FUN_08000f2c": "update_clk_source_08000f2c",
                "CLKSource": "clk_source",
                "DAT_08000f48": "data_register"
            },
            "code": "void update_clk_source_08000f2c(uint32_t clk_source)\n{\n  if (clk_source != 4) {\n    *DAT_08000f48 = *DAT_08000f48 & 0xfffffffb;\n    return;\n  }\n  *DAT_08000f48 = *DAT_08000f48 | 4;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f2c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "update_clk_source_08000f2c"
        },
        "FUN_08000ec4": {
            "renaming": {
                "FUN_08000ec4": "set_interrupt_handler_08000ec4",
                "IRQn": "irq",
                "uVar1": "irq_num",
                "DAT_08000edc": "interrupt_register"
            },
            "code": "void set_interrupt_handler_08000ec4(IRQn_Type_conflict irq)\n{\n  uint irq_num = (uint)irq;\n  if (irq_num >= 0) {\n    int* DAT_08000edc = (int*)(DAT_08000edc + (irq_num >> 5) * 4);\n    int bit_position = irq_num & 0x1f;\n    *DAT_08000edc = 1 << bit_position;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ec4",
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "set_interrupt_handler_08000ec4"
        },
        "FUN_08004338": {
            "renaming": {
                "FUN_08004338": "check_serial3_available_08004338",
                "DAT_0800435c": "serial3_initialized",
                "PTR_Serial3_08004360": "serial3_ptr"
            },
            "code": "void check_serial3_available_08004338(void)\n{\n  if (DAT_0800435c != 0) {\n    HardwareSerial::available(PTR_Serial3_08004360);\n  }\n  return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004338",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "check_serial3_available_08004338"
        },
        "FUN_08003928": {
            "renaming": {
                "FUN_08003928": "handle_i2c_error_interrupt_08003928",
                "PTR_i2c_handles_08003934": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_error_interrupt_08003928(void)\n{\n  HAL_I2C_ER_IRQHandler(*PTR_i2c_handles_08003934);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003928",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08003928"
        },
        "FUN_0800468c": {
            "renaming": {
                "FUN_0800468c": "free_gpio_irq_configurations_0800468c",
                "param_1": "list_start_ptr",
                "puVar1": "previous_ptr",
                "puVar2": "current_ptr"
            },
            "code": "void free_gpio_irq_configurations_0800468c(void *list_start_ptr)\n{\n  void *current_ptr;\n  void *previous_ptr;\n  current_ptr = PTR___malloc_free_list_080046ac;\n  while (previous_ptr = current_ptr, previous_ptr != PTR_gpio_irq_conf_080046b0) {\n    current_ptr = previous_ptr + -0x14;\n    if (*(code **)(previous_ptr + -8) != (code *)0x0) {\n      (**(code **)(previous_ptr + -8))(previous_ptr + -0x10,previous_ptr + -0x10,3);\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800468c",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configurations_0800468c"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "software_interrupt_handler_080005e0",
                "a0": "return_value",
                "a1": "interrupt_number",
                "a2": "parameter_value"
            },
            "code": "uint32_t software_interrupt_handler_080005e0(uint32_t interrupt_number, uint32_t return_value, int32_t parameter_value) {\n  software_interrupt(interrupt_number);\n  return return_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "software_interrupt_handler_080005e0"
        },
        "FUN_0800311c": {
            "renaming": {
                "FUN_0800311c": "reset_uart_dma_transfer_counts_0800311c",
                "*hdma": "dma_handler",
                "*huart": "uart_handler",
                "RxXferCount": "rx_transfer_count",
                "TxXferCount": "tx_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error"
            },
            "code": "void reset_uart_dma_transfer_counts_0800311c(DMA_HandleTypeDef *dma_handler)\n{\n  UART_HandleTypeDef *uart_handler;\n  uart_handler = (UART_HandleTypeDef *)dma_handler->Parent;\n  uart_handler->RxXferCount = 0;\n  uart_handler->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handler);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800311c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_dma_transfer_counts_0800311c"
        },
        "FUN_0800420c": {
            "renaming": {
                "FUN_0800420c": "calculate_next_tx_tail_0800420c",
                "*obj": "*serial_object",
                "iVar3": "next_tx_tail",
                "uVar1": "next_tx_tail_ushort",
                "uVar2": "masked_tx_tail"
            },
            "code": "int calculate_next_tx_tail_0800420c(serial_t_conflict *serial_object)\n{\n  int next_tx_tail = serial_object->tx_tail + 1;\n  ushort next_tx_tail_ushort = (ushort)next_tx_tail;\n  uint16_t masked_tx_tail = next_tx_tail_ushort & 0x7f;\n  if (next_tx_tail == 0) {\n    masked_tx_tail = -(-next_tx_tail_ushort & 0x7f);\n  }\n  serial_object->tx_tail = masked_tx_tail;\n  if (serial_object->tx_head != serial_object->tx_tail) {\n    return 0;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800420c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_next_tx_tail_0800420c"
        },
        "FUN_080005e4": {
            "renaming": {
                "FUN_080005e4": "execute_afl_call_if_no_hypercall_080005e4",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_080005fc": "PTR_noHyperCall_080005fc",
                "aflCall": "aflCall"
            },
            "code": "int execute_afl_call_if_no_hypercall_080005e4(int ticks)\n{\n  uint32_t result;\n  if (*(int *)PTR_noHyperCall_080005fc != 0) {\n    return 0;\n  }\n  result = aflCall(1, ticks, 0);\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e4",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "execute_afl_call_if_no_hypercall_080005e4"
        },
        "FUN_0800076c": {
            "renaming": {
                "FUN_0800076c": "modbus_send_response_0800076c",
                "this": "modbus_instance",
                "u8length": "buffer_length",
                "uVar1": "crc_value",
                "iVar2": "print_result",
                "uVar3": "millis_value",
                "uVar4": "buffer_index",
                "u8txenpin": "tx_enable_pin",
                "u8serno": "serial_number",
                "u8BufferSize": "buffer_size",
                "au8Buffer": "buffer",
                "u32timeOut": "timeout",
                "u16timeOut": "timeout_value",
                "u16OutCnt": "outgoing_message_count"
            },
            "code": "void __thiscall modbus_send_response_0800076c(Modbus *modbus_instance) {\n  byte buffer_length;\n  uint16_t crc_value;\n  int print_result;\n  uint buffer_index;\n  \n  buffer_length = modbus_instance->buffer_size;\n  crc_value = calc_crc(modbus_instance, buffer_length);\n  modbus_instance->buffer[buffer_length] = (uint8_t)(crc_value >> 8);\n  buffer_index = (buffer_length + 1) & 0xFF;\n  modbus_instance->buffer[buffer_index] = (uint8_t)crc_value;\n  modbus_instance->buffer_size = (char)buffer_index + 1;\n  if (modbus_instance->tx_enable_pin > 1) {\n    digitalWrite((uint)modbus_instance->tx_enable_pin, 1);\n  }\n  if (modbus_instance->serial_number < 4) {\n    print_result = (*(modbus_instance->port->super_stream.super_print._vptr_print[1]))(modbus_instance->port, modbus_instance->buffer, (uint)modbus_instance->buffer_size);\n  }\n  if (modbus_instance->tx_enable_pin > 1) {\n    digitalWrite((uint)modbus_instance->tx_enable_pin, 0);\n  }\n  if (modbus_instance->serial_number < 4) {\n    do {\n      print_result = (*(modbus_instance->port->super_stream.super_print._vptr_print[3]))();\n    } while (-1 < print_result);\n  }\n  modbus_instance->buffer_size = 0;\n  modbus_instance->timeout = millis() + modbus_instance->timeout_value;\n  modbus_instance->outgoing_message_count = modbus_instance->outgoing_message_count + 1;\n  return;\n}",
            "called": [
                "digitalWrite",
                "millis",
                "calcCRC"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800076c",
            "calling": [
                "process_FC5",
                "process_FC3",
                "process_FC1",
                "process_FC6",
                "poll",
                "process_FC15",
                "process_FC16"
            ],
            "imported": false,
            "current_name": "modbus_send_response_0800076c"
        },
        "FUN_080015b6": {
            "renaming": {
                "FUN_080015b6": "do_nothing_080015b6"
            },
            "code": "\nvoid do_nothing_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b6",
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_080015b6"
        },
        "FUN_08004460": {
            "renaming": {
                "FUN_08004460": "set_tx_pin_08004460",
                "_tx": "pin_number",
                "PVar1": "tx_pin",
                "PTR_digitalPin_08004478": "digitalPinToPinName_08004478"
            },
            "code": "void __thiscall set_tx_pin_08004460(HardwareSerial *this, uint32_t pin_number)\n{\n  PinName tx_pin;\n  if (pin_number < 0x60) {\n    tx_pin = *(PinName *)(PTR_digitalPin_08004478 + pin_number * 2);\n  }\n  else {\n    tx_pin = NC;\n  }\n  (this->_serial).pin_tx = tx_pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004460",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_tx_pin_08004460"
        },
        "FUN_080015b8": {
            "renaming": {
                "FUN_080015b8": "do_nothing_080015b8"
            },
            "code": "\nvoid do_nothing_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015b8",
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_080015b8"
        },
        "FUN_08001198": {
            "renaming": {
                "FUN_08001198": "set_gpio_pin_state_08001198",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "gpio_pin",
                "PinState": "pin_state",
                "BSRR": "bit_set_reset_register",
                "GPIO_PIN_RESET": "GPIO_PIN_RESET"
            },
            "code": "void set_gpio_pin_state_08001198(GPIO_TypeDef *gpio_port, uint16_t gpio_pin, GPIO_PinState pin_state) {\n  if (pin_state == GPIO_PIN_RESET) {\n    gpio_port->BSRR = (uint32_t)gpio_pin << 16;\n    return;\n  }\n  gpio_port->BSRR = (uint32_t)gpio_pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001198",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_08001198"
        },
        "FUN_080044fc": {
            "renaming": {
                "FUN_080044fc": "initialize_static_data_and_destructors_080044fc"
            },
            "code": "void initialize_static_data_and_destructors_080044fc(void)\n{\n  __static_initialization_and_destruction_0(1, 0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044fc",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_and_destructors_080044fc"
        },
        "FUN_08003138": {
            "renaming": {
                "FUN_08003138": "is_pin_high_08003138",
                "pin": "pin_name",
                "map": "pin_map"
            },
            "code": "_Bool is_pin_high_08003138(PinName_conflict pin, uint32_t *map) {\n    uint32_t shifted_pin = (uint32_t) pin << 24;\n    uint32_t index = shifted_pin >> 28;\n    uint32_t mask = 1 << (pin & 0xF);\n    uint32_t value = map[index] >> (pin & 0xF);\n    return (_Bool)(value & mask);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003138",
            "calling": [
                "digitalWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "is_pin_high_08003138"
        },
        "FUN_08000300": {
            "renaming": {
                "FUN_08000300": "FUNC_08000300"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong FUNC_08000300(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  ulonglong uVar1;\n  uint *puVar2;\n  uint uVar3;\n  uint *puVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar12 = count_leading_zeroes(param_3);\n      if (uVar12 != 0) {\n        param_3 = param_3 << (uVar12 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar12 & 0xff) | param_2 << (uVar12 & 0xff);\n        param_1 = param_1 << (uVar12 & 0xff);\n      }\n      uVar10 = param_3 >> 0x10;\n      uVar8 = param_2 / uVar10;\n      uVar7 = param_1 >> 0x10 | (param_2 - uVar10 * uVar8) * 0x10000;\n      uVar6 = uVar8 * (param_3 & 0xffff);\n      uVar5 = uVar8;\n      if (uVar7 <= uVar6 && uVar6 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,param_3);\n        uVar7 = uVar7 + param_3;\n        uVar5 = uVar8 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar6 && uVar6 - uVar7 != 0)) {\n          uVar5 = uVar8 - 2;\n          uVar7 = uVar7 + param_3;\n        }\n      }\n      uVar8 = (uVar7 - uVar6) / uVar10;\n      uVar7 = param_1 & 0xffff | ((uVar7 - uVar6) - uVar10 * uVar8) * 0x10000;\n      uVar10 = uVar8 * (param_3 & 0xffff);\n      uVar6 = uVar8;\n      if (uVar7 <= uVar10 && uVar10 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,param_3);\n        uVar7 = uVar7 + param_3;\n        uVar6 = uVar8 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar10 && uVar10 - uVar7 != 0)) {\n          uVar6 = uVar8 - 2;\n          uVar7 = uVar7 + param_3;\n        }\n      }\n      uVar7 = uVar7 - uVar10;\n      puVar2 = (uint *)(uVar6 | uVar5 << 0x10);\n      puVar4 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n        param_3 = 1 / 0;\n      }\n      uVar12 = count_leading_zeroes(param_3);\n      if (uVar12 == 0) {\n        param_2 = param_2 - param_3;\n        uVar7 = param_3 >> 0x10;\n        uVar11 = param_3 & 0xffff;\n        puVar4 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar12 & 0xff);\n        uVar7 = param_3 >> 0x10;\n        uVar5 = param_2 >> (0x20 - uVar12 & 0xff);\n        uVar9 = param_1 >> (0x20 - uVar12 & 0xff) | param_2 << (uVar12 & 0xff);\n        uVar6 = uVar5 / uVar7;\n        uVar11 = param_3 & 0xffff;\n        uVar10 = uVar9 >> 0x10 | (uVar5 - uVar7 * uVar6) * 0x10000;\n        uVar8 = uVar6 * uVar11;\n        param_1 = param_1 << (uVar12 & 0xff);\n        uVar5 = uVar6;\n        if (uVar10 <= uVar8 && uVar8 - uVar10 != 0) {\n          bVar13 = CARRY4(uVar10,param_3);\n          uVar10 = uVar10 + param_3;\n          uVar5 = uVar6 - 1;\n          if ((bVar13 == false) && (uVar10 <= uVar8 && uVar8 - uVar10 != 0)) {\n            uVar5 = uVar6 - 2;\n            uVar10 = uVar10 + param_3;\n          }\n        }\n        uVar3 = (uVar10 - uVar8) / uVar7;\n        param_2 = uVar9 & 0xffff | ((uVar10 - uVar8) - uVar7 * uVar3) * 0x10000;\n        uVar8 = uVar3 * uVar11;\n        uVar6 = uVar3;\n        if (param_2 <= uVar8 && uVar8 - param_2 != 0) {\n          bVar13 = CARRY4(param_2,param_3);\n          param_2 = param_2 + param_3;\n          uVar6 = uVar3 - 1;\n          if ((bVar13 == false) && (param_2 <= uVar8 && uVar8 - param_2 != 0)) {\n            uVar6 = uVar3 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar8;\n        puVar4 = (uint *)(uVar6 | uVar5 << 0x10);\n      }\n      uVar10 = param_2 / uVar7;\n      uVar8 = param_1 >> 0x10 | (param_2 - uVar7 * uVar10) * 0x10000;\n      uVar6 = uVar11 * uVar10;\n      uVar5 = uVar10;\n      if (uVar8 <= uVar6 && uVar6 - uVar8 != 0) {\n        bVar13 = CARRY4(uVar8,param_3);\n        uVar8 = uVar8 + param_3;\n        uVar5 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar8 <= uVar6 && uVar6 - uVar8 != 0)) {\n          uVar5 = uVar10 - 2;\n          uVar8 = uVar8 + param_3;\n        }\n      }\n      uVar10 = (uVar8 - uVar6) / uVar7;\n      uVar7 = param_1 & 0xffff | ((uVar8 - uVar6) - uVar7 * uVar10) * 0x10000;\n      uVar11 = uVar11 * uVar10;\n      uVar6 = uVar10;\n      if (uVar7 <= uVar11 && uVar11 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,param_3);\n        uVar7 = uVar7 + param_3;\n        uVar6 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar11 && uVar11 - uVar7 != 0)) {\n          uVar6 = uVar10 - 2;\n          uVar7 = uVar7 + param_3;\n        }\n      }\n      uVar7 = uVar7 - uVar11;\n      puVar2 = (uint *)(uVar6 | uVar5 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar7 >> (uVar12 & 0xff);\n      param_5[1] = 0;\n      return CONCAT44(puVar4,puVar2);\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar4 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar4 = (uint *)count_leading_zeroes(param_4);\n    if (puVar4 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar4;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar4 & 0xff);\n      uVar9 = uVar5 >> 0x10;\n      uVar12 = param_2 >> (uVar8 & 0xff);\n      uVar11 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar4 & 0xff);\n      uVar10 = uVar12 / uVar9;\n      uVar7 = uVar11 >> 0x10 | (uVar12 - uVar9 * uVar10) * 0x10000;\n      uVar6 = uVar10 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar4 & 0xff);\n      param_1 = param_1 << ((uint)puVar4 & 0xff);\n      uVar12 = uVar10;\n      if (uVar7 <= uVar6 && uVar6 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,uVar5);\n        uVar7 = uVar7 + uVar5;\n        uVar12 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar6 && uVar6 - uVar7 != 0)) {\n          uVar12 = uVar10 - 2;\n          uVar7 = uVar7 + uVar5;\n        }\n      }\n      uVar10 = (uVar7 - uVar6) / uVar9;\n      uVar7 = uVar11 & 0xffff | ((uVar7 - uVar6) - uVar9 * uVar10) * 0x10000;\n      uVar9 = uVar10 * (uVar5 & 0xffff);\n      uVar6 = uVar10;\n      if (uVar7 <= uVar9 && uVar9 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,uVar5);\n        uVar7 = uVar7 + uVar5;\n        uVar6 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar9 && uVar9 - uVar7 != 0)) {\n          uVar6 = uVar10 - 2;\n          uVar7 = uVar7 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar12 << 0x10;\n      uVar1 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar7 - uVar9,param_1) < uVar1) {\n        uVar1 = uVar1 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar12 = ((uVar7 - uVar9) - (int)(uVar1 >> 0x20)) - (uint)(param_1 < (uint)uVar1);\n        *param_5 = uVar12 << (uVar8 & 0xff) | param_1 - (uint)uVar1 >> ((uint)puVar4 & 0xff);\n        param_5[1] = uVar12 >> ((uint)puVar4 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar4, param_3 <= param_1)) {\n      bVar13 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar13;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return ZEXT48(puVar2);\n    }\n  }\n  return CONCAT44(puVar4,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000300",
            "calling": [
                "__aeabi_uldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_08000300"
        },
        "FUN_080005dc": {
            "renaming": {
                "FUN_080005dc": "do_nothing_080005dc"
            },
            "code": "\nvoid do_nothing_080005dc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005dc",
            "calling": [
                "__aeabi_uldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_080005dc"
        },
        "FUN_08003810": {
            "renaming": {
                "FUN_08003810": "handle_timers_08003810",
                "PTR_timer_handles_08003828": "PTR_timer_handles_08003828",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "HAL_TIM_IRQHandler": "HAL_TIM_IRQHandler",
                "first_timer_handle": "first_timer_handle",
                "second_timer_handle": "second_timer_handle"
            },
            "code": "void handle_timers_08003810(void)\n{\n  TIM_HandleTypeDef *first_timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003828 + 0x1c);\n  TIM_HandleTypeDef *second_timer_handle = *(TIM_HandleTypeDef **)(PTR_timer_handles_08003828 + 0x30);\n  if (first_timer_handle != NULL) {\n    HAL_TIM_IRQHandler(first_timer_handle);\n  }\n  if (second_timer_handle != NULL) {\n    HAL_TIM_IRQHandler(second_timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003810",
            "calling": [],
            "imported": false,
            "current_name": "handle_timers_08003810"
        },
        "FUN_08002848": {
            "renaming": {
                "FUN_08002848": "set_channel_state_of_timer_08002848",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channel_state",
                "CCER": "channel_control_register"
            },
            "code": "void set_channel_state_of_timer_08002848(TIM_TypeDef *timer, uint32_t channel, uint32_t channel_state) {\n  uint32_t channel_mask = 1 << (channel & 0xff);\n  timer->CCER &= ~channel_mask;\n  timer->CCER |= channel_state << (channel & 0xff);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002848",
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "imported": false,
            "current_name": "set_channel_state_of_timer_08002848"
        },
        "FUN_08003938": {
            "renaming": {
                "FUN_08003938": "handle_i2c_event_08003938",
                "PTR_i2c_handles_08003944": "PTR_i2c_handles",
                "i2c_handle_ptr": "i2c_handle"
            },
            "code": "void handle_i2c_event_08003938(void)\n{\n  I2C_HandleTypeDef* i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003944_08003944 + 4);\n  HAL_I2C_EV_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003938",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_08003938"
        },
        "FUN_0800312c": {
            "renaming": {
                "FUN_0800312c": "get_uart_rx_and_general_state_0800312c",
                "huart": "uart_handle",
                "RxState": "rx_state",
                "gState": "general_state"
            },
            "code": "HAL_UART_StateTypeDef get_uart_rx_and_general_state_0800312c(UART_HandleTypeDef *huart)\n{\n  HAL_UART_StateTypeDef rx_state = huart->RxState;\n  HAL_UART_StateTypeDef general_state = huart->gState;\n  return rx_state | general_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800312c",
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "imported": false,
            "current_name": "get_uart_rx_and_general_state_0800312c"
        },
        "FUN_080028f0": {
            "renaming": {
                "FUN_080028f0": "set_timer_channel_080028f0",
                "*htim": "*timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance",
                "HAL_StatusTypeDef": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef set_timer_channel_080028f0(TIM_HandleTypeDef *timer_handle, uint32_t channel) {\n  TIM_TypeDef *timer_instance = timer_handle->Instance;\n  TIM_CCxNChannelCmd(timer_instance, channel, 0);\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028f0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "set_timer_channel_080028f0"
        },
        "FUN_08000e30": {
            "renaming": {
                "FUN_08000e30": "get_uw_tick_value_08000e30",
                "PTR_uwTick_08000e38": "uw_tick_ptr"
            },
            "code": "uint32_t get_uw_tick_value_08000e30(void)\n{\n  uint32_t* PTR_uwTick_08000e38 = (uint32_t*)PTR_uwTick_08000e38;\n  return *PTR_uwTick_08000e38;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e30",
            "calling": [
                "GetCurrentMilli",
                "HAL_UART_Transmit",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "get_uw_tick_value_08000e30"
        },
        "FUN_08000f56": {
            "renaming": {
                "FUN_08000f56": "reset_dac_state_08000f56",
                "*hdac": "*dac_handle",
                "hdac": "dac_handle",
                "HAL_DAC_StateTypeDef": "HAL_StatusTypeDef",
                "HAL_DAC_MspDeInit": "HAL_DAC_MspDeInit",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef reset_dac_state_08000f56(DAC_HandleTypeDef *dac_handle)\n{\n  if (dac_handle != NULL) {\n    dac_handle->State = HAL_DAC_STATE_BUSY;\n    HAL_DAC_MspDeInit(dac_handle);\n    dac_handle->ErrorCode = 0;\n    dac_handle->State = HAL_DAC_STATE_RESET;\n    dac_handle->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f56",
            "calling": [
                "dac_stop"
            ],
            "imported": false,
            "current_name": "reset_dac_state_08000f56"
        },
        "FUN_0800295c": {
            "renaming": {
                "FUN_0800295c": "transmit_data_0800295c",
                "*huart": "*uart",
                "uVar1": "data_length",
                "pbVar2": "data_pointer",
                "huart->gState": "uart->gState",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "huart->Init": "uart->Init",
                "WordLength": "WordLength",
                "0x1000": "0x1000",
                "huart->Instance->DR": "uart->Instance->DR",
                "*(ushort *)huart->pTxBuffPtr & 0x1ff": "*(ushort *)uart->pTxBuffPtr & 0x1ff",
                "huart->pTxBuffPtr": "uart->pTxBuffPtr",
                "(huart->Init).Parity": "(uart->Init).Parity",
                "huart->pTxBuffPtr + 2": "uart->pTxBuffPtr + 2",
                "huart->pTxBuffPtr + 1": "uart->pTxBuffPtr++",
                "(uint)*pbVar2": "(uint)*data_pointer",
                "huart->TxXferCount": "uart->TxXferCount",
                "huart->Instance->CR1": "uart->Instance->CR1",
                "0xffffff7f": "0xffffff7f",
                "0x40": "0x40",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef transmit_data_0800295c(UART_HandleTypeDef *uart)\n{\n    uint16_t data_length;\n    byte *data_pointer;\n\n    if (uart->gState != HAL_UART_STATE_BUSY_TX) {\n        return HAL_BUSY;\n    }\n\n    if ((uart->Init).WordLength == 0x1000) {\n        uart->Instance->DR = *(ushort *)uart->pTxBuffPtr & 0x1ff;\n        if ((uart->Init).Parity == 0) {\n            uart->pTxBuffPtr += 2;\n        }\n        else {\n            uart->pTxBuffPtr++;\n        }\n    }\n    else {\n        data_pointer = uart->pTxBuffPtr;\n        uart->pTxBuffPtr++;\n        uart->Instance->DR = (uint)*data_pointer;\n    }\n\n    data_length = uart->TxXferCount - 1;\n    uart->TxXferCount = data_length;\n\n    if (data_length == 0) {\n        uart->Instance->CR1 &= 0xffffff7f;\n        uart->Instance->CR1 |= 0x40;\n        return HAL_OK;\n    }\n\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800295c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "transmit_data_0800295c"
        },
        "FUN_08003380": {
            "renaming": {
                "FUN_08003380": "get_dac_pin_function_08003380",
                "pin": "dac_pin",
                "uVar1": "pin_function"
            },
            "code": "uint32_t get_dac_pin_function_08003380(PinName_conflict dac_pin)\n{\n  uint32_t pin_function = pinmap_function(dac_pin, (PinMap_conflict *)PTR_PinMap_DAC_08003398);\n  if ((pin_function << 0xc) >> 0x1b != 2) {\n    return 0;\n  }\n  return 0x10;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003380",
            "calling": [
                "dac_stop"
            ],
            "imported": false,
            "current_name": "get_dac_pin_function_08003380"
        },
        "FUN_08005686": {
            "renaming": {
                "FUN_08005686": "close_file_descriptor_08005686",
                "param_1": "file_descriptor_pointer",
                "param_2": "file_descriptor_offset"
            },
            "code": "void close_file_descriptor_08005686(void* file_descriptor_pointer, int file_descriptor_offset)\n{\n  _close_r(file_descriptor_pointer, (int)*(short *)(file_descriptor_offset + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005686",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_08005686"
        },
        "FUN_08004110": {
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_pin_found",
                "pin": "pin_name",
                "PTR_digitalPin_080041a8": "digital_pin_ptr",
                "NC": "NC",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_080041ac": "output_pin_configured_ptr",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_conflict": "PinMap_conflict",
                "PTR_PinMap_DAC_080041b0": "dac_pin_map_ptr",
                "dac_stop": "dac_stop",
                "PTR_PinMap_PWM_080041b4": "pwm_pin_map_ptr",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "switch": "switch",
                "digital_io_init": "digital_io_init",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_digPinConfigured_080041b8": "dig_pin_configured_ptr"
            },
            "code": "void configure_pin_08004110(uint32_t pin_number, uint32_t mode){\n  _Bool is_pin_found;\n  PinName_conflict pin_name;\n  if (pin_number < 0x60) {\n    pin_name = *(PinName_conflict *)(PTR_digitalPin_080041a8 + pin_number * 2);\n  }\n  else {\n    pin_name = NC;\n  }\n  if (pin_name != NC) {\n    is_pin_found = is_pin_configured(pin_name, PTR_g_anOutputPinConfigured_080041ac);\n    if (is_pin_found) {\n      if (pin_in_pinmap(pin_name, (PinMap_conflict *)PTR_PinMap_DAC_080041b0)) {\n        dac_stop(pin_name);\n      }\n      else if (pin_in_pinmap(pin_name, (PinMap_conflict *)PTR_PinMap_PWM_080041b4)) {\n        pwm_stop(pin_name);\n      }\n      reset_pin_configured(pin_name, PTR_g_anOutputPinConfigured_080041ac);\n    }\n    switch (mode) {\n    case 0:\n      digital_io_init(pin_name, 0, 0);\n      break;\n    case 1:\n      digital_io_init(pin_name, 1, 0);\n      break;\n    case 2:\n      digital_io_init(pin_name, 0, 1);\n      break;\n    case 3:\n      digital_io_init(pin_name, 0, 2);\n      break;\n    }\n    set_pin_configured(pin_name, PTR_g_digPinConfigured_080041b8);\n  }\n  return;\n}",
            "called": [
                "pin_in_pinmap",
                "digital_io_init",
                "set_pin_configured",
                "reset_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004110",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "configure_pin_08004110"
        },
        "FUN_08005320": {
            "renaming": {
                "FUN_08005320": "walk_file_system_and_free_resources_08005320",
                "param_1": "reentrancy_structure",
                "DAT_08005328": "global_free_function"
            },
            "code": "void walk_file_system_and_free_resources_08005320(void* reentrancy_structure) {\n  _fwalk_reent(reentrancy_structure, DAT_08005328);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005320",
            "calling": [],
            "imported": false,
            "current_name": "walk_file_system_and_free_resources_08005320"
        },
        "FUN_08000ee0": {
            "renaming": {
                "FUN_08000ee0": "calculate_ticks_remaining_08000ee0",
                "TicksNumb": "ticks_elapsed",
                "puVar1": "ticks_remaining_ptr",
                "DAT_08000f04": "ticks_remaining_ptr",
                "DAT_08000f08": "unknown_data_ptr"
            },
            "code": "uint32_t calculate_ticks_remaining_08000ee0(uint32_t ticks_elapsed)\n{\n  undefined4 *DAT_08000f04;\n  DAT_08000f04 = DAT_08000f04;\n  if (ticks_elapsed < 0x1000000)\n  {\n    DAT_08000f04[1] = ticks_elapsed - 1;\n    *(undefined *)(DAT_08000f08 + 0x23) = 0xf0;\n    DAT_08000f04[2] = 0;\n    *DAT_08000f04 = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ee0",
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "calculate_ticks_remaining_08000ee0"
        },
        "FUN_080015ba": {
            "renaming": {
                "FUN_080015ba": "do_nothing_080015ba"
            },
            "code": "\nvoid do_nothing_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015ba",
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "do_nothing_080015ba"
        },
        "FUN_08000f4c": {
            "renaming": {
                "FUN_08000f4c": "do_nothing_08000f4c"
            },
            "code": "\nvoid do_nothing_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f4c",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08000f4c"
        },
        "FUN_080015bc": {
            "renaming": {
                "FUN_080015bc": "i2c_transfer_080015bc",
                "hi2c": "handle",
                "HVar1": "state",
                "pbVar2": "buffer_ptr",
                "HAL_I2C_StateTypeDef": "HAL_I2C_State",
                "byte": "uint8_t",
                "HAL_StatusTypeDef": "HAL_Status"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_080015bc(I2C_HandleTypeDef *handle)\n{\n  HAL_I2C_StateTypeDef state;\n  byte *buffer_ptr;\n  \n  state = handle->State;\n  if (handle->XferCount != 0) {\n    buffer_ptr = handle->pBuffPtr;\n    handle->pBuffPtr = buffer_ptr + 1;\n    handle->Instance->DR = (uint)*buffer_ptr;\n    handle->XferCount--;\n    if ((handle->XferCount == 0) && (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      handle->Instance->CR2 &= 0xfffffbff;\n      handle->PreviousState = 0x21;\n      handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(handle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015bc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_080015bc"
        },
        "FUN_08000f4e": {
            "renaming": {
                "FUN_08000f4e": "tick_callback_08000f4e"
            },
            "code": "void tick_callback_08000f4e(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f4e",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "tick_callback_08000f4e"
        },
        "FUN_08003948": {
            "renaming": {
                "FUN_08003948": "handle_i2c_error_interrupt_08003948",
                "PTR_i2c_handles_08003954": "PTR_i2c_handles",
                "i2c_handle": "i2c_handle"
            },
            "code": "void handle_i2c_error_interrupt_08003948(void)\n{\n  I2C_HandleTypeDef* i2c_handle = *(I2C_HandleTypeDef**)(PTR_i2c_handles_08003954_08003954 + 4);\n  HAL_I2C_ER_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003948",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08003948"
        },
        "FUN_0800458c": {
            "renaming": {
                "FUN_0800458c": "initialize_static_variables_and_destructors_0800458c",
                "__static_initialization_and_destruction_0": "initialize_static_variables_and_destructors_0",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void initialize_static_variables_and_destructors_0800458c(void)\n{\n    __static_initialization_and_destruction_0(1, 0xFFFF);\n    return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800458c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_and_destructors_0800458c"
        },
        "FUN_0800066c": {
            "renaming": {
                "FUN_0800066c": "modbus_set_parameters_0800066c",
                "this": "modbus",
                "u8id": "device_id",
                "u8serno": "serial_number",
                "u8txenpin": "tx_enable_pin",
                "u16timeOut": "timeout"
            },
            "code": "void __thiscall modbus_set_parameters_0800066c(Modbus *modbus, uint8_t device_id, uint8_t serial_number, uint8_t tx_enable_pin)\n{\n  modbus->device_id = device_id;\n  if (serial_number > 3) {\n    serial_number = 0;\n  }\n  modbus->serial_number = serial_number;\n  modbus->tx_enable_pin = tx_enable_pin;\n  modbus->timeout = 1000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800066c",
            "calling": [
                "Modbus"
            ],
            "imported": false,
            "current_name": "modbus_set_parameters_0800066c"
        },
        "FUN_080042e8": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_080042e8": "write_byte",
                "*this": "serial",
                "c": "byte_to_write",
                "bVar1": "incremented_head",
                "uVar2": "is_tx_active",
                "bVar3": "new_head",
                "iVar4": "incremented_head",
                "uVar5": "tx_head",
                "DAT_08004334": "tx_callback",
                "PTR_080042f8": "serial_t",
                "PTR_DAT_0800432c": "uart_attach_tx_callback",
                "PTR_FUN_0800435c": "serial_tx_active",
                "PTR_FUN_0800436c": "HardwareSerial::write_byte",
                "FUN_080042e8": "PTR_0800436c_080042e8"
            },
            "code": "size_t __thiscall PTR_0800436c_080042e8(HardwareSerial *serial, uint8_t byte_to_write)\\n{\\n\\tbool is_written = true;\\n\\tuint tx_head = (uint)(serial->_serial).tx_head;\\n\\tint incremented_head = tx_head + 1;\\n\\tbyte new_head = (byte)incremented_head & 0x7f;\\n\\tif (incremented_head == 0) {\\n\\t\\tnew_head = -(-new_head & 0x7f);\\n\\t}\\n\\twhile ((serial->_serial).tx_tail == (ushort)new_head);\\n\\t(serial->_serial).tx_buff[tx_head] = byte_to_write;\\n\\t(serial->_serial).tx_head = (ushort)new_head;\\n\\tuint8_t is_tx_active = PTR_FUN_0800435c((PTR_080042f8 *)&serial->_serial);\\n\\tif (is_tx_active == \"\\0\") {\\n\\t\\tPTR_DAT_0800432c((PTR_080042f8 *)&serial->_serial, DAT_08004334);\\n\\t}\\n\\treturn 1;\\n}",
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e8",
            "calling": [],
            "imported": false,
            "current_name": "PTR_0800436c_080042e8"
        },
        "FUN_080038d0": {
            "renaming": {
                "FUN_080038d0": "i2c_slave_receive_handler_080038d0",
                "*hi2c": "*i2c_handle",
                "piVar1": "i2c_obj",
                "uVar2": "buffer_size",
                "i2c_onSlaveReceive": "i2c_on_slave_receive",
                "_func_void_uint8_t_ptr_int": "function_pointer",
                "slaveMode": "slave_mode",
                "handle": "i2c_handle",
                "XferSize": "transfer_size",
                "i2cTxRxBuffer": "i2c_tx_rx_buffer",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt"
            },
            "code": "void i2c_slave_receive_handler_080038d0(I2C_HandleTypeDef *i2c_handle) {\n  i2c_t *i2c_obj = get_i2c_obj(i2c_handle);\n  if (i2c_obj->i2c_on_slave_receive && i2c_obj->slave_mode == 1) {\n    uint8_t buffer_size = 0x20 - *(uint8_t *)&i2c_obj->handle.XferSize & 0xff;\n    if (buffer_size != 0) {\n      (*i2c_obj->i2c_on_slave_receive)(i2c_obj->i2c_tx_rx_buffer, buffer_size);\n    }\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}",
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038d0",
            "calling": [
                "I2C_ITError",
                "I2C_Slave_STOPF",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "i2c_slave_receive_handler_080038d0"
        },
        "FUN_0800410c": {
            "renaming": {
                "FUN_0800410c": "return_one_0800410c"
            },
            "code": "__pid_t return_one_0800410c(void)\n{\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800410c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "return_one_0800410c"
        },
        "FUN_0800260c": {
            "renaming": {
                "FUN_0800260c": "calculate_HCLK_frequency_0800260c",
                "DAT_08002624": "data_08002624",
                "PTR_APBPrescTable_08002628": "apb_prescaler_table"
            },
            "code": "uint32_t calculate_HCLK_frequency_0800260c(void)\n{\n  uint32_t hclk_freq = HAL_RCC_GetHCLKFreq();\n  uint32_t apb_prescaler_index = (uint)(*(int *)(DAT_08002624 + 8) << 0x10) >> 0x1d;\n  uint32_t apb_prescaler_value = PTR_APBPrescTable_08002628[apb_prescaler_index];\n  return hclk_freq >> apb_prescaler_value;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800260c",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "calculate_HCLK_frequency_0800260c"
        },
        "FUN_08004240": {
            "renaming": {
                "FUN_08004240": "calculate_available_data_in_rx_buffer_08004240",
                "this": "serial_instance",
                "_serial": "serial_data",
                "rx_head": "head_ptr",
                "rx_tail": "tail_ptr",
                "available_data": "available_data_count"
            },
            "code": "int __thiscall calculate_available_data_in_rx_buffer_08004240(HardwareSerial *serial_instance)\n{\n    uint32_t rx_head = serial_instance->_serial.rx_head;\n    uint32_t rx_tail = serial_instance->_serial.rx_tail;\n    uint32_t available_data = (rx_head + 0x40) - rx_tail & 0x3f;\n    return available_data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004240",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "calculate_available_data_in_rx_buffer_08004240"
        },
        "FUN_080026c8": {
            "renaming": {
                "FUN_080026c8": "do_nothing_080026c8"
            },
            "code": "\nvoid do_nothing_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026c8",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080026c8"
        },
        "FUN_08005690": {
            "renaming": {
                "FUN_08005690": "write_to_file_08005690",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "bytes_written"
            },
            "code": "void write_to_file_08005690(int* error_code, int file_descriptor, char* buffer, int buffer_size) {\n    undefined* errno_ptr = PTR_errno_080056b0;\n    *(undefined4*)errno_ptr = 0;\n    int bytes_written = _write(file_descriptor, buffer, buffer_size);\n    if ((bytes_written == -1) && (*(int*)errno_ptr != 0)) {\n        *error_code = *(int*)errno_ptr;\n    }\n    return;\n}",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005690",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_08005690"
        },
        "FUN_080041bc": {
            "renaming": {
                "FUN_080041bc": "digital_pin_write_080041bc",
                "ulPin": "pin",
                "ulVal": "value",
                "_Var1": "is_pin_configured_result",
                "port": "port",
                "uVar2": "pin_index"
            },
            "code": "void digital_pin_write_080041bc(uint32_t pin, uint32_t value)\n{\n    bool is_pin_configured_result;\n    GPIO_TypeDef* port;\n    uint32_t pin_index;\n\n    if (pin < 0x60) {\n        pin_index = (uint32_t)*(short *)(PTR_digitalPin_080041fc + pin * 2);\n    }\n    else {\n        pin_index = 0xffffffff;\n    }\n    if ((pin_index != 0xffffffff) && (is_pin_configured_result = is_pin_configured((PinName_conflict)pin_index, (uint32_t*)PTR_g_digPinConfigured_08004200), is_pin_configured_result)) {\n        port = get_GPIO_Port((pin_index << 0x18) >> 0x1c);\n        digital_io_write(port, 1 << (pin_index & 0xf) & 0xffff, value);\n    }\n    return;\n}",
            "called": [
                "get_GPIO_Port",
                "digital_io_write",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041bc",
            "calling": [
                "getRxBuffer",
                "sendTxBuffer",
                "begin"
            ],
            "imported": false,
            "current_name": "digital_pin_write_080041bc"
        },
        "FUN_08004364": {
            "renaming": {
                "FUN_08004364": "initialize_serial_08004364",
                "this": "serial_instance",
                "ctx": "ctx",
                "_serial": "serial_instance",
                "rx_buff": "rx_buffer",
                "_rx_buffer": "_rx_buffer",
                "rx_head": "rx_head",
                "rx_tail": "rx_tail",
                "tx_buff": "tx_buffer",
                "_tx_buffer": "_tx_buffer",
                "tx_head": "tx_head",
                "tx_tail": "tx_tail"
            },
            "code": "int __thiscall initialize_serial_08004364(HardwareSerial *serial_instance, EVP_PKEY_CTX *ctx) {\n    serial_instance->rx_buffer = serial_instance->_rx_buffer;\n    serial_instance->rx_head = 0;\n    serial_instance->rx_tail = 0;\n    serial_instance->tx_buffer = serial_instance->_tx_buffer;\n    serial_instance->tx_head = 0;\n    serial_instance->tx_tail = 0;\n    return (int)serial_instance;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004364",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initialize_serial_08004364"
        },
        "FUN_08000682": {
            "renaming": {
                "FUN_08000682::FUN_08000682": "initialize",
                "this": "this_ptr",
                "u8id": "device_id",
                "u8serno": "serial_number",
                "u8txenpin": "tx_enable_pin",
                "PTR_": "PTR_",
                "DAT_": "DAT_",
                "FUN_08000682": "initialize_08000682"
            },
            "code": "initialize_08000682* __thiscall initialize_08000682(initialize_08000682* this_ptr, uint8_t device_id, uint8_t serial_number, uint8_t tx_enable_pin)\n{\n  init(this_ptr, device_id, serial_number, tx_enable_pin);\n  return this_ptr;\n}",
            "called": [
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000682",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_08000682"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "handle_usart3_interrupt_08004004",
                "PTR_uart_handlers_08004018": "PTR_uart_handlers",
                "USART3_IRQn": "USART3_Interrupt",
                "UART_HandleTypeDef": "UART_Handler",
                "uart_handler": "current_uart_handler"
            },
            "code": "void handle_usart3_interrupt_08004004(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_08004018_08004018 + 8);\n  if (uart_handler != NULL) {\n    HAL_UART_IRQHandler(uart_handler);\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [],
            "imported": false,
            "current_name": "handle_usart3_interrupt_08004004"
        },
        "FUN_08000e3c": {
            "renaming": {
                "FUN_08000e3c": "set_priority_group_08000e3c",
                "PriorityGroup": "priority_group",
                "PTR_08000e5c": "ptr_dat_08000e5c",
                "DAT_08000e5c": "DAT_08000e5c",
                "*(uint32_t *)(DAT_08000e5c + 0xc)": "*(ptr_dat_08000e5c + 0xc)",
                "*(uint *)(DAT_08000e5c + 0xc)": "current_priority",
                "(PriorityGroup & 7) << 8": "new_priority",
                "0xf8ff": "mask",
                "0x5fa0000": "constant"
            },
            "code": "void set_priority_group_08000e3c(uint32_t priority_group) {\n    uint32_t* PTR_08000e5c = (uint32_t*)DAT_08000e5c;\n    uint32_t *(uint *)(DAT_08000e5c + 0xc) = *(uint32_t *)(DAT_08000e5c + 0xc);\n    uint32_t new_priority = (priority_group & 7) << 8;\n    new_priority |= *(uint *)(DAT_08000e5c + 0xc) & 0xf8ff;\n    new_priority |= 0x5fa0000;\n    *(uint32_t *)(DAT_08000e5c + 0xc) = new_priority;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e3c",
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "set_priority_group_08000e3c"
        },
        "FUN_080037ac": {
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "PTR_timer_handles_080037bc": "PTR_timer_handles",
                "TIM_HandleTypeDef": "timer_handle"
            },
            "code": "void handle_timer_interrupt_080037ac(void)\n{\n    TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_080037bc_080037bc + 8);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037ac",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037ac"
        },
        "FUN_08002864": {
            "renaming": {
                "FUN_08002864": "halt_tim_channel_command_08002864",
                "htim": "tim_handle",
                "Channel": "channel",
                "bVar1": "is_valid_instance",
                "pTVar2": "tim_instance"
            },
            "code": "HAL_StatusTypeDef halt_tim_channel_command_08002864(TIM_HandleTypeDef *htim, uint32_t channel)\n{\n  bool is_valid_instance = false;\n  TIM_TypeDef *tim_instance = htim->Instance;\n  if (tim_instance == PTR_DAT_080028d0 || tim_instance == (TIM_TypeDef *)&DAT_080028d0[0xc].SR) {\n    is_valid_instance = true;\n  }\n  bool is_ccer_zero = (tim_instance->CCER & 0x1555) == 0;\n  bool is_ccer_444_zero = (tim_instance->CCER & 0x444) == 0;\n  if (is_valid_instance && is_ccer_zero && is_ccer_444_zero) {\n    tim_instance->BDTR &= 0xffff7fff;\n  }\n  if (is_ccer_zero && is_ccer_444_zero) {\n    tim_instance->CR1 &= 0xfffffffe;\n  }\n  htim->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002864",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "halt_tim_channel_command_08002864"
        },
        "FUN_0800459a": {
            "renaming": {
                "__thiscall Print::FUN_0800459a": "print_buffer",
                "this": "self",
                "pPVar1": "print_obj",
                "sVar2": "bytes_printed",
                "*buffer": "*buffer",
                "size": "size",
                "FUN_0800459a": "print_buffer_0800459a"
            },
            "code": "size_t __thiscall print_buffer_0800459a(Print* self, uint8_t* buffer, size_t size) {\n    Print* print_obj = self;\n    size_t bytes_printed = 0;\n\n    while (size != 0) {\n        print_obj = (Print*)(**self->_vptr_Print)(print_obj, (uint)*buffer);\n        if (print_obj == (Print*)0x0) break;\n        bytes_printed++;\n        buffer++;\n        size--;\n    }\n    return bytes_printed;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459a",
            "calling": [],
            "imported": false,
            "current_name": "print_buffer_0800459a"
        },
        "FUN_08003958": {
            "renaming": {
                "FUN_08003958": "handle_i2c_event_08003958",
                "PTR_i2c_handles_08003964": "PTR_i2c_handles",
                "i2c_handle_ptr": "i2c_handle"
            },
            "code": "void handle_i2c_event_08003958(void)\n{\n  I2C_HandleTypeDef *i2c_handle_ptr = *(I2C_HandleTypeDef **)(PTR_i2c_handles_08003964_08003964 + 8);\n  HAL_I2C_EV_IRQHandler(i2c_handle_ptr);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003958",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_08003958"
        },
        "FUN_0800532c": {
            "renaming": {
                "std_isra_0": "initialize_data_structure",
                "*param_1": "*data_structure",
                "param_2": "initial_value_1",
                "param_3": "initial_value_2",
                "DAT_08005364": "initial_value_3",
                "DAT_08005368": "initial_value_4",
                "DAT_0800536c": "initial_value_5",
                "DAT_08005370": "initial_value_6",
                "FUN_0800532c": "initialize_data_structure_0800532c"
            },
            "code": "void initialize_data_structure_0800532c(undefined4 *data_structure, undefined2 initial_value_1, undefined2 initial_value_2) {\n  *data_structure = 0;\n  data_structure[1] = 0;\n  data_structure[2] = 0;\n  *(undefined2 *)(data_structure + 3) = initial_value_1;\n  data_structure[0x19] = 0;\n  *(undefined2 *)((int)data_structure + 0xe) = initial_value_2;\n  data_structure[4] = 0;\n  data_structure[5] = 0;\n  data_structure[6] = 0;\n  memset(data_structure + 0x17, 0, 8);\n  data_structure[9] = DAT_08005364;\n  data_structure[10] = DAT_08005368;\n  data_structure[0xb] = DAT_0800536c;\n  undefined4 uVar1 = DAT_08005370;\n  data_structure[8] = data_structure;\n  data_structure[0xc] = uVar1;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800532c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_0800532c"
        },
        "FUN_0800314e": {
            "renaming": {
                "FUN_0800314e": "set_pin_high_0800314e",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_high_0800314e(PinName_conflict pin, uint32_t *pin_map) {\n  uint32_t pin_index = (uint32_t)pin >> 28;\n  pin_map[pin_index] |= 1 << ((uint32_t)pin & 0x0F);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_high_0800314e"
        },
        "FUN_0800447c": {
            "renaming": {
                "FUN_0800447c::FUN_0800447c": "initialize_serial",
                "this": "serial_obj",
                "peripheral": "peripheral",
                "PVar1": "rx_pin",
                "extraout_r1": "ctx_1",
                "extraout_r1_00": "ctx_2",
                "PTR_Serial3_080044cc": "PTR_Serial3_080044cc",
                "PTR_PinMap_UART_RX_080044d0": "PTR_PinMap_UART_RX_080044d0",
                "PTR_PinMap_UART_TX_080044d4": "PTR_PinMap_UART_TX_080044d4",
                "FUN_0800447c": "initialize_serial_0800447c"
            },
            "code": "initialize_serial_0800447c * __thiscall initialize_serial_0800447c(initialize_serial_0800447c *serial_obj, void *peripheral) {\n  PinName_conflict rx_pin;\n  EVP_PKEY_CTX *ctx_1;\n  EVP_PKEY_CTX *ctx_2;\n  \n  (serial_obj->super_Stream).super_Print.write_error = 0;\n  (serial_obj->super_Stream)._timeout = 1000;\n  (serial_obj->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_080044c8;\n  if (serial_obj == (initialize_serial_0800447c *)PTR_Serial3_080044cc) {\n    setRx(serial_obj, 0x4c);\n    setTx(serial_obj, 0x4d);\n    ctx_1 = extraout_r1_00;\n  }\n  else {\n    rx_pin = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_RX_080044d0);\n    (serial_obj->_serial).pin_rx = rx_pin;\n    PinName_conflict tx_pin = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_TX_080044d4);\n    (serial_obj->_serial).pin_tx = tx_pin;\n    ctx_1 = extraout_r1;\n  }\n  init(serial_obj, ctx_2);\n  return serial_obj;\n}",
            "called": [
                "pinmap_pin",
                "setRx",
                "setTx",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800447c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_serial_0800447c"
        },
        "FUN_08004808": {
            "renaming": {
                "FUN_08004808": "print_assertion_failed_message_08004808",
                "param_1": "line_number",
                "param_2": "column_number",
                "param_3": "expression",
                "param_4": "error_code",
                "puVar1": "expression_ptr",
                "puVar2": "message_ptr"
            },
            "code": "void print_assertion_failed_message_08004808(undefined4 line_number, undefined4 column_number, undefined *expression, undefined4 error_code)\n{\n  undefined *expression_ptr;\n  undefined *message_ptr;\n  \n  expression_ptr = PTR_s__08004840;\n  message_ptr = PTR_s__08004840;\n  if (expression != (undefined *)0x0) {\n    expression_ptr = expression;\n    message_ptr = PTR_s___function__08004838;\n  }\n  fiprintf(*(FILE **)(*(int *)PTR__impure_ptr_08004834 + 0xc),\n           PTR_s_assertion___s__failed__file___s__0800483c,error_code,line_number,column_number,message_ptr,expression_ptr,\n           error_code);\n  abort();\n}",
            "called": [
                "abort",
                "fiprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004808",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_message_08004808"
        },
        "FUN_08000f72": {
            "renaming": {
                "FUN_08000f72": "set_dac_channel_state_08000f72",
                "hdac": "dac_handle",
                "Channel": "channel",
                "CR": "control_register",
                "State": "dac_state",
                "HAL_DAC_STATE_READY": "ready_state"
            },
            "code": "HAL_StatusTypeDef set_dac_channel_state_08000f72(DAC_HandleTypeDef *dac_handle, uint32_t channel) {\n  uint32_t channel_mask = ~(1 << (channel & 0xff));\n  dac_handle->Instance->CR = dac_handle->Instance->CR & channel_mask;\n  dac_handle->State = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f72",
            "calling": [
                "dac_stop"
            ],
            "imported": false,
            "current_name": "set_dac_channel_state_08000f72"
        },
        "FUN_08001d00": {
            "renaming": {
                "FUN_08001d00": "i2c_handler_08001d00",
                "hi2c": "handler",
                "pIVar1": "instance",
                "uVar2": "SR1",
                "uVar3": "CR2",
                "uVar4": "SR2"
            },
            "code": "void i2c_handler_08001d00(I2C_HandleTypeDef *handler)\n{\n  I2C_TypeDef *instance;\n  uint SR1;\n  uint SR2;\n  uint CR2;\n  instance = handler->Instance;\n  SR2 = instance->SR2;\n  SR1 = instance->SR1;\n  CR2 = instance->CR2;\n  if ((handler->Mode == HAL_I2C_MODE_MASTER) || (handler->Mode == HAL_I2C_MODE_MEM)) {\n    if (((SR1 & 0x10001) == 0) || ((CR2 & 0x200) == 0)) {\n      if (((SR1 & 0x00000002) == 0) || ((CR2 & 0x200) == 0)) {\n        if (((SR1 & 0x00000040) != 0) && ((CR2 & 0x200) != 0)) {\n          I2C_Master_ADDR(handler);\n        }\n      }\n      else {\n        I2C_Master_ADD10(handler);\n      }\n    }\n    else {\n      I2C_Master_SB(handler);\n    }\n    if ((SR2 & 0x00000001) == 0) {\n      if ((((SR1 & 0x00000080) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x00000020) == 0)) {\n        I2C_MasterReceive_RXNE(handler);\n        return;\n      }\n      if (((SR1 & 0x00000020) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(handler);\n        return;\n      }\n    }\n    else {\n      if ((((SR1 & 0x00000040) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x00000020) == 0)) {\n        I2C_MasterTransmit_TXE(handler);\n        return;\n      }\n      if (((SR1 & 0x00000020) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(handler);\n        return;\n      }\n    }\n  }\n  else {\n    if (((SR1 & 0x00000040) != 0) && ((CR2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(handler);\n      return;\n    }\n    if (((SR1 & 0x00000010) != 0) && ((CR2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(handler);\n      return;\n    }\n    if ((SR2 & 0x00000001) == 0) {\n      if ((((SR1 & 0x00000080) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x00000020) == 0)) {\n        I2C_SlaveReceive_RXNE(handler);\n        return;\n      }\n      if (((SR1 & 0x00000020) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(handler);\n      }\n    }\n    else {\n      if ((((SR1 & 0x00000040) != 0) && ((CR2 & 0x400) != 0)) && ((SR1 & 0x00000020) == 0)) {\n        I2C_SlaveTransmit_TXE(handler);\n        return;\n      }\n      if (((SR1 & 0x00000020) != 0) && ((CR2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(handler);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_SlaveReceive_BTF",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveTransmit_BTF",
                "I2C_Slave_ADDR",
                "I2C_MasterReceive_RXNE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001d00",
            "calling": [
                "I2C3_EV_IRQHandler",
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handler_08001d00"
        },
        "FUN_080037c0": {
            "renaming": {
                "FUN_080037c0": "handle_timer_interrupt_080037c0",
                "*PTR_timer_handles_080037d0": "timer_handles_pointer",
                "*TIM_HandleTypeDef": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_080037c0(void)\n{\n    TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_080037d0 + 0xc);\n    if (timer_handle != NULL) {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037c0",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_080037c0"
        },
        "FUN_0800382c": {
            "renaming": {
                "FUN_0800382c": "handle_timer_interrupt_0800382c",
                "PTR_timer_handles_0800383c": "PTR_timer_handles",
                "TIM_HandleTypeDef": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_0800382c(void)\n{\n  TIM_HandleTypeDef* timer_handle = *(TIM_HandleTypeDef**)(PTR_timer_handles_0800383c_0800383c + 0x20);\n  if (timer_handle != NULL)\n  {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800382c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800382c"
        }
    },
    "used_tokens": 206737,
    "layers": [
        [
            "FUN_080006b4",
            "FUN_080034da",
            "FUN_080035fc",
            "FUN_08003dd0",
            "FUN_08000c8c",
            "FUN_08000a4e",
            "FUN_08004774",
            "FUN_08004658",
            "FUN_080034f4",
            "FUN_0800476a",
            "FUN_0800355e",
            "FUN_0800573c",
            "FUN_08003e54",
            "FUN_080056d4",
            "FUN_080033d8",
            "FUN_08002488",
            "FUN_08004788",
            "FUN_08004544",
            "FUN_08003cc8",
            "FUN_08000fb4",
            "FUN_08001bfc",
            "FUN_08002d72",
            "FUN_080007f0",
            "FUN_0800477e",
            "FUN_0800562a",
            "FUN_080044d8",
            "FUN_08003df4",
            "FUN_08005400",
            "FUN_08003582",
            "FUN_08004792",
            "FUN_08004678",
            "FUN_08003900",
            "FUN_08005768",
            "FUN_08000f0c",
            "FUN_08000998",
            "FUN_08003f94",
            "FUN_080056f8",
            "FUN_080054b4",
            "FUN_0800171a",
            "FUN_08004560",
            "FUN_08000a7a",
            "FUN_08004cb0",
            "FUN_08003594",
            "FUN_08002940",
            "FUN_08004204",
            "FUN_08003476",
            "FUN_08004444",
            "FUN_080055e0",
            "FUN_0800346c",
            "FUN_080053a0",
            "FUN_08003918",
            "FUN_080028d4",
            "FUN_08001460",
            "FUN_08004298",
            "FUN_08003880",
            "FUN_08003fd4",
            "FUN_08002f4c",
            "FUN_080035bc",
            "FUN_08000c4c",
            "FUN_080025ec",
            "FUN_080037fc",
            "FUN_08004a60",
            "FUN_080050d0",
            "FUN_08004978",
            "FUN_08002d0c",
            "FUN_0800404c",
            "FUN_08001904",
            "FUN_08000c64",
            "FUN_08002ffc",
            "FUN_0800387c",
            "FUN_0800351e",
            "FUN_08002f66",
            "FUN_080034b6",
            "FUN_08003eac",
            "FUN_08004064",
            "FUN_08003e18",
            "FUN_080040fc",
            "FUN_08002dd0",
            "FUN_08003414",
            "FUN_08005718",
            "FUN_080011c0",
            "FUN_080047f0",
            "FUN_0800502c",
            "FUN_08000b54",
            "FUN_0800376e",
            "FUN_08000d98",
            "FUN_08003f48",
            "FUN_0800340c",
            "FUN_0800352e",
            "FUN_0800582c",
            "FUN_08001ab0",
            "FUN_08001f9c",
            "FUN_08000d8c",
            "FUN_08005604",
            "FUN_080008cc",
            "FUN_08005608",
            "FUN_08002efa",
            "FUN_080058f0",
            "FUN_080056b4",
            "FUN_0800450a",
            "FUN_0800377c",
            "FUN_08003fec",
            "FUN_0800268e",
            "FUN_080008e2",
            "FUN_080045c8",
            "FUN_08003d18",
            "FUN_08004640",
            "FUN_08000c7c",
            "FUN_08004760",
            "FUN_080034ce",
            "FUN_08003798",
            "FUN_080047fe",
            "FUN_08005974",
            "FUN_08001256",
            "FUN_08004884",
            "FUN_08004648",
            "FUN_080045be",
            "FUN_0800407c",
            "FUN_08000728",
            "FUN_0800354a",
            "FUN_0800124a",
            "FUN_08004094",
            "FUN_080033c8",
            "FUN_080031fc",
            "FUN_08005580",
            "FUN_08000690",
            "FUN_08004254",
            "FUN_080054fc",
            "FUN_08001420",
            "FUN_08003840",
            "FUN_080026ce",
            "FUN_08001f3c",
            "FUN_08000218",
            "FUN_0800339c",
            "FUN_08003968",
            "FUN_08000e60",
            "FUN_0800165a",
            "FUN_080037d4",
            "FUN_08000b04",
            "FUN_0800262c",
            "FUN_080047a8",
            "FUN_08004388",
            "FUN_080051ac",
            "FUN_080052cc",
            "FUN_08002eb2",
            "FUN_08005478",
            "FUN_08000d3c",
            "FUN_08003854",
            "FUN_0800316c",
            "FUN_080040d0",
            "FUN_0800401c",
            "FUN_080040d6",
            "FUN_08004a34",
            "FUN_080002d0",
            "FUN_08003f00",
            "FUN_08004270",
            "FUN_080037e8",
            "FUN_08001440",
            "FUN_08000230",
            "FUN_080051bc",
            "FUN_08004034",
            "FUN_08000f8c",
            "FUN_08001684",
            "FUN_080001ac",
            "FUN_080040e0",
            "FUN_08003868",
            "FUN_080048cc",
            "FUN_080040e4",
            "FUN_08003506",
            "FUN_080025e0",
            "FUN_080040e8",
            "FUN_08000a00",
            "FUN_08005374",
            "FUN_08003750",
            "FUN_080014ec",
            "FUN_080048dc",
            "FUN_08003754",
            "FUN_08001578",
            "FUN_080035ac",
            "FUN_08004844",
            "FUN_0800318c",
            "FUN_080001d0",
            "FUN_080047d0",
            "FUN_080040f8",
            "FUN_0800500c",
            "FUN_080023b4",
            "FUN_080011a4",
            "FUN_08001e68",
            "FUN_080019a0",
            "FUN_08003f24",
            "FUN_080046b4",
            "FUN_0800160e",
            "FUN_08000e18",
            "FUN_08003486",
            "FUN_08005662",
            "FUN_080042ac",
            "FUN_08001864",
            "FUN_08000f2c",
            "FUN_08000ec4",
            "FUN_08004338",
            "FUN_08003928",
            "FUN_0800468c",
            "FUN_080005e0",
            "FUN_0800311c",
            "FUN_0800420c",
            "FUN_080005e4",
            "FUN_0800076c",
            "FUN_08004460",
            "FUN_08001198",
            "FUN_080044fc",
            "FUN_08003138",
            "FUN_08003810",
            "FUN_08002848",
            "FUN_08003938",
            "FUN_0800312c",
            "FUN_080028f0",
            "FUN_08000e30",
            "FUN_08000f56",
            "FUN_0800295c",
            "FUN_08003380",
            "FUN_08005686",
            "FUN_08004110",
            "FUN_08005320",
            "FUN_08000ee0",
            "FUN_080015bc",
            "FUN_08000f4e",
            "FUN_08003948",
            "FUN_0800458c",
            "FUN_0800066c",
            "FUN_080042e8",
            "FUN_080038d0",
            "FUN_0800410c",
            "FUN_0800260c",
            "FUN_08004240",
            "FUN_08005690",
            "FUN_080041bc",
            "FUN_08004364",
            "FUN_08004004",
            "FUN_08000e3c",
            "FUN_080037ac",
            "FUN_08002864",
            "FUN_0800459a",
            "FUN_08003958",
            "FUN_0800314e",
            "FUN_08004808",
            "FUN_08000f72",
            "FUN_08001d00",
            "FUN_080037c0",
            "FUN_0800382c"
        ],
        [
            "FUN_08004fdc",
            "FUN_08005760",
            "FUN_080055d0",
            "FUN_080040ec",
            "FUN_08004860",
            "FUN_08004622",
            "FUN_08000d8e",
            "FUN_08004638",
            "FUN_08000600",
            "FUN_08000de4",
            "FUN_080047c0",
            "FUN_08000682",
            "FUN_0800532c",
            "FUN_0800447c"
        ]
    ],
    "locked_functions": []
}