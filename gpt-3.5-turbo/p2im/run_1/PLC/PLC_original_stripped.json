{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "update_completed_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 updateCompletedFlag_080001ac(undefined4 inputValue)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "update_completed_flag_080001ac",
                "param_1": "inputValue",
                "completed_8667": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001d0": {
            "entrypoint": "0x080001d0",
            "current_name": "FUNC_080001d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001d4) */\n/* WARNING: Removing unreachable block (ram,0x080001ee) */\n/* WARNING: Removing unreachable block (ram,0x080001e4) */\n/* WARNING: Removing unreachable block (ram,0x08000200) */\n/* WARNING: Removing unreachable block (ram,0x080001f4) */\n\nvoid FUNC_080001d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d0": "FUNC_080001d0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000218": {
            "entrypoint": "0x08000218",
            "current_name": "calculate_string_length_08000218",
            "code": "\nsize_t calculate_string_length_08000218(char *str)\n\n{\n  char current_character;\n  char *next_character;\n  char *current_position;\n  \n  current_position = str;\n  do {\n    next_character = current_position + 1;\n    current_character = *current_position;\n    current_position = next_character;\n  } while (current_character != '\\0');\n  return (size_t)(next_character + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_08000218": "calculate_string_length_08000218",
                "__s": "str",
                "cVar1": "current_character",
                "pcVar2": "next_character",
                "pcVar3": "current_position"
            },
            "calling": [
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_byte_in_memory_08000230",
            "code": "\nvoid * find_byte_in_memory_08000230(void *memory,int byte_to_find,size_t size)\n\n{\n  byte current_byte;\n  char is_byte_equal_0;\n  char is_byte_shifted_8_equal_0;\n  char is_byte_shifted_16_equal_0;\n  char is_byte_shifted_24_equal_0;\n  byte *current_byte_pointer;\n  uint *memory_pointer;\n  byte *found_byte_pointer;\n  uint masked_byte_to_find;\n  uint memory_alignment;\n  uint aligned_size;\n  uint xor_result1;\n  uint xor_result2;\n  bool not_byte_equal_0_1;\n  bool not_byte_shifted_8_equal_0_1;\n  bool not_byte_shifted_16_equal_0_1;\n  bool not_byte_shifted_24_equal_0_1;\n  \n  masked_byte_to_find = byte_to_find & 0xff;\n  if ((int)size < 0x10) {\njoined_r0x08000290:\n    do {\n      if (size == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      memory_pointer = (uint *)((int)memory + 1);\n      current_byte = *memory;\n      size = size - 1;\n      memory = memory_pointer;\n    } while (current_byte != masked_byte_to_find);\n  }\n  else {\n    memory_alignment = (uint)memory & 7;\n    while( true ) {\n      if (memory_alignment == 0) {\n        memory_alignment = masked_byte_to_find | masked_byte_to_find << 8;\n        memory_alignment = memory_alignment | memory_alignment << 0x10;\n        aligned_size = size & 0xfffffff8;\n        do {\n          memory_pointer = (uint *)((int)memory + 8);\n                    /* WARNING: Load size is inaccurate */\n          aligned_size = aligned_size - 8;\n          xor_result1 = *memory ^ memory_alignment;\n          xor_result2 = *(uint *)((int)memory + 4) ^ memory_alignment;\n          is_byte_equal_0 = -((char)xor_result1 == '\\0');\n          is_byte_shifted_8_equal_0 = -((char)(xor_result1 >> 8) == '\\0');\n          is_byte_shifted_16_equal_0 = -((char)(xor_result1 >> 0x10) == '\\0');\n          is_byte_shifted_24_equal_0 = -((char)(xor_result1 >> 0x18) == '\\0');\n          xor_result1 = CONCAT13(is_byte_shifted_24_equal_0,CONCAT12(is_byte_shifted_16_equal_0,CONCAT11(is_byte_shifted_8_equal_0,is_byte_equal_0)));\n          not_byte_equal_0_1 = (char)xor_result2 != '\\0';\n          not_byte_shifted_8_equal_0_1 = (char)(xor_result2 >> 8) != '\\0';\n          not_byte_shifted_16_equal_0_1 = (char)(xor_result2 >> 0x10) != '\\0';\n          not_byte_shifted_24_equal_0_1 = (char)(xor_result2 >> 0x18) != '\\0';\n          xor_result2 = CONCAT13(not_byte_shifted_24_equal_0_1 * is_byte_shifted_24_equal_0 - !not_byte_shifted_24_equal_0_1,\n                            CONCAT12(not_byte_shifted_16_equal_0_1 * is_byte_shifted_16_equal_0 - !not_byte_shifted_16_equal_0_1,\n                                     CONCAT11(not_byte_shifted_8_equal_0_1 * is_byte_shifted_8_equal_0 - !not_byte_shifted_8_equal_0_1,not_byte_equal_0_1 * is_byte_equal_0 - !not_byte_equal_0_1)));\n          if (xor_result2 != 0) {\n            if (xor_result1 == 0) {\n              found_byte_pointer = (byte *)((int)memory + 5);\n              xor_result1 = xor_result2;\n            }\n            else {\n              found_byte_pointer = (byte *)((int)memory + 1);\n            }\n            if ((xor_result1 & 1) == 0) {\n              not_byte_equal_0_1 = (xor_result1 & 0x100) == 0;\n              current_byte_pointer = found_byte_pointer + 1;\n              if (not_byte_equal_0_1) {\n                not_byte_equal_0_1 = (xor_result1 & 0x18000) == 0;\n                current_byte_pointer = found_byte_pointer + 2;\n              }\n              found_byte_pointer = current_byte_pointer;\n              if (not_byte_equal_0_1) {\n                found_byte_pointer = found_byte_pointer + 1;\n              }\n            }\n            return found_byte_pointer + -1;\n          }\n          memory = memory_pointer;\n        } while (aligned_size != 0);\n        size = size & 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      memory_pointer = (uint *)((int)memory + 1);\n      size = size - 1;\n      if (*memory == masked_byte_to_find) break;\n      memory_alignment = (uint)memory_pointer & 7;\n      memory = memory_pointer;\n      if (size == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)memory_pointer + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_byte_in_memory_08000230",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "size",
                "bVar1": "current_byte",
                "cVar2": "is_byte_equal_0",
                "cVar3": "is_byte_shifted_8_equal_0",
                "cVar4": "is_byte_shifted_16_equal_0",
                "cVar5": "is_byte_shifted_24_equal_0",
                "pbVar6": "current_byte_pointer",
                "puVar7": "memory_pointer",
                "pbVar8": "found_byte_pointer",
                "uVar9": "masked_byte_to_find",
                "uVar10": "memory_alignment",
                "uVar11": "aligned_size",
                "uVar12": "xor_result1",
                "uVar13": "xor_result2",
                "bVar14": "not_byte_equal_0_1",
                "bVar15": "not_byte_shifted_8_equal_0_1",
                "bVar16": "not_byte_shifted_16_equal_0_1",
                "bVar17": "not_byte_shifted_24_equal_0_1"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "handle_divide_operations_080002d0",
            "code": "\nvoid handleDivideOperations_080002d0(int dividend,int divisor,int remainder,int quotient)\n\n{\n  if ((quotient == 0) && (remainder == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend,divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "handle_divide_operations_080002d0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "quotient"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "divisible_by_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong divisibleBy_08000300(uint dividend,uint divisor,uint quotient,uint remainder,uint *result)\n\n{\n  ulonglong calculation;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  int shift;\n  bool carry;\n  \n  if (remainder == 0) {\n    if (divisor < quotient) {\n      shift = LZCOUNT(quotient);\n      if (shift != 0) {\n        quotient = quotient << shift;\n        divisor = dividend >> (0x20U - shift & 0xff) | divisor << shift;\n        dividend = dividend << shift;\n      }\n      temp7 = quotient >> 0x10;\n      temp5 = divisor / temp7;\n      temp4 = dividend >> 0x10 | (divisor - temp7 * temp5) * 0x10000;\n      temp3 = temp5 * (quotient & 0xffff);\n      temp2 = temp5;\n      if (temp4 <= temp3 && temp3 - temp4 != 0) {\n        carry = CARRY4(temp4,quotient);\n        temp4 = temp4 + quotient;\n        temp2 = temp5 - 1;\n        if ((carry == false) && (temp4 <= temp3 && temp3 - temp4 != 0)) {\n          temp2 = temp5 - 2;\n          temp4 = temp4 + quotient;\n        }\n      }\n      temp5 = (temp4 - temp3) / temp7;\n      temp4 = dividend & 0xffff | ((temp4 - temp3) - temp7 * temp5) * 0x10000;\n      temp7 = temp5 * (quotient & 0xffff);\n      temp3 = temp5;\n      if (temp4 <= temp7 && temp7 - temp4 != 0) {\n        carry = CARRY4(temp4,quotient);\n        temp4 = temp4 + quotient;\n        temp3 = temp5 - 1;\n        if ((carry == false) && (temp4 <= temp7 && temp7 - temp4 != 0)) {\n          temp3 = temp5 - 2;\n          temp4 = temp4 + quotient;\n        }\n      }\n      temp4 = temp4 - temp7;\n      temp3 = temp3 | temp2 << 0x10;\n      temp2 = 0;\n    }\n    else {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shift = LZCOUNT(quotient);\n      if (shift == 0) {\n        divisor = divisor - quotient;\n        temp4 = quotient >> 0x10;\n        temp8 = quotient & 0xffff;\n        temp2 = 1;\n      }\n      else {\n        quotient = quotient << shift;\n        temp4 = quotient >> 0x10;\n        temp3 = divisor >> (0x20U - shift & 0xff);\n        temp6 = dividend >> (0x20U - shift & 0xff) | divisor << shift;\n        temp2 = temp3 / temp4;\n        temp8 = quotient & 0xffff;\n        temp7 = temp6 >> 0x10 | (temp3 - temp4 * temp2) * 0x10000;\n        temp5 = temp2 * temp8;\n        dividend = dividend << shift;\n        temp3 = temp2;\n        if (temp7 <= temp5 && temp5 - temp7 != 0) {\n          carry = CARRY4(temp7,quotient);\n          temp7 = temp7 + quotient;\n          temp3 = temp2 - 1;\n          if ((carry == false) && (temp7 <= temp5 && temp5 - temp7 != 0)) {\n            temp3 = temp2 - 2;\n            temp7 = temp7 + quotient;\n          }\n        }\n        temp1 = (temp7 - temp5) / temp4;\n        divisor = temp6 & 0xffff | ((temp7 - temp5) - temp4 * temp1) * 0x10000;\n        temp5 = temp1 * temp8;\n        temp2 = temp1;\n        if (divisor <= temp5 && temp5 - divisor != 0) {\n          carry = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          temp2 = temp1 - 1;\n          if ((carry == false) && (divisor <= temp5 && temp5 - divisor != 0)) {\n            temp2 = temp1 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - temp5;\n        temp2 = temp2 | temp3 << 0x10;\n      }\n      temp6 = divisor / temp4;\n      temp7 = dividend >> 0x10 | (divisor - temp4 * temp6) * 0x10000;\n      temp3 = temp8 * temp6;\n      temp5 = temp6;\n      if (temp7 <= temp3 && temp3 - temp7 != 0) {\n        carry = CARRY4(temp7,quotient);\n        temp7 = temp7 + quotient;\n        temp5 = temp6 - 1;\n        if ((carry == false) && (temp7 <= temp3 && temp3 - temp7 != 0)) {\n          temp5 = temp6 - 2;\n          temp7 = temp7 + quotient;\n        }\n      }\n      temp6 = (temp7 - temp3) / temp4;\n      temp4 = dividend & 0xffff | ((temp7 - temp3) - temp4 * temp6) * 0x10000;\n      temp8 = temp8 * temp6;\n      temp3 = temp6;\n      if (temp4 <= temp8 && temp8 - temp4 != 0) {\n        carry = CARRY4(temp4,quotient);\n        temp4 = temp4 + quotient;\n        temp3 = temp6 - 1;\n        if ((carry == false) && (temp4 <= temp8 && temp8 - temp4 != 0)) {\n          temp3 = temp6 - 2;\n          temp4 = temp4 + quotient;\n        }\n      }\n      temp4 = temp4 - temp8;\n      temp3 = temp3 | temp5 << 0x10;\n    }\n    if (result != (uint *)0x0) {\n      *result = temp4 >> shift;\n      result[1] = 0;\n      return CONCAT44(temp2,temp3);\n    }\n  }\n  else if (divisor < remainder) {\n    if (result != (uint *)0x0) {\n      *result = dividend;\n      result[1] = divisor;\n      return 0;\n    }\n    temp3 = 0;\n    temp2 = 0;\n  }\n  else {\n    shift = LZCOUNT(remainder);\n    if (shift != 0) {\n      temp7 = 0x20 - shift;\n      temp2 = quotient >> (temp7 & 0xff) | remainder << shift;\n      temp8 = temp2 >> 0x10;\n      temp3 = divisor >> (temp7 & 0xff);\n      temp1 = dividend >> (temp7 & 0xff) | divisor << shift;\n      temp6 = temp3 / temp8;\n      temp5 = temp1 >> 0x10 | (temp3 - temp8 * temp6) * 0x10000;\n      temp4 = temp6 * (temp2 & 0xffff);\n      dividend = dividend << shift;\n      temp3 = temp6;\n      if (temp5 <= temp4 && temp4 - temp5 != 0) {\n        carry = CARRY4(temp5,temp2);\n        temp5 = temp5 + temp2;\n        temp3 = temp6 - 1;\n        if ((carry == false) && (temp5 <= temp4 && temp4 - temp5 != 0)) {\n          temp3 = temp6 - 2;\n          temp5 = temp5 + temp2;\n        }\n      }\n      temp6 = (temp5 - temp4) / temp8;\n      temp5 = temp1 & 0xffff | ((temp5 - temp4) - temp8 * temp6) * 0x10000;\n      temp8 = temp6 * (temp2 & 0xffff);\n      temp4 = temp6;\n      if (temp5 <= temp8 && temp8 - temp5 != 0) {\n        carry = CARRY4(temp5,temp2);\n        temp5 = temp5 + temp2;\n        temp4 = temp6 - 1;\n        if ((carry == false) && (temp5 <= temp8 && temp8 - temp5 != 0)) {\n          temp4 = temp6 - 2;\n          temp5 = temp5 + temp2;\n        }\n      }\n      temp4 = temp4 | temp3 << 0x10;\n      calculation = (ulonglong)temp4 * (ulonglong)(quotient << shift);\n      if (CONCAT44(temp5 - temp8,dividend) < calculation) {\n        calculation = calculation - CONCAT44(temp2,quotient << shift);\n        temp4 = temp4 - 1;\n      }\n      if (result != (uint *)0x0) {\n        temp3 = ((temp5 - temp8) - (int)(calculation >> 0x20)) - (uint)(dividend < (uint)calculation);\n        *result = temp3 << (temp7 & 0xff) | dividend - (uint)calculation >> shift;\n        result[1] = temp3 >> shift;\n      }\n      return (ulonglong)temp4;\n    }\n    if ((remainder < divisor) || (quotient <= dividend)) {\n      carry = dividend < quotient;\n      dividend = dividend - quotient;\n      divisor = (divisor - remainder) - (uint)carry;\n      temp3 = 1;\n    }\n    else {\n      temp3 = 0;\n    }\n    temp2 = 0;\n    if (result != (uint *)0x0) {\n      *result = dividend;\n      result[1] = divisor;\n      return (ulonglong)temp3;\n    }\n  }\n  return CONCAT44(temp2,temp3);\n}\n\n",
            "renaming": {
                "FUN_08000300": "divisible_by_08000300",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "param_5": "result",
                "uVar1": "calculation",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "uVar9": "temp8",
                "iVar10": "shift",
                "bVar11": "carry"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005dc": {
            "entrypoint": "0x080005dc",
            "current_name": "FUNC_080005dc",
            "code": "\nvoid FUNC_080005dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005dc": "FUNC_080005dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "execute_system_interrupt_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_interrupt_080005e0(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "execute_system_interrupt_080005e0"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "execute_afl_call_080005e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_080005e4(int numTicks)\n\n{\n  uint32_t aflCallResult;\n  \n  if (isHyperCallDisabled != 0) {\n    return 0;\n  }\n  aflCallResult = aflCall(1,numTicks,0);\n  return aflCallResult;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "execute_afl_call_080005e4",
                "ticks": "numTicks",
                "noHyperCall": "isHyperCallDisabled",
                "uVar1": "aflCallResult"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "begin_modbus_communication_08000600",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusObject, long baudRate) */\n\nvoid __modbusObjectcall Modbus::beginModbusCommunication_08000600(Modbus *modbusObject,long baudRate)\n\n{\n  uint8_t serialNumber;\n  int readResult;\n  \n  serialNumber = modbusObject->u8serno;\n  if (serialNumber == '\\x02') {\n    modbusObject->port = &Serial3;\n  }\n  else if (serialNumber == '\\x03') {\n    modbusObject->port = &Serial3;\n  }\n  else if (serialNumber == '\\x01') {\n    modbusObject->port = &Serial3;\n  }\n  else {\n    modbusObject->port = &Serial3;\n  }\n  HardwareSerial::begin(modbusObject->port,baudRate,'\\x06');\n  if (1 < modbusObject->u8txenpin) {\n    pinMode((uint)modbusObject->u8txenpin,1);\n    digitalWrite((uint)modbusObject->u8txenpin,0);\n  }\n  do {\n    readResult = (*(modbusObject->port->super_Stream).super_Print._vptr_Print[3])();\n  } while (-1 < readResult);\n  modbusObject->u8BufferSize = '\\0';\n  modbusObject->u8lastRec = '\\0';\n  modbusObject->u16errCnt = 0;\n  modbusObject->u16OutCnt = 0;\n  modbusObject->u16InCnt = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000600": "begin_modbus_communication_08000600",
                "this": "modbusObject",
                "u32speed": "baudRate",
                "uVar1": "serialNumber",
                "iVar2": "readResult"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_modbus_0800066c",
            "code": "\n/* DWARF original prototype: void  init(Modbus * modbusInstance, uint8_t u8id, uint8_t u8serno, uint8_t\n   u8txenpin) */\n\nint __modbusInstancecall Modbus::initializeModbus_0800066c(Modbus *modbusInstance,EVP_PKEY_CTX *cryptoContext)\n\n{\n  int inputVariable2;\n  uint8_t inputVariable3;\n  \n  modbusInstance->u8id = (uint8_t)cryptoContext;\n  if (3 < inputVariable2) {\n    inputVariable2 = 0;\n  }\n  modbusInstance->u8serno = (uint8_t)inputVariable2;\n  modbusInstance->u8txenpin = inputVariable3;\n  modbusInstance->u16timeOut = 1000;\n  return (int)modbusInstance;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_modbus_0800066c",
                "this": "modbusInstance",
                "ctx": "cryptoContext",
                "in_r2": "inputVariable2",
                "in_r3": "inputVariable3"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_modbus_08000682",
            "code": "\n/* DWARF original prototype: Modbus *  Modbus(Modbus * modbusInstance, uint8_t id, uint8_t serialNumber, uint8_t\n   transmitEnablePin) */\n\nModbus * __modbusInstancecall\nModbus::initializeModbus_08000682(Modbus *modbusInstance,uint8_t id,uint8_t serialNumber,uint8_t transmitEnablePin)\n\n{\n  initialize(modbusInstance,(EVP_PKEY_CTX *)(uint)id);\n  return modbusInstance;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u8id": "id",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "init": "initialize",
                "FUN_08000682": "initialize_modbus_08000682"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "initialize_modbus_slave_08000690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbusSlave_08000690(int isInitialized,int priorityLevel)\n\n{\n  if (isInitialized != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    createModbusInstance(&modbusSlave,'\\x01','\\0','\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "initialize_modbus_slave_08000690",
                "__initialize_p": "isInitialized",
                "__priority": "priorityLevel",
                "Modbus::Modbus": "createModbusInstance",
                "slave": "modbusSlave"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "read_rx_buffer_080006b4",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::readRxBuffer_080006b4(Modbus *modbusInstance)\n\n{\n  bool bufferOverflow;\n  int readResult;\n  byte bufferIndex;\n  \n  if (1 < modbusInstance->u8txenpin) {\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  modbusInstance->u8BufferSize = '\\0';\n  if (modbusInstance->u8serno < 4) {\n    bufferOverflow = false;\n    while (readResult = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[2])(), readResult != 0) {\n      bufferIndex = modbusInstance->u8BufferSize;\n      readResult = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n      modbusInstance->au8Buffer[bufferIndex] = (uint8_t)readResult;\n      bufferIndex = modbusInstance->u8BufferSize + 1;\n      modbusInstance->u8BufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        bufferOverflow = true;\n      }\n    }\n  }\n  else {\n    bufferOverflow = false;\n  }\n  modbusInstance->u16InCnt = modbusInstance->u16InCnt + 1;\n  if (bufferOverflow) {\n    modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n    return -3;\n  }\n  return modbusInstance->u8BufferSize;\n}\n\n",
            "renaming": {
                "FUN_080006b4": "read_rx_buffer_080006b4",
                "this": "modbusInstance",
                "bVar1": "bufferOverflow",
                "iVar2": "readResult",
                "bVar3": "bufferIndex"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_crc_08000728",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbusInstance, uint8_t length) */\n\nuint16_t __modbusInstancecall Modbus::calculateCRC_08000728(Modbus *modbusInstance,uint8_t length)\n\n{\n  uchar bitIndex;\n  uint crc;\n  uint flag;\n  uint bit;\n  uint index;\n  \n  crc = 0xffff;\n  for (index = 0; index < length; index = index + 1 & 0xff) {\n    crc = crc ^ modbusInstance->au8Buffer[index];\n    for (bitIndex = 1; bitIndex < 9; bitIndex = bitIndex + 1) {\n      bit = crc & 1;\n      crc = crc >> 1;\n      if (bit != 0) {\n        crc = crc ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "FUN_08000728": "calculate_crc_08000728",
                "this": "modbusInstance",
                "u8length": "length",
                "j": "bitIndex",
                "uVar1": "crc",
                "uVar2": "bit",
                "uVar3": "index"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "send_tx_buffer_0800076c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendTxBuffer_0800076c(Modbus * this) */\n\nvoid __thiscall Modbus::sendTxBuffer_0800076c(Modbus *this)\n\n{\n  byte bufferSize;\n  uint16_t crcValue;\n  uint16_t crc;\n  int printRetVal;\n  uint32_t currentTime;\n  uint newBufferSize;\n  \n  bufferSize = this->u8BufferSize;\n  crcValue = calcCRC(this,bufferSize);\n  this->au8Buffer[bufferSize] = (uint8_t)(crcValue >> 8);\n  newBufferSize = bufferSize + 1 & 0xff;\n  this->au8Buffer[newBufferSize] = (uint8_t)crcValue;\n  this->u8BufferSize = (char)newBufferSize + '\\x01';\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,1);\n  }\n  if (this->u8serno < 4) {\n    (*(this->port->super_Stream).super_Print._vptr_Print[1])\n              (this->port,this->au8Buffer,(uint)this->u8BufferSize);\n  }\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,0);\n  }\n  if (this->u8serno < 4) {\n    do {\n      printRetVal = (*(this->port->super_Stream).super_Print._vptr_Print[3])();\n    } while (-1 < printRetVal);\n  }\n  this->u8BufferSize = '\\0';\n  currentTime = millis();\n  this->u32timeOut = currentTime + this->u16timeOut;\n  this->u16OutCnt = this->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800076c": "send_tx_buffer_0800076c",
                "u8length": "bufferSize",
                "uVar1": "crcValue",
                "u16crc": "crc",
                "iVar2": "printRetVal",
                "uVar3": "currentTime",
                "uVar4": "newBufferSize"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "poll",
                "process_FC16"
            ],
            "called": [
                "calcCRC",
                "digitalWrite",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "validate_request_080007f0",
            "code": "\n/* DWARF original prototype: uint8_t  validateRequest_080007f0(Modbus * modbusInstance) */\n\nuint8_t __modbusInstancecall Modbus::validateRequest_080007f0(Modbus *modbusInstance)\n\n{\n  bool isValidRequest;\n  uint16_t word1;\n  uint16_t word2;\n  uint index;\n  uint8_t registerCount;\n  \n  index = 0;\n  do {\n    if (7 < index) {\n      isValidRequest = false;\nLAB_0800080a:\n      if (!isValidRequest) {\n        modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n        return '\\x01';\n      }\n      switch(modbusInstance->au8Buffer[1]) {\n      case '\\x01':\n      case '\\x02':\n      case '\\x0f':\n        goto switchD_08000816_caseD_1;\n      case '\\x03':\n      case '\\x04':\n      case '\\x10':\n        word1 = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n        word2 = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n        if (modbusInstance->registerCountize < (byte)((char)word2 + (char)word1)) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x05':\n        word1 = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n        if ((uint)modbusInstance->registerCountize < ((uint)word1 << 0x14) >> 0x18) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x06':\n        word1 = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n        if (modbusInstance->registerCountize < (byte)word1) {\n          return '\\x02';\n        }\n        return '\\0';\n      default:\n        return '\\0';\n      }\n    }\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[index] == modbusInstance->au8Buffer[1]) {\n      isValidRequest = true;\n      goto LAB_0800080a;\n    }\n    index = index + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  word1 = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  word2 = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  if ((uint)modbusInstance->registerCountize <\n      ((((uint)word1 << 0xc) >> 0x10) + (((uint)word2 << 0xc) >> 0x10) & 0xff)) {\n    return '\\x02';\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_080007f0": "validate_request_080007f0",
                "this": "modbusInstance",
                "bVar1": "isValidRequest",
                "uVar2": "word1",
                "uVar3": "word2",
                "uVar4": "index",
                "u8regs": "registerCount"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "build_exception_080008cc",
            "code": "\n/* DWARF original prototype: void  buildException_080008cc(Modbus * modbusObject, uint8_t exceptionCode) */\n\nvoid __modbusObjectcall Modbus::buildException_080008cc(Modbus *modbusObject,uint8_t exceptionCode)\n\n{\n  byte secondByte;\n  uint8_t functionCode;\n  \n  secondByte = modbusObject->au8Buffer[1];\n  modbusObject->au8Buffer[0] = modbusObject->u8id;\n  modbusObject->au8Buffer[1] = secondByte ^ 0x80;\n  modbusObject->au8Buffer[2] = exceptionCode;\n  modbusObject->u8BufferSize = '\\x03';\n  return;\n}\n\n",
            "renaming": {
                "this": "modbusObject",
                "u8exception": "exceptionCode",
                "bVar1": "secondByte",
                "u8func": "functionCode",
                "FUN_080008cc": "build_exception_080008cc"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "process_fc1_080008e2",
            "code": "\n/* DWARF original prototype: int8_t  process_FC1_080008e2(Modbus * modbusInstance, uint16_t * registers, uint8_t registerCount) */\n\nint8_t __modbusInstancecall Modbus::process_FC1_080008e2(Modbus *modbusInstance,uint16_t *registers,uint8_t registerCount)\n\n{\n  uint16_t startAddress;\n  uint16_t bitCount;\n  uint16_t currentBit;\n  uint iteration;\n  uint bitIndex;\n  uint8_t byteCount;\n  uint8_t noBytes;\n  uint8_t copyBufferSize;\n  uint16_t startBit;\n  \n  startAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  bitCount = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  byteCount = (uint8_t)(((uint)bitCount << 0x15) >> 0x18);\n  if ((bitCount & 7) != 0) {\n    byteCount = byteCount + '\\x01';\n  }\n  modbusInstance->au8Buffer[2] = byteCount;\n  modbusInstance->bufferSize = '\\x03';\n  bitIndex = 0;\n  for (iteration = 0; iteration < bitCount; iteration = iteration + 1 & 0xffff) {\n    if (((int)(uint)registers[(iteration + startAddress) * 0x100000 >> 0x18] >> (iteration + startAddress & 0xf) & 1U) == 0) {\n      modbusInstance->au8Buffer[modbusInstance->bufferSize] =\n           modbusInstance->au8Buffer[modbusInstance->bufferSize] & ~(byte)(1 << bitIndex);\n    }\n    else {\n      modbusInstance->au8Buffer[modbusInstance->bufferSize] = modbusInstance->au8Buffer[modbusInstance->bufferSize] | (byte)(1 << bitIndex)\n      ;\n    }\n    bitIndex = bitIndex + 1 & 0xff;\n    if (7 < bitIndex) {\n      modbusInstance->bufferSize = modbusInstance->bufferSize + '\\x01';\n      bitIndex = 0;\n    }\n  }\n  if ((bitCount & 7) != 0) {\n    modbusInstance->bufferSize = modbusInstance->bufferSize + '\\x01';\n  }\n  byteCount = modbusInstance->bufferSize;\n  sendTxBuffer(modbusInstance);\n  return byteCount + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registers",
                "u8size": "registerCount",
                "uVar1": "startAddress",
                "uVar2": "bitCount",
                "u16Coilno": "currentBit",
                "uVar3": "iteration",
                "uVar4": "bitIndex",
                "uVar5": "byteCount",
                "u8bytesno": "noBytes",
                "u8CopyBufferSize": "copyBufferSize",
                "u16StartCoil": "startBit",
                "u8BufferSize": "bufferSize",
                "FUN_080008e2": "process_fc1_080008e2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_fc3_08000998",
            "code": "\n/* DWARF orloopIndexgloopIndexnal prototype: loopIndexnt8_t  process_FC3_08000998(Modbus * modbusInstance, uloopIndexnt16_t * registers, uloopIndexnt8_t registersSize) */\n\nloopIndexnt8_t __modbusInstancecall Modbus::process_FC3_08000998(Modbus *modbusInstance,uloopIndexnt16_t *registers,uloopIndexnt8_t registersSize)\n\n{\n  byte bufferSize;\n  uloopIndexnt8_t tempVar;\n  uloopIndexnt8_t registersCount;\n  uloopIndexnt16_t startingAddress;\n  uloopIndexnt16_t quantity;\n  uloopIndexnt currentIndex;\n  uloopIndexnt nextIndex;\n  uloopIndexnt8_t copyBufferSize;\n  uloopIndexnt8_t startAddress;\n  uloopIndexnt8_t loopIndex;\n  \n  startingAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  quantity = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  modbusInstance->au8Buffer[2] = (byte)quantity << 1;\n  modbusInstance->u8BufferSloopIndexze = '\\x03';\n  for (currentIndex = (uloopIndexnt)(byte)startingAddress; currentIndex < (uloopIndexnt)(byte)startingAddress + (uloopIndexnt)(byte)quantity;\n      currentIndex = currentIndex + 1 & 0xff) {\n    bufferSize = modbusInstance->u8BufferSloopIndexze;\n    modbusInstance->au8Buffer[bufferSize] = (uloopIndexnt8_t)(registers[currentIndex] >> 8);\n    nextIndex = bufferSize + 1 & 0xff;\n    tempVar = (uloopIndexnt8_t)nextIndex;\n    modbusInstance->u8BufferSloopIndexze = tempVar;\n    modbusInstance->au8Buffer[nextIndex] = *(uloopIndexnt8_t *)(registers + currentIndex);\n    modbusInstance->u8BufferSloopIndexze = tempVar + '\\x01';\n  }\n  tempVar = modbusInstance->u8BufferSloopIndexze;\n  sendTxBuffer(modbusInstance);\n  return tempVar + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registers",
                "u8size": "registersSize",
                "bVar1": "bufferSize",
                "uVar2": "tempVar",
                "u8regsno": "registersCount",
                "uVar3": "startingAddress",
                "uVar4": "quantity",
                "uVar5": "currentIndex",
                "uVar6": "nextIndex",
                "u8CopyBufferSize": "copyBufferSize",
                "u8StartAdd": "startAddress",
                "i": "loopIndex",
                "FUN_08000998": "process_fc3_08000998"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "update_coil_status_08000a00",
            "code": "\n/* DWARF original prototype: int8_t  process_FC5(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t registerCount) */\n\nint8_t __modbusInstancecall Modbus::updateCoilStatus_08000a00(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t registerCount)\n\n{\n  uint8_t currentBit;\n  uint16_t bufferValue;\n  uint16_t coilValue;\n  uint shiftAmount;\n  uint8_t currentRegister;\n  uint registerIndex;\n  \n  bufferValue = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  registerIndex = ((uint)bufferValue << 0x14) >> 0x18;\n  shiftAmount = bufferValue & 0xf;\n  if (modbusInstance->au8Buffer[4] == 0xff) {\n    coilRegisters[registerIndex] = (ushort)(1 << shiftAmount) | coilRegisters[registerIndex];\n  }\n  else {\n    coilRegisters[registerIndex] = coilRegisters[registerIndex] & ~(ushort)(1 << shiftAmount);\n  }\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "registerCount",
                "u8currentBit": "currentBit",
                "uVar1": "bufferValue",
                "u16coil": "coilValue",
                "uVar2": "shiftAmount",
                "u8currentRegister": "currentRegister",
                "uVar3": "registerIndex",
                "FUN_08000a00": "update_coil_status_08000a00"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "update_regs_and_send_08000a4e",
            "code": "\n/* DWARF original prototype: int8_t  process_FC6(Modbus * modbusInstance, uint16_t * registerArray, uint8_t size) */\n\nint8_t __modbusInstancecall Modbus::updateRegsAndSend_08000a4e(Modbus *modbusInstance,uint16_t *registerArray,uint8_t size)\n\n{\n  uint16_t firstWord;\n  uint16_t secondWord;\n  uint16_t value;\n  uint8_t address;\n  \n  firstWord = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  secondWord = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  registerArray[(byte)firstWord] = secondWord;\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registerArray",
                "u8size": "size",
                "uVar1": "firstWord",
                "uVar2": "secondWord",
                "u16val": "value",
                "u8add": "address",
                "FUN_08000a4e": "update_regs_and_send_08000a4e"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "process_fc15_08000a7a",
            "code": "\n/* DWARF original prototype: int8_t  process_FC15_08000a7a(Modbus * modbus, uint16_t * coilRegisters, uint8_t registerCount) */\n\nint8_t __modbuscall Modbus::process_FC15_08000a7a(Modbus *modbus,uint16_t *coilRegisters,uint8_t registerCount)\n\n{\n  uint16_t startAddress;\n  uint16_t coilCount;\n  uint16_t currentCoil;\n  uint counter;\n  uint bitCount;\n  uint8_t currentBit;\n  uint bitPosition;\n  uint16_t startCoil;\n  uint8_t currentRegister;\n  uint registerIndex;\n  uint bufferIndex;\n  \n  startAddress = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  coilCount = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  bitCount = 0;\n  bufferIndex = 7;\n  for (counter = 0; counter < coilCount; counter = counter + 1 & 0xffff) {\n    registerIndex = (counter + startAddress) * 0x100000 >> 0x18;\n    bitPosition = counter + startAddress & 0xf;\n    if (((int)(uint)modbus->au8Buffer[bufferIndex] >> bitCount & 1U) == 0) {\n      coilRegisters[registerIndex] = coilRegisters[registerIndex] & ~(ushort)(1 << bitPosition);\n    }\n    else {\n      coilRegisters[registerIndex] = (ushort)(1 << bitPosition) | coilRegisters[registerIndex];\n    }\n    bitCount = bitCount + 1 & 0xff;\n    if (7 < bitCount) {\n      bufferIndex = bufferIndex + 1 & 0xff;\n      bitCount = 0;\n    }\n  }\n  modbus->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbus",
                "regs": "coilRegisters",
                "u8size": "registerCount",
                "uVar1": "startAddress",
                "uVar2": "coilCount",
                "u16Coilno": "currentCoil",
                "uVar3": "counter",
                "uVar4": "bitCount",
                "u8currentBit": "currentBit",
                "uVar5": "bitPosition",
                "u16StartCoil": "startCoil",
                "u8currentRegister": "currentRegister",
                "uVar6": "registerIndex",
                "uVar7": "bufferIndex",
                "FUN_08000a7a": "process_fc15_08000a7a"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "process_fc16_08000b04",
            "code": "\n/* DWARF orloopIndexgloopIndexnal prototype: loopIndexnt8_t  process_FC16_08000b04(ModbusProtocol * thloopIndexs, uloopIndexnt16_t * registerArray, uloopIndexnt8_t registerArraySize) */\n\nloopIndexnt8_t __thloopIndexscall ModbusProtocol::process_FC16_08000b04(ModbusProtocol *thloopIndexs,uloopIndexnt16_t *registerArray,uloopIndexnt8_t registerArraySize)\n\n{\n  byte bufferStartIndex;\n  byte bufferCount;\n  uloopIndexnt8_t bufferSize;\n  uloopIndexnt16_t tempValue;\n  uloopIndexnt16_t tempVariable;\n  uloopIndexnt8_t copyBufferSize;\n  uloopIndexnt8_t loopIndex;\n  uloopIndexnt loopCounter;\n  uloopIndexnt8_t numberOfRegisters;\n  uloopIndexnt8_t startAddress;\n  \n  bufferStartIndex = thloopIndexs->au8Buffer[3];\n  bufferCount = thloopIndexs->au8Buffer[5];\n  thloopIndexs->au8Buffer[4] = '\\0';\n  thloopIndexs->au8Buffer[5] = bufferCount;\n  thloopIndexs->u8BufferSloopIndexze = '\\x06';\n  for (loopCounter = 0; loopCounter < bufferCount; loopCounter = loopCounter + 1 & 0xff) {\n    tempValue = makeWord(thloopIndexs->au8Buffer[loopCounter * 2 + 7],thloopIndexs->au8Buffer[loopCounter * 2 + 8]);\n    registerArray[bufferStartIndex + loopCounter] = tempValue;\n  }\n  bufferSize = thloopIndexs->u8BufferSloopIndexze;\n  sendTxBuffer(thloopIndexs);\n  return bufferSize + '\\x02';\n}\n\n",
            "renaming": {
                "Modbus": "ModbusProtocol",
                "regs": "registerArray",
                "u8size": "registerArraySize",
                "bVar1": "bufferStartIndex",
                "bVar2": "bufferCount",
                "uVar3": "bufferSize",
                "uVar4": "tempValue",
                "temp": "tempVariable",
                "u8CopyBufferSize": "copyBufferSize",
                "i": "loopIndex",
                "uVar5": "loopCounter",
                "u8regsno": "numberOfRegisters",
                "u8StartAdd": "startAddress",
                "FUN_08000b04": "process_fc16_08000b04"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "process_modbus_poll_08000b54",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * modbusInstance, uint16_t * regs, uint8_t registerSize) */\n\nint __modbusInstancecall Modbus::processModbusPoll_08000b54(Modbus *modbusInstance,pollfd *pollFileDescriptors,nfds_t numFileDescriptors,int timeout)\n\n{\n  uint8_t registerSize;\n  uint8_t bufferElement;\n  int8_t state;\n  uint8_t exceptionCode;\n  int8_t result;\n  uint value;\n  uint32_t currentMillis;\n  uint8_t current;\n  uint result_r5;\n  int returnValue;\n  \n  modbusInstance->registers = (uint16_t *)pollFileDescriptors;\n  registerSize = (uint8_t)numFileDescriptors;\n  modbusInstance->registersSize = registerSize;\n  if (modbusInstance->serno < 4) {\n    value = (*(modbusInstance->modbusPort->stream).printFunction)();\n    result_r5 = value & 0xff;\n  }\n  if (result_r5 == 0) {\n    returnValue = 0;\n  }\n  else if ((int)result_r5 < 8) {\n    returnValue = 0;\n  }\n  else {\n    bufferElement = getRxBuffer(modbusInstance);\n    returnValue = (int)(char)bufferElement;\n    modbusInstance->u8lastError = bufferElement;\n    if (modbusInstance->au8Buffer[0] == modbusInstance->u8id) {\n      bufferElement = validateRequest(modbusInstance);\n      if (bufferElement == '\\0') {\n        currentMillis = millis();\n        modbusInstance->u32timeOut = modbusInstance->u16timeOut + currentMillis;\n        modbusInstance->u8lastError = '\\0';\n        switch(modbusInstance->au8Buffer[1]) {\n        case '\\x01':\n        case '\\x02':\n          result = process_FC1(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x03':\n        case '\\x04':\n          result = process_FC3(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x05':\n          result = process_FC5(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x06':\n          result = process_FC6(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x0f':\n          result = process_FC15(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x10':\n          result = process_FC16(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n        }\n      }\n      else {\n        if (bufferElement != 0xff) {\n          createException(modbusInstance,bufferElement);\n          transmitBuffer(modbusInstance);\n        }\n        modbusInstance->u8lastError = bufferElement;\n        returnValue = (int)(char)bufferElement;\n      }\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "__fds": "pollFileDescriptors",
                "__nfds": "numFileDescriptors",
                "__timeout": "timeout",
                "u8size": "registerSize",
                "uVar1": "bufferElement",
                "i8state": "state",
                "u8exception": "exceptionCode",
                "iVar2": "result",
                "uVar3": "value",
                "uVar4": "currentMillis",
                "u8current": "current",
                "unaff_r5": "result_r5",
                "iVar5": "returnValue",
                "au16regs": "registers",
                "u8regsize": "registersSize",
                "u8serno": "serno",
                "port": "modbusPort",
                "super_Stream": "stream",
                "super_Print._vptr_Print[2]": "printFunction",
                "buildException": "createException",
                "sendTxBuffer": "transmitBuffer",
                "FUN_08000b54": "process_modbus_poll_08000b54"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer",
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "buildException",
                "process_FC16",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_modbus_slave_08000c4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbusSlave_08000c4c(void)\n\n{\n  startForkServer(0);\n  Modbus::initialize(&modbusSlave,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_modbus_slave_08000c4c",
                "startForkserver": "startForkServer",
                "Modbus::begin": "Modbus::initialize",
                "slave": "modbusSlave"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_modbus_slave_08000c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pollModbusSlave_08000c64(void)\n\n{\n  int data;\n  \n  Modbus::poll(&modbusSlave,(pollfd *)pollFds,0x10,data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_modbus_slave_08000c64",
                "in_r3": "data",
                "slave": "modbusSlave",
                "au16data": "pollFds"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c7c": {
            "entrypoint": "0x08000c7c",
            "current_name": "initialize_static_variables_08000c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_08000c7c(void)\n\n{\n  initialize(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c7c": "initialize_static_variables_08000c7c",
                "__static_initialization_and_destruction_0": "initialize"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_system_clock_08000c8c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemClock_08000c8c(void)\n\n{\n  uint32_t uVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  RCC_OscInitTypeDef rccOscInit;\n  RCC_ClkInitTypeDef rccClkInit;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  rccOscInit.oscillatorType = 1;\n  rccOscInit.oscillatorState = 0x50000;\n  rccOscInit.pllState = 2;\n  rccOscInit.pllSource = 0x400000;\n  rccOscInit.pllM = 8;\n  rccOscInit.pllN = 0x150;\n  rccOscInit.pllP = 2;\n  rccOscInit.pllQ = 7;\n  configureOscillator((RCC_OscInitTypeDef_conflict *)&rccOscInit);\n  enableOverDrive();\n  rccClkInit.clockType = 0xf;\n  rccClkInit.sysClockSource = 2;\n  rccClkInit.ahbClockDivider = 0;\n  rccClkInit.apb1ClockDivider = 0x1400;\n  rccClkInit.apb2ClockDivider = 0x1000;\n  configureClock((RCC_ClkInitTypeDef_conflict *)&rccClkInit,5);\n  uVar1 = getHclkFrequency();\n  configureSysTick(uVar1 / 1000);\n  configureSysTickClkSource(4);\n  setSysTickPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_system_clock_08000c8c",
                "RCC_OscInitStruct": "rccOscInit",
                "RCC_ClkInitStruct": "rccClkInit",
                "HSEState": "oscillatorState",
                "PLLState": "pllState",
                "PLLSource": "pllSource",
                "PLLQ": "pllQ",
                "RCC_OscInitStruct.OscillatorType": "rccOscInit.oscillatorType",
                "RCC_OscInitStruct.HSEState": "rccOscInit.oscillatorState",
                "RCC_OscInitStruct.PLL.PLLState": "rccOscInit.pllState",
                "RCC_OscInitStruct.PLL.PLLSource": "rccOscInit.pllSource",
                "RCC_OscInitStruct.PLL.PLLM": "rccOscInit.pllM",
                "RCC_OscInitStruct.PLL.PLLN": "rccOscInit.pllN",
                "RCC_OscInitStruct.PLL.PLLP": "rccOscInit.pllP",
                "RCC_OscInitStruct.PLL.PLLQ": "rccOscInit.pllQ",
                "HAL_RCC_OscConfig": "configureOscillator",
                "HAL_PWREx_EnableOverDrive": "enableOverDrive",
                "RCC_ClkInitStruct.ClockType": "rccClkInit.clockType",
                "RCC_ClkInitStruct.SYSCLKSource": "rccClkInit.sysClockSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "rccClkInit.ahbClockDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "rccClkInit.apb1ClockDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "rccClkInit.apb2ClockDivider",
                "HAL_RCC_ClockConfig": "configureClock",
                "HAL_RCC_GetHCLKFreq": "getHclkFrequency",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_SYSTICK_CLKSourceConfig": "configureSysTickClkSource",
                "HAL_NVIC_SetPriority": "setSysTickPriority"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8667; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8c": {
            "entrypoint": "0x08000d8c",
            "current_name": "infinite_loop_08000d8c",
            "code": "\nvoid infiniteLoop_08000d8c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08000d8c": "infinite_loop_08000d8c"
            },
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_configuration_08000d8e",
            "code": "\nint initializeHardwareConfiguration_08000d8e(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_configuration_08000d8e",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "initialize_tick_08000d98",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeTick_08000d98(uint32_t tickPriority)\n\n{\n  uint32_t status;\n  \n  status = configureSysTick((uint32_t)((ulonglong)coreClock / (1000 / (ulonglong)tickFrequency))\n                            );\n  if (status != 0) {\n    return error;\n  }\n  if (0xf < tickPriority) {\n    return error;\n  }\n  setSysTickPriority(systickIRQ,tickPriority,0);\n  tickPriorityBuffer = tickPriority;\n  return success;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "initialize_tick_08000d98",
                "TickPriority": "tickPriority",
                "uVar1": "status",
                "SystemCoreClock": "coreClock",
                "uwTickFreq": "tickFrequency",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_ERROR": "error",
                "HAL_NVIC_SetPriority": "setSysTickPriority",
                "SysTick_IRQn": "systickIRQ",
                "uwTickPrio": "tickPriorityBuffer",
                "HAL_OK": "success"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_hardware_08000de4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeHardware_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializePeriph();\n  return success;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_hardware_08000de4",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeriph",
                "HAL_OK": "success"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "update_tick_08000e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTick_08000e18(void)\n\n{\n  newTick = tickFrequency + newTick;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "update_tick_08000e18",
                "uwTick": "newTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_system_tick_08000e30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08000e30(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_system_tick_08000e30",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write",
                "GetCurrentMilli",
                "HAL_RCC_OscConfig",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "configure_priority_group_08000e3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08000e3c(uint32_t newPriorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (newPriorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "configure_priority_group_08000e3c",
                "PriorityGroup": "newPriorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "configure_priority_08000e60",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriority_08000e60(interruptType IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqType;\n  uint priorityShift;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqType = (uint)IRQn;\n  priorityShift = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityShift;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityShift + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityShift - 3;\n  }\n  priorityShift = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqType < 0) {\n    *(char *)((irqType & 0xf) + 0xe000ed14) = (char)(priorityShift << 4);\n  }\n  else {\n    *(char *)(irqType + 0xe000e400) = (char)(priorityShift << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "configure_priority_08000e60",
                "IRQn_Type_conflict": "interruptType",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "uVar1": "irqType",
                "uVar2": "priorityShift"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_interrupt_enabled_08000ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnabled_08000ec4(interruptType IRQn)\n\n{\n  uint interruptNum;\n  \n  interruptNum = (uint)IRQn;\n  if (-1 < (int)interruptNum) {\n    *(int *)((interruptNum >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNum & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_interrupt_enabled_08000ec4",
                "IRQn_Type_conflict": "interruptType",
                "uVar1": "interruptNum"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "initialize_timer_08000ee0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTimer_08000ee0(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    returnValue 0;\n  }\n  returnValue 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "initialize_timer_08000ee0",
                "TicksNumb": "ticksNumber",
                "return": "returnValue"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "set_interrupt_enable_08000f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnable_08000f0c(irqNumber IRQn)\n\n{\n  uint irqValue;\n  \n  irqValue = (uint)IRQn;\n  if (-1 < (int)irqValue) {\n    *(int *)(((irqValue >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (irqValue & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "set_interrupt_enable_08000f0c",
                "IRQn_Type_conflict": "irqNumber",
                "uVar1": "irqValue"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "set_clock_source_08000f2c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08000f2c(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "set_clock_source_08000f2c",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "execute_sys_tick_callback_08000f4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeSysTickCallback_08000f4e(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "execute_sys_tick_callback_08000f4e"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "initialize_dac_08000f56",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeDAC_08000f56(DAC_HandleTypeDef *dacHandle)\n\n{\n  if (dacHandle != (DAC_HandleTypeDef *)0x0) {\n    dacHandle->State = HAL_DAC_STATE_BUSY;\n    HAL_DAC_MspDeInit(dacHandle);\n    dacHandle->ErrorCode = 0;\n    dacHandle->State = HAL_DAC_STATE_RESET;\n    dacHandle->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "initialize_dac_08000f56",
                "hdac": "dacHandle"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "disable_dac_channel_08000f72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableDACChannel_08000f72(DAC_HandleTypeDef *dacHandle,uint32_t channel)\n\n{\n  dacHandle->Instance->CR = dacHandle->Instance->CR & ~(1 << (channel & 0xff));\n  dacHandle->State = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "disable_dac_channel_08000f72",
                "hdac": "dacHandle",
                "Channel": "channel"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "halt_dma_and_set_aborted_state_08000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef haltDmaAndSetAbortedState_08000f8c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  if (dmaHandle->currentState != DMA_STATE_BUSY) {\n    dmaHandle->errorFlag = 0x80;\n    return HAL_ERROR;\n  }\n  dmaHandle->currentState = DMA_STATE_ABORT;\n  dmaHandle->Instance->CR = dmaHandle->Instance->CR & 0xfffffffe;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "halt_dma_and_set_aborted_state_08000f8c",
                "hdma": "dmaHandle",
                "State": "currentState",
                "ErrorCode": "errorFlag",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_DMA_STATE_ABORT": "DMA_STATE_ABORT"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "configure_gpio_08000fb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08000fb4(GPIO *GPIOx,GPIOConfig *GPIO_Init)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint32_t tempVar6;\n  int index;\n  uint tempVar8;\n  int shiftValue;\n  uint32_t GPIO_TEMP_REG;\n  \n  for (tempVar3 = 0; tempVar3 < 0x10; tempVar3 = tempVar3 + 1) {\n    tempVar2 = 1 << (tempVar3 & 0xff);\n    tempVar4 = tempVar2 & GPIO_Init->Pin;\n    tempVar1 = _DAT_40013c0c;\n    if (tempVar2 == tempVar4) {\n      if ((GPIO_Init->Mode == 2) || (GPIO_Init->Mode == 0x12)) {\n        shiftValue = (tempVar3 & 7) << 2;\n        GPIOx->AFR[tempVar3 >> 3] =\n             GPIOx->AFR[tempVar3 >> 3] & ~(0xf << shiftValue) | GPIO_Init->Alternate << shiftValue;\n      }\n      tempVar8 = tempVar3 << 1;\n      tempVar1 = ~(3 << (tempVar8 & 0xff));\n      GPIOx->MODER = GPIOx->MODER & tempVar1 | (GPIO_Init->Mode & 3) << (tempVar8 & 0xff);\n      tempVar6 = GPIO_Init->Mode;\n      if (((tempVar6 - 1 < 2) || (tempVar6 == 0x11)) || (tempVar6 == 0x12)) {\n        GPIOx->OSPEEDR = GPIOx->OSPEEDR & tempVar1 | GPIO_Init->Speed << (tempVar8 & 0xff);\n        GPIOx->OTYPER =\n             GPIOx->OTYPER & ~tempVar2 | ((GPIO_Init->Mode << 0x1b) >> 0x1f) << (tempVar3 & 0xff);\n      }\n      GPIOx->PUPDR = tempVar1 & GPIOx->PUPDR | GPIO_Init->Pull << (tempVar8 & 0xff);\n      tempVar1 = _DAT_40013c0c;\n      if ((GPIO_Init->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        shiftValue = (tempVar3 & 3) << 2;\n        if (GPIOx == (GPIO *)0x40020000) {\n          index = 0;\n        }\n        else if (GPIOx == (GPIO *)0x40020400) {\n          index = 1;\n        }\n        else if (GPIOx == (GPIO *)0x40020800) {\n          index = 2;\n        }\n        else if (GPIOx == (GPIO *)0x40020c00) {\n          index = 3;\n        }\n        else if (GPIOx == (GPIO *)0x40021000) {\n          index = 4;\n        }\n        else if (GPIOx == (GPIO *)0x40021400) {\n          index = 5;\n        }\n        else if (GPIOx == (GPIO *)0x40021800) {\n          index = 6;\n        }\n        else if (GPIOx == (GPIO *)0x40021c00) {\n          index = 7;\n        }\n        else if (GPIOx == (GPIO *)0x40022000) {\n          index = 8;\n        }\n        else if (GPIOx == (GPIO *)0x40022400) {\n          index = 9;\n        }\n        else {\n          index = 10;\n        }\n        *(uint *)(((tempVar3 >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((tempVar3 >> 2) + 2) * 4 + 0x40013800) & ~(0xf << shiftValue) | index << shiftValue;\n        tempVar1 = ~tempVar4;\n        tempVar2 = _DAT_40013c00 & tempVar1;\n        if ((GPIO_Init->Mode & 0x10000) != 0) {\n          tempVar2 = tempVar4 | _DAT_40013c00;\n        }\n        tempVar8 = tempVar1 & _DAT_40013c04;\n        if ((GPIO_Init->Mode & 0x20000) != 0) {\n          tempVar8 = tempVar4 | _DAT_40013c04;\n        }\n        tempVar5 = tempVar1 & _DAT_40013c08;\n        if ((GPIO_Init->Mode & 0x100000) != 0) {\n          tempVar5 = tempVar4 | _DAT_40013c08;\n        }\n        _DAT_40013c00 = tempVar2;\n        _DAT_40013c04 = tempVar8;\n        _DAT_40013c08 = tempVar5;\n        tempVar1 = tempVar1 & _DAT_40013c0c;\n        if ((GPIO_Init->Mode & 0x200000) != 0) {\n          tempVar1 = tempVar4 | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = tempVar1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "configure_gpio_08000fb4",
                "GPIO_TypeDef": "GPIO",
                "GPIO_InitTypeDef": "GPIOConfig",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6",
                "iVar7": "index",
                "uVar8": "tempVar8",
                "iVar9": "shiftValue",
                "tmpreg": "GPIO_TEMP_REG"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "set_gpio_pin_state_08001198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIO_PinState_08001198(GPIO_TypeDef *gpio,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  if (pinState == GPIO_PIN_RESET) {\n    gpio->BSRR = (uint)pinNumber << 0x10;\n    return;\n  }\n  gpio->BSRR = (uint)pinNumber;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "set_gpio_pin_state_08001198",
                "GPIOx": "gpio",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "handle_gpio_interrupt_080011a4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_interrupt_080011a4(uint16_t pin)\n\n{\n  if ((_DAT_40013c14 & pin) != 0) {\n    _DAT_40013c14 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "handle_gpio_interrupt_080011a4",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "set_i2_c_master_mode_080011c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setI2CMasterMode_080011c0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->Mode == I2C_MODE_MEMORY) {\n    if (i2cHandle->EventCount == 0) {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->Init).AddressingMode == 0x4000) {\n    if (i2cHandle->State == I2C_STATE_BUSY_TRANSMIT) {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->EventCount == 0) {\n    i2cHandle->Instance->DR = (i2cHandle->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->EventCount == 1) {\n    i2cHandle->Instance->DR = (i2cHandle->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OPERATION_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "set_i2_c_master_mode_080011c0",
                "hi2c": "i2cHandle",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TRANSMIT",
                "HAL_OK": "HAL_OPERATION_SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "set_dev_address_0800124a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setDevAddress_0800124a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "set_dev_address_0800124a",
                "hi2c": "i2cHandle",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "update_i2_c_state_08001256",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef updateI2CState_08001256(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t tempVar1;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  uint32_t tempRegister2;\n  uint32_t tempRegister3;\n  uint32_t tempRegister4;\n  uint32_t tempRegister5;\n  uint32_t tempRegister6;\n  uint32_t tempRegister7;\n  uint32_t tempRegister8;\n  uint32_t tempRegister9;\n  \n  tempVar1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (tempVar1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((tempVar1 == 4) || (tempVar1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001256": "update_i2_c_state_08001256",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "tempVar1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "tmpreg_2": "tempRegister2",
                "tmpreg_3": "tempRegister3",
                "tmpreg_4": "tempRegister4",
                "tmpreg_5": "tempRegister5",
                "tmpreg_6": "tempRegister6",
                "tmpreg_7": "tempRegister7",
                "tmpreg_8": "tempRegister8",
                "tmpreg_9": "tempRegister9"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "send_byte_via_i2_c_08001420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef sendByteViaI2C_08001420(I2C_HandleTypeDef *i2cHandler)\n\n{\n  byte *pbVar1;\n  \n  if (i2cHandler->transferCount != 0) {\n    pbVar1 = i2cHandler->bufferPointer;\n    i2cHandler->bufferPointer = pbVar1 + 1;\n    i2cHandler->i2cInstance->dataRegister = (uint)*pbVar1;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001420": "send_byte_via_i2_c_08001420",
                "hi2c": "i2cHandler",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "read_byte_from_i2_c_08001440",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef readByteFromI2C_08001440(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint8_t *puVar1;\n  \n  if (i2cHandler->transferCount != 0) {\n    puVar1 = i2cHandler->bufferPointer;\n    i2cHandler->bufferPointer = puVar1 + 1;\n    *puVar1 = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001440": "read_byte_from_i2_c_08001440",
                "hi2c": "i2cHandler",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "configure_i2_c_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureI2C_08001460(I2C_HandleTypeDef *I2C_handle,uint8_t *dataBuffer,uint16_t bufferSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *I2C_instance;\n  uint32_t tempRegister;\n  \n  if (I2C_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (bufferSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (I2C_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      I2C_handle->Lock = HAL_LOCKED;\n      I2C_instance = I2C_handle->Instance;\n      if ((I2C_instance->CR1 & 1) == 0) {\n        I2C_instance->CR1 = I2C_instance->CR1 | 1;\n      }\n      I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffff7ff;\n      I2C_handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      I2C_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      I2C_handle->ErrorCode = 0;\n      I2C_handle->pBuffPtr = dataBuffer;\n      I2C_handle->XferCount = bufferSize;\n      I2C_handle->transferOptions = transferOptions;\n      I2C_handle->XferbufferSize = I2C_handle->XferCount;\n      I2C_handle->Lock = HAL_UNLOCKED;\n      I2C_handle->Instance->CR2 = I2C_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001460": "configure_i2_c_08001460",
                "hi2c": "I2C_handle",
                "pData": "dataBuffer",
                "Size": "bufferSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "I2C_instance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "configure_i2_c_080014ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureI2C_080014ec(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "configure_i2_c_080014ec",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "initialize_i2_c_08001578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeI2C_08001578(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_Struct *i2cInstance;\n  \n  if (i2cHandle->State != I2C_STATE_READY) {\n    return HAL_I2C_BUSY;\n  }\n  i2cHandle->State = I2C_STATE_LISTEN;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->controlRegister1 & 1) == 0) {\n    i2cInstance->controlRegister1 = i2cInstance->controlRegister1 | 1;\n  }\n  i2cHandle->Instance->controlRegister1 = i2cHandle->Instance->controlRegister1 | 0x400;\n  i2cHandle->Instance->controlRegister2 = i2cHandle->Instance->controlRegister2 | 0x300;\n  return HAL_I2C_OK;\n}\n\n",
            "renaming": {
                "FUN_08001578": "initialize_i2_c_08001578",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_BUSY": "HAL_I2C_BUSY",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "I2C_TypeDef": "I2C_Struct",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "HAL_OK": "HAL_I2C_OK"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "process_i2_c_transfer_080015bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CTransfer_080015bc(I2C_HandleTypeDef *i2cHandler)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  byte *bufferPtr;\n  \n  currentState = i2cHandler->State;\n  if (i2cHandler->XferCount != 0) {\n    bufferPtr = i2cHandler->pBuffPtr;\n    i2cHandler->pBuffPtr = bufferPtr + 1;\n    i2cHandler->Instance->DR = (uint)*bufferPtr;\n    i2cHandler->XferCount = i2cHandler->XferCount - 1;\n    if ((i2cHandler->XferCount == 0) && (currentState == HAL_I2C_STATE_TRANSMITTING_LISTENING)) {\n      i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 & 0xfffffbff;\n      i2cHandler->PreviousState = 0x21;\n      i2cHandler->State = HAL_I2C_STATE_LISTENING;\n      handleSlaveTransmitComplete(i2cHandler);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "process_i2_c_transfer_080015bc",
                "hi2c": "i2cHandler",
                "HVar1": "currentState",
                "pbVar2": "bufferPtr",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_TRANSMITTING_LISTENING",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTENING",
                "HAL_I2C_SlaveTxCpltCallback": "handleSlaveTransmitComplete"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_SlaveReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "process_i2_c_data_0800160e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHALStatus processI2CData_0800160e(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  uint8_t *bufferPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    bufferPointer = i2cHandle->dataBufferPointer;\n    i2cHandle->dataBufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->DR;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentState == HAL_I2C_STATE_RX_LISTEN)) {\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n      i2cHandle->previousState = 0x22;\n      i2cHandle->State = HAL_I2C_STATE_RX_COMPLETE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "process_i2_c_data_0800160e",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "bufferPointer",
                "HAL_I2C_StateTypeDef": "I2CState",
                "HAL_StatusTypeDef": "HALStatus",
                "XferCount": "transferCount",
                "pBuffPtr": "dataBufferPointer",
                "Instance": "i2cInstance",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "HAL_I2C_STATE_RX_LISTEN",
                "CR2": "controlRegister2",
                "PreviousState": "previousState",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_RX_COMPLETE"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "handle_addr_match_code_0800165a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleAddrMatchCode_0800165a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t matchCode;\n  \n  if ((i2cHandle->instance->statusRegister2 & 0x80) == 0) {\n    matchCode = *(uint16_t *)&(i2cHandle->i2cInit).ownAddress1;\n  }\n  else {\n    matchCode = *(uint16_t *)&(i2cHandle->i2cInit).ownAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->instance->statusRegister2 & 4) == 0,matchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "handle_addr_match_code_0800165a",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "matchCode",
                "Instance": "instance",
                "SR2": "statusRegister2",
                "Init": "i2cInit",
                "OwnAddress1": "ownAddress1",
                "OwnAddress2": "ownAddress2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "clear_i2_c_state_08001684",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef clearI2CState_08001684(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001684": "clear_i2_c_state_08001684",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "update_i2_c_state_and_options_0800171a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nstatus updateI2CStateAndOptions_0800171a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  state currentState;\n  uint32_t currentI2CState;\n  byte *bufferPointer;\n  uint32_t currentXferOptions;\n  uint32_t handleXferOptions;\n  \n  currentState = i2cHandle->State;\n  handleXferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == I2C_STATE_BUSY_TX)) {\n    if ((handleXferOptions == 4) || ((handleXferOptions == 8 || (handleXferOptions == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = I2C_STATE_READY;\n      if (i2cHandle->Mode == I2C_MODE_MEM) {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        memTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        masterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = I2C_MODE_NONE;\n      i2cHandle->State = I2C_STATE_READY;\n      masterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->Mode == I2C_MODE_MEM && (currentState == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == I2C_MODE_MEM) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == I2C_STATE_BUSY_TX) {\n          bufferPointer = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPointer + 1;\n          i2cHandle->Instance->DR = (uint)*bufferPointer;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "update_i2_c_state_and_options_0800171a",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "bufferPointer",
                "CurrentXferOptions": "currentXferOptions",
                "uVar3": "handleXferOptions",
                "HAL_StatusTypeDef": "status",
                "HAL_I2C_StateTypeDef": "state",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MasterTxCpltCallback": "masterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback": "memTxCpltCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "transfer_data_08001864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferData_08001864(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001864": "transfer_data_08001864",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "process_i2_c_rx_data_08001904",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus processI2CRxData_08001904(I2C_HandleTypeDef *CBTBGBdataRegisterVW)\n\n{\n  uint8_t *buffer;\n  \n  if (CBTBGBdataRegisterVW->State == I2C_STATE_BUSY_RECEIVING) {\n    if (CBTBGBdataRegisterVW->transferCount < 4) {\n      if (CBTBGBdataRegisterVW->transferCount < 2) {\n        CBTBGBdataRegisterVW->i2cInstance->controlRegister1 = CBTBGBdataRegisterVW->i2cInstance->controlRegister1 & 0xfffffbff;\n        CBTBGBdataRegisterVW->i2cInstance->controlRegister2 = CBTBGBdataRegisterVW->i2cInstance->controlRegister2 & 0xfffff8ff;\n        buffer = CBTBGBdataRegisterVW->dataBufferPointer;\n        CBTBGBdataRegisterVW->dataBufferPointer = buffer + 1;\n        *buffer = (uint8_t)CBTBGBdataRegisterVW->i2cInstance->dataRegister;\n        CBTBGBdataRegisterVW->transferCount = CBTBGBdataRegisterVW->transferCount - 1;\n        CBTBGBdataRegisterVW->State = I2C_STATE_READY;\n        CBTBGBdataRegisterVW->previousState = 0;\n        if (CBTBGBdataRegisterVW->Mode == I2C_MODE_MEMORY) {\n          CBTBGBdataRegisterVW->Mode = I2C_MODE_NONE;\n          MemReceiveCompleteCallback(CBTBGBdataRegisterVW);\n        }\n        else {\n          CBTBGBdataRegisterVW->Mode = I2C_MODE_NONE;\n          MasterReceiveCompleteCallback(CBTBGBdataRegisterVW);\n        }\n      }\n    }\n    else {\n      buffer = CBTBGBdataRegisterVW->dataBufferPointer;\n      CBTBGBdataRegisterVW->dataBufferPointer = buffer + 1;\n      *buffer = (uint8_t)CBTBGBdataRegisterVW->i2cInstance->dataRegister;\n      CBTBGBdataRegisterVW->transferCount = CBTBGBdataRegisterVW->transferCount - 1;\n      if (CBTBGBdataRegisterVW->transferCount == 3) {\n        CBTBGBdataRegisterVW->i2cInstance->controlRegister2 = CBTBGBdataRegisterVW->i2cInstance->controlRegister2 & 0xfffffbff;\n      }\n    }\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08001904": "process_i2_c_rx_data_08001904",
                "hi2c": "i2cHandler",
                "puVar1": "buffer",
                "HAL_StatusTypeDef": "Status",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RECEIVING",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_OK": "OK",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "XferCount": "transferCount",
                "pBuffPtr": "dataBufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "PreviousState": "previousState",
                "HAL_I2C_MemRxCpltCallback": "MemReceiveCompleteCallback",
                "HAL_I2C_MasterRxCpltCallback": "MasterReceiveCompleteCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "process_i2_c_data_080019a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CData_080019a0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->transferCount == 4) {\n    i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 3) {\n    i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n    i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 2) {\n    if (i2cHandle->transferOptions - 1 < 2) {\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x100;\n    }\n    else {\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x200;\n    }\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffcff;\n    i2cHandle->i2cState = HAL_I2C_STATE_READY;\n    i2cHandle->previousState = 0;\n    if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "process_i2_c_data_080019a0",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar1": "bufferPtr",
                "Instance": "i2cInstance",
                "CR2": "controlRegister2",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "DR": "dataRegister",
                "CR1": "controlRegister1",
                "XferOptions": "transferOptions",
                "State": "i2cState",
                "PreviousState": "previousState",
                "Mode": "i2cMode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "handle_i2_c_state_08001ab0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *bufferPointer;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPointer = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPointer + 1;\n        *bufferPointer = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPointer = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPointer + 1;\n        *bufferPointer = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          bufferPointer = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPointer + 1;\n          *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "handle_i2_c_state_08001ab0",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "bufferPointer",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "handle_i2_c_transfer_08001bfc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CTransfer_08001bfc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *ptrBuff;\n  uint32_t state;\n  uint32_t temporaryRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->NDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->NDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      ptrBuff = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = ptrBuff + 1;\n      *ptrBuff = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      ptrBuff = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = ptrBuff + 1;\n      *ptrBuff = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "handle_i2_c_transfer_08001bfc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "ptrBuff",
                "CurrentState": "state",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "handle_i2_c_events_08001d00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08001d00(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CPeriph *i2cPeriph;\n  uint32_t currentMode;\n  uint statusRegister1;\n  uint32_t sr1ITFlags;\n  uint controlRegister2;\n  uint32_t itSources;\n  uint statusRegister2;\n  uint32_t sr2itflags;\n  \n  i2cPeriph = i2cHandle->Instance;\n  statusRegister2 = i2cPeriph->SR2;\n  statusRegister1 = i2cPeriph->SR1;\n  controlRegister2 = i2cPeriph->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusRegister1 & 0x10001) == 0) || ((controlRegister2 & 0x200) == 0)) {\n      if (((statusRegister1 & 0x10008) == 0) || ((controlRegister2 & 0x200) == 0)) {\n        if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((statusRegister1 & 0x10010) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "handle_i2_c_events_08001d00",
                "hi2c": "i2cHandle",
                "I2C_TypeDef": "I2CPeriph",
                "pIVar1": "i2cPeriph",
                "CurrentMode": "currentMode",
                "uVar2": "statusRegister1",
                "sr1itflags": "sr1ITFlags",
                "uVar3": "controlRegister2",
                "itsources": "itSources",
                "uVar4": "statusRegister2"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler",
                "I2C3_EV_IRQHandler"
            ],
            "called": [
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_Master_SB",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_ADDR",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "check_i2_c_status_08001e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkI2CStatus_08001e68(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t sr1ITFlags;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "check_i2_c_status_08001e68",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "sr1ITFlags",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C3_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f3c": {
            "entrypoint": "0x08001f3c",
            "current_name": "reset_i2_c_state_08001f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CState_08001f3c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandle;\n  I2C_HandleTypeDef *currentI2CHandle;\n  \n  i2cHandle = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cHandle->XferCount = 0;\n  i2cHandle->dmaHandletx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  i2cHandle->dmaHandlerx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (i2cHandle->State != HAL_I2C_STATE_ABORT) {\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    HAL_I2C_ErrorCallback(i2cHandle);\n    return;\n  }\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f3c": "reset_i2_c_state_08001f3c",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandle",
                "hi2c": "currentI2CHandle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "wait_for_flag_08001f9c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForFlag_08001f9c(void)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t tmpreg;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  startTime = HAL_GetTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      startTime = HAL_GetTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return HAL_OK;\n        }\n        currentTime = HAL_GetTick();\n      } while (currentTime - startTime < 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 0x3e9);\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "wait_for_flag_08001f9c",
                "uVar1": "startTime",
                "uVar2": "currentTime"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "configure_rcc_oscillator_0800201c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nStatus configureRCCOscillator_0800201c(RCC_OscInitTypeDef_conflict *oscillatorConfig)\n\n{\n  Status HVar1;\n  uint32_t tickstart;\n  uint32_t currentTick;\n  uint32_t tickstart;\n  bool isLSEDisabled;\n  uint32_t tempRegister;\n  \n  if (oscillatorConfig == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return ERROR;\n  }\n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (oscillatorConfig->HSEState == 0)) {\n        return ERROR;\n      }\n    }\n    else {\n      if (oscillatorConfig->HSEState == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (oscillatorConfig->HSEState == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (oscillatorConfig->HSEState == 0) {\n        tickstart = getTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          currentTick = getTick();\n          if (100 < currentTick - tickstart) {\n            return TIMEOUT;\n          }\n        }\n      }\n      else {\n        tickstart = getTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          currentTick = getTick();\n          if (100 < currentTick - tickstart) {\n            return TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return ERROR;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42470000 = 0;\n      tickstart = getTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        currentTick = getTick();\n        if (2 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      tickstart = getTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        currentTick = getTick();\n        if (2 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      tickstart = getTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        currentTick = getTick();\n        if (2 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      tickstart = getTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        currentTick = getTick();\n        if (2 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    isLSEDisabled = (_DAT_40023840 & 0x10000000) == 0;\n    if (isLSEDisabled) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      tickstart = getTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = getTick();\n        if (2 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n    }\n    if (oscillatorConfig->LSEState == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (oscillatorConfig->LSEState == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (oscillatorConfig->LSEState == 0) {\n      tickstart = getTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        currentTick = getTick();\n        if (5000 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n    }\n    else {\n      tickstart = getTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        currentTick = getTick();\n        if (5000 < currentTick - tickstart) {\n          return TIMEOUT;\n        }\n      }\n    }\n    if (isLSEDisabled) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  tickstart = (oscillatorConfig->PLL).PLLState;\n  if (tickstart == 0) {\n    HVar1 = HAL_OK;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    HVar1 = ERROR;\n  }\n  else if (tickstart == 2) {\n    _DAT_42470060 = 0;\n    tickstart = getTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             (oscillatorConfig->PLL).PLLSource | (oscillatorConfig->PLL).PLLM |\n             (oscillatorConfig->PLL).PLLN << 6 |\n             (((oscillatorConfig->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (oscillatorConfig->PLL).PLLQ << 0x18;\n        _DAT_42470060 = 1;\n        tickstart = getTick();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTick = getTick();\n        } while (currentTick - tickstart < 3);\n        return TIMEOUT;\n      }\n      currentTick = getTick();\n    } while (currentTick - tickstart < 3);\n    HVar1 = TIMEOUT;\n  }\n  else {\n    _DAT_42470060 = 0;\n    tickstart = getTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTick = getTick();\n    } while (currentTick - tickstart < 3);\n    HVar1 = TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "configure_rcc_oscillator_0800201c",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HAL_StatusTypeDef": "Status",
                "uVar2": "tickstart",
                "uVar3": "currentTick",
                "bVar4": "isLSEDisabled",
                "tmpreg": "tempRegister",
                "HAL_ERROR": "ERROR",
                "HAL_TIMEOUT": "TIMEOUT",
                "HAL_GetTick": "getTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "get_system_clock_frequency_080023b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_system_clock_frequency_080023b4(void)\n\n{\n  uint calculated_frequency;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    calculated_frequency = (_DAT_40023804 << 0x11) >> 0x17;\n    calculated_frequency = __aeabi_uldivmod(calculated_frequency * 16000000,\n                             (((uint)(calculated_frequency * 0x20 < calculated_frequency) * -0x3f -\n                              (uint)(calculated_frequency * 0x7c0 < calculated_frequency * 0x1f)) * 8 +\n                             (uint)CARRY4(calculated_frequency * 0x3d08,calculated_frequency)) * 0x400 | calculated_frequency * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0);\n  }\n  else {\n    calculated_frequency = (_DAT_40023804 << 0x11) >> 0x17;\n    calculated_frequency = __aeabi_uldivmod(calculated_frequency * 8000000,\n                             (((uint)(calculated_frequency * 0x20 < calculated_frequency) * -0x3f -\n                              (uint)(calculated_frequency * 0x7c0 < calculated_frequency * 0x1f)) * 8 +\n                             (uint)CARRY4(calculated_frequency * 0x3d08,calculated_frequency)) * 0x200,_DAT_40023804 & 0x3f,0);\n  }\n  return calculated_frequency / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "get_system_clock_frequency_080023b4",
                "uVar1": "calculated_frequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "set_system_clock_08002488",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setSystemClock_08002488(ClockInitTypeDef *clkInitStruct,uint32_t latency)\n\n{\n  uint32_t var1;\n  uint32_t var2;\n  uint var3;\n  uint32_t tickStart;\n  \n  if (clkInitStruct == (ClockInitTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((_DAT_40023c00 & 0xf) < latency) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)latency), latency != (latency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clkInitStruct->ClockType & 2) != 0) {\n    if ((clkInitStruct->ClockType & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((clkInitStruct->ClockType & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | clkInitStruct->AHBCLKDivider;\n  }\n  if ((clkInitStruct->ClockType & 1) != 0) {\n    var3 = clkInitStruct->SYSCLKSource;\n    if (var3 == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (var3 - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return HAL_ERROR;\n    }\n    _DAT_40023808 = var3 | _DAT_40023808 & 0xfffffffc;\n    var1 = HAL_GetTick();\n    while ((_DAT_40023808 & 0xc) != clkInitStruct->SYSCLKSource * 4) {\n      var2 = HAL_GetTick();\n      if (5000 < var2 - var1) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((latency < (_DAT_40023c00 & 0xf)) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)latency), latency != (latency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clkInitStruct->ClockType & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | clkInitStruct->APB1CLKDivider;\n  }\n  if ((clkInitStruct->ClockType & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | clkInitStruct->APB2CLKDivider << 3;\n  }\n  var1 = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = var1 >> \"\"[(_DAT_40023808 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002488": "set_system_clock_08002488",
                "RCC_ClkInitTypeDef_conflict": "ClockInitTypeDef",
                "RCC_ClkInitStruct": "clkInitStruct",
                "FLatency": "latency",
                "uVar1": "var1",
                "uVar2": "var2",
                "uVar3": "var3",
                "tickstart": "tickStart"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_system_core_clock_080025e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_080025e0(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_system_core_clock_080025e0",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_adjusted_hclk_freq_080025ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_080025ec(void)\n\n{\n  uint32_t adjustedHCLKFreq;\n  \n  adjustedHCLKFreq = HAL_RCC_GetHCLKFreq();\n  return adjustedHCLKFreq >> \"\"[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_adjusted_hclk_freq_080025ec",
                "uVar1": "adjustedHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_hclk_frequency_0800260c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_0800260c(void)\n\n{\n  uint32_t frequency;\n  \n  frequency = get_RCC_HCLK_frequency();\n  return frequency >> \"\"[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_hclk_frequency_0800260c",
                "uVar1": "frequency",
                "HAL_RCC_GetHCLKFreq": "get_RCC_HCLK_frequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "process_rtc_interrupts_0800262c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid process_RTC_interrupts_0800262c(RTC_HandleTypeDef *RTC_handler)\n\n{\n  if (((RTC_handler->Instance->ISR & 0x100) != 0) && ((RTC_handler->Instance->CR & 0x1000) != 0)) {\n    handle_RTC_AlarmA_Event(RTC_handler);\n    RTC_handler->Instance->ISR = RTC_handler->Instance->ISR & 0xff | 0xfffffe7f;\n  }\n  if (((RTC_handler->Instance->ISR & 0x200) != 0) && ((RTC_handler->Instance->CR & 0x2000) != 0)) {\n    handle_RTC_AlarmB_Event(RTC_handler);\n    RTC_handler->Instance->ISR = RTC_handler->Instance->ISR & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  RTC_handler->State = RTC_HANDLER_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "process_rtc_interrupts_0800262c",
                "hrtc": "RTC_handler",
                "HAL_RTC_AlarmAEventCallback": "handle_RTC_AlarmA_Event",
                "HAL_RTCEx_AlarmBEventCallback": "handle_RTC_AlarmB_Event",
                "HAL_RTC_STATE_READY": "RTC_HANDLER_STATE_READY"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "reset_timer_0800268e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimer_0800268e(TIM_HandleTypeDef *timer)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "reset_timer_0800268e",
                "htim": "timer",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "process_tim_irq_handler_080026ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_TIM_IRQHandler_080026ce(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_TypeDef *timer_instance;\n  \n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 2) != 0) && ((timer_instance->interrupt_enable_reg & 2) != 0)) {\n    timer_instance->status_register = 0xfffffffd;\n    timer_handle->current_channel = CHANNEL_1;\n    if ((timer_handle->TIMx->CCMR1 & 3) == 0) {\n      handle_OC_DelayElapsed(timer_handle);\n      handle_PWM_PulseFinished(timer_handle);\n    }\n    else {\n      handle_IC_Capture(timer_handle);\n    }\n    timer_handle->current_channel = CHANNEL_CLEARED;\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 4) != 0) && ((timer_instance->interrupt_enable_reg & 4) != 0)) {\n    timer_instance->status_register = 0xfffffffb;\n    timer_handle->current_channel = CHANNEL_2;\n    if ((timer_handle->TIMx->CCMR1 & 0x300) == 0) {\n      handle_OC_DelayElapsed(timer_handle);\n      handle_PWM_PulseFinished(timer_handle);\n    }\n    else {\n      handle_IC_Capture(timer_handle);\n    }\n    timer_handle->current_channel = CHANNEL_CLEARED;\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 8) != 0) && ((timer_instance->interrupt_enable_reg & 8) != 0)) {\n    timer_instance->status_register = 0xfffffff7;\n    timer_handle->current_channel = CHANNEL_3;\n    if ((timer_handle->TIMx->CCMR2 & 3) == 0) {\n      handle_OC_DelayElapsed(timer_handle);\n      handle_PWM_PulseFinished(timer_handle);\n    }\n    else {\n      handle_IC_Capture(timer_handle);\n    }\n    timer_handle->current_channel = CHANNEL_CLEARED;\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 0x10) != 0) && ((timer_instance->interrupt_enable_reg & 0x10) != 0)) {\n    timer_instance->status_register = 0xffffffef;\n    timer_handle->current_channel = CHANNEL_4;\n    if ((timer_handle->TIMx->CCMR2 & 0x300) == 0) {\n      handle_OC_DelayElapsed(timer_handle);\n      handle_PWM_PulseFinished(timer_handle);\n    }\n    else {\n      handle_IC_Capture(timer_handle);\n    }\n    timer_handle->current_channel = CHANNEL_CLEARED;\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 1) != 0) && ((timer_instance->interrupt_enable_reg & 1) != 0)) {\n    timer_instance->status_register = 0xfffffffe;\n    handle_PeriodElapsed(timer_handle);\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 0x80) != 0) && ((timer_instance->interrupt_enable_reg & 0x80) != 0)) {\n    timer_instance->status_register = 0xffffff7f;\n    handle_Break(timer_handle);\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 0x40) != 0) && ((timer_instance->interrupt_enable_reg & 0x40) != 0)) {\n    timer_instance->status_register = 0xffffffbf;\n    handle_Trigger(timer_handle);\n  }\n  timer_instance = timer_handle->TIMx;\n  if (((timer_instance->status_register & 0x20) != 0) && ((timer_instance->interrupt_enable_reg & 0x20) != 0)) {\n    timer_instance->status_register = 0xffffffdf;\n    handle_Commutation(timer_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "process_tim_irq_handler_080026ce",
                "htim": "timer_handle",
                "pTVar1": "timer_instance",
                "Instance": "TIMx",
                "SR": "status_register",
                "DIER": "interrupt_enable_reg",
                "Channel": "current_channel",
                "HAL_TIM_ACTIVE_CHANNEL_1": "CHANNEL_1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "CHANNEL_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "CHANNEL_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "CHANNEL_4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "CHANNEL_CLEARED",
                "HAL_TIM_OC_DelayElapsedCallback": "handle_OC_DelayElapsed",
                "HAL_TIM_PWM_PulseFinishedCallback": "handle_PWM_PulseFinished",
                "HAL_TIM_IC_CaptureCallback": "handle_IC_Capture",
                "HAL_TIM_PeriodElapsedCallback": "handle_PeriodElapsed",
                "HAL_TIMEx_BreakCallback": "handle_Break",
                "HAL_TIM_TriggerCallback": "handle_Trigger",
                "HAL_TIMEx_CommutationCallback": "handle_Commutation"
            },
            "calling": [
                "TIM3_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_UP_TIM10_IRQHandler",
                "TIM2_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM7_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "set_channel_state_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setChannelState_08002848(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = timer->CCER | newState << (channelNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "set_channel_state_08002848",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "newState"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "configure_timer_channel_08002864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_08002864(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  bool isInstanceValid;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,0);\n  timerInstance = timerHandle->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40010000) {\n    isInstanceValid = true;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40010400) {\n    isInstanceValid = true;\n  }\n  else {\n    isInstanceValid = false;\n  }\n  if (((isInstanceValid) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002864": "configure_timer_channel_08002864",
                "htim": "timerHandle",
                "Channel": "channel",
                "bVar1": "isInstanceValid",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "configure_timer_channel_080028d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerChannel_080028d4(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "configure_timer_channel_080028d4",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channelState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "disable_timer_channel_080028f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTimerChannel_080028f0(TIM_HandleTypeDef *timer,uint32_t channel)\n\n{\n  TimerType *timerInstance;\n  \n  TIM_CCxNchannelCmd(timer->Instance,channel,0);\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "disable_timer_channel_080028f0",
                "htim": "timer",
                "Channel": "channel",
                "TIM_TypeDef": "TimerType",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "reset_uart_instance_08002940",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_UART_instance_08002940(UART_HandleTypeDef *UART_handle)\n\n{\n  UART_handle->Instance->control_register_1 = UART_handle->Instance->control_register_1 & 0xfffffedf;\n  UART_handle->Instance->control_register_3 = UART_handle->Instance->control_register_3 & 0xfffffffe;\n  UART_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "reset_uart_instance_08002940",
                "huart": "UART_handle",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "transmit_data_0800295c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transmitData_0800295c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t remainingDataCount;\n  byte *dataPointer;\n  uint16_t *temporaryPointer;\n  \n  if (uartHandle->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    uartHandle->Instance->DR = *(ushort *)uartHandle->pTxBuffPtr & 0x1ff;\n    if ((uartHandle->Init).Parity == 0) {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    dataPointer = uartHandle->pTxBuffPtr;\n    uartHandle->pTxBuffPtr = dataPointer + 1;\n    uartHandle->Instance->DR = (uint)*dataPointer;\n  }\n  remainingDataCount = uartHandle->TxXferCount - 1;\n  uartHandle->TxXferCount = remainingDataCount;\n  if (remainingDataCount == 0) {\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffff7f;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "transmit_data_0800295c",
                "huart": "uartHandle",
                "uVar1": "remainingDataCount",
                "pbVar2": "dataPointer",
                "tmp": "temporaryPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "configure_uart_080029c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUART_080029c8(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t pclk1;\n  uint32_t pclk1;\n  uint32_t pclk1;\n  uint32_t pclk1;\n  uint32_t pclk1;\n  uint32_t baudRate;\n  uint32_t baudRate;\n  uint32_t baudRate;\n  uint32_t baudRate;\n  USART_TypeDef *usartInstance;\n  \n  uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffcfff | (uartHandle->Init).StopBits;\n  uartHandle->Instance->CR1 =\n       uartHandle->Instance->CR1 & 0xffff69f3 |\n       (uartHandle->Init).WordLength | (uartHandle->Init).Parity | (uartHandle->Init).Mode |\n       (uartHandle->Init).OverSampling;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffcff | (uartHandle->Init).HwFlowCtl;\n  if ((uartHandle->Init).OverSampling == 0x8000) {\n    usartInstance = uartHandle->Instance;\n    if ((usartInstance != (USART_TypeDef *)0x40011000) && (usartInstance != (USART_TypeDef *)0x40011400)) {\n      pclk1 = HAL_RCC_GetPCLK1Freq();\n      baudRate = (uartHandle->Init).BaudRate;\n      pclk1 = HAL_RCC_GetPCLK1Freq();\n      baudRate = (uartHandle->Init).BaudRate;\n      pclk1 = HAL_RCC_GetPCLK1Freq();\n      baudRate = (uartHandle->Init).BaudRate;\n      pclk1 = HAL_RCC_GetPCLK1Freq();\n      baudRate = (uartHandle->Init).BaudRate;\n      pclk1 = HAL_RCC_GetPCLK1Freq();\n      usartInstance->BRR = ((uint)((int)((ulonglong)\n                                   (((pclk1 * 0x19) / (baudRate << 1) +\n                                    (int)(((ulonglong)(pclk1 * 0x19) /\n                                          (ulonglong)((uartHandle->Init).BaudRate << 1)) / 100) * -100) *\n                                    8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                     ((((pclk1 * 0x19) / (baudRate << 1) +\n                       (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 1)) / 100) * -100) *\n                       8 + 0x32) / 100 & 0xf8) * 2 +\n                     (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 1)) / 100) * 0x10;\n      return;\n    }\n    pclk1 = HAL_RCC_GetPCLK2Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK2Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK2Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK2Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK2Freq();\n    usartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk1 * 0x19) / (baudRate << 1) +\n                                  (int)(((ulonglong)(pclk1 * 0x19) /\n                                        (ulonglong)((uartHandle->Init).BaudRate << 1)) / 100) * -100) * 8\n                                 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                   ((((pclk1 * 0x19) / (baudRate << 1) +\n                     (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 1)) / 100) * -100) * 8\n                    + 0x32) / 100 & 0xf8) * 2 +\n                   (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 1)) / 100) * 0x10;\n    return;\n  }\n  usartInstance = uartHandle->Instance;\n  if ((usartInstance != (USART_TypeDef *)0x40011000) && (usartInstance != (USART_TypeDef *)0x40011400)) {\n    pclk1 = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandle->Init).BaudRate;\n    pclk1 = HAL_RCC_GetPCLK1Freq();\n    usartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk1 * 0x19) / (baudRate << 2) +\n                                  (int)(((ulonglong)(pclk1 * 0x19) /\n                                        (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclk1 * 0x19) / (baudRate << 2) +\n                     (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk1 = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  pclk1 = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  pclk1 = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  pclk1 = HAL_RCC_GetPCLK2Freq();\n  baudRate = (uartHandle->Init).BaudRate;\n  pclk1 = HAL_RCC_GetPCLK2Freq();\n  usartInstance->BRR = ((uint)((int)((ulonglong)\n                               (((pclk1 * 0x19) / (baudRate << 2) +\n                                (int)(((ulonglong)(pclk1 * 0x19) /\n                                      (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclk1 * 0x19) / (baudRate << 2) +\n                   (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclk1 * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "configure_uart_080029c8",
                "huart": "uartHandle",
                "uVar1": "pclk1",
                "uVar2": "pclk1",
                "uVar3": "pclk1",
                "uVar4": "pclk1",
                "uVar5": "pclk1",
                "uVar6": "baudRate",
                "uVar7": "baudRate",
                "uVar8": "baudRate",
                "uVar9": "baudRate",
                "pUVar10": "usartInstance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_flag_status_08002d0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_expectedStatusTypeDef\ncheckFlagStatus_08002d0c(UART_HandleTypeDef *uartHandle,uint32_t desiredFlag,desiredFlagexpectedStatus expectedStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((desiredFlag & ~uartHandle->Instance->SR) == 0) != (bool)expectedStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_flag_status_08002d0c",
                "huart": "uartHandle",
                "Flag": "desiredFlag",
                "Status": "expectedStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUart_08002d72(UartHandleTypeDef *uartHandle)\n\n{\n  if (uartHandle != (UartHandleTypeDef *)0x0) {\n    if (uartHandle->globalState == uartStateReset) {\n      uartHandle->lock = unlocked;\n      uartMspInit(uartHandle);\n    }\n    uartHandle->globalState = uartStateBusy;\n    uartHandle->instance->controlRegister1 = uartHandle->instance->controlRegister1 & 0xffffdfff;\n    setUartConfig(uartHandle);\n    uartHandle->instance->controlRegister2 = uartHandle->instance->controlRegister2 & 0xffffb7ff;\n    uartHandle->instance->controlRegister3 = uartHandle->instance->controlRegister3 & 0xffffffd5;\n    uartHandle->instance->controlRegister1 = uartHandle->instance->controlRegister1 | 0x2000;\n    uartHandle->errorCode = 0;\n    uartHandle->globalState = uartStateReady;\n    uartHandle->receiveState = uartStateReady;\n    return halOk;\n  }\n  return halError;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "huart": "uartHandle",
                "UART_HandleTypeDef": "UartHandleTypeDef",
                "gState": "globalState",
                "HAL_UART_STATE_RESET": "uartStateReset",
                "Lock": "lock",
                "HAL_UNLOCKED": "unlocked",
                "HAL_UART_MspInit": "uartMspInit",
                "Instance": "instance",
                "CR1": "controlRegister1",
                "UART_SetConfig": "setUartConfig",
                "CR2": "controlRegister2",
                "CR3": "controlRegister3",
                "HAL_UART_STATE_BUSY": "uartStateBusy",
                "HAL_UART_STATE_READY": "uartStateReady",
                "ErrorCode": "errorCode",
                "RxState": "receiveState",
                "HAL_OK": "halOk",
                "HAL_ERROR": "halError"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "transmit_data_08002dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_08002dd0(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint16_t *tmpBuffer;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      startTick = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,startTick,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,startTick,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,startTick,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "transmit_data_08002dd0",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTick",
                "tmp": "tmpBuffer"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "initialize_uart_transmission_08002eb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUartTransmission_08002eb2(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "initialize_uart_transmission_08002eb2",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "initialize_uart_receive_08002efa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUARTReceive_08002efa(UART_HandleTypeDef *uartHandle,uint8_t *receiveBuffer,uint16_t bufferSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receiveBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = receiveBuffer;\n    uartHandle->RxXferbufferSize = bufferSize;\n    uartHandle->RxXferCount = bufferSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "initialize_uart_receive_08002efa",
                "huart": "uartHandle",
                "pData": "receiveBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "reset_uart_state_08002f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetUartState_08002f4c(UART_HandleTypeDef *uartHandle)\n\n{\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffffbf;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "reset_uart_state_08002f4c",
                "huart": "uartHandle"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "receive_data_08002f66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef receive_data_08002f66(UART_HandleTypeDef *uart_handle)\n\n{\n  uint16_t *temp;\n  byte *byte_ptr;\n  uint16_t count;\n  uint8_t *ptr;\n  \n  if (uart_handle->rx_state != HAL_UART_StateTypeDef.BUSY_RX) {\n    return HAL_StatusTypeDef.BUSY;\n  }\n  if ((uart_handle->uart_init).word_length == 0x1000) {\n    if ((uart_handle->uart_init).parity == 0) {\n      *(ushort *)uart_handle->rx_buffer_ptr = (ushort)((uart_handle->instance->data_register << 0x17) >> 0x17);\n      uart_handle->rx_buffer_ptr = uart_handle->rx_buffer_ptr + 2;\n    }\n    else {\n      *(ushort *)uart_handle->rx_buffer_ptr = (ushort)uart_handle->instance->data_register & 0xff;\n      uart_handle->rx_buffer_ptr = uart_handle->rx_buffer_ptr + 1;\n    }\n  }\n  else if ((uart_handle->uart_init).parity == 0) {\n    ptr = uart_handle->rx_buffer_ptr;\n    uart_handle->rx_buffer_ptr = ptr + 1;\n    *ptr = (uint8_t)uart_handle->instance->data_register;\n  }\n  else {\n    byte_ptr = uart_handle->rx_buffer_ptr;\n    uart_handle->rx_buffer_ptr = byte_ptr + 1;\n    *byte_ptr = (byte)uart_handle->instance->data_register & 0x7f;\n  }\n  count = uart_handle->rx_transfer_count - 1;\n  uart_handle->rx_transfer_count = count;\n  if (count != 0) {\n    return HAL_StatusTypeDef.OK;\n  }\n  uart_handle->instance->control_register_1 = uart_handle->instance->control_register_1 & 0xfffffedf;\n  uart_handle->instance->control_register_3 = uart_handle->instance->control_register_3 & 0xfffffffe;\n  uart_handle->rx_state = HAL_UART_StateTypeDef.READY;\n  uart_receive_complete_callback(uart_handle);\n  return HAL_StatusTypeDef.OK;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "receive_data_08002f66",
                "huart": "uart_handle",
                "tmp": "temp",
                "pbVar1": "byte_ptr",
                "uVar2": "count",
                "puVar3": "ptr",
                "HAL_BUSY": "HAL_StatusTypeDef.BUSY",
                "HAL_OK": "HAL_StatusTypeDef.OK",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_StateTypeDef.BUSY_RX",
                "HAL_UART_STATE_READY": "HAL_UART_StateTypeDef.READY",
                "Instance": "instance",
                "DR": "data_register",
                "pRxBuffPtr": "rx_buffer_ptr",
                "RxState": "rx_state",
                "Init": "uart_init",
                "WordLength": "word_length",
                "Parity": "parity",
                "RxXferCount": "rx_transfer_count",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "HAL_UART_RxCpltCallback": "uart_receive_complete_callback"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "handle_uart_status_08002ffc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_status_08002ffc(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef hal_status;\n  uint cr1;\n  uint32_t cr1its;\n  USART_TypeDef *usart_instance;\n  uint32_t cr3its;\n  uint cr3;\n  uint sr;\n  uint32_t interrupt_flags;\n  \n  usart_instance = uart_handle->Instance;\n  sr = usart_instance->SR;\n  cr1 = usart_instance->CR1;\n  if ((((sr & 0xf) == 0) && ((sr & 0x20) != 0)) && ((cr1 & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n  if (((sr & 0xf) == 0) || ((cr3 = usart_instance->CR3 & 1, cr3 == 0 && ((cr1 & 0x120) == 0)))) {\n    if (((sr & 0x80) != 0) && ((cr1 & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n    if (((sr & 0x40) != 0) && ((cr1 & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr & 1) != 0) && ((cr1 & 0x100) != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 1;\n    }\n    if (((sr & 4) != 0) && (cr3 != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n    }\n    if (((sr & 2) != 0) && (cr3 != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n    }\n    if (((sr & 8) != 0) && (cr3 != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n    }\n    if (uart_handle->ErrorCode != 0) {\n      if (((sr & 0x20) != 0) && ((cr1 & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      if (((uart_handle->ErrorCode & 8) == 0) && ((uart_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handle);\n      usart_instance = uart_handle->Instance;\n      if ((usart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      usart_instance->CR3 = usart_instance->CR3 & 0xffffffbf;\n      if (uart_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      hal_status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n      if (hal_status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "handle_uart_status_08002ffc",
                "huart": "uart_handle",
                "HVar1": "hal_status",
                "uVar2": "cr1",
                "uVar5": "sr",
                "uVar4": "cr3",
                "isrflags": "interrupt_flags",
                "pUVar3": "usart_instance"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800311c": {
            "entrypoint": "0x0800311c",
            "current_name": "handle_dma_transfer_error_0800311c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_DMA_transfer_error_0800311c(DMA_HandleTypeDef *dma_handle)\n\n{\n  UART_HandleTypeDef *parent_uart_handle;\n  UART_HandleTypeDef *current_uart_handle;\n  \n  parent_uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  parent_uart_handle->RxXferCount = 0;\n  parent_uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(parent_uart_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800311c": "handle_dma_transfer_error_0800311c",
                "hdma": "dma_handle",
                "huart_00": "parent_uart_handle",
                "huart": "current_uart_handle"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "get_combined_uart_state_0800312c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef get_combined_uart_state_0800312c(UART_HandleTypeDef *uart_handle)\n\n{\n  return uart_handle->receive_state | uart_handle->global_state;\n}\n\n",
            "renaming": {
                "FUN_0800312c": "get_combined_uart_state_0800312c",
                "huart": "uart_handle",
                "RxState": "receive_state",
                "gState": "global_state"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "check_pin_status_08003138",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinStatus_08003138(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinStatus;\n  \n  pinStatus = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinStatus >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08003138": "check_pin_status_08003138",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinStatus"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "set_pin_mapping_0800314e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinMapping_0800314e(pinName pin,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t unshiftedIndex;\n  \n  shiftedIndex = (uint)((int)pin << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "set_pin_mapping_0800314e",
                "PinName_conflict": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex",
                "index": "unshiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "update_map_entry_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMapEntry_0800316c(pinName pin,uint32_t *map)\n\n{\n  uint shiftAmount;\n  uint32_t index;\n  \n  shiftAmount = (uint)((int)pin << 0x18) >> 0x1c;\n  map[shiftAmount] = map[shiftAmount] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "update_map_entry_0800316c",
                "PinName_conflict": "pinName",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "map_port_to_gpio_0800318c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * mapPortToGPIO_0800318c(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIOType *)0x40020000;\n  case 1:\n    return (GPIOType *)0x40020400;\n  case 2:\n    return (GPIOType *)0x40020800;\n  case 3:\n    return (GPIOType *)0x40020c00;\n  case 4:\n    return (GPIOType *)0x40021000;\n  case 5:\n    return (GPIOType *)0x40021400;\n  case 6:\n    return (GPIOType *)0x40021800;\n  case 7:\n    return (GPIOType *)0x40021c00;\n  case 8:\n    return (GPIOType *)0x40022000;\n  case 9:\n    return (GPIOType *)0x40022400;\n  case 10:\n    return (GPIOType *)0x40022800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "map_port_to_gpio_0800318c",
                "port_idx": "portIndex",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "get_gpio_080031fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIO_080031fc(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *gpio;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  uint32_t temporaryRegister_5;\n  uint32_t temporaryRegister_6;\n  uint32_t temporaryRegister_7;\n  uint32_t temporaryRegister_8;\n  uint32_t temporaryRegister_9;\n  uint32_t temporaryRegister_10;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    gpio = (GPIO_TypeDef *)0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    gpio = (GPIO_TypeDef *)0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    gpio = (GPIO_TypeDef *)0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    gpio = (GPIO_TypeDef *)0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    gpio = (GPIO_TypeDef *)0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    gpio = (GPIO_TypeDef *)0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    gpio = (GPIO_TypeDef *)0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    gpio = (GPIO_TypeDef *)0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    gpio = (GPIO_TypeDef *)0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    gpio = (GPIO_TypeDef *)0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    gpio = (GPIO_TypeDef *)0x40022800;\n    break;\n  default:\n    gpio = (GPIO_TypeDef *)0x0;\n  }\n  return gpio;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "get_gpio_080031fc",
                "port_idx": "portIndex",
                "pGVar1": "gpio",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4",
                "tmpreg_5": "temporaryRegister_5",
                "tmpreg_6": "temporaryRegister_6",
                "tmpreg_7": "temporaryRegister_7",
                "tmpreg_8": "temporaryRegister_8",
                "tmpreg_9": "temporaryRegister_9",
                "tmpreg_10": "temporaryRegister_10"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "check_dac_pin_08003380",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t check_dac_pin_08003380(PinName_conflict pin_name)\n\n{\n  uint32_t function_mapping;\n  uint32_t pin_function;\n  \n  function_mapping = pin_namemap_pin_function(pin_name,(PinMap_conflict *)&PinMap_DAC);\n  pin_function = function_mapping << 0xc;\n  pin_function = pin_function >> 0x1b;\n  if (pin_function != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "check_dac_pin_08003380",
                "pin": "pin_name",
                "uVar1": "function_mapping",
                "function": "pin_function"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "pin_get_pwm_function_0800339c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pin_get_pwm_function_0800339c(pin pin)\n\n{\n  uint32_t function_code;\n  uint32_t mapped_function;\n  \n  function_code = pinmap_mapped_function(pin,(PinMap_conflict *)&PinMap_PWM);\n  mapped_function = function_code << 0xc;\n  mapped_function = mapped_function >> 0x1b;\n  if (mapped_function == 3) {\n    return 8;\n  }\n  if (mapped_function != 4) {\n    if (mapped_function != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "pin_get_pwm_function_0800339c",
                "PinName_conflict": "pin",
                "uVar1": "function_code",
                "function": "mapped_function"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_dac_configuration_080033c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clear_dac_configuration_080033c8(DAC_HandleTypeDef *dac_handle)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_dac_configuration_080033c8",
                "hdac": "dac_handle"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_de_init_dac_080033d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeInitDac_080033d8(PinName_conflict pin)\n\n{\n  uint32_t dacChannel;\n  uint32_t dacdacChannel;\n  DAC_HandleTypeDef dacHandle;\n  \n  dacHandle.Instance = (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_DAC);\n  if ((dacHandle.Instance != (DAC_TypeDef *)0x0) &&\n     ((dacChannel = get_dac_channel(pin), dacChannel == 0 || (dacChannel == 0x10)))) {\n    HAL_DAC_Stop(&dacHandle,dacChannel);\n    HAL_DAC_DeInit(&dacHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_de_init_dac_080033d8",
                "Channel": "dacChannel",
                "DacHandle": "dacHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_Stop",
                "get_dac_channel",
                "HAL_DAC_DeInit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerClock_0800340c(TIM_HandleTypeDef *htim)\n\n{\n  disableTimerClock_0800340c(htim);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "timer_disable_clock": "disableTimerClock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_signal_08003414",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPwmSignal_08003414(pin pin)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timpwmChannel;\n  uint32_t functionCode;\n  TIM_HandleTypeDef timHandler;\n  \n  timHandler.Instance = (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM);\n  if ((timHandler.Instance != (TIM_TypeDef *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pin), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    functionCode = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionCode & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandler,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandler,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_signal_08003414",
                "PinName_conflict": "pin",
                "Channel": "pwmChannel",
                "uVar1": "functionCode",
                "timHandle": "timHandler"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_current_tick_0800346c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_0800346c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_08003476",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSystemTick_08003476(void)\n\n{\n  incrementTick();\n  handleSystickInterrupt();\n  handleNoOsSystick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_08003476",
                "noOsSystickHandler": "handleNoOsSystick",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSystickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "initialize_gpio_08003486",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08003486(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  GPIO_InitTypeDef gpioInit;\n  \n  gpioPort = set_GPIO_Port_Clock((uint)((int)pin << 0x18) >> 0x1c);\n  gpioInit.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  gpioInit.Speed = 2;\n  gpioInit.Mode = mode;\n  gpioInit.Pull = pull;\n  HAL_GPIO_Init(gpioPort,&gpioInit);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "initialize_gpio_08003486",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "GPIO_InitStructure": "gpioInit"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "set_gpio_state_080034b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIOState_080034b6(GPIO_TypeDef *gpioPort,uint32_t gpioPin,uint32_t state)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)gpioPin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)gpioPin,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "set_gpio_state_080034b6",
                "port": "gpioPort",
                "pin": "gpioPin",
                "val": "state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_hardware_080034ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_hardware_080034ce(void)\n\n{\n  initialize_HAL();\n  configure_system_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_hardware_080034ce",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_system_clock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_peripheral_from_pin_080034da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralFromPin_080034da(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->matchedPeripheral;\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_peripheral_from_pin_080034da",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected",
                "peripheral": "matchedPeripheral"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "find_peripheral_080034f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_080034f4(PinName_conflict pin,PinMap_conflict *pin_map)\n\n{\n  void *peripheral;\n  \n  if (pin != NC) {\n    peripheral = pinpin_map_find_peripheral_080034f4(pin,pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "find_peripheral_080034f4",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_write",
                "uart_debug_init",
                "dac_stop",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_pin_from_peripheral_08003506",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPinFromPeripheral_08003506(void *peripheral,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->peripheral == (void *)0x0) {\n      return NC;\n    }\n    if (pinMap->peripheral == peripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_pin_from_peripheral_08003506",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_pin_0800351e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPin_0800351e(void *peripheral,PinMap_conflict *pinMap)\n\n{\n  PinName_conflict foundPin;\n  \n  if (peripheral != (void *)0x0) {\n    foundPin = pinpinMap_find_pin(peripheral,pinMap);\n    return foundPin;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_pin_0800351e",
                "map": "pinMap",
                "PVar1": "foundPin"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_pin_function_0800352e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800352e(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return 0xffffffff;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->function;\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_pin_function_0800352e",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_pin_function_0800354a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_0800354a(PinName_conflict input_pin,PinMap_conflict *pin_map)\n\n{\n  uint32_t function_found;\n  \n  if (input_pin == NC) {\n    return 0xffffffff;\n  }\n  function_found = input_pinpin_map_find_function(input_pin,pin_map);\n  return function_found;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "pin": "input_pin",
                "map": "pin_map",
                "uVar1": "function_found"
            },
            "calling": [
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "pin_exists_in_map_0800355e",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pin_exists_in_map_0800355e(pin pin_to_check,pin_map *pin_map_iterator)\n\n{\n  if (pin_to_check == NC) {\n    return false;\n  }\n  while( true ) {\n    if (pin_map_iterator->pin_to_check == NC) {\n      return false;\n    }\n    if (pin_to_check == pin_map_iterator->pin_to_check) break;\n    pin_map_iterator = pin_map_iterator + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "pin_exists_in_map_0800355e",
                "PinName_conflict": "pin",
                "PinMap_conflict": "pin_map",
                "pin": "pin_to_check",
                "map": "pin_map_iterator"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "combine_non_null_pointers_08003582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * combineNonNullPointers_08003582(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08003582": "combine_non_null_pointers_08003582"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "execute_rtc_user_callback_08003594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRTCUserCallback_08003594(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (userCallback != (callbackPointer)0x0) {\n    (*userCallback)(userData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "execute_rtc_user_callback_08003594",
                "hrtc": "rtcHandle",
                "RTCUserCallback": "userCallback",
                "voidCallbackPtr": "callbackPointer",
                "callbackUserData": "userData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ac": {
            "entrypoint": "0x080035ac",
            "current_name": "run_alarm_irq_handler_080035ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runAlarmIRQHandler_080035ac(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(&ptrRtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ac": "run_alarm_irq_handler_080035ac",
                "RtcHandle": "ptrRtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_system_080035bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_system_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "configure_tim_instance_080035fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configure_TIM_Instance_080035fc(TIM_HandleTypeDef *TIM_handle)\n\n{\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (TIM_handle->Instance == (TIM_TypeDef *)0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "configure_tim_instance_080035fc",
                "htim": "TIM_handle"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "get_stimer_from_htim_08003750",
            "code": "\n/* WARNING: Unknown calling convention */\n\ntimer_struct * get_stimer_from_htim_08003750(TIM_HandleTypeDef *timer_handler)\n\n{\n  return (timer_struct *)&timer_handler[-1].lock_ptr;\n}\n\n",
            "renaming": {
                "FUN_08003750": "get_stimer_from_htim_08003750",
                "htim": "timer_handler",
                "stimer_t": "timer_struct",
                "Lock": "lock_ptr"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "handle_timer_interrupt_08003754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08003754(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *obj;\n  \n  timer_obj = get_timer_obj(timer_handle);\n  if ((timer_obj->handle_output_compare != (func_ptr_output_compare *)0x0) &&\n     (timer_handle->active_channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->handle_output_compare)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "handle_timer_interrupt_08003754",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "irqHandleOC": "handle_output_compare",
                "_func_void_stimer_t_ptr_uint32_t": "func_ptr_output_compare",
                "Channel": "active_channel"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "handle_timer_interrupt_0800376e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_0800376e(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_object;\n  stimer_t *timer_object_handle;\n  \n  timer_object = get_timer_timer_object_handle(timer_handle);\n  if (timer_object->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_object->irqHandle)(timer_object);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "handle_timer_interrupt_0800376e",
                "htim": "timer_handle",
                "psVar1": "timer_object",
                "obj": "timer_object_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_timers_0800377c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_0800377c(void)\n\n{\n  if (timerArray[0] != (TimerHandle *)0x0) {\n    handleIRQ(timerArray[0]);\n  }\n  if (timerArray[9] != (TimerHandle *)0x0) {\n    handleIRQ(timerArray[9]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_timers_0800377c",
                "timer_handles": "timerArray",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003798": {
            "entrypoint": "0x08003798",
            "current_name": "handle_tim_interrupt_08003798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupt_08003798(void)\n\n{\n  if (timerHandles[1] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003798": "handle_tim_interrupt_08003798",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037ac": {
            "entrypoint": "0x080037ac",
            "current_name": "handle_timer_interrupt_080037ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037ac(void)\n\n{\n  if (timerHandles[2] != (TimerHandleStruct *)0x0) {\n    handleTimerIRQ(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleStruct",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037c0": {
            "entrypoint": "0x080037c0",
            "current_name": "handle_timer_interrupt_080037c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037c0(void)\n\n{\n  if (timerHandles[3] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037c0": "handle_timer_interrupt_080037c0",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037d4": {
            "entrypoint": "0x080037d4",
            "current_name": "handle_timer_interrupt_080037d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037d4(void)\n\n{\n  if (timerHandles[4] != (TimerHandleType *)0x0) {\n    handleTimerIRQ(timerHandles[4]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037d4": "handle_timer_interrupt_080037d4",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleType",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037e8": {
            "entrypoint": "0x080037e8",
            "current_name": "handle_timer_interrupt_080037e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037e8(void)\n\n{\n  if (timerHandles[5] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[5]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037e8": "handle_timer_interrupt_080037e8",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "handle_timer_interrupt_080037fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037fc(void)\n\n{\n  if (timerList[6] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerList[6]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "handle_timer_interrupt_080037fc",
                "timer_handles": "timerList",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003810": {
            "entrypoint": "0x08003810",
            "current_name": "handle_irq_for_timers_08003810",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleIRQForTimers_08003810(void)\n\n{\n  if (timers[7] != (TimerHandle *)0x0) {\n    handleTimIRQ(timers[7]);\n  }\n  if (timers[12] != (TimerHandle *)0x0) {\n    handleTimIRQ(timers[12]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003810": "handle_irq_for_timers_08003810",
                "timer_handles": "timers",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800382c": {
            "entrypoint": "0x0800382c",
            "current_name": "handle_timer_interrupt_0800382c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800382c(void)\n\n{\n  if (timerHandles[8] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[8]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800382c": "handle_timer_interrupt_0800382c",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003840": {
            "entrypoint": "0x08003840",
            "current_name": "handle_timer_interrupt_08003840",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003840(void)\n\n{\n  if (timerHandles[10] != (TIM_HandleTypeDef *)0x0) {\n    handleTimerIRQ(timerHandles[10]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003840": "handle_timer_interrupt_08003840",
                "timer_handles": "timerHandles",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003854": {
            "entrypoint": "0x08003854",
            "current_name": "handle_timer_interrupt_08003854",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08003854(void)\n\n{\n  if (timer_handles[11] != (TimerHandle *)0x0) {\n    handle_timer_irq(timer_handles[11]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003854": "handle_timer_interrupt_08003854",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003868": {
            "entrypoint": "0x08003868",
            "current_name": "handle_timer_interrupt_08003868",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003868(void)\n\n{\n  if (timerHandles[13] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[13]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003868": "handle_timer_interrupt_08003868",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "get_i2c_ptr_0800387c",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * getI2cPtr_0800387c(I2C_HandleTypeDef *i2cHandler)\n\n{\n  return (i2c_t *)&i2cHandler[-1].eventCount;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "get_i2c_ptr_0800387c",
                "hi2c": "i2cHandler",
                "EventCount": "eventCount"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "handle_i2_c_event_08003880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08003880(I2C_HandleTypeDef *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  \n  i2cObject = getI2CObject(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->initConfig).ownAddress1) {\n    if (direction == '\\0') {\n      i2cObject->bufferSize = '\\0';\n      i2cObject->isSlaveMode = '\\0';\n      if (i2cObject->onSlaveTransmit != (_func_void *)0x0) {\n        (*i2cObject->onSlaveTransmit)();\n      }\n      transmitDataSequentially\n                (i2cHandle,i2cObject->dataBuffer,(ushort)i2cObject->bufferSize,8);\n      return;\n    }\n    i2cObject->isSlaveMode = '\\x01';\n    receiveDataSequentially(i2cHandle,i2cObject->dataBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "handle_i2_c_event_08003880",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "get_i2c_obj": "getI2CObject",
                "Init": "initConfig",
                "OwnAddress1": "ownAddress1",
                "i2cTxRxBufferSize": "bufferSize",
                "slaveMode": "isSlaveMode",
                "i2c_onSlaveTransmit": "onSlaveTransmit",
                "i2cTxRxBuffer": "dataBuffer",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmitDataSequentially",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receiveDataSequentially"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "enable_i2_c_listen_interrupt_080038d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableI2CListenInterrupt_080038d0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject2;\n  uint bufferSize;\n  \n  i2cObject = get_i2c_i2cObject2(i2cHandle);\n  if (((i2cObject->onSlaveReceiveFunc != (functionType *)0x0) &&\n      (i2cObject->isSlaveMode == '\\x01')) &&\n     (bufferSize = 0x20 - *(byte *)&(i2cObject->i2cHandle2).transferSize & 0xff, bufferSize != 0)) {\n    (*i2cObject->onSlaveReceiveFunc)(i2cObject->txRxBuffer,bufferSize);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "enable_i2_c_listen_interrupt_080038d0",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject2",
                "uVar2": "bufferSize",
                "i2c_onSlaveReceive": "onSlaveReceiveFunc",
                "_func_void_uint8_t_ptr_int": "functionType",
                "slaveMode": "isSlaveMode",
                "handle": "i2cHandle2",
                "XferSize": "transferSize",
                "i2cTxRxBuffer": "txRxBuffer"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_listen_interrupt_08003900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08003900(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObject;\n  \n  i2cObj = get_i2c_i2cObject(i2cHandle);\n  if (i2cObj->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_listen_interrupt_08003900",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObject"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003918": {
            "entrypoint": "0x08003918",
            "current_name": "handle_i2_c_events_08003918",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08003918(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2cHandles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003918": "handle_i2_c_events_08003918",
                "i2c_handles": "i2cHandles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003928": {
            "entrypoint": "0x08003928",
            "current_name": "handle_i2_c_error_interrupt_08003928",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08003928(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003928": "handle_i2_c_error_interrupt_08003928"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003938": {
            "entrypoint": "0x08003938",
            "current_name": "handle_i2_c_irq_event_08003938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CIrqEvent_08003938(void)\n\n{\n  processI2CIrqEvent(ptr_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003938": "handle_i2_c_irq_event_08003938",
                "I2C2_ER_IRQHandler::handle": "ptr_handle",
                "HAL_I2C_EV_IRQHandler": "processI2CIrqEvent"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003948": {
            "entrypoint": "0x08003948",
            "current_name": "handle_i2_c_er_interrupt_08003948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C_ER_interrupt_08003948(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2_er_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003948": "handle_i2_c_er_interrupt_08003948",
                "I2C2_ER_IRQHandler::handle": "i2c2_er_handle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003958": {
            "entrypoint": "0x08003958",
            "current_name": "handle_i2_c_event_08003958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08003958(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c3_Error_Handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003958": "handle_i2_c_event_08003958",
                "I2C3_ER_IRQHandler::handle": "i2c3_Error_Handler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003968": {
            "entrypoint": "0x08003968",
            "current_name": "handle_i2_c_error_08003968",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08003968(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c3ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003968": "handle_i2_c_error_08003968",
                "I2C3_ER_IRQHandler::handle": "i2c3ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_serial_communication_08003978",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003978(serial_t *serialObject)\n\n{\n  void *a;\n  USART_TypeDef *txUart;\n  void *b;\n  USART_TypeDef *rxUart;\n  USART_TypeDef *mergedPeripheral;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t pinFunction;\n  UART_HandleTypeDef *uartHandle;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  uint32_t temporaryRegister_5;\n  uint32_t temporaryRegister_6;\n  uint32_t temporaryRegister_7;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  if (serialObject != (serial_t *)0x0) {\n    a = pinmap_peripheral(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      mergedPeripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serialObject->uart = mergedPeripheral;\n      if (mergedPeripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (mergedPeripheral == (USART_TypeDef *)0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          serialObject->index = '\\0';\n          serialObject->irq = USART1_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          serialObject->index = '\\x01';\n          serialObject->irq = USART2_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          serialObject->index = '\\x02';\n          serialObject->irq = USART3_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          serialObject->index = '\\x03';\n          serialObject->irq = UART4_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          serialObject->index = '\\x04';\n          serialObject->irq = UART5_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          serialObject->index = '\\x05';\n          serialObject->irq = USART6_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          serialObject->index = '\\x06';\n          serialObject->irq = UART7_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          serialObject->index = '\\a';\n          serialObject->irq = UART8_IRQn;\n        }\n        gpioPort = set_GPIO_Port_Clock((uint)((int)serialObject->pin_rx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpioInitStructure.Pin = 1 << (serialObject->pin_rx & 0xfU) & 0xffff;\n        gpioInitStructure.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStructure.Pull = (pinFunction << 0x1a) >> 0x1e;\n        gpioInitStructure.Alternate = (pinFunction << 0x11) >> 0x19;\n        gpioInitStructure.Speed = 3;\n        HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n        gpioPort = set_GPIO_Port_Clock((uint)((int)serialObject->pin_tx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpioInitStructure.Pin = 1 << (serialObject->pin_tx & 0xfU) & 0xffff;\n        gpioInitStructure.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStructure.Pull = (pinFunction << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n        uart_handlers[serialObject->index] = &serialObject->handle;\n        (serialObject->handle).Instance = serialObject->uart;\n        (serialObject->handle).Init.BaudRate = serialObject->baudrate;\n        (serialObject->handle).Init.WordLength = serialObject->databits;\n        (serialObject->handle).Init.StopBits = serialObject->stopbits;\n        (serialObject->handle).Init.Parity = serialObject->parity;\n        (serialObject->handle).Init.Mode = 0xc;\n        (serialObject->handle).Init.HwFlowCtl = 0;\n        (serialObject->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialObject->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_serial_communication_08003978",
                "obj": "serialObject",
                "uart_tx": "txUart",
                "uart_rx": "rxUart",
                "pUVar1": "mergedPeripheral",
                "pGVar2": "gpioPort",
                "port": "gpioPort",
                "uVar3": "pinFunction",
                "huart": "uartHandle",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4",
                "tmpreg_5": "temporaryRegister_5",
                "tmpreg_6": "temporaryRegister_6",
                "tmpreg_7": "temporaryRegister_7",
                "GPIO_InitStruct": "gpioInitStructure"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_serial_debug_08003cc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_serial_debug_08003cc8(void)\n\n{\n  void *peripheral_address;\n  \n  peripheral_address = get_peripheral_address(GPIO_PIN_8,(ConflictingPinMap *)&UART_TX);\n  if (peripheral_address != (void *)0x0) {\n    peripheral_address = get_peripheral_address(GPIO_PIN_8,(ConflictingPinMap *)&UART_TX);\n    serial_debug_rx_pin = pinmap_pin(peripheral_address,(ConflictingPinMap *)&PinMap_UART_RX);\n    serial_debug_tx_pin = GPIO_PIN_8;\n    serial_debug_baudrate = 0x2580;\n    serial_debug_parity = 0;\n    serial_debug_databits = 0;\n    serial_debug_stopbits = 0;\n    initialize_uart(&serial_debug);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_serial_debug_08003cc8",
                "pvVar1": "peripheral_address",
                "pinmap_peripheral": "get_peripheral_address",
                "PD_8": "GPIO_PIN_8",
                "PinMap_conflict": "ConflictingPinMap",
                "PinMap_UART_TX": "UART_TX",
                "serial_debug.pin_rx": "serial_debug_rx_pin",
                "serial_debug.pin_tx": "serial_debug_tx_pin",
                "serial_debug.baudrate": "serial_debug_baudrate",
                "serial_debug.parity": "serial_debug_parity",
                "serial_debug.databits": "serial_debug_databits",
                "serial_debug.stopbits": "serial_debug_stopbits",
                "uart_init": "initialize_uart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "transmit_data_08003d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_08003d18(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef uartStatus;\n  uint32_t startTime;\n  uint32_t tickStart;\n  void *uartPeripheral;\n  USART_TypeDef *usartPeripheral;\n  uint32_t currentTime;\n  uint handlerIndex;\n  \n  startTime = HAL_GetTick();\n  uartPeripheral = pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX);\n  if (uartPeripheral == (void *)0x0) {\n    return 0;\n  }\n  handlerIndex = 0;\n  while ((handlerIndex < 10 &&\n         ((uart_handlers[handlerIndex] == (UART_HandleTypeDef *)0x0 ||\n          (usartPeripheral = (USART_TypeDef *)pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[handlerIndex]->Instance != usartPeripheral))))) {\n    handlerIndex = handlerIndex + 1 & 0xff;\n  }\n  if (9 < handlerIndex) {\n    if ((9 < serial_debug.index) && (uart_debug_init(), 9 < serial_debug.index)) {\n      return 0;\n    }\n    handlerIndex = (uint)serial_debug.index;\n  }\n  do {\n    uartStatus = HAL_UART_Transmit(uart_handlers[handlerIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (uartStatus == HAL_OK) {\n      return bufferSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "transmit_data_08003d18",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "uartStatus",
                "uVar2": "startTime",
                "tickstart": "tickStart",
                "pvVar3": "uartPeripheral",
                "pUVar4": "usartPeripheral",
                "uVar5": "currentTime",
                "uVar6": "handlerIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "HAL_UART_Transmit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_state_08003dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003dd0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_state_08003dd0",
                "obj": "serial_object",
                "HVar1": "uart_state"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "check_uart_state_08003df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003df4(serial_t *object)\n\n{\n  UartState uartState;\n  \n  uartState = HAL_UART_GetState(uart_handlers[object->index]);\n  return (uartState & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "check_uart_state_08003df4",
                "obj": "object",
                "HAL_UART_StateTypeDef": "UartState",
                "HVar1": "uartState"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "read_and_receive_data_08003e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint read_and_receive_data_08003e18(serial_t *serial_obj,uchar *c)\n\n{\n  uint8_t is_rx_active;\n  \n  if (serial_obj == (serial_t *)0x0) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_obj);\n  if (is_rx_active == '\\0') {\n    *c = serial_obj->recv;\n    HAL_UART_Receive_IT(uart_handlers[serial_obj->index],&serial_obj->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "read_and_receive_data_08003e18",
                "obj": "serial_obj",
                "uVar1": "is_rx_active"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_communication_08003e54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003e54(serial_t *serialObject,_func_void_serial_t_ptr *callbackFunction)\n\n{\n  byte index;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = serial_rx_active(serialObject);\n    if (rxActive == '\\0') {\n      index = serialObject->index;\n      rx_callbackFunction[index] = callbackFunction;\n      rx_callbackFunction_serialObject[index] = serialObject;\n      setPriority(serialObject->irq,0,1);\n      enableIRQ(serialObject->irq);\n      receiveData(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_communication_08003e54",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "uVar2": "rxActive",
                "bVar1": "index",
                "HAL_NVIC_SetPriority": "setPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_UART_Receive_IT": "receiveData"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "initialize_serial_communication_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003eac(serial_t *serialDevice,callbackFunction *callback)\n\n{\n  byte deviceIndex;\n  \n  if (serialDevice != (serial_t *)0x0) {\n    deviceIndex = serialDevice->index;\n    tx_callback[deviceIndex] = callback;\n    tx_callback_serialDevice[deviceIndex] = serialDevice;\n    HAL_NVIC_SetPriority(serialDevice->irq,0,2);\n    HAL_NVIC_EnableIRQ(serialDevice->irq);\n    HAL_UART_Transmit_IT(uart_handlers[serialDevice->index],serialDevice->tx_buff + serialDevice->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "initialize_serial_communication_08003eac",
                "obj": "serialDevice",
                "_func_int_serial_t_ptr": "callbackFunction",
                "bVar1": "deviceIndex"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_uart_handler_08003f00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_08003f00(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_uart_handler_08003f00",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "handle_uart_callback_08003f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_callback_08003f24(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index;\n  uint8_t index;\n  uint converted_index;\n  \n  index = uart_index(uart_handle);\n  converted_index = (uint)index;\n  if (converted_index < 10) {\n    (*rx_callback[converted_index])(rx_callback_obj[converted_index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "handle_uart_callback_08003f24",
                "huart": "uart_handle",
                "bVar1": "index",
                "uVar2": "converted_index"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_data_08003f48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08003f48(UART_HandleTypeDef *uartHandler)\n\n{\n  byte uartIndex;\n  uint8_t currentIndex;\n  int txCallbackResult;\n  serial_t *serialObj;\n  serial_t *txCallbackObj;\n  uint callbackIndex;\n  \n  uartIndex = uart_currentIndex(uartHandler);\n  callbackIndex = (uint)uartIndex;\n  txCallbackObj = tx_callback_serialObj[callbackIndex];\n  if ((callbackIndex < 10) && (txCallbackResult = (*tx_callback[callbackIndex])(txCallbackObj), txCallbackResult != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[txCallbackObj->currentIndex],txCallbackObj->tx_buff + txCallbackObj->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_data_08003f48",
                "huart": "uartHandler",
                "bVar1": "uartIndex",
                "index": "currentIndex",
                "iVar3": "txCallbackResult",
                "obj": "serialObj",
                "psVar4": "txCallbackObj",
                "uVar2": "callbackIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "initialize_uart_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08003f94(UART_HandleTypeDef *UART_handle)\n\n{\n  uint32_t temporaryValue;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "initialize_uart_08003f94",
                "huart": "UART_handle",
                "tmpval": "temporaryValue"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd4": {
            "entrypoint": "0x08003fd4",
            "current_name": "handle_usart1_interrupt_08003fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART1_interrupt_08003fd4(void)\n\n{\n  clear_pending_interrupt(USART1_interrupt_number);\n  handle_UART_interrupt(UART_handlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd4": "handle_usart1_interrupt_08003fd4",
                "USART1_IRQn": "USART1_interrupt_number",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fec": {
            "entrypoint": "0x08003fec",
            "current_name": "handle_usart2_interrupt_08003fec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_interrupt_08003fec(void)\n\n{\n  clear_pending_interrupt(USART2_interrupt_handler);\n  handle_UART_interrupt(UART_interrupt_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fec": "handle_usart2_interrupt_08003fec",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "USART2_IRQn": "USART2_interrupt_handler",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "UART_interrupt_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "handle_usart3_irq_handler_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_IRQHandler_08004004(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_interrupt);\n  if (uart_handlers_array[2] != (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(uart_handlers_array[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "handle_usart3_irq_handler_08004004",
                "USART3_IRQn": "USART3_interrupt",
                "uart_handlers": "uart_handlers_array"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800401c": {
            "entrypoint": "0x0800401c",
            "current_name": "handle_uart4_interrupt_0800401c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUart4Interrupt_0800401c(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart4Interrupt);\n  HAL_UART_IRQHandler(uartHandlers[3]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800401c": "handle_uart4_interrupt_0800401c",
                "UART4_IRQn": "uart4Interrupt",
                "uart_handlers": "uartHandlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004034": {
            "entrypoint": "0x08004034",
            "current_name": "handle_uart_interrupt_08004034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_08004034(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart5_interrupt);\n  HAL_UART_IRQHandler(uart_handler_array[4]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004034": "handle_uart_interrupt_08004034",
                "UART5_IRQn": "uart5_interrupt",
                "uart_handlers": "uart_handler_array"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800404c": {
            "entrypoint": "0x0800404c",
            "current_name": "handle_uart_interrupt_0800404c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_0800404c(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart_6_interrupt);\n  HAL_UART_IRQHandler(uart_handler_5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800404c": "handle_uart_interrupt_0800404c",
                "USART6_IRQn": "uart_6_interrupt",
                "uart_handlers[5]": "uart_handler_5"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004064": {
            "entrypoint": "0x08004064",
            "current_name": "handle_uart7_interrupt_08004064",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART7_interrupt_08004064(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART7_interrupt_number);\n  HAL_UART_IRQHandler(UART7_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004064": "handle_uart7_interrupt_08004064",
                "UART7_IRQn": "UART7_interrupt_number",
                "uart_handlers[6]": "UART7_handler"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "handle_uart8_interrupt_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART8_interrupt_0800407c(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart8_interrupt_number);\n  HAL_UART_IRQHandler(uart8_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800407c": "handle_uart8_interrupt_0800407c",
                "UART8_IRQn": "uart8_interrupt_number",
                "uart_handlers[7]": "uart8_handler"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "allocate_memory_08004094",
            "code": "\nvoid * allocate_memory_08004094(intptr_t memory_size)\n\n{\n  char *previous_heap_end;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  previous_heap_end = _sbrk::heap_end;\n  if (_sbrk::heap_end + memory_size <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + memory_size;\n    return previous_heap_end;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "__delta": "memory_size",
                "pcVar1": "previous_heap_end",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "check_file_status_080040d0",
            "code": "\nint check_file_status_080040d0(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "check_file_status_080040d0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "set_file_permissions_080040d6",
            "code": "\nint setFilePermissions_080040d6(int fileDescriptor,stat *fileStat)\n\n{\n  *(undefined4 *)((int)&fileStat->deviceNumber + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "set_file_permissions_080040d6",
                "__fd": "fileDescriptor",
                "__buf": "fileStat",
                "st_dev": "deviceNumber"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "check_file_descriptor_080040e0",
            "code": "\nint check_file_descriptor_080040e0(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "check_file_descriptor_080040e0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "calculate_offset_080040e4",
            "code": "\n__off_t calculateOffset_080040e4(int fileDescriptor,__off_t offset,int referencePoint)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "calculate_offset_080040e4",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "referencePoint"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "file_processing_function_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint file_processing_function_080040e8(int file_descriptor,char *buffer_pointer,int buffer_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "file_processing_function_080040e8",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer_pointer",
                "len_UNUSED": "buffer_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_to_uart_debug_080040ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_to_uart_debug_080040ec(int unused_file,char *data_pointer,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_to_uart_debug_080040ec",
                "file_UNUSED": "unused_file",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "infinite_loop_080040f8",
            "code": "\nvoid infiniteLoop_080040f8(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "infinite_loop_080040f8",
                "__status": "status"
            },
            "calling": [
                "abort",
                "_exit"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "set_errno_value_080040fc",
            "code": "\nint setErrnoValue_080040fc(processId_t processId,int signal)\n\n{\n  errorNumber = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "set_errno_value_080040fc",
                "__pid": "processId",
                "__sig": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "get_process_id_0800410c",
            "code": "\n\n\nprocess_id get_process_id_0800410c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "get_process_id_0800410c",
                "__pid_t": "process_id"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_pin_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004110(uint32_t pin,uint32_t mode)\n\n{\n  _Bool isConfigured;\n  PinName_conflict pinName;\n  \n  if (pin < 0x60) {\n    pinName = *(PinName_conflict *)(&digitalPin + pin * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  if (pinName != NC) {\n    isConfigured = is_pinNamein_configured(pinName,outputPinConfigured);\n    if (isConfigured) {\n      isConfigured = pinNamein_in_pinNameinmapinName(pinName,(pinMap *)&dacPinMap);\n      if (isConfigured) {\n        dac_stopinName(pinName);\n      }\n      else {\n        isConfigured = pinNamein_in_pinNameinmapinName(pinName,(pinMap *)&pwmPinMap);\n        if (isConfigured) {\n          pinNamewm_stopinName(pinName);\n        }\n      }\n      reset_pinNamein_configured(pinName,outputPinConfigured);\n    }\n    switch(mode) {\n    case 0:\n      digital_io_init(pinName,0,0);\n      break;\n    case 1:\n      digital_io_init(pinName,1,0);\n      break;\n    case 2:\n      digital_io_init(pinName,0,1);\n      break;\n    case 3:\n      digital_io_init(pinName,0,2);\n    }\n    set_pinNamein_configured(pinName,digitalPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "ulPin": "pin",
                "ulMode": "mode",
                "_Var1": "isConfigured",
                "p": "pinName",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "PinMap_conflict": "pinMap",
                "PinMap_DAC": "dacPinMap",
                "PinMap_PWM": "pwmPinMap",
                "g_digPinConfigured": "digitalPinConfigured"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "pin_in_pinmap",
                "reset_pin_configured",
                "digital_io_init",
                "set_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "write_gpio_080041bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeGPIO_080041bc(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isPinConfigured;\n  GPIO_TypinNameeDef *gpioPort;\n  PinName_conflict pinName;\n  uint pinConfig;\n  \n  if (pinNumber < 0x60) {\n    pinConfig = (uint)*(short *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    pinConfig = 0xffffffff;\n  }\n  if ((pinConfig != 0xffffffff) &&\n     (isPinConfigured = is_pinNamein_configured((PinName_conflict)pinConfig,g_digPinConfigured), isPinConfigured)) {\n    gpioPort = getGPIOPort((pinConfig << 0x18) >> 0x1c);\n    writeDigitalIO(gpioPort,1 << (pinConfig & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "write_gpio_080041bc",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isPinConfigured",
                "port": "gpioPort",
                "p": "pinName",
                "uVar2": "pinConfig",
                "get_GPIO_Port": "getGPIOPort",
                "digital_io_write": "writeDigitalIO"
            },
            "calling": [
                "sendTxBuffer",
                "getRxBuffer",
                "begin"
            ],
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_milliseconds_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_08004204(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_milliseconds_08004204",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800420c": {
            "entrypoint": "0x0800420c",
            "current_name": "update_tx_tail_0800420c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTxTail_0800420c(serial_t_conflict *serialObject)\n\n{\n  ushort newTail;\n  uint16_t maskedTail;\n  int nextTail;\n  \n  nextTail = serialObject->tx_tail + 1;\n  newTail = (ushort)nextTail;\n  maskedTail = newTail & 0x7f;\n  if (nextTail == 0) {\n    maskedTail = -(-newTail & 0x7f);\n  }\n  serialObject->tx_tail = maskedTail;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800420c": "update_tx_tail_0800420c",
                "obj": "serialObject",
                "uVar1": "newTail",
                "uVar2": "maskedTail",
                "iVar3": "nextTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_available_bytes_08004240",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::calculateAvailableBytes_08004240(HardwareSerial *serial)\n\n{\n  return ((serial->serial_data).receiveBufferHead + 0x40) - (uint)(serial->serial_data).receiveBufferTail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_available_bytes_08004240",
                "this": "serial",
                "_serial": "serial_data",
                "rx_head": "receiveBufferHead",
                "rx_tail": "receiveBufferTail"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004254": {
            "entrypoint": "0x08004254",
            "current_name": "get_next_received_byte_08004254",
            "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * serial_object) */\n\nint __serial_objectcall HardwareSerial::get_next_received_byte_08004254(HardwareSerial *serial_object)\n\n{\n  uint rx_tail;\n  \n  rx_tail = (uint)(serial_object->_serial).rx_tail;\n  if ((serial_object->_serial).head != rx_tail) {\n    return (uint)(serial_object->_serial).buffer[rx_tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004254": "get_next_received_byte_08004254",
                "this": "serial_object",
                "uVar1": "rx_tail",
                "rx_head": "head",
                "rx_buff": "buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004270": {
            "entrypoint": "0x08004270",
            "current_name": "read_serial_data_08004270",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * this) */\n\nssize_t class_method\nHardwareSerial::read_serial_data_08004270(HardwareSerial *this,int file_descriptor,void *buffer,size_t num_bytes)\n\n{\n  byte received_byte;\n  ushort rx_tail;\n  uchar c;\n  \n  rx_tail = (this->serial_data).receive_tail;\n  if ((uint)(this->serial_data).receive_head != (uint)rx_tail) {\n    received_byte = (this->serial_data).receive_buffer[rx_tail];\n    (this->serial_data).receive_tail = rx_tail + 1 & 0x3f;\n    return (uint)received_byte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004270": "read_serial_data_08004270",
                "__thiscall": "class_method",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__nbytes": "num_bytes",
                "bVar1": "received_byte",
                "uVar2": "rx_tail",
                "_serial": "serial_data",
                "rx_head": "receive_head",
                "rx_buff": "receive_buffer",
                "rx_tail": "receive_tail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004298": {
            "entrypoint": "0x08004298",
            "current_name": "flush_serial_08004298",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serial) */\n\nvoid __serialcall HardwareSerial::flushSerial_08004298(HardwareSerial *serial)\n\n{\n  if (serial->isDataWritten != false) {\n    do {\n    } while ((serial->serialData).tx_head != (serial->serialData).tx_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004298": "flush_serial_08004298",
                "this": "serial",
                "_written": "isDataWritten",
                "_serial": "serialData"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "process_serial_data_080042ac",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd HardwareSerindexal::processSerialData_080042ac(serindexal_t_conflindexct *serialObject)\n\n{\n  indexnt readResult;\n  rx_buffer_indexndex_t index;\n  ushort newHead;\n  uchar c;\n  \n  readResult = uart_getc((serindexal_t *)serialObject,&c);\n  indexf ((readResult == 0) && (newHead = serialObject->rx_head + 1 & 0x3f, newHead != serialObject->rx_taindexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = newHead;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "process_serial_data_080042ac",
                "obj": "serialObject",
                "iVar1": "readResult",
                "i": "index",
                "uVar2": "newHead"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "write_data_080042e8",
            "code": "\n/* DWARF orbufferIndexgbufferIndexnal prototype: sbufferIndexze_t  wrbufferIndexte(HardwareSerbufferIndexal * serialInstance, ubufferIndexnt8_t c) */\n\nssbufferIndexze_t __serialInstancecall\nHardwareSerbufferIndexal::writeData_080042e8(HardwareSerbufferIndexal *serialInstance,bufferIndexnt character,vobufferIndexd *buffer,sbufferIndexze_t bufferSize)\n\n{\n  byte nextIndex;\n  ubufferIndexnt8_t isActive;\n  byte adjustedIndex;\n  bufferIndexnt tmpIndex;\n  ubufferIndexnt previousIndex;\n  tx_buffer_bufferIndexndex_t bufferIndex;\n  \n  serialInstance->_wrbufferIndextten = true;\n  previousIndex = (ubufferIndexnt)(serialInstance->_serbufferIndexal).tx_head;\n  tmpIndex = previousIndex + 1;\n  nextIndex = (byte)tmpIndex;\n  adjustedIndex = nextIndex & 0x7f;\n  bufferIndexf (tmpIndex == 0) {\n    adjustedIndex = -(-nextIndex & 0x7f);\n  }\n  do {\n  } whbufferIndexle ((serialInstance->_serbufferIndexal).tx_tabufferIndexl == (ushort)adjustedIndex);\n  (serialInstance->_serbufferIndexal).tx_buff[previousIndex] = (ubufferIndexnt8_t)character;\n  (serialInstance->_serbufferIndexal).tx_head = (ushort)adjustedIndex;\n  isActive = serbufferIndexal_tx_actbufferIndexve((serbufferIndexal_t *)&serialInstance->_serbufferIndexal);\n  bufferIndexf (isActive == '\\0') {\n    uart_attach_tx_callback((serbufferIndexal_t *)&serialInstance->_serbufferIndexal,_tx_complete_bufferIndexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "__fd": "character",
                "__buf": "buffer",
                "__n": "bufferSize",
                "bVar1": "nextIndex",
                "uVar2": "isActive",
                "bVar3": "adjustedIndex",
                "iVar4": "tmpIndex",
                "uVar5": "previousIndex",
                "i": "bufferIndex",
                "FUN_080042e8": "write_data_080042e8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_serial_08004364",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialInstance) */\n\nint __serialInstancecall HardwareSerial::initializeSerial_08004364(HardwareSerial *serialInstance,context *ctx)\n\n{\n  (serialInstance->_serial).rx_buff = serialInstance->_rx_buffer;\n  (serialInstance->_serial).rx_head = 0;\n  (serialInstance->_serial).rx_tail = 0;\n  (serialInstance->_serial).tx_buff = serialInstance->_tx_buffer;\n  (serialInstance->_serial).tx_head = 0;\n  (serialInstance->_serial).tx_tail = 0;\n  return (int)serialInstance;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "EVP_PKEY_CTX": "context",
                "FUN_08004364": "initialize_serial_08004364"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "configure_serial_08004388",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialObject, ulong baudRate, byte configuration) */\n\nvoid __serialObjectcall HardwareSerial::configureSerial_08004388(HardwareSerial *serialObject,ulong baudRate,byte configuration)\n\n{\n  byte configBits;\n  int dataBits;\n  \n  (serialObject->serialData).baudRaterate = baudRate;\n  serialObject->_configuration = configuration;\n  configBits = configuration & 7;\n  if (configBits == 4) {\n    dataBits = 7;\n  }\n  else if (configBits == 6) {\n    dataBits = 8;\n  }\n  else if (configBits == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    (serialObject->serialData).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    (serialObject->serialData).parity = 0;\n  }\n  else {\n    (serialObject->serialData).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((configuration & 8) == 0) {\n    (serialObject->serialData).stopbits = 0;\n  }\n  else {\n    (serialObject->serialData).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (serialObject->serialData).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (serialObject->serialData).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    uart_init((serial_t *)&serialObject->serialData);\n    uart_attach_rx_callback((serial_t *)&serialObject->serialData,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "FUN_08004388": "configure_serial_08004388",
                "this": "serialObject",
                "baud": "baudRate",
                "config": "configuration",
                "bVar1": "configBits",
                "iVar2": "dataBits",
                "_serial": "serialData"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "set_rx_08004444",
            "code": "\n/* DWARF original prototype: void  setRx_08004444(HardwareSerial * serial, uint32_t pinIndex) */\n\nvoid __serialcall HardwareSerial::setRx_08004444(HardwareSerial *serial,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x60) {\n    pinName = *(PinName *)(&digitalPin + pinIndex * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serial->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004444": "set_rx_08004444",
                "this": "serial",
                "_rx": "pinIndex",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "set_tx_08004460",
            "code": "\n/* DWARF original prototype: void  setTx_08004460(HardwareSerial * serialInstance, uint32_t pinIndex) */\n\nvoid __serialInstancecall HardwareSerial::setTx_08004460(HardwareSerial *serialInstance,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x60) {\n    pinName = *(PinName *)(&digitalPin + pinIndex * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serialInstance->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "_tx": "pinIndex",
                "PVar1": "pinName",
                "FUN_08004460": "set_tx_08004460"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_hardware_serial_0800447c",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialInstance, void *\n   peripheral) */\n\nHardwareSerial * __serialInstancecall HardwareSerial::initializeHardwareSerial_0800447c(HardwareSerial *serialInstance,void *peripheral)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *context1;\n  EVP_PKEY_CTX *context2;\n  EVP_PKEY_CTX *context3;\n  \n  (serialInstance->super_Stream).super_Print.write_error = 0;\n  (serialInstance->super_Stream)._timeout = 1000;\n  (serialInstance->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08005ed4;\n  if (serialInstance == &Serial3) {\n    setRx(&Serial3,0x4c);\n    setTx(&Serial3,0x4d);\n    context2 = context3;\n  }\n  else {\n    rxPin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialInstance->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialInstance->_serial).pin_tx = rxPin;\n    context2 = context1;\n  }\n  init(serialInstance,context2);\n  return serialInstance;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "PVar1": "rxPin",
                "extraout_r1": "context1",
                "ctx": "context2",
                "extraout_r1_00": "context3",
                "FUN_0800447c": "initialize_hardware_serial_0800447c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "pinmap_pin",
                "init",
                "setTx",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_serial_port_080044d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialPort_080044d8(int shouldInitialize,int priorityLevel)\n\n{\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    HardwareSerial::HardwareSerial(&Serial3,(void *)0x40004800);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_serial_port_080044d8",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044fc": {
            "entrypoint": "0x080044fc",
            "current_name": "initialize_static_data_080044fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080044fc(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044fc": "initialize_static_data_080044fc"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800450a": {
            "entrypoint": "0x0800450a",
            "current_name": "print_ip_address_0800450a",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_0800450a(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t byteCount;\n  size_t dotCount;\n  int loopCounter;\n  int totalBytes;\n  \n  totalBytes = 0;\n  for (loopCounter = 0; loopCounter < 3; loopCounter = loopCounter + 1) {\n    byteCount = Print::printerrint(printer,(ipAddress->_address).bytes[loopCounter],10);\n    dotCount = Print::printerrint(printer,'.');\n    totalBytes = totalBytes + byteCount + dotCount;\n  }\n  byteCount = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return byteCount + totalBytes;\n}\n\n",
            "renaming": {
                "FUN_0800450a": "print_ip_address_0800450a",
                "this": "ipAddress",
                "p": "printer",
                "sVar1": "byteCount",
                "sVar2": "dotCount",
                "iVar3": "loopCounter",
                "iVar4": "totalBytes"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "initialize_ip_address_08004544",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::initializeIPAddress_08004544(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08005f28;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "FUN_08004544": "initialize_ip_address_08004544",
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "initialize_ip_address_08004560",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08004560(int isInitialize,int priority)\n\n{\n  if ((isInitialize == 1) && (priority == 0xffff)) {\n    IPAddress::IPAddress(&noneAddress,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "initialize_ip_address_08004560",
                "__initialize_p": "isInitialize",
                "__priority": "priority",
                "INADDR_NONE": "noneAddress"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_static_variables_0800458c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_0800458c(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_static_variables_0800458c"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459a": {
            "entrypoint": "0x0800459a",
            "current_name": "print_output_0800459a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::print_output_0800459a(Print *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *print_obj;\n  int iteration_count;\n  \n  iteration_count = 0;\n  print_obj = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return iteration_count;\n    }\n    print_obj = (Print *)(**this->_vptr_Print)(print_obj,(uint)*(byte *)file_descriptor,buffer,*this->_vptr_Print,size)\n    ;\n    if (print_obj == (Print *)0x0) break;\n    iteration_count = iteration_count + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return iteration_count;\n}\n\n",
            "renaming": {
                "FUN_0800459a": "print_output_0800459a",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "print_obj",
                "iVar2": "iteration_count"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045be": {
            "entrypoint": "0x080045be",
            "current_name": "print_character_080045be",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045c4 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printInstance, char c) */\n\nsize_t __printInstancecall Print::printCharacter_080045be(Print *printInstance,char c)\n\n{\n  size_t result;\n  \n  result = (**printInstance->_vptr_Print)(printInstance,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "this": "printInstance",
                "sVar1": "result",
                "FUN_080045be": "print_character_080045be"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045c8": {
            "entrypoint": "0x080045c8",
            "current_name": "print_number_080045c8",
            "code": "\n/* WARNING: Heritage AFTER dead redividendoval. Exadividendple locationumber: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode elidividendinumberationumber for space: register */\n/* WARNING: Exceeded dividendaxidividendudividend restarts with dividendore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNudividendber(Prinumbert * printInstance, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printInstancecall Prinumbert::printNumber_080045c8(Prinumbert *printInstance,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char convertedChar;\n  char c;\n  size_t stringLength;\n  size_t returnValue;\n  ulonumberg dividend;\n  uinumbert multiplicationResult;\n  uinumbert baseValue;\n  uinumbert divisionResult;\n  char *buffer;\n  char numberBuffer [33];\n  \n  baseValue = (uinumbert)numberBase;\n  numberBuffer[32] = '\\0';\n  if (baseValue < 2) {\n    baseValue = 10;\n  }\n  buffer = numberBuffer + 0x20;\n  dividend = number;\n  do {\n    divisionResult = dividend / baseValue;\n    multiplicationResult = (dividend & 0xff) - ((inumbert)(short)divisionResult * (inumbert)(short)baseValue & 0xffU) & 0xff;\n    buffer = buffer + -1;\n    convertedChar = (char)multiplicationResult;\n    if (multiplicationResult < 10) {\n      convertedChar = convertedChar + '0';\n    }\n    else {\n      convertedChar = convertedChar + '7';\n    }\n    *buffer = convertedChar;\n    dividend = divisionResult;\n  } while (divisionResult != 0);\n  if (buffer == (char *)0x0) {\n    returnValue = 0;\n  }\n  else {\n    stringLength = strlenumber(buffer);\n    returnValue = (*printInstance->_vptr_Prinumbert[1])(stringLength,buffer,stringLength);\n  }\n  returnumber returnValue;\n}\n\n",
            "renaming": {
                "FUN_080045c8": "print_number_080045c8",
                "this": "printInstance",
                "n": "number",
                "base": "numberBase",
                "cVar1": "convertedChar",
                "sVar2": "stringLength",
                "sVar3": "returnValue",
                "m": "dividend",
                "uVar4": "multiplicationResult",
                "uVar5": "baseValue",
                "uVar6": "divisionResult",
                "__s": "buffer",
                "buf": "numberBuffer"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004622": {
            "entrypoint": "0x08004622",
            "current_name": "print_formatted_number_08004622",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08004634 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printInstance, ulonumberg number, inumbert numberBase) */\n\nsize_t __printInstancecall Prinumbert::printFormattedNumber_08004622(Prinumbert *printInstance,ulonumberg number,inumbert numberBase)\n\n{\n  size_t result;\n  \n  if (numberBase != 0) {\n    result = prinumbertNumber(printInstance,number,(uinumbert8_t)numberBase);\n    returnumber result;\n  }\n  result = (**printInstance->_vptr_Prinumbert)(printInstance,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08004622": "print_formatted_number_08004622",
                "this": "printInstance",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004638": {
            "entrypoint": "0x08004638",
            "current_name": "print_byte_in_base_08004638",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printObj, uchar b, int numberBase) */\n\nsize_t __printObjcall Print::printByteInBase_08004638(Print *printObj,uchar b,int numberBase)\n\n{\n  size_t dataSize;\n  \n  dataSize = print(printObj,(uint)b,numberBase);\n  return dataSize;\n}\n\n",
            "renaming": {
                "FUN_08004638": "print_byte_in_base_08004638",
                "this": "printObj",
                "base": "numberBase",
                "sVar1": "dataSize"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "combine_bytes_08004640",
            "code": "\n/* WARNING: Unknown calowBytelowByteing convention */\n\nuint16_t combineBytes_08004640(uint8_t highByte,uint8_t lowByte)\n\n{\n  return CONCAT11(highByte,lowByte);\n}\n\n",
            "renaming": {
                "FUN_08004640": "combine_bytes_08004640",
                "h": "highByte",
                "l": "lowByte"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "validateRequest",
                "process_FC16"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_encryption_08004648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEncryption_08004648(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  setPriorityGrouping(3);\n  initialize(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_encryption_08004648",
                "ctx": "context",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "init": "initialize"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "initialize_and_run_08004658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initialize_and_run_08004658(void)\n\n{\n  initialize_variant();\n  setup_environment();\n  do {\n    perform_loop();\n    run_serial_event();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "initialize_and_run_08004658",
                "initVariant": "initialize_variant",
                "setup": "setup_environment",
                "loop": "perform_loop",
                "serialEventRun": "run_serial_event"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "initVariant",
                "loop",
                "serialEventRun"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "count_set_bits_08004678",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08004678(uint16_t input)\n\n{\n  uint num;\n  uint8_t count;\n  \n  count = '\\0';\n  for (num = (uint)input; num != 1; num = num >> 1) {\n    count = count + '\\x01';\n  }\n  return count;\n}\n\n",
            "renaming": {
                "FUN_08004678": "count_set_bits_08004678",
                "pin": "input",
                "uVar1": "num",
                "uVar2": "count"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800468c": {
            "entrypoint": "0x0800468c",
            "current_name": "cleanup_interrupts_0800468c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupInterrupts_0800468c(void *param)\n\n{\n  gpio_irq_conf_str *current_ptr;\n  _Manager_type manager;\n  gpio_irq_conf_str *next_ptr;\n  \n  current_ptr = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (next_ptr = current_ptr, next_ptr != gpio_irq_conf) {\n    manager = next_ptr[-1].callback.super__Function_base._M_manager;\n    current_ptr = next_ptr + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&next_ptr[-1].callback,(_Any_data *)&next_ptr[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800468c": "cleanup_interrupts_0800468c",
                "param_1": "param",
                "pgVar1": "current_ptr",
                "p_Var2": "manager",
                "pgVar3": "next_ptr"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_priority_callbacks_080046b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePriorityCallbacks_080046b4(int isInitialize,int priority)\n\n{\n  if (isInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpioInterruptConfigurations[0].irqnb = ExternalInterrupt0_IRQn;\n    gpioInterruptConfigurations[0].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[1].irqnb = ExternalInterrupt1_IRQn;\n    gpioInterruptConfigurations[1].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[2].irqnb = ExternalInterrupt2_IRQn;\n    gpioInterruptConfigurations[2].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[3].irqnb = ExternalInterrupt3_IRQn;\n    gpioInterruptConfigurations[3].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[4].irqnb = ExternalInterrupt4_IRQn;\n    gpioInterruptConfigurations[4].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[5].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioInterruptConfigurations[5].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[6].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioInterruptConfigurations[6].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[7].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioInterruptConfigurations[7].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[8].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioInterruptConfigurations[8].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[9].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioInterruptConfigurations[9].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[10].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioInterruptConfigurations[10].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[11].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioInterruptConfigurations[11].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[12].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioInterruptConfigurations[12].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[13].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioInterruptConfigurations[13].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[14].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioInterruptConfigurations[14].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpioInterruptConfigurations[15].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioInterruptConfigurations[15].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    __aeabi_atexit(0,0x800468d,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_priority_callbacks_080046b4",
                "__initialize_p": "isInitialize",
                "__priority": "priority",
                "gpio_irq_conf": "gpioInterruptConfigurations",
                "EXTI0_IRQn": "ExternalInterrupt0_IRQn",
                "EXTI1_IRQn": "ExternalInterrupt1_IRQn",
                "EXTI2_IRQn": "ExternalInterrupt2_IRQn",
                "EXTI3_IRQn": "ExternalInterrupt3_IRQn",
                "EXTI4_IRQn": "ExternalInterrupt4_IRQn",
                "EXTI9_5_IRQn": "ExternalInterrupt9_5_IRQn",
                "EXTI15_10_IRQn": "ExternalInterrupt15_10_IRQn"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004760": {
            "entrypoint": "0x08004760",
            "current_name": "handle_external_interrupt_08004760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08004760(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004760": "handle_external_interrupt_08004760"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800476a": {
            "entrypoint": "0x0800476a",
            "current_name": "handle_gpio_exti_interrupt_0800476a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupt_0800476a(void)\n\n{\n  handle_EXTI_IRQ(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800476a": "handle_gpio_exti_interrupt_0800476a",
                "HAL_GPIO_EXTI_IRQHandler": "handle_EXTI_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004774": {
            "entrypoint": "0x08004774",
            "current_name": "handle_exti_gpio4_interrupt_08004774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_EXTI_GPIO4_interrupt_08004774(void)\n\n{\n  initialize_GPIO_interrupt_handler(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004774": "handle_exti_gpio4_interrupt_08004774",
                "HAL_GPIO_EXTI_IRQHandler": "initialize_GPIO_interrupt_handler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800477e": {
            "entrypoint": "0x0800477e",
            "current_name": "handle_external_interrupt_0800477e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800477e(void)\n\n{\n  handleGPIOInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800477e": "handle_external_interrupt_0800477e",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004788": {
            "entrypoint": "0x08004788",
            "current_name": "handle_external_interrupt_08004788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08004788(void)\n\n{\n  handleGPIOInterrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004788": "handle_external_interrupt_08004788",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004792": {
            "entrypoint": "0x08004792",
            "current_name": "handle_interrupts_08004792",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupts_08004792(void)\n\n{\n  uint loopIndex;\n  \n  for (loopIndex = 0x20; loopIndex < 0x201; loopIndex = loopIndex << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loopIndex);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004792": "handle_interrupts_08004792",
                "uVar1": "loopIndex"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047a8": {
            "entrypoint": "0x080047a8",
            "current_name": "handle_gpio_exti_interrupts_080047a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupts_080047a8(void)\n\n{\n  uint interval;\n  \n  for (interval = 0x400; interval < 0x8001; interval = interval << 1) {\n    process_GPIO_EXTI_interrupt((GPIO_pin)interval);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047a8": "handle_gpio_exti_interrupts_080047a8",
                "uVar1": "interval",
                "HAL_GPIO_EXTI_IRQHandler": "process_GPIO_EXTI_interrupt",
                "uint16_t": "GPIO_pin"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "invoke_function_080047c0",
            "code": "\n/* DWARF original prototype: invokeFunction_080047c0  operator()(function<invokeFunction_080047c0()> * functionPtr) */\n\ninvokeFunction_080047c0 __functionPtrcall std::function<invokeFunction_080047c0()>::invoke_function_080047c0(function<invokeFunction_080047c0()> *functionPtr)\n\n{\n  if ((functionPtr->super__Function_base)._M_manager != nullManager) {\n    (*functionPtr->_M_invoker)((_Any_data *)functionPtr);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPtr",
                "(_Manager_type)0x0": "nullManager",
                "void": "invokeFunction",
                "FUN_080047c0": "invoke_function_080047c0"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "handle_gpio_interrupt_080047d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_interrupt_080047d0(uint16_t pin_number)\n\n{\n  byte pin_id;\n  uint8_t interrupt_id;\n  \n  pin_id = get_pin_id(pin_number);\n  if (gpio_irq_conf[pin_id].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pin_id].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "handle_gpio_interrupt_080047d0",
                "GPIO_Pin": "pin_number",
                "bVar1": "pin_id",
                "irq_id": "interrupt_id"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f0": {
            "entrypoint": "0x080047f0",
            "current_name": "initialize_static_data_080047f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080047f0(void)\n\n{\n  initialize_static_data_080047f0_helper(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047f0": "initialize_static_data_080047f0",
                "__static_initialization_and_destruction_0": "initialize_static_data_helper"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_exit_function_080047fe",
            "code": "\nvoid registerExitFunction_080047fe(undefined4 exitFunction,undefined4 param)\n\n{\n  __cxa_atexit(param,exitFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_exit_function_080047fe",
                "param_1": "exitFunction",
                "param_2": "param"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "print_assertion_error_08004808",
            "code": "\nvoid printAssertionError_08004808(undefined4 file,undefined4 line,char *functionName,undefined4 assertion)\n\n{\n  char *separator;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    separator = functionName;\n  }\n  else {\n    separator = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertion,file,line,separator,functionName,assertion);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08004808": "print_assertion_error_08004808",
                "param_1": "file",
                "param_2": "line",
                "param_3": "functionName",
                "param_4": "assertion",
                "pcVar1": "separator"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "shift_param_to_high_bits_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong shiftParamToHighBits_08004844(undefined4 param1,uint param2)\n\n{\n  return (ulonglong)param2 << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "shift_param_to_high_bits_08004844",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_formatted_to_file_08004860",
            "code": "\nint printFormattedToFile_08004860(FILE *fileStream,char *formatString,...)\n\n{\n  int result;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  undefined4 param4;\n  \n  param3 = param1;\n  param4 = param2;\n  result = _vfiprintf_r(impurePointer,fileStream,formatString,&param3,fileStream,&param3);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_formatted_to_file_08004860",
                "__stream": "fileStream",
                "__format": "formatString",
                "iVar1": "result",
                "in_r2": "param1",
                "in_r3": "param2",
                "uStack_8": "param3",
                "uStack_4": "param4",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "initialize_program_08004884",
            "code": "\nvoid initializeProgram_08004884(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&functionArray)[index])();\n  }\n  initializeLibrary();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&functionArray)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "initialize_program_08004884",
                "iVar1": "index",
                "__preinit_array_end": "functionArray",
                "_init": "initializeLibrary"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "memset_080048cc",
            "code": "\nvoid * memset_080048cc(void *dest,int ch,size_t count)\n\n{\n  undefined *currentByte;\n  \n  for (currentByte = (undefined *)dest; currentByte != (undefined *)(count + (int)dest); currentByte = currentByte + 1) {\n    *currentByte = (char)ch;\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "memset_080048cc",
                "__s": "dest",
                "__c": "ch",
                "__n": "count",
                "puVar1": "currentByte"
            },
            "calling": [
                "__sfmoreglue",
                "std.isra.0",
                "__sfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "allocate_memory_080048dc",
            "code": "\nvoid allocateMemory_080048dc(undefined4 *result,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int *temp;\n  int **extraOutput;\n  int **tempPtr1;\n  int **currentPtr;\n  int **previousPtr;\n  int **newPtr;\n  bool flag;\n  \n  if (size == 0) {\n    return;\n  }\n  newPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newPtr = (int **)((int)newPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  currentPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    newPtr[1] = (int *)0x0;\n    tempPtr1 = extraOutput;\n    __malloc_free_list = newPtr;\n  }\n  else {\n    currentPtr = __malloc_free_list;\n    if (newPtr < __malloc_free_list) {\n      tempPtr1 = (int **)*newPtr;\n      currentPtr = (int **)((int)newPtr + (int)tempPtr1);\n      flag = __malloc_free_list == currentPtr;\n      if (flag) {\n        currentPtr = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      newPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = newPtr;\n      if (flag) {\n        currentPtr = (int **)((int)currentPtr + (int)tempPtr1);\n        *newPtr = (int *)currentPtr;\n      }\n    }\n    else {\n      do {\n        previousPtr = currentPtr;\n        currentPtr = (int **)previousPtr[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= newPtr);\n      tempPtr1 = (int **)*previousPtr;\n      if ((int **)((int)previousPtr + (int)tempPtr1) == newPtr) {\n        tempPtr1 = (int **)((int)tempPtr1 + (int)*newPtr);\n        *previousPtr = (int *)tempPtr1;\n        if (currentPtr == (int **)((int)previousPtr + (int)tempPtr1)) {\n          temp = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          previousPtr[1] = (int *)currentPtr;\n          tempPtr1 = (int **)((int)tempPtr1 + (int)temp);\n          *previousPtr = (int *)tempPtr1;\n        }\n      }\n      else if (newPtr < (int **)((int)previousPtr + (int)tempPtr1)) {\n        *result = 0xc;\n      }\n      else {\n        tempPtr1 = (int **)((int)newPtr + (int)*newPtr);\n        flag = currentPtr == tempPtr1;\n        if (flag) {\n          tempPtr1 = (int **)*currentPtr;\n          currentPtr = (int **)currentPtr[1];\n        }\n        newPtr[1] = (int *)currentPtr;\n        if (flag) {\n          tempPtr1 = (int **)((int)tempPtr1 + (int)*newPtr);\n          *newPtr = (int *)tempPtr1;\n        }\n        previousPtr[1] = (int *)newPtr;\n      }\n    }\n  }\n  __malloc_unlock(result,tempPtr1,currentPtr,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "allocate_memory_080048dc",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "piVar1": "temp",
                "extraout_r1": "extraOutput",
                "ppiVar2": "tempPtr1",
                "ppiVar3": "currentPtr",
                "ppiVar4": "previousPtr",
                "ppiVar5": "newPtr",
                "bVar6": "flag"
            },
            "calling": [
                "__sflush_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_08004978",
            "code": "\nuint allocate_memory_08004978(undefined4 *err_code,uint size)\n\n{\n  uint *temp_ptr;\n  int difference;\n  uint *current_ptr;\n  uint temp_size;\n  uint *previous_ptr;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *err_code = 0xc;\n  }\n  else {\n    __malloc_lock();\n    temp_ptr = __malloc_free_list;\n    previous_ptr = __malloc_free_list;\n    while (current_ptr = temp_ptr, current_ptr != (uint *)0x0) {\n      temp_size = *current_ptr - allocated_size;\n      if (-1 < (int)temp_size) {\n        if (temp_size < 0xc) {\n          if (previous_ptr == current_ptr) {\n            temp_ptr = (uint *)previous_ptr[1];\n          }\n          else {\n            temp_ptr = (uint *)current_ptr[1];\n          }\n          if (previous_ptr != current_ptr) {\n            previous_ptr[1] = (uint)temp_ptr;\n            previous_ptr = current_ptr;\n            temp_ptr = __malloc_free_list;\n          }\n        }\n        else {\n          *current_ptr = temp_size;\n          *(uint *)((int)current_ptr + temp_size) = allocated_size;\n          previous_ptr = (uint *)((int)current_ptr + temp_size);\n          temp_ptr = __malloc_free_list;\n        }\n        goto LAB_080049dc;\n      }\n      previous_ptr = current_ptr;\n      temp_ptr = (uint *)current_ptr[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(err_code);\n    }\n    temp_ptr = (uint *)_sbrk_r(err_code,allocated_size);\n    if ((temp_ptr != (uint *)0xffffffff) &&\n       ((previous_ptr = (uint *)((int)temp_ptr + 3U & 0xfffffffc), temp_ptr == previous_ptr ||\n        (difference = _sbrk_r(err_code,(int)previous_ptr - (int)temp_ptr), difference != -1)))) {\n      *previous_ptr = allocated_size;\n      temp_ptr = __malloc_free_list;\nLAB_080049dc:\n      __malloc_free_list = temp_ptr;\n      __malloc_unlock(err_code);\n      allocated_size = (int)previous_ptr + 0xbU & 0xfffffff8;\n      difference = allocated_size - (int)(previous_ptr + 1);\n      if (difference != 0) {\n        *(int *)((int)previous_ptr + difference) = -difference;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *err_code = 0xc;\n    __malloc_unlock(err_code);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "err_code",
                "param_2": "size",
                "puVar1": "temp_ptr",
                "iVar2": "difference",
                "puVar3": "current_ptr",
                "uVar4": "temp_size",
                "puVar5": "previous_ptr",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "write_byte_to_file_08004a34",
            "code": "\nuint writeByteToFile_08004a34(undefined4 param1,byte byteToWrite,byte **fileData)\n\n{\n  uint returnValue;\n  byte *lastByteIndex;\n  \n  lastByteIndex = fileData[2] + -1;\n  fileData[2] = lastByteIndex;\n  if (((int)lastByteIndex < 0) && (((int)lastByteIndex < (int)fileData[6] || (byteToWrite == 10)))) {\n    returnValue = __swbuf_r();\n    return returnValue;\n  }\n  lastByteIndex = *fileData;\n  *fileData = lastByteIndex + 1;\n  *lastByteIndex = byteToWrite;\n  return (uint)byteToWrite;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "write_byte_to_file_08004a34",
                "param_1": "param1",
                "param_2": "byteToWrite",
                "param_3": "fileData",
                "uVar1": "returnValue",
                "pbVar2": "lastByteIndex"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "stream_writer_08004a60",
            "code": "\nint streamWriter_08004a60(undefined4 stream,undefined4 character,undefined *data,int length)\n\n{\n  int result;\n  undefined *endPtr;\n  int currentLength;\n  \n  endPtr = data + length;\n  currentLength = length;\n  do {\n    if (data == endPtr) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,character,length,currentLength);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "stream_writer_08004a60",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "endPtr",
                "iVar3": "currentLength"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "print_formatted_output_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint printFormattedOutput_08004a84(int formatString,undefined4 *outputStream,byte *arguments,int *errorCode)\n\n{\n  bool isNumber;\n  int returnValue;\n  void *memCharResult;\n  int *argPtr;\n  byte *currentChar;\n  byte *formatSpecifier;\n  int swSetupResult;\n  int numericValue;\n  int *argStack;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int fieldWidth;\n  int totalCharsPrinted;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined alternativeFormFlag;\n  undefined4 argIndex;\n  \n  argStack = errorCode;\n  if ((formatString != 0) && (*(int *)(formatString + 0x18) == 0)) {\n    __sinit();\n  }\n  if (outputStream == &__sf_fake_stdin) {\n    outputStream = *(undefined4 **)(formatString + 4);\n  }\n  else if (outputStream == (undefined4 *)&__sf_fake_stdout) {\n    outputStream = *(undefined4 **)(formatString + 8);\n  }\n  else if (outputStream == (undefined4 *)&__sf_fake_stderr) {\n    outputStream = *(undefined4 **)(formatString + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(outputStream + 3) << 0x1c)) || (outputStream[4] == 0)) &&\n     (numericValue = __swsetup_r(formatString,outputStream), numericValue != 0)) {\n    return -1;\n  }\n  totalCharsPrinted = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  currentChar = arguments;\nLAB_08004ac6:\n  formatSpecifier = currentChar;\n  if (*formatSpecifier != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  currentChar = formatSpecifier + 1;\n  if (*formatSpecifier != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  numericValue = (int)formatSpecifier - (int)arguments;\n  if (numericValue != 0) {\n    returnValue = __sfputs_r(formatString,outputStream,arguments,numericValue);\n    if (returnValue == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(outputStream + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalCharsPrinted;\n    }\n    totalCharsPrinted = totalCharsPrinted + numericValue;\n  }\n  if (*formatSpecifier == 0) goto LAB_08004c70;\n  flags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  width = 0;\n  alternativeFormFlag = 0;\n  argIndex = 0;\n  currentChar = formatSpecifier + 1;\n  while( true ) {\n    memCharResult = memchr(\"#-0+ \",(uint)*currentChar,5);\n    arguments = currentChar + 1;\n    if (memCharResult == (void *)0x0) break;\n    flags = 1 << ((int)memCharResult + 0xf7ffa094U & 0xff) | flags;\n    currentChar = arguments;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    alternativeFormFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    alternativeFormFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    argPtr = argStack + 1;\n    numericValue = *argStack;\n    argStack = argPtr;\n    if (numericValue < 0) {\n      fieldWidth = -numericValue;\n      flags = flags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    isNumber = false;\n    numericValue = fieldWidth;\n    arguments = currentChar;\n    while( true ) {\n      if (9 < *arguments - 0x30) break;\n      numericValue = numericValue * 10 + (*arguments - 0x30);\n      isNumber = true;\n      arguments = arguments + 1;\n    }\n    if (!isNumber) goto LAB_08004bae;\n  }\n  fieldWidth = numericValue;\nLAB_08004bae:\n  if (*arguments == 0x2e) {\n    if (arguments[1] == 0x2a) {\n      precision = *argStack;\n      if (precision < 0) {\n        precision = -1;\n      }\n      arguments = arguments + 2;\n      argStack = argStack + 1;\n    }\n    else {\n      isNumber = false;\n      precision = 0;\n      numericValue = 0;\n      while( true ) {\n        arguments = arguments + 1;\n        if (9 < *arguments - 0x30) break;\n        numericValue = numericValue * 10 + (*arguments - 0x30);\n        isNumber = true;\n      }\n      if (isNumber) {\n        precision = numericValue;\n      }\n    }\n  }\n  memCharResult = memchr(&DAT_08005f72,(uint)*arguments,3);\n  if (memCharResult != (void *)0x0) {\n    flags = flags | 0x40 << ((int)memCharResult + 0xf7ffa08eU & 0xff);\n    arguments = arguments + 1;\n  }\n  conversionSpecifier = *arguments;\n  arguments = arguments + 1;\n  memCharResult = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (memCharResult == (void *)0x0) {\n    swSetupResult = _printf_i(formatString,&flags,outputStream,0x8004a61,&argStack);\n    if (swSetupResult == -1) goto LAB_08004c70;\n  }\n  else {\n    argStack = (int *)(((int)argStack + 7U & 0xfffffff8) + 8);\n  }\n  totalCharsPrinted = totalCharsPrinted + swSetupResult;\n  currentChar = arguments;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "print_formatted_output_08004a84",
                "param_1": "formatString",
                "param_2": "outputStream",
                "param_3": "arguments",
                "param_4": "errorCode",
                "bVar1": "isNumber",
                "iVar2": "returnValue",
                "pvVar3": "memCharResult",
                "piVar4": "argPtr",
                "pbVar5": "currentChar",
                "pbVar6": "formatSpecifier",
                "unaff_r9": "swSetupResult",
                "iVar7": "numericValue",
                "local_8c": "argStack",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "fieldWidth",
                "local_74": "totalCharsPrinted",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "alternativeFormFlag",
                "local_30": "argIndex"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "memchr",
                "__swsetup_r",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "process_data_08004cb0",
            "code": "\nundefined4\nprocessData_08004cb0(undefined4 input,uint *data,uint *output,undefined4 param,code *processByte)\n\n{\n  int loopIndex1;\n  int loopIndex2;\n  uint maxValue;\n  uint count;\n  bool isFlagOn;\n  \n  maxValue = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxValue = data[2];\n  }\n  *output = maxValue;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *output = maxValue + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (loopIndex1 = 0; loopIndex1 < (int)(data[3] - *output); loopIndex1 = loopIndex1 + 1) {\n      loopIndex2 = (*processByte)(input,param,(int)data + 0x19,1);\n      if (loopIndex2 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)data + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxValue + 0x43) = 0x30;\n    *(undefined *)((int)data + maxValue + 0x44) = *(undefined *)((int)data + 0x45);\n    maxValue = maxValue + 2;\n  }\n  loopIndex1 = (*processByte)(input,param,(int)data + 0x43,maxValue);\n  if (loopIndex1 != -1) {\n    maxValue = data[3];\n    isFlagOn = (*data & 6) == 4;\n    if (isFlagOn) {\n      maxValue = maxValue - *output;\n    }\n    if (isFlagOn) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    else {\n      maxValue = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxValue = maxValue + (data[2] - data[4]);\n    }\n    count = 0;\n    while( true ) {\n      if (maxValue == count) {\n        return 0;\n      }\n      loopIndex1 = (*processByte)(input,param,(int)data + 0x1a,1);\n      if (loopIndex1 == -1) break;\n      count = count + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "process_data_08004cb0",
                "param_1": "input",
                "param_2": "data",
                "param_3": "output",
                "param_4": "param",
                "param_5": "processByte",
                "iVar1": "loopIndex1",
                "iVar2": "loopIndex2",
                "uVar3": "maxValue",
                "uVar4": "count",
                "bVar5": "isFlagOn"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "print_formatted_string_08004d9c",
            "code": "\nuint print_formatted_string_08004d9c(undefined4 format_string,uint *args,undefined4 args_count,code *write_function,uint **args_ptr)\n\n{\n  byte format_type;\n  int result;\n  uint *arg_ptr;\n  void *char_ptr;\n  int write_result;\n  char *hex_chars;\n  uint current_char;\n  uint **arg_ptr_ptr;\n  char **char_ptr_ptr;\n  uint num;\n  uint len;\n  char *current_char_ptr;\n  char *buffer;\n  uint buffer_size [2];\n  \n  format_type = *(byte *)(args + 6);\n  buffer = (char *)((int)args + 0x43);\n  if (format_type != 0x6e) {\n    if (format_type < 0x6f) {\n      if (format_type != 99) {\n        if (format_type < 100) {\n          if (format_type == 0) goto LAB_08004f56;\n          if (format_type != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)args + 0x45) = 0x58;\n          hex_chars = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          current_char = *args;\n          arg_ptr = *args_ptr;\n          *args_ptr = arg_ptr + 1;\n          if (((current_char & 0x80) == 0) && ((int)(current_char << 0x19) < 0)) {\n            num = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            num = *arg_ptr;\n          }\n          if ((int)(current_char << 0x1f) < 0) {\n            *args = current_char | 0x20;\n          }\n          if (num == 0) {\n            *args = *args & 0xffffffdf;\n          }\n          current_char = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)args + 0x43) = 0;\n        }\n        else {\n          if ((format_type != 100) && (format_type != 0x69)) goto LAB_08004dcc;\n          num = *args;\n          arg_ptr = *args_ptr;\n          if ((num & 0x80) == 0) {\n            *args_ptr = arg_ptr + 1;\n            if ((num & 0x40) == 0) goto LAB_08004dec;\n            num = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *args_ptr = arg_ptr + 1;\nLAB_08004dec:\n            num = *arg_ptr;\n          }\n          if ((int)num < 0) {\n            num = -num;\n            *(undefined *)((int)args + 0x43) = 0x2d;\n          }\n          hex_chars = \"0123456789ABCDEF\";\n          current_char = 10;\n        }\n        len = args[1];\n        args[2] = len;\n        current_char_ptr = buffer;\n        if ((int)len < 0) {\n          if (num != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)args + 0x42) = *hex_chars;\n          current_char_ptr = (char *)((int)args + 0x42);\n        }\n        else {\n          *args = *args & 0xfffffffb;\n          if (num == 0) {\n            if (len != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              len = num / current_char;\n              current_char_ptr = current_char_ptr + -1;\n              *current_char_ptr = hex_chars[num - current_char * len];\n              num = len;\n            } while (len != 0);\n          }\n        }\n        if (((current_char == 8) && ((int)(*args << 0x1f) < 0)) && ((int)args[1] <= (int)args[4]))\n        {\n          current_char_ptr[-1] = '0';\n          current_char_ptr = current_char_ptr + -1;\n        }\n        args[4] = (int)buffer - (int)current_char_ptr;\n        buffer = current_char_ptr;\n        goto LAB_08004ec2;\n      }\n      arg_ptr = *args_ptr;\n      *args_ptr = arg_ptr + 1;\n      *(char *)((int)args + 0x42) = (char)*arg_ptr;\nLAB_08004e2c:\n      buffer = (char *)((int)args + 0x42);\n      num = 1;\n    }\n    else {\n      if (format_type != 0x73) {\n        if (format_type < 0x74) {\n          if (format_type == 0x6f) {\nLAB_08004e52:\n            num = *args;\n            arg_ptr = *args_ptr;\n            if ((num & 0x80) == 0) {\n              *args_ptr = arg_ptr + 1;\n              if ((num & 0x40) == 0) goto LAB_08004e60;\n              num = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *args_ptr = arg_ptr + 1;\nLAB_08004e60:\n              num = *arg_ptr;\n            }\n            hex_chars = \"0123456789ABCDEF\";\n            if (format_type == 0x6f) {\n              current_char = 8;\n            }\n            else {\n              current_char = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (format_type == 0x70) {\n            *args = *args | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)args + 0x45) = 0x78;\n            hex_chars = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (format_type == 0x75) goto LAB_08004e52;\n          if (format_type == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)args + 0x42) = format_type;\n        goto LAB_08004e2c;\n      }\n      char_ptr_ptr = (char **)*args_ptr;\n      *args_ptr = (uint *)(char_ptr_ptr + 1);\n      buffer = *char_ptr_ptr;\n      char_ptr = memchr(buffer,0,args[1]);\n      if (char_ptr != (void *)0x0) {\n        args[1] = (int)char_ptr - (int)buffer;\n      }\n      num = args[1];\n    }\n    args[4] = num;\n    *(undefined *)((int)args + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  num = *args;\n  arg_ptr_ptr = (uint **)*args_ptr;\n  current_char = args[5];\n  if ((num & 0x80) == 0) {\n    *args_ptr = (uint *)(arg_ptr_ptr + 1);\n    arg_ptr = *arg_ptr_ptr;\n    if ((num & 0x40) == 0) goto LAB_08004f42;\n    *(short *)arg_ptr = (short)current_char;\n  }\n  else {\n    *args_ptr = (uint *)(arg_ptr_ptr + 1);\n    arg_ptr = *arg_ptr_ptr;\nLAB_08004f42:\n    *arg_ptr = current_char;\n  }\nLAB_08004f56:\n  args[4] = 0;\nLAB_08004ec2:\n  result = _printf_common(format_string,args,buffer_size,args_count,write_function);\n  if ((result == -1) || (result = (*write_function)(format_string,args_count,buffer,args[4]), result == -1)) {\nLAB_08004ed6:\n    num = 0xffffffff;\n  }\n  else {\n    if ((int)(*args << 0x1e) < 0) {\n      for (result = 0; result < (int)(args[3] - buffer_size[0]); result = result + 1) {\n        write_result = (*write_function)(format_string,args_count,(int)args + 0x19,1);\n        if (write_result == -1) goto LAB_08004ed6;\n      }\n    }\n    num = args[3];\n    if ((int)args[3] < (int)buffer_size[0]) {\n      num = buffer_size[0];\n    }\n  }\n  return num;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "print_formatted_string_08004d9c",
                "param_1": "format_string",
                "param_2": "args",
                "param_3": "args_count",
                "param_4": "write_function",
                "param_5": "args_ptr",
                "bVar1": "format_type",
                "iVar2": "result",
                "puVar3": "arg_ptr",
                "pvVar4": "char_ptr",
                "iVar5": "write_result",
                "pcVar6": "hex_chars",
                "uVar7": "current_char",
                "ppuVar8": "arg_ptr_ptr",
                "ppcVar9": "char_ptr_ptr",
                "uVar10": "num",
                "uVar11": "len",
                "pcVar12": "current_char_ptr",
                "__s": "buffer",
                "local_24": "buffer_size"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "formatted_print_08004fdc",
            "code": "\nint formattedPrint_08004fdc(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *formatPtr;\n  undefined4 inReg1;\n  undefined4 inReg2;\n  undefined4 inReg3;\n  \n  impurePtr = _impure_ptr;\n  formatPtr = formatString;\n  inReg1 = in_r1;\n  inReg2 = in_r2;\n  inReg3 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&inReg1,formatPtr,&inReg1);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "formatted_print_08004fdc",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "pcVar2": "formatPtr",
                "uStack_c": "inReg1",
                "uStack_8": "inReg2",
                "uStack_4": "inReg3"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocate_memory_0800500c(int *error_code,intptr_t size)\n\n{\n  void *allocated_ptr;\n  \n  errno = 0;\n  allocated_ptr = _sbrk(size);\n  if ((allocated_ptr == (void *)0xffffffff) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "error_code",
                "param_2": "size",
                "pvVar1": "allocated_ptr"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800502c": {
            "entrypoint": "0x0800502c",
            "current_name": "write_to_stream_0800502c",
            "code": "\nuint write_to_stream_0800502c(int stream,uint character,int *stream_buffer,undefined4 stream_lock)\n\n{\n  int result;\n  uint ushort_value;\n  undefined *next_byte;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == &__sf_fake_stdin) {\n    stream_buffer = *(int **)(stream + 4);\n  }\n  else if (stream_buffer == (int *)&__sf_fake_stdout) {\n    stream_buffer = *(int **)(stream + 8);\n  }\n  else if (stream_buffer == (int *)&__sf_fake_stderr) {\n    stream_buffer = *(int **)(stream + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  ushort_value = (uint)*(ushort *)(stream_buffer + 3);\n  result = ushort_value << 0x1c;\n  if (((result < 0) && (ushort_value = stream_buffer[4], ushort_value != 0)) ||\n     (result = __swsetup_r(stream,stream_buffer,result,ushort_value,stream_lock), result == 0)) {\n    result = *stream_buffer - stream_buffer[4];\n    character = character & 0xff;\n    if ((result < stream_buffer[5]) || (result = _fflush_r(stream,stream_buffer), result == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      next_byte = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(next_byte + 1);\n      *next_byte = (char)character;\n      if (result + 1 != stream_buffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      result = _fflush_r(stream,stream_buffer);\n      if (result == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800502c": "write_to_stream_0800502c",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "stream_buffer",
                "param_4": "stream_lock",
                "iVar1": "result",
                "uVar2": "ushort_value",
                "puVar3": "next_byte"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "process_file_080050d0",
            "code": "\nuint processFile_080050d0(undefined4 *inputStream,undefined4 *outputStream)\n\n{\n  int globalPtr;\n  uint result;\n  ushort streamFlags;\n  \n  globalPtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (outputStream == &__sf_fake_stdin) {\n    outputStream = *(undefined4 **)(globalPtr + 4);\n  }\n  else if (outputStream == (undefined4 *)&__sf_fake_stdout) {\n    outputStream = *(undefined4 **)(globalPtr + 8);\n  }\n  else if (outputStream == (undefined4 *)&__sf_fake_stderr) {\n    outputStream = *(undefined4 **)(globalPtr + 0xc);\n  }\n  streamFlags = *(ushort *)(outputStream + 3);\n  result = (uint)streamFlags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *inputStream = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)outputStream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)outputStream[0xd] != outputStream + 0x11) {\n          _free_r(inputStream);\n        }\n        outputStream[0xd] = 0;\n      }\n      *(ushort *)(outputStream + 3) = *(ushort *)(outputStream + 3) & 0xffdb;\n      outputStream[1] = 0;\n      *outputStream = outputStream[4];\n    }\n    *(ushort *)(outputStream + 3) = *(ushort *)(outputStream + 3) | 8;\n  }\n  if ((outputStream[4] == 0) && ((*(ushort *)(outputStream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(inputStream,outputStream);\n  }\n  streamFlags = *(ushort *)(outputStream + 3);\n  result = streamFlags & 1;\n  if ((streamFlags & 1) == 0) {\n    if (-1 < (int)((uint)streamFlags << 0x1e)) {\n      result = outputStream[5];\n    }\n    outputStream[2] = result;\n  }\n  else {\n    outputStream[2] = 0;\n    outputStream[6] = -outputStream[5];\n  }\n  if (outputStream[4] == 0) {\n    streamFlags = *(ushort *)(outputStream + 3);\n    result = (int)(short)streamFlags & 0x80;\n    if (result != 0) {\nLAB_08005100:\n      *(ushort *)(outputStream + 3) = streamFlags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "process_file_080050d0",
                "param_1": "inputStream",
                "param_2": "outputStream",
                "iVar1": "globalPtr",
                "uVar2": "result",
                "uVar3": "streamFlags"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sinit",
                "_free_r",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "handle_error_and_exit_080051ac",
            "code": "\n\n\nvoid handleErrorAndExit_080051ac(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_080051ac": "handle_error_and_exit_080051ac"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "raise",
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051bc": {
            "entrypoint": "0x080051bc",
            "current_name": "process_data_080051bc",
            "code": "\nundefined4 processData_080051bc(uint *inputData,int *outputData)\n\n{\n  int temp1;\n  int *temp2;\n  uint flag;\n  ushort value;\n  int temp3;\n  code *callback;\n  int temp4;\n  uint temp5;\n  bool isZero;\n  \n  value = *(ushort *)(outputData + 3);\n  flag = (uint)value;\n  if ((int)(flag << 0x1c) < 0) {\n    temp1 = outputData[4];\n    if (temp1 != 0) {\n      temp3 = flag << 0x1e;\n      isZero = temp3 == 0;\n      temp4 = *outputData;\n      if (isZero) {\n        temp3 = outputData[5];\n      }\n      *outputData = temp1;\n      if (!isZero) {\n        temp3 = 0;\n      }\n      outputData[2] = temp3;\n      for (temp4 = temp4 - temp1; 0 < temp4; temp4 = temp4 - temp3) {\n        temp3 = (*(code *)outputData[10])(inputData,outputData[8],temp1,temp4);\n        if (temp3 < 1) {\n          value = *(ushort *)(outputData + 3);\n          goto LAB_080052b2;\n        }\n        temp1 = temp1 + temp3;\n      }\n    }\n  }\n  else if (((0 < outputData[1]) || (0 < outputData[0x10])) &&\n          (callback = (code *)outputData[0xb], callback != (code *)0x0)) {\n    temp5 = *inputData;\n    *inputData = 0;\n    if ((value & 0x1000) == 0) {\n      temp1 = (*callback)(inputData,outputData[8],flag & 0x1000,1);\n      if ((temp1 == -1) && (flag = *inputData, flag != 0)) {\n        if ((flag != 0x1d) && (flag != 0x16)) {\n          *(ushort *)(outputData + 3) = *(ushort *)(outputData + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *inputData = temp5;\n        return 0;\n      }\n    }\n    else {\n      temp1 = outputData[0x15];\n    }\n    if (((int)((uint)*(ushort *)(outputData + 3) << 0x1d) < 0) &&\n       (temp1 = temp1 - outputData[1], outputData[0xd] != 0)) {\n      temp1 = temp1 - outputData[0x10];\n    }\n    temp1 = (*(code *)outputData[0xb])(inputData,outputData[8],temp1,0);\n    value = *(ushort *)(outputData + 3);\n    if ((temp1 == -1) &&\n       ((0x1d < *inputData || (-1 < (int)((0x20400001U >> (*inputData & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(outputData + 3) = value | 0x40;\n      return 0xffffffff;\n    }\n    outputData[1] = 0;\n    *outputData = outputData[4];\n    if (((int)((uint)value << 0x13) < 0) && ((temp1 != -1 || (*inputData == 0)))) {\n      outputData[0x15] = temp1;\n    }\n    temp2 = (int *)outputData[0xd];\n    *inputData = temp5;\n    if (temp2 != (int *)0x0) {\n      if (temp2 != outputData + 0x11) {\n        _free_r(inputData);\n      }\n      outputData[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080051bc": "process_data_080051bc",
                "param_1": "inputData",
                "param_2": "outputData",
                "iVar1": "temp1",
                "piVar2": "temp2",
                "uVar3": "flag",
                "uVar4": "value",
                "iVar5": "temp3",
                "pcVar6": "callback",
                "iVar7": "temp4",
                "uVar8": "temp5",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "flush_and_reset_stream_080052cc",
            "code": "\nundefined4 flushAndResetStream_080052cc(int streamPtr,undefined4 *stream,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 returnValue;\n  \n  if (stream[4] != 0) {\n    if ((streamPtr != 0) && (*(int *)(streamPtr + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == &__sf_fake_stdin) {\n      stream = *(undefined4 **)(streamPtr + 4);\n    }\n    else if (stream == (undefined4 *)&__sf_fake_stdout) {\n      stream = *(undefined4 **)(streamPtr + 8);\n    }\n    else if (stream == (undefined4 *)&__sf_fake_stderr) {\n      stream = *(undefined4 **)(streamPtr + 0xc);\n    }\n    if (*(short *)(stream + 3) != 0) {\n      returnValue = __sflush_r(streamPtr,stream,param3,param4);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "flush_and_reset_stream_080052cc",
                "param_1": "streamPtr",
                "param_2": "stream",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "returnValue"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005320": {
            "entrypoint": "0x08005320",
            "current_name": "execute_fwalk_reent_08005320",
            "code": "\nvoid execute_fwalk_reent_08005320(undefined4 param)\n\n{\n  execute_fwalk_reent_08005320rant(param,0x80052cd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005320": "execute_fwalk_reent_08005320",
                "param_1": "param",
                "_fwalk_reent": "execute_fwalk_reentrant"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_data_0800532c",
            "code": "\nvoid initializeData_0800532c(undefined4 *data,undefined2 value1,undefined2 value2)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[0x19] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[9] = 0x8005609;\n  data[10] = 0x800562b;\n  data[0xb] = 0x8005663;\n  data[8] = data;\n  data[0xc] = 0x8005687;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_data_0800532c",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "allocate_memory_08005374",
            "code": "\nundefined4 * allocateMemory_08005374(undefined4 size,int count)\n\n{\n  undefined4 *ptr;\n  int offset;\n  \n  offset = (count + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(size,offset + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = count;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,offset + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08005374": "allocate_memory_08005374",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "ptr",
                "iVar2": "offset"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_data_080053a0",
            "code": "\nvoid initializeData_080053a0(undefined1 *dataPtr)\n\n{\n  undefined4 sfpResult;\n  undefined1 *impureDataPtr;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    impureDataPtr = impureDataPtr;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8005321;\n    if (dataPtr == impureDataPtr) {\n      impureDataPtr = (undefined1 *)0x1;\n    }\n    if (dataPtr == impureDataPtr) {\n      *(undefined1 **)(dataPtr + 0x18) = impureDataPtr;\n    }\n    sfpResult = getSfpValue();\n    *(undefined4 *)(dataPtr + 4) = sfpResult;\n    sfpResult = getSfpValue(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = sfpResult;\n    sfpResult = getSfpValue(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = sfpResult;\n    setFlag(*(undefined4 *)(dataPtr + 4),4,0);\n    setFlag(*(undefined4 *)(dataPtr + 8),9,1);\n    setFlag(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_data_080053a0",
                "param_1": "dataPtr",
                "uVar1": "sfpResult",
                "puVar2": "impureDataPtr",
                "&impure_data": "impureDataPtr",
                "__sfp": "getSfpValue",
                "std_isra_0": "setFlag"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r",
                "iprintf",
                "_fflush_r",
                "__swsetup_r",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_struct_08005400",
            "code": "\nint * initializeStruct_08005400(undefined4 *paramList)\n\n{\n  int *currentStruct;\n  int *nextStruct;\n  int **structList;\n  \n  if (DAT_200000bc == 0) {\n    __sinit(&impure_data);\n  }\n  structList = (int **)&DAT_200000ec;\n  do {\n    nextStruct = structList[2];\n    currentStruct = structList[1];\n    while (currentStruct = (int *)((int)currentStruct + -1), -1 < (int)currentStruct) {\n      if (*(short *)(nextStruct + 3) == 0) {\n        *(undefined2 *)((int)nextStruct + 0xe) = 0xffff;\n        *(undefined2 *)(nextStruct + 3) = 1;\n        nextStruct[0x19] = 0;\n        *nextStruct = 0;\n        nextStruct[2] = 0;\n        nextStruct[1] = 0;\n        nextStruct[4] = 0;\n        nextStruct[5] = 0;\n        nextStruct[6] = 0;\n        memset(nextStruct + 0x17,0,8);\n        nextStruct[0xd] = 0;\n        nextStruct[0xe] = 0;\n        nextStruct[0x12] = 0;\n        nextStruct[0x13] = 0;\n        return nextStruct;\n      }\n      nextStruct = nextStruct + 0x1a;\n    }\n    if (*structList == (int *)0x0) {\n      currentStruct = (int *)__sfmoreglue(paramList,4);\n      *structList = currentStruct;\n      if (currentStruct == (int *)0x0) {\n        *paramList = 0xc;\n        return (int *)0x0;\n      }\n    }\n    structList = (int **)*structList;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_struct_08005400",
                "param_1": "paramList",
                "piVar1": "currentStruct",
                "piVar2": "nextStruct",
                "ppiVar3": "structList"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sinit",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005478": {
            "entrypoint": "0x08005478",
            "current_name": "process_data_08005478",
            "code": "\nuint processData_08005478(int inputData,code *callback,undefined4 paramA,undefined4 paramB)\n\n{\n  uint result;\n  int var1;\n  int *ptr;\n  int var2;\n  uint flags;\n  int var3;\n  \n  flags = 0;\n  for (ptr = (int *)(inputData + 0x48); ptr != (int *)0x0; ptr = (int *)*ptr) {\n    var2 = ptr[2];\n    var3 = ptr[1];\n    while (var3 = var3 + -1, -1 < var3) {\n      if ((1 < *(ushort *)(var2 + 0xc)) && (var1 = *(short *)(var2 + 0xe) + 1, var1 != 0)) {\n        result = (*callback)(inputData,var2,paramA,var1,paramB);\n        flags = flags | result;\n      }\n      var2 = var2 + 0x68;\n    }\n  }\n  return flags;\n}\n\n",
            "renaming": {
                "FUN_08005478": "process_data_08005478",
                "param_1": "inputData",
                "param_2": "callback",
                "param_3": "paramA",
                "param_4": "paramB",
                "uVar1": "result",
                "iVar2": "var1",
                "piVar3": "ptr",
                "iVar4": "var2",
                "uVar5": "flags",
                "iVar6": "var3"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_file_permission_080054b4",
            "code": "\nundefined4 checkFilePermission_080054b4(undefined4 fileDescriptor,int fileInfo,undefined4 *resultFlag,uint *isExecutable)\n\n{\n  int fileStatus;\n  undefined4 permissionFlag;\n  undefined stackVariable [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (fileStatus = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),stackVariable), fileStatus < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      permissionFlag = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  permissionFlag = 0x400;\nLAB_080054f4:\n  *resultFlag = permissionFlag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_file_permission_080054b4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "resultFlag",
                "param_4": "isExecutable",
                "iVar1": "fileStatus",
                "uVar2": "permissionFlag",
                "auStack_4c": "stackVariable",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "initialize_buffer_080054fc",
            "code": "\nvoid initializeBuffer_080054fc(int bufferSize,int *buffer)\n\n{\n  ushort status;\n  int allocatedMemory;\n  int tempBuffer;\n  int *tempPtr;\n  \n  if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x1e)) {\n    tempBuffer = bufferSize;\n    tempPtr = buffer;\n    status = __swhatbuf_r(bufferSize,buffer,&tempBuffer,&tempPtr);\n    allocatedMemory = _malloc_r(bufferSize,tempBuffer);\n    if (allocatedMemory != 0) {\n      *(undefined4 *)(bufferSize + 0x28) = 0x8005321;\n      *buffer = allocatedMemory;\n      *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x80;\n      buffer[5] = tempBuffer;\n      buffer[4] = allocatedMemory;\n      if ((tempPtr != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(bufferSize,(int)*(short *)((int)buffer + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(buffer + 3) = status | *(ushort *)(buffer + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(buffer + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 2;\n  }\n  *buffer = (int)buffer + 0x47;\n  buffer[4] = (int)buffer + 0x47;\n  buffer[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "initialize_buffer_080054fc",
                "param_1": "bufferSize",
                "param_2": "buffer",
                "uVar1": "status",
                "iVar2": "allocatedMemory",
                "local_18": "tempBuffer",
                "local_14": "tempPtr"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005580": {
            "entrypoint": "0x08005580",
            "current_name": "execute_process_08005580",
            "code": "\nundefined4 executeProcess_08005580(undefined4 *output,uint processIndex,undefined4 arg3,undefined4 arg4)\n\n{\n  __pid_t pid;\n  undefined4 result;\n  int processArray;\n  code *functionPtr;\n  \n  if (0x1f < processIndex) {\n    *output = 0x16;\n    return 0xffffffff;\n  }\n  processArray = output[0x11];\n  if ((processArray != 0) && (functionPtr = *(code **)(processArray + processIndex * 4), functionPtr != (code *)0x0)) {\n    if (functionPtr != (code *)0x1) {\n      if (functionPtr == (code *)0xffffffff) {\n        *output = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(processArray + processIndex * 4) = 0;\n      (*functionPtr)(processIndex);\n    }\n    return 0;\n  }\n  pid = _getpid_r();\n  result = _kill_r(output,pid,processIndex,arg4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005580": "execute_process_08005580",
                "param_1": "output",
                "param_2": "processIndex",
                "param_3": "arg3",
                "param_4": "arg4",
                "_Var1": "pid",
                "uVar2": "result",
                "iVar3": "processArray",
                "pcVar4": "functionPtr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "execute_signal_handler_080055d0",
            "code": "\nint execute_signal_handler_080055d0(int signal_number)\n\n{\n  int raise_result;\n  \n  raise_result = _raise_r(pointer_impure,signal_number);\n  return raise_result;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "execute_signal_handler_080055d0",
                "__sig": "signal_number",
                "_impure_ptr": "pointer_impure",
                "iVar1": "raise_result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "perform_kill_operation_080055e0",
            "code": "\nvoid performKillOperation_080055e0(int *errorNum,__pid_t processID,int signalNum)\n\n{\n  int killResult;\n  \n  errno = 0;\n  killResult = _kill(processID,signalNum);\n  if ((killResult == -1) && (errno != 0)) {\n    *errorNum = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "perform_kill_operation_080055e0",
                "param_1": "errorNum",
                "param_2": "processID",
                "param_3": "signalNum",
                "iVar1": "killResult"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "update_data_08005608",
            "code": "\nvoid updateData_08005608(undefined4 fileDescriptor,int dataAddress)\n\n{\n  int bytesRead;\n  uint updatedValue;\n  bool isPositive;\n  \n  bytesRead = _read_r(fileDescriptor,(int)*(short *)(dataAddress + 0xe));\n  isPositive = -1 < bytesRead;\n  if (isPositive) {\n    updatedValue = *(int *)(dataAddress + 0x54) + bytesRead;\n  }\n  else {\n    updatedValue = *(ushort *)(dataAddress + 0xc) & 0xffffefff;\n  }\n  if (isPositive) {\n    *(uint *)(dataAddress + 0x54) = updatedValue;\n  }\n  if (!isPositive) {\n    *(short *)(dataAddress + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "update_data_08005608",
                "param_1": "fileDescriptor",
                "param_2": "dataAddress",
                "iVar1": "bytesRead",
                "uVar2": "updatedValue",
                "bVar3": "isPositive"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "update_file_0800562a",
            "code": "\nvoid updateFile_0800562a(undefined4 fileDescriptor,int bufferAddress,undefined4 sourceAddress,undefined4 count)\n\n{\n  if ((int)((uint)*(ushort *)(bufferAddress + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),0,2);\n  }\n  *(ushort *)(bufferAddress + 0xc) = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  _write_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),sourceAddress,count);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "update_file_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "param_3": "sourceAddress",
                "param_4": "count"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "update_file_position_08005662",
            "code": "\nvoid updateFilePosition_08005662(undefined4 fileDescriptor,int context)\n\n{\n  int seekResult;\n  ushort modifiedFlag;\n  bool seekFailed;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(context + 0xe));\n  seekFailed = seekResult == -1;\n  if (seekFailed) {\n    modifiedFlag = *(ushort *)(context + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(context + 0x54) = seekResult;\n    modifiedFlag = *(ushort *)(context + 0xc) | 0x1000;\n  }\n  if (seekFailed) {\n    *(ushort *)(context + 0xc) = modifiedFlag;\n  }\n  if (!seekFailed) {\n    *(ushort *)(context + 0xc) = modifiedFlag;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "update_file_position_08005662",
                "param_1": "fileDescriptor",
                "param_2": "context",
                "iVar1": "seekResult",
                "uVar2": "modifiedFlag",
                "bVar3": "seekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005686": {
            "entrypoint": "0x08005686",
            "current_name": "close_file_descriptor_08005686",
            "code": "\nvoid closeFileDescriptor_08005686(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005686": "close_file_descriptor_08005686",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "write_to_stream_08005690",
            "code": "\nvoid writeToStream_08005690(int *errorPtr,int stream,char *buffer,int size)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(stream,buffer,size);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorPtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "write_to_stream_08005690",
                "param_1": "errorPtr",
                "param_2": "stream",
                "param_3": "buffer",
                "param_4": "size",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056b4": {
            "entrypoint": "0x080056b4",
            "current_name": "close_file_and_handle_error_080056b4",
            "code": "\nvoid closeFileAndHandleError_080056b4(int *errorFlag,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056b4": "close_file_and_handle_error_080056b4",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "get_file_status_080056d4",
            "code": "\nvoid get_file_status_080056d4(int *error_code,int file_descriptor,stat *status)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,status);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "get_file_status_080056d4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "status",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_tty_support_080056f8",
            "code": "\nvoid check_tty_support_080056f8(int *error_code,int file_descriptor)\n\n{\n  int is_tty;\n  \n  error_number = 0;\n  is_tty = _isatty(file_descriptor);\n  if ((is_tty == -1) && (error_number != 0)) {\n    *error_code = error_number;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_tty_support_080056f8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "iVar1": "is_tty",
                "errno": "error_number"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "set_file_pointer_and_handle_errors_08005718",
            "code": "\nvoid setFilePointerAndHandleErrors_08005718(int *errorCode,int fileDescriptor,__off_t offset,int origin)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,origin);\n  if ((result == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "set_file_pointer_and_handle_errors_08005718",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_and_store_0800573c",
            "code": "\nvoid readAndStore_0800573c(int *errorPtr,int fileDescriptor,char *buffer,int bufferSize)\n\n{\n  int bytesRead;\n  \n  errorCode = 0;\n  bytesRead = _read(fileDescriptor,buffer,bufferSize);\n  if ((bytesRead == -1) && (errorCode != 0)) {\n    *errorPtr = errorCode;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_and_store_0800573c",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "bufferSize",
                "errno": "errorCode",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "terminate_function_08005760",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::terminateFunction_08005760(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08005760": "terminate_function_08005760"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005768": {
            "entrypoint": "0x08005768",
            "current_name": "initialize_c_type_08005768",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCType_08005768(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005768": "initialize_c_type_08005768"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800582c": {
            "entrypoint": "0x0800582c",
            "current_name": "initialize_ctype_functions_0800582c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCtypeFunctions_0800582c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800582c": "initialize_ctype_functions_0800582c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058f0": {
            "entrypoint": "0x080058f0",
            "current_name": "initialize_locale_info_080058f0",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocaleInfo_080058f0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058f0": "initialize_locale_info_080058f0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005974": {
            "entrypoint": "0x08005974",
            "current_name": "initialize_char_type_08005974",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCharType_08005974(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005974": "initialize_char_type_08005974"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 143106,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000218",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000682",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c4c",
            "FUN_08000c64",
            "FUN_08000c7c",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f3c",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800311c",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035ac",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_08003798",
            "FUN_080037ac",
            "FUN_080037c0",
            "FUN_080037d4",
            "FUN_080037e8",
            "FUN_080037fc",
            "FUN_08003810",
            "FUN_0800382c",
            "FUN_08003840",
            "FUN_08003854",
            "FUN_08003868",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003918",
            "FUN_08003928",
            "FUN_08003938",
            "FUN_08003948",
            "FUN_08003958",
            "FUN_08003968",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08003f94",
            "FUN_08003fd4",
            "FUN_08003fec",
            "FUN_08004004",
            "FUN_0800401c",
            "FUN_08004034",
            "FUN_0800404c",
            "FUN_08004064",
            "FUN_0800407c",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_0800420c",
            "FUN_08004240",
            "FUN_08004254",
            "FUN_08004270",
            "FUN_08004298",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_080044fc",
            "FUN_0800450a",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_0800458c",
            "FUN_0800459a",
            "FUN_080045be",
            "FUN_080045c8",
            "FUN_08004622",
            "FUN_08004638",
            "FUN_08004640",
            "FUN_08004648",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_0800468c",
            "FUN_080046b4",
            "FUN_08004760",
            "FUN_0800476a",
            "FUN_08004774",
            "FUN_0800477e",
            "FUN_08004788",
            "FUN_08004792",
            "FUN_080047a8",
            "FUN_080047c0",
            "FUN_080047d0",
            "FUN_080047f0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_0800502c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080051bc",
            "FUN_080052cc",
            "FUN_08005320",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_08005478",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_08005580",
            "FUN_080055d0",
            "FUN_080055e0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_08005686",
            "FUN_08005690",
            "FUN_080056b4",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c",
            "FUN_08005760",
            "FUN_08005768",
            "FUN_0800582c",
            "FUN_080058f0",
            "FUN_08005974"
        ]
    ],
    "locked_functions": []
}