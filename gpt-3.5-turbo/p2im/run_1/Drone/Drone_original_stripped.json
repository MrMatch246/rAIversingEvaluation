{
    "functions": {
        "FUN_080050fc": {
            "renaming": {
                "FUN_080050fc": "FUNC_080050fc"
            },
            "code": "\nint FUNC_080050fc(undefined4 *param_1,int *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  void *pvVar5;\n  undefined4 *puVar6;\n  int *piVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  undefined4 *unaff_r9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = _malloc_r(param_1,0x40);\n    *param_2 = iVar3;\n    param_2[4] = iVar3;\n    if (iVar3 == 0) {\n      *param_1 = 0xc;\n      return -1;\n    }\n    param_2[5] = 0x40;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\nLAB_08005146:\n  pbVar9 = pbVar8;\n  if (*pbVar9 != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  pbVar8 = pbVar9 + 1;\n  if (*pbVar9 != 0x25) goto LAB_08005146;\nLAB_08005150:\n  iVar3 = (int)pbVar9 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = __ssputs_r(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(param_2 + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar9 == 0) goto LAB_080052ac;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar9 + 1;\n  while( true ) {\n    pvVar5 = memchr(PTR_DAT_080052d0,(uint)*pbVar8,5);\n    puVar2 = PTR_DAT_080052d4;\n    param_3 = pbVar8 + 1;\n    if (pvVar5 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar5 - (int)PTR_DAT_080052d0 & 0xffU) | local_88;\n    pbVar8 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar7 = local_8c + 1;\n    iVar3 = *local_8c;\n    local_8c = piVar7;\n    if (-1 < iVar3) goto LAB_080051ee;\n    local_7c = -iVar3;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar3 = local_7c;\n    param_3 = pbVar8;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_080051ee:\n      local_7c = iVar3;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar7 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar7;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar3 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  pvVar5 = memchr(PTR_DAT_080052d4,(uint)*param_3,3);\n  if (pvVar5 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar5 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar5 = memchr(PTR_s_efgEFG_080052d8,(uint)local_70,6);\n  if (pvVar5 == (void *)0x0) {\n    puVar6 = (undefined4 *)_printf_i(param_1,&local_88,param_2,DAT_080052e0,&local_8c);\n  }\n  else {\n    puVar6 = param_1;\n    if (DAT_080052dc == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      puVar6 = unaff_r9;\n      goto LAB_08005260;\n    }\n  }\n  if (puVar6 == (undefined4 *)0xffffffff) goto LAB_080052ac;\nLAB_08005260:\n  local_74 = local_74 + (int)puVar6;\n  pbVar8 = param_3;\n  unaff_r9 = puVar6;\n  goto LAB_08005146;\n}\n\n",
            "called": [
                "__ssputs_r",
                "memchr",
                "_printf_i",
                "_malloc_r"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080050fc",
            "calling": [
                "siprintf"
            ],
            "imported": false,
            "current_name": "FUNC_080050fc"
        },
        "FUN_08003320": {
            "renaming": {
                "FUN_08003320": "update_delta_time_08003320",
                "_deltat": "delta_time"
            },
            "code": "void update_delta_time_08003320(float delta_time) {\n  *(float *)PTR_deltat_08003328 = delta_time;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003320",
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "update_delta_time_08003320"
        },
        "FUN_08004410": {
            "renaming": {
                "FUN_08004410": "send_attitude_data_08004410",
                "in_r1": "input_register_1",
                "local_10": "attitude_data",
                "local_c": "combined_data"
            },
            "code": "void send_attitude_data_08004410(void)\n{\n  uint16_t attitude_data = *(uint16_t *)PTR_msp_txf_attitude_08004430;\n  uint32_t combined_data = (in_r1 & 0xffff0000) | (uint32_t)attitude_data;\n  MSP_SendFrame('l', (uint8_t *)&combined_data, 6);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004410",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_attitude_data_08004410"
        },
        "FUN_08003ef2": {
            "renaming": {
                "FUN_08003ef2": "initialize_circular_buffer_08003ef2",
                "cb": "circular_buffer",
                "iVar1": "index"
            },
            "code": "void initialize_circular_buffer_08003ef2(CircularBuffer *cb)\\n{\\n  int index = 0;\\n  cb->head = 0;\\n  cb->tail = 0;\\n  cb->size = 0;\\n  do {\\n    cb->buffer[index] = \"\\0\";\\n    index++;\\n  } while (index != 0x800);\\n  return;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ef2",
            "calling": [
                "serialFlush"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_08003ef2"
        },
        "FUN_08001264": {
            "renaming": {
                "FUN_08001264": "configure_gpio_pins_08001264",
                "GPIOx": "gpio_port",
                "GPIO_Init": "gpio_init_struct",
                "puVar1": "cr_ptr",
                "uVar2": "alternate_function_mode_1",
                "uVar3": "alternate_function_mode_2",
                "uVar4": "cr_value",
                "uVar5": "pin_mask",
                "uVar6": "mode_value",
                "iVar7": "port_index",
                "uVar8": "pin_index",
                "uVar9": "cr_value_mask",
                "uVar10": "alternate_function_mode_3",
                "tmpreg": "unused_variable",
                "unaff_r10": "unused_variable"
            },
            "code": "void configure_gpio_pins_08001264(GPIO_TypeDef *gpio_port, GPIO_InitTypeDef *gpio_init_struct)\n{\n    uint32_t pin_mask = 0;\n    uint32_t mode_value = 0;\n    uint32_t speed_value = 0;\n    uint32_t pull_value = 0;\n    uint32_t cr_value = 0;\n\n    for (uint32_t pin_index = 0; pin_index < 16; pin_index++) {\n        pin_mask = 1 << pin_index;\n        if (pin_mask & gpio_init_struct->Pin) {\n            uint32_t mode = gpio_init_struct->Mode;\n            if (mode == GPIO_MODE_AF_PP || mode == GPIO_MODE_AF_OD) {\n                // Alternate function mode\n                // Not implemented in this function\n            }\n            else {\n                if (mode == GPIO_MODE_INPUT) {\n                    pull_value = gpio_init_struct->Pull;\n                    if (pull_value == GPIO_NOPULL) {\n                        pull_value = GPIO_PULLUP;\n                    }\n                    cr_value = pull_value;\n                }\n                else {\n                    speed_value = gpio_init_struct->Speed;\n                    if (mode == GPIO_MODE_OUTPUT_PP || mode == GPIO_MODE_OUTPUT_OD) {\n                        // Output mode\n                        cr_value = speed_value;\n                    }\n                    else if (mode == GPIO_MODE_IT_RISING || mode == GPIO_MODE_IT_FALLING || mode == GPIO_MODE_IT_RISING_FALLING) {\n                        // Interrupt mode\n                        // Not implemented in this function\n                    }\n                }\n                if (pin_index < 8) {\n                    mode_value = pin_index * 4;\n                    gpio_port->CRL &= ~(0xf << mode_value);\n                    gpio_port->CRL |= cr_value << mode_value;\n                }\n                else {\n                    mode_value = (pin_index - 8) * 4;\n                    gpio_port->CRH &= ~(0xf << mode_value);\n                    gpio_port->CRH |= cr_value << mode_value;\n                }\n            }\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001264",
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_TIM_MspPostInit",
                "HAL_I2C_MspInit"
            ],
            "imported": false,
            "current_name": "configure_gpio_pins_08001264"
        },
        "FUN_080058fc": {
            "renaming": {
                "FUN_080058fc": "calculate_result_080058fc",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "exponent",
                "param_4": "modulus",
                "param_5": "input_value",
                "uVar1": "temp1",
                "extraout_r1": "temp2",
                "extraout_r1_00": "temp2",
                "unaff_r4": "unaff_r4",
                "iVar2": "diff",
                "uVar3": "bit_mask",
                "uVar4": "temp_divisor",
                "uVar6": "temp_modulus",
                "iVar5": "diff",
                "uVar7": "result",
                "uVar8": "temp3"
            },
            "code": "undefined8 calculate_result_080058fc(uint dividend, uint divisor, uint exponent, uint modulus, double input_value)\n{\n  uint temp_modulus = modulus & 0x7fffffff;\n  if (DAT_08006220 < (temp_modulus | (-exponent | exponent) >> 0x1f))\n    return __aeabi_dadd(dividend, divisor);\n  uint temp_divisor = divisor & 0x7fffffff;\n  if (DAT_08006220 < (temp_divisor | (-dividend | dividend) >> 0x1f))\n    return __aeabi_dadd(dividend, divisor);\n  if ((modulus + 0xc0100000 | exponent) == 0)\n  {\n    atan(input_value);\n    return CONCAT44(extraout_r1, dividend);\n  }\n  uint bit_mask = (int)modulus >> 0x1e & 2U | divisor >> 0x1f;\n  if ((dividend | temp_divisor) == 0)\n  {\n    if (bit_mask == 2)\n      return CONCAT44(DAT_080061fc,DAT_080061f8);\n    if (bit_mask != 3)\n      return CONCAT44(divisor, dividend);\n  }\n  else\n  {\n    if ((exponent | temp_modulus) != 0)\n    {\n      if (temp_modulus == DAT_08006220)\n      {\n        if (temp_divisor == temp_modulus)\n        {\n          if (bit_mask == 2)\n            return CONCAT44(DAT_080061ec,DAT_080061e8);\n          if (bit_mask == 3)\n            return CONCAT44(DAT_080061f4,DAT_080061f0);\n          if (bit_mask != 1)\n            return CONCAT44(DAT_0800621c,DAT_08006218);\n          return CONCAT44(DAT_080061e4,DAT_080061e0);\n        }\n        if (bit_mask == 2)\n          return CONCAT44(DAT_080061fc,DAT_080061f8);\n        if (bit_mask == 3)\n          return CONCAT44(DAT_08006204,DAT_08006200);\n        if (bit_mask == 1)\n          return 0x8000000000000000;\n        return 0;\n      }\n      if (temp_divisor != DAT_08006220)\n      {\n        int diff = (int)(temp_divisor - temp_modulus) >> 0x14;\n        undefined4 temp1 = DAT_08006210;\n        int temp2 = DAT_08006214;\n        if (diff < 0x3d)\n        {\n          if (((int)modulus < 0) && (diff + 0x3c < 0 != SCARRY4(diff,0x3c)))\n          {\n            temp1 = 0;\n            temp2 = 0;\n          }\n          else\n          {\n            temp1 = __divdf3(dividend, divisor);\n            fabs((double)CONCAT44(unaff_r4,modulus));\n            atan((double)CONCAT44(unaff_r4,modulus));\n            temp2 = extraout_r1_00;\n          }\n        }\n        if (bit_mask != 1)\n        {\n          if (bit_mask == 2)\n          {\n            undefined8 temp3 = __subdf3(temp1,temp2,DAT_08006208,DAT_0800620c);\n            return CONCAT44(DAT_080061fc,DAT_080061f8);\n          }\n          if (bit_mask == 0)\n            return CONCAT44(temp2,temp1);\n          undefined8 temp3 = __subdf3(temp1,temp2,DAT_08006208,DAT_0800620c);\n          return __subdf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)CONCAT44(DAT_080061fc,DAT_080061f8),(int)((ulonglong)CONCAT44(DAT_080061fc,DAT_080061f8) >> 0x20));\n        }\n        return CONCAT44(temp2 + -0x80000000,temp1);\n      }\n    }\n    if ((int)divisor < 0)\n      return CONCAT44(DAT_080061dc,DAT_080061d8);\n    return CONCAT44(DAT_08006214,DAT_08006210);\n  }\n}",
            "called": [
                "__ieee754_atan2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058fc",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_result_080058fc"
        },
        "FUN_080070b0": {
            "renaming": {
                "FUN_080070b0": "calculate_double_from_bits_080070b0",
                "__x": "high_bits",
                "in_r0": "low_bits",
                "in_r1": "high_bits",
                "uVar2": "ptr_0",
                "uVar3": "ptr_1",
                "uVar4": "mask",
                "uVar5": "mask2",
                "dVar6": "sum",
                "uVar7": "sum2",
                "PTR_TWO52_080071b8": "TWO_TO_THE_52",
                "DAT_080071bc": "TWO_TO_THE_52_BITS"
            },
            "code": "double calculate_double_from_bits_080070b0(uint32_t high_bits, uint32_t low_bits)\n{\n  int exponent = ((high_bits << 1) >> 0x15) - 0x3ff;\n  int sign = high_bits >> 31;\n  if (exponent < 0x14) {\n    if (exponent < 0) {\n      if ((high_bits & 0x7fffffff | low_bits) == 0) {\n        return 0.0;\n      }\n      uint32_t bits = high_bits & 0xfffff | low_bits;\n      uint32_t* ptr = &PTR_TWO52_080071b8[sign];\n      double sum = __aeabi_dadd(low_bits, (-bits | bits) >> 0xc & 0x80000 | high_bits & 0xfffe0000, ptr[0], ptr[1]);\n      return (double)__subdf3((int)sum, (int)((uint64_t)sum >> 0x20), ptr[0], ptr[1]);\n    }\n    uint32_t mask = DAT_080071bc >> (exponent & 0xff);\n    if ((high_bits & mask | low_bits) == 0) {\n      return 0.0;\n    }\n    mask = mask >> 1;\n    low_bits = high_bits & mask | low_bits;\n    if (low_bits != 0) {\n      if (exponent == 0x13) {\n        low_bits = 0x80000000;\n      }\n      else {\n        low_bits = 0;\n      }\n      high_bits = 0x40000 >> (exponent & 0xff) | high_bits & ~mask;\n    }\n  }\n  else {\n    if (exponent > 0x33) {\n      if (exponent == 0x400) {\n        double sum = __aeabi_dadd(low_bits, high_bits, PTR_TWO52_080071b8[0], PTR_TWO52_080071b8[1]);\n        return sum;\n      }\n      else {\n        return 0.0;\n      }\n    }\n    exponent = exponent - 0x413;\n    uint32_t mask = 0xffffffff >> (exponent & 0xff);\n    if ((low_bits & mask) == 0) {\n      return 0.0;\n    }\n    mask = mask >> 1;\n    if ((low_bits & mask) != 0) {\n      low_bits = 0x40000000 >> (exponent & 0xff) | low_bits & ~mask;\n    }\n  }\n  uint32_t* ptr = &PTR_TWO52_080071b8[sign];\n  double sum = __aeabi_dadd(low_bits, high_bits, ptr[0], ptr[1]);\n  return (double)__subdf3((int)sum, (int)((uint64_t)sum >> 0x20), ptr[0], ptr[1]);\n}",
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080070b0",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "calculate_double_from_bits_080070b0"
        },
        "FUN_08001028": {
            "renaming": {
                "FUN_08001028": "is_end_of_string_08001028",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_08001028(void)\n{\n  char current_char;\n  __aeabi_cfcmpeq();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001028",
            "calling": [
                "PID_Update",
                "AHRS_GetYaw",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08001028"
        },
        "FUN_080006ac": {
            "renaming": {
                "FUN_080006ac": "convert_uint_to_double_080006ac",
                "param_1": "number1",
                "param_2": "number2",
                "param_3": "number3",
                "param_4": "number4",
                "uVar1": "temp3",
                "unaff_r4": "temp6",
                "uVar2": "temp1",
                "uVar3": "temp5",
                "in_r12": "mask",
                "bVar4": "check1",
                "mask2": "mask2",
                "mask3": "mask3",
                "mask4": "mask4"
            },
            "code": "ulonglong convert_uint_to_double_080006ac(uint number1,uint number2,uint number3,uint number4)\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool check1;\n  bool check2;\n  uint mask = 0x80000000;\n  uint mask2 = 0x100000;\n  uint mask3 = 0x7ff00000;\n  uint mask4 = 0x7ff8000000000000;\n  temp1 = number4 >> 0x14;\n  if (number2 != number4 && temp1 != number4) {\n    check1 = (number1 | number2 << 1) == 0;\n    if (!check1) {\n      check1 = (number3 | number4 << 1) == 0;\n    }\n    if (check1) {\n      return (ulonglong)((number2 ^ number4) & mask) << 0x20;\n    }\n    if (number2 == 0) {\n      temp2 = number1 & mask;\n      do {\n        temp3 = number1 & mask;\n        number1 = number1 << 1;\n        number2 = number2 * 2 + (uint)(temp3 != 0);\n      } while ((number2 & mask2) == 0);\n      number2 = number2 | temp2;\n      if (temp1 != 0) {\n        return CONCAT44(number2,number1);\n      }\n    }\n    do {\n      temp4 = number3 & mask;\n      number3 = number3 << 1;\n      number4 = number4 * 2 + (uint)(temp4 != 0);\n    } while ((number4 & mask2) == 0);\n    return CONCAT44(number2,number1);\n  }\n  check1 = (number1 | number2 << 1) == 0;\n  if (check1) {\n    number2 = number4;\n    number1 = number3;\n  }\n  if (!check1) {\n    check2 = (number3 | number4 << 1) == 0;\n  }\n  temp5 = number2;\n  if (((!check2) && ((number2 != number4 || ((number1 | number2 << 0xc) == 0)))) && ((temp1 != number4 || (number1 = number3, temp5 = number4, (number3 | number4 << 0xc) == 0)))) {\n    return (ulonglong)((number2 ^ number4) & mask | mask3) << 0x20;\n  }\n  return CONCAT44(temp5,number1) | mask4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006ac",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "convert_uint_to_double_080006ac"
        },
        "FUN_0800125a": {
            "renaming": {
                "FUN_0800125a": "run_HAL_SYSTICK_Callback_0800125a"
            },
            "code": "void run_HAL_SYSTICK_Callback_0800125a(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800125a",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "run_HAL_SYSTICK_Callback_0800125a"
        },
        "FUN_08001828": {
            "renaming": {
                "FUN_08001828": "write_i2c_memory_08001828",
                "*hi2c": "*i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "*pData": "*data",
                "Size": "data_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "*pIVar4": "*i2c_instance",
                "uVar5": "cr1_value",
                "bytes_left": "bytes_left"
            },
            "code": "HAL_StatusTypeDef write_i2c_memory_08001828(I2C_HandleTypeDef *i2c_handle, uint16_t device_address, uint16_t memory_address, uint16_t memory_address_size, uint8_t *data, uint16_t data_size, uint32_t timeout)\\\n    {\\\n        HAL_StatusTypeDef status;\\\n        uint32_t start_time;\\\n        uint32_t current_time;\\\n        I2C_TypeDef *i2c_instance;\\\n        uint16_t bytes_left;\\\n        if (i2c_handle->State != HAL_I2C_STATE_READY) {\\\n            return HAL_BUSY;\\\n        }\\\n        if (data == NULL || data_size == 0) {\\\n            return HAL_ERROR;\\\n        }\\\n        start_time = HAL_GetTick();\\\n        do {\\\n            i2c_instance = i2c_handle->Instance;\\\n            if ((~i2c_instance->SR2 & 2) != 0) {\\\n                if (i2c_handle->Lock == HAL_LOCKED) {\\\n                    return HAL_BUSY;\\\n                }\\\n                uint16_t cr1_value = i2c_instance->CR1;\\\n                i2c_handle->Lock = HAL_LOCKED;\\\n                i2c_instance->CR1 = cr1_value & 0xFFFFF7FF;\\\n                i2c_handle->State = HAL_I2C_STATE_BUSY_TX;\\\n                i2c_handle->Mode = HAL_I2C_MODE_MEM;\\\n                i2c_handle->ErrorCode = 0;\\\n                status = I2C_RequestMemoryWrite(i2c_handle, device_address, memory_address, memory_address_size, timeout);\\\n                if (status != HAL_OK) {\\\n                    i2c_handle->Lock = HAL_UNLOCKED;\\\n                    if (i2c_handle->ErrorCode == 4) {\\\n                        return HAL_ERROR;\\\n                    }\\\n                    return HAL_TIMEOUT;\\\n                }\\\n                goto LAB_080018e2;\\\n            }\\\n            current_time = HAL_GetTick();\\\n        } while (current_time - start_time < 0x2711);\\\n        i2c_handle->Lock = HAL_UNLOCKED;\\\n        i2c_handle->State = HAL_I2C_STATE_READY;\\\n        return HAL_BUSY;\\\n        while (data_size != 0) {\\\n        LAB_080018e2:\\\n            status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\\\n            if (status != HAL_OK) {\\\n                goto LAB_080018ee;\\\n            }\\\n            i2c_instance = i2c_handle->Instance;\\\n            i2c_instance->DR = (uint32_t)*data;\\\n            if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\\\n                if ((uint16_t)(data_size - 1) == 0) {\\\n                    break;\\\n                }\\\n                bytes_left = data_size - 2;\\\n                i2c_instance->DR = (uint32_t)data[1];\\\n                data += 2;\\\n            }\\\n            else {\\\n                data += 1;\\\n                bytes_left = data_size - 1;\\\n            }\\\n            data_size = bytes_left;\\\n        }\\\n        status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\\\n        if (status == HAL_OK) {\\\n            i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\\\n            i2c_handle->Lock = HAL_UNLOCKED;\\\n            i2c_handle->State = HAL_I2C_STATE_READY;\\\n            i2c_handle->Mode = HAL_I2C_MODE_NONE;\\\n            return HAL_OK;\\\n        }\\\n    LAB_080018ee:\\\n        if (i2c_handle->ErrorCode == 4) {\\\n            i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\\\n            return HAL_ERROR;\\\n        }\\\n        return HAL_TIMEOUT;\\\n    }",
            "called": [
                "I2C_RequestMemoryWrite",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001828",
            "calling": [
                "I2C_WriteByte"
            ],
            "imported": false,
            "current_name": "write_i2c_memory_08001828"
        },
        "FUN_0800016c": {
            "renaming": {
                "FUN_0800016c": "FUNC_0800016c"
            },
            "code": "\nulonglong FUNC_0800016c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = param_2;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar5 = param_2;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar5 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar5 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar5 = -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar4 = uVar5 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar4;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar5;\n    uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if ((uVar10 & 0x100000) != 0) goto LAB_08000278;\n  uVar5 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar5 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar5 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar5 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar5 = uVar5 << (uVar10 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 >> (uVar10 & 0xff),\n                    uVar5 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800016c",
            "calling": [
                "__ieee754_atan2",
                "scalbn",
                "__ieee754_sqrt",
                "__aeabi_drsub",
                "atan",
                "rint",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "FUNC_0800016c"
        },
        "FUN_08001b58": {
            "renaming": {
                "FUN_08001b58": "FUNC_08001b58"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) */\n/* WARNING: Removing unreachable block (ram,0x08001ee8) */\n\nHAL_StatusTypeDef FUNC_08001b58(RCC_OscInitTypeDef *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  int iVar5;\n  uint uVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08001e70;\n  if ((int)(RCC_OscInitStruct->OscillatorType << 0x1f) < 0) {\n    if (((DAT_08001e70[1] & 0xc) == 4) ||\n       (((DAT_08001e70[1] & 0xc) == 8 && ((int)(DAT_08001e70[1] << 0xf) < 0)))) {\n      uVar6 = count_leading_zeroes(0x4000);\n      if (((int)((*DAT_08001e70 >> (uVar6 & 0x1f)) << 0x1f) < 0) &&\n         (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar3 = RCC_OscInitStruct->HSEState;\n      if (uVar3 == 0x10000) {\nLAB_08001c1e:\n        uVar6 = *puVar1 | 0x10000;\n      }\n      else {\n        if (uVar3 == 0) {\n          *DAT_08001e70 = *DAT_08001e70 & 0xfffeffff;\n          *puVar1 = *puVar1 & 0xfffbffff;\n          uVar3 = HAL_GetTick();\n          while (uVar6 = count_leading_zeroes(0x4000),\n                (int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f) < 0) {\n            uVar4 = HAL_GetTick();\n            if (100 < uVar4 - uVar3) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (uVar3 == 0x50000) {\n          *DAT_08001e70 = *DAT_08001e70 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        *DAT_08001e70 = *DAT_08001e70 & 0xfffeffff;\n        uVar6 = *puVar1 & 0xfffbffff;\n      }\n      *puVar1 = uVar6;\n      uVar3 = HAL_GetTick();\n      while (uVar6 = count_leading_zeroes(0x4000), -1 < (int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f))\n      {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  puVar1 = DAT_08001e70;\n  if ((int)(RCC_OscInitStruct->OscillatorType << 0x1e) < 0) {\n    if (((DAT_08001e70[1] & 0xc) == 0) ||\n       (((DAT_08001e70[1] & 0xc) == 8 && (-1 < (int)(DAT_08001e70[1] << 0xf))))) {\n      uVar6 = count_leading_zeroes(0x40000000);\n      if (((int)((*DAT_08001e70 >> (uVar6 & 0x1f)) << 0x1f) < 0) &&\n         (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (RCC_OscInitStruct->HSIState == 0) {\n        iVar5 = count_leading_zeroes(0x80000000);\n        *(undefined4 *)(iVar5 * 4 + 0x42420000) = 0;\n        uVar3 = HAL_GetTick();\n        while (uVar6 = count_leading_zeroes(0x40000000),\n              (int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f) < 0) {\n          uVar4 = HAL_GetTick();\n          if (2 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      iVar5 = count_leading_zeroes(0x80000000);\n      *(undefined4 *)(iVar5 * 4 + 0x42420000) = 1;\n      uVar3 = HAL_GetTick();\n      while (uVar6 = count_leading_zeroes(0x40000000),\n            -1 < (int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f)) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    uVar6 = count_leading_zeroes(0x1f000000);\n    *puVar1 = RCC_OscInitStruct->HSICalibrationValue << (uVar6 & 0xff) | *puVar1 & 0xffffff07;\n  }\nLAB_08001b6c:\n  puVar1 = DAT_08001e70;\n  if ((int)(RCC_OscInitStruct->OscillatorType << 0x1c) < 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      iVar5 = count_leading_zeroes(0x80000000);\n      *(undefined4 *)(DAT_08001e74 + iVar5 * 4) = 0;\n      uVar3 = HAL_GetTick();\n      while (uVar6 = count_leading_zeroes(0x40000000),\n            (int)((puVar1[9] >> (uVar6 & 0x1f)) << 0x1f) < 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      iVar5 = count_leading_zeroes(0x80000000);\n      *(undefined4 *)(DAT_08001e74 + iVar5 * 4) = 1;\n      uVar3 = HAL_GetTick();\n      while (uVar6 = count_leading_zeroes(0x40000000),\n            -1 < (int)((puVar1[9] >> (uVar6 & 0x1f)) << 0x1f)) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      HAL_Delay(1);\n    }\n  }\n  puVar2 = DAT_08001e78;\n  puVar1 = DAT_08001e70;\n  if (-1 < (int)(RCC_OscInitStruct->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  DAT_08001e70[7] = DAT_08001e70[7] | 0x10000000;\n  *puVar2 = *puVar2 | 0x100;\n  uVar3 = HAL_GetTick();\n  while (-1 < (int)(*puVar2 << 0x17)) {\n    uVar4 = HAL_GetTick();\n    if (100 < uVar4 - uVar3) {\n      return HAL_TIMEOUT;\n    }\n  }\n  uVar3 = RCC_OscInitStruct->LSEState;\n  if (uVar3 == 1) {\nLAB_08001e1a:\n    uVar6 = puVar1[8] | 1;\n  }\n  else {\n    if (uVar3 == 0) {\n      puVar1[8] = puVar1[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n      uVar3 = HAL_GetTick();\n      while (uVar6 = count_leading_zeroes(0x40000000),\n            (int)((puVar1[8] >> (uVar6 & 0x1f)) << 0x1f) < 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (uVar3 == 5) {\n      puVar1[8] = puVar1[8] | 4;\n      goto LAB_08001e1a;\n    }\n    puVar1[8] = puVar1[8] & 0xfffffffe;\n    uVar6 = puVar1[8] & 0xfffffffb;\n  }\n  puVar1[8] = uVar6;\n  uVar3 = HAL_GetTick();\n  while (uVar6 = count_leading_zeroes(0x40000000), -1 < (int)((puVar1[8] >> (uVar6 & 0x1f)) << 0x1f)\n        ) {\n    uVar4 = HAL_GetTick();\n    if (5000 < uVar4 - uVar3) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  puVar1 = DAT_08002004;\n  uVar3 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar3 == 0) {\n    return HAL_OK;\n  }\n  if ((DAT_08002004[1] & 0xc) != 8) {\n    if (uVar3 != 2) {\n      iVar5 = count_leading_zeroes(0x80);\n      *(undefined4 *)(iVar5 * 4 + 0x42420000) = 0;\n      uVar3 = HAL_GetTick();\n      do {\n        uVar6 = count_leading_zeroes(0x40);\n        if (-1 < (int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f)) {\n          return HAL_OK;\n        }\n        uVar4 = HAL_GetTick();\n      } while (uVar4 - uVar3 < 3);\n      return HAL_TIMEOUT;\n    }\n    iVar5 = count_leading_zeroes(0x80);\n    *(undefined4 *)(iVar5 * 4 + 0x42420000) = 0;\n    uVar3 = HAL_GetTick();\n    do {\n      uVar6 = count_leading_zeroes(0x40);\n      if (-1 < (int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f)) {\n        uVar6 = (RCC_OscInitStruct->PLL).PLLSource;\n        if (uVar6 == 0x10000) {\n          puVar1[1] = puVar1[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        puVar1[1] = uVar6 | (RCC_OscInitStruct->PLL).PLLMUL | puVar1[1] & 0xffc2ffff;\n        iVar5 = count_leading_zeroes(0x80);\n        *(undefined4 *)(iVar5 * 4 + 0x42420000) = 1;\n        uVar3 = HAL_GetTick();\n        do {\n          uVar6 = count_leading_zeroes(0x40);\n          if ((int)((*puVar1 >> (uVar6 & 0x1f)) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar3 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar3 < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "HAL_Delay",
                "HAL_GetTick"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001b58",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_08001b58"
        },
        "FUN_0800290c": {
            "renaming": {
                "FUN_0800290c": "receive_data_from_uart_0800290c",
                "*huart": "*uart_handle",
                "uVar1": "parity",
                "bVar2": "data_byte",
                "pUVar3": "uart_instance",
                "uVar4": "word_length",
                "puVar5": "rx_buff_ptr",
                "puVar6": "next_rx_byte",
                "bVar7": "transfer_complete",
                "State": "UART_BUSY_STATE",
                "HAL_BUSY": "HAL_BUSY",
                "Init": "UART_INIT",
                "Parity": "UART_PARITY",
                "Instance": "UART_INSTANCE",
                "pRxBuffPtr": "UART_RX_BUFF_PTR",
                "WordLength": "UART_WORD_LENGTH",
                "UART_9BIT_WORD_LENGTH": "UART_9BIT_WORD_LENGTH",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "UART_RX_DISABLE_BITMASK": "UART_RX_DISABLE_BITMASK",
                "RxXferCount": "UART_RX_TRANSFER_COUNT",
                "UART_RX_COMPLETE_STATE": "UART_RX_COMPLETE_STATE",
                "UART_IDLE_INTERRUPT_DISABLE_BITMASK": "UART_IDLE_INTERRUPT_DISABLE_BITMASK",
                "UART_ERR_INTERRUPT_DISABLE_BITMASK": "UART_ERR_INTERRUPT_DISABLE_BITMASK",
                "HAL_UART_StateTypeDef": "HAL_UART_STATE",
                "HAL_OK": "HAL_OK",
                "HAL_UART_RxCpltCallback": "HAL_UART_RECEIVE_COMPLETE_CALLBACK"
            },
            "code": "HAL_StatusTypeDef receive_data_from_uart_0800290c(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t parity;\n  byte data_byte;\n  USART_TypeDef *uart_instance;\n  uint16_t word_length;\n  ushort *rx_buff_ptr;\n  ushort *next_rx_byte;\n  bool transfer_complete;\n  \n  if ((uart_handle->State & UART_BUSY_STATE) != UART_RX_STATE) {\n    return HAL_BUSY;\n  }\n  parity = uart_handle->Init.Parity;\n  uart_instance = uart_handle->Instance;\n  rx_buff_ptr = (ushort *)uart_handle->pRxBuffPtr;\n  word_length = uart_handle->Init.WordLength;\n  if (word_length == UART_9BIT_WORD_LENGTH) {\n    if (parity == UART_PARITY_NONE) {\n      next_rx_byte = rx_buff_ptr + 1;\n      *rx_buff_ptr = (ushort)((uart_instance->DR << 0x17) >> 0x17);\n    }\n    else {\n      next_rx_byte = (ushort *)((int)rx_buff_ptr + 1);\n      *rx_buff_ptr = (ushort)uart_instance->DR & 0xff;\n    }\n    uart_handle->pRxBuffPtr = (uint8_t *)next_rx_byte;\n  }\n  else {\n    if (parity == UART_PARITY_NONE) {\n      data_byte = (byte)uart_instance->DR;\n      uart_handle->pRxBuffPtr = (uint8_t *)((int)rx_buff_ptr + 1);\n    }\n    else {\n      parity = uart_instance->DR;\n      uart_handle->pRxBuffPtr = (uint8_t *)((int)rx_buff_ptr + 1);\n      data_byte = (byte)parity & 0x7f;\n    }\n    *(byte *)rx_buff_ptr = data_byte;\n  }\n  transfer_complete = uart_handle->RxXferCount - 1 == 0;\n  uart_handle->RxXferCount = transfer_complete ? 0 : uart_handle->RxXferCount - 1;\n  if (transfer_complete) {\n    uart_instance = uart_handle->Instance;\n    uart_instance->CR1 = uart_instance->CR1 & UART_RX_DISABLE_BITMASK;\n    transfer_complete = uart_handle->State != UART_RX_COMPLETE_STATE;\n    if (transfer_complete) {\n      uart_instance->CR1 = uart_instance->CR1 & UART_IDLE_INTERRUPT_DISABLE_BITMASK;\n      uart_instance->CR3 = uart_instance->CR3 & UART_ERR_INTERRUPT_DISABLE_BITMASK;\n      uart_instance = (USART_TypeDef *)UART_RX_COMPLETE_STATE;\n    }\n    uart_handle->State = (HAL_UART_StateTypeDef)uart_instance;\n    HAL_UART_RxCpltCallback(uart_handle);\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800290c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_from_uart_0800290c"
        },
        "FUN_080028a6": {
            "renaming": {
                "FUN_080028a6": "receive_data_080028a6",
                "*huart": "*uart_handler",
                "huart": "uart_handler",
                "pData": "data_buffer",
                "Size": "buffer_size",
                "HVar1": "uart_state",
                "uVar2": "cr1_value",
                "*pUVar3": "*uart_instance",
                "pUVar3": "uart_instance"
            },
            "code": "HAL_StatusTypeDef receive_data_080028a6(UART_HandleTypeDef *uart_handler, uint8_t *data_buffer, uint16_t buffer_size)\n{\n    HAL_UART_StateTypeDef uart_state;\n    uint cr1_value;\n    USART_TypeDef *uart_instance;\n    \n    if ((uart_handler->State == HAL_UART_STATE_READY) || (uart_handler->State == HAL_UART_STATE_BUSY_TX)) {\n        if ((data_buffer == NULL) || (buffer_size == 0)) {\n            return HAL_ERROR;\n        }\n        if (uart_handler->Lock != HAL_LOCKED) {\n            uart_handler->Lock = HAL_LOCKED;\n            uart_handler->ErrorCode = 0;\n            uart_handler->RxXferSize = buffer_size;\n            uart_handler->RxXferCount = buffer_size;\n            uart_handler->Lock = HAL_UNLOCKED;\n            if (uart_handler->State == HAL_UART_STATE_BUSY_TX) {\n                uart_state = HAL_UART_STATE_BUSY_TX_RX;\n            }\n            else {\n                uart_state = HAL_UART_STATE_BUSY_RX;\n            }\n            uart_instance = uart_handler->Instance;\n            uart_handler->State = uart_state;\n            cr1_value = uart_instance->CR1;\n            uart_handler->pRxBuffPtr = data_buffer;\n            uart_instance->CR1 = cr1_value | 0x100;\n            uart_instance->CR3 = uart_instance->CR3 | 1;\n            uart_instance->CR1 = uart_instance->CR1 | 0x20;\n            return HAL_OK;\n        }\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028a6",
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "imported": false,
            "current_name": "receive_data_080028a6"
        },
        "FUN_0800290a": {
            "renaming": {
                "FUN_0800290a": "do_nothing_0800290a"
            },
            "code": "\nvoid do_nothing_0800290a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800290a",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800290a"
        },
        "FUN_08004300": {
            "renaming": {
                "FUN_08004300": "print_data_with_checksum_08004300",
                "code": "checksum_seed",
                "data": "data",
                "data_length": "data_length",
                "ch": "checksum",
                "pbVar1": "current_byte"
            },
            "code": "void print_data_with_checksum_08004300(uint8_t checksum_seed, uint8_t *data, uint16_t data_length) {\n  uint8_t checksum = 0;\n  uint8_t *current_byte;\n  serialPrint(PTR_DAT_08004344);\n  serialWrite((byte)data_length);\n  checksum = (byte)data_length ^ checksum_seed;\n  serialWrite(checksum_seed);\n  for (current_byte = data; current_byte < data + data_length; current_byte++) {\n    serialWrite(*current_byte);\n    checksum ^= *current_byte;\n  }\n  serialWrite(checksum);\n  return;\n}",
            "called": [
                "serialPrint",
                "serialWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004300",
            "calling": [
                "MSP_SendStatus",
                "MSP_SendPID",
                "MSP_SendAltitude",
                "MSP_SendAttitude",
                "MSP_SendRawIMU",
                "MSP_SendMotor",
                "MSP_SendIdent"
            ],
            "imported": false,
            "current_name": "print_data_with_checksum_08004300"
        },
        "FUN_08005630": {
            "renaming": {
                "FUN_08005630": "reverse_copy_08005630",
                "__dest": "dest",
                "__src": "src",
                "__n": "n",
                "puVar1": "src_ptr",
                "puVar2": "dest_ptr"
            },
            "code": "void * reverse_copy_08005630(void *dest, void *src, size_t n)\n{\n  unsigned char *dest_ptr = (unsigned char *)dest + n - 1;\n  unsigned char *src_ptr = (unsigned char *)src;\n  for (; src_ptr < (unsigned char *)src + n; src_ptr++, dest_ptr--)\n  {\n    *dest_ptr = *src_ptr;\n  }\n  return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005630",
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_08005630"
        },
        "FUN_08003330": {
            "renaming": {
                "FUN_08003330": "FUNC_08003330"
            },
            "code": "\nvoid FUNC_08003330\n               (float ax,float ay,float az,float gx,float gy,float gz,float mx,float my,float mz,\n               float *angle)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  int iVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  int iVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  undefined4 uVar23;\n  undefined4 uVar24;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  int iVar27;\n  undefined4 in_r2;\n  undefined4 uVar28;\n  int iVar29;\n  undefined4 uVar30;\n  undefined4 uVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_00000000;\n  undefined4 in_stack_00000004;\n  undefined4 in_stack_00000008;\n  undefined4 in_stack_0000000c;\n  undefined4 in_stack_00000010;\n  undefined4 *in_stack_00000014;\n  undefined4 in_stack_ffffff78;\n  float hy;\n  float hx;\n  \n  uVar28 = *(undefined4 *)PTR_q_080035d8;\n  iVar29 = *(int *)(PTR_q_080035d8 + 4);\n  uVar31 = *(undefined4 *)(PTR_q_080035d8 + 8);\n  uVar30 = *(undefined4 *)(PTR_q_080035d8 + 0xc);\n  uVar2 = __aeabi_fmul(ax,mz,mz);\n  uVar3 = __aeabi_fmul(angle);\n  uVar2 = __addsf3(uVar2,uVar3);\n  uVar3 = __aeabi_fmul(in_r2);\n  __addsf3(uVar2,uVar3);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n  uVar2 = __truncdfsf2();\n  iVar4 = __aeabi_fcmpeq(uVar2,0);\n  if (iVar4 == 0) {\n    uVar3 = __aeabi_fmul(in_stack_00000008);\n    uVar5 = __aeabi_fmul(in_stack_0000000c);\n    uVar3 = __addsf3(uVar3,uVar5);\n    uVar5 = __aeabi_fmul(in_stack_00000010);\n    __addsf3(uVar3,uVar5);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n    uVar3 = __truncdfsf2();\n    iVar4 = __aeabi_fcmpeq(uVar3,0);\n    if (iVar4 == 0) {\n      uVar32 = __aeabi_f2d();\n      __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_080035d0,DAT_080035d4);\n      uVar5 = __truncdfsf2();\n      uVar32 = __aeabi_f2d(in_stack_00000000);\n      __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_080035d0,DAT_080035d4);\n      uVar6 = __truncdfsf2();\n      uVar32 = __aeabi_f2d(in_stack_00000004);\n      __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_080035d0,DAT_080035d4);\n      uVar7 = __truncdfsf2();\n      iVar4 = __addsf3(uVar28);\n      uVar8 = __addsf3(iVar29);\n      iVar9 = __addsf3(uVar31,uVar31);\n      uVar10 = __addsf3(uVar30,uVar30);\n      uVar11 = __aeabi_fmul(uVar28);\n      uVar12 = __aeabi_fmul(uVar28,iVar29);\n      uVar13 = __aeabi_fmul(uVar28,uVar31);\n      uVar14 = __aeabi_fmul(iVar29);\n      uVar15 = __aeabi_fmul(iVar29,uVar30);\n      uVar16 = __aeabi_fmul(uVar31,uVar31);\n      uVar17 = __aeabi_fmul(uVar30,uVar30);\n      uVar2 = __aeabi_fdiv(0x3f800000,uVar2);\n      uVar3 = __aeabi_fdiv(0x3f800000,uVar3);\n      uVar18 = __aeabi_fmul(in_stack_00000008,uVar3);\n      uVar19 = __aeabi_fmul(in_stack_0000000c,uVar3);\n      uVar3 = __aeabi_fmul(in_stack_00000010,uVar3);\n      iVar20 = __aeabi_fmul(iVar4,uVar18);\n      uVar21 = __aeabi_fmul(iVar4,uVar19);\n      uVar22 = __aeabi_fmul(iVar4,uVar3);\n      uVar23 = __aeabi_fmul(uVar8,uVar18);\n      uVar24 = __aeabi_fmul(uVar11,uVar18);\n      uVar25 = __aeabi_fmul(uVar30,uVar21);\n      uVar24 = __aeabi_fsub(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar31,uVar22);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar14,uVar18);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar8,uVar19);\n      uVar25 = __aeabi_fmul(uVar25,uVar31);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar8,uVar3);\n      uVar25 = __aeabi_fmul(uVar25,uVar30);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar16,uVar18);\n      uVar24 = __aeabi_fsub(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar17,uVar18);\n      uVar24 = __aeabi_fsub(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar30,iVar20);\n      uVar26 = __aeabi_fmul(uVar11,uVar19);\n      uVar25 = __addsf3(uVar25,uVar26);\n      uVar22 = __aeabi_fmul(iVar29,uVar22);\n      uVar22 = __aeabi_fsub(uVar25,uVar22);\n      uVar25 = __aeabi_fmul(uVar31,uVar23);\n      uVar22 = __addsf3(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(uVar14,uVar19);\n      uVar22 = __aeabi_fsub(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(uVar16,uVar19);\n      uVar22 = __addsf3(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(iVar9,uVar3);\n      uVar25 = __aeabi_fmul(uVar25,uVar30);\n      uVar22 = __addsf3(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(uVar17,uVar19);\n      uVar22 = __aeabi_fsub(uVar22,uVar25);\n      uVar24 = __aeabi_fmul(uVar24,uVar24);\n      uVar22 = __aeabi_fmul(uVar22,uVar22);\n      __addsf3(uVar24,uVar22);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n      iVar27 = __truncdfsf2();\n      uVar22 = __aeabi_fmul(iVar20 + -0x80000000,uVar31);\n      uVar21 = __aeabi_fmul(iVar29,uVar21);\n      uVar21 = __addsf3(uVar22,uVar21);\n      uVar11 = __aeabi_fmul(uVar11,uVar3);\n      uVar11 = __addsf3(uVar21,uVar11);\n      uVar21 = __aeabi_fmul(uVar30,uVar23);\n      uVar11 = __addsf3(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(uVar14,uVar3);\n      uVar11 = __aeabi_fsub(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(iVar9,uVar19);\n      uVar21 = __aeabi_fmul(uVar21,uVar30);\n      uVar11 = __addsf3(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(uVar16,uVar3);\n      uVar11 = __aeabi_fsub(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(uVar17,uVar3);\n      uVar11 = __addsf3(uVar11,uVar21);\n      uVar21 = __addsf3(uVar11,uVar11);\n      uVar22 = __addsf3(uVar15);\n      uVar23 = __aeabi_fmul(uVar31,iVar4);\n      uVar22 = __aeabi_fsub(uVar22,uVar23);\n      uVar23 = __aeabi_fmul(mz,uVar2);\n      uVar22 = __aeabi_fsub(uVar22,uVar23);\n      uVar23 = __aeabi_fmul(uVar30,iVar9);\n      uVar24 = __addsf3(uVar12);\n      uVar23 = __addsf3(uVar23,uVar24);\n      uVar24 = __aeabi_fmul(angle,uVar2);\n      uVar23 = __aeabi_fsub(uVar23,uVar24);\n      uVar24 = __aeabi_fmul(uVar31,uVar11);\n      uVar25 = __aeabi_fsub(0x3f000000,uVar16);\n      uVar17 = __aeabi_fsub(uVar25,uVar17);\n      uVar17 = __aeabi_fmul(uVar17,iVar27);\n      uVar25 = __aeabi_fsub(uVar15,uVar13);\n      uVar25 = __aeabi_fmul(uVar25,uVar11);\n      uVar17 = __addsf3(uVar17,uVar25);\n      uVar17 = __aeabi_fsub(uVar17,uVar18);\n      uVar18 = __aeabi_fmul(iVar29,uVar11);\n      uVar25 = __aeabi_fmul(iVar29,uVar31);\n      uVar26 = __aeabi_fmul(uVar28,uVar30);\n      uVar25 = __aeabi_fsub(uVar25,uVar26);\n      uVar25 = __aeabi_fmul(uVar25,iVar27);\n      uVar26 = __aeabi_fmul(uVar31,uVar30);\n      uVar12 = __addsf3(uVar26,uVar12);\n      uVar12 = __aeabi_fmul(uVar12,uVar11);\n      uVar12 = __addsf3(uVar25,uVar12);\n      uVar12 = __aeabi_fsub(uVar12,uVar19);\n      uVar19 = __aeabi_fmul(uVar31,iVar27);\n      uVar25 = __aeabi_fsub(0x3f000000,uVar14);\n      uVar25 = __aeabi_fsub(uVar25,uVar16);\n      uVar25 = __aeabi_fmul(uVar25,uVar11);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar13 = __aeabi_fmul(uVar13,iVar27);\n      uVar13 = __addsf3(uVar25,uVar13);\n      uVar3 = __aeabi_fsub(uVar13,uVar3);\n      uVar13 = __aeabi_fmul(iVar9 + -0x80000000,uVar22);\n      uVar15 = __aeabi_fmul(uVar8,uVar23);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar15 = __aeabi_fmul(uVar24,uVar17);\n      uVar13 = __aeabi_fsub(uVar13,uVar15);\n      uVar15 = __aeabi_fmul(uVar30,iVar27 + -0x80000000);\n      uVar15 = __addsf3(uVar15,uVar18);\n      uVar15 = __aeabi_fmul(uVar15,uVar12);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar15 = __aeabi_fmul(uVar19,uVar3);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar14 = __addsf3(uVar14);\n      uVar14 = __aeabi_fsub(0x3f800000,uVar14);\n      uVar15 = __addsf3(uVar16);\n      uVar14 = __aeabi_fsub(uVar14,uVar15);\n      uVar2 = __aeabi_fmul(in_r2,uVar2);\n      uVar2 = __aeabi_fsub(uVar14,uVar2);\n      uVar14 = __aeabi_fmul(uVar30,uVar11);\n      uVar11 = __aeabi_fmul(uVar28,uVar11);\n      uVar15 = __aeabi_fmul(uVar10,uVar22);\n      uVar16 = __aeabi_fmul(iVar4,uVar23);\n      uVar15 = __addsf3(uVar15,uVar16);\n      uVar16 = __aeabi_fmul(iVar29,0x40800000);\n      uVar16 = __aeabi_fmul(uVar16,uVar2);\n      uVar15 = __aeabi_fsub(uVar15,uVar16);\n      uVar16 = __aeabi_fmul(uVar17,uVar14);\n      uVar15 = __addsf3(uVar15,uVar16);\n      uVar16 = __addsf3(uVar19,uVar11);\n      uVar16 = __aeabi_fmul(uVar16,uVar12);\n      uVar15 = __addsf3(uVar15,uVar16);\n      uVar16 = __aeabi_fmul(uVar30,iVar27);\n      uVar19 = __aeabi_fmul(iVar29,uVar21);\n      uVar16 = __aeabi_fsub(uVar16,uVar19);\n      uVar16 = __aeabi_fmul(uVar16,uVar3);\n      uVar15 = __addsf3(uVar15,uVar16);\n      iVar20 = __addsf3(iVar27,iVar27);\n      uVar16 = __aeabi_fmul(iVar29,iVar27);\n      uVar19 = __aeabi_fmul(iVar4 + -0x80000000,uVar22);\n      uVar10 = __aeabi_fmul(uVar10,uVar23);\n      uVar10 = __addsf3(uVar19,uVar10);\n      uVar19 = __aeabi_fmul(uVar31,0x40800000);\n      uVar2 = __aeabi_fmul(uVar19,uVar2);\n      uVar2 = __aeabi_fsub(uVar10,uVar2);\n      uVar10 = __aeabi_fmul(uVar31,iVar20 + -0x80000000);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,uVar17);\n      uVar2 = __addsf3(uVar2,uVar10);\n      uVar10 = __addsf3(uVar14,uVar16);\n      uVar10 = __aeabi_fmul(uVar10,uVar12);\n      uVar2 = __addsf3(uVar2,uVar10);\n      uVar10 = __aeabi_fmul(uVar28,iVar27);\n      uVar11 = __aeabi_fmul(uVar31,uVar21);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,uVar3);\n      uVar2 = __addsf3(uVar2,uVar10);\n      uVar8 = __aeabi_fmul(uVar8,uVar22);\n      uVar10 = __aeabi_fmul(iVar9,uVar23);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar30,iVar20 + -0x80000000);\n      uVar10 = __addsf3(uVar10,uVar18);\n      uVar10 = __aeabi_fmul(uVar10,uVar17);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar28,iVar27 + -0x80000000);\n      uVar10 = __addsf3(uVar10,uVar24);\n      uVar10 = __aeabi_fmul(uVar10,uVar12);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar3 = __aeabi_fmul(uVar3,uVar16);\n      uVar3 = __addsf3(uVar8,uVar3);\n      uVar8 = __aeabi_fmul(uVar13);\n      uVar10 = __aeabi_fmul(uVar15);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar2,uVar2);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar3,uVar3);\n      __addsf3(uVar8,uVar10);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n      uVar8 = __truncdfsf2();\n      uVar8 = __aeabi_fdiv(0x3f800000,uVar8);\n      puVar1 = PTR_deltat_08003d84;\n      uVar12 = *(undefined4 *)PTR_beta_08003d80;\n      uVar14 = *(undefined4 *)PTR_beta_08003d80;\n      uVar16 = *(undefined4 *)PTR_beta_08003d80;\n      uVar17 = *(undefined4 *)PTR_beta_08003d80;\n      uVar10 = __aeabi_fmul(iVar29 + -0x80000000,uVar5);\n      uVar11 = __aeabi_fmul(uVar31,uVar6);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar11 = __aeabi_fmul(uVar30,uVar7);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,0x3f000000);\n      uVar11 = __aeabi_fmul(uVar13,uVar8);\n      uVar13 = *(undefined4 *)puVar1;\n      uVar11 = __aeabi_fmul(uVar11,uVar12);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,uVar13);\n      uVar10 = __addsf3(uVar10,uVar28);\n      uVar11 = __aeabi_fmul(uVar28,uVar5);\n      uVar12 = __aeabi_fmul(uVar31,uVar7);\n      uVar13 = *(undefined4 *)puVar1;\n      uVar11 = __addsf3(uVar11,uVar12);\n      uVar12 = __aeabi_fmul(uVar30,uVar6);\n      uVar11 = __aeabi_fsub(uVar11,uVar12);\n      uVar11 = __aeabi_fmul(uVar11,0x3f000000);\n      uVar12 = __aeabi_fmul(uVar15,uVar8);\n      uVar12 = __aeabi_fmul(uVar12,uVar14);\n      uVar11 = __aeabi_fsub(uVar11,uVar12);\n      uVar11 = __aeabi_fmul(uVar11,uVar13);\n      uVar11 = __addsf3(uVar11,iVar29);\n      uVar14 = *(undefined4 *)puVar1;\n      uVar12 = __aeabi_fmul(uVar28,uVar6);\n      uVar13 = __aeabi_fmul(iVar29,uVar7);\n      uVar12 = __aeabi_fsub(uVar12,uVar13);\n      uVar13 = __aeabi_fmul(uVar30,uVar5);\n      uVar12 = __addsf3(uVar12,uVar13);\n      uVar12 = __aeabi_fmul(uVar12,0x3f000000);\n      uVar2 = __aeabi_fmul(uVar2,uVar8);\n      uVar2 = __aeabi_fmul(uVar2,uVar16);\n      uVar2 = __aeabi_fsub(uVar12,uVar2);\n      uVar2 = __aeabi_fmul(uVar2,uVar14);\n      uVar2 = __addsf3(uVar2,uVar31);\n      uVar28 = __aeabi_fmul(uVar28,uVar7);\n      uVar6 = __aeabi_fmul(iVar29,uVar6);\n      uVar28 = __addsf3(uVar28,uVar6);\n      uVar31 = __aeabi_fmul(uVar31,uVar5);\n      uVar31 = __aeabi_fsub(uVar28,uVar31);\n      uVar31 = __aeabi_fmul(uVar31,0x3f000000);\n      uVar3 = __aeabi_fmul(uVar3,uVar8);\n      uVar3 = __aeabi_fmul(uVar3,uVar17);\n      uVar5 = *(undefined4 *)puVar1;\n      uVar3 = __aeabi_fsub(uVar31,uVar3);\n      uVar3 = __aeabi_fmul(uVar3,uVar5);\n      uVar3 = __addsf3(uVar3,uVar30);\n      uVar30 = __aeabi_fmul(uVar10,uVar10);\n      uVar31 = __aeabi_fmul(uVar11,uVar11);\n      uVar30 = __addsf3(uVar30,uVar31);\n      uVar31 = __aeabi_fmul(uVar2,uVar2);\n      uVar30 = __addsf3(uVar30,uVar31);\n      uVar31 = __aeabi_fmul(uVar3,uVar3);\n      __addsf3(uVar30,uVar31);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(uVar28,in_stack_ffffff78));\n      uVar30 = __truncdfsf2();\n      uVar30 = __aeabi_fdiv(0x3f800000,uVar30);\n      uVar31 = __aeabi_fmul(uVar10,uVar30);\n      puVar1 = PTR_q_08003d88;\n      *(undefined4 *)PTR_q_08003d88 = uVar31;\n      uVar5 = __aeabi_fmul(uVar11,uVar30);\n      *(undefined4 *)(puVar1 + 4) = uVar5;\n      uVar2 = __aeabi_fmul(uVar2,uVar30);\n      *(undefined4 *)(puVar1 + 8) = uVar2;\n      uVar3 = __aeabi_fmul(uVar3,uVar30);\n      *(undefined4 *)(puVar1 + 0xc) = uVar3;\n      uVar3 = __aeabi_fmul(uVar5,uVar3);\n      uVar2 = __aeabi_fmul(uVar31,uVar2);\n      uVar2 = __aeabi_fsub(uVar3,uVar2);\n      __addsf3(uVar2,uVar2);\n      __aeabi_f2d();\n      asin((double)CONCAT44(uVar28,in_stack_ffffff78));\n      uVar32 = __muldf3();\n      __divdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_08003d78,DAT_08003d7c);\n      uVar2 = __truncdfsf2();\n      *in_stack_00000014 = uVar2;\n      uVar31 = *(undefined4 *)puVar1;\n      uVar5 = *(undefined4 *)(puVar1 + 4);\n      uVar2 = __aeabi_fmul(uVar31,uVar31);\n      uVar3 = __aeabi_fmul(uVar5,uVar5);\n      uVar2 = __aeabi_fsub(uVar2,uVar3);\n      uVar28 = *(undefined4 *)(puVar1 + 8);\n      uVar3 = __aeabi_fmul(uVar28,uVar28);\n      uVar2 = __aeabi_fsub(uVar2,uVar3);\n      uVar30 = *(undefined4 *)(puVar1 + 0xc);\n      uVar3 = __aeabi_fmul(uVar30,uVar30);\n      __addsf3(uVar2,uVar3);\n      uVar32 = __aeabi_f2d();\n      uVar2 = __aeabi_fmul(uVar31,uVar5);\n      uVar3 = __aeabi_fmul(uVar28,uVar30);\n      uVar2 = __addsf3(uVar2,uVar3);\n      __addsf3(uVar2,uVar2);\n      uVar33 = __aeabi_f2d();\n      uVar32 = atan2((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar32,\n                     (int)((ulonglong)uVar32 >> 0x20));\n      uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,DAT_08003ea8);\n      __divdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_08003ea0,DAT_08003ea4);\n      uVar2 = __truncdfsf2();\n      in_stack_00000014[1] = uVar2;\n      uVar30 = *(undefined4 *)puVar1;\n      uVar31 = *(undefined4 *)(puVar1 + 4);\n      uVar2 = __aeabi_fmul(uVar30,uVar30);\n      uVar3 = __aeabi_fmul(uVar31,uVar31);\n      uVar2 = __addsf3(uVar2,uVar3);\n      uVar5 = *(undefined4 *)(puVar1 + 8);\n      uVar3 = __aeabi_fmul(uVar5,uVar5);\n      uVar2 = __aeabi_fsub(uVar2,uVar3);\n      uVar28 = *(undefined4 *)(puVar1 + 0xc);\n      uVar3 = __aeabi_fmul(uVar28,uVar28);\n      __aeabi_fsub(uVar2,uVar3);\n      uVar32 = __aeabi_f2d();\n      uVar2 = __aeabi_fmul(uVar31,uVar5);\n      uVar3 = __aeabi_fmul(uVar30,uVar28);\n      uVar2 = __addsf3(uVar2,uVar3);\n      __addsf3(uVar2,uVar2);\n      uVar33 = __aeabi_f2d();\n      uVar32 = atan2((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar32,\n                     (int)((ulonglong)uVar32 >> 0x20));\n      uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,DAT_08003ea8);\n      __divdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_08003ea0,DAT_08003ea4);\n      uVar2 = __truncdfsf2();\n      in_stack_00000014[2] = uVar2;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "asin",
                "__aeabi_fmul",
                "__divdf3",
                "__addsf3",
                "__muldf3",
                "sqrt",
                "__aeabi_fsub",
                "__aeabi_f2d",
                "__aeabi_fdiv",
                "__truncdfsf2",
                "atan2",
                "__aeabi_fcmpeq"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003330",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "FUNC_08003330"
        },
        "FUN_08000980": {
            "renaming": {
                "FUN_08000980": "compare_double_values_08000980",
                "param_1": "value1",
                "param_2": "value2"
            },
            "code": "void compare_double_values_08000980(double value1, double value2) {\n    __aeabi_cdcmpeq(value1, value2, PTR_param_1, PTR_param_2);\n    return;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000980",
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "imported": false,
            "current_name": "compare_double_values_08000980"
        },
        "FUN_08002368": {
            "renaming": {
                "FUN_08002368": "set_timer_08002368",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "cr1",
                "pTVar2": "repetition_counter",
                "DAT_080023cc": "timer1"
            },
            "code": "void set_timer_08002368(TIM_TypeDef *timer, TIM_Base_InitTypeDef *config)\n{\n    uint32_t cr1 = timer->CR1;\n    if ((((timer == DAT_080023cc) || (timer == timer2)) ||\n         (timer == &DAT_080023cc[-0x387].DMAR)) ||\n        (timer == &DAT_080023cc[-0x37A].SMCR)) {\n        cr1 = cr1 & 0xffffff8f | config->CounterMode;\n        if (((timer == DAT_080023cc) || (timer == timer2)) ||\n            ((timer == &DAT_080023cc[-0x387].DMAR ||\n              (timer == &DAT_080023cc[-0x37A].SMCR)))) {\n            cr1 = cr1 & 0xfffffcff | config->ClockDivision;\n        }\n    }\n    timer->CR1 = cr1;\n    timer->ARR = config->Period;\n    timer->PSC = config->Prescaler;\n    TIM_TypeDef *repetition_counter = DAT_080023cc;\n    if (timer == DAT_080023cc) {\n        repetition_counter = (TIM_TypeDef *)config->RepetitionCounter;\n    }\n    if (timer == DAT_080023cc) {\n        timer->RCR = (uint32_t)repetition_counter;\n    }\n    timer->EGR = 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002368",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "set_timer_08002368"
        },
        "FUN_08002008": {
            "renaming": {
                "FUN_08002008": "calculate_pll_multiplier_08002008",
                "aPredivFactorTable": "prediv_factor_table",
                "aPLLMULFactorTable": "pll_mul_factor_table",
                "uVar1": "current_pll_mul_factor_low",
                "uVar2": "pll_multiplier",
                "uVar3": "current_pll_mul_factor_high",
                "uVar4": "reg_value",
                "uVar5": "leading_zeroes",
                "uVar6": "prediv_factor_index"
            },
            "code": "uint32_t calculate_pll_multiplier_08002008(void)\n{\n    uint32_t pll_mul_factor_table[16];\n    uint8_t prediv_factor_table[2] = {1, 2};\n    uint32_t pll_multiplier = DAT_08002094;\n    uint32_t reg_value = *(uint *)(DAT_08002090 + 4);\n    if ((reg_value & 0xc) == 8)\n    {\n        uint32_t leading_zeroes = count_leading_zeroes(0x3c00);\n        uint32_t prediv_factor_index = count_leading_zeroes(0x4000);\n        if ((int)(reg_value << 0xf) < 0)\n        {\n            prediv_factor_index = count_leading_zeroes(0x4000);\n            prediv_factor_index = prediv_factor_index & 0xff;\n            prediv_factor_index = (*(uint *)(DAT_08002090 + 4) & 0x20000) >> prediv_factor_index;\n            prediv_factor_index = aPredivFactorTable[prediv_factor_index];\n            pll_multiplier = DAT_08002094 / prediv_factor_index;\n        }\n        uint32_t pll_mul_factor_index = (reg_value & 0x3c0000) >> leading_zeroes;\n        pll_mul_factor_index = pll_mul_factor_index & 0xff;\n        pll_multiplier = pll_multiplier * pll_mul_factor_table[pll_mul_factor_index];\n    }\n    return pll_multiplier;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002008",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_pll_multiplier_08002008"
        },
        "FUN_080008fc": {
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "x",
                "param_2": "y",
                "param_3": "z",
                "param_4": "w",
                "uVar1": "temp1",
                "bVar2": "is_zero",
                "bVar3": "is_equal"
            },
            "code": "uint check_parameters_080008fc(uint x, uint y, uint z, uint w) {\n  uint temp1;\n  bool is_zero;\n  bool is_equal;\n  if (((int)(y << 1) >> 0x15 == -1 || (int)(w << 1) >> 0x15 == -1) && ((((int)(y << 1) >> 0x15 == -1 && ((x | y << 0xc) != 0)) || (((int)(w << 1) >> 0x15 == -1 && ((z | w << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (x | y << 1) == 0;\n  if (is_zero) {\n    is_zero = (z | w << 1) == 0;\n  }\n  if (!is_zero) {\n    is_equal = y == w;\n  }\n  if (is_equal) {\n    is_equal = x == z;\n  }\n  if (!is_equal) {\n    temp1 = y ^ w;\n    is_zero = temp1 == 0;\n    if (-1 < (int)temp1) {\n      is_zero = y == w;\n    }\n    is_equal = -1 < (int)temp1 && w <= y;\n    if (is_zero) {\n      is_equal = z <= x;\n    }\n    w = (int)w >> 0x1f;\n    if (!is_equal) {\n      w = ~w;\n    }\n    return w | 1;\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008fc",
            "calling": [],
            "imported": false,
            "current_name": "check_parameters_080008fc"
        },
        "FUN_0800114c": {
            "renaming": {
                "FUN_0800114c": "increment_uwTick_0800114c",
                "PTR_uwTick_08001158": "uwTick"
            },
            "code": "void increment_uwTick_0800114c(void)\n{\n  int* PTR_uwTick_08001158 = (int*) PTR_PTR_uwTick_08001158_08001158;\n  *PTR_uwTick_08001158 += 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800114c",
            "calling": [
                "main",
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "increment_uwTick_0800114c"
        },
        "FUN_08002250": {
            "renaming": {
                "FUN_08002250": "number_of_leading_zero_bits_08002250",
                "uVar1": "leading_zeroes_count",
                "value": "input_value",
                "system_clock_ptr": "system_clock_pointer",
                "apb_presc_table_ptr": "apb_prescaler_table_pointer",
                "dat_ptr": "dat_pointer",
                "mask": "bit_mask",
                "shift": "shift_amount"
            },
            "code": "uint32_t number_of_leading_zero_bits_08002250() {\n  uint32_t value = 0x1c0000;\n  uint32_t* system_clock_ptr = (uint32_t*) PTR_SystemCoreClock_0800227c;\n  uint32_t* apb_presc_table_ptr = (uint32_t*) PTR_APBPrescTable_08002278;\n  uint32_t* dat_ptr = (uint32_t*) DAT_08002274;\n  uint32_t mask = 0x3800;\n  uint32_t shift = ((*dat_ptr) & mask) >> count_leading_zeroes(value);\n  return (*system_clock_ptr) >> apb_presc_table_ptr[shift];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002250",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "number_of_leading_zero_bits_08002250"
        },
        "FUN_080011fc": {
            "renaming": {
                "FUN_080011fc": "set_interrupt_priority_bit_080011fc",
                "IRQn": "interrupt_number",
                "DAT_08001210": "interrupt_priority_register_base_address",
                "PTR_08001210": "interrupt_priority_register_base_address_pointer",
                "PTR_DAT_08001210": "interrupt_priority_register_base_address_pointer_to_pointer"
            },
            "code": "void set_interrupt_priority_bit_080011fc(IRQn_Type interrupt_number)\n{\n  int* interrupt_priority_register = (int*)(DAT_08001210 + ((uint)(int)interrupt_number >> 5) * 4);\n  int interrupt_priority_bit = 1 << ((int)interrupt_number & 0x1fU);\n  *interrupt_priority_register = interrupt_priority_bit;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011fc",
            "calling": [
                "HAL_UART_MspInit"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_bit_080011fc"
        },
        "FUN_08003f7c": {
            "renaming": {
                "FUN_08003f7c": "blink_led_three_times_08003f7c",
                "iVar1": "num_blinks"
            },
            "code": "void blink_led_three_times_08003f7c(void)\n{\n  int num_blinks = 3;\n  do {\n    toggleLED(1,0,0);\n    delay_ms(100);\n    toggleLED(0,1,0);\n    delay_ms(100);\n    toggleLED(0,0,1);\n    delay_ms(100);\n    num_blinks--;\n  } while (num_blinks > 0);\n  toggleLED(1,1,1);\n  return;\n}",
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f7c",
            "calling": [
                "Devices_Init"
            ],
            "imported": false,
            "current_name": "blink_led_three_times_08003f7c"
        },
        "FUN_08005646": {
            "renaming": {
                "FUN_08005646": "reverse_copy_08005646",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "destination_ptr",
                "iVar2": "overlap_size",
                "puVar3": "source_ptr"
            },
            "code": "void * reverse_copy_08005646(void *destination, const void *source, size_t num_bytes) {\n  unsigned char *source_ptr = (unsigned char *)source + num_bytes;\n  unsigned char *destination_ptr = (unsigned char *)destination + num_bytes;\n  if ((source < destination) && (destination < source_ptr)) {\n    size_t overlap_size = num_bytes - ((size_t)source_ptr - (size_t)destination);\n    while (source_ptr + overlap_size != NULL) {\n      source_ptr--;\n      destination_ptr--;\n      *destination_ptr = *source_ptr;\n    }\n    return destination;\n  }\n  unsigned char *destination_ptr_minus_one = (unsigned char *)destination - 1;\n  for (; (unsigned char *)source != source_ptr; source = (unsigned char *)source + 1) {\n    destination_ptr_minus_one++;\n    *destination_ptr_minus_one = *(unsigned char *)source;\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005646",
            "calling": [
                "__ssputs_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_08005646"
        },
        "FUN_08000990": {
            "renaming": {
                "FUN_08000990": "convert_float_to_double_08000990",
                "param_1": "float_val"
            },
            "code": "undefined4 convert_float_to_double_08000990(undefined4 float_val)\n{\n  __nedf2();\n  return float_val;\n}",
            "called": [
                "__nedf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000990",
            "calling": [
                "__aeabi_dcmple",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmpeq"
            ],
            "imported": false,
            "current_name": "convert_float_to_double_08000990"
        },
        "FUN_08004ee6": {
            "renaming": {
                "FUN_08004ee6": "infinite_loop_08004ee6"
            },
            "code": "void infinite_loop_08004ee6(void)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "HardFault_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee6",
            "calling": [
                "HardFault_Handler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08004ee6"
        },
        "FUN_08004434": {
            "renaming": {
                "FUN_08004434": "send_altitude_data_08004434",
                "in_r1": "altitude_and_flags",
                "local_10": "altitude",
                "local_c": "combined_data",
                "PTR_msp_txf_altitude_08004454": "msp_txf_altitude_ptr"
            },
            "code": "void send_altitude_data_08004434(void)\n{\n  uint16_t altitude_data;\n  uint32_t combined_data;\n  altitude_data = *(uint16_t *)PTR_msp_txf_altitude_08004454;\n  combined_data = (uint32_t)(altitude_data << 16) | (uint32_t)(*(uint16_t *)(PTR_msp_txf_altitude_08004454 + 4));\n  MSP_SendFrame('m', (uint8_t *)&combined_data, 6);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004434",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_altitude_data_08004434"
        },
        "FUN_08001168": {
            "renaming": {
                "FUN_08001168": "do_nothing_08001168"
            },
            "code": "\nvoid do_nothing_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001168",
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "imported": false,
            "current_name": "do_nothing_08001168"
        },
        "FUN_08004ee4": {
            "renaming": {
                "FUN_08004ee4": "do_nothing_08004ee4"
            },
            "code": "\nvoid do_nothing_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee4",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004ee4"
        },
        "FUN_08004ee8": {
            "renaming": {
                "FUN_08004ee8": "infinite_loop_08004ee8"
            },
            "code": "void infinite_loop_08004ee8(void)\n{\n  while(true) {\n    // do nothing\n  }\n}",
            "called": [
                "MemManage_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee8",
            "calling": [
                "MemManage_Handler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08004ee8"
        },
        "FUN_08004ffc": {
            "renaming": {
                "FUN_08004ffc": "print_formatted_string_08004ffc",
                "__s": "string",
                "__format": "format",
                "iVar1": "num_chars_printed",
                "local_78": "local_string_ptrs",
                "local_70": "max_string_length",
                "local_6c": "local_ints[0]",
                "local_6a": "max_field_width",
                "local_68": "string_ptr",
                "local_64": "local_ints[1]",
                "pcStack_c": "format_ptr",
                "uStack_8": "unused_var_1",
                "uStack_4": "unused_var_2"
            },
            "code": "int print_formatted_string_08004ffc(char* string, char* format, ...) {\n  int num_chars_printed;\n  char* string_ptr = string;\n  char* format_ptr = format;\n  char* local_string_ptrs[2];\n  int max_string_length = 0x7fffffff;\n  int max_field_width = 0xffff;\n  unsigned int local_ints[2];\n  local_string_ptrs[0] = string_ptr;\n  local_ints[0] = max_string_length;\n  local_ints[1] = max_field_width;\n  num_chars_printed = _svfiprintf_r(*(undefined4*)PTR__impure_ptr_08005040, local_string_ptrs, format_ptr);\n  *local_string_ptrs[0] = '\\0';\n  return num_chars_printed;\n}\n",
            "called": [
                "_svfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ffc",
            "calling": [
                "serialInt"
            ],
            "imported": false,
            "current_name": "print_formatted_string_08004ffc"
        },
        "FUN_0800103c": {
            "renaming": {
                "FUN_0800103c": "is_not_equal_to_zero_or_not_nan_0800103c",
                "in_ZR": "is_nan",
                "in_CY": "unused_variable"
            },
            "code": "bool is_not_equal_to_zero_or_not_nan_0800103c(void)\n{\n  bool is_nan = __aeabi_cfcmpeq();\n  return !is_nan || is_nan;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800103c",
            "calling": [],
            "imported": false,
            "current_name": "is_not_equal_to_zero_or_not_nan_0800103c"
        },
        "FUN_0800115c": {
            "renaming": {
                "FUN_0800115c": "get_uwTick_value_0800115c",
                "PTR_uwTick_08001164": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_0800115c(void)\n{\n  return *(uint32_t *)PTR_uwTick_08001164;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800115c",
            "calling": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "HAL_RCC_OscConfig",
                "HAL_I2C_Mem_Read",
                "millis",
                "I2C_RequestMemoryWrite",
                "HAL_RCC_ClockConfig",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_0800115c"
        },
        "FUN_08004f60": {
            "renaming": {
                "FUN_08004f60": "get_uw_tick_08004f60",
                "PTR_uwTick_08001164": "uw_tick_ptr"
            },
            "code": "uint32_t get_uw_tick_08004f60(void)\n{\n  uint32_t* PTR_uwTick_08001164 = (uint32_t*) PTR_uwTick_08001164;\n  return *PTR_uwTick_08001164;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f60",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "get_uw_tick_08004f60"
        },
        "FUN_08002d88": {
            "renaming": {
                "FUN_08002d88": "read_mag_data_08002d88",
                "sVar1": "x_raw",
                "sVar2": "y_raw",
                "puVar3": "s____Src_MPU9250_c_08002e80",
                "puVar4": "magData",
                "puVar5": "magCalib",
                "puVar6": "magBias",
                "bVar7": "status",
                "uVar8": "x",
                "uVar9": "resolution",
                "raw_data": "raw_data",
                "PTR_s____Src_MPU9250_c_08002e80": "s____Src_MPU9250_c_08002e80",
                "PTR_magRaw_08002e84": "magRaw",
                "PTR_magBias_08002e9c": "magBias",
                "PTR_magCalib_08002e98": "magCalib",
                "PTR_mRes_08002e88": "mRes",
                "PTR_magScale_08002e8c": "magScale",
                "PTR_magData_08002e90": "magData",
                "msp_txf_status": "msp_txf_status"
            },
            "code": "void read_mag_data_08002d88()\n{\n    short x_raw;\n    short y_raw;\n    uint8_t raw_data[7];\n    float resolution = *(float*)PTR_mRes_08002e88;\n    float scale_factor = *(float*)PTR_magScale_08002e8c;\n    float calibration = *(float*)PTR_magCalib_08002e98;\n    float bias = *(float*)PTR_magBias_08002e9c;\n\n    raw_data[0] = 0;\n    raw_data[1] = 0;\n    raw_data[2] = 0;\n    raw_data[3] = 0;\n    raw_data[4] = 0;\n    raw_data[5] = 0;\n    raw_data[6] = 0;\n\n    uint8_t status = I2C_ReadByte(0x18, 2, PTR_s____Src_MPU9250_c_08002e80, 0xd7);\n\n    if (status >= 0)\n    {\n        I2C_ReadByteArray(0x18, 3, raw_data, 7, PTR_s____Src_MPU9250_c_08002e80, 0xda);\n\n        if ((int)((uint)raw_data[6] << 0x1c) < 0)\n        {\n            *(short*)(msp_txf_status + 2) = *(short*)(msp_txf_status + 2) + 1;\n        }\n        else\n        {\n            x_raw = (raw_data[2] << 8) | raw_data[3];\n            y_raw = (raw_data[4] << 8) | raw_data[5];\n\n            PTR_magRaw_08002e84[0] = raw_data[0];\n            PTR_magRaw_08002e84[1] = x_raw;\n            PTR_magRaw_08002e84[2] = y_raw;\n\n            float x = (float)x_raw * resolution * *(float*)(PTR_magCalib_08002e98 + 4) - *(float*)(PTR_magBias_08002e9c + 4);\n            float y = (float)y_raw * resolution * *(float*)(PTR_magCalib_08002e98 + 8) - *(float*)(PTR_magBias_08002e9c + 8);\n\n            PTR_magData_08002e90[0] = x * scale_factor;\n            PTR_magData_08002e90[1] = y * scale_factor;\n        }\n    }\n}",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "I2C_ReadByteArray",
                "__aeabi_fsub",
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d88",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "read_mag_data_08002d88"
        },
        "FUN_08004f64": {
            "renaming": {
                "FUN_08004f64": "do_nothing_08004f64"
            },
            "code": "\nvoid do_nothing_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "called": [
                "HAL_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f64",
            "calling": [
                "LED_StartupSequence",
                "I2C_WriteByte",
                "_Error_Handler",
                "MS5611_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f64"
        },
        "FUN_08002b48": {
            "renaming": {
                "FUN_08002b48": "read_accelerometer_data_08002b48",
                "in_r3": "MPU9250_I2C_BUS",
                "raw_data": "raw_data",
                "puVar1": "accelRaw",
                "uVar2": "acceleration",
                "PTR_s____Src_MPU9250_c_08002be4": "MPU9250_I2C_BUS",
                "PTR_accelRaw_08002be8": "accelRaw",
                "PTR_accelData_08002bec": "accelData"
            },
            "code": "void read_accelerometer_data_08002b48(void)\n{\n  uint16_t raw_data[3];\n  I2C_ReadByteArray(0xd0, 0x3b, raw_data, 6, PTR_s____Src_MPU9250_c_08002be4, 0x58);\n  float x_acceleration = (float)((int16_t) ((raw_data[0] << 8) | raw_data[1])) * 0.000244140625f;\n  float y_acceleration = (float)((int16_t) ((raw_data[2] << 8) | raw_data[3])) * 0.000244140625f;\n  float z_acceleration = (float)((int16_t) ((raw_data[4] << 8) | raw_data[5])) * 0.000244140625f;\n  PTR_accelData_08002bec[0] = x_acceleration;\n  PTR_accelData_08002bec[1] = y_acceleration;\n  PTR_accelData_08002bec[2] = z_acceleration;\n}",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "I2C_ReadByteArray"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b48",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "read_accelerometer_data_08002b48"
        },
        "FUN_08004f68": {
            "renaming": {
                "FUN_08004f68": "initialize_system_08004f68",
                "iVar1": "index",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "jump_table_ptr"
            },
            "code": "void initialize_system_08004f68(void)\n{\n  int index;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8672_08004fa8;\n  code *jump_table_ptr;\n  for (index = 0; PTR_gyroBias_08004fa0 + index < PTR_completed_8672_08004fa4; index += 4)\n  {\n    *(undefined4 *)(PTR_gyroBias_08004fa0 + index) = *(undefined4 *)(PTR__sidata_08004f9c + index);\n  }\n  for (; completed_ptr < PTR__ebss_08004fac; completed_ptr++)\n  {\n    *completed_ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jump_table_ptr = (code *)0x8004f9a;\n  main();\n  (*jump_table_ptr)();\n  return;\n}",
            "called": [
                "SystemInit",
                "main",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f68",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08004f68"
        },
        "FUN_08001170": {
            "renaming": {
                "FUN_08001170": "set_priority_group_08001170",
                "PriorityGroup": "priority_group",
                "DAT_08001190": "data_ptr",
                "PTR_": "ptr_"
            },
            "code": "void set_priority_group_08001170(uint32_t priority_group) {\n    uint32_t* ptr = (uint32_t*)(DAT_08001190 + 0xc);\n    uint32_t mask = 0xf8ff;\n    uint32_t priority_bits = (priority_group & 7) << 8;\n    uint32_t value = *ptr;\n    value = (value & mask) | 0x5fa0000 | priority_bits;\n    *ptr = value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001170",
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "imported": false,
            "current_name": "set_priority_group_08001170"
        },
        "FUN_08002bf0": {
            "renaming": {
                "FUN_08002bf0": "read_gyro_data_08002bf0",
                "raw_data": "gyro_raw_data",
                "puVar1": "gyro_raw_data_ptr",
                "puVar2": "gyro_data_ptr",
                "uVar3": "gyro_bias",
                "gyro_x": "gyro_x_raw",
                "gyro_y": "gyro_y_raw",
                "gyro_z": "gyro_z_raw",
                "gyroBias_08002ca4": "gyro_bias_ptr",
                "DAT_08002ca8": "gyro_scale_factor"
            },
            "code": "void read_gyro_data_08002bf0(void)\n{\n    uint8_t raw_data[6] = {0};\n    I2C_ReadByteArray(0xd0, 0x43, raw_data, 6, gyro_raw_data_ptr, 0x7b);\n    int16_t gyro_x = (raw_data[0] << 8) | raw_data[1];\n    int16_t gyro_y = (raw_data[2] << 8) | raw_data[3];\n    int16_t gyro_z = (raw_data[4] << 8) | raw_data[5];\n    float gyro_bias = *(float *)gyro_bias_ptr;\n    float DAT_08002ca8 = 0.00013316211f;\n    float gyro_x_data = (float)gyro_x * DAT_08002ca8 - gyro_bias;\n    float gyro_y_data = (float)gyro_y * DAT_08002ca8 - *(float *)(gyro_bias_ptr + 4);\n    float gyro_z_data = (float)gyro_z * DAT_08002ca8 - *(float *)(gyro_bias_ptr + 8);\n    *(float *)gyro_data_ptr = gyro_x_data;\n    *(float *)(gyro_data_ptr + 4) = gyro_y_data;\n    *(float *)(gyro_data_ptr + 8) = gyro_z_data;\n}\n",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "I2C_ReadByteArray",
                "__aeabi_fsub"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002bf0",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "read_gyro_data_08002bf0"
        },
        "FUN_08004ef0": {
            "renaming": {
                "FUN_08004ef0": "do_nothing_08004ef0"
            },
            "code": "\nvoid do_nothing_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004ef0"
        },
        "FUN_08002ad0": {
            "renaming": {
                "FUN_08002ad0": "read_MPU9250_sensor_data_08002ad0",
                "PTR_s____Src_MPU9250_c_08002b44": "sensor_data"
            },
            "code": "void read_MPU9250_sensor_data_08002ad0(void)\n{\n  I2C_ReadByte(0xd0, 0x75, PTR_s____Src_MPU9250_c_08002b44, 0x3b);\n  I2C_WriteByte(0xd0, 0x6b, 0x80, 0x01);\n  I2C_WriteByte(0xd0, 0x6b, 0x01, 0x01);\n  I2C_WriteByte(0xd0, 0x6c, 0x00, 0x01);\n  I2C_WriteByte(0xd0, 0x19, 0x00, 0x01);\n  I2C_WriteByte(0xd0, 0x1d, 0x03, 0x01);\n  I2C_WriteByte(0xd0, 0x1a, 0x03, 0x01);\n  I2C_WriteByte(0xd0, 0x1b, 0x10, 0x01);\n  I2C_WriteByte(0xd0, 0x1c, 0x08, 0x01);\n  return;\n}",
            "called": [
                "I2C_WriteByte",
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ad0",
            "calling": [
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "read_MPU9250_sensor_data_08002ad0"
        },
        "FUN_08001050": {
            "renaming": {
                "FUN_08001050": "is_less_than_or_equal_to_zero_08001050",
                "in_CY": "is_nan",
                "in_ZR": "num",
                "__aeabi_cfrcmple": "__aeabi_cfrcmple"
            },
            "code": "bool is_less_than_or_equal_to_zero_08001050(float num) {\n    bool is_nan = __aeabi_cfrcmple(num, num);\n    return is_nan || num <= 0.0;\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001050",
            "calling": [
                "AHRS_GetYaw"
            ],
            "imported": false,
            "current_name": "is_less_than_or_equal_to_zero_08001050"
        },
        "FUN_08004ef4": {
            "renaming": {
                "FUN_08004ef4": "tick_handler_08004ef4"
            },
            "code": "void tick_handler_08004ef4(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  return;\n}",
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef4",
            "calling": [],
            "imported": false,
            "current_name": "tick_handler_08004ef4"
        },
        "FUN_08004ef2": {
            "renaming": {
                "FUN_08004ef2": "do_nothing_08004ef2"
            },
            "code": "\nvoid do_nothing_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef2",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004ef2"
        },
        "FUN_080043bc": {
            "renaming": {
                "FUN_080043bc": "copy_imu_data_to_frame_and_send_080043bc",
                "puVar3": "imu_data_ptr",
                "puVar4": "raw_imu_data_ptr",
                "uVar1": "imu_data_low_byte",
                "uVar2": "imu_data_high_byte",
                "local_24": "imu_data",
                "local_1c": "unused_local_variables"
            },
            "code": "void copy_imu_data_to_frame_and_send_080043bc(void)\n{\n  uint16_t imu_data[6];\n  uint16_t *imu_data_ptr = (uint16_t *)PTR_msp_txf_raw_imu_080043ec;\n  for (int i = 0; i < 6; i++) {\n    imu_data[i] = *imu_data_ptr;\n    imu_data_ptr++;\n  }\n  MSP_SendFrame('f', (uint8_t *)imu_data, 0x12);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043bc",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "copy_imu_data_to_frame_and_send_080043bc"
        },
        "FUN_08004f5c": {
            "renaming": {
                "FUN_08004f5c": "get_uw_tick_value_08004f5c",
                "PTR_uwTick_08001164": "uw_tick_ptr"
            },
            "code": "uint32_t get_uw_tick_value_08004f5c(void)\n{\n  uint32_t* PTR_uwTick_08001164 = (uint32_t*)PTR_uwTick_08001164;\n  return *PTR_uwTick_08001164;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f5c",
            "calling": [
                "MS5611_Update",
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "get_uw_tick_value_08004f5c"
        },
        "FUN_08000404": {
            "renaming": {
                "FUN_08000404": "calculate_bitmask_08000404",
                "param_1": "number",
                "uVar1": "mask",
                "uVar2": "abs_number",
                "uVar3": "shift_amount",
                "iVar4": "count_leading",
                "uVar5": "count_leading_shifted",
                "uVar6": "sign_bit",
                "bVar7": "leading_less_than_11",
                "bVar8": "leading_equals_11",
                "bVar9": "leading_greater_than_11"
            },
            "code": "ulonglong calculate_bitmask_08000404(uint number)\n{\n    ulonglong count = 0;\n    if (number == 0) return 32;\n    if ((number & 0xFFFF0000) == 0) { count += 16; number <<= 16; }\n    if ((number & 0xFF000000) == 0) { count += 8; number <<= 8; }\n    if ((number & 0xF0000000) == 0) { count += 4; number <<= 4; }\n    if ((number & 0xC0000000) == 0) { count += 2; number <<= 2; }\n    if ((number & 0x80000000) == 0) { count += 1; }\n    return count;\n}\n\nulonglong count_trailing_zeroes(uint number)\n{\n    ulonglong count = 0;\n    if (number == 0) return 32;\n    if ((number & 0x0000FFFF) == 0) { count += 16; number >>= 16; }\n    if ((number & 0x000000FF) == 0) { count += 8; number >>= 8; }\n    if ((number & 0x0000000F) == 0) { count += 4; number >>= 4; }\n    if ((number & 0x00000003) == 0) { count += 2; number >>= 2; }\n    if ((number & 0x00000001) == 0) { count += 1; }\n    return count;\n}\n\nulonglong calculate_bitmask_08000404(uint number)\n{\n    if (number == 0) return 0;\n    uint abs_number = (number & 0x80000000) ? -number : number;\n    ulonglong count_leading = calculate_bitmask_08000404(abs_number);\n    ulonglong count_trailing = count_trailing_zeroes(number);\n    if (count_leading >= 0x20) return (number & 0x80000000) ? 0xFFFFFFFFFFFFFFFF : 0;\n    uint shift_amount = count_trailing + 0x15;\n    if (count_leading < 0xB) shift_amount -= 0xB - count_leading;\n    if (shift_amount >= 0x20) return (number & 0x80000000) ? 0xFFFFFFFFFFFFFFFF : 0;\n    uint high_bits = (shift_amount < 0xC) ? (number << shift_amount) : (number >> (0x20 - shift_amount));\n    uint low_bits = (shift_amount < 0xC) ? (number >> (0x20 - shift_amount)) : 0;\n    if (shift_amount > 0x15) low_bits |= (0xFFFFFFFF << (0x20 - shift_amount));\n    return ((ulonglong)high_bits << 32) | low_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000404",
            "calling": [
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_bitmask_08000404"
        },
        "FUN_08004eec": {
            "renaming": {
                "FUN_08004eec": "infinite_loop_with_no_operations_08004eec"
            },
            "code": "void infinite_loop_with_no_operations_08004eec(void)\n{\n  while( true )\n  {\n    // Do nothing\n  }\n}",
            "called": [
                "UsageFault_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004eec",
            "calling": [
                "UsageFault_Handler"
            ],
            "imported": false,
            "current_name": "infinite_loop_with_no_operations_08004eec"
        },
        "FUN_08004eea": {
            "renaming": {
                "FUN_08004eea": "do_nothing_forever_08004eea"
            },
            "code": "void do_nothing_forever_08004eea(void)\n{\n  while(true)\n  {\n      // Do nothing\n  }\n}",
            "called": [
                "BusFault_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004eea",
            "calling": [
                "BusFault_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_forever_08004eea"
        },
        "FUN_08006070": {
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "a",
                "param_2": "b",
                "param_3": "c",
                "param_4": "d",
                "param_5": "x",
                "uVar1": "var1",
                "extraout_r1": "var2",
                "extraout_r1_00": "var3",
                "unaff_r4": "var4",
                "iVar2": "diff",
                "uVar3": "var5",
                "uVar4": "abs_b",
                "uVar6": "abs_d",
                "iVar5": "diff_shifted",
                "uVar7": "result",
                "uVar8": "result2"
            },
            "code": "undefined8 calculate_result_08006070(uint a, uint b, uint c, uint d, double x) {\n  uint abs_c = c & 0x7fffffff;\n  uint abs_b = b & 0x7fffffff;\n  uint abs_d = d & 0x7fffffff;\n  undefined8 result;\n  if (DAT_08006220 < (abs_c | (-c | c) >> 0x1f) || DAT_08006220 < (abs_b | (-a | a) >> 0x1f)) {\n    result = __aeabi_dadd(a, b);\n    return result;\n  }\n  if ((d + 0xc0100000 | c) == 0) {\n    atan(x);\n    result = CONCAT44(extraout_r1, a);\n    return result;\n  }\n  uint uVar3 = (int)d >> 0x1e & 2U | b >> 0x1f;\n  if ((a | abs_b) == 0) {\n    if (uVar3 == 2) {\n      result = CONCAT44(DAT_080061fc, DAT_080061f8);\n    }\n    else if (uVar3 == 3) {\n      result = CONCAT44(abs_b, a);\n    }\n    else {\n      result = CONCAT44(abs_b, a);\n    }\n  }\n  else {\n    if ((c | abs_d) != 0) {\n      if (abs_d == DAT_08006220) {\n        if (abs_b == DAT_08006220) {\n          if (uVar3 == 2) {\n            result = CONCAT44(DAT_080061ec, DAT_080061e8);\n          }\n          else if (uVar3 == 3) {\n            result = CONCAT44(DAT_080061f4, DAT_080061f0);\n          }\n          else if (uVar3 == 1) {\n            result = CONCAT44(DAT_080061e4, DAT_080061e0);\n          }\n          else {\n            result = CONCAT44(DAT_0800621c, DAT_08006218);\n          }\n        }\n        else {\n          if (uVar3 == 2) {\n            result = CONCAT44(DAT_080061fc, DAT_080061f8);\n          }\n          else if (uVar3 == 3) {\n            result = CONCAT44(DAT_08006204, DAT_08006200);\n          }\n          else if (uVar3 == 1) {\n            result = 0x8000000000000000;\n          }\n          else {\n            result = 0;\n          }\n        }\n      }\n      else if (abs_b != DAT_08006220) {\n        int diff = (int)(abs_b - abs_d) >> 0x14;\n        undefined4 var1 = DAT_08006210;\n        int var2 = DAT_08006214;\n        if (diff < 0x3d) {\n          if ((int)d < 0 && diff + 0x3c < 0 != SCARRY4(diff, 0x3c)) {\n            var1 = 0;\n            var2 = 0;\n          }\n          else {\n            var1 = __divdf3(a, b);\n            fabs((double)CONCAT44(unaff_r4, c));\n            atan((double)CONCAT44(unaff_r4, c));\n            var2 = extraout_r1_00;\n          }\n        }\n        if (uVar3 != 1) {\n          if (uVar3 == 2) {\n            result = __subdf3(var1, var2, DAT_08006208, DAT_0800620c);\n            result = CONCAT44(DAT_080061fc, DAT_080061f8);\n          }\n          else {\n            if (uVar3 == 0) {\n              result = CONCAT44(var2, var1);\n            }\n            else {\n              result = __subdf3(var1, var2, DAT_08006208, DAT_0800620c);\n              result = CONCAT44(DAT_080061fc, DAT_080061f8);\n            }\n          }\n          result = __subdf3((int)result, (int)((ulonglong)result >> 0x20), (int)result, (int)((ulonglong)result >> 0x20));\n        }\n        else {\n          result = CONCAT44(var2 + -0x80000000, var1);\n        }\n      }\n    }\n    else {\n      result = CONCAT44(DAT_08006214, DAT_08006210);\n      if ((int)b < 0) {\n        result = CONCAT44(DAT_080061dc, DAT_080061d8);\n      }\n    }\n  }\n  return result;\n}",
            "called": [
                "__divdf3",
                "__aeabi_dadd",
                "atan",
                "fabs",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006070",
            "calling": [
                "atan2"
            ],
            "imported": false,
            "current_name": "calculate_result_08006070"
        },
        "FUN_08004cac": {
            "renaming": {
                "FUN_08004cac": "print_serial_data_08004cac",
                "val": "value",
                "data": "tx_buffer"
            },
            "code": "void print_serial_data_08004cac(int value)\n{\n  undefined *tx_buffer;\n  tx_buffer = PTR_tx_buffer_08004cc4;\n  siprintf(tx_buffer,PTR_DAT_08004cc8,value);\n  serialPrint(tx_buffer);\n  return;\n}",
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004cac",
            "calling": [
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "print_serial_data_08004cac"
        },
        "FUN_08004eee": {
            "renaming": {
                "FUN_08004eee": "do_nothing_08004eee"
            },
            "code": "\nvoid do_nothing_08004eee(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004eee",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004eee"
        },
        "FUN_08004c18": {
            "renaming": {
                "FUN_08004c18": "transmit_byte_to_uart1_08004c18",
                "ch": "byte",
                "*pData": "tx_buffer_ptr",
                "PTR_tx_buffer_08004c28": "tx_buffer_start_ptr",
                "HAL_UART_Transmit": "HAL_UART_Transmit",
                "*PTR_huart1_08004c2c": "huart1_ptr"
            },
            "code": "void transmit_byte_to_uart1_08004c18(uchar byte) {\n  undefined *tx_buffer_ptr;\n  tx_buffer_ptr = PTR_tx_buffer_08004c28;\n  *tx_buffer_ptr = byte;\n  HAL_UART_Transmit((UART_HandleTypeDef *)*PTR_huart1_08004c2c, tx_buffer_ptr, 1, 5);\n  return;\n}",
            "called": [
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c18",
            "calling": [
                "MSP_SendFrame",
                "_Error_Handler",
                "serialPrint"
            ],
            "imported": false,
            "current_name": "transmit_byte_to_uart1_08004c18"
        },
        "FUN_08004c8c": {
            "renaming": {
                "FUN_08004c8c": "send_serial_data_08004c8c",
                "*data": "data",
                "sVar1": "len",
                "*puVar2": "data_ptr",
                "puVar2": "data_ptr",
                "serialWrite": "serialWrite"
            },
            "code": "void send_serial_data_08004c8c(char *data)\n{\n  size_t len = strlen(data);\n  uchar *data_ptr = (uchar *)data;\n\n  for (size_t i = 0; i < len; i++) {\n    serialWrite(*data_ptr);\n    data_ptr++;\n  }\n  return;\n}",
            "called": [
                "strlen",
                "serialWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c8c",
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "send_serial_data_08004c8c"
        },
        "FUN_08001460": {
            "renaming": {
                "FUN_08001460": "check_i2c_flag_08001460",
                "*hi2c": "*i2c_handle",
                "Flag": "flag",
                "Timeout": "timeout",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "uVar3": "sr",
                "*pIVar4": "*i2c_instance"
            },
            "code": "HAL_StatusTypeDef check_i2c_flag_08001460(I2C_HandleTypeDef *i2c_handle, uint32_t flag, uint32_t timeout) {\n  uint32_t start_time = HAL_GetTick();\n  do {\n    I2C_TypeDef *i2c_instance = i2c_handle->Instance;\n    uint32_t sr = ((flag << 8) >> 0x18 == 1) ? i2c_instance->SR1 : i2c_instance->SR2;\n    if ((flag & 0xffff & ~sr) == 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2c_instance->SR1 << 0x15) < 0) {\n      i2c_instance->CR1 |= 0x200;\n      i2c_instance->SR1 &= 0xfffffbff;\n      i2c_handle->ErrorCode = 4;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) || ((timeout != 0 && (HAL_GetTick() - start_time <= timeout))));\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001460",
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "imported": false,
            "current_name": "check_i2c_flag_08001460"
        },
        "FUN_08003fd0": {
            "renaming": {
                "FUN_08003fd0": "set_pwm_value_08003fd0",
                "pwm": "pwm_value",
                "PTR_htim4_08003fd8": "htim4_ptr"
            },
            "code": "void set_pwm_value_08003fd0(int pwm_value)\n{\n    int* PTR_htim4_08003fd8 = *(int*)PTR_htim4_08003fd8;\n    int* pwm_value_ptr = PTR_htim4_08003fd8 + 0x3c;\n    *pwm_value_ptr = pwm_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd0",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_value_08003fd0"
        },
        "FUN_08000134": {
            "renaming": {
                "FUN_08000134": "concatenate_08000134",
                "param_1": "first",
                "param_2": "second",
                "DAT_08000144": "DAT_global_flag",
                "PTR__init_0800014c": "PTR_init_data",
                "PTR_object_8677_08000148": "PTR_object_data"
            },
            "code": "typedef unsigned long long uint64_t;\n\nuint64_t concatenate_08000134(uint64_t *first, uint64_t *second)\n{\n  if (DAT_08000144 != 0) {\n    first = PTR__init_0800014c;\n    second = PTR_object_8677_08000148;\n  }\n  return ((uint64_t)(*second) << 32) | (*first);\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000134",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "concatenate_08000134"
        },
        "FUN_08003eb0": {
            "renaming": {
                "FUN_08003eb0": "execute_afl_call_if_no_hypercall_08003eb0",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_08003ec4": "PTR_noHyperCall_08003ec4",
                "aflCall": "aflCall"
            },
            "code": "uint32_t execute_afl_call_if_no_hypercall_08003eb0(int ticks)\n{\n    uint32_t result;\n    if (*(int *)PTR_noHyperCall_08003ec4 == 0) {\n        result = aflCall(1, ticks, 0);\n        return result;\n    }\n    return 0;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003eb0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_afl_call_if_no_hypercall_08003eb0"
        },
        "FUN_08005c70": {
            "renaming": {
                "FUN_08005c70": "FUNC_08005c70"
            },
            "code": "\nulonglong FUNC_08005c70(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 extraout_r1;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  ulonglong uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined4 in_stack_ffffffc8;\n  \n  uVar9 = CONCAT44(param_2,param_1);\n  uVar8 = param_2 & 0x7fffffff;\n  if (DAT_08005f90 < (int)uVar8) {\n    if ((uVar8 + 0xc0100000 | param_1) != 0) {\n      uVar10 = __subdf3(param_1,param_2,param_1,param_2);\n      uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar9 = __divdf3((int)uVar10,uVar2,(int)uVar10,uVar2);\n      return uVar9;\n    }\n    uVar9 = __muldf3(param_1,param_2,DAT_08005f28,DAT_08005f2c);\n    uVar10 = __muldf3(param_1,param_2,DAT_08005f30,DAT_08005f34);\nLAB_08005cba:\n    uVar9 = __aeabi_dadd((int)uVar9,(int)(uVar9 >> 0x20),(int)uVar10,\n                         (int)((ulonglong)uVar10 >> 0x20));\n  }\n  else {\n    if ((int)uVar8 <= DAT_08005f94) {\n      if (0x3e3fffff < uVar8) {\n        uVar10 = __muldf3(param_1,param_2,param_1,param_2);\n        uVar7 = (undefined4)((ulonglong)uVar10 >> 0x20);\n        uVar2 = (undefined4)uVar10;\n        uVar10 = __muldf3(uVar2,uVar7,DAT_08005f40,DAT_08005f44);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f48,DAT_08005f4c\n                             );\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f50,DAT_08005f54);\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f58,DAT_08005f5c\n                             );\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f60,DAT_08005f64);\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f68,DAT_08005f6c\n                             );\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar11 = __muldf3(uVar2,uVar7,DAT_08005f70,DAT_08005f74);\n        uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f78,DAT_08005f7c);\n        uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar7);\n        uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f80,DAT_08005f84\n                             );\n        uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar7);\n        uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f88,DAT_08005f8c);\n        uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar7);\n        uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),0,DAT_08005f98);\n        uVar10 = __divdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                          (int)((ulonglong)uVar11 >> 0x20));\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),param_1,param_2);\n        goto LAB_08005cba;\n      }\n      uVar10 = __aeabi_dadd(param_1,param_2,DAT_08005f38,DAT_08005f3c);\n      iVar1 = __aeabi_dcmpgt((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08005f98);\n      if (iVar1 != 0) {\n        return uVar9;\n      }\n    }\n    fabs((double)CONCAT44(param_2,in_stack_ffffffc8));\n    uVar10 = __subdf3(0,DAT_08005f98,param_1,extraout_r1);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08005f9c);\n    uVar3 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar2 = (undefined4)uVar10;\n    uVar10 = __muldf3(uVar2,uVar3,DAT_08005f40,DAT_08005f44);\n    uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f48,DAT_08005f4c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f50,DAT_08005f54);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f58,DAT_08005f5c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f60,DAT_08005f64);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f68,DAT_08005f6c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar4 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar11 = __muldf3(uVar2,uVar3,DAT_08005f70,DAT_08005f74);\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f78,DAT_08005f7c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar3);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f80,DAT_08005f84);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar3);\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f88,DAT_08005f8c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar3);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),0,DAT_08005f98);\n    uVar5 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar12 = __ieee754_sqrt(uVar2,uVar3);\n    uVar6 = (undefined4)((ulonglong)uVar12 >> 0x20);\n    uVar7 = (undefined4)uVar12;\n    if (DAT_08005fa0 < (int)uVar8) {\n      uVar10 = __divdf3((int)uVar10,uVar4,(int)uVar11,uVar5);\n      uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar7,uVar6);\n      uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar7,uVar6);\n      uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar10 = __aeabi_dadd((int)uVar10,uVar2,(int)uVar10,uVar2);\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f30,DAT_08005f34);\n      uVar2 = DAT_08005f28;\n      uVar7 = DAT_08005f2c;\n    }\n    else {\n      uVar10 = __divdf3((int)uVar10,uVar4,(int)uVar11,uVar5);\n      uVar11 = __aeabi_dadd(uVar7,uVar6,uVar7,uVar6);\n      uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                        (int)((ulonglong)uVar11 >> 0x20));\n      uVar11 = __muldf3(0,uVar6,0,uVar6);\n      uVar11 = __subdf3(uVar2,uVar3,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n      uVar12 = __aeabi_dadd(uVar7,uVar6,0,uVar6);\n      uVar11 = __divdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar12,\n                        (int)((ulonglong)uVar12 >> 0x20));\n      uVar2 = (undefined4)((ulonglong)uVar11 >> 0x20);\n      uVar11 = __aeabi_dadd((int)uVar11,uVar2,(int)uVar11,uVar2);\n      uVar11 = __subdf3(DAT_08006060,DAT_08006064,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                        (int)((ulonglong)uVar11 >> 0x20));\n      uVar11 = __aeabi_dadd(0,uVar6,0,uVar6);\n      uVar11 = __subdf3(DAT_08006068,DAT_0800606c,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                        (int)((ulonglong)uVar11 >> 0x20));\n      uVar2 = DAT_08006068;\n      uVar7 = DAT_0800606c;\n    }\n    uVar9 = __subdf3(uVar2,uVar7,(int)uVar10,(int)((ulonglong)uVar10 >> 0x20));\n    if ((int)param_2 < 1) {\n      uVar9 = uVar9 & 0xffffffff | (ulonglong)((int)(uVar9 >> 0x20) + 0x80000000) << 0x20;\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "__divdf3",
                "__muldf3",
                "__ieee754_sqrt",
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "fabs",
                "__subdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005c70",
            "calling": [
                "asin"
            ],
            "imported": false,
            "current_name": "FUNC_08005c70"
        },
        "FUN_08002ee8": {
            "renaming": {
                "FUN_08002ee8": "calculate_ahrs_angle_08002ee8",
                "iVar1": "is_greater_than_or_equal_to_threshold",
                "uVar2": "angle",
                "fVar3": "calculated_angle"
            },
            "code": "float calculate_ahrs_angle_08002ee8(void)\n{\n  int is_greater_than_or_equal_to_threshold;\n  undefined4 angle;\n  float calculated_angle;\n  angle = *(undefined4 *)(PTR_AHRS_Angle_08002f18 + 8);\n  is_greater_than_or_equal_to_threshold = __aeabi_fcmpge(angle,DAT_08002f1c);\n  if ((is_greater_than_or_equal_to_threshold != 0) && (__aeabi_fcmplt(angle,DAT_08002f20) != 0)) {\n    calculated_angle = (float)__addsf3(angle,DAT_08002f20);\n    return calculated_angle;\n  }\n  calculated_angle = (float)__aeabi_fsub(angle,DAT_08002f24);\n  return calculated_angle;\n}",
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmpge",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ee8",
            "calling": [
                "AHRS_ComputeAngles",
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_ahrs_angle_08002ee8"
        },
        "FUN_08001104": {
            "renaming": {
                "FUN_08001104": "initialize_systick_08001104",
                "TickPriority": "tick_priority",
                "uVar1": "hclk_freq",
                "SysTick_IRQn": "SysTick_IRQn",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef initialize_systick_08001104(uint32_t tick_priority)\n{\n  uint32_t hclk_freq = HAL_RCC_GetHCLKFreq();\n  uint32_t systick_ticks = hclk_freq / 1000;\n  HAL_SYSTICK_Config(systick_ticks);\n  HAL_NVIC_SetPriority(SysTick_IRQn, tick_priority, 0);\n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001104",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "initialize_systick_08001104"
        },
        "FUN_08004978": {
            "renaming": {
                "FUN_08004978": "initialize_pid_controllers_08004978",
                "PTR_pid_roll_080049e8": "roll_controller",
                "PTR_pid_pitch_080049ec": "pitch_controller",
                "PTR_pid_yaw_080049f0": "yaw_controller",
                "PTR_pid_altitude_080049f4": "altitude_controller",
                "DAT_080049f8": "roll_kp",
                "DAT_08004a10": "roll_ki",
                "DAT_080049fc": "pitch_kp",
                "DAT_08004a08": "pitch_kd",
                "DAT_08004a0c": "yaw_kp",
                "DAT_08004a14": "yaw_ki",
                "DAT_08004a18": "altitude_kp",
                "DAT_08004a1c": "altitude_kd"
            },
            "code": "void initialize_pid_controllers_08004978(void)\n{\n    float *PTR_pid_roll_080049e8 = PTR_pid_roll_080049e8;\n    float *PTR_pid_pitch_080049ec = PTR_pid_pitch_080049ec;\n    float *PTR_pid_yaw_080049f0 = PTR_pid_yaw_080049f0;\n    float *PTR_pid_altitude_080049f4 = PTR_pid_altitude_080049f4;\n\n    *(PTR_pid_roll_080049e8 + 0x4c) = 1;\n    *(PTR_pid_pitch_080049ec + 0x4c) = 1;\n    *(PTR_pid_yaw_080049f0 + 0x4c) = -1;\n    *(PTR_pid_altitude_080049f4 + 0x4c) = 1;\n\n    float DAT_080049f8 = DAT_080049f8;\n    float DAT_08004a10 = DAT_08004a10;\n    float roll_kd = DAT_08004a10;\n    float DAT_080049fc = DAT_080049fc;\n    float pitch_ki = DAT_08004a10;\n    float DAT_08004a08 = DAT_08004a08;\n    float DAT_08004a0c = DAT_08004a0c;\n    float DAT_08004a14 = DAT_08004a14;\n    float yaw_kd = DAT_08004a18;\n    float DAT_08004a18 = DAT_08004a18;\n    float altitude_ki = DAT_08004a10;\n    float DAT_08004a1c = DAT_08004a1c;\n\n    *(PTR_pid_pitch_080049ec + 0x20) = DAT_080049fc;\n    *(PTR_pid_roll_080049e8 + 0x20) = DAT_080049f8;\n    *(PTR_pid_yaw_080049f0 + 0x20) = DAT_08004a0c;\n    *(PTR_pid_altitude_080049f4 + 0x20) = DAT_08004a18;\n\n    *(PTR_pid_roll_080049e8 + 4) = DAT_080049f8;\n    *(PTR_pid_roll_080049e8 + 8) = DAT_08004a10;\n    *(PTR_pid_roll_080049e8 + 0xc) = roll_kd;\n    *(PTR_pid_roll_080049e8 + 0x10) = DAT_080049fc;\n    *(PTR_pid_roll_080049e8 + 0x14) = pitch_ki;\n    *(PTR_pid_roll_080049e8 + 0x18) = DAT_08004a08;\n\n    *(PTR_pid_pitch_080049ec + 4) = DAT_080049fc;\n    *(PTR_pid_pitch_080049ec + 8) = pitch_ki;\n    *(PTR_pid_pitch_080049ec + 0xc) = DAT_08004a08;\n    *(PTR_pid_pitch_080049ec + 0x10) = DAT_080049f8;\n    *(PTR_pid_pitch_080049ec + 0x14) = DAT_08004a10;\n    *(PTR_pid_pitch_080049ec + 0x18) = roll_kd;\n\n    *(PTR_pid_yaw_080049f0 + 4) = DAT_08004a0c;\n    *(PTR_pid_yaw_080049f0 + 8) = DAT_08004a14;\n    *(PTR_pid_yaw_080049f0 + 0xc) = yaw_kd;\n    *(PTR_pid_yaw_080049f0 + 0x10) = 0;\n    *(PTR_pid_yaw_080049f0 + 0x14) = 0;\n    *(PTR_pid_yaw_080049f0 + 0x18) = 0;\n\n    *(PTR_pid_altitude_080049f4 + 4) = DAT_08004a18;\n    *(PTR_pid_altitude_080049f4 + 8) = altitude_ki;\n    *(PTR_pid_altitude_080049f4 + 0xc) = DAT_08004a1c;\n    *(PTR_pid_altitude_080049f4 + 0x10) = 0;\n    *(PTR_pid_altitude_080049f4 + 0x14) = 0;\n    *(PTR_pid_altitude_080049f4 + 0x18) = 0;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004978",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_pid_controllers_08004978"
        },
        "FUN_08000c60": {
            "renaming": {
                "FUN_08000c60": "calculate_hash_08000c60",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "hash_value",
                "uVar2": "shift_amount_1",
                "iVar3": "leading_zero_count",
                "uVar4": "shift_amount_2",
                "iVar5": "mask_1",
                "uVar6": "mask_2"
            },
            "code": "uint calculate_hash_08000c60(uint input_1, uint input_2)\n{\n  uint hash_value;\n  uint shift_amount_1;\n  uint shift_amount_2;\n  uint leading_zero_count;\n  uint mask_1 = 0x5b000000;\n  uint mask_2 = 0x4b000000;\n  \n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  if (input_2 == 0) {\n    hash_value = 0;\n    shift_amount_1 = input_1;\n  }\n  else {\n    hash_value = input_1;\n    shift_amount_1 = input_2;\n  }\n  if (input_2 == 0) {\n    mask_1 = mask_2;\n  }\n  leading_zero_count = count_leading_zeroes(shift_amount_1);\n  shift_amount_2 = leading_zero_count - 8;\n  mask_1 = mask_1 + (-0x800000 + shift_amount_2 * -0x800000);\n  if (leading_zero_count < 8) {\n    shift_amount_2 = shift_amount_1 << (leading_zero_count + 0x18U & 0xff);\n    hash_value = mask_1 + ((shift_amount_1 >> (0x20 - (leading_zero_count + 0x18U) & 0xff)) - ((int)shift_amount_2 >> 0x1f));\n    if ((hash_value | shift_amount_2 << 1) == 0) {\n      hash_value = hash_value & ~(shift_amount_2 >> 0x1f);\n    }\n    return hash_value;\n  }\n  shift_amount_2 = input_1 << (shift_amount_2 & 0xff);\n  hash_value = mask_1 + (shift_amount_1 << (shift_amount_2 & 0xff)) + (input_1 >> (0x20 - shift_amount_2 & 0xff)) + (uint)(0x7fffffff < shift_amount_2);\n  if (shift_amount_2 == 0x80000000) {\n    hash_value = hash_value & 0xfffffffe;\n  }\n  return hash_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c60",
            "calling": [],
            "imported": false,
            "current_name": "calculate_hash_08000c60"
        },
        "FUN_08006d68": {
            "renaming": {
                "FUN_08006d68": "FUNC_08006d68"
            },
            "code": "\ndouble FUNC_08006d68(double __x)\n\n{\n  int in_r0;\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint in_r1;\n  undefined4 extraout_r1;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 in_r3;\n  undefined4 unaff_r4;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  undefined4 *puVar9;\n  double in_d0;\n  double extraout_d0;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  \n  uVar11 = CONCAT44(in_r1,in_r0);\n  uVar8 = in_r1 & 0x7fffffff;\n  if (DAT_08007058 < (int)uVar8) {\n    if (((int)DAT_0800705c < (int)uVar8) || ((uVar8 == DAT_0800705c && (in_r0 != 0)))) {\n      in_d0 = (double)__aeabi_dadd();\n    }\n  }\n  else {\n    if (DAT_08007068 < (int)uVar8) {\n      fabs((double)CONCAT44(unaff_r4,in_r3));\n      if (DAT_08007070 < (int)uVar8) {\n        if (DAT_08007074 < (int)uVar8) {\n          uVar11 = __divdf3(0,DAT_0800707c,in_r0,extraout_r1);\n          iVar1 = 3;\n        }\n        else {\n          uVar11 = __subdf3();\n          uVar10 = __muldf3(in_r0,extraout_r1,0,DAT_08007078);\n          uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_0800706c);\n          uVar11 = __divdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar10,\n                            (int)((ulonglong)uVar10 >> 0x20));\n          iVar1 = 2;\n        }\n      }\n      else if (DAT_08007070 + -0xd0000 < (int)uVar8) {\n        uVar11 = __subdf3();\n        uVar10 = __aeabi_dadd(in_r0,extraout_r1,0,DAT_0800706c);\n        uVar11 = __divdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar10,\n                          (int)((ulonglong)uVar10 >> 0x20));\n        iVar1 = 1;\n      }\n      else {\n        uVar11 = __aeabi_dadd();\n        uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),0,DAT_0800706c);\n        uVar10 = __aeabi_dadd(in_r0,extraout_r1,0,0x40000000);\n        uVar11 = __divdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar10,\n                          (int)((ulonglong)uVar10 >> 0x20));\n        iVar1 = 0;\n      }\n    }\n    else {\n      if ((int)uVar8 <= DAT_08007068 + -0x1bc0000) {\n        uVar10 = __aeabi_dadd(in_r0,in_r1,DAT_08006ff8,DAT_08006ffc);\n        iVar1 = __aeabi_dcmpgt((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_0800706c);\n        if (iVar1 != 0) {\n          return extraout_d0;\n        }\n      }\n      iVar1 = -1;\n    }\n    uVar7 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar6 = (undefined4)uVar11;\n    uVar11 = __muldf3(uVar6,uVar7,uVar6,uVar7);\n    uVar4 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar2 = (undefined4)uVar11;\n    uVar11 = __muldf3(uVar2,uVar4,uVar2,uVar4);\n    uVar5 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar3 = (undefined4)uVar11;\n    uVar11 = __muldf3(uVar3,uVar5,DAT_08007000,DAT_08007004);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08007008,DAT_0800700c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar3,uVar5);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08007010,DAT_08007014);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar3,uVar5);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08007018,DAT_0800701c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar3,uVar5);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08007020,DAT_08007024);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar3,uVar5);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08007028,DAT_0800702c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar4);\n    uVar2 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar10 = __muldf3(uVar3,uVar5,DAT_08007030,DAT_08007034);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08007038,DAT_0800703c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08007040,DAT_08007044);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08007048,DAT_0800704c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08007050,DAT_08007054);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar3 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    if (iVar1 == -1) {\n      uVar11 = __aeabi_dadd((int)uVar11,uVar2,(int)uVar10,uVar3);\n      uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar6,uVar7);\n      in_d0 = (double)__subdf3(uVar6,uVar7,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n    }\n    else {\n      uVar11 = __aeabi_dadd((int)uVar11,uVar2,(int)uVar10,uVar3);\n      uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar6,uVar7);\n      puVar9 = (undefined4 *)(PTR_FUNC_08006d68hi_08007080 + iVar1 * 8);\n      uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),\n                        *(undefined4 *)(PTR_FUNC_08006d68lo_08007084 + iVar1 * 8),\n                        *(undefined4 *)((int)(PTR_FUNC_08006d68lo_08007084 + iVar1 * 8) + 4));\n      uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar6,uVar7);\n      in_d0 = (double)__subdf3(*puVar9,puVar9[1],(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n    }\n  }\n  return in_d0;\n}\n\n",
            "called": [
                "__divdf3",
                "__muldf3",
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "fabs",
                "__subdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08006d68",
            "calling": [
                "__ieee754_atan2"
            ],
            "imported": false,
            "current_name": "FUNC_08006d68"
        },
        "FUN_08004f04": {
            "renaming": {
                "FUN_08004f04": "handle_uart_interrupt_08004f04",
                "PTR_huart1_08004f0c": "&huart1"
            },
            "code": "void handle_uart_interrupt_08004f04(void)\n{\n  HAL_UART_IRQHandler(PTR_huart1_08004f0c);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f04",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_08004f04"
        },
        "FUN_080072b8": {
            "renaming": {
                "FUN_080072b8": "allocate_memory_080072b8",
                "__delta": "delta",
                "puVar1": "heap_end",
                "pvVar2": "allocated_memory"
            },
            "code": "void * allocate_memory_080072b8(intptr_t delta)\n{\n  undefined *heap_end = PTR_heap_end_4116_080072cc;\n  if (*(int *)PTR_heap_end_4116_080072cc == 0) {\n    *(undefined **)PTR_heap_end_4116_080072cc = PTR__ebss_080072d0;\n  }\n  void *allocated_memory = *(void **)heap_end;\n  *(intptr_t *)heap_end = delta + (int)allocated_memory;\n  return allocated_memory;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072b8",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080072b8"
        },
        "FUN_0800581c": {
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "error_ptr",
                "pvVar2": "memory_ptr"
            },
            "code": "void allocate_memory_0800581c(int *error_code, intptr_t size) {\n  undefined *error_ptr;\n  void *memory_ptr;\n  error_ptr = PTR_errno_08005838;\n  *(undefined4 *)PTR_errno_08005838 = 0;\n  memory_ptr = _sbrk(size);\n  if ((memory_ptr == (void *)0xffffffff) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800581c",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_0800581c"
        },
        "FUN_08003eac": {
            "renaming": {
                "FUN_08003eac": "process_data_08003eac",
                "a0": "input_data",
                "a1": "control_signal",
                "a2": "interrupt_flag"
            },
            "code": "uint32_t process_data_08003eac(uint32_t input_data, uint32_t control_signal, int32_t interrupt_flag)\n{\n  software_interrupt(0x3f);\n  return input_data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003eac",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "process_data_08003eac"
        },
        "FUN_080072ac": {
            "renaming": {
                "FUN_080072ac": "get_impure_ptr_value_080072ac",
                "PTR__impure_ptr_080072b4": "PTR__impure_ptr_080072b4",
                "undefined4": "int",
                "*": "*",
                "impure_ptr": "impure_ptr",
                "return": "return",
                ";": ";",
                "(": "(",
                ")": ")",
                "int*": "int*",
                "**": "**",
                "": ""
            },
            "code": "int get_impure_ptr_value_080072ac(void)\n{\n    int* impure_ptr = *(int**)PTR__impure_ptr_080072b4;\n    return *impure_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072ac",
            "calling": [
                "asin",
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "get_impure_ptr_value_080072ac"
        },
        "FUN_08000ad0": {
            "renaming": {
                "FUN_08000ad0": "FUNC_08000ad0"
            },
            "code": "\nuint FUNC_08000ad0(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  int iVar7;\n  bool bVar8;\n  \n  uVar2 = param_1 ^ 0x80000000;\n  uVar4 = param_1 << 1;\n  bVar8 = uVar4 == 0;\n  if (!bVar8) {\n    param_4 = param_2 << 1;\n    bVar8 = param_4 == 0;\n  }\n  if (!bVar8) {\n    bVar8 = uVar4 == param_4;\n  }\n  iVar7 = (int)uVar4 >> 0x18;\n  if (!bVar8) {\n    bVar8 = iVar7 == -1;\n  }\n  if (!bVar8) {\n    bVar8 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar8) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar7 == -1 || iVar1 == -1) {\n      uVar4 = param_2;\n      if (iVar7 == -1) {\n        uVar4 = uVar2;\n      }\n      if (iVar7 != -1 || iVar1 != -1) {\n        param_2 = uVar4;\n      }\n      bVar8 = (uVar4 & 0x7fffff) == 0;\n      if (bVar8) {\n        bVar8 = (param_2 & 0x7fffff) == 0;\n      }\n      if (bVar8) {\n        bVar8 = uVar4 == param_2;\n      }\n      if (!bVar8) {\n        uVar4 = uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ param_2) & 0x7fffffff) != 0) {\n      if (uVar4 == 0) {\n        uVar2 = param_2;\n      }\n      return uVar2;\n    }\n    if (uVar2 != param_2) {\n      return 0;\n    }\n    if ((uVar4 & 0xff000000) == 0) {\n      param_1 = param_1 << 1;\n      if ((uVar2 & 0x80000000) != 0) {\n        param_1 = param_1 | 0x80000000;\n      }\n      return param_1;\n    }\n    if (uVar4 < 0xfe000000) {\n      return uVar2 + 0x800000;\n    }\n    uVar2 = uVar2 & 0x80000000;\nLAB_08000c12:\n    return uVar2 | 0x7f800000;\n  }\n  uVar4 = uVar4 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar6 = param_4 - uVar4;\n  bVar8 = uVar6 != 0;\n  uVar5 = uVar4;\n  if (bVar8 && uVar4 <= param_4) {\n    uVar5 = uVar4 + uVar6;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_2 = param_2 ^ uVar2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_2 = param_2 ^ uVar2;\n  }\n  if (param_4 < uVar4) {\n    uVar6 = -uVar6;\n  }\n  if (0x19 < uVar6) {\n    return uVar2;\n  }\n  uVar4 = uVar2 & 0xffffff | 0x800000;\n  if ((uVar2 & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  uVar3 = param_2 & 0xffffff | 0x800000;\n  if ((param_2 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  if (uVar5 == uVar6) {\n    uVar3 = uVar3 ^ 0x800000;\n    if (uVar5 == 0) {\n      uVar4 = uVar4 ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      uVar6 = uVar6 - 1;\n    }\n  }\n  uVar4 = uVar4 + ((int)uVar3 >> (uVar6 & 0xff));\n  uVar3 = uVar3 << (0x20 - uVar6 & 0xff);\n  uVar2 = uVar4 & 0x80000000;\n  if ((int)uVar4 < 0) {\n    bVar8 = uVar3 != 0;\n    uVar3 = -uVar3;\n    uVar4 = -uVar4 - (uint)bVar8;\n  }\n  if (uVar4 < 0x800000) {\n    uVar6 = uVar3 & 0x80000000;\n    uVar3 = uVar3 << 1;\n    uVar4 = uVar4 * 2 + (uint)(uVar6 != 0);\n    uVar6 = uVar5 - 2;\n    if ((uVar4 & 0x800000) == 0) {\n      iVar7 = count_leading_zeroes(uVar4);\n      uVar5 = iVar7 - 8;\n      uVar4 = uVar4 << (uVar5 & 0xff);\n      if ((int)uVar6 < (int)uVar5) {\n        uVar4 = uVar4 >> (-(uVar6 - uVar5) & 0xff);\n      }\n      else {\n        uVar4 = uVar4 + (uVar6 - uVar5) * 0x800000;\n      }\n      return uVar4 | uVar2;\n    }\n  }\n  else {\n    uVar6 = uVar5 - 1;\n    if (0xffffff < uVar4) {\n      uVar6 = uVar4 & 1;\n      uVar4 = uVar4 >> 1;\n      uVar3 = (uint)(uVar6 != 0) << 0x1f | uVar3 >> 1;\n      uVar6 = uVar5;\n      if (0xfd < uVar5) goto LAB_08000c12;\n    }\n  }\n  uVar4 = uVar4 + uVar6 * 0x800000 + (uint)(0x7fffffff < uVar3);\n  if (uVar3 == 0x80000000) {\n    uVar4 = uVar4 & 0xfffffffe;\n  }\n  return uVar4 | uVar2;\n}\n\n",
            "called": [
                "__addsf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ad0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08000ad0"
        },
        "FUN_08002cb0": {
            "renaming": {
                "FUN_08002cb0": "read_mpu9250_data_08002cb0",
                "in_r3": "raw_data",
                "puVar1": "pointer_to_mag_calib",
                "uVar2": "temp_float",
                "_rawData": "raw_data_uint",
                "rawData": "raw_data_array",
                "magCalib_08002d84": "mag_calibration"
            },
            "code": "void read_mpu9250_data_08002cb0(void)\n{\n  uint8_t rawData[3];\n  uint8_t mpu9250_address = 0xD0;\n  uint8_t ak8963_address = 0x18;\n  uint8_t ak8963_st1;\n  float mag_calibration[3];\n\n  I2C_WriteByte(mpu9250_address, 0x37, '\"', '\\x01');\n  I2C_WriteByte(mpu9250_address, 0x6A, '\\x01', '\\x01');\n\n  I2C_ReadByte(ak8963_address, 0x02, &ak8963_st1, 0x01);\n\n  if(ak8963_st1 & 0x01) {\n    I2C_ReadByteArray(ak8963_address, 0x03, rawData, 0x03);\n    mag_calibration[0] = ((float)rawData[0] - 128.0f) / 256.0f + 1.0f;\n    mag_calibration[1] = ((float)rawData[1] - 128.0f) / 256.0f + 1.0f;\n    mag_calibration[2] = ((float)rawData[2] - 128.0f) / 256.0f + 1.0f;\n  }\n\n  I2C_WriteByte(ak8963_address, 0x0B, '\\x01', '\\x01');\n  I2C_WriteByte(ak8963_address, 0x0A, '\\x0F', '\\x01');\n}",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "__addsf3",
                "I2C_ReadByteArray",
                "I2C_WriteByte",
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb0",
            "calling": [
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "read_mpu9250_data_08002cb0"
        },
        "FUN_08002324": {
            "renaming": {
                "FUN_08002324": "set_timer_output_compare_08002324",
                "TIMx": "timer",
                "OC_Config": "config",
                "uVar1": "cr2_value",
                "uVar2": "oc_mode",
                "uVar3": "oc_polarity",
                "pTVar4": "timer_idle_state"
            },
            "code": "void set_timer_output_compare_08002324(TIM_TypeDef *timer, TIM_OC_InitTypeDef *config)\n{\n  uint32_t cr2_value = timer->CR2;\n  uint32_t oc_mode = config->OCMode;\n  uint32_t oc_polarity = config->OCPolarity;\n  TIM_TypeDef *timer_idle_state = DAT_08002364;\n  if (timer == DAT_08002364) {\n    timer_idle_state = (TIM_TypeDef *)config->OCIdleState;\n    cr2_value &= 0xffffbfff;\n  }\n  if (timer == DAT_08002364) {\n    cr2_value |= (int)timer_idle_state << 6;\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR2 = (timer->CCMR2 & 0xffff8cff) | (oc_mode << 8);\n  timer->CCR4 = config->Pulse;\n  timer->CCER = (timer->CCER & 0xffffdfff) | (oc_polarity << 0xc);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002324",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "set_timer_output_compare_08002324"
        },
        "FUN_08002564": {
            "renaming": {
                "FUN_08002564": "set_break_dead_time_config_08002564",
                "htim": "timer_handle",
                "sBreakDeadTimeConfig": "break_dead_time_config",
                "HVar1": "status",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_UNLOCKED": "HAL_UNLOCKED"
            },
            "code": "HAL_StatusTypeDef set_break_dead_time_config_08002564(TIM_HandleTypeDef *timer_handle, TIM_BreakDeadTimeConfigTypeDef *break_dead_time_config)\n{\n  HAL_StatusTypeDef status = HAL_BUSY;\n  if (timer_handle->Lock != HAL_LOCKED) {\n    timer_handle->State = HAL_TIM_STATE_BUSY;\n    timer_handle->Instance->BDTR =\n         break_dead_time_config->OffStateRunMode | break_dead_time_config->OffStateIDLEMode |\n         break_dead_time_config->LockLevel | break_dead_time_config->DeadTime |\n         break_dead_time_config->BreakState | break_dead_time_config->BreakPolarity |\n         break_dead_time_config->AutomaticOutput;\n    timer_handle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002564",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "set_break_dead_time_config_08002564"
        },
        "FUN_08004fb0": {
            "renaming": {
                "FUN_08004fb0": "infinite_loop_08004fb0"
            },
            "code": "void infinite_loop_08004fb0() {\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004fb0",
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08004fb0"
        },
        "FUN_08000ad8": {
            "renaming": {
                "FUN_08000ad8": "FUNC_08000ad8"
            },
            "code": "\nuint FUNC_08000ad8(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  int iVar7;\n  bool bVar8;\n  \n  uVar2 = param_2 ^ 0x80000000;\n  uVar4 = param_1 << 1;\n  bVar8 = uVar4 == 0;\n  if (!bVar8) {\n    param_4 = param_2 << 1;\n    bVar8 = param_4 == 0;\n  }\n  if (!bVar8) {\n    bVar8 = uVar4 == param_4;\n  }\n  iVar7 = (int)uVar4 >> 0x18;\n  if (!bVar8) {\n    bVar8 = iVar7 == -1;\n  }\n  if (!bVar8) {\n    bVar8 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar8) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar7 == -1 || iVar1 == -1) {\n      uVar4 = uVar2;\n      if (iVar7 == -1) {\n        uVar4 = param_1;\n      }\n      if (iVar7 != -1 || iVar1 != -1) {\n        uVar2 = uVar4;\n      }\n      bVar8 = (uVar4 & 0x7fffff) == 0;\n      if (bVar8) {\n        bVar8 = (uVar2 & 0x7fffff) == 0;\n      }\n      if (bVar8) {\n        bVar8 = uVar4 == uVar2;\n      }\n      if (!bVar8) {\n        uVar4 = uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ uVar2) & 0x7fffffff) != 0) {\n      if (uVar4 == 0) {\n        param_1 = uVar2;\n      }\n      return param_1;\n    }\n    if (param_1 != uVar2) {\n      return 0;\n    }\n    if ((uVar4 & 0xff000000) == 0) {\n      uVar2 = param_1 << 1;\n      if ((param_1 & 0x80000000) != 0) {\n        uVar2 = uVar2 | 0x80000000;\n      }\n      return uVar2;\n    }\n    if (uVar4 < 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 = param_1 & 0x80000000;\nLAB_08000c12:\n    return param_1 | 0x7f800000;\n  }\n  uVar4 = uVar4 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar6 = param_4 - uVar4;\n  bVar8 = uVar6 != 0;\n  uVar5 = uVar4;\n  if (bVar8 && uVar4 <= param_4) {\n    uVar5 = uVar4 + uVar6;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_1;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_1 = param_1 ^ uVar2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_1;\n  }\n  if (param_4 < uVar4) {\n    uVar6 = -uVar6;\n  }\n  if (0x19 < uVar6) {\n    return param_1;\n  }\n  uVar4 = param_1 & 0xffffff | 0x800000;\n  if ((param_1 & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  uVar3 = uVar2 & 0xffffff | 0x800000;\n  if ((uVar2 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  if (uVar5 == uVar6) {\n    uVar3 = uVar3 ^ 0x800000;\n    if (uVar5 == 0) {\n      uVar4 = uVar4 ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      uVar6 = uVar6 - 1;\n    }\n  }\n  uVar4 = uVar4 + ((int)uVar3 >> (uVar6 & 0xff));\n  uVar3 = uVar3 << (0x20 - uVar6 & 0xff);\n  param_1 = uVar4 & 0x80000000;\n  if ((int)uVar4 < 0) {\n    bVar8 = uVar3 != 0;\n    uVar3 = -uVar3;\n    uVar4 = -uVar4 - (uint)bVar8;\n  }\n  if (uVar4 < 0x800000) {\n    uVar2 = uVar3 & 0x80000000;\n    uVar3 = uVar3 << 1;\n    uVar4 = uVar4 * 2 + (uint)(uVar2 != 0);\n    uVar2 = uVar5 - 2;\n    if ((uVar4 & 0x800000) == 0) {\n      iVar7 = count_leading_zeroes(uVar4);\n      uVar6 = iVar7 - 8;\n      uVar4 = uVar4 << (uVar6 & 0xff);\n      if ((int)uVar2 < (int)uVar6) {\n        uVar4 = uVar4 >> (-(uVar2 - uVar6) & 0xff);\n      }\n      else {\n        uVar4 = uVar4 + (uVar2 - uVar6) * 0x800000;\n      }\n      return uVar4 | param_1;\n    }\n  }\n  else {\n    uVar2 = uVar5 - 1;\n    if (0xffffff < uVar4) {\n      uVar2 = uVar4 & 1;\n      uVar4 = uVar4 >> 1;\n      uVar3 = (uint)(uVar2 != 0) << 0x1f | uVar3 >> 1;\n      uVar2 = uVar5;\n      if (0xfd < uVar5) goto LAB_08000c12;\n    }\n  }\n  uVar4 = uVar4 + uVar2 * 0x800000 + (uint)(0x7fffffff < uVar3);\n  if (uVar3 == 0x80000000) {\n    uVar4 = uVar4 & 0xfffffffe;\n  }\n  return uVar4 | param_1;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ad8",
            "calling": [
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "Motor_DistributeSpeed",
                "AHRS_GetYaw",
                "MPU9250_ReadGyroData",
                "lowPassFilter",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "FUNC_08000ad8"
        },
        "FUN_08003ec8": {
            "renaming": {
                "FUN_08003ec8": "append_to_circular_buffer_08003ec8",
                "cb": "circular_buffer",
                "data": "data",
                "size": "size",
                "buffer": "buffer",
                "tail": "tail"
            },
            "code": "int append_to_circular_buffer_08003ec8(CircularBuffer *circular_buffer, uint8_t data) {\n    circular_buffer->size++;\n    circular_buffer->buffer[circular_buffer->tail] = data;\n    circular_buffer->tail = (circular_buffer->tail + 1) & 0x7ff;\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ec8",
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "append_to_circular_buffer_08003ec8"
        },
        "FUN_08003fe8": {
            "renaming": {
                "FUN_08003fe8": "set_pwm_value_08003fe8",
                "pwm": "pwm_value",
                "PTR_htim3_08003ff0": "tim3_ptr"
            },
            "code": "void set_pwm_value_08003fe8(int pwm_value) {\n    int *PTR_htim3_08003ff0 = (int *)PTR_htim3_08003ff0;\n    int *tim3_3c_ptr = (int *)(*PTR_htim3_08003ff0 + 0x3c);\n    *tim3_3c_ptr = pwm_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fe8",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_value_08003fe8"
        },
        "FUN_08005714": {
            "renaming": {
                "FUN_08005714": "allocate_memory_block_08005714",
                "param_1": "allocation_status",
                "param_2": "size",
                "puVar1": "memory_block_start",
                "uVar2": "allocation_result",
                "puVar3": "free_block_ptr",
                "iVar4": "remaining_block_size",
                "puVar5": "previous_free_block_ptr",
                "uVar6": "block_size",
                "puVar7": "new_free_block_ptr"
            },
            "code": "uint allocate_memory_block_08005714(undefined4 *allocation_status, uint size) {\n  undefined *memory_block_start;\n  undefined4 allocation_result;\n  uint *free_block_ptr;\n  int remaining_block_size;\n  uint *previous_free_block_ptr;\n  uint block_size;\n  uint *new_free_block_ptr;\n  \n  block_size = (size + 3 & 0xfffffffc) + 8;\n  if (block_size < 0xc) {\n    block_size = 0xc;\n  }\n  if (((int)block_size < 0) || (block_size < size)) {\n    *allocation_status = 0xc;\n  }\n  else {\n    __malloc_lock();\n    memory_block_start = PTR___malloc_sbrk_start_080057cc;\n    free_block_ptr = *(uint **)PTR___malloc_free_list_080057c8;\n    previous_free_block_ptr = *(uint **)PTR___malloc_free_list_080057c8;\n    while (new_free_block_ptr = free_block_ptr, new_free_block_ptr != (uint *)0x0) {\n      remaining_block_size = *new_free_block_ptr - block_size;\n      if (-1 < remaining_block_size) {\n        if (remaining_block_size < 0xc) {\n          if (previous_free_block_ptr == new_free_block_ptr) {\n            block_size = previous_free_block_ptr[1];\n            *(uint *)PTR___malloc_free_list_080057c8 = block_size;\n          }\n          else {\n            block_size = new_free_block_ptr[1];\n          }\n          if (previous_free_block_ptr != new_free_block_ptr) {\n            previous_free_block_ptr[1] = block_size;\n            previous_free_block_ptr = new_free_block_ptr;\n          }\n        }\n        else {\n          *new_free_block_ptr = remaining_block_size;\n          *(uint *)((int)new_free_block_ptr + remaining_block_size) = block_size;\n          previous_free_block_ptr = (uint *)((int)new_free_block_ptr + remaining_block_size);\n        }\n        goto LAB_08005778;\n      }\n      previous_free_block_ptr = new_free_block_ptr;\n      free_block_ptr = (uint *)new_free_block_ptr[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_080057cc == 0) {\n      allocation_result = _sbrk_r(allocation_status);\n      *(undefined4 *)memory_block_start = allocation_result;\n    }\n    free_block_ptr = (uint *)_sbrk_r(allocation_status, block_size);\n    if ((free_block_ptr != (uint *)0xffffffff) &&\n       ((previous_free_block_ptr = (uint *)((int)free_block_ptr + 3U & 0xfffffffc), free_block_ptr == previous_free_block_ptr ||\n        (remaining_block_size = _sbrk_r(allocation_status,(int)previous_free_block_ptr - (int)free_block_ptr), remaining_block_size != -1)))) {\n      *previous_free_block_ptr = block_size;\nLAB_08005778:\n      __malloc_unlock(allocation_status);\n      block_size = (int)previous_free_block_ptr + 0xbU & 0xfffffff8;\n      remaining_block_size = block_size - (int)(previous_free_block_ptr + 1);\n      if (remaining_block_size != 0) {\n        *(int *)((int)previous_free_block_ptr + remaining_block_size) = -remaining_block_size;\n        return block_size;\n      }\n      return block_size;\n    }\n    *allocation_status = 0xc;\n    __malloc_unlock(allocation_status);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005714",
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08005714"
        },
        "FUN_08004fb4": {
            "renaming": {
                "FUN_08004fb4": "initialize_EVP_PKEY_CTX_08004fb4",
                "param_1": "ctx",
                "puVar1": "init_array_entry",
                "iVar2": "init_array_size",
                "iVar3": "i",
                "_init": "_initialize",
                "PTR___frame_dummy_init_array_entry_08004ff4": "fini_array_entry",
                "PTR___do_global_dtors_aux_fini_array_entry_08004ff8": "fini_array_size"
            },
            "code": "void initialize_EVP_PKEY_CTX_08004fb4(EVP_PKEY_CTX *ctx)\n{\n  void **init_array_entry = PTR___frame_dummy_init_array_entry_08004fec;\n  int init_array_size = (int)PTR___frame_dummy_init_array_entry_08004ff0 - (int)PTR___frame_dummy_init_array_entry_08004fec;\n  for (int i = 0; i < init_array_size >> 2; i++) {\n    ctx = (EVP_PKEY_CTX *)(**(void (**)(void))(init_array_entry + i * 4))();\n  }\n  _init(ctx);\n  void **PTR___frame_dummy_init_array_entry_08004ff4 = PTR___frame_dummy_init_array_entry_08004ff4;\n  int PTR___do_global_dtors_aux_fini_array_entry_08004ff8 = (int)PTR___do_global_dtors_aux_PTR___frame_dummy_init_array_entry_08004ff4_08004ff8 - (int)PTR___frame_dummy_init_array_entry_08004ff4;\n  for (int i = 0; i < PTR___do_global_dtors_aux_fini_array_entry_08004ff8 >> 2; i++) {\n    (**(void (**)(void))(PTR___frame_dummy_init_array_entry_08004ff4 + i * 4))();\n  }\n}",
            "called": [
                "frame_dummy",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004fb4",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08004fb4"
        },
        "FUN_080009dc": {
            "renaming": {
                "FUN_080009dc": "check_if_not_greater_than_or_equal_to_zero_080009dc",
                "in_CY": "is_CY_zero",
                "in_ZR": "is_ZR"
            },
            "code": "bool check_if_not_greater_than_or_equal_to_zero_080009dc(void)\n{\n    bool is_CY_zero = __aeabi_cdrcmple();\n    return is_CY_zero || !is_ZR;\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009dc",
            "calling": [],
            "imported": false,
            "current_name": "check_if_not_greater_than_or_equal_to_zero_080009dc"
        },
        "FUN_08000c70": {
            "renaming": {
                "FUN_08000c70": "calculate_twos_complement_08000c70",
                "param_1": "number_1",
                "param_2": "number_2",
                "uVar1": "result",
                "uVar2": "number_1",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount",
                "uVar5": "sign_bit",
                "iVar6": "shifted_sign_bit",
                "uVar7": "shifted_number_1",
                "bVar8": "is_negative"
            },
            "code": "uint calculate_twos_complement_08000c70(uint number_1, uint number_2) {\n  uint sign_bit;\n  uint leading_zeroes;\n  uint shift_amount;\n  uint result;\n  bool is_negative;\n  \n  if ((number_1 | number_2) == 0) {\n    return number_1;\n  }\n  sign_bit = number_2 & 0x80000000;\n  if ((int)sign_bit < 0) {\n    is_negative = number_1 != 0;\n    number_1 = -number_1;\n    number_2 = -number_2 - (uint)is_negative;\n  }\n  result = number_1;\n  if (number_2 == 0) {\n    result = 0;\n    number_2 = number_1;\n  }\n  sign_bit = sign_bit | 0x5b000000;\n  if (number_2 == 0) {\n    sign_bit = sign_bit + 0xf0000000;\n  }\n  leading_zeroes = count_leading_zeroes(number_2);\n  shift_amount = leading_zeroes - 8;\n  result = (sign_bit - 0x800000) + shift_amount * -0x800000;\n  if (leading_zeroes < 8) {\n    shift_amount = number_2 << (leading_zeroes + 0x18U & 0xff);\n    result = result + ((number_2 >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((result | shift_amount << 1) == 0) {\n      result = result & ~(shift_amount >> 0x1f);\n    }\n    return result;\n  }\n  uint shifted_number_1 = number_1 << (shift_amount & 0xff);\n  result = result + (number_2 << (shift_amount & 0xff)) + (number_1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shifted_number_1);\n  if (shifted_number_1 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c70",
            "calling": [],
            "imported": false,
            "current_name": "calculate_twos_complement_08000c70"
        },
        "FUN_080023d0": {
            "renaming": {
                "FUN_080023d0": "set_timer_config_080023d0",
                "htim": "timer_handle",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspInit": "HAL_TIM_PWM_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef set_timer_config_080023d0(TIM_HandleTypeDef *timer_handle)\n{\n    if (timer_handle != NULL)\n    {\n        if (timer_handle->State == HAL_TIM_STATE_RESET)\n        {\n            timer_handle->Lock = HAL_UNLOCKED;\n            HAL_TIM_PWM_MspInit(timer_handle);\n        }\n        timer_handle->State = HAL_TIM_STATE_BUSY;\n        TIM_Base_SetConfig(timer_handle->Instance, &(timer_handle->Init));\n        timer_handle->State = HAL_TIM_STATE_READY;\n        return HAL_OK;\n    }\n    return HAL_ERROR;\n}",
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080023d0",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "set_timer_config_080023d0"
        },
        "FUN_08000a30": {
            "renaming": {
                "FUN_08000a30": "calculate_float_bits_08000a30",
                "param_1": "float_bits",
                "param_2": "float_bits2",
                "uVar1": "exponent_bits",
                "uVar2": "mantissa_bits",
                "uVar3": "is_special_case",
                "in_r12": "temp",
                "bVar4": "is_mantissa_negative",
                "bVar5": "is_special_case_2"
            },
            "code": "uint calculate_float_bits_08000a30(uint float_bits, uint float_bits2)\n{\n  uint mantissa_bits;\n  uint exponent_bits;\n  uint is_mantissa_negative;\n  uint is_special_case;\n  \n  mantissa_bits = float_bits2 * 2;\n  is_special_case = mantissa_bits < 0x70000000;\n  exponent_bits = mantissa_bits + 0x90000000;\n  if (!is_special_case) {\n    mantissa_bits += 0x8fe00000;\n    exponent_bits = mantissa_bits;\n  }\n  is_mantissa_negative = exponent_bits == 0;\n  if (!is_special_case && exponent_bits >= 0x200000) {\n    is_mantissa_negative = mantissa_bits == 0x1fc00000;\n  }\n  if (((is_special_case || exponent_bits < 0x200000) || 0x1fc00000 < mantissa_bits) || is_mantissa_negative) {\n    if ((float_bits2 & 0x40000000) != 0) {\n      if (((int)mantissa_bits >> 0x15 == -1) && ((float_bits | float_bits2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return float_bits2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(mantissa_bits + 0x92e00000) < 0 != SCARRY4(exponent_bits,0x2e00000)) {\n      return float_bits2 & 0x80000000;\n    }\n    mantissa_bits = 0x18 - (mantissa_bits + 0x92e00000 >> 0x15);\n    exponent_bits = float_bits >> (mantissa_bits & 0xff);\n    if (float_bits << (0x20 - mantissa_bits & 0xff) != 0) {\n      exponent_bits |= 1;\n    }\n    is_special_case = float_bits2 & 0x1fffff | 0x100000;\n    float_bits = exponent_bits | is_special_case << (0x20 - mantissa_bits & 0xff);\n    is_special_case = (is_special_case >> (mantissa_bits & 0xff)) << 1;\n  }\n  exponent_bits = (float_bits2 & 0x80000000 | exponent_bits >> 0x1d) + is_special_case * 4 + (uint)(0x7fffffff < exponent_bits * 8);\n  if (exponent_bits * 8 == 0x80000000) {\n    exponent_bits &= 0xfffffffe;\n  }\n  return exponent_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a30",
            "calling": [
                "MS5611_Update",
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_float_bits_08000a30"
        },
        "FUN_08003fdc": {
            "renaming": {
                "FUN_08003fdc": "set_pwm_value_08003fdc",
                "pwm": "pwm_value",
                "PTR_htim2_08003fe4": "htim2_ptr",
                "*(int *)(*(int *)PTR_htim2_08003fe4 + 0x38)": "pwm_register_ptr",
                "*(int *)PTR_htim2_08003fe4": "htim2_ptr_value"
            },
            "code": "void set_pwm_value_08003fdc(int pwm_value) {\n  int* PTR_htim2_08003fe4 = *(int*)PTR_htim2_08003fe4;\n  int* *(int *)(*(int *)PTR_htim2_08003fe4 + 0x38) = PTR_htim2_08003fe4 + 0x38;\n  **(int *)(*(int *)PTR_htim2_08003fe4 + 0x38) = pwm_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fdc",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_value_08003fdc"
        },
        "FUN_080009f0": {
            "renaming": {
                "FUN_080009f0": "is_end_of_string_080009f0",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_080009f0(void)\n{\n  char current_char;\n  __aeabi_cdrcmple();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009f0",
            "calling": [
                "asin",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "is_end_of_string_080009f0"
        },
        "FUN_08004f10": {
            "renaming": {
                "FUN_08004f10": "update_data_08004f10",
                "puVar1": "data_ptr",
                "DAT_08004f50": "PTR_DATA_START",
                "DAT_08004f54": "PTR_DATA_MASK1",
                "DAT_08004f58": "PTR_DATA_START2"
            },
            "code": "void update_data_08004f10(void)\n{\n  uint *data_ptr;\n  data_ptr = DAT_08004f50;\n  *DAT_08004f50 |= 1;\n  data_ptr[1] &= DAT_08004f54;\n  *data_ptr &= PTR_DATA_MASK2;\n  *data_ptr &= PTR_DATA_MASK3;\n  data_ptr[1] &= PTR_DATA_MASK4;\n  data_ptr[2] = 0x9f0000;\n  *(undefined4 *)(DAT_08004f58 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f10",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "update_data_08004f10"
        },
        "FUN_08005044": {
            "renaming": {
                "FUN_08005044": "resize_buffer_08005044",
                "param_1": "error_code",
                "param_2": "buffer",
                "param_3": "current_end",
                "param_4": "new_end",
                "pvVar1": "new_buffer",
                "pvVar2": "old_buffer_end",
                "__n": "buffer_size"
            },
            "code": "unsigned int resize_buffer_08005044(unsigned int *error_code, void **buffer, void *current_end, void *new_end)\n{\n    void *old_buffer_end = (*buffer)[2];\n    if ((old_buffer_end <= new_end) && ((*(unsigned short *)(*buffer + 6) & 0x480) != 0)) {\n        size_t buffer_size = (int)*buffer - (int)(*buffer)[8];\n        void *new_buffer_end = (void *)((int)new_end + buffer_size + 1);\n        if ((void *)((int)(*buffer)[10] * 3 / 2) < new_buffer_end) {\n            new_buffer_end = (void *)((int)(*buffer)[10] * 3 / 2);\n        }\n        if ((int)((unsigned int)*(unsigned short *)(*buffer + 6) << 0x15) < 0) {\n            void *new_buffer = (void *)malloc(buffer_size);\n            if (new_buffer == NULL) {\n                *error_code = 0xc;\n                *(unsigned short *)(*buffer + 6) |= 0x40;\n                return 0xffffffff;\n            }\n            memcpy(new_buffer, (*buffer)[8], buffer_size);\n            *(unsigned short *)(*buffer + 6) &= 0xfb7f;\n            *(unsigned short *)(*buffer + 6) |= 0x80;\n            *buffer = new_buffer;\n        }\n        else {\n            void *new_buffer = (void *)realloc((*buffer)[8], new_buffer_end);\n            if (new_buffer == NULL) {\n                free((*buffer)[8]);\n                *error_code = 0xc;\n                *(unsigned short *)(*buffer + 6) |= 0x40;\n                return 0xffffffff;\n            }\n            *buffer = new_buffer;\n        }\n        (*buffer)[8] = (void *)((int)(*buffer)[8] + buffer_size);\n        *buffer = (void *)((int)(*buffer)[8] + buffer_size);\n        (*buffer)[10] = new_buffer_end;\n        (*buffer)[2] = (void *)((int)new_buffer_end - buffer_size);\n        old_buffer_end = new_end;\n    }\n    if (new_end <= old_buffer_end) {\n        old_buffer_end = new_end;\n    }\n    memmove(*buffer, current_end, (size_t)old_buffer_end);\n    (*buffer)[2] = (void *)((int)(*buffer)[2] - (int)old_buffer_end);\n    *buffer = (void *)((int)old_buffer_end + (int)(*buffer));\n    return 0;\n}",
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "_realloc_r",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005044",
            "calling": [
                "_svfiprintf_r"
            ],
            "imported": false,
            "current_name": "resize_buffer_08005044"
        },
        "FUN_08004194": {
            "renaming": {
                "FUN_08004194": "initialize_devices_08004194",
                "Devices_Init": "initialize_devices",
                "serialBegin": "initialize_serial_communication",
                "IMU_Init": "initialize_inertial_measurement_unit",
                "MS5611_Init": "initialize_pressure_sensor",
                "PID_Init": "initialize_pid_controller"
            },
            "code": "void initialize_devices_08004194(void)\n{\n  initialize_devices_08004194();\n  initialize_serial_communication();\n  initialize_inertial_measurement_unit();\n  initialize_pressure_sensor();\n  initialize_pid_controller();\n  return;\n}",
            "called": [
                "Devices_Init",
                "PID_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004194",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_devices_08004194"
        },
        "FUN_08001240": {
            "renaming": {
                "FUN_08001240": "set_clock_source_08001240",
                "CLKSource": "clock_source",
                "uVar1": "clock_register_value",
                "DAT_08001254": "clock_register"
            },
            "code": "void set_clock_source_08001240(uint32_t clock_source)\n{\n  uint32_t DAT_08001254_value;\n  if (clock_source == 4) {\n    DAT_08001254_value = *DAT_08001254 | 4;\n  }\n  else {\n    DAT_08001254_value = *DAT_08001254 & 0xfffffffb;\n  }\n  *DAT_08001254 = DAT_08001254_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001240",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_08001240"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_new_index_08005840",
                "param_1": "current_index",
                "param_2": "array",
                "iVar1": "new_index",
                "*(int *)(param_2 + -4)": "array[current_index - 4]",
                "*(int *)(param_2 + iVar1)": "array[new_index]"
            },
            "code": "int calculate_new_index_08005840(int current_index, int* array){\n    int new_index = current_index - 4;\n    if (array[current_index - 4] < 0) {\n        new_index += array[new_index];\n    }\n    return new_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_new_index_08005840"
        },
        "FUN_08000150": {
            "renaming": {
                "FUN_08000150": "count_characters_08000150",
                "__s": "string",
                "pcVar3": "current_position",
                "pcVar2": "next_position",
                "cVar1": "current_character"
            },
            "code": "size_t count_characters_08000150(char* string) {\n  char current_character;\n  char* current_position = string;\n  while (current_character = *current_position) {\n    current_position++;\n  }\n  return (size_t)(current_position - string);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000150",
            "calling": [
                "serialPrint"
            ],
            "imported": false,
            "current_name": "count_characters_08000150"
        },
        "FUN_08003f3c": {
            "renaming": {
                "FUN_08003f3c": "set_leds_state_08003f3c",
                "led_white": "white_leds",
                "led_red": "red_leds",
                "led_blue": "blue_leds",
                "GPIOx": "gpio",
                "uVar1": "leading_zeroes"
            },
            "code": "void set_leds_state_08003f3c(int white_leds, int red_leds, int blue_leds) {\n  GPIO_TypeDef *gpio;\n  uint32_t leading_zeroes;\n  \n  gpio = DAT_08003f78;\n  leading_zeroes = count_leading_zeroes(white_leds);\n  HAL_GPIO_WritePin(DAT_08003f78, 0x8000, (GPIO_PinState)(leading_zeroes >> 5));\n  leading_zeroes = count_leading_zeroes(red_leds);\n  HAL_GPIO_WritePin(gpio, 0x4000, (GPIO_PinState)(leading_zeroes >> 5));\n  leading_zeroes = count_leading_zeroes(blue_leds);\n  HAL_GPIO_WritePin(gpio, 0x2000, (GPIO_PinState)(leading_zeroes >> 5));\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f3c",
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "imported": false,
            "current_name": "set_leds_state_08003f3c"
        },
        "FUN_08002214": {
            "renaming": {
                "FUN_08002214": "get_system_core_clock_value_08002214",
                "PTR_SystemCoreClock_0800221c": "system_core_clock_ptr"
            },
            "code": "uint32_t get_system_core_clock_value_08002214(void)\n{\n    return *(uint32_t *)PTR_SystemCoreClock_0800221c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002214",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "get_system_core_clock_value_08002214"
        },
        "FUN_08003ff4": {
            "renaming": {
                "FUN_08003ff4": "pwm_start_08003ff4",
                "htim": "timer_handle",
                "PTR_htim4_0800401c": "PTR_htim4_0800401c",
                "HAL_TIM_PWM_Start": "HAL_TIM_PWM_Start",
                "TIM_HandleTypeDef": "TIM_HandleTypeDef",
                "PTR_htim2_08004020": "PTR_htim2_08004020",
                "PTR_htim3_08004024": "PTR_htim3_08004024",
                "channel_num": "channel_num"
            },
            "code": "void pwm_start_08003ff4(void)\n{\n  TIM_HandleTypeDef *timer_handle;\n  uint32_t channel_num;\n\n  timer_handle = (TIM_HandleTypeDef *)PTR_htim2_08004020;\n  channel_num = 4;\n  HAL_TIM_PWM_Start(timer_handle, channel_num);\n\n  timer_handle = (TIM_HandleTypeDef *)PTR_htim3_08004024;\n  channel_num = 8;\n  HAL_TIM_PWM_Start(timer_handle, channel_num);\n\n  timer_handle = (TIM_HandleTypeDef *)PTR_htim4_0800401c;\n  channel_num = 8;\n  HAL_TIM_PWM_Start(timer_handle, channel_num);\n\n  channel_num = 12;\n  HAL_TIM_PWM_Start(timer_handle, channel_num);\n}\n",
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ff4",
            "calling": [
                "Devices_Init"
            ],
            "imported": false,
            "current_name": "pwm_start_08003ff4"
        },
        "FUN_08001004": {
            "renaming": {
                "FUN_08001004": "__compare_floats_08001004",
                "param_1": "dst",
                "param_2": "src",
                "__cmpsf2": "__compare_floats_internal"
            },
            "code": "__compare_floats_08001004()\n{\n    return CONCAT44(dst,src);\n}",
            "called": [
                "__cmpsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001004",
            "calling": [
                "__aeabi_fcmple",
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt"
            ],
            "imported": false,
            "current_name": "__compare_floats_08001004"
        },
        "FUN_08001128": {
            "renaming": {
                "FUN_08001128": "initialize_system_08001128",
                "FUN_08001128Tick": "initialize_system_tick",
                "HAL_NVIC_SetPriorityGrouping": "NVIC_SetPriorityGrouping",
                "HAL_MspInit": "msp_initialize",
                "*DAT_08001148": "*system_status"
            },
            "code": "HAL_StatusTypeDef initialize_system_08001128(void)\n{\n  *DAT_08001148 |= 0x10;\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  initialize_system_08001128_tick(0);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001128",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "initialize_system_08001128"
        },
        "FUN_08004514": {
            "renaming": {
                "FUN_08004514": "initialize_clock_08004514",
                "HVar1": "status",
                "uVar3": "hclk_freq",
                "FLatency": "latency",
                "RCC_ClkInitStruct": "clock_init_struct",
                "RCC_OscInitStruct": "osc_init_struct",
                "puVar2": "unused_pointer",
                "line": "unused_line"
            },
            "code": "void initialize_clock_08004514(void)\n{\n  HAL_StatusTypeDef status;\n  uint32_t latency;\n  RCC_ClkInitTypeDef clock_init_struct;\n  RCC_OscInitTypeDef osc_init_struct;\n  osc_init_struct.HSIState = RCC_HSI_ON;\n  osc_init_struct.HSICalibrationValue = 0x10;\n  latency = FLASH_LATENCY_2;\n  osc_init_struct.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  osc_init_struct.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  osc_init_struct.PLL.PLLState = RCC_PLL_ON;\n  osc_init_struct.PLL.PLLMUL = RCC_PLL_MUL16;\n  status = HAL_RCC_OscConfig(&osc_init_struct);\n  if (status != HAL_OK)\n  {\n    error_handler();\n  }\n  clock_init_struct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n  clock_init_struct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clock_init_struct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clock_init_struct.APB1CLKDivider = RCC_HCLK_DIV2;\n  clock_init_struct.APB2CLKDivider = RCC_HCLK_DIV1;\n  status = HAL_RCC_ClockConfig(&clock_init_struct, latency);\n  if (status != HAL_OK)\n  {\n    error_handler();\n  }\n  uint32_t hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclk_freq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n",
            "called": [
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_RCC_ClockConfig",
                "_Error_Handler",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004514",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "initialize_clock_08004514"
        },
        "FUN_08004a84": {
            "renaming": {
                "FUN_08004a84": "flight_control_08004a84",
                "puVar1": "pid_pitch",
                "puVar2": "pid_roll",
                "puVar3": "pid_yaw",
                "puVar4": "joystick",
                "puVar5": "pid_altitude",
                "extraout_s0": "throttle",
                "extraout_s0_00": "throttle",
                "extraout_s1": "pitch",
                "extraout_s1_00": "pitch",
                "extraout_s2": "roll",
                "extraout_s2_00": "roll",
                "extraout_s3": "yaw",
                "extraout_s3_00": "yaw",
                "in_r0": "altitude_setpoint",
                "iVar7": "comparison_result",
                "uVar6": "integer_result",
                "uVar8": "scaling_factor",
                "DAT_08004bfc": "PITCH_ROLL_LIMIT",
                "DAT_08004c00": "PITCH_ROLL_LIMIT",
                "DAT_08004c10": "PITCH_ROLL_SCALING_FACTOR",
                "DAT_08004c0c": "ALTITUDE_SCALING_FACTOR",
                "PTR_pid_pitch_08004bf0": "&pid_pitch",
                "PTR_pid_roll_08004bf4": "&pid_roll",
                "PTR_pid_yaw_08004bf8": "&pid_yaw",
                "PTR_joystick_08004c04": "&joystick",
                "PTR_pid_altitude_08004c08": "&pid_altitude",
                "PTR_msp_txf_pid_08004c14": "&msp_txf_pid",
                "AHRS_GetPitch": "AHRS_GetPitch",
                "AHRS_GetRoll": "AHRS_GetRoll",
                "AHRS_GetYaw": "AHRS_GetYaw",
                "FUN_08004a84Altitude": "FUN_08004a84Altitude",
                "toggleLED": "toggleLED",
                "Motor_StopAll": "Motor_StopAll",
                "Motor_DistributeSpeed": "Motor_DistributeSpeed"
            },
            "code": "void flight_control_08004a84()\n{\n  float throttle;\n  float pitch;\n  float roll;\n  float yaw;\n  float altitude;\n  \n  float pitch_setpoint = AHRS_GetPitch();\n  float roll_setpoint = AHRS_GetRoll();\n  float yaw_setpoint = AHRS_GetYaw();\n  float altitude_setpoint = flight_control_08004a84Altitude();\n  \n  int pitch_direction = (pitch_setpoint > 0) - (pitch_setpoint < 0);\n  int roll_direction = (roll_setpoint > 0) - (roll_setpoint < 0);\n  \n  int pitch_in_range = (pitch_setpoint > -DAT_08004bfc && pitch_setpoint < DAT_08004bfc);\n  int roll_in_range = (roll_setpoint > -DAT_08004bfc && roll_setpoint < DAT_08004bfc);\n  \n  if (pitch_in_range && roll_in_range)\n  {\n    toggleLED(1, 1, 1);\n    PID_Compute(PTR_pid_pitch_08004bf0);\n    PID_Compute(PTR_pid_roll_08004bf4);\n    PID_Compute(PTR_pid_yaw_08004bf8);\n    \n    if (joystick[1] != 0)\n    {\n      PID_Compute(PTR_pid_altitude_08004c08);\n      altitude = pid_altitude.output;\n      altitude_setpoint += altitude;\n    }\n    else\n    {\n      altitude_setpoint = joystick[4];\n      Motor_StopAll();\n    }\n    \n    throttle = altitude_setpoint / 100.0f;\n    pitch = pitch_direction * __builtin_fabsf(pitch_setpoint) / DAT_08004bfc;\n    roll = roll_direction * __builtin_fabsf(roll_setpoint) / DAT_08004bfc;\n    yaw = yaw_setpoint / YAW_LIMIT;\n    \n    Motor_DistributeSpeed(throttle, pitch, roll, yaw);\n    \n    msp_txf_pid[3] = (int)(pitch_setpoint * DAT_08004c10);\n    msp_txf_pid[4] = (int)(roll_setpoint * DAT_08004c10);\n    msp_txf_pid[0] = (int)(pid_pitch.output * DAT_08004c10);\n    msp_txf_pid[1] = (int)(pid_roll.output * DAT_08004c10);\n    msp_txf_pid[2] = (int)(pid_yaw.output * YAW_SCALING_FACTOR);\n    msp_txf_pid[6] = (int)(altitude * DAT_08004c0c);\n    msp_txf_pid[7] = (int)(altitude_setpoint * DAT_08004c0c);\n  }\n  else\n  {\n    Motor_StopAll();\n    toggleLED(0, 1, 0);\n  }\n}\n",
            "called": [
                "__aeabi_fcmpgt",
                "AHRS_GetPitch",
                "Motor_DistributeSpeed",
                "AHRS_GetRoll",
                "AHRS_GetYaw",
                "PID_Compute",
                "Motor_StopAll",
                "__aeabi_fcmplt",
                "PID_UpdateAltitude",
                "__aeabi_fmul",
                "toggleLED",
                "__addsf3",
                "__fixunssfsi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a84",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "flight_control_08004a84"
        },
        "FUN_080057d0": {
            "renaming": {
                "FUN_080057d0": "allocate_memory_and_copy_data_to_it_080057d0",
                "param_1": "size",
                "param_2": "source",
                "param_3": "destination",
                "param_4": "unknown_param",
                "pvVar1": "allocated_memory",
                "pvVar2": "usable_memory"
            },
            "code": "void allocate_memory_and_copy_data_to_it_080057d0(int size, void *source, void *destination, int unknown_param)\n{\n    void *allocated_memory;\n    void *usable_memory;\n\n    if (source != NULL) {\n        if (destination == NULL) {\n            free(destination);\n            allocated_memory = destination;\n        }\n        else {\n            usable_memory = (void *)malloc_usable_size(destination);\n            allocated_memory = source;\n            if ((usable_memory < destination) && (allocated_memory = (void *)malloc(size), allocated_memory != NULL)) {\n                memcpy(allocated_memory, source, (size_t)destination);\n                free(source);\n            }\n        }\n        return allocated_memory;\n    }\n    allocated_memory = (void *)malloc(size, destination, destination, unknown_param);\n    return allocated_memory;\n}",
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057d0",
            "calling": [
                "__ssputs_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_and_copy_data_to_it_080057d0"
        },
        "FUN_080072d4": {
            "renaming": {
                "FUN_080072d4": "get_context_address_080072d4",
                "ctx": "context"
            },
            "code": "int get_context_address_080072d4(EVP_PKEY_CTX *context)\n{\n  return (int)context;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d4",
            "calling": [
                "__do_global_dtors_aux",
                "frame_dummy",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "get_context_address_080072d4"
        },
        "FUN_0800583c": {
            "renaming": {
                "FUN_0800583c": "do_nothing_0800583c"
            },
            "code": "\nvoid do_nothing_0800583c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800583c"
        },
        "FUN_08000adc": {
            "renaming": {
                "FUN_08000adc": "FUNC_08000adc"
            },
            "code": "\nuint FUNC_08000adc(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  bool bVar7;\n  \n  uVar3 = param_1 << 1;\n  bVar7 = uVar3 == 0;\n  if (!bVar7) {\n    param_4 = param_2 << 1;\n    bVar7 = param_4 == 0;\n  }\n  if (!bVar7) {\n    bVar7 = uVar3 == param_4;\n  }\n  iVar6 = (int)uVar3 >> 0x18;\n  if (!bVar7) {\n    bVar7 = iVar6 == -1;\n  }\n  if (!bVar7) {\n    bVar7 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar7) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar3 = param_2;\n      if (iVar6 == -1) {\n        uVar3 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_2 = uVar3;\n      }\n      bVar7 = (uVar3 & 0x7fffff) == 0;\n      if (bVar7) {\n        bVar7 = (param_2 & 0x7fffff) == 0;\n      }\n      if (bVar7) {\n        bVar7 = uVar3 == param_2;\n      }\n      if (!bVar7) {\n        uVar3 = uVar3 | 0x400000;\n      }\n      return uVar3;\n    }\n    if (((param_1 ^ param_2) & 0x7fffffff) != 0) {\n      if (uVar3 == 0) {\n        param_1 = param_2;\n      }\n      return param_1;\n    }\n    if (param_1 != param_2) {\n      return 0;\n    }\n    if ((uVar3 & 0xff000000) == 0) {\n      uVar3 = param_1 << 1;\n      if ((param_1 & 0x80000000) != 0) {\n        uVar3 = uVar3 | 0x80000000;\n      }\n      return uVar3;\n    }\n    if (uVar3 < 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 = param_1 & 0x80000000;\nLAB_08000c12:\n    return param_1 | 0x7f800000;\n  }\n  uVar3 = uVar3 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar5 = param_4 - uVar3;\n  bVar7 = uVar5 != 0;\n  uVar4 = uVar3;\n  if (bVar7 && uVar3 <= param_4) {\n    uVar4 = uVar3 + uVar5;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_2 = param_2 ^ param_1;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_1 = param_1 ^ param_2;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_2 = param_2 ^ param_1;\n  }\n  if (param_4 < uVar3) {\n    uVar5 = -uVar5;\n  }\n  if (0x19 < uVar5) {\n    return param_1;\n  }\n  uVar3 = param_1 & 0xffffff | 0x800000;\n  if ((param_1 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  uVar2 = param_2 & 0xffffff | 0x800000;\n  if ((param_2 & 0x80000000) != 0) {\n    uVar2 = -uVar2;\n  }\n  if (uVar4 == uVar5) {\n    uVar2 = uVar2 ^ 0x800000;\n    if (uVar4 == 0) {\n      uVar3 = uVar3 ^ 0x800000;\n      uVar4 = 1;\n    }\n    else {\n      uVar5 = uVar5 - 1;\n    }\n  }\n  uVar3 = uVar3 + ((int)uVar2 >> (uVar5 & 0xff));\n  uVar2 = uVar2 << (0x20 - uVar5 & 0xff);\n  param_1 = uVar3 & 0x80000000;\n  if ((int)uVar3 < 0) {\n    bVar7 = uVar2 != 0;\n    uVar2 = -uVar2;\n    uVar3 = -uVar3 - (uint)bVar7;\n  }\n  if (uVar3 < 0x800000) {\n    uVar5 = uVar2 & 0x80000000;\n    uVar2 = uVar2 << 1;\n    uVar3 = uVar3 * 2 + (uint)(uVar5 != 0);\n    uVar5 = uVar4 - 2;\n    if ((uVar3 & 0x800000) == 0) {\n      iVar6 = count_leading_zeroes(uVar3);\n      uVar4 = iVar6 - 8;\n      uVar3 = uVar3 << (uVar4 & 0xff);\n      if ((int)uVar5 < (int)uVar4) {\n        uVar3 = uVar3 >> (-(uVar5 - uVar4) & 0xff);\n      }\n      else {\n        uVar3 = uVar3 + (uVar5 - uVar4) * 0x800000;\n      }\n      return uVar3 | param_1;\n    }\n  }\n  else {\n    uVar5 = uVar4 - 1;\n    if (0xffffff < uVar3) {\n      uVar5 = uVar3 & 1;\n      uVar3 = uVar3 >> 1;\n      uVar2 = (uint)(uVar5 != 0) << 0x1f | uVar2 >> 1;\n      uVar5 = uVar4;\n      if (0xfd < uVar4) goto LAB_08000c12;\n    }\n  }\n  uVar3 = uVar3 + uVar5 * 0x800000 + (uint)(0x7fffffff < uVar2);\n  if (uVar2 == 0x80000000) {\n    uVar3 = uVar3 & 0xfffffffe;\n  }\n  return uVar3 | param_1;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000adc",
            "calling": [
                "__aeabi_frsub",
                "MS5611_Update",
                "MadgwickQuaternionUpdate",
                "Motor_DistributeSpeed",
                "PID_Update",
                "AHRS_GetYaw",
                "lowPassFilter",
                "AK8963_Init",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "FUNC_08000adc"
        },
        "FUN_0800583e": {
            "renaming": {
                "FUN_0800583e": "do_nothing_0800583e"
            },
            "code": "\nvoid do_nothing_0800583e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583e",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800583e"
        },
        "FUN_08000160": {
            "renaming": {
                "FUN_08000160": "FUNC_08000160"
            },
            "code": "\nulonglong FUNC_08000160(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar4 = param_2 ^ 0x80000000;\n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((uVar4 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = uVar4;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((uVar4 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        uVar4 = param_4;\n      }\n      return CONCAT44(uVar4,param_1);\n    }\n    if (uVar4 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(uVar4,uVar4) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(uVar4 + 0x100000,param_1);\n    }\n    uVar4 = uVar4 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(uVar4 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar12 = uVar4;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar12 = param_4;\n    param_3 = param_1;\n    param_4 = uVar4;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar12,uVar8);\n  }\n  uVar9 = uVar12 & 0xfffff | 0x100000;\n  if ((uVar12 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar4 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar4 = uVar4 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar5 = uVar4 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar5;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar4 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar11 = uVar4 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar4 = (int)uVar4 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar4;\n    uVar9 = uVar9 + ((int)uVar4 >> 0x1f) + (uint)CARRY4(uVar8,uVar4);\n  }\n  uVar4 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | uVar4,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if ((uVar10 & 0x100000) != 0) goto LAB_08000278;\n  uVar3 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar3 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar3 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar3 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar3 = uVar3 << (uVar10 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | uVar4,uVar3);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar3 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(uVar4 | uVar7 >> (uVar10 & 0xff),\n                    uVar3 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000160",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08000160"
        },
        "FUN_08002220": {
            "renaming": {
                "FUN_08002220": "calculate_clock_frequency_08002220",
                "uVar1": "leading_zeroes_count",
                "PTR_SystemCoreClock_0800224c": "system_core_clock_pointer",
                "PTR_APBPrescTable_08002248": "apb_prescaler_table_pointer",
                "DAT_08002244": "data_pointer"
            },
            "code": "uint32_t calculate_clock_frequency_08002220(void)\n{\n  uint32_t leading_zeroes_count;\n  leading_zeroes_count = count_leading_zeroes(0xe00000);\n  uint32_t apb_prescaler_index = (*(uint32_t *)PTR_SystemCoreClock_0800224c) >> PTR_APBPrescTable_08002248[(*(uint32_t *)(DAT_08002244 + 4) & 0x700) >> (leading_zeroes_count & 0xff)];\n  return apb_prescaler_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002220",
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "calculate_clock_frequency_08002220"
        },
        "FUN_08003314": {
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "beta_value",
                "in_r0": "input"
            },
            "code": "void set_beta_08003314(float beta_value)\n{\n  undefined4 input;\n  *(undefined4 *)PTR_beta_0800331c = input;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003314",
            "calling": [
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "set_beta_08003314"
        },
        "FUN_08005854": {
            "renaming": {
                "FUN_08005854": "calculate_function_08005854",
                "__x": "input",
                "dVar4": "result",
                "iVar2": "comparison_result",
                "puVar1": "version_string",
                "puVar3": "errno_pointer",
                "in_stack_ffffffb8": "input_part_2",
                "in_stack_ffffffbc": "input_part_1"
            },
            "code": "double calculate_function_08005854(double input){\n  double result;\n  int comparison_result;\n  char *version_string;\n  int errno_value;\n\n  result = (double)__ieee754_calculate_function_08005854();\n  version_string = PTR___fdlib_version_080058f8;\n  if ((*version_string != -1) && (comparison_result = __unorddf2(), result = extraout_d0, comparison_result == 0)) {\n    fabs((double)CONCAT44(input,in_stack_ffffffb8));\n    comparison_result = __aeabi_dcmpgt();\n    result = extraout_d0_00;\n    if ((comparison_result != 0) && ((nan(PTR_DAT_080058f4), *version_string == '\\x02' || (comparison_result = matherr((exception *)&stack0xffffffb8), result = extraout_d0_02, comparison_result == 0)))) {\n      errno_value = *__errno();\n      *puVar3 = 0x21;\n      result = extraout_d0_01;\n    }\n  }\n  return result;\n}",
            "called": [
                "__unorddf2",
                "__aeabi_dcmpgt",
                "fabs",
                "matherr",
                "__errno",
                "nan",
                "__ieee754_asin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005854",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_function_08005854"
        },
        "FUN_08000168": {
            "renaming": {
                "FUN_08000168": "FUNC_08000168"
            },
            "code": "\nulonglong FUNC_08000168(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar6 = param_4 ^ 0x80000000;\n  uVar9 = param_2 << 1;\n  param_4 = param_4 << 1;\n  bVar13 = ((param_2 ^ uVar6) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar9 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (param_4 | param_3) == 0;\n  }\n  iVar8 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar8 == -1;\n  }\n  iVar1 = (int)param_4 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar8 == -1 || iVar1 == -1) {\n      uVar9 = uVar6;\n      uVar11 = param_3;\n      if (iVar8 == -1) {\n        uVar9 = param_2;\n        uVar11 = param_1;\n      }\n      if (iVar8 != -1 || iVar1 != -1) {\n        param_3 = uVar11;\n        uVar6 = uVar9;\n      }\n      bVar14 = (uVar11 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | uVar6 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == uVar6;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar11);\n    }\n    if (((param_2 ^ uVar6) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar9 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = uVar6;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != uVar6) {\n      return 0;\n    }\n    if (uVar9 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar6 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar6 = uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,param_1 << 1);\n    }\n    if (uVar9 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar9 = uVar9 >> 0x15;\n  param_4 = param_4 >> 0x15;\n  uVar11 = param_4 - uVar9;\n  bVar14 = uVar11 != 0;\n  if (param_4 < uVar9) {\n    uVar11 = -uVar11;\n  }\n  uVar10 = param_1;\n  uVar7 = param_2;\n  if (bVar14 && uVar9 <= param_4) {\n    uVar9 = uVar9 + uVar11;\n    uVar10 = param_3;\n    uVar7 = uVar6;\n    param_3 = param_1;\n    uVar6 = param_2;\n  }\n  if (0x36 < uVar11) {\n    return CONCAT44(uVar7,uVar10);\n  }\n  uVar4 = uVar7 & 0xfffff | 0x100000;\n  if ((uVar7 & 0x80000000) != 0) {\n    bVar14 = uVar10 != 0;\n    uVar10 = -uVar10;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  uVar7 = uVar6 & 0xfffff | 0x100000;\n  if ((uVar6 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar7 = -uVar7 - (uint)bVar14;\n  }\n  if (uVar9 == uVar11) {\n    uVar7 = uVar7 ^ 0x100000;\n    if (uVar9 == 0) {\n      uVar4 = uVar4 ^ 0x100000;\n      uVar9 = 1;\n    }\n    else {\n      uVar11 = uVar11 - 1;\n    }\n  }\n  uVar6 = -uVar11 + 0x20;\n  if ((int)uVar11 < 0x21) {\n    uVar12 = param_3 << (uVar6 & 0xff);\n    param_3 = param_3 >> (uVar11 & 0xff);\n    uVar3 = uVar10 + param_3;\n    uVar5 = uVar7 << (uVar6 & 0xff);\n    uVar6 = uVar3 + uVar5;\n    uVar4 = uVar4 + CARRY4(uVar10,param_3) + ((int)uVar7 >> (uVar11 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar12 = uVar7 << (-uVar11 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar12 = uVar12 | 2;\n    }\n    uVar7 = (int)uVar7 >> (uVar11 - 0x20 & 0xff);\n    uVar6 = uVar10 + uVar7;\n    uVar4 = uVar4 + ((int)uVar7 >> 0x1f) + (uint)CARRY4(uVar10,uVar7);\n  }\n  param_2 = uVar4 & 0x80000000;\n  uVar11 = uVar4;\n  if ((int)uVar4 < 0) {\n    bVar14 = uVar12 == 0;\n    uVar12 = -uVar12;\n    uVar11 = -uVar6;\n    uVar6 = -(uint)!bVar14 - uVar6;\n    uVar11 = -(uint)(bVar14 <= uVar11) - uVar4;\n  }\n  if (0xfffff < uVar11) {\n    uVar10 = uVar9 - 1;\n    if (0x1fffff < uVar11) {\n      uVar10 = uVar11 & 1;\n      uVar11 = uVar11 >> 1;\n      bVar2 = (byte)uVar6;\n      uVar6 = (uint)(uVar10 != 0) << 0x1f | uVar6 >> 1;\n      uVar12 = (uint)(bVar2 & 1) << 0x1f | uVar12 >> 1;\n      uVar10 = uVar9;\n      if (0xffbfffff < uVar9 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    bVar14 = 0x7fffffff < uVar12;\n    if (uVar12 == 0x80000000) {\n      bVar14 = (uVar6 & 1) != 0;\n    }\n    return CONCAT44(uVar11 + uVar10 * 0x100000 + (uint)CARRY4(uVar6,(uint)bVar14) | param_2,\n                    uVar6 + bVar14);\n  }\n  bVar13 = (uVar12 & 0x80000000) != 0;\n  uVar12 = uVar12 << 1;\n  uVar10 = uVar6 * 2;\n  bVar14 = CARRY4(uVar6,uVar6);\n  uVar6 = uVar6 * 2 + (uint)bVar13;\n  uVar11 = uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10,(uint)bVar13));\n  uVar10 = uVar9 - 2;\n  if ((uVar11 & 0x100000) != 0) goto LAB_08000278;\n  uVar7 = uVar6;\n  uVar9 = uVar11;\n  if (uVar11 == 0) {\n    uVar7 = 0;\n    uVar9 = uVar6;\n  }\n  iVar8 = count_leading_zeroes(uVar9);\n  if (uVar11 == 0) {\n    iVar8 = iVar8 + 0x20;\n  }\n  uVar11 = iVar8 - 0xb;\n  bVar15 = SBORROW4(uVar11,0x20);\n  uVar6 = iVar8 - 0x2b;\n  bVar14 = (int)uVar6 < 0;\n  bVar13 = uVar6 == 0;\n  if ((int)uVar11 < 0x20) {\n    bVar15 = SCARRY4(uVar6,0xc);\n    iVar8 = iVar8 + -0x1f;\n    bVar14 = iVar8 < 0;\n    bVar13 = iVar8 == 0;\n    uVar6 = uVar11;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar7 = uVar9 << (uVar11 & 0xff);\n      uVar9 = uVar9 >> (0xcU - iVar8 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar12 = 0x20 - uVar6;\n  }\n  uVar9 = uVar9 << (uVar6 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar9 = uVar9 | uVar7 >> (uVar12 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 << (uVar6 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)uVar11 <= (int)uVar10) {\n    return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2,uVar7);\n  }\n  uVar6 = ~(uVar10 - uVar11);\n  if ((int)uVar6 < 0x1f) {\n    iVar8 = uVar6 - 0x13;\n    if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(uVar4,uVar7 >> (0x20 - (0xcU - iVar8) & 0xff) | uVar9 << (0xcU - iVar8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar6 = uVar6 + 1;\n    return CONCAT44(param_2 | uVar9 >> (uVar6 & 0xff),\n                    uVar7 >> (uVar6 & 0xff) | uVar9 << (0x20 - uVar6 & 0xff));\n  }\n  return CONCAT44(uVar4,uVar9 >> (uVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000168",
            "calling": [
                "MS5611_Update",
                "__ieee754_atan2",
                "__ieee754_sqrt",
                "atan",
                "rint",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "FUNC_08000168"
        },
        "FUN_080072e0": {
            "renaming": {
                "FUN_080072e0": "do_nothing_080072e0"
            },
            "code": "\nvoid do_nothing_080072e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072e0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080072e0"
        },
        "FUN_08001014": {
            "renaming": {
                "FUN_08001014": "compare_zero_08001014",
                "in_ZR": "input_char"
            },
            "code": "bool compare_zero_08001014(char input_char){\\n\\tint comparison_result = __aeabi_cfcmpeq();\\n\\treturn input_char != \"\\0\";\\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001014",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "compare_zero_08001014"
        },
        "FUN_080071c0": {
            "renaming": {
                "FUN_080071c0": "calculate_result_080071c0",
                "__x": "x",
                "__n": "n",
                "in_r1": "shifted_r1",
                "extraout_r1": "extra_out_r1",
                "in_r2": "r2",
                "in_d0": "result",
                "dVar3": "temp_result",
                "DAT_08007290": "DAT_constant_1",
                "DAT_08007294": "DAT_constant_2",
                "SCARRY4": "SCARRY4_function",
                "unaff_r4": "r4",
                "unaff_r3": "r3",
                "unaff_r5": "r5",
                "unaff_r6": "r6"
            },
            "code": "double calculate_result_080071c0(double x, int n)\n{\n  uint shifted_r1;\n  int extraout_r1;\n  int r2;\n  uint uVar1;\n  int iVar2;\n  undefined4 r3;\n  undefined4 r4;\n  undefined4 r5;\n  undefined4 r6;\n  double result;\n  double temp_result;\n  \n  shifted_r1 = (r1 << 1) >> 0x15;\n  if (shifted_r1 == 0) {\n    if ((r1 & 0x7fffffff | n) == 0) {\n      return result;\n    }\n    result = (double)__muldf3(n, r1, 0, DAT_08007290);\n    if (r2 < DAT_08007294) {\n        goto LAB_0800722e;\n    }\n    shifted_r1 = ((uint)(extraout_r1 << 1) >> 0x15) - 0x36;\n  }\n  else if (shifted_r1 == 0x7ff) {\n    temp_result = (double)__aeabi_dadd(n, r1, n);\n    return temp_result;\n  }\n  iVar2 = shifted_r1 + r2;\n  if (iVar2 < 0x7ff) {\n    if (0 < iVar2) {\n      return result;\n    }\n    if (iVar2 + 0x35 < 0 == SCARRY4(iVar2, 0x35)) {\n        goto LAB_0800722e;\n    }\n    if (r2 < 0xc351) {\n      copysign((double)CONCAT44(r4, r3), (double)CONCAT44(r6, r5));\n      goto LAB_0800722e;\n    }\n  }\n  copysign((double)CONCAT44(r4, r3), (double)CONCAT44(r6, r5));\n  LAB_0800722e:\n  temp_result = (double)__muldf3();\n  return temp_result;\n}",
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "copysign"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071c0",
            "calling": [
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_result_080071c0"
        },
        "FUN_08001258": {
            "renaming": {
                "FUN_08001258": "do_nothing_08001258"
            },
            "code": "\nvoid do_nothing_08001258(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001258",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08001258"
        },
        "FUN_08005614": {
            "renaming": {
                "FUN_08005614": "find_byte_08005614",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "size",
                "pbVar1": "current_byte",
                "pbVar2": "next_byte"
            },
            "code": "void* find_byte_08005614(void* data, int byte_to_find, size_t size){\n  unsigned char* current_byte = (unsigned char*)data;\n  while(current_byte != (unsigned char*)(size + (int)data)){\n    if((unsigned int)*current_byte == (byte_to_find & 0xffU)){\n      return current_byte;\n    }\n    current_byte++;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005614",
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_08005614"
        },
        "FUN_08000724": {
            "renaming": {
                "FUN_08000724": "FUNC_08000724"
            },
            "code": "\nulonglong FUNC_08000724(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  ulonglong uVar17;\n  \n  uVar17 = CONCAT44(param_2,param_1);\n  uVar13 = 0x7ff;\n  uVar7 = param_2 >> 0x14 & 0x7ff;\n  bVar14 = uVar7 == 0;\n  if (!bVar14) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar14 = unaff_r5 == 0;\n  }\n  if (!bVar14) {\n    bVar14 = uVar7 == 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 = unaff_r5 == 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 = decode_bits_08000892();\n  }\n  uVar9 = (uint)(uVar17 >> 0x20);\n  uVar11 = (uint)uVar17;\n  iVar8 = uVar7 - unaff_r5;\n  if ((param_3 | param_4 << 0xc) == 0) {\n    uVar7 = (uVar9 ^ param_4) & 0x80000000 | uVar9 & 0xfffff;\n    bVar16 = SCARRY4(iVar8,uVar13 >> 1);\n    uVar9 = iVar8 + (uVar13 >> 1);\n    bVar14 = (int)uVar9 < 0;\n    bVar15 = uVar9 == 0;\n    if (!bVar15 && bVar14 == bVar16) {\n      bVar16 = SBORROW4(uVar13,uVar9);\n      bVar14 = (int)(uVar13 - uVar9) < 0;\n      bVar15 = uVar13 == uVar9;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      uVar7 = uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      return uVar17 & 0xffffffff | (ulonglong)uVar7 << 0x20;\n    }\n    uVar7 = uVar7 | 0x100000;\n    uVar13 = 0;\n    bVar15 = SBORROW4(uVar9,1);\n    uVar9 = uVar9 - 1;\n    bVar14 = uVar9 == 0;\n    uVar3 = uVar9;\n  }\n  else {\n    uVar3 = (param_4 << 0xc) >> 4 | 0x10000000 | param_3 >> 0x18;\n    uVar13 = param_3 << 8;\n    uVar10 = (uVar9 << 0xc) >> 4 | 0x10000000 | uVar11 >> 0x18;\n    uVar11 = uVar11 * 0x100;\n    uVar7 = (uVar9 ^ param_4) & 0x80000000;\n    bVar14 = uVar3 <= uVar10;\n    if (uVar10 == uVar3) {\n      bVar14 = uVar13 <= uVar11;\n    }\n    iVar8 = iVar8 + (uint)bVar14;\n    uVar9 = iVar8 + 0x3fd;\n    if (bVar14 == false) {\n      uVar3 = uVar3 >> 1;\n      uVar13 = (uint)((param_3 >> 0x18 & 1) != 0) << 0x1f | uVar13 >> 1;\n    }\n    uVar12 = uVar11 - uVar13;\n    uVar10 = (uVar10 - uVar3) - (uint)(uVar11 < uVar13);\n    uVar4 = uVar3 >> 1;\n    uVar1 = (uint)((uVar3 & 1) != 0) << 0x1f | uVar13 >> 1;\n    uVar11 = 0x100000;\n    uVar3 = 0x80000;\n    while( true ) {\n      bVar14 = uVar1 <= uVar12;\n      if (uVar4 < uVar10 || uVar10 - uVar4 < (uint)bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar11 = uVar11 | uVar3;\n        uVar10 = (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 = uVar4 >> 1;\n      uVar1 = (uint)((uVar4 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar10 - uVar5 < (uint)bVar15;\n      uVar13 = uVar10;\n      if (uVar5 < uVar10 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar13 = (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 < uVar10 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 1;\n      }\n      uVar10 = uVar4 >> 2;\n      uVar2 = (uint)((uVar5 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar2 <= uVar12;\n      bVar14 = uVar13 - uVar10 < (uint)bVar15;\n      uVar5 = uVar13;\n      if (uVar10 < uVar13 || bVar14) {\n        uVar12 = uVar12 - uVar2;\n        uVar5 = (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 < uVar13 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 2;\n      }\n      uVar6 = uVar4 >> 3;\n      uVar1 = (uint)((uVar10 & 1) != 0) << 0x1f | uVar2 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar5 - uVar6 < (uint)bVar15;\n      uVar10 = uVar5;\n      if (uVar6 < uVar5 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar10 = (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 < uVar5 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 3;\n      }\n      uVar13 = uVar10 | uVar12;\n      if (uVar13 == 0) break;\n      uVar10 = uVar10 << 4 | uVar12 >> 0x1c;\n      uVar12 = uVar12 << 4;\n      uVar4 = uVar4 & 0xfffffff8 | uVar1 >> 0x1d;\n      uVar1 = (uVar2 >> 1) << 3;\n      uVar3 = uVar3 >> 4;\n      if (uVar3 == 0) {\n        uVar6 = uVar4;\n        if ((uVar7 & 0x100000) != 0) goto LAB_08000842;\n        uVar7 = uVar7 | uVar11;\n        uVar11 = 0;\n        uVar3 = 0x80000000;\n      }\n    }\n    if ((uVar7 & 0x100000) == 0) {\n      uVar7 = uVar7 | uVar11;\n      uVar11 = 0;\n    }\nLAB_08000842:\n    bVar16 = 0xfc < uVar9;\n    bVar15 = SBORROW4(uVar9,0xfd);\n    uVar4 = iVar8 + 0x300;\n    bVar14 = uVar4 == 0;\n    uVar3 = uVar4;\n    if (bVar16 && !bVar14) {\n      bVar16 = 0x6ff < uVar4;\n      bVar15 = SBORROW4(uVar4,0x700);\n      uVar3 = iVar8 - 0x400;\n      bVar14 = uVar4 == 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 = uVar6 <= uVar10;\n      if (uVar10 == uVar6) {\n        bVar14 = uVar1 <= uVar12;\n      }\n      if (uVar10 == uVar6 && uVar12 == uVar1) {\n        bVar14 = (uVar11 & 1) != 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 && (int)uVar3 < 0 == bVar15) {\n    return (ulonglong)(uVar7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar16 = SCARRY4(uVar9,0x36);\n  bVar14 = (int)(uVar9 + 0x36) < 0;\n  bVar15 = uVar9 == 0xffffffca;\n  if (bVar15 || bVar14 != bVar16) {\n    uVar11 = 0;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    uVar7 = uVar7 & 0x80000000;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 = -uVar9;\n  uVar10 = uVar3 - 0x20;\n  if (0x1f < (int)uVar3) {\n    uVar3 = uVar11 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff);\n    uVar9 = (uVar7 >> (uVar10 & 0xff) & ~((uVar7 & 0x80000000) >> (uVar10 & 0xff))) -\n            ((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar11 << (0x20 - uVar10 & 0xff) | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) & 0x80000000ffffffff;\n  }\n  iVar8 = uVar3 - 0x14;\n  if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar10,0xc)) {\n    uVar9 = 0xc - iVar8;\n    uVar3 = uVar11 << (uVar9 & 0xff);\n    uVar11 = uVar11 >> (0x20 - uVar9 & 0xff) | uVar7 << (uVar9 & 0xff);\n    uVar9 = uVar11 + -((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44((uVar7 & 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 >> 0x1f)),uVar9);\n  }\n  uVar10 = uVar11 << (uVar9 + 0x20 & 0xff);\n  uVar11 = uVar11 >> (uVar3 & 0xff) | uVar7 << (uVar9 + 0x20 & 0xff);\n  uVar9 = uVar11 + -((int)uVar10 >> 0x1f);\n  if ((uVar13 | uVar10 << 1) == 0) {\n    uVar9 = uVar9 & ~(uVar10 >> 0x1f);\n  }\n  return CONCAT44((uVar7 & 0x80000000) +\n                  ((uVar7 & 0x7fffffff) >> (uVar3 & 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 >> 0x1f)),uVar9);\n}\n\n",
            "called": [
                "FUN_08000892"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000724",
            "calling": [
                "__ieee754_atan2",
                "MadgwickQuaternionUpdate",
                "sqrt",
                "__ieee754_sqrt",
                "atan",
                "pow",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "FUNC_08000724"
        },
        "FUN_080070a4": {
            "renaming": {
                "FUN_080070a4": "calculate_tagb_length_080070a4",
                "__tagb": "tagb",
                "in_d0": "length"
            },
            "code": "double calculate_tagb_length_080070a4(char *tagb) {\n  double length = 0.0;\n  return length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080070a4",
            "calling": [
                "asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_tagb_length_080070a4"
        },
        "FUN_0800407c": {
            "renaming": {
                "FUN_0800407c": "read_i2c_byte_0800407c",
                "device_add": "device_address",
                "register_add": "register_address",
                "file": "file_name",
                "line": "line_number",
                "HVar1": "status",
                "byte": "byte_buffer"
            },
            "code": "uint8_t read_i2c_byte_0800407c(uint16_t device_address, uint16_t register_address, char *file_name, int line_number) {\n  HAL_StatusTypeDef status = HAL_OK;\n  uint8_t byte_buffer[1] = {0};\n  status = HAL_I2C_Mem_Read(PTR_hi2c1_080040b4, device_address, register_address, 1, byte_buffer, 1, 200);\n  if (status != HAL_OK) {\n    _Error_Handler(file_name, line_number);\n  }\n  return byte_buffer[0];\n}",
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800407c",
            "calling": [
                "MPU9250_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray",
                "AK8963_Init"
            ],
            "imported": false,
            "current_name": "read_i2c_byte_0800407c"
        },
        "FUN_08001938": {
            "renaming": {
                "FUN_08001938": "FUNC_08001938"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nHAL_StatusTypeDef\nFUNC_08001938(I2C_HandleTypeDef *hi2c,uint16_t DevAddress,uint16_t MemAddress,uint16_t MemAddSize\n                ,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  uint8_t *puVar1;\n  HAL_StatusTypeDef HVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  I2C_TypeDef *pIVar5;\n  uint uVar6;\n  uint8_t *puVar7;\n  bool bVar8;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  \n  if (hi2c->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  uVar3 = HAL_GetTick();\n  while (pIVar5 = hi2c->Instance, (~pIVar5->SR2 & 2) == 0) {\n    uVar4 = HAL_GetTick();\n    if (10000 < uVar4 - uVar3) {\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (hi2c->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  uVar6 = pIVar5->CR1;\n  hi2c->Lock = HAL_LOCKED;\n  pIVar5->CR1 = uVar6 & 0xfffff7ff;\n  hi2c->State = HAL_I2C_STATE_BUSY_RX;\n  hi2c->Mode = HAL_I2C_MODE_MEM;\n  hi2c->ErrorCode = 0;\n  HVar2 = I2C_RequestMemoryRead(hi2c,DevAddress,MemAddress,MemAddSize,Timeout);\n  if (HVar2 != HAL_OK) {\n    hi2c->Lock = HAL_UNLOCKED;\n    if (hi2c->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  pIVar5 = hi2c->Instance;\n  uVar6 = pIVar5->CR1;\n  if (Size == 1) {\n    pIVar5->CR1 = uVar6 & 0xfffffbff;\n    disableIRQinterrupts();\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    HVar2 = I2C_WaitOnRXNEFlagUntilTimeout(hi2c,Timeout);\n    if (HVar2 == HAL_OK) {\n      *pData = (uint8_t)hi2c->Instance->DR;\nLAB_08001ab8:\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      hi2c->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (hi2c->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (Size == 2) {\n    pIVar5->CR1 = uVar6 | 0x800;\n    disableIRQinterrupts();\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    pIVar5->CR1 = uVar6 | 0x400;\n    while (3 < Size) {\n      HVar2 = I2C_WaitOnRXNEFlagUntilTimeout(hi2c,Timeout);\n      if (HVar2 != HAL_OK) goto LAB_08001a18;\n      *pData = (uint8_t)hi2c->Instance->DR;\n      pIVar5 = hi2c->Instance;\n      bVar8 = (int)(pIVar5->SR1 << 0x1d) < 0;\n      if (bVar8) {\n        pIVar5 = (I2C_TypeDef *)pIVar5->DR;\n        puVar7 = pData + 2;\n        Size = Size - 2;\n      }\n      else {\n        puVar7 = pData + 1;\n        Size = Size - 1;\n      }\n      puVar1 = pData + 1;\n      pData = puVar7;\n      if (bVar8) {\n        *puVar1 = (uint8_t)pIVar5;\n      }\n    }\n    if (Size != 2) {\n      uVar3 = HAL_GetTick();\n      do {\n        pIVar5 = hi2c->Instance;\n        do {\n          if ((int)(pIVar5->SR1 << 0x1d) < 0) {\n            pIVar5->CR1 = pIVar5->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *pData = (uint8_t)hi2c->Instance->DR;\n            uVar3 = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (Timeout == 0xffffffff);\n      } while ((Timeout != 0) && (uVar4 = HAL_GetTick(), uVar4 - uVar3 <= Timeout));\n      goto LAB_08001afa;\n    }\n  }\n  uVar3 = HAL_GetTick();\n  do {\n    do {\n      if ((int)(hi2c->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        pIVar5 = hi2c->Instance;\n        pIVar5->CR1 = pIVar5->CR1 | 0x200;\n        *pData = (uint8_t)pIVar5->DR;\n        enableIRQinterrupts();\n        pData[1] = (uint8_t)hi2c->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (Timeout == 0xffffffff);\n  } while ((Timeout != 0) && (uVar4 = HAL_GetTick(), uVar4 - uVar3 <= Timeout));\nLAB_08001afa:\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    pIVar5 = hi2c->Instance;\n    do {\n      if ((int)(pIVar5->SR1 << 0x1d) < 0) {\n        pIVar5->CR1 = pIVar5->CR1 | 0x200;\n        pData[1] = (uint8_t)pIVar5->DR;\n        enableIRQinterrupts();\n        pData[2] = (uint8_t)hi2c->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (Timeout == 0xffffffff);\n  } while ((Timeout != 0) && (uVar4 = HAL_GetTick(), uVar4 - uVar3 <= Timeout));\n  goto LAB_08001afa;\n}\n\n",
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryRead"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001938",
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "imported": false,
            "current_name": "FUNC_08001938"
        },
        "FUN_080022d0": {
            "renaming": {
                "FUN_080022d0": "set_timer_output_compare_080022d0",
                "TIMx": "timer",
                "OC_Config": "config",
                "uVar1": "ccer_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode",
                "DAT_08002320": "PTR_08002320",
                "CCER": "ccer_mask",
                "OCMode": "oc_mode",
                "OCPolarity": "oc_polarity",
                "OCNPolarity": "ocn_polarity",
                "CR2": "cr2_value",
                "OCIdleState": "oc_idle_state",
                "OCNIdleState": "ocn_idle_state",
                "CCMR2": "ccmr2_value",
                "Pulse": "pulse_value"
            },
            "code": "void set_timer_output_compare_080022d0(TIM_TypeDef *timer, TIM_OC_InitTypeDef *config)\n{\n  uint32_t ccer_mask = 0xfffffeff;\n  uint32_t cr2_value = timer->CR2;\n  uint oc_mode = config->OCMode;\n  uint32_t ccer_value = (timer->CCER & 0xfffffdff) | (config->OCPolarity << 8);\n  if (timer == DAT_08002320) {\n    ccer_value = (ccer_value & 0xfffff7ff) | (config->OCNPolarity << 8);\n    cr2_value = (cr2_value & 0xffffcfff) | ((config->OCIdleState | config->OCNIdleState) << 4);\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR2 = (timer->CCMR2 & 0xffffff8c) | oc_mode;\n  timer->CCR3 = config->Pulse;\n  timer->CCER = ccer_value;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022d0",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "set_timer_output_compare_080022d0"
        },
        "FUN_080010c4": {
            "renaming": {
                "FUN_080010c4": "check_valid_number_080010c4",
                "param_1": "number",
                "uVar1": "shift_distance",
                "result": "result"
            },
            "code": "uint check_valid_number_080010c4(uint number) {\n  uint result;\n  \n  if (((number & 0x80000000) != 0) || (number << 1 < 0x7f000000)) {\n    return 0;\n  }\n  uint shift_value = (number << 1) >> 0x18;\n  uint shift_distance = 0x9e - shift_value;\n  if (-1 < (int)shift_distance) {\n    result = (number << 8 | 0x80000000) >> (shift_distance & 0xff);\n  }\n  else {\n    if ((shift_distance == 0xffffff9f) && ((number & 0x7fffff) != 0)) {\n      return 0;\n    }\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080010c4",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "check_valid_number_080010c4"
        },
        "FUN_0800245c": {
            "renaming": {
                "FUN_0800245c": "configure_tim_oc_0800245c",
                "htim": "tim_handle",
                "sConfig": "oc_config",
                "Channel": "channel",
                "extraout_r1": "extraout_r1",
                "extraout_r1_00": "extraout_r1_00",
                "extraout_r1_01": "extraout_r1_01",
                "uVar1": "uVar1",
                "extraout_r1_02": "extraout_r1_02",
                "iVar2": "iVar2",
                "uVar3": "ccmr1_val",
                "pTVar4": "tim_instance"
            },
            "code": "HAL_StatusTypeDef configure_tim_oc_0800245c(TIM_HandleTypeDef *tim_handle, TIM_OC_InitTypeDef *oc_config, uint32_t channel)\n{\n  int extraout_r1;\n  int extraout_r1_00;\n  int extraout_r1_01;\n  uint32_t uVar1;\n  int extraout_r1_02;\n  int iVar2;\n  uint32_t ccmr1_val;\n  uint32_t ccmr2_val;\n  TIM_TypeDef *tim_instance;\n  if (tim_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  tim_handle->State = HAL_TIM_STATE_BUSY;\n  tim_handle->Lock = HAL_LOCKED;\n  switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(tim_handle->Instance, oc_config);\n      tim_instance = tim_handle->Instance;\n      uVar1 = *(uint *)(extraout_r1 + 0x10);\n      tim_instance->CCMR1 = tim_instance->CCMR1 | 8;\n      tim_instance->CCMR1 = tim_instance->CCMR1 & 0xfffffffb;\n      ccmr1_val = tim_instance->CCMR1 | uVar1;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(tim_handle->Instance, oc_config);\n      tim_instance = tim_handle->Instance;\n      iVar2 = *(int *)(extraout_r1_00 + 0x10);\n      tim_instance->CCMR1 = tim_instance->CCMR1 | 0x800;\n      tim_instance->CCMR1 = tim_instance->CCMR1 & 0xfffffbff;\n      ccmr1_val = tim_instance->CCMR1 | iVar2 << 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(tim_handle->Instance, oc_config);\n      tim_instance = tim_handle->Instance;\n      uVar1 = *(uint *)(extraout_r1_01 + 0x10);\n      tim_instance->CCMR2 = tim_instance->CCMR2 | 8;\n      tim_instance->CCMR2 = tim_instance->CCMR2 & 0xfffffffb;\n      ccmr2_val = tim_instance->CCMR2 | uVar1;\n      goto LAB_080024fa;\n    case 0xc:\n      TIM_OC4_SetConfig(tim_handle->Instance, oc_config);\n      tim_instance = tim_handle->Instance;\n      iVar2 = *(int *)(extraout_r1_02 + 0x10);\n      tim_instance->CCMR2 = tim_instance->CCMR2 | 0x800;\n      tim_instance->CCMR2 = tim_instance->CCMR2 & 0xfffffbff;\n      ccmr2_val = tim_instance->CCMR2 | iVar2 << 8;\nLAB_080024fa:\n      tim_instance->CCMR2 = ccmr2_val;\n      break;\n    default:\n      tim_instance = tim_handle->Instance;\n      ccmr1_val = tim_instance->CCMR1 | uVar1;\n      break;\n  }\n  tim_instance->CCMR1 = ccmr1_val;\n  tim_handle->State = HAL_TIM_STATE_READY;\n  tim_handle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800245c",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configure_tim_oc_0800245c"
        },
        "FUN_080008f4": {
            "renaming": {
                "FUN_080008f4": "check_parameters_080008f4",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result",
                "bVar2": "is_invalid",
                "bVar3": "is_param4_greater"
            },
            "code": "uint check_parameters_080008f4(uint param1, uint param2, uint param3, uint param4)\n{\n  uint result;\n  bool is_invalid;\n  bool are_equal;\n  if (((int)(param2 << 1) >> 0x15 == -1 || (int)(param4 << 1) >> 0x15 == -1) && ((((int)(param2 << 1) >> 0x15 == -1 && ((param1 | param2 << 0xc) != 0)) || (((int)(param4 << 1) >> 0x15 == -1 && ((param3 | param4 << 0xc) != 0))))){\n    return 0xffffffff;\n  }\n  is_invalid = (param1 | param2 << 1) == 0;\n  if (is_invalid) {\n    is_invalid = (param3 | param4 << 1) == 0;\n  }\n  if (!is_invalid) {\n    are_equal = param2 == param4;\n    if (are_equal) {\n      are_equal = param1 == param3;\n    }\n    if (!are_equal) {\n      uint uVar1 = param2 ^ param4;\n      is_invalid = uVar1 == 0;\n      if (-1 < (int)uVar1) {\n        is_invalid = param2 == param4;\n      }\n      bool is_param4_greater = -1 < (int)uVar1 && param4 <= param2;\n      if (is_invalid) {\n        is_param4_greater = param3 <= param1;\n      }\n      param4 = (int)param4 >> 0x1f;\n      if (!is_param4_greater) {\n        param4 = ~param4;\n      }\n      result = param4 | 1;\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008f4",
            "calling": [],
            "imported": false,
            "current_name": "check_parameters_080008f4"
        },
        "FUN_08004e14": {
            "renaming": {
                "FUN_08004e14": "set_gpio_pin_mode_08004e14",
                "*htim": "*timer_handler",
                "pGVar1": "gpio_port",
                "pTVar2": "timer_instance",
                "GPIO_InitStruct": "gpio_init_struct",
                "DAT_08004e6c": "gpio_port_1",
                "DAT_08004e68": "timer_instance_1",
                "(TIM_TypeDef *)0x40000000": "timer_instance_4",
                "GPIO_InitStruct.Pin = 0x800": "gpio_init_struct.Pin = GPIO_PIN_11",
                "GPIO_InitStruct.Pin = 2": "gpio_init_struct.Pin = GPIO_PIN_1",
                "DAT_08004e74": "gpio_port_2",
                "DAT_08004e70": "timer_instance_2",
                "GPIO_InitStruct.Pin = 3": "gpio_init_struct.Pin = GPIO_PIN_2",
                "DAT_08004e78": "timer_instance_3",
                "GPIO_InitStruct.Pin = 0x300": "gpio_init_struct.Pin = GPIO_PIN_8 | GPIO_PIN_9"
            },
            "code": "void set_gpio_pin_mode_08004e14(TIM_HandleTypeDef *timer_handler)\n{\n  GPIO_TypeDef *gpio_port;\n  TIM_TypeDef *timer_instance;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  timer_instance = timer_handler->Instance;\n  gpio_port = DAT_08004e6c;\n  if (timer_instance == DAT_08004e68) {\n    gpio_init_struct.Pin = GPIO_PIN_11;\n  }\n  else if (timer_instance == (TIM_TypeDef *)0x40000000) {\n    gpio_init_struct.Pin = GPIO_PIN_1;\n  }\n  else {\n    gpio_port = DAT_08004e74;\n    if (timer_instance == DAT_08004e70) {\n      gpio_init_struct.Pin = GPIO_PIN_2;\n    }\n    else {\n      if (timer_instance != DAT_08004e78) {\n        return;\n      }\n      gpio_init_struct.Pin = GPIO_PIN_8 | GPIO_PIN_9;\n    }\n  }\n  gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;\n  gpio_init_struct.Mode = GPIO_MODE_AF_PP;\n  HAL_GPIO_Init(gpio_port, &gpio_init_struct);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e14",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_mode_08004e14"
        },
        "FUN_08002ea0": {
            "renaming": {
                "FUN_08002ea0": "initialize_sensors_08002ea0",
                "_beta": "beta_value",
                "_deltat": "delta_time"
            },
            "code": "void initialize_sensors_08002ea0(void)\n{\n  float beta_value;\n  float delta_time;\n  MPU9250_Init();\n  AK8963_Init();\n  MadgwickSetBeta(beta_value);\n  MadgwickSetDelta(delta_time);\n  return;\n}",
            "called": [
                "MPU9250_Init",
                "MadgwickSetBeta",
                "MadgwickSetDelta",
                "AK8963_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ea0",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_sensors_08002ea0"
        },
        "FUN_08001424": {
            "renaming": {
                "FUN_08001424": "set_gpio_pin_state_08001424",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "uVar1": "pin_mask"
            },
            "code": "void set_gpio_pin_state_08001424(GPIO_TypeDef *gpio, uint16_t pin, GPIO_PinState state)\n{\n  uint32_t pin_mask = (uint32_t)pin;\n  if (state == GPIO_PIN_RESET) {\n    pin_mask <<= 0x10;\n  }\n  gpio->BSRR = pin_mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001424",
            "calling": [
                "toggleLED",
                "_Error_Handler",
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_08001424"
        },
        "FUN_08002998": {
            "renaming": {
                "FUN_08002998": "do_nothing_08002998"
            },
            "code": "\nvoid do_nothing_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002998",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08002998"
        },
        "FUN_08005900": {
            "renaming": {
                "FUN_08005900": "FUNC_08005900"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\ndouble FUNC_08005900(double __x,double __y)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  undefined4 *puVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 uVar7;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  double extraout_d0_02;\n  double extraout_d0_03;\n  double extraout_d0_04;\n  double extraout_d0_05;\n  double extraout_d0_06;\n  double extraout_d0_07;\n  double extraout_d0_08;\n  double extraout_d0_09;\n  double extraout_d0_10;\n  double extraout_d0_11;\n  double extraout_d0_12;\n  double dVar8;\n  undefined8 uVar9;\n  undefined local_50 [24];\n  undefined8 local_38;\n  int local_30;\n  \n  dVar8 = (double)__ieee754_FUNC_08005900();\n  puVar2 = PTR___fdlib_version_08005ba8;\n  cVar1 = *PTR___fdlib_version_08005ba8;\n  if (cVar1 == -1) {\n    return extraout_d0;\n  }\n  local_30 = __unorddf2();\n  if (local_30 != 0) {\n    return extraout_d0_00;\n  }\n  iVar3 = __unorddf2();\n  if (iVar3 != 0) {\n    iVar3 = __aeabi_dcmpeq();\n    if (iVar3 == 0) {\n      return extraout_d0_01;\n    }\n    local_50._0_4_ = 1;\n    local_50._4_4_ = PTR_DAT_08005bac;\n    local_38 = (double)((ulonglong)DAT_08005bb0 << 0x20);\n    if (cVar1 == '\\x02') {\n      return extraout_d0_01;\n    }\n    goto LAB_08005978;\n  }\n  iVar4 = __aeabi_dcmpeq();\n  if (iVar4 == 0) {\n    iVar3 = finite(dVar8);\n    if ((iVar3 == 0) && (iVar4 = finite(dVar8), iVar4 != 0)) {\n      iVar4 = finite(dVar8);\n      if (iVar4 == 0) goto LAB_08005b4c;\n      local_30 = __unorddf2(SUB84(dVar8,0),(int)((ulonglong)dVar8 >> 0x20));\n      cVar1 = *puVar2;\n      if (local_30 != 0) {\n        local_50._4_4_ = PTR_DAT_08005bac;\n        local_50._0_4_ = 1;\n        local_30 = iVar3;\n        if (cVar1 == '\\0') goto LAB_08005a22;\n        local_38 = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      local_50._4_4_ = PTR_DAT_08005bac;\n      local_50._0_4_ = 3;\n      if (cVar1 != '\\0') {\n        local_38._0_4_ = 0;\n        local_38._4_4_ = DAT_08005bc4;\n        iVar3 = __aeabi_dcmplt();\n        if (iVar3 != 0) {\n          uVar9 = __muldf3();\n          uVar7 = (int)uVar9;\n          rint(dVar8);\n          iVar3 = __aeabi_dcmpeq((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar7,extraout_r1_00);\n          if (iVar3 == 0) {\n            local_38._0_4_ = 0;\n            local_38._4_4_ = DAT_08005bb4;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      local_38._0_4_ = 0xe0000000;\n      local_38._4_4_ = DAT_08005bb8;\n      iVar3 = __aeabi_dcmplt();\n      if (iVar3 != 0) {\n        uVar9 = __muldf3();\n        uVar7 = (int)uVar9;\n        rint(dVar8);\n        iVar3 = __aeabi_dcmpeq((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar7,extraout_r1);\n        if (iVar3 == 0) {\n          local_38._0_4_ = 0xe0000000;\n          local_38._4_4_ = DAT_08005bc0;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      iVar3 = matherr((exception *)local_50);\n      dVar8 = extraout_d0_12;\n      if (iVar3 != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      iVar3 = __aeabi_dcmpeq(SUB84(dVar8,0),(int)((ulonglong)dVar8 >> 0x20),0,0);\n      if (iVar3 == 0) {\n        return extraout_d0_09;\n      }\n      iVar3 = finite(dVar8);\n      if (iVar3 == 0) {\n        return extraout_d0_10;\n      }\n      iVar3 = finite(dVar8);\n      if (iVar3 == 0) {\n        return extraout_d0_11;\n      }\n      local_50._0_4_ = 4;\n      local_50._4_4_ = PTR_DAT_08005bac;\n      local_30 = 0;\n      local_38._0_4_ = 0;\n      local_38._4_4_ = 0;\nLAB_08005afa:\n      if (*puVar2 != '\\x02') goto LAB_08005b98;\n    }\n    puVar6 = (undefined4 *)__errno();\n    uVar7 = 0x22;\n    dVar8 = extraout_d0_08;\n  }\n  else {\n    local_30 = __aeabi_dcmpeq();\n    if (local_30 == 0) {\n      iVar3 = finite(dVar8);\n      if (iVar3 == 0) {\n        return extraout_d0_05;\n      }\n      iVar3 = __aeabi_dcmplt();\n      if (iVar3 == 0) {\n        return extraout_d0_06;\n      }\n      local_50._0_4_ = 1;\n      local_50._4_4_ = PTR_DAT_08005bac;\n      cVar1 = *puVar2;\n      if (cVar1 == '\\0') {\nLAB_08005a22:\n        local_50._0_4_ = 1;\n        local_38 = 0.0;\n        local_50._4_4_ = PTR_DAT_08005bac;\n        goto LAB_08005978;\n      }\n      local_38 = (double)((ulonglong)DAT_08005bb4 << 0x20);\nLAB_08005a32:\n      if (cVar1 != '\\x02') goto LAB_08005978;\n    }\n    else {\n      local_50._0_4_ = 1;\n      local_50._4_4_ = PTR_DAT_08005bac;\n      local_38 = 0.0;\n      local_30 = iVar3;\n      if (cVar1 != '\\0') {\n        local_38 = (double)((ulonglong)DAT_08005bb0 << 0x20);\n        dVar8 = extraout_d0_03;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      iVar3 = matherr((exception *)local_50);\n      dVar8 = extraout_d0_02;\n      if (iVar3 != 0) goto LAB_080059d0;\n    }\n    puVar6 = (undefined4 *)__errno();\n    uVar7 = 0x21;\n    dVar8 = extraout_d0_07;\n  }\n  *puVar6 = uVar7;\nLAB_080059d0:\n  if (local_30 != 0) {\n    piVar5 = (int *)__errno();\n    *piVar5 = local_30;\n    dVar8 = extraout_d0_04;\n  }\n  return dVar8;\n}\n\n",
            "called": [
                "__divdf3",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__aeabi_dcmpeq",
                "__muldf3",
                "finite",
                "matherr",
                "rint",
                "__errno",
                "__ieee754_pow"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005900",
            "calling": [
                "MS5611_Update"
            ],
            "imported": false,
            "current_name": "FUNC_08005900"
        },
        "FUN_08004c64": {
            "renaming": {
                "FUN_08004c64": "initialize_circular_buffer_08004c64",
                "PTR_rxc_08004c6c": "circular_buffer_rx"
            },
            "code": "void initialize_circular_buffer_08004c64(void)\n{\n  CB_Init(&PTR_rxc_08004c6c);\n  return;\n}",
            "called": [
                "CB_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c64",
            "calling": [
                "serialBegin"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_08004c64"
        },
        "FUN_080041e4": {
            "renaming": {
                "FUN_080041e4": "set_motor_pwm_080041e4",
                "m1": "motor1_pwm",
                "m2": "motor2_pwm",
                "m3": "motor3_pwm",
                "m4": "motor4_pwm",
                "puVar1": "motor_pwm_ptr",
                "puVar2": "msp_txf_motor_ptr",
                "pwm": "pwm_val"
            },
            "code": "void set_motor_pwm_080041e4(int motor1_pwm, int motor2_pwm, int motor3_pwm, int motor4_pwm)\n{\n  uint32_t pwm;\n  if (motor1_pwm > 999) {\n    motor1_pwm = 1000;\n  }\n  if (motor2_pwm > 999) {\n    motor2_pwm = 1000;\n  }\n  if (motor3_pwm > 999) {\n    motor3_pwm = 1000;\n  }\n  if (motor4_pwm > 999) {\n    motor4_pwm = 1000;\n  }\n  pwm = motor1_pwm & ~(motor1_pwm >> 0x1f);\n  *(int *)(PTR_motor_pwm_08004264 + 8) = motor3_pwm & ~(motor3_pwm >> 0x1f);\n  *(int *)(PTR_motor_pwm_08004264 + 0xc) = motor4_pwm & ~(motor4_pwm >> 0x1f);\n  *(int *)(PTR_motor_pwm_08004264 + 4) = motor2_pwm & ~(motor2_pwm >> 0x1f);\n  *(uint32_t *)PTR_motor_pwm_08004264 = pwm;\n  Motor1_SetPWM(pwm);\n  Motor2_SetPWM(*(int *)(PTR_motor_pwm_08004264 + 4));\n  Motor3_SetPWM(*(int *)(PTR_motor_pwm_08004264 + 8));\n  Motor4_SetPWM(*(int *)(PTR_motor_pwm_08004264 + 0xc));\n  *(short *)PTR_msp_txf_motor_08004268 = (short)*(int *)PTR_motor_pwm_08004264 + 1000;\n  *(short *)(PTR_msp_txf_motor_08004268 + 2) = (short)*(int *)(PTR_motor_pwm_08004264 + 4) + 1000;\n  *(short *)(PTR_msp_txf_motor_08004268 + 4) = (short)*(int *)(PTR_motor_pwm_08004264 + 8) + 1000;\n  *(short *)(PTR_msp_txf_motor_08004268 + 6) = (short)*(int *)(PTR_motor_pwm_08004264 + 0xc) + 1000;\n}",
            "called": [
                "Motor2_SetPWM",
                "Motor1_SetPWM",
                "Motor4_SetPWM",
                "Motor3_SetPWM"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041e4",
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "imported": false,
            "current_name": "set_motor_pwm_080041e4"
        },
        "FUN_080003e4": {
            "renaming": {
                "FUN_080003e4": "convert_to_64_bit_080003e4",
                "param_1": "input",
                "uVar1": "result_high",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeros",
                "uVar4": "overflow_bits",
                "in_r12": "shifted_overflow",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "overflowed",
                "SCARRY4": "signed_carry_4",
                "SBORROW4": "signed_borrow_4",
                "LAB_080002f0": "end_of_overflow_handling",
                "CONCAT44": "concatenate_44_bits",
                "0U": "unsigned_zero",
                "count_leading_zeroes": "count_leading_zeros"
            },
            "code": "unsigned long long convert_to_64_bit_080003e4(uint32_t input){\n  uint32_t leading_zeros = count_leading_zeroes(input);\n  uint32_t shift_amount = leading_zeros + 21;\n  uint32_t overflow_bits = shift_amount - 32;\n  uint32_t shifted_input = input << (shift_amount & 0xff);\n  uint32_t shifted_overflow = 0;\n  if(shift_amount < 32){\n    shifted_overflow = 0U >> (overflow_bits & 0xff);\n    shifted_input |= shifted_overflow;\n  }\n  unsigned long long result = 0;\n  if(shift_amount < 1075){\n    result = ((unsigned long long)(shifted_input + (1074 - shift_amount) * 0x100000)) << 32;\n  }else{\n    uint32_t underflow_bits = ~(1074 - shift_amount);\n    if(30 < underflow_bits){\n      result = (unsigned long long)(shifted_input >> (underflow_bits - 31 & 0xff));\n    }else{\n      int32_t shifted_u = underflow_bits - 19;\n      if(shifted_u == 0 || shifted_u < 0 != (shift_amount - 31 < 0)){\n        underflow_bits++;\n        result = (unsigned long long)(shifted_input >> (underflow_bits & 0xff));\n        result |= (unsigned long long)(shifted_input << (32 - underflow_bits & 0xff));\n      }else{\n        result = (unsigned long long)(shifted_input >> (32 - (shift_amount - 19) & 0xff));\n        result |= (unsigned long long)(shifted_input << (shift_amount - 19 & 0xff));\n      }\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003e4",
            "calling": [],
            "imported": false,
            "current_name": "convert_to_64_bit_080003e4"
        },
        "FUN_08007092": {
            "renaming": {
                "FUN_08007092": "calculate_sign_bit_08007092",
                "__value": "value",
                "in_r1": "sign_bit"
            },
            "code": "int calculate_sign_bit_08007092(double value) {\n    uint32_t sign_bit = 0x80000000;\n    return (sign_bit | *(uint32_t*)&value) + 0x100000 >> 0x1f;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007092",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "calculate_sign_bit_08007092"
        },
        "FUN_08002f28": {
            "renaming": {
                "FUN_08002f28": "calculate_attitude_08002f28",
                "puVar2": "last_update_ptr",
                "puVar3": "time_now_ptr",
                "puVar4": "accel_raw_ptr",
                "uVar5": "roll/pitch/yaw",
                "uVar6": "time_now",
                "uVar7": "delta_t",
                "iVar8": "last_update",
                "_deltat": "delta_t",
                "ax": "accel_x",
                "ay": "accel_y",
                "az": "accel_z",
                "gx": "gyro_x",
                "gy": "gyro_y",
                "gz": "gyro_z",
                "mx": "mag_x",
                "my": "mag_y"
            },
            "code": "void calculate_attitude_08002f28() {\n  short accel_short;\n  undefined *last_update_ptr;\n  undefined *time_now_ptr;\n  undefined *accel_raw_ptr;\n  undefined *gyro_raw_ptr;\n  undefined *mag_raw_ptr;\n  undefined2 roll;\n  undefined2 pitch;\n  undefined2 yaw;\n  float delta_t;\n  float accel_x;\n  float accel_y;\n  float accel_z;\n  float gyro_x;\n  float gyro_y;\n  float gyro_z;\n  float mag_x;\n  float mag_y;\n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n  uint32_t time_now = micros();\n  time_now_ptr = PTR_AHRS_timeNow_08003004;\n  last_update_ptr = PTR_AHRS_lastUpdate_08003000;\n  int last_update = *(int *)last_update_ptr;\n  *(uint32_t *)time_now_ptr = time_now;\n  delta_t = (float)(time_now - last_update) / DAT_08003008;\n  MadgwickSetDelta(delta_t);\n  accel_raw_ptr = PTR_accelData_0800300c;\n  *(undefined4 *)last_update_ptr = *(undefined4 *)time_now_ptr;\n  MadgwickQuaternionUpdate(accel_x, accel_y, accel_z, gyro_x, gyro_y, gyro_z, mag_x, mag_y, (float)(*(int *)(accel_raw_ptr + 4) + -0x80000000), (float *)(*(int *)accel_raw_ptr + -0x80000000));\n  gyro_raw_ptr = PTR_gyroRaw_08003028;\n  mag_raw_ptr = PTR_magRaw_0800302c;\n  accel_short = *(short *)(accel_raw_ptr + 2);\n  *(short *)(PTR_msp_txf_raw_imu_08003020 + 4) = (short)((uint)(int)*(short *)(accel_raw_ptr + 4) / 100);\n  *(short *)PTR_msp_txf_raw_imu_08003020 = (short)((uint)(int)accel_short / 100);\n  *(undefined2 *)(PTR_msp_txf_raw_imu_08003020 + 6) = *(undefined2 *)gyro_raw_ptr;\n  *(undefined2 *)(PTR_msp_txf_raw_imu_08003020 + 8) = *(undefined2 *)(gyro_raw_ptr + 2);\n  *(undefined2 *)(PTR_msp_txf_raw_imu_08003020 + 10) = *(undefined2 *)(gyro_raw_ptr + 4);\n  *(undefined2 *)(PTR_msp_txf_raw_imu_08003020 + 0xc) = *(undefined2 *)mag_raw_ptr;\n  *(undefined2 *)(PTR_msp_txf_raw_imu_08003020 + 0xe) = *(undefined2 *)(mag_raw_ptr + 2);\n  roll = AHRS_GetRoll();\n  pitch = AHRS_GetPitch();\n  yaw = AHRS_GetYaw();\n  *(undefined2 *)PTR_msp_txf_attitude_08003024 = __aeabi_f2iz(roll);\n  *(undefined2 *)(PTR_msp_txf_attitude_08003024 + 2) = __aeabi_f2iz(pitch);\n  *(undefined2 *)(PTR_msp_txf_attitude_08003024 + 4) = __aeabi_f2iz(yaw);\n}",
            "called": [
                "AK8963_ReadData",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AHRS_GetRoll",
                "__aeabi_fdiv",
                "AHRS_GetYaw",
                "micros",
                "__aeabi_f2iz",
                "MPU9250_ReadAccelData",
                "__aeabi_fmul",
                "__floatunsisf",
                "MadgwickSetDelta",
                "MPU9250_ReadGyroData"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f28",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "calculate_attitude_08002f28"
        },
        "FUN_08004384": {
            "renaming": {
                "FUN_08004384": "send_msp_txf_status_frame_08004384",
                "puVar1": "msp_txf_status_ptr",
                "in_r3": "status_field_mask",
                "local_14": "frame_data",
                "uStack_10": "frame_length",
                "local_c": "status_field",
                "PTR_msp_txf_status_080043b8": "PTR_msp_txf_status_080043b8"
            },
            "code": "void send_msp_txf_status_frame_08004384(void)\n{\n  uint8_t *msp_txf_status_ptr;\n  uint32_t frame_data;\n  uint32_t frame_length;\n  uint32_t frame_type = 'e';\n  uint32_t frame_subtype = 0x2a;\n  uint32_t reserved_field_1 = 0;\n  uint32_t reserved_field_2 = 0;\n  uint32_t reserved_field_3 = 0;\n  uint32_t status_field = 7;\n  uint32_t status_field_padding = 0;\n  uint32_t status_field_length = 2;\n  uint32_t status_field_mask = 0xff000000;\n  msp_txf_status_ptr = PTR_msp_txf_status_080043b8;\n  msp_txf_status_ptr[4] = status_field;\n  msp_txf_status_ptr[5] = status_field_padding;\n  msp_txf_status_ptr[6] = frame_subtype;\n  msp_txf_status_ptr[7] = reserved_field_1;\n  frame_data = *(uint32_t *)msp_txf_status_ptr;\n  frame_length = *(uint32_t *)(msp_txf_status_ptr + 4);\n  msp_txf_status_ptr[8] = reserved_field_2;\n  msp_txf_status_ptr[9] = reserved_field_3;\n  msp_txf_status_ptr[10] = status_field_length;\n  frame_data &= status_field_mask;\n  frame_data |= (uint32_t)*(uint16_t *)(msp_txf_status_ptr + 8);\n  MSP_SendFrame(frame_type, (uint8_t *)&frame_data, frame_length);\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004384",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_msp_txf_status_frame_08004384"
        },
        "FUN_080009a0": {
            "renaming": {
                "FUN_080009a0": "check_if_not_equal_080009a0",
                "in_ZR": "input_char"
            },
            "code": "bool check_if_not_equal_080009a0(char input_char)\n{\n  __aeabi_cdcmpeq();\n  return input_char != '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009a0",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "check_if_not_equal_080009a0"
        },
        "FUN_08003298": {
            "renaming": {
                "FUN_08003298": "read_MS5611_coefficients_08003298",
                "rxbuf": "rx_buffer",
                "iVar3": "coefficient_index",
                "PTR_MS5611_Coefficients_0800330c": "MS5611_coefficients",
                "PTR_s____Src_MS5611_c_08003308": "MS5611_coefficients",
                "PTR_MS5611_OSR_08003304": "coefficient_oversampling_ratio",
                "PTR_alt_filter_08003310": "alt_filter"
            },
            "code": "void read_MS5611_coefficients_08003298() {\n    uint8_t rx_buffer[2];\n    int coefficient_index = 0;\n    I2C_WriteByte(0xee, 0x1e, 0x01, 0x01);\n    delay_ms(10);\n    for (int i = 0; i < 16; i++) {\n        rx_buffer[0] = 0;\n        rx_buffer[1] = 0;\n        I2C_ReadByteArray(0xee, i + 0xa0, rx_buffer, 2, PTR_MS5611_Coefficients_0800330c, 0x7c);\n        coefficients[coefficient_index] = (rx_buffer[0] << 8) | rx_buffer[1];\n        coefficient_index += 1;\n    }\n    for (int i = 0; i < 20; i++) {\n        PTR_alt_filter_08003310[i] = 0;\n    }\n}",
            "called": [
                "I2C_ReadByteArray",
                "delay_ms",
                "I2C_WriteByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003298",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "read_MS5611_coefficients_08003298"
        },
        "FUN_08004028": {
            "renaming": {
                "FUN_08004028": "initialize_peripherals_and_leds_08004028",
                "Peripherals_Init": "initialize_peripherals",
                "PWM_Init": "initialize_pwm",
                "LED_StartupSequence": "start_led_startup_sequence"
            },
            "code": "void initialize_peripherals_and_leds_08004028(void)\n{\n  initialize_peripherals();\n  initialize_pwm();\n  start_led_startup_sequence();\n  return;\n}",
            "called": [
                "LED_StartupSequence",
                "PWM_Init",
                "Peripherals_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004028",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_peripherals_and_leds_08004028"
        },
        "FUN_0800708c": {
            "renaming": {
                "FUN_0800708c": "calculate_0800708c",
                "__x": "input",
                "in_d0": "result"
            },
            "code": "double calculate_0800708c(double input){\n  double result;\n  // perform calculations here\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800708c",
            "calling": [
                "asin",
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_0800708c"
        },
        "FUN_08002520": {
            "renaming": {
                "FUN_08002520": "set_channel_state_08002520",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channel_state",
                "PTR_": "ptr_",
                "DAT_": "dat_",
                "CCER": "ccer"
            },
            "code": "void set_channel_state_08002520(TIM_TypeDef *timer, uint32_t channel, uint32_t channel_state) {\n  uint32_t mask = ~(1 << (channel & 0xff));\n  uint32_t shifted_state = channel_state << (channel & 0xff);\n  timer->CCER = (timer->CCER & mask) | shifted_state;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002520",
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "set_channel_state_08002520"
        },
        "FUN_08000464": {
            "renaming": {
                "FUN_08000464": "convert_uints_to_ulonglong_08000464",
                "param_1": "first_uint",
                "param_2": "second_uint",
                "iVar7": "int_var2",
                "uVar8": "uint_var5",
                "uVar4": "uint_var3",
                "iVar5": "int_var1",
                "bVar1": "byte_var",
                "uVar2": "uint_var1",
                "bVar9": "bool_var1",
                "bVar10": "bool_var2",
                "bVar11": "bool_var3"
            },
            "code": "ulonglong convert_uints_to_ulonglong_08000464(uint first_uint, uint second_uint)\n{\n    byte byte_var;\n    uint uint_var1;\n    uint uint_var2;\n    uint uint_var3;\n    int int_var1;\n    uint uint_var4;\n    int int_var2;\n    uint uint_var5;\n    bool bool_var1;\n    bool bool_var2;\n    bool bool_var3;\n\n    if ((first_uint | second_uint) == 0)\n    {\n        return CONCAT44(second_uint, first_uint);\n    }\n\n    int_var2 = 0x432;\n    uint_var5 = second_uint >> 0x16;\n\n    if (uint_var5 != 0)\n    {\n        int_var2 = 3;\n\n        if (second_uint >> 0x19 != 0)\n        {\n            int_var2 = 6;\n        }\n\n        if (second_uint >> 0x1c != 0)\n        {\n            int_var2 += 3;\n        }\n\n        uint_var3 = int_var2 - ((int)second_uint >> 0x1f);\n        uint_var5 = first_uint << (0x20 - uint_var3 & 0xff);\n        first_uint = first_uint >> (uint_var3 & 0xff) | second_uint << (0x20 - uint_var3 & 0xff);\n        second_uint = second_uint >> (uint_var3 & 0xff);\n        int_var2 = uint_var3 + 0x432;\n    }\n\n    if (0xfffff < second_uint)\n    {\n        if (0x1fffff < second_uint)\n        {\n            uint_var3 = second_uint & 1;\n            second_uint = second_uint >> 1;\n            byte_var = (byte)first_uint;\n            first_uint = (uint)(uint_var3 != 0) << 0x1f | first_uint >> 1;\n            uint_var5 = (uint)(byte_var & 1) << 0x1f | uint_var5 >> 1;\n            int_var2 += 1;\n\n            if (0xffbfffff < (uint)(int_var2 * 0x200000))\n            {\n                return 0x7ff0000000000000;\n            }\n        }\n\n        bool_var2 = 0x7fffffff < uint_var5;\n\n        if (uint_var5 == 0x80000000)\n        {\n            bool_var2 = (first_uint & 1) != 0;\n        }\n\n        return CONCAT44(second_uint + int_var2 * 0x100000 + (uint)CARRY4(first_uint, (uint)bool_var2), first_uint + bool_var2);\n    }\n\n    bool_var1 = (uint_var5 & 0x80000000) != 0;\n    uint_var5 = uint_var5 << 1;\n    uint_var3 = first_uint * 2;\n    bool_var2 = CARRY4(first_uint, first_uint);\n    first_uint = first_uint * 2 + (uint)bool_var1;\n    second_uint = second_uint * 2 + (uint)(bool_var2 || CARRY4(uint_var3, (uint)bool_var1));\n    int_var2 += -1;\n\n    if ((second_uint & 0x100000) != 0)\n    {\n        goto LAB_08000278;\n    }\n\n    uint_var1 = first_uint;\n    uint_var3 = second_uint;\n\n    if (second_uint == 0)\n    {\n        uint_var1 = 0;\n        uint_var3 = first_uint;\n    }\n\n    int_var1 = count_leading_zeroes(uint_var3);\n\n    if (second_uint == 0)\n    {\n        int_var1 += 0x20;\n    }\n\n    uint_var4 = int_var1 - 0xb;\n    bool_var3 = SBORROW4(uint_var4, 0x20);\n    uint_var2 = int_var1 - 0x2b;\n    bool_var2 = (int)uint_var2 < 0;\n    bool_var1 = uint_var2 == 0;\n\n    if ((int)uint_var4 < 0x20)\n    {\n        bool_var3 = SCARRY4(uint_var2, 0xc);\n        int_var1 += -0x1f;\n        bool_var2 = int_var1 < 0;\n        bool_var1 = int_var1 == 0;\n        uint_var4 = uint_var4;\n\n        if (!bool_var1 && bool_var2 == bool_var3)\n        {\n            uint_var5 = uint_var3 << (uint_var4 & 0xff);\n            uint_var3 = uint_var3 >> (0xcU - int_var1 & 0xff);\n            goto LAB_080002f0;\n        }\n    }\n\n    if (bool_var1 || bool_var2 != bool_var3)\n    {\n        uint_var5 = 0x20 - uint_var4;\n    }\n\n    uint_var3 = uint_var3 << (uint_var4 & 0xff);\n\n    if (bool_var1 || bool_var2 != bool_var3)\n    {\n        uint_var3 |= uint_var1 >> (uint_var5 & 0xff);\n    }\n\n    if (bool_var1 || bool_var2 != bool_var3)\n    {\n        uint_var1 = uint_var1 << (uint_var4 & 0xff);\n    }\n\nLAB_080002f0:\n\n    if ((int)uint_var4 <= int_var2)\n    {\n        return CONCAT44(uint_var3 + (int_var2 - uint_var4) * 0x100000, uint_var1);\n    }\n\n    uint_var5 = ~(int_var2 - uint_var4);\n\n    if (0x1e < (int)uint_var5)\n    {\n        return (ulonglong)(uint_var3 >> (uint_var5 - 0x1f & 0xff));\n    }\n\n    int_var2 = uint_var5 - 0x13;\n\n    if (int_var2 == 0 || int_var2 < 0 != SCARRY4(uint_var5 - 0x1f, 0xc))\n    {\n        uint_var5 += 1;\n        return CONCAT44(uint_var3 >> (uint_var5 & 0xff), uint_var1 >> (uint_var5 & 0xff) | uint_var3 << (0x20 - uint_var5 & 0xff));\n    }\n\n    return (ulonglong)(uint_var1 >> (0x20 - (0xcU - int_var2) & 0xff) | uint_var3 << (0xcU - int_var2 & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000464",
            "calling": [],
            "imported": false,
            "current_name": "convert_uints_to_ulonglong_08000464"
        },
        "FUN_08002404": {
            "renaming": {
                "FUN_08002404": "configure_timer_08002404",
                "TIMx": "timer",
                "OC_Config": "oc_config",
                "uVar1": "ccer_value",
                "uVar2": "cr2",
                "uVar3": "oc_mode"
            },
            "code": "void configure_timer_08002404(TIM_TypeDef *timer, TIM_OC_InitTypeDef *oc_config) {\n    uint32_t ccer_mask = 0xffffffef;\n    uint32_t cr2 = timer->CR2;\n    uint32_t oc_mode = oc_config->OCMode;\n    uint32_t ccer_value = (timer->CCER & 0xffffffdf) | (oc_config->OCPolarity << 4);\n    if (timer == PTR_08002458) {\n        ccer_value = (ccer_value & 0xffffff7f) | (oc_config->OCNPolarity << 4);\n        cr2 = (cr2 & 0xfffff3ff) | ((oc_config->OCIdleState | oc_config->OCNIdleState) << 2);\n    }\n    timer->CR2 = cr2;\n    timer->CCMR1 = (timer->CCMR1 & 0xffff8cff) | (oc_mode << 8);\n    timer->CCR2 = oc_config->Pulse;\n    timer->CCER = ccer_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002404",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08002404"
        },
        "FUN_08005bc8": {
            "renaming": {
                "FUN_08005bc8": "calculate_function_08005bc8",
                "__x": "input_value",
                "cVar1": "fdlib_version",
                "iVar2": "comparison_result",
                "piVar3": "errno_ptr_2",
                "puVar4": "errno_ptr",
                "dVar5": "result",
                "extraout_d0": "extraout_d0",
                "extraout_d0_00": "extraout_d0_00",
                "extraout_d0_01": "extraout_d0_01",
                "extraout_d0_02": "extraout_d0_02",
                "extraout_d0_03": "extraout_d0_03",
                "local_50": "math_error_info",
                "local_38": "math_error_arg",
                "local_30": "unordered_result"
            },
            "code": "double calculate_function_08005bc8(double input_value)\\n{\\n    double result;\\n    char fdlib_version;\\n    int unordered_result;\\n    int comparison_result;\\n    int math_error_result;\\n    undefined math_error_info[24];\\n    undefined8 math_error_arg;\\n    double extraout_d0;\\n    double extraout_d0_00;\\n    double extraout_d0_01;\\n    double extraout_d0_02;\\n    double extraout_d0_03;\\n\\n    result = (double)__ieee754_calculate_function_08005bc8();\\n    fdlib_version = *PTR___fdlib_version_08005c68;\\n    if (fdlib_version == -1) {\\n        return result;\\n    }\\n    unordered_result = __unorddf2();\\n    if (unordered_result != 0) {\\n        return extraout_d0;\\n    }\\n    comparison_result = __aeabi_dcmplt();\\n    if (comparison_result == 0) {\\n        return extraout_d0_00;\\n    }\\n    math_error_info._0_4_ = 1;\\n    math_error_info._4_4_ = PTR_DAT_08005c6c;\\n    if (fdlib_version == \"\\0\") {\\n        math_error_arg = 0.0;\\n    LAB_08005c26:\\n        math_error_result = matherr((exception *)math_error_info);\\n        result = extraout_d0_01;\\n        if (math_error_result != 0) goto LAB_08005c2e;\\n    }\\n    else {\\n        math_error_arg = (double)__divdf3(0,0,0,0);\\n        if (fdlib_version != \"\\x02\") goto LAB_08005c26;\\n    }\\n    undefined4 *errno_ptr = (undefined4 *)__errno();\\n    *errno_ptr = 0x21;\\n    result = extraout_d0_03;\\nLAB_08005c2e:\\n    if (unordered_result != 0) {\\n        int *errno_ptr_2 = (int *)__errno();\\n        *errno_ptr_2 = unordered_result;\\n        result = extraout_d0_02;\\n    }\\n    return result;\\n}",
            "called": [
                "__divdf3",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__ieee754_sqrt",
                "matherr",
                "__errno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bc8",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_function_08005bc8"
        },
        "FUN_08001436": {
            "renaming": {
                "FUN_08001436": "check_i2c_status_08001436",
                "*hi2c": "*i2c_handler",
                "pIVar1": "i2c_instance",
                "hi2c": "i2c_handler",
                "SR1": "status_register_1",
                "ErrorCode": "error_code",
                "State": "state",
                "Lock": "lock",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef check_i2c_status_08001436(I2C_HandleTypeDef *i2c_handler)\n{\n  I2C_TypeDef *i2c_instance;\n  i2c_instance = i2c_handler->Instance;\n  if ((i2c_instance->SR1 & 0x400) != 0) {\n    i2c_instance->SR1 = i2c_instance->SR1 & 0xfffffbff;\n    i2c_handler->ErrorCode = 4;\n    i2c_handler->State = HAL_I2C_STATE_READY;\n    i2c_handler->Lock = HAL_UNLOCKED;\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001436",
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08001436"
        },
        "FUN_08004a30": {
            "renaming": {
                "FUN_08004a30": "calculate_altitude_pid_error_08004a30",
                "PTR_joystick_08004a74": "joystick",
                "PTR_ALT_FLAG_08004a78": "alt_flag",
                "PTR_pid_altitude_08004a7c": "pid_altitude",
                "MS5611_GetFilteredAltitude": "get_filtered_altitude"
            },
            "code": "void calculate_altitude_pid_error_08004a30(void)\n{\n  float *PTR_joystick_08004a74 = PTR_PTR_joystick_08004a74_08004a74;\n  float *PTR_ALT_FLAG_08004a78 = PTR_ALT_FLAG_08004a78;\n  float *PTR_pid_altitude_08004a7c = PTR_PTR_pid_altitude_08004a7c_08004a7c;\n  if (PTR_joystick_08004a74[1] != 0)\n  {\n    if (*PTR_ALT_FLAG_08004a78 == 0)\n    {\n      float altitude = MS5611_GetFilteredAltitude();\n      float altitude_error = altitude - PTR_pid_altitude_08004a7c[6];\n      PTR_pid_altitude_08004a7c[7] = altitude_error;\n      *PTR_ALT_FLAG_08004a78 = 1;\n    }\n    else\n    {\n      float altitude = MS5611_GetFilteredAltitude();\n      float altitude_error = altitude - PTR_pid_altitude_08004a7c[6];\n      PTR_pid_altitude_08004a7c[12] = altitude_error;\n    }\n  }\n  if (PTR_joystick_08004a74[1] == 0)\n  {\n    if (*PTR_ALT_FLAG_08004a78 != 0)\n    {\n      *PTR_ALT_FLAG_08004a78 = 0;\n    }\n    PTR_pid_altitude_08004a7c[18] = PTR_joystick_08004a74[2];\n  }\n  return;\n}",
            "called": [
                "__aeabi_fmul",
                "MS5611_GetFilteredAltitude"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a30",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_altitude_pid_error_08004a30"
        },
        "FUN_08004c70": {
            "renaming": {
                "FUN_08004c70": "receive_uart_data_08004c70",
                "PTR_huart1_08004c88": "huart1_ptr",
                "PTR_rx_buffer_08004c84": "rx_buffer_ptr",
                "serialFlush": "serial_flush",
                "HAL_UART_Receive_IT": "HAL_UART_Receive_IT"
            },
            "code": "void receive_uart_data_08004c70(void)\n{\n  serial_flush();\n  HAL_UART_Receive_IT((UART_HandleTypeDef *)PTR_huart1_08004c88, PTR_rx_buffer_08004c84, 1);\n  return;\n}",
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c70",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "receive_uart_data_08004c70"
        },
        "FUN_08000904": {
            "renaming": {
                "FUN_08000904": "check_params_08000904",
                "param_1": "left",
                "param_2": "right",
                "param_3": "up",
                "param_4": "down",
                "uVar1": "xor_res",
                "bVar2": "both_zero",
                "bVar3": "right_greater"
            },
            "code": "uint check_params_08000904(uint left, uint right, uint up, uint down) {\n  if (((int)(right << 1) >> 0x15 == -1 || (int)(down << 1) >> 0x15 == -1) && ((((int)(right << 1) >> 0x15 == -1 && ((left | right << 0xc) != 0)) || (((int)(down << 1) >> 0x15 == -1 && ((up | down << 0xc) != 0)))))) {\n    return 1;\n  }\n  bool both_zero = (left | right << 1) == 0 && (up | down << 1) == 0;\n  if (!both_zero) {\n    bool same_cols = right == down;\n    if (same_cols) {\n      same_cols = left == up;\n    }\n    if (!same_cols) {\n      uint xor_res = right ^ down;\n      bool xor_zero = xor_res == 0;\n      if (-1 < (int)xor_res) {\n        xor_zero = right == down;\n      }\n      bool right_greater = -1 < (int)xor_res && down <= right;\n      if (xor_zero) {\n        right_greater = up <= left;\n      }\n      down = (int)down >> 0x1f;\n      if (!right_greater) {\n        down = ~down;\n      }\n      return down | 1;\n    }\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000904",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "check_params_08000904"
        },
        "FUN_0800299a": {
            "renaming": {
                "FUN_0800299a": "receive_uart_data_0800299a",
                "*huart": "*uart_handler",
                "uVar1": "uart_control_reg",
                "uVar2": "tx_data",
                "uVar3": "uart_status_reg",
                "puVar4": "tx_buffer",
                "HVar5": "uart_state",
                "pUVar6": "uart_instance",
                "uVar7": "uart_error_code",
                "uVar8": "uart_control_reg3",
                "bVar9": "error_flag"
            },
            "code": "void receive_uart_data_0800299a(UART_HandleTypeDef *uart_handler)\n{\n    uint32_t uart_status_reg;\n    uint32_t uart_control_reg;\n    uint32_t uart_error_code;\n    USART_TypeDef *uart_instance;\n    HAL_UART_StateTypeDef uart_state;\n    uint16_t *tx_buffer;\n    uint16_t tx_data;\n\n    uart_instance = uart_handler->Instance;\n    uart_status_reg = uart_instance->SR;\n    uart_control_reg = uart_instance->CR1;\n\n    if ((uart_status_reg & 0xf) == 0) {\n        if (((int)(uart_status_reg << 0x1a) < 0) && ((int)(uart_control_reg << 0x1a) < 0)) {\n            UART_Receive_IT(uart_handler);\n            return;\n        }\n    }\n    else {\n        uint32_t uart_control_reg3 = uart_instance->CR3 & 1;\n        if ((uart_control_reg3 != 0) || ((uart_control_reg & 0x120) != 0)) {\n            uart_error_code = uart_status_reg << 0x1f;\n            if ((int)uart_error_code < 0) {\n                bool error_flag = (int)(uart_control_reg << 0x17) < 0;\n                if (error_flag) {\n                    uart_error_code = uart_handler->ErrorCode | 1;\n                }\n                if (error_flag) {\n                    uart_handler->ErrorCode = uart_error_code;\n                }\n            }\n            if (((int)(uart_status_reg << 0x1d) < 0) && (uart_control_reg3 != 0)) {\n                uart_handler->ErrorCode = uart_handler->ErrorCode | 2;\n            }\n            if (((int)(uart_status_reg << 0x1e) < 0) && (uart_control_reg3 != 0)) {\n                uart_handler->ErrorCode = uart_handler->ErrorCode | 4;\n            }\n            if (((int)(uart_status_reg << 0x1c) < 0) && (uart_control_reg3 != 0)) {\n                uart_handler->ErrorCode = uart_handler->ErrorCode | 8;\n            }\n            if (uart_handler->ErrorCode == 0) {\n                return;\n            }\n            if (((int)(uart_status_reg << 0x1a) < 0) && ((int)(uart_control_reg << 0x1a) < 0)) {\n                UART_Receive_IT(uart_handler);\n            }\n            uart_instance = uart_handler->Instance;\n            if ((-1 < (int)(uart_handler->ErrorCode << 0x1c)) && ((uart_instance->CR3 & 0x40) == 0)) {\n                HAL_UART_ErrorCallback(uart_handler);\n                uart_handler->ErrorCode = 0;\n                return;\n            }\n            uart_instance->CR1 = uart_instance->CR1 & 0xfffffedf;\n            uart_instance->CR3 = uart_instance->CR3 & 0xfffffffe;\n            uart_handler->State = HAL_UART_STATE_READY;\n            HAL_UART_ErrorCallback(uart_handler);\n            return;\n        }\n    }\n    if (((int)(uart_status_reg << 0x18) < 0) && ((int)(uart_control_reg << 0x18) < 0)) {\n        if ((uart_handler->State & 0xdf) == 0x12) {\n            tx_buffer = (uint16_t *)uart_handler->pTxBuffPtr;\n            if ((uart_handler->Init).WordLength == 0x1000) {\n                tx_data = *tx_buffer & 0x1ff;\n                if ((uart_handler->Init).Parity == 0) {\n                    tx_buffer = tx_buffer + 1;\n                }\n                else {\n                    tx_buffer = (uint16_t *)((int)tx_buffer + 1);\n                }\n                uart_handler->pTxBuffPtr = (uint8_t *)tx_buffer;\n            }\n            else {\n                uart_handler->pTxBuffPtr = (uint8_t *)((int)tx_buffer + 1);\n                tx_data = (uint16_t)*(uint8_t *)tx_buffer;\n            }\n            uint16_t tx_count = uart_handler->TxXferCount - 1;\n            uart_handler->TxXferCount = tx_count;\n            if (tx_count == 0) {\n                uart_instance->CR1 = uart_instance->CR1 & 0xffffff7f;\n                uart_instance->CR1 = uart_instance->CR1 | 0x40;\n                return;\n            }\n        }\n    }\n    else if (((int)(uart_status_reg << 0x19) < 0) && ((int)(uart_control_reg << 0x19) < 0)) {\n        uart_instance->CR1 = uart_instance->CR1 & 0xffffffbf;\n        if (uart_handler->State == HAL_UART_STATE_BUSY_TX_RX) {\n            uart_state = HAL_UART_STATE_BUSY_RX;\n        }\n        else {\n            uart_state = HAL_UART_STATE_READY;\n        }\n        uart_handler->State = uart_state;\n        HAL_UART_TxCpltCallback(uart_handler);\n    }\n    return;\n}",
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800299a",
            "calling": [
                "USART1_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_uart_data_0800299a"
        },
        "FUN_080052e4": {
            "renaming": {
                "FUN_080052e4": "process_data_080052e4",
                "param_1": "param_1",
                "param_2": "data",
                "param_3": "output_size",
                "param_4": "param_4",
                "param_5": "callback",
                "iVar1": "i",
                "uVar2": "max_size",
                "uVar3": "is_unsigned",
                "bVar4": "is_four",
                "data_idx": "data_idx",
                "data_offset": "data_offset",
                "data_size": "data_size",
                "output_offset": "output_offset"
            },
            "code": "undefined4 process_data_080052e4(undefined4 param_1, uint *data, uint *output_size, undefined4 param_4, code *callback)\n{\n    int i;\n    uint max_size = data[4];\n    if ((int)data[4] < (int)data[2]) {\n        max_size = data[2];\n    }\n    *output_size = max_size;\n    if (*(char *)((int)data + 0x43) != '\\0') {\n        *output_size = max_size + 1;\n    }\n    if ((int)(*data << 0x1a) < 0) {\n        *output_size += 2;\n    }\n    uint data_idx = *data & 6;\n    if (data_idx == 0) {\n        for (; (int)data_idx < (int)(data[3] - *output_size); data_idx++) {\n            int result = (*callback)(param_1, param_4, (int)data + 0x19, 1);\n            if (result == -1) {\n                return 0xffffffff;\n            }\n        }\n    }\n    uint is_unsigned = (uint)*(byte *)((int)data + 0x43);\n    if (is_unsigned != 0) {\n        is_unsigned = 1;\n    }\n    uint data_offset = is_unsigned;\n    if ((int)(*data << 0x1a) < 0) {\n        *(undefined *)((int)data + is_unsigned + 0x43) = 0x30;\n        data_offset += 2;\n        *(undefined *)((int)data + is_unsigned + 0x44) = *(undefined *)((int)data + 0x45);\n    }\n    int result = (*callback)(param_1, param_4, (int)data + 0x43, data_offset);\n    if (result != -1) {\n        uint data_size = data[3];\n        bool is_four = (*data & 6) != 4;\n        if (is_four) {\n            data_size = 0;\n        }\n        uint output_offset = 0;\n        if (!is_four) {\n            data_size = data_size - *output_size;\n        }\n        if (!is_four) {\n            data_size = data_size & ~((int)data_size >> 0x1f);\n        }\n        if ((int)data[4] < (int)data[2]) {\n            data_size += (data[2] - data[4]);\n        }\n        while (true) {\n            if (data_size == output_offset) {\n                return 0;\n            }\n            result = (*callback)(param_1, param_4, (int)data + 0x1a, 1);\n            if (result == -1) {\n                break;\n            }\n            output_offset++;\n        }\n    }\n    return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052e4",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "process_data_080052e4"
        },
        "FUN_08000f94": {
            "renaming": {
                "FUN_08000f94": "check_overflow_08000f94",
                "param_1": "x",
                "param_2": "y",
                "uVar2": "left_shifted_x",
                "uVar3": "left_shifted_y",
                "uVar4": "x_and_y_cleared_of_sign_bits",
                "bVar1": "x_xor_y_is_negative",
                "bVar5": "x_and_y_cleared_of_sign_bits_is_zero"
            },
            "code": "uint check_overflow_08000f94(uint x, uint y) {\n  uint left_shifted_x = x * 2;\n  uint left_shifted_y = y * 2;\n  bool x_is_negative = ((int)left_shifted_x >> 0x18 == -1);\n  bool y_is_negative = ((int)left_shifted_y >> 0x18 == -1);\n  bool x_is_negative_and_not_all_ones = (x_is_negative && ((x & 0x7fffff) != 0));\n  bool y_is_negative_and_not_all_ones = (y_is_negative && ((y & 0x7fffff) != 0));\n  if (x_is_negative_and_not_all_ones || y_is_negative_and_not_all_ones) {\n    return 1;\n  }\n  uint x_and_y_cleared_of_sign_bits = left_shifted_x | y & 0x7fffffff;\n  bool x_xor_y_is_zero = (x ^ y) == 0;\n  bool x_and_y_cleared_of_sign_bits_is_zero = x_and_y_cleared_of_sign_bits == 0;\n  bool x_and_y_cleared_of_sign_bits_is_negative = ((int)x_and_y_cleared_of_sign_bits >> 0x1f == 1);\n  bool y_is_not_greater_than_x = (left_shifted_y <= left_shifted_x);\n  if (x_xor_y_is_zero) {\n    return (int)x_and_y_cleared_of_sign_bits >> 0x1f | 1;\n  }\n  if (x_and_y_cleared_of_sign_bits_is_zero) {\n    return x_and_y_cleared_of_sign_bits_is_negative ? ~1 : 0;\n  }\n  if (y_is_not_greater_than_x) {\n    return (int)y >> 0x1f;\n  }\n  return ~0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f94",
            "calling": [],
            "imported": false,
            "current_name": "check_overflow_08000f94"
        },
        "FUN_080014e2": {
            "renaming": {
                "FUN_080014e2": "check_i2c_ack_080014e2",
                "*hi2c": "*i2c_handle",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time"
            },
            "code": "HAL_StatusTypeDef check_i2c_ack_080014e2(I2C_HandleTypeDef *i2c_handle, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time = HAL_GetTick();\n  while(true)\n  {\n    if((int)(i2c_handle->Instance->SR1 << 0x18) < 0)\n    {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2c_handle);\n    if(status != HAL_OK)\n    {\n      if((timeout != 0xffffffff) && (timeout == 0 || (HAL_GetTick() - start_time) > timeout))\n      {\n        i2c_handle->ErrorCode |= 0x20;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      break;\n    }\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014e2",
            "calling": [
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "imported": false,
            "current_name": "check_i2c_ack_080014e2"
        },
        "FUN_0800142e": {
            "renaming": {
                "FUN_0800142e": "update_gpio_output_register_0800142e",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "ODR": "output_register"
            },
            "code": "void update_gpio_output_register_0800142e(GPIO_TypeDef *gpio, uint16_t pin){\n  uint16_t new_output_value = pin ^ gpio->ODR;\n  gpio->ODR = new_output_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800142e",
            "calling": [
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "update_gpio_output_register_0800142e"
        },
        "FUN_08004d8c": {
            "renaming": {
                "FUN_08004d8c": "update_timer_flags_08004d8c",
                "htim_pwm": "timer_handle",
                "pTVar1": "timer_instance",
                "tmpreg": "timer_flag1",
                "tmpreg_1": "timer_flag2",
                "tmpreg_2": "timer_flag3",
                "tmpreg_3": "timer_flag4",
                "DAT_08004e04": "ptr_timer1",
                "DAT_08004e08": "ptr_timer_flags",
                "(TIM_TypeDef *)0x40000000": "ptr_timer2",
                "DAT_08004e0c": "ptr_timer3",
                "DAT_08004e10": "ptr_timer4"
            },
            "code": "void update_timer_flags_08004d8c(TIM_HandleTypeDef *timer_handle)\n{\n  TIM_TypeDef *timer_instance;\n  uint32_t timer_flag1;\n  uint32_t timer_flag2;\n  uint32_t timer_flag3;\n  uint32_t timer_flag4;\n  \n  timer_instance = timer_handle->Instance;\n  if (timer_instance == DAT_08004e04) {\n    *(uint *)(DAT_08004e08 + 0x18) |= 0x800;\n  }\n  else if (timer_instance == ptr_timer2) {\n    *ptr_timer2_flag |= 1;\n  }\n  else if (timer_instance == DAT_08004e0c) {\n    *(uint *)(DAT_08004e08 + 0x1c) |= 2;\n  }\n  else if (timer_instance == DAT_08004e10) {\n    *(uint *)(DAT_08004e08 + 0x1c) |= 4;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d8c",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "update_timer_flags_08004d8c"
        },
        "FUN_080009b4": {
            "renaming": {
                "FUN_080009b4": "is_input_null_terminated_080009b4",
                "in_CY": "input_string"
            },
            "code": "bool is_input_null_terminated_080009b4(char input_string){\n  __aeabi_cdcmpeq();\n  return input_string == '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009b4",
            "calling": [
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "is_input_null_terminated_080009b4"
        },
        "FUN_08003068": {
            "renaming": {
                "FUN_08003068": "calculate_result_08003068",
                "in_s0": "result"
            },
            "code": "float calculate_result_08003068(void)\n{\n  float result = 0.0;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003068",
            "calling": [
                "PID_UpdateAltitude"
            ],
            "imported": false,
            "current_name": "calculate_result_08003068"
        },
        "FUN_08000f8c": {
            "renaming": {
                "FUN_08000f8c": "calculate_result_08000f8c",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative_1",
                "uVar2": "doubled_1",
                "uVar3": "doubled_2",
                "uVar4": "temp_result",
                "bVar5": "is_zero_result"
            },
            "code": "uint calculate_result_08000f8c(uint input_1, uint input_2) {\n  bool is_negative_1;\n  uint doubled_1;\n  uint doubled_2;\n  uint temp_result;\n  bool is_zero_result;\n  \n  doubled_1 = input_1 * 2;\n  doubled_2 = input_2 * 2;\n  if (((int)doubled_1 >> 0x18 == -1 || (int)doubled_2 >> 0x18 == -1) &&\n     ((((int)doubled_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  temp_result = doubled_1 | input_2 & 0x7fffffff;\n  is_zero_result = temp_result == 0;\n  if (!is_zero_result) {\n    temp_result = input_1 ^ input_2;\n    is_zero_result = temp_result == 0;\n  }\n  is_negative_1 = -1 < (int)temp_result;\n  if (is_negative_1) {\n    input_1 = doubled_1 + input_2 * -2;\n    is_zero_result = input_1 == 0;\n  }\n  if ((is_negative_1 && doubled_2 <= doubled_1) && !is_zero_result) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_1 || doubled_2 > doubled_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero_result) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f8c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08000f8c"
        },
        "FUN_08000474": {
            "renaming": {
                "FUN_08000474": "calculate_result_08000474",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "is_quotient_odd",
                "uVar2": "quotient",
                "uVar3": "divisor_copy",
                "uVar4": "remainder",
                "iVar5": "quotient_bit_count",
                "uVar6": "is_quotient_bit_count_overflowed",
                "iVar7": "count_leading_zeroes",
                "uVar8": "is_divisor_negative",
                "uVar9": "quotient_high_bits",
                "bVar10": "is_quotient_overflowed",
                "bVar11": "is_quotient_bit_count_overflowed",
                "bVar12": "is_quotient_bit_count_overflowed"
            },
            "code": "ulonglong calculate_result_08000474(uint dividend, uint divisor)\n{\n  byte is_divisor_negative;\n  uint divisor_copy;\n  uint quotient_high_bits;\n  int quotient_bit_count;\n  uint quotient;\n  uint remainder;\n  bool is_quotient_odd;\n  bool is_quotient_overflowed;\n  bool is_quotient_bit_count_overflowed;\n  \n  if ((dividend | divisor) == 0) {\n    return CONCAT44(divisor, dividend);\n  }\n  \n  is_divisor_negative = divisor & 0x80000000;\n  divisor_copy = divisor;\n  if ((int)is_divisor_negative < 0) {\n    is_quotient_odd = dividend & 1;\n    dividend = -dividend;\n    divisor_copy = -divisor - (uint)is_quotient_odd;\n  }\n  \n  quotient_bit_count = 0x432;\n  quotient_high_bits = divisor_copy >> 0x16;\n  if (quotient_high_bits != 0) {\n    quotient_bit_count = 3;\n    if (divisor_copy >> 0x19 != 0) {\n      quotient_bit_count = 6;\n    }\n    if (divisor_copy >> 0x1c != 0) {\n      quotient_bit_count += 3;\n    }\n    quotient_bit_count -= ((int)divisor_copy >> 0x1f);\n    quotient_high_bits = dividend << (0x20 - quotient_bit_count & 0xff);\n    dividend = dividend >> (quotient_bit_count & 0xff) | divisor_copy << (0x20 - quotient_bit_count & 0xff);\n    divisor_copy = divisor_copy >> (quotient_bit_count & 0xff);\n    quotient_bit_count += 0x432;\n  }\n  \n  if (0xfffff < divisor_copy) {\n    if (0x1fffff < divisor_copy) {\n      is_quotient_odd = dividend & 1;\n      dividend = dividend >> 1;\n      quotient_high_bits = (uint)(divisor_copy & 1) << 0x1f | quotient_high_bits >> 1;\n      quotient_bit_count += 1;\n      is_quotient_bit_count_overflowed = 0xffbfffff < (uint)(quotient_bit_count * 0x200000);\n      if (is_quotient_bit_count_overflowed) {\n        return (ulonglong)(is_divisor_negative | 0x7ff00000) << 0x20;\n      }\n    }\n    \n    is_quotient_overflowed = 0x7fffffff < quotient_high_bits;\n    if (quotient_high_bits == 0x80000000) {\n      is_quotient_overflowed = (dividend & 1) != 0;\n    }\n    return CONCAT44(divisor_copy + quotient_bit_count * 0x100000 + (uint)CARRY4(dividend,(uint)is_quotient_overflowed) | is_divisor_negative, dividend + is_quotient_overflowed);\n  }\n  \n  is_quotient_odd = (quotient_high_bits & 0x80000000) != 0;\n  quotient_high_bits = quotient_high_bits << 1;\n  remainder = dividend * 2 + (uint)is_quotient_odd;\n  is_quotient_overflowed = CARRY4(dividend, dividend);\n  dividend = dividend * 2 + (uint)is_quotient_odd;\n  quotient_bit_count += -1;\n  if ((remainder & 0x100000) != 0) {\n    is_quotient_odd = remainder & 1;\n    remainder = remainder >> 1;\n    quotient_high_bits = (uint)(dividend & 1) << 0x1f | quotient_high_bits >> 1;\n    quotient_bit_count += 1;\n    is_quotient_bit_count_overflowed = 0xffbfffff < (uint)(quotient_bit_count * 0x200000);\n    if (is_quotient_bit_count_overflowed) {\n      return (ulonglong)(is_divisor_negative | 0x7ff00000) << 0x20;\n    }\n  }\n  \n  if (quotient_bit_count <= 0) {\n    quotient = remainder;\n  } else {\n    quotient = quotient_high_bits + (quotient_bit_count - count_leading_zeroes(remainder)) * 0x100000;\n  }\n  \n  if (quotient_bit_count <= 31 && quotient_bit_count >= -20) {\n    if (quotient_bit_count == 0 || quotient_bit_count < 0 != SCARRY4(quotient_bit_count - 31, 12)) {\n      quotient_bit_count += 1;\n      return CONCAT44(is_divisor_negative | quotient_high_bits >> (quotient_bit_count & 0xff), dividend >> (quotient_bit_count & 0xff) | remainder << (0x20 - quotient_bit_count & 0xff));\n    }\n    return CONCAT44(is_divisor_negative | divisor, dividend);\n  }\n  \n  quotient_bit_count = ~(quotient_bit_count - 11);\n  if (quotient_bit_count > 0x1e) {\n    return CONCAT44(divisor, remainder >> (quotient_bit_count - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  quotient_bit_count -= 0x13;\n  if (quotient_bit_count == 0 || quotient_bit_count < 0 != SCARRY4(quotient_bit_count + 0xd, 12)) {\n    quotient_bit_count += 1;\n    return CONCAT44(is_divisor_negative | remainder >> (0x20 - (0xcU - quotient_bit_count) & 0xff) | quotient_high_bits << (0xcU - quotient_bit_count & 0xff)), dividend >> (quotient_bit_count & 0xff) | remainder << (0x20 - quotient_bit_count & 0xff)) & 0x80000000ffffffff;\n  }\n  return CONCAT44(divisor, dividend >> (quotient_bit_count & 0xff) | remainder << (0x20 - quotient_bit_count & 0xff)) & 0x80000000ffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000474",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08000474"
        },
        "FUN_08000110": {
            "renaming": {
                "FUN_08000110": "check_initialization_status_08000110",
                "param_1": "input_string",
                "*PTR_completed_8672_08000128": "completion_status",
                "DAT_0800012c": "initialization_status",
                "PTR__init_08000130": "initialized_string"
            },
            "code": "char* check_initialization_status_08000110(char* input_string) {\\n    if (*PTR_completed_8672_08000128 == \"\\0\") {\\n        if (DAT_0800012c != 0) {\\n            input_string = PTR__init_08000130;\\n        }\\n        *PTR_completed_8672_08000128 = 1;\\n    }\\n    return input_string;\\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000110",
            "calling": [],
            "imported": false,
            "current_name": "check_initialization_status_08000110"
        },
        "FUN_0800709e": {
            "renaming": {
                "FUN_0800709e": "exception_handler_0800709e",
                "__exc": "__exc"
            },
            "code": "int exception_handler_0800709e(exception* __exc)\n{\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800709e",
            "calling": [
                "asin",
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "exception_handler_0800709e"
        },
        "FUN_08002ec0": {
            "renaming": {
                "FUN_08002ec0": "calculate_filtered_pitch_08002ec0",
                "in_s0": "input_pitch",
                "fVar1": "filtered_pitch"
            },
            "code": "float calculate_filtered_pitch_08002ec0(void)\n{\n  float input_pitch;\n  float filtered_pitch;\n  \n  filtered_pitch = lowPassFilter((LPF *)PTR_lpf_pitch_08002ed0, input_pitch);\n  return filtered_pitch;\n}",
            "called": [
                "lowPassFilter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec0",
            "calling": [
                "AHRS_ComputeAngles",
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_filtered_pitch_08002ec0"
        },
        "FUN_08006c0c": {
            "renaming": {
                "FUN_08006c0c": "calculate_square_root_08006c0c",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient_high",
                "uVar2": "quotient_low",
                "iVar3": "exponent",
                "uVar4": "remainder",
                "shifted_dividend": "shifted_dividend",
                "shifted_quotient": "shifted_quotient",
                "iVar7": "trial_divisor",
                "product": "product",
                "difference": "difference",
                "quotient": "quotient",
                "bit_count": "bit_count",
                "divisor_mantissa": "divisor_mantissa",
                "trial_exponent": "trial_exponent",
                "quotient_mantissa": "quotient_mantissa",
                "trial_divisor_mantissa": "trial_divisor_mantissa",
                "trial_sum": "trial_sum",
                "divisor_bits_remaining": "divisor_bits_remaining",
                "quotient_bits_remaining": "quotient_bits_remaining",
                "trial_quotient_mantissa": "trial_quotient_mantissa",
                "trial_remainder": "trial_remainder"
            },
            "code": "undefined8 calculate_square_root_08006c0c(uint dividend, uint divisor)\n{\n  undefined4 quotient_high;\n  uint quotient_low;\n  int exponent;\n  uint remainder;\n  uint shifted_dividend;\n  uint shifted_quotient;\n  uint trial_divisor;\n  \n  if ((DAT_08006d60 & ~divisor) == 0) {\n    undefined8 product = __muldf3(dividend, divisor, dividend, divisor);\n    quotient_low = __aeabi_dadd(dividend, divisor, (int)product, (int)((ulonglong)product >> 0x20));\n    return CONCAT44(0x3fe00000, quotient_low >> 1);\n  }\n  if ((int)divisor < 1) {\n    if ((divisor & 0x7fffffff | dividend) == 0) {\n      return CONCAT44(divisor, dividend);\n    }\n    if (divisor != 0) {\n      undefined8 difference = __subdf3(dividend, divisor, dividend, divisor);\n      quotient_high = (undefined4)((ulonglong)difference >> 0x20);\n      undefined8 quotient = __divdf3((int)difference, quotient_high, (int)difference, quotient_high);\n      return quotient;\n    }\n  }\n  exponent = (int)divisor >> 0x14;\n  if (exponent == 0) {\n    while (divisor == 0) {\n      exponent = exponent + -0x15;\n      shifted_dividend = dividend >> 0xb;\n      dividend = dividend << 0x15;\n    }\n    uint bit_count = 0;\n    for (; -1 < (int)(shifted_dividend << 0xb); shifted_dividend = shifted_dividend << 1) {\n      bit_count = bit_count + 1;\n    }\n    exponent = exponent - (bit_count - 1);\n    divisor = shifted_dividend | dividend >> (0x20 - bit_count & 0xff);\n    dividend = dividend << (bit_count & 0xff);\n  }\n  uint divisor_mantissa = divisor & 0xfffff | 0x100000;\n  if ((exponent + -0x3ff) * -0x80000000 < 0) {\n    divisor_mantissa = divisor_mantissa * 2 - ((int)dividend >> 0x1f);\n    dividend = dividend << 1;\n  }\n  divisor_mantissa = divisor_mantissa * 2 - ((int)dividend >> 0x1f);\n  uint trial_exponent = 0x16;\n  uint quotient_mantissa = 0;\n  uint trial_divisor_mantissa = 0x200000;\n  dividend = dividend << 1;\n  do {\n    int trial_sum = quotient_mantissa + trial_divisor_mantissa;\n    if (trial_sum <= (int)divisor_mantissa) {\n      divisor_mantissa = divisor_mantissa - trial_sum;\n      quotient_mantissa = trial_sum + trial_divisor_mantissa;\n      shifted_quotient = shifted_quotient + trial_divisor_mantissa;\n    }\n    trial_exponent = trial_exponent - 1;\n    divisor_mantissa = divisor_mantissa * 2 - ((int)dividend >> 0x1f);\n    trial_divisor_mantissa = trial_divisor_mantissa >> 1;\n    dividend = dividend << 1;\n  } while (trial_exponent != 0);\n  uint divisor_bits_remaining = 0x20;\n  uint quotient_bits_remaining = 0x80000000;\n  trial_divisor_mantissa = quotient_mantissa;\n  do {\n    uint trial_quotient_mantissa = quotient_bits_remaining + trial_divisor_mantissa;\n    uint trial_remainder = divisor_mantissa;\n    if (((int)trial_divisor_mantissa < (int)divisor_mantissa) || ((divisor_mantissa == trial_divisor_mantissa && (trial_quotient_mantissa <= dividend)))) {\n      quotient_bits_remaining = quotient_bits_remaining >> 1;\n      trial_divisor_mantissa = trial_quotient_mantissa;\n      if (((int)trial_quotient_mantissa < 0) && (-1 < (int)(trial_quotient_mantissa + quotient_bits_remaining))) {\n        divisor_bits_remaining = divisor_bits_remaining + 1;\n      }\n      divisor_mantissa = divisor_mantissa - trial_quotient_mantissa;\n      if (dividend < trial_quotient_mantissa) {\n        divisor_mantissa = divisor_mantissa - 1;\n      }\n      dividend = dividend - trial_quotient_mantissa;\n      shifted_quotient = shifted_quotient + quotient_bits_remaining;\n    }\n    divisor_mantissa = divisor_mantissa * 2 - ((int)dividend >> 0x1f);\n    divisor_bits_remaining = divisor_bits_remaining - 1;\n    dividend = dividend << 1;\n    quotient_bits_remaining = quotient_bits_remaining >> 1;\n    trial_divisor_mantissa = trial_quotient_mantissa;\n  } while (divisor_bits_remaining != 0);\n  if ((dividend | divisor_mantissa) != 0) {\n    if (shifted_quotient == 0xffffffff) {\n      exponent = exponent + 1;\n      shifted_quotient = divisor_bits_remaining;\n    }\n    else {\n      shifted_quotient = shifted_quotient + 1 & 0xfffffffe;\n    }\n  }\n  shifted_quotient = shifted_quotient >> 1;\n  if (exponent << 0x1f < 0) {\n    shifted_quotient = shifted_quotient | 0x80000000;\n  }\n  return CONCAT44((shifted_quotient >> 1) + 0x3fe00000 + (exponent + -0x3ff >> 1) * 0x100000, divisor_mantissa);\n}",
            "called": [
                "__divdf3",
                "__muldf3",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c0c",
            "calling": [
                "sqrt",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_square_root_08006c0c"
        },
        "FUN_0800426c": {
            "renaming": {
                "FUN_0800426c": "calculate_motor_speeds_0800426c",
                "throttle": "throttle",
                "pitch": "pitch",
                "roll": "roll",
                "yaw": "yaw",
                "uVar1": "difference1",
                "uVar2": "sum1",
                "uVar3": "difference2",
                "m4": "motor4_speed",
                "m3": "motor3_speed",
                "m2": "motor2_speed",
                "m1": "motor1_speed"
            },
            "code": "void calculate_motor_speeds_0800426c(float throttle, float pitch, float roll, float yaw)\n{\n  float difference1 = throttle - roll;\n  float sum1 = throttle + roll;\n  float difference2 = pitch - yaw;\n  float sum2 = pitch + yaw;\n  int motor4_speed = (int)(sum1 - difference2);\n  int motor3_speed = (int)(sum1 + difference2);\n  int motor2_speed = (int)(sum2 - difference1);\n  int motor1_speed = (int)(sum2 + difference1);\n  Motor_SetSpeed(motor1_speed, motor2_speed, motor3_speed, motor4_speed);\n  return;\n}",
            "called": [
                "Motor_SetSpeed",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_f2iz"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800426c",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_motor_speeds_0800426c"
        },
        "FUN_08002538": {
            "renaming": {
                "FUN_08002538": "set_timer_channel_08002538",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "backup_timer_instance",
                "pTVar2": "timer_instance",
                "TIM_CCxChannelCmd": "TIM_CCxChannelCmd",
                "Instance": "Instance",
                "DAT_08002560": "DAT_08002560",
                "BDTR": "BDTR",
                "CR1": "CR1",
                "HAL_OK": "HAL_OK",
                "uint32_t": "uint32_t"
            },
            "code": "HAL_StatusTypeDef set_timer_channel_08002538(TIM_HandleTypeDef *timer_handle, uint32_t channel)\n{\n  TIM_TypeDef *timer_instance;\n  TIM_TypeDef *backup_timer_instance;\n  \n  TIM_CCxChannelCmd(timer_handle->Instance, channel, ENABLE);\n  timer_instance = timer_handle->Instance;\n  backup_timer_instance = DAT_08002560;\n  if (timer_instance == DAT_08002560) {\n    backup_timer_instance = (TIM_TypeDef *)(timer_instance->BDTR | 0x8000);\n  }\n  if (timer_instance == DAT_08002560) {\n    timer_instance->BDTR = (uint32_t)backup_timer_instance;\n  }\n  timer_instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002538",
            "calling": [
                "PWM_Init"
            ],
            "imported": false,
            "current_name": "set_timer_channel_08002538"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "read_i2c_data_080040e8",
                "device_add": "device_address",
                "register_add": "register_address",
                "byte_array": "data_array",
                "size": "data_size",
                "file": "file_name",
                "line": "line_number",
                "puVar3": "data_ptr",
                "uVar1": "byte_read"
            },
            "code": "void read_i2c_data_080040e8(uint16_t device_address, uint16_t register_address, uint8_t *data_array, uint16_t data_size, char *file_name, int line_number)\n{\n  uint8_t *data_ptr = data_array - 1;\n  for (int i = 0; i < (int)(uint)data_size; i++) {\n    uint8_t byte_read = I2C_ReadByte(device_address, register_address + (short)i, PTR_s____Src_i2c_c_08004118, 0x4c);\n    data_ptr++;\n    *data_ptr = byte_read;\n  }\n  return;\n}",
            "called": [
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "AK8963_ReadData",
                "MS5611_Init",
                "MPU9250_ReadGyroData",
                "AK8963_Init",
                "MPU9250_ReadAccelData"
            ],
            "imported": false,
            "current_name": "read_i2c_data_080040e8"
        },
        "FUN_08000c44": {
            "renaming": {
                "FUN_08000c44": "calculate_hash_08000c44",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar4": "hash_offset",
                "uVar3": "sign_bit",
                "uVar5": "overflow",
                "shifted_input": "shifted_input",
                "shifted_overflow": "shifted_overflow",
                "hash": "hash"
            },
            "code": "uint calculate_hash_08000c44(uint input)\n{\n  uint sign_bit = input & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  int leading_zeroes = count_leading_zeroes(input);\n  uint shift_amount = leading_zeroes - 8;\n  int hash_offset = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (leading_zeroes > 7) {\n    uint overflow = 0 << (shift_amount & 0xff);\n    uint shifted_input = input << (shift_amount & 0xff);\n    uint shifted_overflow = 0U >> (0x20 - shift_amount & 0xff);\n    uint hash = hash_offset + shifted_input + shifted_overflow + (uint)(0x7fffffff < overflow);\n    if (overflow == 0x80000000) {\n      hash = hash & 0xfffffffe;\n    }\n    return hash;\n  }\n  uint shifted_input = input << (leading_zeroes + 0x18U & 0xff);\n  uint shifted_overflow = (input >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shifted_input >> 0x1f);\n  uint hash = hash_offset + shifted_overflow;\n  if ((shifted_input & 0x7fffffff) == 0) {\n    hash = hash & ~(shifted_input >> 0x1f);\n  }\n  return hash;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c44",
            "calling": [
                "MS5611_Update",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "AK8963_Init",
                "PID_Compute",
                "MPU9250_ReadAccelData"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000c44"
        },
        "FUN_08000a04": {
            "renaming": {
                "FUN_08000a04": "check_params_08000a04",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "code": "int check_params_08000a04(uint32_t param1, int32_t param2, uint32_t param3, int32_t param4) {\n\tint32_t shifted_param2 = (param2 << 1) >> 0x15;\n\tint32_t shifted_param4 = (param4 << 1) >> 0x15;\n\tif ((shifted_param2 != -1 || (param1 | (param2 << 0xc)) == 0) && (shifted_param4 != -1 || (param3 | (param4 << 0xc)) == 0)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a04",
            "calling": [
                "asin",
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "check_params_08000a04"
        },
        "FUN_080025e8": {
            "renaming": {
                "FUN_080025e8": "configure_uart_080025e8",
                "*huart": "*uart_handle",
                "uVar1": "peripheral_clock_frequency",
                "uVar2": "baud_rate_divisor2",
                "uVar3": "parity_bits",
                "iVar4": "integer_baud_rate_divisor",
                "uVar5": "baud_rate",
                "iVar6": "fractional_baud_rate_divisor",
                "*pUVar7": "*uart_instance"
            },
            "code": "void configure_uart_080025e8(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t baud_rate_divisor1;\n  uint32_t baud_rate_divisor2;\n  uint parity_bits;\n  uint word_length;\n  uint mode;\n  uint hardware_flow_control;\n  int integer_baud_rate_divisor;\n  int fractional_baud_rate_divisor;\n  USART_TypeDef *uart_instance;\n  \n  uart_instance = uart_handle->Instance;\n  parity_bits = (uart_handle->Init).Parity;\n  uart_instance->CR2 = uart_instance->CR2 & 0xffffcfff | (uart_handle->Init).StopBits;\n  word_length = (uart_handle->Init).WordLength;\n  mode = (uart_handle->Init).Mode;\n  hardware_flow_control = (uart_handle->Init).HwFlowCtl;\n  uart_instance->CR1 = word_length | parity_bits | mode | uart_instance->CR1 & 0xffffe9f3;\n  uart_instance->CR3 = uart_instance->CR3 & 0xfffffcff | hardware_flow_control;\n  if (uart_instance == PTR_DAT_08002720) {\n    uint32_t peripheral_clock_frequency = HAL_RCC_GetPCLK2Freq();\n    baud_rate_divisor1 = (peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2);\n    baud_rate_divisor2 = (peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) + ((peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) / 100) * -100;\n    integer_baud_rate_divisor = (peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) + ((peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) / 100) * -100;\n  }\n  else {\n    uint32_t peripheral_clock_frequency = HAL_RCC_GetPCLK1Freq();\n    baud_rate_divisor1 = (peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2);\n    baud_rate_divisor2 = (peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) + ((peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) / 100) * -100;\n    integer_baud_rate_divisor = (peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) + ((peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) / 100) * -100;\n  }\n  fractional_baud_rate_divisor = ((baud_rate_divisor1 + baud_rate_divisor2 * 0x10 + 0x32) / 100 & 0xf) | ((integer_baud_rate_divisor * 0x10 + 0x32) / 100 & 0xf0) + ((peripheral_clock_frequency * 0x19) / ((uart_handle->Init).BaudRate << 2) / 100) * 0x10;\n  uart_instance->BRR = fractional_baud_rate_divisor;\n}\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e8",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_080025e8"
        },
        "FUN_08003078": {
            "renaming": {
                "FUN_08003078": "FUNC_08003078"
            },
            "code": "\nvoid FUNC_08003078(void)\n\n{\n  undefined4 *puVar1;\n  byte bVar2;\n  longlong lVar3;\n  uint uVar4;\n  undefined *puVar5;\n  undefined *puVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  uint32_t uVar13;\n  undefined4 extraout_r1;\n  uint uVar14;\n  undefined4 unaff_r4;\n  uint uVar15;\n  uint uVar16;\n  uint uVar17;\n  undefined4 *puVar18;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  int iVar19;\n  int iVar20;\n  int iVar21;\n  bool bVar22;\n  undefined8 uVar23;\n  \n  puVar6 = PTR_PRESSURE_READY_08003254;\n  puVar5 = PTR_TEMP_READY_08003250;\n  if ((*PTR_TEMP_READY_08003250 != '\\0') && (*PTR_PRESSURE_READY_08003254 != '\\0')) {\n    iVar21 = *(int *)PTR_MS5611_RawTemperature_0800325c +\n             (uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 10) * -0x100;\n    uVar14 = (uint)((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 0xc) *\n                   (longlong)iVar21) >> 0x17 |\n             (int)((ulonglong)\n                   ((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 0xc) *\n                   (longlong)iVar21) >> 0x20) << 9;\n    uVar15 = (uint)((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 8) *\n                    (longlong)iVar21 >> 7);\n    uVar16 = uVar15 + (uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 4) * 0x10000;\n    uVar8 = (uint)((ulonglong)\n                   ((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 6) *\n                   (longlong)iVar21) >> 8);\n    iVar19 = uVar14 + 2000;\n    uVar9 = uVar8 + (uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 2) * 0x8000;\n    bVar22 = (int)uVar14 < 0;\n    if (1999 < iVar19) {\n      uVar14 = 0;\n    }\n    uVar4 = uVar14;\n    if (bVar22 != SBORROW4(iVar19,2000)) {\n      iVar20 = uVar14 * uVar14 * 5;\n      uVar14 = iVar20 >> 2;\n      uVar4 = iVar20 >> 1;\n    }\n    uVar17 = uVar16 - uVar4;\n    lVar3 = (ulonglong)(uVar9 - uVar14) * (ulonglong)*(uint *)PTR_MS5611_RawPressure_08003260;\n    iVar20 = *(uint *)PTR_MS5611_RawPressure_08003260 *\n             ((((int)((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 6) *\n                      (longlong)iVar21 >> 0x28) +\n               (uint)CARRY4(uVar8,(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 2) * 0x8000))\n              - ((int)uVar14 >> 0x1f)) - (uint)(uVar9 < uVar14)) + (int)((ulonglong)lVar3 >> 0x20);\n    uVar8 = (uint)lVar3 >> 0x15 | iVar20 * 0x800;\n    uVar10 = __floatsisf(uVar8 - uVar17 >> 0xf |\n                         (((iVar20 >> 0x15) -\n                          ((((int)((longlong)\n                                   (int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 8) *\n                                   (longlong)iVar21 >> 0x27) +\n                            (uint)CARRY4(uVar15,(uint)*(ushort *)\n                                                       (PTR_MS5611_Coefficients_08003258 + 4) *\n                                                0x10000)) - ((int)uVar4 >> 0x1f)) -\n                          (uint)(uVar16 < uVar4))) - (uint)(uVar8 < uVar17)) * 0x20000);\n    uVar11 = __aeabi_fdiv(uVar10,DAT_08003264);\n    *(undefined4 *)PTR_MS5611_CompensatedPressure_08003268 = uVar11;\n    uVar10 = __floatsisf(iVar19);\n    uVar12 = __aeabi_fdiv(uVar10,DAT_08003264);\n    uVar10 = DAT_08003270;\n    *(undefined4 *)PTR_MS5611_CompensatedTemperature_0800326c = uVar12;\n    __aeabi_fdiv(uVar11,uVar10);\n    uVar10 = __aeabi_f2d();\n    pow((double)CONCAT44(unaff_r5,unaff_r4),(double)CONCAT44(unaff_r7,unaff_r6));\n    uVar23 = __subdf3(0,DAT_08003274,uVar10,extraout_r1);\n    __muldf3((int)uVar23,(int)((ulonglong)uVar23 >> 0x20),DAT_08003248,DAT_0800324c);\n    uVar10 = __truncdfsf2();\n    puVar7 = PTR_alt_filter_08003278;\n    *(undefined4 *)PTR_MS5611_Altitude_0800327c = uVar10;\n    uVar11 = 0;\n    puVar18 = (undefined4 *)puVar7;\n    do {\n      puVar1 = puVar18 + 1;\n      *puVar18 = *puVar1;\n      uVar11 = __addsf3(uVar11);\n      puVar18 = puVar1;\n    } while ((undefined4 *)(puVar7 + 0x4c) != puVar1);\n    *(undefined4 *)(puVar7 + 0x4c) = uVar10;\n    uVar10 = __addsf3(uVar11,uVar10);\n    uVar10 = __aeabi_fdiv(uVar10,DAT_08003280);\n    *(undefined4 *)PTR_MS5611_FilteredAltitude_08003284 = uVar10;\n    iVar19 = __aeabi_f2iz();\n    puVar7 = PTR_MS5611_OSR_0800328c;\n    *(int *)PTR_msp_txf_altitude_08003288 = iVar19 * 100;\n    bVar2 = *puVar7;\n    *puVar5 = 0;\n    *puVar6 = 0;\n    I2C_WriteByte(0xee,bVar2 + 0x50,'\\x01','\\0');\n    uVar13 = millis();\n    *(uint32_t *)PTR_temp_time_08003290 = uVar13;\n  }\n  uVar13 = millis();\n  puVar6 = PTR_pressure_time_08003294;\n  if (((10 < uVar13 - *(int *)PTR_temp_time_08003290) && (*puVar5 == '\\0')) &&\n     (*PTR_PRESSURE_READY_08003254 == '\\0')) {\n    uVar13 = MS5611_ReadADC();\n    puVar7 = PTR_MS5611_RawTemperature_0800325c;\n    *puVar5 = 1;\n    *(uint32_t *)puVar7 = uVar13;\n    I2C_WriteByte(0xee,(byte)*PTR_MS5611_OSR_0800328c + 0x40,'\\x01','\\0');\n    uVar13 = millis();\n    *(uint32_t *)puVar6 = uVar13;\n  }\n  uVar13 = millis();\n  puVar7 = PTR_PRESSURE_READY_08003254;\n  if (((10 < uVar13 - *(int *)puVar6) && (*puVar5 != '\\0')) &&\n     (*PTR_PRESSURE_READY_08003254 == '\\0')) {\n    uVar13 = MS5611_ReadADC();\n    *(uint32_t *)PTR_MS5611_RawPressure_08003260 = uVar13;\n    *puVar7 = 1;\n  }\n  return;\n}\n\n",
            "called": [
                "__floatsisf",
                "__muldf3",
                "__addsf3",
                "millis",
                "__aeabi_fdiv",
                "__aeabi_f2d",
                "__truncdfsf2",
                "I2C_WriteByte",
                "__subdf3",
                "MS5611_ReadADC",
                "pow",
                "__aeabi_f2iz"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003078",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "FUNC_08003078"
        },
        "FUN_080009c8": {
            "renaming": {
                "FUN_080009c8": "is_not_equal_to_zero_080009c8",
                "in_CY": "is_CY_zero",
                "in_ZR": "is_ZR_zero"
            },
            "code": "bool is_not_equal_to_zero_080009c8(void)\n{\n  bool is_CY_zero = __aeabi_cdcmpeq();\n  bool is_ZR_zero = (bool)in_ZR;\n  return !is_CY_zero || is_ZR_zero;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009c8",
            "calling": [
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "is_not_equal_to_zero_080009c8"
        },
        "FUN_08000f9c": {
            "renaming": {
                "FUN_08000f9c": "calculate_result_08000f9c",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "combined_inputs",
                "bVar1": "is_negative_result",
                "bVar5": "is_combined_inputs_zero"
            },
            "code": "uint calculate_result_08000f9c(uint input_1, uint input_2) {\n    bool is_negative_result;\n    uint doubled_input_1 = input_1 * 2;\n    uint doubled_input_2 = input_2 * 2;\n    if (((int)doubled_input_1 >> 0x18 == -1 || (int)doubled_input_2 >> 0x18 == -1) && ((((int)doubled_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) || (((int)doubled_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n        return 1;\n    }\n    uint combined_inputs = doubled_input_1 | input_2 & 0x7fffffff;\n    bool is_combined_inputs_zero = combined_inputs == 0;\n    if (!is_combined_inputs_zero) {\n        combined_inputs = input_1 ^ input_2;\n        is_combined_inputs_zero = combined_inputs == 0;\n    }\n    is_negative_result = -1 < (int)combined_inputs;\n    if (is_negative_result) {\n        input_1 = doubled_input_1 + input_2 * -2;\n        is_combined_inputs_zero = input_1 == 0;\n    }\n    if ((is_negative_result && doubled_input_2 <= doubled_input_1) && !is_combined_inputs_zero) {\n        input_1 = (int)input_2 >> 0x1f;\n    }\n    if (!is_negative_result || doubled_input_2 > doubled_input_1) {\n        input_1 = ~((int)input_2 >> 0x1f);\n    }\n    if (!is_combined_inputs_zero) {\n        input_1 = input_1 | 1;\n    }\n    return input_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f9c",
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "imported": false,
            "current_name": "calculate_result_08000f9c"
        },
        "FUN_08002ed4": {
            "renaming": {
                "FUN_08002ed4": "apply_low_pass_filter_to_roll_08002ed4",
                "in_s0": "roll_input",
                "fVar1": "filtered_roll"
            },
            "code": "float apply_low_pass_filter_to_roll_08002ed4(void)\n{\n  float roll_input;\n  float filtered_roll;\n  filtered_roll = lowPassFilter((LPF *)PTR_lpf_roll_08002ee4, roll_input);\n  return filtered_roll;\n}",
            "called": [
                "lowPassFilter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed4",
            "calling": [
                "AHRS_ComputeAngles",
                "PID_Update"
            ],
            "imported": false,
            "current_name": "apply_low_pass_filter_to_roll_08002ed4"
        },
        "FUN_08006228": {
            "renaming": {
                "FUN_08006228": "FUNC_08006228"
            },
            "code": "\nvoid FUNC_08006228(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  undefined4 extraout_r1;\n  uint extraout_r1_00;\n  undefined4 uVar2;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  uint extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined4 uVar6;\n  uint uVar7;\n  undefined4 uVar8;\n  uint uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined8 uVar12;\n  undefined8 uVar13;\n  undefined8 uVar14;\n  undefined8 uVar15;\n  longlong lVar16;\n  ulonglong uVar17;\n  undefined8 uVar18;\n  undefined4 uVar19;\n  undefined4 in_stack_ffffff94;\n  undefined4 local_68;\n  undefined4 local_64;\n  int local_54;\n  \n  uVar9 = param_4 & 0x7fffffff;\n  if ((uVar9 | param_3) == 0) {\n    return;\n  }\n  uVar7 = param_2 & 0x7fffffff;\n  if ((int)uVar7 <= (int)DAT_08006428) {\n    if (uVar7 == DAT_08006428) {\n      if (param_1 == 0) {\n        if (uVar7 < uVar9) goto LAB_08006278;\nLAB_08006262:\n        if ((uVar9 != DAT_08006428) || (param_3 == 0)) {\n          if (-1 < (int)param_2) goto LAB_0800632a;\n          if (DAT_08006430 < (int)uVar9) {\n            uVar1 = 2;\nLAB_080062ba:\n            if (param_3 == 0) {\n              if (uVar9 == DAT_08006428) {\n                return;\n              }\nLAB_0800630c:\n              if (uVar9 == DAT_08006438) {\n                if (-1 < (int)param_4) {\n                  return;\n                }\n                uVar7 = 0;\n                uVar9 = DAT_08006438;\n                goto LAB_08006320;\n              }\n              if (param_4 == 0x40000000) goto LAB_0800634a;\n              if ((param_4 == DAT_0800643c) && (-1 < (int)param_2)) {\n                __ieee754_sqrt(param_1,param_2);\n                return;\n              }\n            }\n          }\n          else {\n            if ((int)uVar9 <= DAT_08006430 + -0x3500000) {\nLAB_0800632a:\n              uVar1 = 0;\n              goto LAB_080062ba;\n            }\n            iVar4 = ((int)uVar9 >> 0x14) + -0x3ff;\n            if (0x14 < iVar4) {\n              uVar1 = param_3 >> (0x34U - iVar4 & 0xff);\n              if (param_3 == uVar1 << (0x34U - iVar4 & 0xff)) {\n                uVar1 = 2 - (uVar1 & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (param_3 == 0) {\n              uVar5 = (int)uVar9 >> (0x14U - iVar4 & 0xff);\n              uVar1 = param_3;\n              if (uVar9 == uVar5 << (0x14U - iVar4 & 0xff)) {\n                uVar1 = 2 - (uVar5 & 1);\n              }\n              goto LAB_0800630c;\n            }\n            uVar1 = 0;\n          }\n          uVar5 = param_1;\n          fabs((double)CONCAT44(in_stack_ffffff94,uVar1));\n          uVar17 = CONCAT44(param_2,uVar5) & 0x7fffffffffffffff;\n          if ((param_1 == 0) && ((uVar7 == 0 || ((param_2 & 0x3fffffff) == DAT_08006438)))) {\n            if ((int)param_4 < 0) {\n              __divdf3(0,DAT_08006438,uVar5,extraout_r1);\n            }\n            if (-1 < (int)param_2) {\n              return;\n            }\n            if ((uVar1 | uVar7 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            uVar5 = 0xffffffff - ((int)param_2 >> 0x1f);\n            if ((uVar1 | uVar5) != 0) {\n              if (DAT_08006440 < (int)uVar9) {\n                if (DAT_08006440 + 0x2100000 < (int)uVar9) {\n                  if (DAT_08006434 < (int)uVar7) {\nLAB_08006418:\n                    if ((int)param_4 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)param_4) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if ((int)uVar7 <= DAT_08006444) goto LAB_080063fa;\n                if ((int)DAT_08006438 < (int)uVar7) goto LAB_08006418;\n                uVar12 = __subdf3();\n                uVar10 = (undefined4)((ulonglong)uVar12 >> 0x20);\n                uVar8 = (undefined4)uVar12;\n                uVar12 = __muldf3(uVar8,uVar10,DAT_080065a8,DAT_080065ac);\n                uVar13 = __muldf3(uVar8,uVar10,DAT_080065b0,DAT_080065b4);\n                uVar14 = __muldf3(uVar8,uVar10,0,DAT_080065d4);\n                uVar14 = __subdf3(DAT_080065b8,DAT_080065bc,(int)uVar14,\n                                  (int)((ulonglong)uVar14 >> 0x20));\n                uVar14 = __muldf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),uVar8,uVar10);\n                uVar14 = __subdf3(0,DAT_080065d8,(int)uVar14,(int)((ulonglong)uVar14 >> 0x20));\n                uVar15 = __muldf3(uVar8,uVar10,uVar8,uVar10);\n                uVar14 = __muldf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),(int)uVar15,\n                                  (int)((ulonglong)uVar15 >> 0x20));\n                uVar14 = __muldf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),DAT_080065c0,\n                                  DAT_080065c4);\n                uVar13 = __subdf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar14,\n                                  (int)((ulonglong)uVar14 >> 0x20));\n                __aeabi_dadd((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,\n                             (int)((ulonglong)uVar13 >> 0x20));\n                lVar16 = (ulonglong)extraout_r1_00 << 0x20;\n                uVar9 = extraout_r1_00;\n              }\n              else {\n                local_54 = 0;\n                if (uVar7 < 0x100000) {\n                  uVar17 = __muldf3();\n                  local_54 = -0x35;\n                }\n                uVar9 = (uint)(uVar17 >> 0x20);\n                local_54 = ((int)uVar9 >> 0x14) + -0x3ff + local_54;\n                uVar9 = uVar9 & 0xfffff;\n                uVar7 = uVar9 | 0x3ff00000;\n                if (DAT_0800691c < (int)uVar9) {\n                  if (DAT_08006920 < (int)uVar9) {\n                    uVar7 = uVar7 - 0x100000;\n                    local_54 = local_54 + 1;\n                    goto LAB_08006628;\n                  }\n                  iVar4 = 1;\n                }\n                else {\nLAB_08006628:\n                  iVar4 = 0;\n                }\n                uVar6 = *(undefined4 *)(PTR_bp_08006924 + iVar4 * 8);\n                uVar19 = *(undefined4 *)((int)(PTR_bp_08006924 + iVar4 * 8) + 4);\n                uVar12 = __subdf3();\n                uVar10 = (undefined4)((ulonglong)uVar12 >> 0x20);\n                uVar13 = __aeabi_dadd((int)uVar17,uVar7,uVar6,uVar19);\n                uVar13 = __divdf3(0,DAT_08006928,(int)uVar13,(int)((ulonglong)uVar13 >> 0x20));\n                uVar11 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                uVar14 = __muldf3((int)uVar12,uVar10,(int)uVar13,uVar11);\n                uVar2 = (undefined4)((ulonglong)uVar14 >> 0x20);\n                uVar8 = (undefined4)uVar14;\n                uVar14 = __muldf3(0,uVar2);\n                uVar12 = __subdf3((int)uVar12,uVar10,(int)uVar14,(int)((ulonglong)uVar14 >> 0x20));\n                uVar14 = __subdf3(0,((int)uVar7 >> 1 | 0x20000000U) + 0x80000 + iVar4 * 0x40000,\n                                  uVar6,uVar19);\n                uVar14 = __subdf3((int)uVar17,uVar7,(int)uVar14,(int)((ulonglong)uVar14 >> 0x20));\n                uVar14 = __muldf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),0,uVar2);\n                uVar12 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar14,\n                                  (int)((ulonglong)uVar14 >> 0x20));\n                uVar12 = __muldf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,uVar11);\n                uVar11 = (undefined4)((ulonglong)uVar12 >> 0x20);\n                uVar13 = __muldf3(uVar8,uVar2);\n                uVar6 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                uVar10 = (undefined4)uVar13;\n                uVar13 = __muldf3(uVar10,uVar6,DAT_080068d0,DAT_080068d4);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_080068d8,\n                                      DAT_080068dc);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar10,uVar6);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_080068e0,\n                                      DAT_080068e4);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar10,uVar6);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_080068e8,\n                                      DAT_080068ec);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar10,uVar6);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_080068f0,\n                                      DAT_080068f4);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar10,uVar6);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_080068f8,\n                                      DAT_080068fc);\n                uVar14 = __muldf3(uVar10,uVar6,uVar10,uVar6);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar14,\n                                  (int)((ulonglong)uVar14 >> 0x20));\n                uVar14 = __aeabi_dadd(uVar8,uVar2,0,uVar2);\n                uVar14 = __muldf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),(int)uVar12,uVar11);\n                uVar13 = __aeabi_dadd((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),(int)uVar13,\n                                      (int)((ulonglong)uVar13 >> 0x20));\n                uVar10 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                uVar14 = __muldf3(0,uVar2,0,uVar2);\n                uVar6 = (undefined4)((ulonglong)uVar14 >> 0x20);\n                uVar15 = __aeabi_dadd((int)uVar14,uVar6,0,DAT_0800692c);\n                __aeabi_dadd((int)uVar15,(int)((ulonglong)uVar15 >> 0x20),(int)uVar13,uVar10);\n                uVar15 = __muldf3(0,uVar2,0,extraout_r1_01);\n                uVar19 = (undefined4)((ulonglong)uVar15 >> 0x20);\n                uVar18 = __subdf3(0,extraout_r1_01,0,DAT_0800692c);\n                uVar14 = __subdf3((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),(int)uVar14,uVar6);\n                uVar13 = __subdf3((int)uVar13,uVar10,(int)uVar14,(int)((ulonglong)uVar14 >> 0x20));\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar8,uVar2);\n                uVar12 = __muldf3((int)uVar12,uVar11,0,extraout_r1_01);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar12,\n                                      (int)((ulonglong)uVar12 >> 0x20));\n                uVar8 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                __aeabi_dadd((int)uVar15,uVar19,(int)uVar13,uVar8);\n                uVar12 = __muldf3(0,extraout_r1_02,DAT_08006900,DAT_08006904);\n                uVar14 = __subdf3(0,extraout_r1_02,(int)uVar15,uVar19);\n                uVar13 = __subdf3((int)uVar13,uVar8,(int)uVar14,(int)((ulonglong)uVar14 >> 0x20));\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_08006908,\n                                  DAT_0800690c);\n                uVar14 = __muldf3(0,extraout_r1_02,DAT_08006910,DAT_08006914);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar14,\n                                      (int)((ulonglong)uVar14 >> 0x20));\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),\n                                      *(undefined4 *)(PTR_dp_l_08006930 + iVar4 * 8),\n                                      *(undefined4 *)((int)(PTR_dp_l_08006930 + iVar4 * 8) + 4));\n                uVar14 = __aeabi_i2d(local_54);\n                uVar8 = (undefined4)((ulonglong)uVar14 >> 0x20);\n                uVar10 = *(undefined4 *)(PTR_dp_h_08006934 + iVar4 * 8);\n                uVar11 = *(undefined4 *)((int)(PTR_dp_h_08006934 + iVar4 * 8) + 4);\n                uVar15 = __aeabi_dadd((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,\n                                      (int)((ulonglong)uVar13 >> 0x20));\n                uVar15 = __aeabi_dadd((int)uVar15,(int)((ulonglong)uVar15 >> 0x20),uVar10,uVar11);\n                __aeabi_dadd((int)uVar15,(int)((ulonglong)uVar15 >> 0x20),(int)uVar14,uVar8);\n                uVar14 = __subdf3(0,extraout_r1_03,(int)uVar14,uVar8);\n                lVar16 = __subdf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),uVar10,uVar11);\n                uVar9 = extraout_r1_03;\n              }\n              uVar12 = __subdf3((int)lVar16,(int)((ulonglong)lVar16 >> 0x20),(int)uVar12,\n                                (int)((ulonglong)uVar12 >> 0x20));\n              uVar12 = __subdf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar12,\n                                (int)((ulonglong)uVar12 >> 0x20));\n              uVar8 = DAT_080065dc;\n              if ((uVar1 - 1 | uVar5) != 0) {\n                uVar8 = DAT_080065d0;\n              }\n              uVar19 = 0;\n              uVar13 = __subdf3(param_3,param_4,0,param_4);\n              uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),0,uVar9);\n              uVar12 = __muldf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),param_3,param_4);\n              uVar12 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar12,\n                                    (int)((ulonglong)uVar12 >> 0x20));\n              uVar2 = (undefined4)((ulonglong)uVar12 >> 0x20);\n              uVar10 = (undefined4)uVar12;\n              uVar12 = __muldf3(0,uVar9,0,param_4);\n              uVar6 = (undefined4)((ulonglong)uVar12 >> 0x20);\n              uVar11 = (undefined4)uVar12;\n              lVar16 = __aeabi_dadd(uVar10,uVar2,uVar11,uVar6);\n              uVar7 = (uint)((ulonglong)lVar16 >> 0x20);\n              uVar9 = (uint)lVar16;\n              if (DAT_080065e0 < (int)uVar7) {\n                if ((uVar7 + 0xbf700000 | uVar9) == 0) {\n                  uVar13 = __aeabi_dadd(uVar10,uVar2,DAT_08006ba8,DAT_08006bac);\n                  uVar14 = __subdf3(uVar9,uVar7,uVar11,uVar6);\n                  iVar4 = __aeabi_dcmpgt((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar14,\n                                         (int)((ulonglong)uVar14 >> 0x20));\n                  if (iVar4 == 0) goto LAB_08006968;\n                }\n                __muldf3(uVar19,uVar8,DAT_080065c8,DAT_080065cc);\n                goto LAB_0800634a;\n              }\n              if (DAT_08006c04 < (int)(uVar7 & 0x7fffffff)) {\n                if ((DAT_08006c08 + uVar7 | uVar9) == 0) {\n                  uVar13 = __subdf3(uVar9,uVar7,uVar11,uVar6);\n                  iVar4 = __aeabi_dcmple(uVar10,uVar2,(int)uVar13,(int)((ulonglong)uVar13 >> 0x20));\n                  if (iVar4 == 0) goto LAB_08006968;\n                }\n                __muldf3(uVar19,uVar8,DAT_08006bf0,DAT_08006bf4);\n              }\n              else {\nLAB_08006968:\n                if (DAT_08006bf8 < (int)(uVar7 & 0x7fffffff)) {\n                  uVar7 = (0x100000 >> (((int)(uVar7 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          uVar7;\n                  uVar9 = (uVar7 * 2 >> 0x15) - 0x3ff;\n                  iVar4 = (int)(uVar7 & 0xfffff | 0x100000) >> (0x14 - uVar9 & 0xff);\n                  if (lVar16 < 0) {\n                    iVar4 = -iVar4;\n                  }\n                  uVar12 = __subdf3(uVar11,uVar6,0,uVar7 & ~(DAT_08006bfc >> (uVar9 & 0xff)));\n                }\n                else {\n                  iVar4 = 0;\n                }\n                local_64 = (undefined4)((ulonglong)uVar12 >> 0x20);\n                local_68 = (undefined4)uVar12;\n                __aeabi_dadd(local_68,local_64,uVar10,uVar2);\n                uVar12 = __muldf3(0,extraout_r1_04,DAT_08006bb0,DAT_08006bb4);\n                uVar11 = (undefined4)((ulonglong)uVar12 >> 0x20);\n                uVar13 = __subdf3(0,extraout_r1_04,local_68,local_64);\n                uVar13 = __subdf3(uVar10,uVar2,(int)uVar13,(int)((ulonglong)uVar13 >> 0x20));\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_08006bb8,\n                                  DAT_08006bbc);\n                uVar14 = __muldf3(0,extraout_r1_04,DAT_08006bc0,DAT_08006bc4);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar14,\n                                      (int)((ulonglong)uVar14 >> 0x20));\n                uVar2 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                uVar14 = __aeabi_dadd((int)uVar12,uVar11,(int)uVar13,uVar2);\n                uVar6 = (undefined4)((ulonglong)uVar14 >> 0x20);\n                uVar10 = (undefined4)uVar14;\n                uVar12 = __subdf3(uVar10,uVar6,(int)uVar12,uVar11);\n                uVar12 = __subdf3((int)uVar13,uVar2,(int)uVar12,(int)((ulonglong)uVar12 >> 0x20));\n                uVar2 = (undefined4)((ulonglong)uVar12 >> 0x20);\n                uVar13 = __muldf3(uVar10,uVar6,uVar10,uVar6);\n                uVar3 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                uVar11 = (undefined4)uVar13;\n                uVar13 = __muldf3(uVar11,uVar3,DAT_08006bc8,DAT_08006bcc);\n                uVar13 = __subdf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_08006bd0,\n                                  DAT_08006bd4);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar11,uVar3);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_08006bd8,\n                                      DAT_08006bdc);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar11,uVar3);\n                uVar13 = __subdf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_08006be0,\n                                  DAT_08006be4);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar11,uVar3);\n                uVar13 = __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),DAT_08006be8,\n                                      DAT_08006bec);\n                uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),uVar11,uVar3);\n                uVar13 = __subdf3(uVar10,uVar6,(int)uVar13,(int)((ulonglong)uVar13 >> 0x20));\n                uVar11 = (undefined4)((ulonglong)uVar13 >> 0x20);\n                uVar14 = __muldf3(uVar10,uVar6,(int)uVar13,uVar11);\n                uVar13 = __subdf3((int)uVar13,uVar11,0,0x40000000);\n                uVar13 = __divdf3((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),(int)uVar13,\n                                  (int)((ulonglong)uVar13 >> 0x20));\n                uVar14 = __muldf3(uVar10,uVar6,(int)uVar12,uVar2);\n                uVar12 = __aeabi_dadd((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),(int)uVar12,uVar2\n                                     );\n                uVar12 = __subdf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),(int)uVar12,\n                                  (int)((ulonglong)uVar12 >> 0x20));\n                uVar12 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),uVar10,uVar6);\n                uVar12 = __subdf3(0,DAT_08006c00,(int)uVar12,(int)((ulonglong)uVar12 >> 0x20));\n                if ((int)((ulonglong)uVar12 >> 0x20) + iVar4 * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(uVar8,uVar19),(int)uVar12);\n                }\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          uVar12 = __subdf3();\n          uVar9 = (uint)((ulonglong)uVar12 >> 0x20);\n          uVar7 = (uint)uVar12;\n          param_1 = uVar7;\n          param_2 = uVar9;\nLAB_08006320:\n          __divdf3(uVar7,uVar9,param_1,param_2);\n          return;\n        }\n      }\n    }\n    else if ((int)uVar9 <= (int)DAT_08006428) goto LAB_08006262;\n  }\n  if ((uVar7 + 0xc0100000 | param_1) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(PTR_DAT_0800642c);\n  return;\n}\n\n",
            "called": [
                "scalbn",
                "__aeabi_dcmple",
                "__divdf3",
                "__muldf3",
                "__ieee754_sqrt",
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "fabs",
                "__subdf3",
                "__aeabi_i2d",
                "nan"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08006228",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "FUNC_08006228"
        },
        "FUN_08000c3c": {
            "renaming": {
                "FUN_08000c3c": "calculate_value_08000c3c",
                "param_1": "input_value",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar3": "multiplier",
                "uVar4": "carry",
                "left_shifted": "left_shifted",
                "right_shifted": "right_shifted",
                "0U": "zero",
                "0x7fffffff": "max_int",
                "0x80000000": "min_int"
            },
            "code": "uint calculate_value_08000c3c(uint input_value)\n{\n  int leading_zeroes = count_leading_zeroes(input_value);\n  int shift_amount = leading_zeroes - 8;\n  int multiplier = shift_amount * -0x800000 + 0x4a800000;\n  if (leading_zeroes > 7) {\n    uint left_shifted = input_value << (shift_amount & 0xff);\n    uint right_shifted = 0U >> (0x20 - shift_amount & 0xff);\n    uint carry = (uint)(0x7fffffff < 0);\n    uint result = multiplier + left_shifted + right_shifted + carry;\n    if ((left_shifted & 0x80000000) != 0) {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  uint left_shifted = input_value << (leading_zeroes + 0x18U & 0xff);\n  uint right_shifted = (input_value >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)left_shifted >> 0x1f);\n  if ((left_shifted & 0x7fffffff) == 0) {\n    right_shifted = right_shifted & ~(left_shifted >> 0x1f);\n  }\n  uint result = multiplier + right_shifted;\n  return result;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c3c",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "calculate_value_08000c3c"
        },
        "FUN_08001214": {
            "renaming": {
                "FUN_08001214": "calculate_ticks_08001214",
                "TicksNumb": "ticks_number",
                "puVar1": "ticks_ptr",
                "iVar2": "data_loc"
            },
            "code": "uint32_t calculate_ticks_08001214(uint32_t ticks_number) {\n  undefined4 *ticks_ptr;\n  int data_loc;\n  data_loc = DAT_0800123c;\n  ticks_ptr = DAT_08001238;\n  if (ticks_number - 1 < 0x1000000) {\n    DAT_08001238[1] = ticks_number - 1;\n    *(undefined *)(data_loc + 0x23) = 0xf0;\n    ticks_ptr[2] = 0;\n    *ticks_ptr = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001214",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08001214"
        },
        "FUN_08003fc4": {
            "renaming": {
                "FUN_08003fc4": "set_pwm_value_08003fc4",
                "pwm": "pwm_value",
                "PTR_htim4_08003fcc": "htim4",
                "* (int *) PTR_htim4_08003fcc + 0x40": "pwm_register",
                "*(int *)(*(int *)PTR_htim4_08003fcc + 0x40)": "*pwm_register"
            },
            "code": "void set_pwm_value_08003fc4(int pwm_value) {\n    int* PTR_htim4_08003fcc = (int*) PTR_PTR_htim4_08003fcc_08003fcc;\n    int* * (int *) PTR_PTR_htim4_08003fcc_08003fcc + 0x40 = (int*) (PTR_htim4_08003fcc + 0x40);\n    *(int *)(*(int *)PTR_PTR_htim4_08003fcc_08003fcc + 0x40) = pwm_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fc4",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_value_08003fc4"
        },
        "FUN_0800209c": {
            "renaming": {
                "FUN_0800209c": "set_clock_init_0800209c",
                "*RCC_ClkInitStruct": "*clk_init_struct",
                "FLatency": "flash_latency",
                "cVar1": "char_1",
                "cVar2": "char_2",
                "*puVar3": "*ptr_3",
                "uVar4": "uint_4",
                "uVar5": "uint_5",
                "uVar6": "uint_6",
                "uVar7": "uint_7",
                "DAT_08002204": "flash_latency_reg",
                "RCC_ClkInitStruct->ClockType": "clk_init_struct->ClockType",
                "DAT_08002208[1]": "ahb_apb_clk_reg[1]",
                "RCC_ClkInitStruct->AHBCLKDivider": "clk_init_struct->AHBCLKDivider",
                "-1": "neg_one",
                "RCC_ClkInitStruct->SYSCLKSource": "clk_init_struct->SYSCLKSource",
                "count_leading_zeroes(0xf000000)": "count_leading_zeroes(0xf000000)",
                "PTR_SystemCoreClock_08002210": "PTR_SystemCoreClock_08002210",
                "PTR_AHBPrescTable_0800220c": "PTR_AHBPrescTable_0800220c",
                "RCC_ClkInitStruct->APB1CLKDivider": "clk_init_struct->APB1CLKDivider",
                "RCC_ClkInitStruct->APB2CLKDivider": "clk_init_struct->APB2CLKDivider",
                "HAL_RCC_GetSysClockFreq()": "HAL_RCC_GetSysClockFreq()",
                "flash_latency > (*DAT_08002204 & 7)": "flash_latency > (*flash_latency_reg & 7)",
                "flash_latency != (*puVar3 & 7)": "flash_latency != (*flash_latency_reg & 7)",
                "*DAT_08002204 = *DAT_08002204 & 0xfffffff8 | flash_latency": "*flash_latency_reg = *flash_latency_reg & 0xfffffff8 | flash_latency",
                "clock_type & RCC_CLOCKTYPE_HCLK": "clock_type & RCC_CLOCKTYPE_HCLK",
                "ahb_apb_clk_reg[1] & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider": "ahb_apb_clk_reg[1] & 0xffffff0f | ahb_clk_divider",
                "clock_type & RCC_CLOCKTYPE_PCLK1": "clock_type & RCC_CLOCKTYPE_PCLK1",
                "ahb_apb_clk_reg[1] & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider << 8": "ahb_apb_clk_reg[1] & 0xfffff8ff | apb1_clk_divider << 8",
                "clock_type & RCC_CLOCKTYPE_PCLK2": "clock_type & RCC_CLOCKTYPE_PCLK2",
                "ahb_apb_clk_reg[1] & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3": "ahb_apb_clk_reg[1] & 0xffffc7ff | apb2_clk_divider << 3",
                "sys_clk_source == 1": "sys_clk_source == RCC_SYSCLKSOURCE_HSI",
                "sys_clk_source == 2": "sys_clk_source == RCC_SYSCLKSOURCE_HSE",
                "ahb_apb_clk_reg[1] & 0xfffffffc | RCC_SYSCLKSOURCE_PLLCLK": "ahb_apb_clk_reg[1] & 0xfffffffc | RCC_SYSCLKSOURCE_PLLCLK",
                "ahb_apb_clk_reg[1] & RCC_CFGR_SWS": "ahb_apb_clk_reg[1] & RCC_CFGR_SWS",
                "sys_clk_source << 2": "sys_clk_source << 2",
                "*(uint32_t *)PTR_SystemCoreClock_08002210 = uVar5 >> PTR_AHBPrescTable_0800220c[(ahb_apb_clk_reg[1] & RCC_CFGR_HPRE) >> ahb_presc_table_index]": "*(uint32_t*)PTR_SystemCoreClock_08002210 = sys_clk_freq >> PTR_AHBPrescTable_0800220c[(ahb_apb_clk_reg[1] & RCC_CFGR_HPRE) >> ahb_presc_table_index]",
                "HAL_InitTick(0)": "HAL_InitTick(0)",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_GetTick()": "HAL_GetTick()",
                "tick_start": "tick_start",
                "tick_wait": "tick_wait"
            },
            "code": "HAL_StatusTypeDef set_clock_init_0800209c(RCC_ClkInitTypeDef *clk_init_struct, uint32_t flash_latency) {\n  uint32_t clock_type = clk_init_struct->ClockType;\n  uint32_t sys_clk_freq = HAL_RCC_GetSysClockFreq();\n  uint32_t ahb_presc_table_index = count_leading_zeroes(0xf000000);\n  uint32_t ahb_clk_divider = clk_init_struct->AHBCLKDivider;\n  uint32_t apb1_clk_divider = clk_init_struct->APB1CLKDivider;\n  uint32_t apb2_clk_divider = clk_init_struct->APB2CLKDivider;\n  uint32_t sys_clk_source = clk_init_struct->SYSCLKSource;\n  uint32_t tick_start = HAL_GetTick();\n  uint32_t tick_wait = 0x1389;\n  uint32_t* ahb_apb_clk_reg = DAT_08002208;\n  uint32_t* DAT_08002204 = DAT_08002204;\n  \n  if (flash_latency > (*DAT_08002204 & 7) || (flash_latency != (*DAT_08002204 & 7) && (*DAT_08002204 = *DAT_08002204 & 0xfffffff8 | flash_latency, 1))) {\n    if (clock_type & RCC_CLOCKTYPE_HCLK) {\n      DAT_08002208[1] = DAT_08002208[1] & 0xffffff0f | ahb_clk_divider;\n    }\n    if (clock_type & RCC_CLOCKTYPE_PCLK1) {\n      DAT_08002208[1] = DAT_08002208[1] & 0xfffff8ff | apb1_clk_divider << 8;\n    }\n    if (clock_type & RCC_CLOCKTYPE_PCLK2) {\n      DAT_08002208[1] = DAT_08002208[1] & 0xffffc7ff | apb2_clk_divider << 3;\n    }\n    if (sys_clk_source == RCC_SYSCLKSOURCE_PLLCLK) {\n      DAT_08002208[1] = DAT_08002208[1] & 0xfffffffc | RCC_SYSCLKSOURCE_PLLCLK;\n      while ((DAT_08002208[1] & RCC_CFGR_SWS) != RCC_SYSCLKSOURCE_PLLCLK) {\n        if (HAL_GetTick() - tick_start >= tick_wait) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((DAT_08002208[1] & RCC_CFGR_SWS) != sys_clk_source << 2) {\n        if (HAL_GetTick() - tick_start >= tick_wait) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    *(uint32_t *)PTR_SystemCoreClock_08002210 = uVar5 >> PTR_AHBPrescTable_0800220c[(DAT_08002208[1] & RCC_CFGR_HPRE) >> ahb_presc_table_index];\n    HAL_InitTick(0);\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800209c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_init_0800209c"
        },
        "FUN_08003f0e": {
            "renaming": {
                "FUN_08003f0e": "update_last_with_beta_08003f0e",
                "var": "filter",
                "current": "current_value",
                "fVar3": "beta",
                "extraout_s0": "new_last",
                "uVar1": "current_times_beta_complement",
                "uVar2": "last_times_beta"
            },
            "code": "float update_last_with_beta_08003f0e(LPF *filter, float current_value) {\n    float beta_complement = 1.0f - filter->beta;\n    float current_times_beta_complement = current_value * beta_complement;\n    float last_times_beta = filter->last * filter->beta;\n    float new_last = current_times_beta_complement + last_times_beta;\n    filter->last = new_last;\n    return new_last;\n}",
            "called": [
                "__aeabi_fmul",
                "__addsf3",
                "__aeabi_fsub"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0e",
            "calling": [
                "AHRS_GetPitch",
                "AHRS_GetRoll"
            ],
            "imported": false,
            "current_name": "update_last_with_beta_08003f0e"
        },
        "FUN_0800403c": {
            "renaming": {
                "FUN_0800403c": "write_i2c_register_0800403c",
                "device_add": "device_address",
                "register_add": "register_address",
                "register_val": "register_value",
                "delay_mode": "delay_enabled",
                "HVar1": "status",
                "byte": "buffer"
            },
            "code": "void write_i2c_register_0800403c(uint16_t device_address, uint16_t register_address, uint8_t register_value, uint8_t delay_enabled) {\n    HAL_StatusTypeDef status;\n    uint8_t buffer[1];\n    buffer[0] = register_value;\n    status = HAL_I2C_Mem_Write((I2C_HandleTypeDef *)PTR_hi2c1_08004074, device_address, register_address, 1, buffer, 1, 200);\n    if (status != HAL_OK) {\n        _Error_Handler(PTR_s____Src_i2c_c_08004078, 0x1b);\n    }\n    if (delay_enabled) {\n        delay_ms(50);\n    }\n    return;\n}",
            "called": [
                "HAL_I2C_Mem_Write",
                "delay_ms",
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800403c",
            "calling": [
                "MPU9250_Init",
                "MS5611_Update",
                "MS5611_Init",
                "AK8963_Init"
            ],
            "imported": false,
            "current_name": "write_i2c_register_0800403c"
        },
        "FUN_08000cec": {
            "renaming": {
                "FUN_08000cec": "FUNC_08000cec"
            },
            "code": "\nuint FUNC_08000cec(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar3 = param_1 >> 0x17 & 0xff;\n  bVar9 = uVar3 == 0;\n  if (!bVar9) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    bVar9 = param_4 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar3 == 0xff;\n  }\n  if (!bVar9) {\n    bVar9 = param_4 == 0xff;\n  }\n  if (bVar9) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    if (uVar3 == 0xff || param_4 == 0xff) {\n      bVar9 = param_1 == 0 || param_1 == 0x80000000;\n      uVar2 = param_2;\n      if (param_1 != 0 && param_1 != 0x80000000) {\n        bVar9 = param_2 == 0;\n        uVar2 = param_1;\n      }\n      if (!bVar9) {\n        bVar9 = param_2 == 0x80000000;\n      }\n      uVar8 = uVar2;\n      if (((bVar9) || ((uVar3 == 0xff && ((uVar2 & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (uVar8 = param_2, (param_2 & 0x7fffff) != 0)))) {\n        return uVar8 | 0x7fc00000;\n      }\n      uVar2 = uVar2 ^ param_2;\n      goto LAB_08000e3c;\n    }\n    bVar9 = (param_1 & 0x7fffffff) == 0;\n    if (!bVar9) {\n      bVar9 = (param_2 & 0x7fffffff) == 0;\n    }\n    if (bVar9) {\n      return (param_1 ^ param_2) & 0x80000000;\n    }\n    bVar9 = uVar3 == 0;\n    uVar2 = param_1 & 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_1 = param_1 << 1;\n        bVar9 = (param_1 & 0x800000) == 0;\n      }\n      if (!bVar9) break;\n      uVar3 = uVar3 - 1;\n    }\n    param_1 = param_1 | uVar2;\n    bVar9 = param_4 == 0;\n    uVar2 = param_2 & 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_2 = param_2 << 1;\n        bVar9 = (param_2 & 0x800000) == 0;\n      }\n      if (!bVar9) break;\n      param_4 = param_4 - 1;\n    }\n    param_2 = param_2 | uVar2;\n  }\n  iVar4 = uVar3 + param_4;\n  uVar8 = param_1 ^ param_2;\n  uVar3 = param_1 << 9;\n  bVar9 = uVar3 == 0;\n  if (!bVar9) {\n    param_2 = param_2 << 9;\n    bVar9 = param_2 == 0;\n  }\n  if (bVar9) {\n    if (uVar3 == 0) {\n      param_2 = param_2 << 9;\n    }\n    uVar2 = uVar8 & 0x80000000 | param_1 & 0x7fffff | param_2 >> 9;\n    bVar10 = SBORROW4(iVar4,0x7f);\n    iVar5 = iVar4 + -0x7f;\n    bVar9 = iVar5 == 0;\n    iVar7 = iVar5;\n    if (!bVar9 && 0x7e < iVar4) {\n      bVar10 = SBORROW4(0xff,iVar5);\n      iVar7 = 0xff - iVar5;\n      bVar9 = iVar5 == 0xff;\n    }\n    if (!bVar9 && iVar7 < 0 == bVar10) {\n      uVar2 = uVar2 | iVar5 * 0x800000;\n    }\n    if (!bVar9 && iVar7 < 0 == bVar10) {\n      return uVar2;\n    }\n    uVar2 = uVar2 | 0x800000;\n    uVar6 = 0;\n    bVar10 = SBORROW4(iVar5,1);\n    uVar8 = iVar4 - 0x80;\n    bVar9 = uVar8 == 0;\n    uVar3 = uVar8;\n  }\n  else {\n    lVar1 = (ulonglong)(uVar3 >> 5 | 0x8000000) * (ulonglong)(param_2 >> 5 | 0x8000000);\n    uVar6 = (uint)lVar1;\n    uVar2 = (uint)((ulonglong)lVar1 >> 0x20);\n    bVar9 = uVar2 < 0x800000;\n    if (bVar9) {\n      uVar2 = uVar2 << 1;\n    }\n    if (bVar9) {\n      uVar2 = uVar2 | uVar6 >> 0x1f;\n      uVar6 = uVar6 << 1;\n    }\n    uVar2 = uVar8 & 0x80000000 | uVar2;\n    uVar8 = (iVar4 + -0x7f) - (uint)bVar9;\n    bVar10 = SBORROW4(uVar8,0xfd);\n    bVar9 = uVar8 == 0xfd;\n    uVar3 = uVar8 - 0xfd;\n    if (uVar8 < 0xfe) {\n      uVar2 = uVar2 + uVar8 * 0x800000 + (uint)(0x7fffffff < uVar6);\n      if (uVar6 == 0x80000000) {\n        uVar2 = uVar2 & 0xfffffffe;\n      }\n      return uVar2;\n    }\n  }\n  if (bVar9 || (int)uVar3 < 0 != bVar10) {\n    bVar9 = (int)(uVar8 + 0x19) < 0;\n    if (uVar8 == 0xffffffe7 || bVar9 != SCARRY4(uVar8,0x19)) {\n      uVar2 = uVar2 & 0x80000000;\n    }\n    if (uVar8 != 0xffffffe7 && bVar9 == SCARRY4(uVar8,0x19)) {\n      uVar3 = (uVar2 << 1) >> (-uVar8 & 0xff);\n      uVar8 = uVar2 << (uVar8 + 0x20 & 0xff);\n      uVar3 = ((uint)((uVar2 & 0x80000000) != 0) << 0x1f | uVar3 >> 1) + (uint)((byte)uVar3 & 1);\n      if ((uVar6 | uVar8 << 1) == 0) {\n        uVar3 = uVar3 & ~(uVar8 >> 0x1f);\n      }\n      return uVar3;\n    }\n    return uVar2;\n  }\nLAB_08000e3c:\n  return uVar2 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000cec",
            "calling": [
                "AK8963_ReadData",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "PID_Update",
                "MPU9250_ReadGyroData",
                "lowPassFilter",
                "AK8963_Init",
                "PID_Compute",
                "MPU9250_ReadAccelData",
                "PID_UpdateAltitude"
            ],
            "imported": false,
            "current_name": "FUNC_08000cec"
        },
        "FUN_0800277c": {
            "renaming": {
                "FUN_0800277c": "send_data_over_uart_0800277c",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "HVar3": "uart_state",
                "pUVar4": "uart_instance"
            },
            "code": "HAL_StatusTypeDef send_data_over_uart_0800277c(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size, uint32_t timeout)\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  HAL_UART_StateTypeDef uart_state;\n  USART_TypeDef *uart_instance;\n  \n  if ((uart_handle->State == HAL_UART_STATE_READY) || (uart_handle->State == HAL_UART_STATE_BUSY_RX)) {\n    if ((data == NULL) || (size == 0)) {\n      return HAL_ERROR;\n    }\n    if (uart_handle->Lock != HAL_LOCKED) {\n      uart_handle->Lock = HAL_LOCKED;\n      uart_handle->ErrorCode = 0;\n      uart_handle->TxXferSize = size;\n      if (uart_handle->State == HAL_UART_STATE_BUSY_RX) {\n        uart_state = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uart_state = HAL_UART_STATE_BUSY_TX;\n      }\n      uart_handle->TxXferCount = size;\n      uart_handle->State = uart_state;\nLAB_080027c4:\n      if (uart_handle->TxXferCount == 0) {\n        start_time = HAL_GetTick();\n        do {\n          do {\n            if ((int)(uart_handle->Instance->SR << 0x19) < 0) {\n              if (uart_handle->State == HAL_UART_STATE_BUSY_TX_RX) {\n                uart_state = HAL_UART_STATE_BUSY_RX;\n              }\n              else {\n                uart_state = HAL_UART_STATE_READY;\n              }\n              uart_handle->State = uart_state;\n              uart_handle->Lock = HAL_UNLOCKED;\n              return HAL_OK;\n            }\n          } while (timeout == 0xffffffff);\n        } while ((timeout != 0) && (current_time = HAL_GetTick(), current_time - start_time <= timeout));\n      }\n      else {\n        uart_handle->TxXferCount = uart_handle->TxXferCount - 1;\n        if ((uart_handle->Init).WordLength == 0x1000) {\n          start_time = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uart_handle->Instance->SR << 0x18) < 0) {\n                uart_handle->Instance->DR = *(ushort *)data & 0x1ff;\n                if ((uart_handle->Init).Parity == 0) {\n                  data = (uint8_t *)((int)data + 2);\n                }\n                else {\n                  data = (uint8_t *)((int)data + 1);\n                }\n                goto LAB_080027c4;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (current_time = HAL_GetTick(), current_time - start_time <= timeout));\n        }\n        else {\n          start_time = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uart_handle->Instance->SR << 0x18) < 0) {\n                uart_handle->Instance->DR = (uint)*data;\n                goto LAB_080027c4;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (current_time = HAL_GetTick(), current_time - start_time <= timeout));\n        }\n      }\n      uart_instance = uart_handle->Instance;\n      uart_instance->CR1 = uart_instance->CR1 & 0xffffff7f;\n      uart_instance->CR1 = uart_instance->CR1 & 0xffffffdf;\n      uart_instance->CR1 = uart_instance->CR1 & 0xfffffeff;\n      uart_instance->CR3 = uart_instance->CR3 & 0xfffffffe;\n      uart_handle->State = HAL_UART_STATE_READY;\n      uart_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800277c",
            "calling": [
                "serialWrite"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_0800277c"
        },
        "FUN_0800483c": {
            "renaming": {
                "FUN_0800483c": "calculate_pid_output_0800483c",
                "pid": "pid_struct",
                "uVar1": "float_add_result",
                "iVar2": "comparison_result",
                "uVar3": "float_mul_result",
                "fVar4": "proportional_term",
                "fVar5": "derivative_term",
                "fVar6": "integral_term",
                "set_point": "pid_set_point",
                "offset": "pid_offset",
                "input": "pid_input",
                "error": "pid_error",
                "instance": "pid_instance",
                "con_KP": "pid_constant_KP",
                "integral": "pid_integral",
                "con_KI": "pid_constant_KI",
                "con_KD": "pid_constant_KD",
                "last_input": "pid_last_input",
                "derivative": "pid_derivative",
                "output": "pid_output",
                "direction": "pid_direction",
                "last_error": "pid_last_error",
                "last_time": "pid_last_time",
                "DAT_08004974": "error_threshold_small",
                "DAT_08004964": "error_threshold_big",
                "DAT_0800496c": "output_limit_low",
                "DAT_08004970": "output_limit_high"
            },
            "code": "void calculate_pid_output_0800483c(PID_TypeDef *pid)\n{\n    float input = pid->input;\n    float set_point = pid->set_point;\n    float offset = pid->offset;\n    float error = set_point + offset - input;\n    pid->error = error;\n    \n    if (pid->instance == 3) {\n        bool error_is_positive = error > 0;\n        bool error_is_small = error < DAT_08004974;\n        bool error_is_big = error > DAT_08004964;\n        \n        if ((error_is_positive && error_is_big) || (!error_is_positive && error_is_small)) {\n            float proportional = pid->con_KP * error;\n            float integral = pid->integral + error;\n            \n            if (integral < DAT_0800496c) {\n                integral = DAT_0800496c;\n            }\n            else if (integral > DAT_08004970) {\n                integral = DAT_08004970;\n            }\n            \n            float derivative = input - pid->last_input;\n            float output = pid->con_KP * error + pid->con_KI * integral - pid->con_KD * derivative;\n            \n            if (output < DAT_0800496c) {\n                output = DAT_0800496c;\n            }\n            else if (output > DAT_08004970) {\n                output = DAT_08004970;\n            }\n            \n            output *= pid->direction;\n            pid->proportional = proportional;\n            pid->integral = integral;\n            pid->derivative = derivative;\n            pid->output = output;\n            pid->last_input = input;\n            pid->last_error = error;\n            pid->last_time = pid->time;\n        }\n    }\n}",
            "called": [
                "__aeabi_fmul",
                "__aeabi_fcmpgt",
                "__floatsisf",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fdiv",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800483c",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_pid_output_0800483c"
        },
        "FUN_08001064": {
            "renaming": {
                "FUN_08001064": "is_end_of_input_08001064",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_input_08001064(void)\n{\n  char current_char;\n  __aeabi_cfrcmple();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001064",
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "is_end_of_input_08001064"
        },
        "FUN_08000892": {
            "renaming": {
                "FUN_08000892": "decode_bits_08000892",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "msb_input_1",
                "unaff_r4": "mask",
                "uVar2": "mask_shifted",
                "uVar3": "output_2",
                "in_r12": "constant",
                "bVar4": "is_input_1_2_zero"
            },
            "code": "ulonglong decode_bits_08000892(uint input_1, uint input_2, uint input_3, uint input_4) {\n  uint mask = input_4 >> 0x14;\n  uint output_2 = input_2;\n  if (input_3 != input_4 || mask != input_4) {\n    if (input_3 == input_4) {\n      if (((input_1 | input_2 << 0xc) == 0) && (input_1 = input_3, output_2 = input_4, mask != input_4)) {\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (mask == input_4) {\n      input_1 = input_3;\n      output_2 = input_4;\n      if ((input_3 | input_4 << 0xc) == 0) {\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bool is_input_1_2_zero = (input_1 | input_2 << 1) == 0;\n      if (!is_input_1_2_zero) {\n        is_input_1_2_zero = (input_3 | input_4 << 1) == 0;\n      }\n      if (!is_input_1_2_zero) {\n        if (input_3 == 0) {\n          output_2 = input_2 & 0x80000000;\n          do {\n            uint msb_input_1 = input_1 & 0x80000000;\n            input_1 = input_1 << 1;\n            input_2 = input_2 * 2 + (uint)(msb_input_1 != 0);\n          } while ((input_2 & 0x100000) == 0);\n          input_2 = input_2 | output_2;\n          if (mask != 0) {\n            return CONCAT44(input_2,input_1);\n          }\n        }\n        do {\n          output_2 = input_3 & 0x80000000;\n          input_3 = input_3 << 1;\n          input_4 = input_4 * 2 + (uint)(output_2 != 0);\n        } while ((input_4 & 0x100000) == 0);\n        return CONCAT44(input_2,input_1);\n      }\n      if ((input_1 | input_2 << 1) != 0) goto LAB_08000704;\n      if ((input_3 | input_4 << 1) != 0) goto LAB_080006c8;\n    }\n  }\n  return CONCAT44(output_2,input_1) | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000892",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "decode_bits_08000892"
        },
        "FUN_08004458": {
            "renaming": {
                "FUN_08004458": "reverse_and_send_data_08004458",
                "puVar1": "destination_ptr",
                "puVar5": "source_ptr",
                "puVar4": "temp_ptr",
                "puVar3": "temp_destination_ptr",
                "uVar2": "temp_uint32_t",
                "local_30": "data",
                "local_24": "data2"
            },
            "code": "void reverse_and_send_data_08004458(void)\n{\n    uint32_t *source_ptr;\n    uint32_t *destination_ptr;\n    uint32_t temp1;\n    uint32_t temp2;\n    uint32_t temp3;\n    uint8_t data[30];\n    uint16_t data2[10];\n    \n    source_ptr = (uint32_t *)msp_txf_pid_0800448c;\n    destination_ptr = (uint32_t *)data;\n    for(int i=0; i<3; i++)\n    {\n        temp1 = *source_ptr++;\n        temp2 = *source_ptr++;\n        temp3 = *source_ptr++;\n        *destination_ptr++ = temp3;\n        *destination_ptr++ = temp2;\n        *destination_ptr++ = temp1;\n    }\n    temp1 = *source_ptr++;\n    temp2 = *source_ptr;\n    data2[0] = (uint16_t)temp1;\n    data2[1] = (uint16_t)(temp1 >> 16);\n    data2[2] = (uint16_t)temp2;\n    data2[3] = (uint16_t)(temp2 >> 16);\n    MSP_SendFrame('p', (uint8_t *)data, 0x1e);\n}\n",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004458",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "reverse_and_send_data_08004458"
        },
        "FUN_08004d48": {
            "renaming": {
                "FUN_08004d48": "configure_i2c_gpio_pins_08004d48",
                "hi2c": "i2c_handle",
                "GPIO_InitStruct": "gpio_init_structure",
                "DAT_08004d80": "I2C1",
                "DAT_08004d84": "GPIOB",
                "DAT_08004d88": "0x40005400"
            },
            "code": "void configure_i2c_gpio_pins_08004d48(I2C_HandleTypeDef *i2c_handle)\n{\n  uint32_t tmp_reg;\n  GPIO_InitTypeDef gpio_init_structure;\n  if (i2c_handle->Instance == DAT_08004d80) {\n    gpio_init_structure.Pin = GPIO_PIN_6 | GPIO_PIN_7;\n    gpio_init_structure.Mode = GPIO_MODE_AF_OD;\n    gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(DAT_08004d84, &gpio_init_structure);\n    *(uint *)(DAT_08004d88 + 0x1c) = *(uint *)(DAT_08004d88 + 0x1c) | 0x200000;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d48",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "configure_i2c_gpio_pins_08004d48"
        },
        "FUN_08002280": {
            "renaming": {
                "FUN_08002280": "configure_timer_08002280",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "ccer_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode",
                "DAT_080022cc": "PTR_080022cc",
                "CCER": "ccer_mask",
                "CCR1": "capture_compare_register_value"
            },
            "code": "void configure_timer_08002280(TIM_TypeDef *timer, TIM_OC_InitTypeDef *output_compare_config)\n{\n  uint32_t ccer_mask = 0xfffffffe;\n  uint32_t cr2_value = timer->CR2;\n  uint oc_mode = output_compare_config->OCMode;\n  uint32_t ccer_value = (timer->CCER & 0xfffffffd) | output_compare_config->OCPolarity;\n  if (timer == DAT_080022cc) {\n    ccer_value = (ccer_value & 0xfffffff7 | output_compare_config->OCNPolarity) & 0xfffffffb;\n    cr2_value = cr2_value & 0xfffffcff | output_compare_config->OCIdleState | output_compare_config->OCNIdleState;\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | oc_mode;\n  timer->CCR1 = output_compare_config->Pulse;\n  timer->CCER = ccer_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002280",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08002280"
        },
        "FUN_08001194": {
            "renaming": {
                "FUN_08001194": "set_interrupt_priority_08001194",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_value",
                "uVar2": "priority_value",
                "uVar3": "group_priority_bits",
                "uVar4": "priority_shift",
                "uVar5": "sub_priority_bits"
            },
            "code": "void set_interrupt_priority_08001194(IRQn_Type irq, uint32_t preempt_priority, uint32_t sub_priority)\n{\n  uint32_t priority_mask, priority_value;\n  uint32_t priority_shift = (uint32_t)(*(int *)(DAT_080011f4 + 0xc) << 0x15) >> 0x1d;\n  uint32_t group_priority_bits = 7 - priority_shift;\n  uint32_t sub_priority_bits = priority_shift + 4;\n  if (group_priority_bits > 3) {\n    group_priority_bits = 4;\n  }\n  if (sub_priority_bits < 7) {\n    priority_shift = 0;\n  }\n  group_priority_bits = (1 << (group_priority_bits & 0xff)) - 1;\n  if (sub_priority_bits > 6) {\n    priority_shift = priority_shift - 3;\n  }\n  priority_value = (sub_priority & (1 << (priority_shift & 0xff)) - 1U | (preempt_priority & group_priority_bits) << (priority_shift & 0xff)) << 4;\n  if ((int)irq >= 0) {\n    priority_shift = irq + 0xe000e100;\n  }\n  else {\n    priority_shift = irq & 0xf;\n    group_priority_bits = DAT_080011f8;\n  }\n  if ((int)irq >= 0) {\n    *(undefined *)(priority_shift + 0x300) = (undefined)priority_value;\n  }\n  else {\n    *(undefined *)(group_priority_bits + priority_shift) = (undefined)priority_value;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001194",
            "calling": [
                "HAL_InitTick",
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08001194"
        },
        "FUN_08004348": {
            "renaming": {
                "FUN_08004348": "send_msp_tx_frame_08004348",
                "puVar1": "tx_frame",
                "local_10": "frame_data",
                "local_c": "frame_length"
            },
            "code": "void send_msp_tx_frame_08004348(void)\n{\n    uint8_t* tx_frame = PTR_msp_txf_ident_08004380;\n    tx_frame[0] = 0xe9;\n    tx_frame[1] = 3;\n    tx_frame[2] = 0;\n    tx_frame[3] = 4;\n    *(uint32_t*)&tx_frame[4] = 0;\n    tx_frame[7] = 0;\n    tx_frame[8] = 0;\n    tx_frame[9] = 0;\n    uint32_t frame_data = *(uint32_t*)tx_frame;\n    uint32_t frame_length = (in_r1 & 0xff000000) | *(uint16_t*)(tx_frame + 4);\n    MSP_SendFrame('d', (uint8_t*)&frame_data, 10);\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004348",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_msp_tx_frame_08004348"
        },
        "FUN_08001078": {
            "renaming": {
                "FUN_08001078": "convert_param_to_value_08001078",
                "param_1": "param",
                "uVar1": "shift_amount",
                "uVar2": "uVar2",
                "shifted_value": "shifted_value"
            },
            "code": "uint convert_param_to_value_08001078(uint param)\n{\n  if (param << 1 < 0x7f000000) {\n    return 0;\n  }\n  uint shift_amount = (param << 1) >> 0x18;\n  uint uVar2 = 0x9e - shift_amount;\n  if (shift_amount < 0x9f && uVar2 != 0) {\n    uint shifted_value = (param << 8 | 0x80000000) >> (uVar2 & 0xff);\n    if ((param & 0x80000000) != 0) {\n      shifted_value = -shifted_value;\n    }\n    return shifted_value;\n  }\n  if ((uVar2 == 0xffffff9f) && ((param & 0x7fffff) != 0)) {\n    return 0;\n  }\n  param = param & 0x80000000;\n  if (param == 0) {\n    param = 0x7fffffff;\n  }\n  return param;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001078",
            "calling": [
                "MS5611_Update",
                "AHRS_ComputeAngles",
                "Motor_DistributeSpeed"
            ],
            "imported": false,
            "current_name": "convert_param_to_value_08001078"
        },
        "FUN_08001754": {
            "renaming": {
                "FUN_08001754": "configure_i2c_08001754",
                "hi2c": "i2c_handle",
                "uVar1": "pclk1_freq",
                "extraout_r1": "timeout",
                "uVar2": "ccr_value",
                "pIVar3": "i2c_instance",
                "uVar4": "clock_speed",
                "uVar5": "DAT_08001820",
                "uVar6": "rise_time",
                "hi2c->State": "state",
                "hi2c->Lock": "lock",
                "HAL_I2C_MspInit": "HAL_I2C_MspInit",
                "hi2c->Instance->CR1": "i2c_instance->CR1",
                "HAL_RCC_GetPCLK1Freq": "HAL_RCC_GetPCLK1Freq",
                "hi2c->Init": "i2c_handle->Init",
                "i2c_handle->ErrorCode": "i2c_handle->ErrorCode",
                "i2c_handle->State": "i2c_handle->State",
                "i2c_handle->Mode": "i2c_handle->Mode",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_I2C_STATE_BUSY": "HAL_I2C_STATE_BUSY",
                "HAL_I2C_STATE_RESET": "HAL_I2C_STATE_RESET",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE"
            },
            "code": "HAL_StatusTypeDef configure_i2c_08001754(I2C_HandleTypeDef *i2c_handle)\n{\n  uint32_t pclk1_freq, clock_speed, rise_time, ccr_value;\n  I2C_TypeDef *i2c_instance;\n  uint8_t no_stretch_mode, general_call_mode;\n  uint16_t addressing_mode, own_address1, dual_address_mode, own_address2;\n  uint state, lock;\n  uint timeout = 300;\n  if (i2c_handle == NULL) {\n    return HAL_ERROR;\n  }\n  state = i2c_handle->State;\n  if (state == HAL_I2C_STATE_RESET) {\n    lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(i2c_handle);\n  }\n  i2c_handle->State = HAL_I2C_STATE_BUSY;\n  i2c_instance = i2c_handle->Instance;\n  i2c_instance->CR1 &= ~(1U);\n  pclk1_freq = HAL_RCC_GetPCLK1Freq();\n  clock_speed = i2c_handle->Init.ClockSpeed;\n  rise_time = pclk1_freq / 1000000U + 1U;\n  if (clock_speed < DAT_08001820) {\n    timeout = (pclk1_freq / DAT_08001824) * timeout / 1000U;\n  }\n  i2c_instance->CR2 = rise_time;\n  if (clock_speed < DAT_08001820) {\n    if (i2c_handle->Init.DutyCycle == 0U) {\n      ccr_value = pclk1_freq / (clock_speed * 3U) | 0x8000U;\n    }\n    else {\n      ccr_value = pclk1_freq / (clock_speed * 25U) | 0xc000U;\n    }\n    if ((ccr_value & 0xfffU) == 0U) {\n      ccr_value |= 1U;\n    }\n  }\n  else {\n    ccr_value = pclk1_freq / (clock_speed << 1U);\n    if ((ccr_value & 0xfffU) < 4U) {\n      ccr_value = 4U;\n    }\n  }\n  no_stretch_mode = i2c_handle->Init.NoStretchMode;\n  general_call_mode = i2c_handle->Init.GeneralCallMode;\n  addressing_mode = i2c_handle->Init.AddressingMode;\n  own_address1 = i2c_handle->Init.OwnAddress1;\n  dual_address_mode = i2c_handle->Init.DualAddressMode;\n  own_address2 = i2c_handle->Init.OwnAddress2;\n  i2c_instance->CCR = ccr_value;\n  i2c_instance->CR1 = (uint32_t)general_call_mode | (uint32_t)no_stretch_mode | 1U;\n  i2c_instance->OAR1 = addressing_mode | own_address1;\n  i2c_instance->OAR2 = dual_address_mode | own_address2;\n  i2c_handle->ErrorCode = 0U;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Mode = HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001754",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configure_i2c_08001754"
        },
        "FUN_08002724": {
            "renaming": {
                "FUN_08002724": "configure_uart_08002724",
                "*huart": "*uart",
                "huart": "uart",
                "pUVar1": "usart_instance"
            },
            "code": "HAL_StatusTypeDef configure_uart_08002724(UART_HandleTypeDef *uart)\n{\n    USART_TypeDef *usart_instance;\n    if (uart != NULL)\n    {\n        if (uart->State == HAL_UART_STATE_RESET)\n        {\n            uart->Lock = HAL_UNLOCKED;\n            HAL_UART_MspInit(uart);\n        }\n        uart->State = HAL_UART_STATE_BUSY;\n        uart->Instance->CR1 &= ~USART_CR1_OVER8;\n        UART_SetConfig(uart);\n        usart_instance = uart->Instance;\n        usart_instance->CR2 &= ~USART_CR2_LINEN;\n        usart_instance->CR3 &= ~USART_CR3_HDSEL;\n        usart_instance->CR1 |= USART_CR1_UE;\n        uart->ErrorCode = 0;\n        uart->State = HAL_UART_STATE_READY;\n        return HAL_OK;\n    }\n    return HAL_ERROR;\n}",
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002724",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_08002724"
        },
        "FUN_080043f0": {
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "local_10": "motor_data_1",
                "uStack_c": "motor_data_2"
            },
            "code": "void send_motor_data_080043f0(void)\n{\n  uint32_t motor_data_1 = *(uint32_t *)PTR_msp_txf_motor_0800440c;\n  uint32_t motor_data_2 = *(uint32_t *)(PTR_msp_txf_motor_0800440c + 4);\n  MSP_SendFrame('h', (uint8_t *)&motor_data_1, 8);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043f0",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_motor_data_080043f0"
        },
        "FUN_08000428": {
            "renaming": {
                "FUN_08000428": "calculate_hash_08000428",
                "param_1": "input_value",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "sign_bit",
                "uVar2": "input_value_copy",
                "uVar3": "shifted_input_with_sign_bit",
                "uVar4": "leading_zeroes_count_diff",
                "uVar5": "shifted_input_divided_by_16_with_sign_bit",
                "uVar7": "leading_zeroes_count",
                "iVar6": "iVar6",
                "in_r12": "in_r12",
                "bVar8": "is_uVar4_zero",
                "bVar9": "is_uVar4_negative",
                "bVar10": "bVar10",
                "shifted_input": "shifted_input",
                "is_shifted_input_zero": "is_shifted_input_zero"
            },
            "code": "ulonglong calculate_hash_08000428(uint input_value, undefined4 param_2, undefined4 param_3, uint param_4)\n{\n  uint shifted_input = input_value << 1;\n  bool is_shifted_input_zero = shifted_input == 0;\n  uint sign_bit = (uint)((input_value & 0x80000000) != 0) << 0x1f;\n  uint shifted_input_divided_by_16 = (uint)((int)shifted_input >> 3) >> 1;\n  uint shifted_input_with_sign_bit = sign_bit | shifted_input_divided_by_16;\n  input_value = input_value << 0x1d;\n  if (!is_shifted_input_zero) {\n    uint shifted_input_and_0xff000000 = shifted_input & 0xff000000;\n    bool is_shifted_input_and_0xff000000_zero = shifted_input_and_0xff000000 == 0;\n    if (!is_shifted_input_and_0xff000000_zero) {\n      is_shifted_input_and_0xff000000_zero = shifted_input_and_0xff000000 == 0xff000000;\n    }\n    if (!is_shifted_input_and_0xff000000_zero) {\n      return CONCAT44(shifted_input_with_sign_bit,input_value) ^ 0x3800000000000000;\n    }\n    if (shifted_input == 0 || shifted_input_and_0xff000000 == 0xff000000) {\n      return CONCAT44(shifted_input_with_sign_bit,input_value);\n    }\n    uint shifted_input_divided_by_16_with_sign_bit = shifted_input_divided_by_16;\n    uint shifted_input_with_sign_bit_copy = input_value;\n    if (shifted_input_divided_by_16 == 0) {\n      shifted_input_with_sign_bit_copy = 0;\n      shifted_input_divided_by_16_with_sign_bit = input_value;\n    }\n    int leading_zeroes_count = count_leading_zeroes(shifted_input_divided_by_16_with_sign_bit);\n    if (shifted_input_divided_by_16 == 0) {\n      leading_zeroes_count = leading_zeroes_count + 0x20;\n    }\n    uint uVar7 = leading_zeroes_count - 0xb;\n    bool bVar10 = SBORROW4(uVar7,0x20);\n    uint uVar4 = leading_zeroes_count - 0x2b;\n    bool is_uVar4_negative = (int)uVar4 < 0;\n    bool is_uVar4_zero = uVar4 == 0;\n    if ((int)uVar7 < 0x20) {\n      bVar10 = SCARRY4(uVar4,0xc);\n      leading_zeroes_count = leading_zeroes_count + -0x1f;\n      is_uVar4_negative = leading_zeroes_count < 0;\n      is_uVar4_zero = leading_zeroes_count == 0;\n      uVar4 = uVar7;\n      if (!is_uVar4_zero && is_uVar4_negative == bVar10) {\n        shifted_input_with_sign_bit_copy = shifted_input_divided_by_16_with_sign_bit << (uVar7 & 0xff);\n        shifted_input_divided_by_16_with_sign_bit = shifted_input_divided_by_16_with_sign_bit >> (0xcU - leading_zeroes_count & 0xff);\n        goto LAB_080002f0;\n      }\n    }\n    if (is_uVar4_zero || is_uVar4_negative != bVar10) {\n      uint in_r12 = 0x20 - uVar4;\n    }\n    shifted_input_divided_by_16_with_sign_bit = shifted_input_divided_by_16_with_sign_bit << (uVar4 & 0xff);\n    if (is_uVar4_zero || is_uVar4_negative != bVar10) {\n      shifted_input_divided_by_16_with_sign_bit = shifted_input_divided_by_16_with_sign_bit | input_value >> (in_r12 & 0xff);\n    }\n    if (is_uVar4_zero || is_uVar4_negative != bVar10) {\n      input_value = input_value << (uVar4 & 0xff);\n    }\n  }\nLAB_080002f0:\n  if ((int)uVar7 < 0x381) {\n    return CONCAT44(shifted_input_divided_by_16_with_sign_bit + (0x380 - uVar7) * 0x100000 | sign_bit,input_value);\n  }\n  uint uVar4 = ~(0x380 - uVar7);\n  if ((int)uVar4 < 0x1f) {\n    int iVar6 = uVar4 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar4 - 0x1f,0xc)) {\n      return CONCAT44(shifted_input_with_sign_bit, input_value >> (0x20 - (0xcU - iVar6) & 0xff) | shifted_input_divided_by_16_with_sign_bit << (0xcU - iVar6 & 0xff)) & 0x80000000ffffffff;\n    }\n    uVar4 = uVar4 + 1;\n    return CONCAT44(sign_bit | shifted_input_divided_by_16_with_sign_bit >> (uVar4 & 0xff), input_value >> (uVar4 & 0xff) | shifted_input_divided_by_16_with_sign_bit << (0x20 - uVar4 & 0xff));\n  }\n  return CONCAT44(shifted_input_with_sign_bit,shifted_input_divided_by_16_with_sign_bit >> (uVar4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000428",
            "calling": [
                "MS5611_Update",
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000428"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "set_interrupt_priorities_08004ccc",
                "tmpreg": "tmp_reg",
                "DAT_08004d44": "interrupt_priority_register"
            },
            "code": "void set_interrupt_priorities_08004ccc(void)\n{\n  uint32_t tmp_reg;\n  uint32_t *DAT_08004d44 = (uint32_t *)(DAT_08004d44 + 0x18);\n  *DAT_08004d44 |= 1;\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  HAL_NVIC_SetPriority(BusFault_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  HAL_NVIC_SetPriority(UsageFault_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  HAL_NVIC_SetPriority(SVCall_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  HAL_NVIC_SetPriority(PendSV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  HAL_NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n  return;\n}\n",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priorities_08004ccc"
        },
        "FUN_08004c30": {
            "renaming": {
                "FUN_08004c30": "receive_uart_data_08004c30",
                "*huart": "*uart_handle",
                "undefined": "uint8_t",
                "*pData": "*data_buffer",
                "PTR_rx_buffer_08004c58": "rx_buffer",
                "DAT_08004c54": "uart_instance",
                "CB_Write": "circular_buffer_write",
                "CircularBuffer": "circular_buffer",
                "*PTR_rxc_08004c5c": "*rx_circular_buffer",
                "*PTR_rx_buffer_08004c58": "*rx_buffer",
                "HAL_UART_Receive_IT": "HAL_UART_Receive_IT",
                "(UART_HandleTypeDef *)PTR_huart1_08004c60": "uart_handle_1"
            },
            "code": "void receive_uart_data_08004c30(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t *data_buffer;\n  data_buffer = PTR_rx_buffer_08004c58;\n  if (uart_handle->Instance == DAT_08004c54) {\n    circular_buffer_write(&rx_circular_buffer, *PTR_PTR_rx_buffer_08004c58_08004c58);\n    HAL_UART_Receive_IT((UART_HandleTypeDef *)PTR_huart1_08004c60, data_buffer, 1);\n    return;\n  }\n  return;\n}",
            "called": [
                "CB_Write",
                "HAL_UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c30",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "receive_uart_data_08004c30"
        },
        "FUN_080004d0": {
            "renaming": {
                "FUN_080004d0": "FUNC_080004d0"
            },
            "code": "\nulonglong FUNC_080004d0(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 = CONCAT44(param_2,param_1);\n  uVar7 = 0x7ff;\n  uVar4 = param_2 >> 0x14 & 0x7ff;\n  bVar9 = uVar4 == 0;\n  if (!bVar9) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar9 = unaff_r5 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar4 == 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 = unaff_r5 == 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 = convert_uint_to_double_080006ac();\n  }\n  uVar3 = (uint)(uVar12 >> 0x20);\n  iVar5 = uVar4 + unaff_r5;\n  uVar4 = uVar3 ^ param_4;\n  uVar3 = uVar3 & ~(uVar7 << 0x15);\n  param_4 = param_4 & ~(uVar7 << 0x15);\n  bVar9 = ((uint)uVar12 | uVar3 << 0xc) == 0;\n  if (!bVar9) {\n    bVar9 = (param_3 | param_4 << 0xc) == 0;\n  }\n  uVar3 = uVar3 | 0x100000;\n  param_4 = param_4 | 0x100000;\n  if (bVar9) {\n    param_3 = (uint)uVar12 | param_3;\n    param_4 = (uVar4 & 0x80000000 | uVar3) ^ param_4;\n    uVar4 = uVar7 >> 1;\n    bVar11 = SBORROW4(iVar5,uVar4);\n    uVar6 = iVar5 - uVar4;\n    bVar9 = uVar6 == 0;\n    uVar3 = uVar6;\n    if (!bVar9 && (int)uVar4 <= iVar5) {\n      bVar11 = SBORROW4(uVar7,uVar6);\n      uVar3 = uVar7 - uVar6;\n      bVar9 = uVar7 == uVar6;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      param_4 = param_4 | uVar6 * 0x100000;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      return CONCAT44(param_4,param_3);\n    }\n    param_4 = param_4 | 0x100000;\n    uVar7 = 0;\n    bVar11 = SBORROW4(uVar6,1);\n    uVar6 = uVar6 - 1;\n    bVar9 = uVar6 == 0;\n    uVar4 = uVar6;\n  }\n  else {\n    uVar1 = (uVar12 & 0xffffffff) * (ulonglong)param_3;\n    uVar12 = (uVar12 & 0xffffffff) * (ulonglong)param_4 +\n             (ulonglong)uVar3 * (ulonglong)param_3 + (uVar1 >> 0x20);\n    uVar8 = (uint)uVar12;\n    lVar2 = (ulonglong)uVar3 * (ulonglong)param_4 + (uVar12 >> 0x20);\n    uVar7 = (uint)lVar2;\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    if ((int)uVar1 != 0) {\n      uVar8 = uVar8 | 1;\n    }\n    uVar6 = (iVar5 + -0x3ff) - (uint)(uVar3 < 0x200);\n    if (uVar3 < 0x200) {\n      bVar9 = (uVar8 & 0x80000000) != 0;\n      uVar8 = uVar8 << 1;\n      lVar2 = CONCAT44(uVar3 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    param_4 = uVar4 & 0x80000000 | (int)((ulonglong)lVar2 >> 0x20) << 0xb | (uint)lVar2 >> 0x15;\n    param_3 = (uint)lVar2 << 0xb | uVar8 >> 0x15;\n    uVar7 = uVar8 * 0x800;\n    bVar10 = 0xfc < uVar6;\n    bVar11 = SBORROW4(uVar6,0xfd);\n    uVar3 = uVar6 - 0xfd;\n    bVar9 = uVar3 == 0;\n    uVar4 = uVar3;\n    if (bVar10 && !bVar9) {\n      bVar10 = 0x6ff < uVar3;\n      bVar11 = SBORROW4(uVar3,0x700);\n      uVar4 = uVar6 - 0x7fd;\n      bVar9 = uVar3 == 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 = 0x7fffffff < uVar7;\n      if (uVar7 == 0x80000000) {\n        bVar9 = (uVar8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(param_4 + uVar6 * 0x100000 + (uint)CARRY4(param_3,(uint)bVar9),param_3 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 && (int)uVar4 < 0 == bVar11) {\n    return (ulonglong)(param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar10 = SCARRY4(uVar6,0x36);\n  bVar9 = (int)(uVar6 + 0x36) < 0;\n  bVar11 = uVar6 == 0xffffffca;\n  if (bVar11 || bVar9 != bVar10) {\n    param_3 = 0;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    param_4 = param_4 & 0x80000000;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    return CONCAT44(param_4,param_3);\n  }\n  uVar4 = -uVar6;\n  uVar3 = uVar4 - 0x20;\n  if (0x1f < (int)uVar4) {\n    uVar6 = param_3 >> (uVar3 & 0xff) | param_4 << (0x20 - uVar3 & 0xff);\n    uVar4 = (param_4 >> (uVar3 & 0xff) & ~((param_4 & 0x80000000) >> (uVar3 & 0xff))) -\n            ((int)uVar6 >> 0x1f);\n    if ((uVar7 | param_3 << (0x20 - uVar3 & 0xff) | uVar6 << 1) == 0) {\n      uVar4 = uVar4 & ~(uVar6 >> 0x1f);\n    }\n    return CONCAT44(param_4,uVar4) & 0x80000000ffffffff;\n  }\n  iVar5 = uVar4 - 0x14;\n  if (iVar5 == 0 || iVar5 < 0 != SCARRY4(uVar3,0xc)) {\n    uVar8 = param_3 << (uVar6 + 0x20 & 0xff);\n    uVar3 = param_3 >> (uVar4 & 0xff) | param_4 << (uVar6 + 0x20 & 0xff);\n    uVar6 = uVar3 + -((int)uVar8 >> 0x1f);\n    if ((uVar7 | uVar8 << 1) == 0) {\n      uVar6 = uVar6 & ~(uVar8 >> 0x1f);\n    }\n    return CONCAT44((param_4 & 0x80000000) +\n                    ((param_4 & 0x7fffffff) >> (uVar4 & 0xff)) +\n                    (uint)CARRY4(uVar3,-((int)uVar8 >> 0x1f)),uVar6);\n  }\n  uVar4 = 0xc - iVar5;\n  uVar6 = param_3 << (uVar4 & 0xff);\n  uVar4 = param_3 >> (0x20 - uVar4 & 0xff) | param_4 << (uVar4 & 0xff);\n  uVar3 = uVar4 + -((int)uVar6 >> 0x1f);\n  if ((uVar7 | uVar6 << 1) == 0) {\n    uVar3 = uVar3 & ~(uVar6 >> 0x1f);\n  }\n  return CONCAT44((param_4 & 0x80000000) + (uint)CARRY4(uVar4,-((int)uVar6 >> 0x1f)),uVar3);\n}\n\n",
            "called": [
                "FUN_080006ac"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080004d0",
            "calling": [
                "MS5611_Update",
                "scalbn",
                "MadgwickQuaternionUpdate",
                "__ieee754_sqrt",
                "atan",
                "pow",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "FUNC_080004d0"
        },
        "FUN_0800729c": {
            "renaming": {
                "FUN_0800729c": "calculate_distance_0800729c",
                "__x": "x_coordinate",
                "__y": "y_coordinate",
                "in_d0": "distance"
            },
            "code": "double calculate_distance_0800729c(double x_coordinate, double y_coordinate)\n{\n  double distance;\n  //calculate distance between two points using x and y coordinates\n  distance = sqrt(pow(x_coordinate,2) + pow(y_coordinate,2));\n  return distance;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800729c",
            "calling": [
                "scalbn"
            ],
            "imported": false,
            "current_name": "calculate_distance_0800729c"
        },
        "FUN_080041ae": {
            "renaming": {
                "FUN_080041ae": "run_main_loop_080041ae",
                "startForkserver": "start_fork_server",
                "setup": "setup_system",
                "taskScheduler": "run_task_scheduler"
            },
            "code": "int run_main_loop_080041ae(void)\n{\n  start_fork_server(0);\n  setup_system();\n  do {\n    HAL_IncTick();\n    run_task_scheduler();\n  } while( true );\n}",
            "called": [
                "HAL_IncTick",
                "setup",
                "taskScheduler",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041ae",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "run_main_loop_080041ae"
        },
        "FUN_080053d4": {
            "renaming": {
                "FUN_080053d4": "FUNC_080053d4"
            },
            "code": "\nuint FUNC_080053d4(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_0800558e;\n          if (bVar1 != 0x58) goto LAB_08005404;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_08005610;\nLAB_0800551e:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_08005404;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_08005424;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_08005424:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_08005610;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08005552;\nLAB_08005600:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080054fa;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08005464:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800548a:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_08005498;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_08005498:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_08005610;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_080054b4;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800544a:\n            puVar6 = PTR_s_0123456789abcdef_0800560c;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800548a;\n          if (bVar1 == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08005464;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_0800557a;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_0800557a:\n    *puVar3 = uVar7;\n  }\nLAB_0800558e:\n  param_2[4] = 0;\nLAB_080054fa:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_0800550e:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_0800550e;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080053d4",
            "calling": [
                "_svfiprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_080053d4"
        },
        "FUN_080041c4": {
            "renaming": {
                "FUN_080041c4": "stop_all_motors_080041c4",
                "Motor1_SetPWM": "set_motor1_pwm",
                "Motor2_SetPWM": "set_motor2_pwm",
                "Motor3_SetPWM": "set_motor3_pwm",
                "Motor4_SetPWM": "set_motor4_pwm"
            },
            "code": "void stop_all_motors_080041c4(void)\n{\n  Motor1_SetPWM(0);\n  Motor2_SetPWM(0);\n  Motor3_SetPWM(0);\n  Motor4_SetPWM(0);\n  return;\n}",
            "called": [
                "Motor2_SetPWM",
                "Motor1_SetPWM",
                "Motor4_SetPWM",
                "Motor3_SetPWM"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041c4",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "stop_all_motors_080041c4"
        },
        "FUN_0800567c": {
            "renaming": {
                "FUN_0800567c": "allocate_memory_0800567c",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "prev_ptr",
                "extraout_r1": "curr_ptr",
                "ppiVar2": "prev_ptr",
                "ppiVar3": "next_ptr",
                "piVar4": "block_ptr",
                "ppiVar5": "prev_ptr",
                "ppiVar6": "next_ptr",
                "ppiVar7": "curr_ptr"
            },
            "code": "void allocate_memory_0800567c(int* error_code, int size, int arg3, int arg4) {\n  int **prev_ptr;\n  int **curr_ptr;\n  int **next_ptr;\n  int *block_ptr;\n  \n  if (size == 0) {\n    return;\n  }\n  curr_ptr = (int **)(size - 4);\n  if (*(int *)(size - 4) < 0) {\n    curr_ptr = (int **)((int)curr_ptr + *(int *)(size - 4));\n  }\n  __malloc_lock();\n  prev_ptr = (int **)PTR___malloc_free_list_08005710;\n  next_ptr = *(int ***)PTR___malloc_free_list_08005710;\n  if (next_ptr == (int **)0x0) {\n    curr_ptr[1] = (int *)0x0;\n    *(int ***)prev_ptr = curr_ptr;\n    curr_ptr = extraout_r1;\n    next_ptr = (int **)prev_ptr;\n  }\n  else if (curr_ptr < next_ptr) {\n    curr_ptr[1] = (int *)next_ptr;\n    *(int ***)prev_ptr = curr_ptr;\n  }\n  else {\n    do {\n      prev_ptr = next_ptr;\n      next_ptr = (int **)prev_ptr[1];\n      if (next_ptr == (int **)0x0) break;\n    } while (next_ptr <= curr_ptr);\n    block_ptr = (int *)*prev_ptr;\n    if ((int **)((int)prev_ptr + (int)block_ptr) == curr_ptr) {\n      block_ptr = (int **)((int)block_ptr + (int)*curr_ptr);\n      *prev_ptr = (int *)block_ptr;\n      if (next_ptr == (int **)((int)prev_ptr + (int)block_ptr)) {\n        block_ptr = *next_ptr;\n        next_ptr = (int **)next_ptr[1];\n        block_ptr = (int **)((int)block_ptr + (int)*curr_ptr);\n        *prev_ptr = (int *)block_ptr;\n        prev_ptr[1] = (int *)next_ptr;\n      }\n    }\n    else if (curr_ptr < (int **)((int)prev_ptr + (int)block_ptr)) {\n      *error_code = 0xc;\n    }\n    else {\n      block_ptr = (int **)((int)curr_ptr + (int)*curr_ptr);\n      if (next_ptr == block_ptr) {\n        block_ptr = *next_ptr;\n        next_ptr = (int **)next_ptr[1];\n        block_ptr = (int **)((int)block_ptr + (int)*curr_ptr);\n        *curr_ptr = (int *)block_ptr;\n      }\n      curr_ptr[1] = (int *)next_ptr;\n      prev_ptr[1] = (int *)curr_ptr;\n    }\n  }\n  __malloc_unlock(error_code, block_ptr, next_ptr, arg4);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800567c",
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_0800567c"
        },
        "FUN_0800458c": {
            "renaming": {
                "FUN_0800458c": "FUNC_0800458c"
            },
            "code": "\nvoid FUNC_0800458c(void)\n\n{\n  GPIO_TypeDef *GPIOx;\n  undefined4 uVar1;\n  undefined *huart;\n  HAL_StatusTypeDef HVar2;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  TIM_MasterConfigTypeDef sMasterConfig;\n  TIM_OC_InitTypeDef sConfigOC;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  undefined *puVar3;\n  \n  HAL_Init();\n  SystemClock_Config();\n  GPIOx = DAT_08004800;\n  iVar5 = DAT_080047fc;\n  *(uint *)(DAT_080047fc + 0x18) = *(uint *)(DAT_080047fc + 0x18) | 0x10;\n  uVar6 = 2;\n  *(uint *)(iVar5 + 0x18) = *(uint *)(iVar5 + 0x18) | 4;\n  uVar1 = DAT_08004804;\n  *(uint *)(iVar5 + 0x18) = *(uint *)(iVar5 + 0x18) | 8;\n  HAL_GPIO_WritePin(GPIOx,0xe000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin(DAT_08004808,0x20,GPIO_PIN_RESET);\n  GPIO_InitStruct.Pin = 0xe000;\n  GPIO_InitStruct.Mode = 1;\n  GPIO_InitStruct.Speed = 2;\n  HAL_GPIO_Init(DAT_08004800,&GPIO_InitStruct);\n  GPIO_InitStruct.Pin = 0x20;\n  GPIO_InitStruct.Mode = 1;\n  GPIO_InitStruct.Speed = 2;\n  HAL_GPIO_Init(DAT_08004808,&GPIO_InitStruct);\n  puVar3 = PTR_hi2c1_0800480c;\n  *(undefined4 *)PTR_hi2c1_0800480c = DAT_08004810;\n  *(undefined4 *)(puVar3 + 4) = uVar1;\n  *(undefined4 *)(puVar3 + 0x10) = 0x4000;\n  *(undefined4 *)(puVar3 + 8) = 0;\n  *(undefined4 *)(puVar3 + 0xc) = 0;\n  *(undefined4 *)(puVar3 + 0x14) = 0;\n  *(undefined4 *)(puVar3 + 0x18) = 0;\n  *(undefined4 *)(puVar3 + 0x1c) = 0;\n  *(undefined4 *)(puVar3 + 0x20) = 0;\n  HVar2 = HAL_I2C_Init((I2C_HandleTypeDef *)puVar3);\n  puVar3 = (undefined *)(uint)HVar2;\n  if (puVar3 == (undefined *)0x0) goto LAB_0800463a;\n  iVar5 = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  puVar3 = PTR_s____Src_peripherals_c_08004814;\n                                  _Error_Handler(PTR_s____Src_peripherals_c_08004814,iVar5);\nLAB_0800463a:\n                                  uVar1 = DAT_0800481c;\n                                  huart = PTR_huart1_08004818;\n                                  *(undefined **)(PTR_huart1_08004818 + 8) = puVar3;\n                                  *(undefined **)(huart + 0xc) = puVar3;\n                                  *(undefined **)(huart + 0x10) = puVar3;\n                                  *(undefined **)(huart + 0x18) = puVar3;\n                                  *(undefined **)(huart + 0x1c) = puVar3;\n                                  *(undefined4 *)huart = uVar1;\n                                  *(undefined4 *)(huart + 4) = 0x1c200;\n                                  *(undefined4 *)(huart + 0x14) = 0xc;\n                                  HVar2 = HAL_UART_Init((UART_HandleTypeDef *)huart);\n                                  uVar1 = DAT_08004824;\n                                  puVar3 = PTR_htim1_08004820;\n                                  if (HVar2 == HAL_OK) break;\n                                  iVar5 = 0x151;\n                                }\n                                *(undefined4 *)(PTR_htim1_08004820 + 8) = 0;\n                                *(undefined4 *)(puVar3 + 0x10) = 0;\n                                *(undefined4 *)(puVar3 + 0x14) = 0;\n                                *(undefined4 *)puVar3 = uVar1;\n                                *(uint *)(puVar3 + 4) = uVar6;\n                                *(undefined4 *)(puVar3 + 0xc) = 1000;\n                                HVar2 = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)puVar3);\n                                uVar4 = (uint)HVar2;\n                                if (uVar4 == 0) break;\n                                iVar5 = 0x88;\n                              }\n                              sMasterConfig.MasterOutputTrigger = uVar4;\n                              sMasterConfig.MasterSlaveMode = uVar4;\n                              HVar2 = HAL_TIMEx_MasterConfigSynchronization\n                                                ((TIM_HandleTypeDef *)puVar3,&sMasterConfig);\n                              uVar4 = (uint)HVar2;\n                              if (uVar4 == 0) break;\n                              iVar5 = 0x8f;\n                            }\n                            sConfigOC.OCMode = 0x60;\n                            sConfigOC.Pulse = uVar4;\n                            sConfigOC.OCPolarity = uVar4;\n                            sConfigOC.OCFastMode = uVar4;\n                            sConfigOC.OCIdleState = uVar4;\n                            sConfigOC.OCNIdleState = uVar4;\n                            HVar2 = HAL_TIM_PWM_ConfigChannel\n                                              ((TIM_HandleTypeDef *)puVar3,&sConfigOC,0xc);\n                            uVar4 = (uint)HVar2;\n                            if (uVar4 == 0) break;\n                            iVar5 = 0x9a;\n                          }\n                          GPIO_InitStruct.Pin = uVar4;\n                          GPIO_InitStruct.Mode = uVar4;\n                          GPIO_InitStruct.Pull = uVar4;\n                          GPIO_InitStruct.Speed = uVar4;\n                          HVar2 = HAL_TIMEx_ConfigBreakDeadTime\n                                            ((TIM_HandleTypeDef *)puVar3,\n                                             (TIM_BreakDeadTimeConfigTypeDef *)&GPIO_InitStruct);\n                          if (HVar2 == HAL_OK) break;\n                          iVar5 = 0xa6;\n                        }\n                        HAL_TIM_MspPostInit((TIM_HandleTypeDef *)puVar3);\n                        puVar3 = PTR_htim2_08004828;\n                        *(undefined4 *)PTR_htim2_08004828 = 0x40000000;\n                        *(uint *)(puVar3 + 4) = uVar6;\n                        *(undefined4 *)(puVar3 + 8) = 0;\n                        *(undefined4 *)(puVar3 + 0xc) = 1000;\n                        *(undefined4 *)(puVar3 + 0x10) = 0;\n                        HVar2 = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)puVar3);\n                        uVar4 = (uint)HVar2;\n                        if (uVar4 == 0) break;\n                        iVar5 = 0xc3;\n                      }\n                      sConfigOC.OCMode = uVar4;\n                      sConfigOC.Pulse = uVar4;\n                      HVar2 = HAL_TIMEx_MasterConfigSynchronization\n                                        ((TIM_HandleTypeDef *)puVar3,\n                                         (TIM_MasterConfigTypeDef *)&sConfigOC);\n                      uVar4 = (uint)HVar2;\n                      if (uVar4 == 0) break;\n                      iVar5 = 0xca;\n                    }\n                    GPIO_InitStruct.Pin = 0x60;\n                    GPIO_InitStruct.Mode = uVar4;\n                    GPIO_InitStruct.Pull = uVar4;\n                    HVar2 = HAL_TIM_PWM_ConfigChannel\n                                      ((TIM_HandleTypeDef *)puVar3,\n                                       (TIM_OC_InitTypeDef *)&GPIO_InitStruct,4);\n                    if (HVar2 == HAL_OK) break;\n                    iVar5 = 0xd3;\n                  }\n                  HAL_TIM_MspPostInit((TIM_HandleTypeDef *)puVar3);\n                  uVar1 = DAT_08004830;\n                  puVar3 = PTR_htim3_0800482c;\n                  *(undefined4 *)(PTR_htim3_0800482c + 0xc) = 1000;\n                  *(undefined4 *)puVar3 = uVar1;\n                  *(uint *)(puVar3 + 4) = uVar6;\n                  *(undefined4 *)(puVar3 + 8) = 0;\n                  *(undefined4 *)(puVar3 + 0x10) = 0;\n                  HVar2 = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)puVar3);\n                  if (HVar2 == HAL_OK) break;\n                  iVar5 = 0xf0;\n                }\n                sConfigOC.OCMode = 0;\n                sConfigOC.Pulse = 0;\n                HVar2 = HAL_TIMEx_MasterConfigSynchronization\n                                  ((TIM_HandleTypeDef *)PTR_htim3_0800482c,\n                                   (TIM_MasterConfigTypeDef *)&sConfigOC);\n                uVar4 = (uint)HVar2;\n                if (uVar4 == 0) break;\n                iVar5 = 0xf7;\n              }\n              GPIO_InitStruct.Pin = 0x60;\n              GPIO_InitStruct.Mode = uVar4;\n              GPIO_InitStruct.Pull = uVar4;\n              HVar2 = HAL_TIM_PWM_ConfigChannel\n                                ((TIM_HandleTypeDef *)PTR_htim3_0800482c,\n                                 (TIM_OC_InitTypeDef *)&GPIO_InitStruct,8);\n              if (HVar2 == HAL_OK) break;\n              iVar5 = 0x100;\n            }\n            HVar2 = HAL_TIM_PWM_ConfigChannel\n                              ((TIM_HandleTypeDef *)PTR_htim3_0800482c,\n                               (TIM_OC_InitTypeDef *)&GPIO_InitStruct,0xc);\n            uVar6 = (uint)HVar2;\n            if (uVar6 == 0) break;\n            iVar5 = 0x105;\n          }\n          HAL_TIM_MspPostInit((TIM_HandleTypeDef *)PTR_htim3_0800482c);\n          puVar3 = PTR_htim4_08004834;\n          *(undefined4 *)PTR_htim4_08004834 = DAT_08004838;\n          *(undefined4 *)(puVar3 + 4) = 2;\n          *(undefined4 *)(puVar3 + 8) = 0;\n          *(undefined4 *)(puVar3 + 0xc) = 1000;\n          *(undefined4 *)(puVar3 + 0x10) = 0;\n          HVar2 = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)puVar3);\n          uVar4 = (uint)HVar2;\n          if (uVar4 == 0) break;\n          iVar5 = 0x122;\n        }\n        sConfigOC.OCMode = uVar4;\n        sConfigOC.Pulse = uVar4;\n        HVar2 = HAL_TIMEx_MasterConfigSynchronization\n                          ((TIM_HandleTypeDef *)puVar3,(TIM_MasterConfigTypeDef *)&sConfigOC);\n        uVar4 = (uint)HVar2;\n        if (uVar4 == 0) break;\n        iVar5 = 0x129;\n      }\n      GPIO_InitStruct.Pin = 0x60;\n      GPIO_InitStruct.Mode = uVar4;\n      GPIO_InitStruct.Pull = uVar4;\n      HVar2 = HAL_TIM_PWM_ConfigChannel\n                        ((TIM_HandleTypeDef *)puVar3,(TIM_OC_InitTypeDef *)&GPIO_InitStruct,8);\n      if (HVar2 == HAL_OK) break;\n      iVar5 = 0x132;\n    }\n    HVar2 = HAL_TIM_PWM_ConfigChannel\n                      ((TIM_HandleTypeDef *)puVar3,(TIM_OC_InitTypeDef *)&GPIO_InitStruct,0xc);\n    if (HVar2 == HAL_OK) break;\n    iVar5 = 0x137;\n  }\n  HAL_TIM_MspPostInit((TIM_HandleTypeDef *)puVar3);\n  return;\n}\n\n",
            "called": [
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_I2C_Init",
                "_Error_Handler",
                "HAL_GPIO_Init",
                "HAL_Init",
                "HAL_TIM_MspPostInit",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_PWM_ConfigChannel",
                "SystemClock_Config",
                "HAL_UART_Init",
                "HAL_GPIO_WritePin"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800458c",
            "calling": [
                "Devices_Init"
            ],
            "imported": false,
            "current_name": "FUNC_0800458c"
        },
        "FUN_08000ffc": {
            "renaming": {
                "FUN_08000ffc": "compare_values_08000ffc",
                "param_1": "value1",
                "param_2": "value2"
            },
            "code": "void compare_values_08000ffc(int value1, int value2)\n{\n  __aeabi_cfcmpeq(value2, value1);\n  return;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ffc",
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "imported": false,
            "current_name": "compare_values_08000ffc"
        },
        "FUN_080016f4": {
            "renaming": {
                "FUN_080016f4": "i2c_communication_080016f4",
                "*hi2c": "*i2c_handle",
                "Timeout": "timeout_ms",
                "uVar1": "start_time_ms",
                "uVar2": "current_time_ms",
                "*pIVar3": "*i2c_instance",
                "SR1": "I2C_SR1_TXE",
                "ErrorCode": "I2C_ERROR_TIMEOUT",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef i2c_communication_080016f4(I2C_HandleTypeDef *i2c_handle, uint32_t timeout_ms)\n{\n  uint32_t start_time_ms;\n  uint32_t current_time_ms;\n  I2C_TypeDef *i2c_instance;\n  start_time_ms = HAL_GetTick();\n  while (true)\n  {\n    i2c_instance = i2c_handle->Instance;\n    if ((i2c_instance->SR1 & I2C_SR1_TXE) != 0)\n    {\n      return HAL_OK;\n    }\n    if ((int)(i2c_instance->SR1 << 0x1b) < 0)\n    {\n      break;\n    }\n    if ((timeout_ms != 0) && (current_time_ms = HAL_GetTick(), timeout_ms < current_time_ms - start_time_ms))\n    {\n      i2c_handle->ErrorCode |= I2C_ERROR_TIMEOUT;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2c_instance->SR1 &= ~I2C_SR1_AF;\n  i2c_handle->ErrorCode = 0;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080016f4",
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "imported": false,
            "current_name": "i2c_communication_080016f4"
        },
        "FUN_080025a4": {
            "renaming": {
                "FUN_080025a4": "configure_timer_080025a4",
                "htim": "timer_handle",
                "sMasterConfig": "master_config",
                "HVar2": "status",
                "pTVar3": "timer_instance",
                "uVar1": "master_slave_mode",
                "uVar4": "master_output_trigger"
            },
            "code": "HAL_StatusTypeDef configure_timer_080025a4(TIM_HandleTypeDef *timer_handle, TIM_MasterConfigTypeDef *master_config)\n{\n  uint32_t master_output_trigger;\n  uint32_t master_slave_mode;\n  HAL_StatusTypeDef status = HAL_BUSY;\n  if (timer_handle->Lock != HAL_LOCKED) {\n    timer_handle->State = HAL_TIM_STATE_BUSY;\n    TIM_TypeDef *timer_instance = timer_handle->Instance;\n    master_output_trigger = master_config->MasterOutputTrigger;\n    master_slave_mode = master_config->MasterSlaveMode;\n    timer_instance->CR2 &= ~TIM_CR2_MMS;\n    timer_instance->CR2 |= master_output_trigger;\n    timer_instance->SMCR &= ~TIM_SMCR_SMS;\n    timer_instance->SMCR |= master_slave_mode;\n    timer_handle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025a4",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_080025a4"
        },
        "FUN_08003034": {
            "renaming": {
                "FUN_08003034": "read_ms5611_sensor_data_08003034",
                "in_r3": "unused_parameter",
                "rxbuf": "rx_buffer",
                "_rxbuf": "unused_variable",
                "PTR_s____Src_MS5611_c_08003064": "ms5611_sensor_data_src",
                "CONCAT12": "concatenate_12_bits",
                "CONCAT11": "concatenate_11_bits"
            },
            "code": "uint32_t read_ms5611_sensor_data_08003034(void)\n{\n  uint8_t rx_buffer[3];\n  uint32_t sensor_data = 0;\n\n  I2C_ReadBytes(0xee, 0, rx_buffer, 3, PTR_s____Src_MS5611_c_08003064, 0x8c);\n  sensor_data |= rx_buffer[0] << 16;\n  sensor_data |= rx_buffer[1] << 8;\n  sensor_data |= rx_buffer[2];\n\n  return sensor_data;\n}",
            "called": [
                "I2C_ReadBytes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003034",
            "calling": [
                "MS5611_Update"
            ],
            "imported": false,
            "current_name": "read_ms5611_sensor_data_08003034"
        },
        "FUN_08004e7c": {
            "renaming": {
                "FUN_08004e7c": "configure_uart_gpio_08004e7c",
                "huart": "uart_handle",
                "tmpreg": "control_register",
                "GPIO_InitStruct": "gpio_init_structure",
                "huart->Instance": "uart_handle->Instance",
                "DAT_08004edc": "USART1",
                "DAT_08004ee0": "GPIOA",
                "0x7b7": "N/A"
            },
            "code": "void configure_uart_gpio_08004e7c(UART_HandleTypeDef *uart_handle){\n  uint32_t control_register;\n  GPIO_InitTypeDef gpio_init_structure;\n  if (uart_handle->Instance == DAT_08004edc) {\n    control_register = uart_handle->Instance->CR3;\n    control_register |= 0x4000;\n    uart_handle->Instance->CR3 = control_register;\n    gpio_init_structure.Pin = GPIO_PIN_9;\n    gpio_init_structure.Mode = GPIO_MODE_AF_PP;\n    gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(DAT_08004ee0, &gpio_init_structure);\n    gpio_init_structure.Pin = GPIO_PIN_10;\n    gpio_init_structure.Mode = GPIO_MODE_INPUT;\n    gpio_init_structure.Pull = GPIO_NOPULL;\n    HAL_GPIO_Init(DAT_08004ee0, &gpio_init_structure);\n    HAL_NVIC_SetPriority(DAT_08004edc_IRQn,0,0);\n    HAL_NVIC_EnableIRQ(DAT_08004edc_IRQn);\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_GPIO_Init",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e7c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_gpio_08004e7c"
        },
        "FUN_08001530": {
            "renaming": {
                "FUN_08001530": "i2c_data_transfer_08001530",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "tick_start",
                "uVar3": "current_tick",
                "pIVar4": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef i2c_data_transfer_08001530(I2C_HandleTypeDef *i2c_handle, uint16_t device_address, uint16_t memory_address, uint16_t memory_address_size, uint32_t timeout) {\n  HAL_StatusTypeDef status;\n  uint32_t tick_start = HAL_GetTick();\n  do {\n    if ((int)(i2c_handle->Instance->SR1 << 0x1f) < 0) {\n      i2c_handle->Instance->DR = device_address & 0xfe;\n      status = I2C_WaitOnMasterAddressFlagUntilTimeout(i2c_handle, DAT_080015e4, timeout);\n      if (status == HAL_OK) {\n        status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\n        if (status == HAL_OK) {\n          I2C_TypeDef *i2c_instance = i2c_handle->Instance;\n          if (memory_address_size == 1) {\n            i2c_instance->DR = (uint)(byte)memory_address;\n            return status;\n          }\n          i2c_instance->DR = (uint)(memory_address >> 8);\n          status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\n          if (status == HAL_OK) {\n            i2c_instance = i2c_handle->Instance;\n            i2c_instance->DR = (uint)(byte)memory_address;\n            return status;\n          }\n        }\n        if (i2c_handle->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      }\n      else if (i2c_handle->ErrorCode != 4) {\n        return HAL_TIMEOUT;\n      }\n      return HAL_ERROR;\n    }\n    if ((timeout != 0xffffffff) && (timeout != 0) && (timeout < HAL_GetTick() - tick_start)) {\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  } while (true);\n}",
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001530",
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "imported": false,
            "current_name": "i2c_data_transfer_08001530"
        },
        "FUN_0800411c": {
            "renaming": {
                "FUN_0800411c": "update_sensors_and_send_data_0800411c",
                "puVar1": "last_tick_ptr",
                "uVar2": "current_time",
                "PTR_last_tick1_08004188": "last_tick1",
                "AHRS_ComputeAngles": "compute_angles",
                "PTR_last_tick3_0800418c": "last_tick3",
                "PID_Update": "update_pid",
                "PTR_last_tick2_08004190": "last_tick2",
                "MSP_SendIdent": "send_ident",
                "MSP_SendStatus": "send_status",
                "MSP_SendMotor": "send_motor",
                "MSP_SendAttitude": "send_attitude",
                "MSP_SendAltitude": "send_altitude",
                "MSP_SendRawIMU": "send_raw_imu",
                "MSP_SendPID": "send_pid",
                "MS5611_Update": "update_ms5611"
            },
            "code": "void update_sensors_and_send_data_0800411c(void)\n{\n  uint32_t current_time = millis();\n  uint32_t *PTR_last_tick1_08004188 = PTR_PTR_last_tick1_08004188_08004188;\n  if (current_time - *(int *)PTR_last_tick1_08004188 > 1)\n  {\n    *PTR_last_tick1_08004188 = current_time;\n    AHRS_ComputeAngles();\n  }\n  uint32_t *PTR_last_tick3_0800418c = PTR_PTR_last_tick3_0800418c_0800418c;\n  if (current_time - *(int *)PTR_last_tick3_0800418c > 2)\n  {\n    *PTR_last_tick3_0800418c = current_time;\n    PID_Update();\n  }\n  uint32_t *PTR_last_tick2_08004190 = PTR_PTR_last_tick2_08004190_08004190;\n  if (current_time - *(int *)PTR_last_tick2_08004190 > 3)\n  {\n    *PTR_last_tick2_08004190 = current_time;\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}",
            "called": [
                "MS5611_Update",
                "MSP_SendPID",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendAltitude",
                "millis",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendRawIMU",
                "MSP_SendMotor",
                "MSP_SendIdent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800411c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "update_sensors_and_send_data_0800411c"
        },
        "FUN_080040b8": {
            "renaming": {
                "FUN_080040b8": "read_i2c_memory_080040b8",
                "device_add": "device_address",
                "register_add": "register_address",
                "bytes": "data",
                "size": "size",
                "file": "file",
                "line": "line",
                "HVar1": "status"
            },
            "code": "void read_i2c_memory_080040b8(uint16_t device_address, uint16_t register_address, uint8_t *data, uint16_t size, char *file, int line)\n{\n  HAL_StatusTypeDef status = HAL_I2C_Mem_Read((I2C_HandleTypeDef *)PTR_hi2c1_080040e4, device_address, register_address, 1, data, size, 200);\n  if (status != HAL_OK) {\n    _Error_Handler(file, line);\n    return;\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040b8",
            "calling": [
                "MS5611_ReadADC"
            ],
            "imported": false,
            "current_name": "read_i2c_memory_080040b8"
        },
        "FUN_08004490": {
            "renaming": {
                "FUN_08004490": "print_error_info_08004490",
                "file": "file_name",
                "line": "line_number",
                "GPIOx": "gpio",
                "data": "line_message",
                "data_00": "error_message"
            },
            "code": "void print_error_info_08004490(char* file_name, int line_number) {\n  GPIO_TypeDef *gpio;\n  char *error_message;\n  char *line_message;\n  gpio = DAT_08004508;\n  error_message = PTR_s_Error_with_08004510;\n  line_message = PTR_s__at_line__0800450c;\n  do {\n    HAL_GPIO_TogglePin(gpio, 0x4000);\n    HAL_GPIO_TogglePin(gpio, 0x8000);\n    HAL_GPIO_TogglePin(gpio, 0x2000);\n    serialPrint(error_message);\n    serialPrint(file_name);\n    serialPrint(line_message);\n    serialInt(line_number);\n    serialWrite('\n');\n    delay_ms(500);\n  } while (true);\n}",
            "called": [
                "serialInt",
                "HAL_GPIO_TogglePin",
                "delay_ms",
                "serialPrint",
                "HAL_GPIO_WritePin",
                "serialWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004490",
            "calling": [
                "I2C_WriteByte",
                "I2C_ReadByte",
                "Peripherals_Init",
                "I2C_ReadBytes",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "print_error_info_08004490"
        },
        "FUN_08000e54": {
            "renaming": {
                "FUN_08000e54": "FUNC_08000e54"
            },
            "code": "\nuint FUNC_08000e54(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  uVar2 = param_1 >> 0x17 & 0xff;\n  bVar7 = uVar2 == 0;\n  if (!bVar7) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    bVar7 = param_4 == 0;\n  }\n  if (!bVar7) {\n    bVar7 = uVar2 == 0xff;\n  }\n  if (!bVar7) {\n    bVar7 = param_4 == 0xff;\n  }\n  if (bVar7) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    uVar6 = param_1;\n    if (uVar2 == 0xff) {\n      if (((param_1 & 0x7fffff) != 0) || (uVar6 = param_2, param_4 == 0xff)) {\nLAB_08000e4a:\n        return uVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (param_4 == 0xff) {\n        uVar6 = param_2;\n        if ((param_2 & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (param_1 ^ param_2) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      bVar7 = (param_1 & 0x7fffffff) == 0;\n      if (!bVar7) {\n        bVar7 = (param_2 & 0x7fffffff) == 0;\n      }\n      if (!bVar7) {\n        bVar7 = uVar2 == 0;\n        uVar6 = param_1 & 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_1 = param_1 << 1;\n            bVar7 = (param_1 & 0x800000) == 0;\n          }\n          if (!bVar7) break;\n          uVar2 = uVar2 - 1;\n        }\n        param_1 = param_1 | uVar6;\n        bVar7 = param_4 == 0;\n        uVar6 = param_2 & 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_2 = param_2 << 1;\n            bVar7 = (param_2 & 0x800000) == 0;\n          }\n          if (!bVar7) break;\n          param_4 = param_4 - 1;\n        }\n        param_2 = param_2 | uVar6;\n        goto LAB_08000e6c;\n      }\n      if ((param_1 & 0x7fffffff) == 0) {\n        if ((param_2 & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    param_1 = param_1 ^ param_2;\n  }\n  else {\nLAB_08000e6c:\n    iVar3 = uVar2 - param_4;\n    if (param_2 << 9 == 0) {\n      param_1 = (param_1 ^ param_2) & 0x80000000 | param_1 & 0x7fffff;\n      bVar9 = SCARRY4(iVar3,0x7f);\n      iVar5 = iVar3 + 0x7f;\n      bVar7 = iVar5 < 0;\n      bVar8 = iVar5 == 0;\n      if (!bVar8 && bVar7 == bVar9) {\n        bVar9 = SBORROW4(0xff,iVar5);\n        bVar7 = 0xff - iVar5 < 0;\n        bVar8 = iVar5 == 0xff;\n      }\n      if (!bVar8 && bVar7 == bVar9) {\n        param_1 = param_1 | iVar5 * 0x800000;\n      }\n      if (!bVar8 && bVar7 == bVar9) {\n        return param_1;\n      }\n      param_1 = param_1 | 0x800000;\n      uVar2 = 0;\n      bVar8 = SBORROW4(iVar5,1);\n      uVar4 = iVar3 + 0x7e;\n      bVar7 = uVar4 == 0;\n      uVar6 = uVar4;\n    }\n    else {\n      uVar1 = (param_2 << 9) >> 4 | 0x10000000;\n      uVar2 = (param_1 << 9) >> 4 | 0x10000000;\n      param_1 = (param_1 ^ param_2) & 0x80000000;\n      bVar7 = uVar1 <= uVar2;\n      if (!bVar7) {\n        uVar2 = uVar2 << 1;\n      }\n      uVar4 = iVar3 + 0x7d + (uint)bVar7;\n      uVar6 = 0x800000;\n      do {\n        if (uVar1 <= uVar2) {\n          uVar2 = uVar2 - uVar1;\n          param_1 = param_1 | uVar6;\n        }\n        bVar7 = uVar1 >> 1 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 1);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 1;\n        }\n        bVar7 = uVar1 >> 2 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 2);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 2;\n        }\n        bVar7 = uVar1 >> 3 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 3);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 3;\n        }\n        uVar2 = uVar2 * 0x10;\n        bVar7 = uVar2 == 0;\n        if (!bVar7) {\n          uVar6 = uVar6 >> 4;\n          bVar7 = uVar6 == 0;\n        }\n      } while (!bVar7);\n      bVar8 = SBORROW4(uVar4,0xfd);\n      bVar7 = uVar4 == 0xfd;\n      uVar6 = uVar4 - 0xfd;\n      if (uVar4 < 0xfe) {\n        param_1 = param_1 + uVar4 * 0x800000 + (uint)(uVar1 <= uVar2);\n        if (uVar2 - uVar1 == 0) {\n          param_1 = param_1 & 0xfffffffe;\n        }\n        return param_1;\n      }\n    }\n    if (bVar7 || (int)uVar6 < 0 != bVar8) {\n      bVar7 = (int)(uVar4 + 0x19) < 0;\n      if (uVar4 == 0xffffffe7 || bVar7 != SCARRY4(uVar4,0x19)) {\n        param_1 = param_1 & 0x80000000;\n      }\n      if (uVar4 == 0xffffffe7 || bVar7 != SCARRY4(uVar4,0x19)) {\n        return param_1;\n      }\n      uVar6 = (param_1 << 1) >> (-uVar4 & 0xff);\n      uVar4 = param_1 << (uVar4 + 0x20 & 0xff);\n      uVar6 = ((uint)((param_1 & 0x80000000) != 0) << 0x1f | uVar6 >> 1) + (uint)((byte)uVar6 & 1);\n      if ((uVar2 | uVar4 << 1) == 0) {\n        uVar6 = uVar6 & ~(uVar4 >> 0x1f);\n      }\n      return uVar6;\n    }\n  }\n  return param_1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000e54",
            "calling": [
                "MS5611_Update",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "FUNC_08000e54"
        },
        "FUN_080015e8": {
            "renaming": {
                "FUN_080015e8": "i2c_read_080015e8",
                "*hi2c": "*handle",
                "DevAddress": "dev_address",
                "MemAddress": "mem_address",
                "MemAddSize": "mem_address_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "pIVar4": "instance"
            },
            "code": "HAL_StatusTypeDef i2c_read_080015e8(I2C_HandleTypeDef *handle, uint16_t dev_address, uint16_t mem_address, uint16_t mem_address_size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  I2C_TypeDef *instance;\n  instance = handle->Instance;\n  instance->CR1 |= I2C_CR1_ACK;\n  instance->CR1 |= I2C_CR1_START;\n  start_time = HAL_GetTick();\n  while ((handle->Instance->SR1 & I2C_SR1_ADDR) == 0) {\n    if (timeout != HAL_MAX_DELAY && HAL_GetTick() - start_time >= timeout) {\n      return HAL_TIMEOUT;\n    }\n  }\n  instance->SR1;\n  instance->SR2;\n  instance->DR = (uint8_t)(dev_address << 1);\n  start_time = HAL_GetTick();\n  while ((handle->Instance->SR1 & I2C_SR1_TXE) == 0) {\n    if (timeout != HAL_MAX_DELAY && HAL_GetTick() - start_time >= timeout) {\n      return HAL_TIMEOUT;\n    }\n  }\n  if (mem_address_size == 2) {\n    instance->DR = (uint8_t)(mem_address >> 8);\n    start_time = HAL_GetTick();\n    while ((handle->Instance->SR1 & I2C_SR1_TXE) == 0) {\n      if (timeout != HAL_MAX_DELAY && HAL_GetTick() - start_time >= timeout) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  instance->DR = (uint8_t)(mem_address & 0xFF);\n  start_time = HAL_GetTick();\n  while ((handle->Instance->SR1 & I2C_SR1_TXE) == 0) {\n    if (timeout != HAL_MAX_DELAY && HAL_GetTick() - start_time >= timeout) {\n      return HAL_TIMEOUT;\n    }\n  }\n  instance->CR1 |= I2C_CR1_START;\n  start_time = HAL_GetTick();\n  while ((handle->Instance->SR1 & I2C_SR1_ADDR) == 0) {\n    if (timeout != HAL_MAX_DELAY && HAL_GetTick() - start_time >= timeout) {\n      return HAL_TIMEOUT;\n    }\n  }\n  instance->SR1;\n  instance->SR2;\n  instance->DR = (uint8_t)((dev_address << 1) | 0x01);\n  start_time = HAL_GetTick();\n  while ((handle->Instance->SR1 & I2C_SR1_RXNE) == 0) {\n    if (timeout != HAL_MAX_DELAY && HAL_GetTick() - start_time >= timeout) {\n      return HAL_TIMEOUT;\n    }\n  }\n  status = instance->DR;\n  instance->CR1 |= I2C_CR1_STOP;\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015e8",
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "imported": false,
            "current_name": "i2c_read_080015e8"
        }
    },
    "used_tokens": 170357,
    "layers": [
        [
            "FUN_08003320",
            "FUN_08004410",
            "FUN_08003ef2",
            "FUN_08001264",
            "FUN_080058fc",
            "FUN_080070b0",
            "FUN_08001028",
            "FUN_080006ac",
            "FUN_0800125a",
            "FUN_08001828",
            "FUN_0800290c",
            "FUN_080028a6",
            "FUN_08004300",
            "FUN_08005630",
            "FUN_08000980",
            "FUN_08002368",
            "FUN_08002008",
            "FUN_080008fc",
            "FUN_0800114c",
            "FUN_08002250",
            "FUN_080011fc",
            "FUN_08003f7c",
            "FUN_08005646",
            "FUN_08000990",
            "FUN_08004ee6",
            "FUN_08004434",
            "FUN_08004ee8",
            "FUN_08004ffc",
            "FUN_0800103c",
            "FUN_0800115c",
            "FUN_08004f60",
            "FUN_08002d88",
            "FUN_08002b48",
            "FUN_08004f68",
            "FUN_08001170",
            "FUN_08002bf0",
            "FUN_08002ad0",
            "FUN_08001050",
            "FUN_08004ef4",
            "FUN_080043bc",
            "FUN_08004f5c",
            "FUN_08000404",
            "FUN_08004eec",
            "FUN_08004eea",
            "FUN_08006070",
            "FUN_08004cac",
            "FUN_08004c18",
            "FUN_08004c8c",
            "FUN_08001460",
            "FUN_08003fd0",
            "FUN_08000134",
            "FUN_08003eb0",
            "FUN_08002ee8",
            "FUN_08001104",
            "FUN_08004978",
            "FUN_08000c60",
            "FUN_08004f04",
            "FUN_080072b8",
            "FUN_0800581c",
            "FUN_08003eac",
            "FUN_080072ac",
            "FUN_08002cb0",
            "FUN_08002324",
            "FUN_08002564",
            "FUN_08004fb0",
            "FUN_08003ec8",
            "FUN_08003fe8",
            "FUN_08005714",
            "FUN_08004fb4",
            "FUN_080009dc",
            "FUN_08000c70",
            "FUN_080023d0",
            "FUN_08000a30",
            "FUN_08003fdc",
            "FUN_080009f0",
            "FUN_08004f10",
            "FUN_08005044",
            "FUN_08004194",
            "FUN_08001240",
            "FUN_08005840",
            "FUN_08000150",
            "FUN_08003f3c",
            "FUN_08002214",
            "FUN_08003ff4",
            "FUN_08001004",
            "FUN_08004514",
            "FUN_080057d0",
            "FUN_080072d4",
            "FUN_08002220",
            "FUN_08003314",
            "FUN_08001014",
            "FUN_080071c0",
            "FUN_08005614",
            "FUN_080070a4",
            "FUN_0800407c",
            "FUN_080022d0",
            "FUN_080010c4",
            "FUN_0800245c",
            "FUN_080008f4",
            "FUN_08004e14",
            "FUN_08002ea0",
            "FUN_08001424",
            "FUN_08004c64",
            "FUN_080041e4",
            "FUN_080003e4",
            "FUN_08007092",
            "FUN_08002f28",
            "FUN_08004384",
            "FUN_080009a0",
            "FUN_08003298",
            "FUN_08004028",
            "FUN_0800708c",
            "FUN_08002520",
            "FUN_08000464",
            "FUN_08002404",
            "FUN_08001436",
            "FUN_08004a30",
            "FUN_08004c70",
            "FUN_08000904",
            "FUN_0800299a",
            "FUN_080052e4",
            "FUN_08000f94",
            "FUN_080014e2",
            "FUN_0800142e",
            "FUN_08004d8c",
            "FUN_080009b4",
            "FUN_08003068",
            "FUN_08000f8c",
            "FUN_08000474",
            "FUN_08000110",
            "FUN_0800709e",
            "FUN_08002ec0",
            "FUN_08006c0c",
            "FUN_0800426c",
            "FUN_08002538",
            "FUN_080040e8",
            "FUN_08000c44",
            "FUN_08000a04",
            "FUN_080025e8",
            "FUN_080009c8",
            "FUN_08000f9c",
            "FUN_08002ed4",
            "FUN_08000c3c",
            "FUN_08001214",
            "FUN_08003fc4",
            "FUN_0800209c",
            "FUN_08003f0e",
            "FUN_0800403c",
            "FUN_0800277c",
            "FUN_0800483c",
            "FUN_08001064",
            "FUN_08000892",
            "FUN_08004458",
            "FUN_08004d48",
            "FUN_08002280",
            "FUN_08001194",
            "FUN_08004348",
            "FUN_08001078",
            "FUN_08001754",
            "FUN_08002724",
            "FUN_080043f0",
            "FUN_08000428",
            "FUN_08004ccc",
            "FUN_08004c30",
            "FUN_0800729c",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_0800567c",
            "FUN_08000ffc",
            "FUN_080016f4",
            "FUN_080025a4",
            "FUN_08003034",
            "FUN_08004e7c",
            "FUN_08001530",
            "FUN_0800411c",
            "FUN_080040b8",
            "FUN_08004490",
            "FUN_080015e8"
        ],
        [
            "FUN_08001128",
            "FUN_08004a84",
            "FUN_08005854",
            "FUN_08005bc8"
        ]
    ],
    "locked_functions": []
}