{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeCompletedFlag_08000110(undefined4 input)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "input",
                "completed_8672": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_parameters_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenateParameters_08000134(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  return CONCAT44(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_parameters_08000134",
                "param_1": "firstParameter",
                "param_2": "secondParameter"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "calculate_string_length_08000150",
            "code": "\nsize_t calculateStringLength_08000150(char *inputString)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = inputString;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)inputString));\n}\n\n",
            "renaming": {
                "FUN_08000150": "calculate_string_length_08000150",
                "__s": "inputString",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "serialPrint"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000160": {
            "entrypoint": "0x08000160",
            "current_name": "add_offset_08000160",
            "code": "\nvoid addOffset_08000160(void result,uint input)\n\n{\n  addDouble(result,input ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000160": "add_offset_08000160",
                "param_1": "result",
                "param_2": "input",
                "undefined4": "void",
                "__aeabi_dadd": "addDouble"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000168": {
            "entrypoint": "0x08000168",
            "current_name": "calculate_unsigned_division_08000168",
            "code": "\nulonglong calculateUnsignedDivision_08000168(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  int shift1;\n  byte carry1;\n  uint product1;\n  uint shiftResult1;\n  uint product2;\n  uint temp1;\n  uint temp2;\n  int shift2;\n  uint divisorShifted;\n  uint quotientAdd;\n  uint remainderDiff;\n  uint maskedResult;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  temp1 = remainder ^ 0x80000000;\n  divisorShifted = divisor << 1;\n  remainder = remainder << 1;\n  isNegative = ((divisor ^ temp1) & 0x7fffffff) == 0;\n  isZero = isNegative && dividend == quotient;\n  if (!isNegative || dividend != quotient) {\n    isZero = (divisorShifted | dividend) == 0;\n  }\n  if (!isZero) {\n    isZero = (remainder | quotient) == 0;\n  }\n  shift2 = (int)divisorShifted >> 0x15;\n  if (!isZero) {\n    isZero = shift2 == -1;\n  }\n  shift1 = (int)remainder >> 0x15;\n  if (!isZero) {\n    isZero = shift1 == -1;\n  }\n  if (isZero) {\n    if (shift2 == -1 || shift1 == -1) {\n      divisorShifted = temp1;\n      remainderDiff = quotient;\n      if (shift2 == -1) {\n        divisorShifted = divisor;\n        remainderDiff = dividend;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        quotient = remainderDiff;\n        temp1 = divisorShifted;\n      }\n      isZero = (remainderDiff | divisorShifted << 0xc) == 0;\n      if (isZero) {\n        isZero = (quotient | temp1 << 0xc) == 0;\n      }\n      if (isZero) {\n        isZero = divisorShifted == temp1;\n      }\n      if (!isZero) {\n        divisorShifted = divisorShifted | 0x80000;\n      }\n      return CONCAT44(divisorShifted,remainderDiff);\n    }\n    if (((divisor ^ temp1) & 0x7fffffff) != 0 || dividend != quotient) {\n      if ((divisorShifted | dividend) == 0) {\n        dividend = quotient;\n        divisor = temp1;\n      }\n      return CONCAT44(divisor,dividend);\n    }\n    if (divisor != temp1) {\n      return 0;\n    }\n    if (divisorShifted >> 0x15 == 0) {\n      isZero = (dividend & 0x80000000) != 0;\n      temp1 = divisor * 2 + (uint)isZero;\n      if (CARRY4(divisor,divisor) || CARRY4(divisor * 2,(uint)isZero)) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return CONCAT44(temp1,dividend << 1);\n    }\n    if (divisorShifted < 0xffc00000) {\n      return CONCAT44(divisor + 0x100000,dividend);\n    }\n    divisor = divisor & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(divisor | 0x7ff00000) << 0x20;\n  }\n  divisorShifted = divisorShifted >> 0x15;\n  remainder = remainder >> 0x15;\n  remainderDiff = remainder - divisorShifted;\n  isZero = remainderDiff != 0;\n  if (remainder < divisorShifted) {\n    remainderDiff = -remainderDiff;\n  }\n  quotientAdd = dividend;\n  temp2 = divisor;\n  if (isZero && divisorShifted <= remainder) {\n    divisorShifted = divisorShifted + remainderDiff;\n    quotientAdd = quotient;\n    temp2 = temp1;\n    quotient = dividend;\n    temp1 = divisor;\n  }\n  if (0x36 < remainderDiff) {\n    return CONCAT44(temp2,quotientAdd);\n  }\n  shiftResult1 = temp2 & 0xfffff | 0x100000;\n  if ((temp2 & 0x80000000) != 0) {\n    isZero = quotientAdd != 0;\n    quotientAdd = -quotientAdd;\n    shiftResult1 = -shiftResult1 - (uint)isZero;\n  }\n  temp2 = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    isZero = quotient != 0;\n    quotient = -quotient;\n    temp2 = -temp2 - (uint)isZero;\n  }\n  if (divisorShifted == remainderDiff) {\n    temp2 = temp2 ^ 0x100000;\n    if (divisorShifted == 0) {\n      shiftResult1 = shiftResult1 ^ 0x100000;\n      divisorShifted = 1;\n    }\n    else {\n      remainderDiff = remainderDiff - 1;\n    }\n  }\n  temp1 = -remainderDiff + 0x20;\n  if ((int)remainderDiff < 0x21) {\n    maskedResult = quotient << (temp1 & 0xff);\n    quotient = quotient >> (remainderDiff & 0xff);\n    product1 = quotientAdd + quotient;\n    product2 = temp2 << (temp1 & 0xff);\n    temp1 = product1 + product2;\n    shiftResult1 = shiftResult1 + CARRY4(quotientAdd,quotient) + ((int)temp2 >> (remainderDiff & 0xff)) +\n            (uint)CARRY4(product1,product2);\n  }\n  else {\n    maskedResult = temp2 << (-remainderDiff + 0x40 & 0xff);\n    if (quotient != 0) {\n      maskedResult = maskedResult | 2;\n    }\n    temp2 = (int)temp2 >> (remainderDiff - 0x20 & 0xff);\n    temp1 = quotientAdd + temp2;\n    shiftResult1 = shiftResult1 + ((int)temp2 >> 0x1f) + (uint)CARRY4(quotientAdd,temp2);\n  }\n  divisor = shiftResult1 & 0x80000000;\n  remainderDiff = shiftResult1;\n  if ((int)shiftResult1 < 0) {\n    isZero = maskedResult == 0;\n    maskedResult = -maskedResult;\n    remainderDiff = -temp1;\n    temp1 = -(uint)!isZero - temp1;\n    remainderDiff = -(uint)(isZero <= remainderDiff) - shiftResult1;\n  }\n  if (0xfffff < remainderDiff) {\n    quotientAdd = divisorShifted - 1;\n    if (0x1fffff < remainderDiff) {\n      quotientAdd = remainderDiff & 1;\n      remainderDiff = remainderDiff >> 1;\n      carry1 = (byte)temp1;\n      temp1 = (uint)(quotientAdd != 0) << 0x1f | temp1 >> 1;\n      maskedResult = (uint)(carry1 & 1) << 0x1f | maskedResult >> 1;\n      quotientAdd = divisorShifted;\n      if (0xffbfffff < divisorShifted * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    isZero = 0x7fffffff < maskedResult;\n    if (maskedResult == 0x80000000) {\n      isZero = (temp1 & 1) != 0;\n    }\n    return CONCAT44(remainderDiff + quotientAdd * 0x100000 + (uint)CARRY4(temp1,(uint)isZero) | divisor,\n                    temp1 + isZero);\n  }\n  isNegative = (maskedResult & 0x80000000) != 0;\n  maskedResult = maskedResult << 1;\n  quotientAdd = temp1 * 2;\n  isZero = CARRY4(temp1,temp1);\n  temp1 = temp1 * 2 + (uint)isNegative;\n  remainderDiff = remainderDiff * 2 + (uint)(isZero || CARRY4(quotientAdd,(uint)isNegative));\n  quotientAdd = divisorShifted - 2;\n  if ((remainderDiff & 0x100000) != 0) goto LAB_08000278;\n  temp2 = temp1;\n  divisorShifted = remainderDiff;\n  if (remainderDiff == 0) {\n    temp2 = 0;\n    divisorShifted = temp1;\n  }\n  shift2 = LZCOUNT(divisorShifted);\n  if (remainderDiff == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  remainderDiff = shift2 - 0xb;\n  isCarry = SBORROW4(remainderDiff,0x20);\n  temp1 = shift2 - 0x2b;\n  isZero = (int)temp1 < 0;\n  isNegative = temp1 == 0;\n  if ((int)remainderDiff < 0x20) {\n    isCarry = SCARRY4(temp1,0xc);\n    shift2 = shift2 + -0x1f;\n    isZero = shift2 < 0;\n    isNegative = shift2 == 0;\n    temp1 = remainderDiff;\n    if (!isNegative && isZero == isCarry) {\n      temp2 = divisorShifted << (remainderDiff & 0xff);\n      divisorShifted = divisorShifted >> (0xcU - shift2 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isNegative || isZero != isCarry) {\n    maskedResult = 0x20 - temp1;\n  }\n  divisorShifted = divisorShifted << (temp1 & 0xff);\n  if (isNegative || isZero != isCarry) {\n    divisorShifted = divisorShifted | temp2 >> (maskedResult & 0xff);\n  }\n  if (isNegative || isZero != isCarry) {\n    temp2 = temp2 << (temp1 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)remainderDiff <= (int)quotientAdd) {\n    return CONCAT44(divisorShifted + (quotientAdd - remainderDiff) * 0x100000 | divisor,temp2);\n  }\n  temp1 = ~(quotientAdd - remainderDiff);\n  if ((int)temp1 < 0x1f) {\n    shift2 = temp1 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(temp1 - 0x1f,0xc)) {\n      return CONCAT44(shiftResult1,temp2 >> (0x20 - (0xcU - shift2) & 0xff) | divisorShifted << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp1 = temp1 + 1;\n    return CONCAT44(divisor | divisorShifted >> (temp1 & 0xff),\n                    temp2 >> (temp1 & 0xff) | divisorShifted << (0x20 - temp1 & 0xff));\n  }\n  return CONCAT44(shiftResult1,divisorShifted >> (temp1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000168": "calculate_unsigned_division_08000168",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "iVar1": "shift1",
                "bVar2": "carry1",
                "uVar3": "product1",
                "uVar4": "shiftResult1",
                "uVar5": "product2",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "iVar8": "shift2",
                "uVar9": "divisorShifted",
                "uVar10": "quotientAdd",
                "uVar11": "remainderDiff",
                "uVar12": "maskedResult",
                "bVar13": "isNegative",
                "bVar14": "isZero",
                "bVar15": "isCarry"
            },
            "calling": [
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800016c": {
            "entrypoint": "0x0800016c",
            "current_name": "calculate_sum_0800016c",
            "code": "\nulonglong calculate_sum_0800016c(uint num1,uint num2,uint num3,uint num4)\n\n{\n  int shiftedNum2;\n  byte carryVal;\n  uint shiftedNum2;\n  uint shiftedNum4;\n  uint tempSum1;\n  int shiftedNum4;\n  uint shiftedNum2;\n  uint shiftedNum4;\n  uint shiftedNum2;\n  uint shiftedNum4;\n  uint carryVal;\n  uint result;\n  bool isSameSign;\n  bool isZero;\n  bool isNegative;\n  \n  shiftedNum2 = num2 << 1;\n  shiftedNum2 = num4 << 1;\n  isSameSign = ((num2 ^ num4) & 0x7fffffff) == 0;\n  isZero = isSameSign && num1 == num3;\n  if (!isSameSign || num1 != num3) {\n    isZero = (shiftedNum2 | num1) == 0;\n  }\n  if (!isZero) {\n    isZero = (shiftedNum2 | num3) == 0;\n  }\n  shiftedNum4 = (int)shiftedNum2 >> 0x15;\n  if (!isZero) {\n    isZero = shiftedNum4 == -1;\n  }\n  shiftedNum2 = (int)shiftedNum2 >> 0x15;\n  if (!isZero) {\n    isZero = shiftedNum2 == -1;\n  }\n  if (isZero) {\n    if (shiftedNum4 == -1 || shiftedNum2 == -1) {\n      shiftedNum2 = num4;\n      shiftedNum2 = num3;\n      if (shiftedNum4 == -1) {\n        shiftedNum2 = num2;\n        shiftedNum2 = num1;\n      }\n      if (shiftedNum4 != -1 || shiftedNum2 != -1) {\n        num3 = shiftedNum2;\n        num4 = shiftedNum2;\n      }\n      isZero = (shiftedNum2 | shiftedNum2 << 0xc) == 0;\n      if (isZero) {\n        isZero = (num3 | num4 << 0xc) == 0;\n      }\n      if (isZero) {\n        isZero = shiftedNum2 == num4;\n      }\n      if (!isZero) {\n        shiftedNum2 = shiftedNum2 | 0x80000;\n      }\n      return CONCAT44(shiftedNum2,shiftedNum2);\n    }\n    if (((num2 ^ num4) & 0x7fffffff) != 0 || num1 != num3) {\n      if ((shiftedNum2 | num1) == 0) {\n        num1 = num3;\n        num2 = num4;\n      }\n      return CONCAT44(num2,num1);\n    }\n    if (num2 != num4) {\n      return 0;\n    }\n    if (shiftedNum2 >> 0x15 == 0) {\n      isZero = (num1 & 0x80000000) != 0;\n      shiftedNum2 = num2 * 2 + (uint)isZero;\n      if (CARRY4(num2,num2) || CARRY4(num2 * 2,(uint)isZero)) {\n        shiftedNum2 = shiftedNum2 | 0x80000000;\n      }\n      return CONCAT44(shiftedNum2,num1 << 1);\n    }\n    if (shiftedNum2 < 0xffc00000) {\n      return CONCAT44(num2 + 0x100000,num1);\n    }\n    num2 = num2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(num2 | 0x7ff00000) << 0x20;\n  }\n  shiftedNum2 = shiftedNum2 >> 0x15;\n  shiftedNum2 = shiftedNum2 >> 0x15;\n  shiftedNum4 = shiftedNum2 - shiftedNum2;\n  isZero = shiftedNum4 != 0;\n  if (shiftedNum2 < shiftedNum2) {\n    shiftedNum4 = -shiftedNum4;\n  }\n  shiftedNum4 = num1;\n  tempSum1 = num2;\n  if (isZero && shiftedNum2 <= shiftedNum2) {\n    shiftedNum2 = shiftedNum2 + shiftedNum4;\n    shiftedNum4 = num3;\n    tempSum1 = num4;\n    num3 = num1;\n    num4 = num2;\n  }\n  if (0x36 < shiftedNum4) {\n    return CONCAT44(tempSum1,shiftedNum4);\n  }\n  shiftedNum2 = tempSum1 & 0xfffff | 0x100000;\n  if ((tempSum1 & 0x80000000) != 0) {\n    isZero = shiftedNum4 != 0;\n    shiftedNum4 = -shiftedNum4;\n    shiftedNum2 = -shiftedNum2 - (uint)isZero;\n  }\n  tempSum1 = num4 & 0xfffff | 0x100000;\n  if ((num4 & 0x80000000) != 0) {\n    isZero = num3 != 0;\n    num3 = -num3;\n    tempSum1 = -tempSum1 - (uint)isZero;\n  }\n  if (shiftedNum2 == shiftedNum4) {\n    tempSum1 = tempSum1 ^ 0x100000;\n    if (shiftedNum2 == 0) {\n      shiftedNum2 = shiftedNum2 ^ 0x100000;\n      shiftedNum2 = 1;\n    }\n    else {\n      shiftedNum4 = shiftedNum4 - 1;\n    }\n  }\n  result = -shiftedNum4 + 0x20;\n  if ((int)shiftedNum4 < 0x21) {\n    carryVal = num3 << (result & 0xff);\n    num3 = num3 >> (shiftedNum4 & 0xff);\n    shiftedNum2 = shiftedNum4 + num3;\n    shiftedNum4 = tempSum1 << (result & 0xff);\n    result = shiftedNum2 + shiftedNum4;\n    shiftedNum2 = shiftedNum2 + CARRY4(shiftedNum4,num3) + ((int)tempSum1 >> (shiftedNum4 & 0xff)) +\n            (uint)CARRY4(shiftedNum2,shiftedNum4);\n  }\n  else {\n    carryVal = tempSum1 << (-shiftedNum4 + 0x40 & 0xff);\n    if (num3 != 0) {\n      carryVal = carryVal | 2;\n    }\n    tempSum1 = (int)tempSum1 >> (shiftedNum4 - 0x20 & 0xff);\n    result = shiftedNum4 + tempSum1;\n    shiftedNum2 = shiftedNum2 + ((int)tempSum1 >> 0x1f) + (uint)CARRY4(shiftedNum4,tempSum1);\n  }\n  num2 = shiftedNum2 & 0x80000000;\n  shiftedNum4 = shiftedNum2;\n  if ((int)shiftedNum2 < 0) {\n    isZero = carryVal == 0;\n    carryVal = -carryVal;\n    shiftedNum4 = -result;\n    result = -(uint)!isZero - result;\n    shiftedNum4 = -(uint)(isZero <= shiftedNum4) - shiftedNum2;\n  }\n  if (0xfffff < shiftedNum4) {\n    shiftedNum4 = shiftedNum2 - 1;\n    if (0x1fffff < shiftedNum4) {\n      shiftedNum2 = shiftedNum4 & 1;\n      shiftedNum4 = shiftedNum4 >> 1;\n      carryVal = (byte)result;\n      result = (uint)(shiftedNum2 != 0) << 0x1f | result >> 1;\n      carryVal = (uint)(carryVal & 1) << 0x1f | carryVal >> 1;\n      shiftedNum4 = shiftedNum2;\n      if (0xffbfffff < shiftedNum2 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    isZero = 0x7fffffff < carryVal;\n    if (carryVal == 0x80000000) {\n      isZero = (result & 1) != 0;\n    }\n    return CONCAT44(shiftedNum4 + shiftedNum4 * 0x100000 + (uint)CARRY4(result,(uint)isZero) | num2,\n                    result + isZero);\n  }\n  isSameSign = (carryVal & 0x80000000) != 0;\n  carryVal = carryVal << 1;\n  shiftedNum4 = result * 2;\n  isZero = CARRY4(result,result);\n  result = result * 2 + (uint)isSameSign;\n  shiftedNum4 = shiftedNum4 * 2 + (uint)(isZero || CARRY4(shiftedNum4,(uint)isSameSign));\n  shiftedNum4 = shiftedNum2 - 2;\n  if ((shiftedNum4 & 0x100000) != 0) goto LAB_08000278;\n  tempSum1 = result;\n  shiftedNum2 = shiftedNum4;\n  if (shiftedNum4 == 0) {\n    tempSum1 = 0;\n    shiftedNum2 = result;\n  }\n  shiftedNum4 = LZCOUNT(shiftedNum2);\n  if (shiftedNum4 == 0) {\n    shiftedNum4 = shiftedNum4 + 0x20;\n  }\n  result = shiftedNum4 - 0xb;\n  isNegative = SBORROW4(result,0x20);\n  shiftedNum4 = shiftedNum4 - 0x2b;\n  isZero = (int)shiftedNum4 < 0;\n  isSameSign = shiftedNum4 == 0;\n  if ((int)result < 0x20) {\n    isNegative = SCARRY4(shiftedNum4,0xc);\n    shiftedNum4 = shiftedNum4 + -0x1f;\n    isZero = shiftedNum4 < 0;\n    isSameSign = shiftedNum4 == 0;\n    shiftedNum4 = result;\n    if (!isSameSign && isZero == isNegative) {\n      tempSum1 = shiftedNum2 << (result & 0xff);\n      shiftedNum2 = shiftedNum2 >> (0xcU - shiftedNum4 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isSameSign || isZero != isNegative) {\n    carryVal = 0x20 - shiftedNum4;\n  }\n  shiftedNum2 = shiftedNum2 << (shiftedNum4 & 0xff);\n  if (isSameSign || isZero != isNegative) {\n    shiftedNum2 = shiftedNum2 | tempSum1 >> (carryVal & 0xff);\n  }\n  if (isSameSign || isZero != isNegative) {\n    tempSum1 = tempSum1 << (shiftedNum4 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)result <= (int)shiftedNum4) {\n    return CONCAT44(shiftedNum2 + (shiftedNum4 - result) * 0x100000 | num2,tempSum1);\n  }\n  shiftedNum4 = ~(shiftedNum4 - result);\n  if ((int)shiftedNum4 < 0x1f) {\n    shiftedNum4 = shiftedNum4 - 0x13;\n    if (shiftedNum4 != 0 && shiftedNum4 < 0 == SCARRY4(shiftedNum4 - 0x1f,0xc)) {\n      return CONCAT44(shiftedNum2,tempSum1 >> (0x20 - (0xcU - shiftedNum4) & 0xff) | shiftedNum2 << (0xcU - shiftedNum4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftedNum4 = shiftedNum4 + 1;\n    return CONCAT44(num2 | shiftedNum2 >> (shiftedNum4 & 0xff),\n                    tempSum1 >> (shiftedNum4 & 0xff) | shiftedNum2 << (0x20 - shiftedNum4 & 0xff));\n  }\n  return CONCAT44(shiftedNum2,shiftedNum2 >> (shiftedNum4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800016c": "calculate_sum_0800016c",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "iVar1": "shiftedNum2",
                "bVar2": "carryVal",
                "uVar3": "shiftedNum2",
                "uVar4": "shiftedNum4",
                "uVar5": "tempSum1",
                "iVar6": "shiftedNum4",
                "uVar7": "shiftedNum2",
                "uVar8": "shiftedNum4",
                "uVar9": "shiftedNum2",
                "uVar10": "shiftedNum4",
                "uVar11": "carryVal",
                "uVar12": "result",
                "bVar13": "isSameSign",
                "bVar14": "isZero",
                "bVar15": "isNegative"
            },
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "__aeabi_drsub",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003e4": {
            "entrypoint": "0x080003e4",
            "current_name": "reverse_and_shift_080003e4",
            "code": "\nulonglong reverseAndShift_080003e4(uint input)\n\n{\n  uint shiftedResult;\n  uint shiftAmount;\n  int bitCount;\n  uint totalShift;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isBorrow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  shiftedResult = 0;\n  bitCount = LZCOUNT(input);\n  totalShift = bitCount + 0x15;\n  isBorrow = SBORROW4(totalShift,0x20);\n  shiftAmount = bitCount - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (totalShift < 0x20) {\n    isBorrow = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    shiftAmount = totalShift;\n    if (!isZero && isBorrow == false) {\n      shiftedResult = input << totalShift;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isNegative != isBorrow) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isZero || isNegative != isBorrow) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isBorrow) {\n    shiftedResult = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002f0:\n  if (totalShift < 0x433) {\n    return CONCAT44(input + (0x432 - totalShift) * 0x100000,shiftedResult);\n  }\n  shiftAmount = ~(0x432 - totalShift);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  bitCount = shiftAmount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(input >> (shiftAmount & 0xff),\n                    shiftedResult >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(shiftedResult >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003e4": "reverse_and_shift_080003e4",
                "param_1": "input",
                "uVar1": "shiftedResult",
                "uVar2": "shiftAmount",
                "iVar3": "bitCount",
                "uVar4": "totalShift",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isBorrow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000404": {
            "entrypoint": "0x08000404",
            "current_name": "calculate_shifted_concatenation_08000404",
            "code": "\nulonglong calculateShiftedConcatenation_08000404(uint inputNumber)\n\n{\n  uint shiftCount;\n  uint absValue;\n  uint extractedBits;\n  int leadingZeros;\n  uint additionalShift;\n  uint signBit;\n  uint unusedValue;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (inputNumber == 0) {\n    return 0;\n  }\n  signBit = inputNumber & 0x80000000;\n  absValue = inputNumber;\n  if ((int)signBit < 0) {\n    absValue = -inputNumber;\n  }\n  shiftCount = 0;\n  leadingZeros = LZCOUNT(absValue);\n  additionalShift = leadingZeros + 0x15;\n  isCarry = SBORROW4(additionalShift,0x20);\n  extractedBits = leadingZeros - 0xb;\n  isNegative = (int)extractedBits < 0;\n  isZero = extractedBits == 0;\n  if (additionalShift < 0x20) {\n    isCarry = SCARRY4(extractedBits,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    extractedBits = additionalShift;\n    if (!isZero && isCarry == false) {\n      shiftCount = absValue << additionalShift;\n      absValue = absValue >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    unusedValue = 0x20 - extractedBits;\n  }\n  absValue = absValue << (extractedBits & 0xff);\n  if (isZero || isNegative != isCarry) {\n    absValue = absValue | 0U >> (unusedValue & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    shiftCount = 0 << (extractedBits & 0xff);\n  }\nLAB_080002f0:\n  if (additionalShift < 0x433) {\n    return CONCAT44(absValue + (0x432 - additionalShift) * 0x100000 | signBit,shiftCount);\n  }\n  extractedBits = ~(0x432 - additionalShift);\n  if (0x1e < (int)extractedBits) {\n    return CONCAT44(inputNumber,absValue >> (extractedBits - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = extractedBits - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(extractedBits - 0x1f,0xc)) {\n    extractedBits = extractedBits + 1;\n    return CONCAT44(signBit | absValue >> (extractedBits & 0xff),\n                    shiftCount >> (extractedBits & 0xff) | absValue << (0x20 - extractedBits & 0xff));\n  }\n  return CONCAT44(inputNumber,shiftCount >> (0x20 - (0xcU - leadingZeros) & 0xff) | absValue << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000404": "calculate_shifted_concatenation_08000404",
                "param_1": "inputNumber",
                "uVar1": "shiftCount",
                "uVar2": "absValue",
                "uVar3": "extractedBits",
                "iVar4": "leadingZeros",
                "uVar5": "additionalShift",
                "uVar6": "signBit",
                "in_r12": "unusedValue",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "isCarry"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000428": {
            "entrypoint": "0x08000428",
            "current_name": "reverse_bit_pattern_08000428",
            "code": "\nulonglong reverseBitPattern_08000428(uint inputValue,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint signBit;\n  uint temp1;\n  uint result1;\n  uint shiftedValue;\n  uint temp2;\n  int shiftCount;\n  uint maskedValue;\n  uint temp3;\n  bool isNegative;\n  bool isZero;\n  bool carry;\n  \n  temp2 = inputValue << 1;\n  isZero = temp2 == 0;\n  signBit = (uint)((inputValue & 0x80000000) != 0) << 0x1f;\n  shiftedValue = (uint)((int)temp2 >> 3) >> 1;\n  result1 = signBit | shiftedValue;\n  inputValue = inputValue << 0x1d;\n  if (!isZero) {\n    param4 = temp2 & 0xff000000;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = param4 == 0xff000000;\n  }\n  if (!isZero) {\n    return CONCAT44(result1,inputValue) ^ 0x3800000000000000;\n  }\n  if (temp2 == 0 || param4 == 0xff000000) {\n    return CONCAT44(result1,inputValue);\n  }\n  temp1 = inputValue;\n  temp2 = shiftedValue;\n  if (shiftedValue == 0) {\n    temp1 = 0;\n    temp2 = inputValue;\n  }\n  shiftCount = leadingZerosCount(temp2);\n  if (shiftedValue == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  maskedValue = shiftCount - 0xb;\n  carry = subtractionBorrow(maskedValue,0x20);\n  shiftedValue = shiftCount - 0x2b;\n  isZero = (int)shiftedValue < 0;\n  isNegative = shiftedValue == 0;\n  if ((int)maskedValue < 0x20) {\n    carry = subtractionCarry(shiftedValue,0xc);\n    shiftCount = shiftCount + -0x1f;\n    isZero = shiftCount < 0;\n    isNegative = shiftCount == 0;\n    shiftedValue = maskedValue;\n    if (!isNegative && isZero == carry) {\n      temp1 = temp2 << (maskedValue & 0xff);\n      temp2 = temp2 >> (0xcU - shiftCount & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isNegative || isZero != carry) {\n    temp3 = 0x20 - shiftedValue;\n  }\n  temp2 = temp2 << (shiftedValue & 0xff);\n  if (isNegative || isZero != carry) {\n    temp2 = temp2 | temp1 >> (temp3 & 0xff);\n  }\n  if (isNegative || isZero != carry) {\n    temp1 = temp1 << (shiftedValue & 0xff);\n  }\nLAB_080002f0:\n  if ((int)maskedValue < 0x381) {\n    return CONCAT44(temp2 + (0x380 - maskedValue) * 0x100000 | signBit,temp1);\n  }\n  shiftedValue = ~(0x380 - maskedValue);\n  if ((int)shiftedValue < 0x1f) {\n    shiftCount = shiftedValue - 0x13;\n    if (shiftCount != 0 && shiftCount < 0 == subtractionCarry(shiftedValue - 0x1f,0xc)) {\n      return CONCAT44(result1,temp1 >> (0x20 - (0xcU - shiftCount) & 0xff) | temp2 << (0xcU - shiftCount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftedValue = shiftedValue + 1;\n    return CONCAT44(signBit | temp2 >> (shiftedValue & 0xff),\n                    temp1 >> (shiftedValue & 0xff) | temp2 << (0x20 - shiftedValue & 0xff));\n  }\n  return CONCAT44(result1,temp2 >> (shiftedValue - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000428": "reverse_bit_pattern_08000428",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "signBit",
                "uVar2": "temp1",
                "uVar3": "result1",
                "uVar4": "shiftedValue",
                "uVar5": "temp2",
                "iVar6": "shiftCount",
                "uVar7": "maskedValue",
                "in_r12": "temp3",
                "bVar8": "isNegative",
                "bVar9": "isZero",
                "bVar10": "carry",
                "LZCOUNT": "leadingZerosCount",
                "SBORROW4": "subtractionBorrow",
                "SCARRY4": "subtractionCarry"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000464": {
            "entrypoint": "0x08000464",
            "current_name": "calculate_concatenation_08000464",
            "code": "\nulonglong calculateConcatenation_08000464(uint firstNumber,uint secondNumber)\n\n{\n  byte firstByte;\n  uint tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  int tempVar4;\n  uint tempVar5;\n  int tempVar6;\n  uint tempVar7;\n  bool boolVar1;\n  bool boolVar2;\n  bool boolVar3;\n  \n  if ((firstNumber | secondNumber) == 0) {\n    return CONCAT44(secondNumber,firstNumber);\n  }\n  tempVar6 = 0x432;\n  tempVar7 = secondNumber >> 0x16;\n  if (tempVar7 != 0) {\n    tempVar6 = 3;\n    if (secondNumber >> 0x19 != 0) {\n      tempVar6 = 6;\n    }\n    if (secondNumber >> 0x1c != 0) {\n      tempVar6 = tempVar6 + 3;\n    }\n    tempVar3 = tempVar6 - ((int)secondNumber >> 0x1f);\n    tempVar7 = firstNumber << (0x20 - tempVar3 & 0xff);\n    firstNumber = firstNumber >> (tempVar3 & 0xff) | secondNumber << (0x20 - tempVar3 & 0xff);\n    secondNumber = secondNumber >> (tempVar3 & 0xff);\n    tempVar6 = tempVar3 + 0x432;\n  }\n  if (0xfffff < secondNumber) {\n    if (0x1fffff < secondNumber) {\n      tempVar3 = secondNumber & 1;\n      secondNumber = secondNumber >> 1;\n      firstByte = (byte)firstNumber;\n      firstNumber = (uint)(tempVar3 != 0) << 0x1f | firstNumber >> 1;\n      tempVar7 = (uint)(firstByte & 1) << 0x1f | tempVar7 >> 1;\n      tempVar6 = tempVar6 + 1;\n      if (0xffbfffff < (uint)(tempVar6 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000278:\n    boolVar2 = 0x7fffffff < tempVar7;\n    if (tempVar7 == 0x80000000) {\n      boolVar2 = (firstNumber & 1) != 0;\n    }\n    return CONCAT44(secondNumber + tempVar6 * 0x100000 + (uint)CARRY4(firstNumber,(uint)boolVar2),firstNumber + boolVar2\n                   );\n  }\n  boolVar1 = (tempVar7 & 0x80000000) != 0;\n  tempVar7 = tempVar7 << 1;\n  tempVar3 = firstNumber * 2;\n  boolVar2 = CARRY4(firstNumber,firstNumber);\n  firstNumber = firstNumber * 2 + (uint)boolVar1;\n  secondNumber = secondNumber * 2 + (uint)(boolVar2 || CARRY4(tempVar3,(uint)boolVar1));\n  tempVar6 = tempVar6 + -1;\n  if ((secondNumber & 0x100000) != 0) goto LAB_08000278;\n  tempVar1 = firstNumber;\n  tempVar3 = secondNumber;\n  if (secondNumber == 0) {\n    tempVar1 = 0;\n    tempVar3 = firstNumber;\n  }\n  tempVar4 = LZCOUNT(tempVar3);\n  if (secondNumber == 0) {\n    tempVar4 = tempVar4 + 0x20;\n  }\n  tempVar5 = tempVar4 - 0xb;\n  boolVar3 = SBORROW4(tempVar5,0x20);\n  tempVar2 = tempVar4 - 0x2b;\n  boolVar2 = (int)tempVar2 < 0;\n  boolVar1 = tempVar2 == 0;\n  if ((int)tempVar5 < 0x20) {\n    boolVar3 = SCARRY4(tempVar2,0xc);\n    tempVar4 = tempVar4 + -0x1f;\n    boolVar2 = tempVar4 < 0;\n    boolVar1 = tempVar4 == 0;\n    tempVar2 = tempVar5;\n    if (!boolVar1 && boolVar2 == boolVar3) {\n      tempVar1 = tempVar3 << (tempVar5 & 0xff);\n      tempVar3 = tempVar3 >> (0xcU - tempVar4 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (boolVar1 || boolVar2 != boolVar3) {\n    tempVar7 = 0x20 - tempVar2;\n  }\n  tempVar3 = tempVar3 << (tempVar2 & 0xff);\n  if (boolVar1 || boolVar2 != boolVar3) {\n    tempVar3 = tempVar3 | tempVar1 >> (tempVar7 & 0xff);\n  }\n  if (boolVar1 || boolVar2 != boolVar3) {\n    tempVar1 = tempVar1 << (tempVar2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)tempVar5 <= tempVar6) {\n    return CONCAT44(tempVar3 + (tempVar6 - tempVar5) * 0x100000,tempVar1);\n  }\n  tempVar7 = ~(tempVar6 - tempVar5);\n  if (0x1e < (int)tempVar7) {\n    return (ulonglong)(tempVar3 >> (tempVar7 - 0x1f & 0xff));\n  }\n  tempVar6 = tempVar7 - 0x13;\n  if (tempVar6 == 0 || tempVar6 < 0 != SCARRY4(tempVar7 - 0x1f,0xc)) {\n    tempVar7 = tempVar7 + 1;\n    return CONCAT44(tempVar3 >> (tempVar7 & 0xff),tempVar1 >> (tempVar7 & 0xff) | tempVar3 << (0x20 - tempVar7 & 0xff)\n                   );\n  }\n  return (ulonglong)(tempVar1 >> (0x20 - (0xcU - tempVar6) & 0xff) | tempVar3 << (0xcU - tempVar6 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_08000464": "calculate_concatenation_08000464",
                "param_1": "firstNumber",
                "param_2": "secondNumber",
                "bVar1": "firstByte",
                "uVar2": "tempVar1",
                "uVar3": "tempVar2",
                "uVar4": "tempVar3",
                "iVar5": "tempVar4",
                "uVar6": "tempVar5",
                "iVar7": "tempVar6",
                "uVar8": "tempVar7",
                "bVar9": "boolVar1",
                "bVar10": "boolVar2",
                "bVar11": "boolVar3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000474": {
            "entrypoint": "0x08000474",
            "current_name": "bitwise_arithmetic_08000474",
            "code": "\nulonglong bitwise_arithmetic_08000474(uint input_1,uint input_2)\n\n{\n  byte result_byte;\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  int temp_4;\n  uint temp_5;\n  int temp_6;\n  uint temp_7;\n  uint temp_8;\n  bool bool_1;\n  bool bool_2;\n  bool bool_3;\n  \n  if ((input_1 | input_2) == 0) {\n    return CONCAT44(input_2,input_1);\n  }\n  temp_7 = input_2 & 0x80000000;\n  temp_2 = input_2;\n  if ((int)temp_7 < 0) {\n    bool_2 = input_1 != 0;\n    input_1 = -input_1;\n    temp_2 = -input_2 - (uint)bool_2;\n  }\n  temp_6 = 0x432;\n  temp_8 = temp_2 >> 0x16;\n  if (temp_8 != 0) {\n    temp_6 = 3;\n    if (temp_2 >> 0x19 != 0) {\n      temp_6 = 6;\n    }\n    if (temp_2 >> 0x1c != 0) {\n      temp_6 = temp_6 + 3;\n    }\n    temp_3 = temp_6 - ((int)temp_2 >> 0x1f);\n    temp_8 = input_1 << (0x20 - temp_3 & 0xff);\n    input_1 = input_1 >> (temp_3 & 0xff) | temp_2 << (0x20 - temp_3 & 0xff);\n    temp_2 = temp_2 >> (temp_3 & 0xff);\n    temp_6 = temp_3 + 0x432;\n  }\n  if (0xfffff < temp_2) {\n    if (0x1fffff < temp_2) {\n      temp_3 = temp_2 & 1;\n      temp_2 = temp_2 >> 1;\n      result_byte = (byte)input_1;\n      input_1 = (uint)(temp_3 != 0) << 0x1f | input_1 >> 1;\n      temp_8 = (uint)(result_byte & 1) << 0x1f | temp_8 >> 1;\n      temp_6 = temp_6 + 1;\n      if (0xffbfffff < (uint)(temp_6 * 0x200000)) {\n        return (ulonglong)(temp_7 | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000278:\n    bool_2 = 0x7fffffff < temp_8;\n    if (temp_8 == 0x80000000) {\n      bool_2 = (input_1 & 1) != 0;\n    }\n    return CONCAT44(temp_2 + temp_6 * 0x100000 + (uint)CARRY4(input_1,(uint)bool_2) | temp_7,\n                    input_1 + bool_2);\n  }\n  bool_1 = (temp_8 & 0x80000000) != 0;\n  temp_8 = temp_8 << 1;\n  temp_3 = input_1 * 2;\n  bool_2 = CARRY4(input_1,input_1);\n  input_1 = input_1 * 2 + (uint)bool_1;\n  temp_2 = temp_2 * 2 + (uint)(bool_2 || CARRY4(temp_3,(uint)bool_1));\n  temp_6 = temp_6 + -1;\n  if ((temp_2 & 0x100000) != 0) goto LAB_08000278;\n  temp_1 = input_1;\n  temp_3 = temp_2;\n  if (temp_2 == 0) {\n    temp_1 = 0;\n    temp_3 = input_1;\n  }\n  temp_4 = LZCOUNT(temp_3);\n  if (temp_2 == 0) {\n    temp_4 = temp_4 + 0x20;\n  }\n  temp_5 = temp_4 - 0xb;\n  bool_3 = SBORROW4(temp_5,0x20);\n  temp_2 = temp_4 - 0x2b;\n  bool_2 = (int)temp_2 < 0;\n  bool_1 = temp_2 == 0;\n  if ((int)temp_5 < 0x20) {\n    bool_3 = SCARRY4(temp_2,0xc);\n    temp_4 = temp_4 + -0x1f;\n    bool_2 = temp_4 < 0;\n    bool_1 = temp_4 == 0;\n    temp_2 = temp_5;\n    if (!bool_1 && bool_2 == bool_3) {\n      temp_1 = temp_3 << (temp_5 & 0xff);\n      temp_3 = temp_3 >> (0xcU - temp_4 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bool_1 || bool_2 != bool_3) {\n    temp_8 = 0x20 - temp_2;\n  }\n  temp_3 = temp_3 << (temp_2 & 0xff);\n  if (bool_1 || bool_2 != bool_3) {\n    temp_3 = temp_3 | temp_1 >> (temp_8 & 0xff);\n  }\n  if (bool_1 || bool_2 != bool_3) {\n    temp_1 = temp_1 << (temp_2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp_5 <= temp_6) {\n    return CONCAT44(temp_3 + (temp_6 - temp_5) * 0x100000 | temp_7,temp_1);\n  }\n  temp_2 = ~(temp_6 - temp_5);\n  if (0x1e < (int)temp_2) {\n    return CONCAT44(input_2,temp_3 >> (temp_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  temp_6 = temp_2 - 0x13;\n  if (temp_6 == 0 || temp_6 < 0 != SCARRY4(temp_2 - 0x1f,0xc)) {\n    temp_2 = temp_2 + 1;\n    return CONCAT44(temp_7 | temp_3 >> (temp_2 & 0xff),\n                    temp_1 >> (temp_2 & 0xff) | temp_3 << (0x20 - temp_2 & 0xff));\n  }\n  return CONCAT44(input_2,temp_1 >> (0x20 - (0xcU - temp_6) & 0xff) | temp_3 << (0xcU - temp_6 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000474": "bitwise_arithmetic_08000474",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "result_byte",
                "uVar2": "temp_1",
                "uVar3": "temp_2",
                "uVar4": "temp_3",
                "iVar5": "temp_4",
                "uVar6": "temp_5",
                "iVar7": "temp_6",
                "uVar8": "temp_7",
                "uVar9": "temp_8",
                "bVar10": "bool_1",
                "bVar11": "bool_2",
                "bVar12": "bool_3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d0": {
            "entrypoint": "0x080004d0",
            "current_name": "calculate_shift_and_add_080004d0",
            "code": "\nulonglong calculate_shift_and_add_080004d0(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  ulonglong temp_1;\n  longlong temp_2;\n  uint temp_3;\n  uint temp_4;\n  int temp_5;\n  uint temp_6;\n  uint temp_7;\n  uint temp_8;\n  uint temp_9;\n  bool flag_1;\n  bool flag_2;\n  bool flag_3;\n  ulonglong result;\n  \n  result = CONCAT44(input_2,input_1);\n  temp_8 = 0x7ff;\n  temp_4 = input_2 >> 0x14 & 0x7ff;\n  flag_1 = temp_4 == 0;\n  if (!flag_1) {\n    temp_7 = input_4 >> 0x14 & 0x7ff;\n    flag_1 = temp_7 == 0;\n  }\n  if (!flag_1) {\n    flag_1 = temp_4 == 0x7ff;\n  }\n  if (!flag_1) {\n    flag_1 = temp_7 == 0x7ff;\n  }\n  if (flag_1) {\n    result = calculate_xor_shift_080006ac();\n  }\n  temp_3 = (uint)(result >> 0x20);\n  temp_5 = temp_4 + temp_7;\n  temp_4 = temp_3 ^ input_4;\n  temp_3 = temp_3 & ~(temp_8 << 0x15);\n  input_4 = input_4 & ~(temp_8 << 0x15);\n  flag_1 = ((uint)result | temp_3 << 0xc) == 0;\n  if (!flag_1) {\n    flag_1 = (input_3 | input_4 << 0xc) == 0;\n  }\n  temp_3 = temp_3 | 0x100000;\n  input_4 = input_4 | 0x100000;\n  if (flag_1) {\n    input_3 = (uint)result | input_3;\n    input_4 = (temp_4 & 0x80000000 | temp_3) ^ input_4;\n    temp_4 = temp_8 >> 1;\n    flag_3 = SBORROW4(temp_5,temp_4);\n    temp_6 = temp_5 - temp_4;\n    flag_1 = temp_6 == 0;\n    temp_3 = temp_6;\n    if (!flag_1 && (int)temp_4 <= temp_5) {\n      flag_3 = SBORROW4(temp_8,temp_6);\n      temp_3 = temp_8 - temp_6;\n      flag_1 = temp_8 == temp_6;\n    }\n    if (!flag_1 && (int)temp_3 < 0 == flag_3) {\n      input_4 = input_4 | temp_6 * 0x100000;\n    }\n    if (!flag_1 && (int)temp_3 < 0 == flag_3) {\n      return CONCAT44(input_4,input_3);\n    }\n    input_4 = input_4 | 0x100000;\n    temp_8 = 0;\n    flag_3 = SBORROW4(temp_6,1);\n    temp_6 = temp_6 - 1;\n    flag_1 = temp_6 == 0;\n    temp_4 = temp_6;\n  }\n  else {\n    temp_1 = (result & 0xffffffff) * (ulonglong)input_3;\n    result = (result & 0xffffffff) * (ulonglong)input_4 +\n             (ulonglong)temp_3 * (ulonglong)input_3 + (temp_1 >> 0x20);\n    temp_9 = (uint)result;\n    temp_2 = (ulonglong)temp_3 * (ulonglong)input_4 + (result >> 0x20);\n    temp_8 = (uint)temp_2;\n    temp_3 = (uint)((ulonglong)temp_2 >> 0x20);\n    if ((int)temp_1 != 0) {\n      temp_9 = temp_9 | 1;\n    }\n    temp_6 = (temp_5 + -0x3ff) - (uint)(temp_3 < 0x200);\n    if (temp_3 < 0x200) {\n      flag_1 = (temp_9 & 0x80000000) != 0;\n      temp_9 = temp_9 << 1;\n      temp_2 = CONCAT44(temp_3 * 2 + (uint)(CARRY4(temp_8,temp_8) || CARRY4(temp_8 * 2,(uint)flag_1)),\n                       temp_8 * 2 + (uint)flag_1);\n    }\n    input_4 = temp_4 & 0x80000000 | (int)((ulonglong)temp_2 >> 0x20) << 0xb | (uint)temp_2 >> 0x15;\n    input_3 = (uint)temp_2 << 0xb | temp_9 >> 0x15;\n    temp_8 = temp_9 * 0x800;\n    flag_2 = 0xfc < temp_6;\n    flag_3 = SBORROW4(temp_6,0xfd);\n    temp_3 = temp_6 - 0xfd;\n    flag_1 = temp_3 == 0;\n    temp_4 = temp_3;\n    if (flag_2 && !flag_1) {\n      flag_2 = 0x6ff < temp_3;\n      flag_3 = SBORROW4(temp_3,0x700);\n      temp_4 = temp_6 - 0x7fd;\n      flag_1 = temp_3 == 0x700;\n    }\n    if (!flag_2 || flag_1) {\n      flag_1 = 0x7fffffff < temp_8;\n      if (temp_8 == 0x80000000) {\n        flag_1 = (temp_9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_4 + temp_6 * 0x100000 + (uint)CARRY4(input_3,(uint)flag_1),input_3 + flag_1\n                     );\n    }\n  }\n  if (!flag_1 && (int)temp_4 < 0 == flag_3) {\n    return (ulonglong)(input_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag_2 = SCARRY4(temp_6,0x36);\n  flag_1 = (int)(temp_6 + 0x36) < 0;\n  flag_3 = temp_6 == 0xffffffca;\n  if (flag_3 || flag_1 != flag_2) {\n    input_3 = 0;\n  }\n  if (flag_3 || flag_1 != flag_2) {\n    input_4 = input_4 & 0x80000000;\n  }\n  if (flag_3 || flag_1 != flag_2) {\n    return CONCAT44(input_4,input_3);\n  }\n  temp_4 = -temp_6;\n  temp_3 = temp_4 - 0x20;\n  if (0x1f < (int)temp_4) {\n    temp_6 = input_3 >> (temp_3 & 0xff) | input_4 << (0x20 - temp_3 & 0xff);\n    temp_4 = (input_4 >> (temp_3 & 0xff) & ~((input_4 & 0x80000000) >> (temp_3 & 0xff))) -\n            ((int)temp_6 >> 0x1f);\n    if ((temp_8 | input_3 << (0x20 - temp_3 & 0xff) | temp_6 << 1) == 0) {\n      temp_4 = temp_4 & ~(temp_6 >> 0x1f);\n    }\n    return CONCAT44(input_4,temp_4) & 0x80000000ffffffff;\n  }\n  temp_5 = temp_4 - 0x14;\n  if (temp_5 == 0 || temp_5 < 0 != SCARRY4(temp_3,0xc)) {\n    temp_9 = input_3 << (temp_6 + 0x20 & 0xff);\n    temp_3 = input_3 >> (temp_4 & 0xff) | input_4 << (temp_6 + 0x20 & 0xff);\n    temp_6 = temp_3 + -((int)temp_9 >> 0x1f);\n    if ((temp_8 | temp_9 << 1) == 0) {\n      temp_6 = temp_6 & ~(temp_9 >> 0x1f);\n    }\n    return CONCAT44((input_4 & 0x80000000) +\n                    ((input_4 & 0x7fffffff) >> (temp_4 & 0xff)) +\n                    (uint)CARRY4(temp_3,-((int)temp_9 >> 0x1f)),temp_6);\n  }\n  temp_4 = 0xc - temp_5;\n  temp_6 = input_3 << (temp_4 & 0xff);\n  temp_4 = input_3 >> (0x20 - temp_4 & 0xff) | input_4 << (temp_4 & 0xff);\n  temp_3 = temp_4 + -((int)temp_6 >> 0x1f);\n  if ((temp_8 | temp_6 << 1) == 0) {\n    temp_3 = temp_3 & ~(temp_6 >> 0x1f);\n  }\n  return CONCAT44((input_4 & 0x80000000) + (uint)CARRY4(temp_4,-((int)temp_6 >> 0x1f)),temp_3);\n}\n\n",
            "renaming": {
                "FUN_080004d0": "calculate_shift_and_add_080004d0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "lVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "iVar5": "temp_5",
                "uVar6": "temp_6",
                "unaff_r5": "temp_7",
                "uVar7": "temp_8",
                "uVar8": "temp_9",
                "bVar9": "flag_1",
                "bVar10": "flag_2",
                "bVar11": "flag_3",
                "uVar12": "result"
            },
            "calling": [
                "pow",
                "scalbn",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_080006ac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006ac": {
            "entrypoint": "0x080006ac",
            "current_name": "calculate_xor_shift_080006ac",
            "code": "\nulonglong calculate_xor_shift_080006ac(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint shifted_input1;\n  uint input_copy;\n  uint shifted_copy;\n  uint shifted_input2;\n  uint input_mask;\n  bool is_zero;\n  \n  shifted_copy = input_mask & input4 >> 0x14;\n  if (input_copy != input_mask && shifted_copy != input_mask) {\n    is_zero = (input1 | input2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input3 | input4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (input_copy == 0) {\n      shifted_input2 = input2 & 0x80000000;\n      do {\n        shifted_input1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(shifted_input1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | shifted_input2;\n      if (shifted_copy != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      shifted_copy = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(shifted_copy != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  is_zero = (input1 | input2 << 1) == 0;\n  if (is_zero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!is_zero) {\n    is_zero = (input3 | input4 << 1) == 0;\n  }\n  shifted_input2 = input2;\n  if (((!is_zero) && ((input_copy != input_mask || ((input1 | input2 << 0xc) == 0)))) &&\n     ((shifted_copy != input_mask || (input1 = input3, shifted_input2 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(shifted_input2,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006ac": "calculate_xor_shift_080006ac",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "shifted_input1",
                "unaff_r4": "input_copy",
                "uVar2": "shifted_copy",
                "uVar3": "shifted_input2",
                "in_r12": "input_mask",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000724": {
            "entrypoint": "0x08000724",
            "current_name": "calculate_floating_point_08000724",
            "code": "\nulonglong calculateFloatingPoint_08000724(undefined4 sign,uint exponent,uint mantissa1,uint mantissa2)\n\n{\n  uint exponent1;\n  uint exponent2;\n  uint mantissa1Shifted;\n  uint mantissa2Shifted;\n  uint shiftedDifference;\n  uint bitMask;\n  uint resultExponent;\n  int exponentDifference;\n  uint roundedExponent;\n  uint unaff_r5;\n  uint mantissa1Scaled;\n  uint mantissa2Scaled;\n  uint difference;\n  uint onesComplement;\n  bool isZero;\n  bool isDifferenceZero;\n  bool carrySet;\n  undefined8 reversedBinary;\n  \n  reversedBinary = CONCAT44(exponent,sign);\n  onesComplement = 0x7ff;\n  resultExponent = exponent >> 0x14 & 0x7ff;\n  isZero = resultExponent == 0;\n  if (!isZero) {\n    unaff_r5 = mantissa2 >> 0x14 & 0x7ff;\n    isZero = unaff_r5 == 0;\n  }\n  if (!isZero) {\n    isZero = resultExponent == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = unaff_r5 == 0x7ff;\n  }\n  if (isZero) {\n    reversedBinary = reverse_binary_08000892();\n  }\n  roundedExponent = (uint)((ulonglong)reversedBinary >> 0x20);\n  mantissa2Scaled = (uint)reversedBinary;\n  exponentDifference = resultExponent - unaff_r5;\n  if ((mantissa1 | mantissa2 << 0xc) == 0) {\n    resultExponent = (roundedExponent ^ mantissa2) & 0x80000000 | roundedExponent & 0xfffff;\n    carrySet = SCARRY4(exponentDifference,onesComplement >> 1);\n    roundedExponent = exponentDifference + (onesComplement >> 1);\n    isZero = (int)roundedExponent < 0;\n    isDifferenceZero = roundedExponent == 0;\n    if (!isDifferenceZero && isZero == carrySet) {\n      carrySet = SBORROW4(onesComplement,roundedExponent);\n      isZero = (int)(onesComplement - roundedExponent) < 0;\n      isDifferenceZero = onesComplement == roundedExponent;\n    }\n    if (!isDifferenceZero && isZero == carrySet) {\n      resultExponent = resultExponent | roundedExponent * 0x100000;\n    }\n    if (!isDifferenceZero && isZero == carrySet) {\n      return CONCAT44(resultExponent,mantissa2Scaled);\n    }\n    resultExponent = resultExponent | 0x100000;\n    onesComplement = 0;\n    isDifferenceZero = SBORROW4(roundedExponent,1);\n    roundedExponent = roundedExponent - 1;\n    isZero = roundedExponent == 0;\n    mantissa1Shifted = roundedExponent;\n  }\n  else {\n    mantissa1Shifted = (mantissa2 << 0xc) >> 4 | 0x10000000 | mantissa1 >> 0x18;\n    onesComplement = mantissa1 << 8;\n    mantissa1Scaled = (roundedExponent << 0xc) >> 4 | 0x10000000 | mantissa2Scaled >> 0x18;\n    mantissa2Scaled = mantissa2Scaled * 0x100;\n    resultExponent = (roundedExponent ^ mantissa2) & 0x80000000;\n    isZero = mantissa1Shifted <= mantissa1Scaled;\n    if (mantissa1Scaled == mantissa1Shifted) {\n      isZero = onesComplement <= mantissa2Scaled;\n    }\n    exponentDifference = exponentDifference + (uint)isZero;\n    roundedExponent = exponentDifference + 0x3fd;\n    if (isZero == false) {\n      mantissa1Shifted = mantissa1Shifted >> 1;\n      onesComplement = (uint)((mantissa1 >> 0x18 & 1) != 0) << 0x1f | onesComplement >> 1;\n    }\n    difference = mantissa2Scaled - onesComplement;\n    mantissa1Scaled = (mantissa1Scaled - mantissa1Shifted) - (uint)(mantissa2Scaled < onesComplement);\n    mantissa2Shifted = mantissa1Shifted >> 1;\n    exponent1 = (uint)((mantissa1Shifted & 1) != 0) << 0x1f | onesComplement >> 1;\n    mantissa2Scaled = 0x100000;\n    mantissa1Shifted = 0x80000;\n    while( true ) {\n      isZero = exponent1 <= difference;\n      if (mantissa2Shifted < mantissa1Scaled || mantissa1Scaled - mantissa2Shifted < (uint)isZero) {\n        difference = difference - exponent1;\n        mantissa2Scaled = mantissa2Scaled | mantissa1Shifted;\n        mantissa1Scaled = (mantissa1Scaled - mantissa2Shifted) - (uint)!isZero;\n      }\n      shiftedDifference = mantissa2Shifted >> 1;\n      exponent1 = (uint)((mantissa2Shifted & 1) != 0) << 0x1f | exponent1 >> 1;\n      isDifferenceZero = exponent1 <= difference;\n      isZero = mantissa1Scaled - shiftedDifference < (uint)isDifferenceZero;\n      onesComplement = mantissa1Scaled;\n      if (shiftedDifference < mantissa1Scaled || isZero) {\n        difference = difference - exponent1;\n        onesComplement = (mantissa1Scaled - shiftedDifference) - (uint)!isDifferenceZero;\n      }\n      if (shiftedDifference < mantissa1Scaled || isZero) {\n        mantissa2Scaled = mantissa2Scaled | mantissa1Shifted >> 1;\n      }\n      mantissa1Scaled = mantissa2Shifted >> 2;\n      exponent2 = (uint)((shiftedDifference & 1) != 0) << 0x1f | exponent1 >> 1;\n      isDifferenceZero = exponent2 <= difference;\n      isZero = onesComplement - mantissa1Scaled < (uint)isDifferenceZero;\n      shiftedDifference = onesComplement;\n      if (mantissa1Scaled < onesComplement || isZero) {\n        difference = difference - exponent2;\n        shiftedDifference = (onesComplement - mantissa1Scaled) - (uint)!isDifferenceZero;\n      }\n      if (mantissa1Scaled < onesComplement || isZero) {\n        mantissa2Scaled = mantissa2Scaled | mantissa1Shifted >> 2;\n      }\n      bitMask = mantissa2Shifted >> 3;\n      exponent1 = (uint)((mantissa1Scaled & 1) != 0) << 0x1f | exponent2 >> 1;\n      isDifferenceZero = exponent1 <= difference;\n      isZero = shiftedDifference - bitMask < (uint)isDifferenceZero;\n      mantissa1Scaled = shiftedDifference;\n      if (bitMask < shiftedDifference || isZero) {\n        difference = difference - exponent1;\n        mantissa1Scaled = (shiftedDifference - bitMask) - (uint)!isDifferenceZero;\n      }\n      if (bitMask < shiftedDifference || isZero) {\n        mantissa2Scaled = mantissa2Scaled | mantissa1Shifted >> 3;\n      }\n      onesComplement = mantissa1Scaled | difference;\n      if (onesComplement == 0) break;\n      mantissa1Scaled = mantissa1Scaled << 4 | difference >> 0x1c;\n      difference = difference << 4;\n      mantissa2Shifted = mantissa2Shifted & 0xfffffff8 | exponent1 >> 0x1d;\n      exponent1 = (exponent2 >> 1) << 3;\n      mantissa1Shifted = mantissa1Shifted >> 4;\n      if (mantissa1Shifted == 0) {\n        bitMask = mantissa2Shifted;\n        if ((resultExponent & 0x100000) != 0) goto LAB_08000842;\n        resultExponent = resultExponent | mantissa2Scaled;\n        mantissa2Scaled = 0;\n        mantissa1Shifted = 0x80000000;\n      }\n    }\n    if ((resultExponent & 0x100000) == 0) {\n      resultExponent = resultExponent | mantissa2Scaled;\n      mantissa2Scaled = 0;\n    }\nLAB_08000842:\n    carrySet = 0xfc < roundedExponent;\n    isDifferenceZero = SBORROW4(roundedExponent,0xfd);\n    mantissa2Shifted = exponentDifference + 0x300;\n    isZero = mantissa2Shifted == 0;\n    mantissa1Shifted = mantissa2Shifted;\n    if (carrySet && !isZero) {\n      carrySet = 0x6ff < mantissa2Shifted;\n      isDifferenceZero = SBORROW4(mantissa2Shifted,0x700);\n      mantissa1Shifted = exponentDifference - 0x400;\n      isZero = mantissa2Shifted == 0x700;\n    }\n    if (!carrySet || isZero) {\n      isZero = bitMask <= mantissa1Scaled;\n      if (mantissa1Scaled == bitMask) {\n        isZero = exponent1 <= difference;\n      }\n      if (mantissa1Scaled == bitMask && difference == exponent1) {\n        isZero = (mantissa2Scaled & 1) != 0;\n      }\n      return CONCAT44(resultExponent + roundedExponent * 0x100000 + (uint)CARRY4(mantissa2Scaled,(uint)isZero),mantissa2Scaled + isZero);\n    }\n  }\n  if (!isZero && (int)mantissa1Shifted < 0 == isDifferenceZero) {\n    return (ulonglong)(resultExponent & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  carrySet = SCARRY4(roundedExponent,0x36);\n  isZero = (int)(roundedExponent + 0x36) < 0;\n  isDifferenceZero = roundedExponent == 0xffffffca;\n  if (isDifferenceZero || isZero != carrySet) {\n    mantissa2Scaled = 0;\n  }\n  if (isDifferenceZero || isZero != carrySet) {\n    resultExponent = resultExponent & 0x80000000;\n  }\n  if (isDifferenceZero || isZero != carrySet) {\n    return CONCAT44(resultExponent,mantissa2Scaled);\n  }\n  mantissa1Shifted = -roundedExponent;\n  mantissa1Scaled = mantissa1Shifted - 0x20;\n  if (0x1f < (int)mantissa1Shifted) {\n    mantissa1Shifted = mantissa2Scaled >> (mantissa1Scaled & 0xff) | resultExponent << (0x20 - mantissa1Scaled & 0xff);\n    roundedExponent = (resultExponent >> (mantissa1Scaled & 0xff) & ~((resultExponent & 0x80000000) >> (mantissa1Scaled & 0xff))) -\n            ((int)mantissa1Shifted >> 0x1f);\n    if ((onesComplement | mantissa2Scaled << (0x20 - mantissa1Scaled & 0xff) | mantissa1Shifted << 1) == 0) {\n      roundedExponent = roundedExponent & ~(mantissa1Shifted >> 0x1f);\n    }\n    return CONCAT44(resultExponent,roundedExponent) & 0x80000000ffffffff;\n  }\n  exponentDifference = mantissa1Shifted - 0x14;\n  if (exponentDifference != 0 && exponentDifference < 0 == SCARRY4(mantissa1Scaled,0xc)) {\n    roundedExponent = 0xc - exponentDifference;\n    mantissa1Shifted = mantissa2Scaled << (roundedExponent & 0xff);\n    mantissa2Scaled = mantissa2Scaled >> (0x20 - roundedExponent & 0xff) | resultExponent << (roundedExponent & 0xff);\n    roundedExponent = mantissa2Scaled + -((int)mantissa1Shifted >> 0x1f);\n    if ((onesComplement | mantissa1Shifted << 1) == 0) {\n      roundedExponent = roundedExponent & ~(mantissa1Shifted >> 0x1f);\n    }\n    return CONCAT44((resultExponent & 0x80000000) + (uint)CARRY4(mantissa2Scaled,-((int)mantissa1Shifted >> 0x1f)),roundedExponent);\n  }\n  mantissa1Scaled = mantissa2Scaled << (roundedExponent + 0x20 & 0xff);\n  mantissa2Scaled = mantissa2Scaled >> (mantissa1Shifted & 0xff) | resultExponent << (roundedExponent + 0x20 & 0xff);\n  roundedExponent = mantissa2Scaled + -((int)mantissa1Scaled >> 0x1f);\n  if ((onesComplement | mantissa1Scaled << 1) == 0) {\n    roundedExponent = roundedExponent & ~(mantissa1Scaled >> 0x1f);\n  }\n  return CONCAT44((resultExponent & 0x80000000) +\n                  ((resultExponent & 0x7fffffff) >> (mantissa1Shifted & 0xff)) +\n                  (uint)CARRY4(mantissa2Scaled,-((int)mantissa1Scaled >> 0x1f)),roundedExponent);\n}\n\n",
            "renaming": {
                "FUN_08000724": "calculate_floating_point_08000724",
                "param_1": "sign",
                "param_2": "exponent",
                "param_3": "mantissa1",
                "param_4": "mantissa2",
                "uVar1": "exponent1",
                "uVar2": "exponent2",
                "uVar3": "mantissa1Shifted",
                "uVar4": "mantissa2Shifted",
                "uVar5": "shiftedDifference",
                "uVar6": "bitMask",
                "uVar7": "resultExponent",
                "iVar8": "exponentDifference",
                "uVar9": "roundedExponent",
                "uVar10": "mantissa1Scaled",
                "uVar11": "mantissa2Scaled",
                "uVar12": "difference",
                "uVar13": "onesComplement",
                "bVar14": "isZero",
                "bVar15": "isDifferenceZero",
                "bVar16": "carrySet",
                "uVar17": "reversedBinary"
            },
            "calling": [
                "pow",
                "__ieee754_atan2",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_08000892"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000892": {
            "entrypoint": "0x08000892",
            "current_name": "reverse_binary_08000892",
            "code": "\nulonglong reverseBinary_08000892(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit1;\n  uint temp_1;\n  uint bit2;\n  uint temp_2;\n  uint mask;\n  bool isZero;\n  \n  bit2 = mask & input_4 >> 0x14;\n  temp_2 = input_2;\n  if (temp_1 != mask || bit2 != mask) {\n    if (temp_1 == mask) {\n      if (((input_1 | input_2 << 0xc) == 0) && (input_1 = input_3, temp_2 = input_4, bit2 != mask)\n         ) {\nLAB_08000704:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit2 == mask) {\n      input_1 = input_3;\n      temp_2 = input_4;\n      if ((input_3 | input_4 << 0xc) == 0) {\nLAB_080006c8:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input_1 | input_2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input_3 | input_4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (temp_1 == 0) {\n          temp_2 = input_2 & 0x80000000;\n          do {\n            bit1 = input_1 & 0x80000000;\n            input_1 = input_1 << 1;\n            input_2 = input_2 * 2 + (uint)(bit1 != 0);\n          } while ((input_2 & 0x100000) == 0);\n          input_2 = input_2 | temp_2;\n          if (bit2 != 0) {\n            return CONCAT44(input_2,input_1);\n          }\n        }\n        do {\n          temp_2 = input_3 & 0x80000000;\n          input_3 = input_3 << 1;\n          input_4 = input_4 * 2 + (uint)(temp_2 != 0);\n        } while ((input_4 & 0x100000) == 0);\n        return CONCAT44(input_2,input_1);\n      }\n      if ((input_1 | input_2 << 1) != 0) goto LAB_08000704;\n      if ((input_3 | input_4 << 1) != 0) goto LAB_080006c8;\n    }\n  }\n  return CONCAT44(temp_2,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08000892": "reverse_binary_08000892",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit1",
                "unaff_r4": "temp_1",
                "uVar2": "bit2",
                "uVar3": "temp_2",
                "in_r12": "mask",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_parameters_equality_080008f4",
            "code": "\nuint check_parameters_equality_080008f4(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_parameters_equality_080008f4",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_parameters_080008fc",
            "code": "\nuint check_parameters_080008fc(uint num1,uint num2,uint num3,uint num4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLessOrEqual;\n  \n  if (((int)(num2 << 1) >> 0x15 == -1 || (int)(num4 << 1) >> 0x15 == -1) &&\n     ((((int)(num2 << 1) >> 0x15 == -1 && ((num1 | num2 << 0xc) != 0)) ||\n      (((int)(num4 << 1) >> 0x15 == -1 && ((num3 | num4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (num1 | num2 << 1) == 0;\n  if (isZero) {\n    isZero = (num3 | num4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = num2 == num4;\n  }\n  if (isZero) {\n    isZero = num1 == num3;\n  }\n  if (!isZero) {\n    result = num2 ^ num4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = num2 == num4;\n    }\n    isLessOrEqual = -1 < (int)result && num4 <= num2;\n    if (isZero) {\n      isLessOrEqual = num3 <= num1;\n    }\n    num4 = (int)num4 >> 0x1f;\n    if (!isLessOrEqual) {\n      num4 = ~num4;\n    }\n    return num4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLessOrEqual"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000904": {
            "entrypoint": "0x08000904",
            "current_name": "check_data_equality_08000904",
            "code": "\nuint check_data_equality_08000904(uint data_1,uint data_2,uint data_3,uint data_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(data_2 << 1) >> 0x15 == -1 || (int)(data_4 << 1) >> 0x15 == -1) &&\n     ((((int)(data_2 << 1) >> 0x15 == -1 && ((data_1 | data_2 << 0xc) != 0)) ||\n      (((int)(data_4 << 1) >> 0x15 == -1 && ((data_3 | data_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (data_1 | data_2 << 1) == 0;\n  if (isZero) {\n    isZero = (data_3 | data_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = data_2 == data_4;\n  }\n  if (isZero) {\n    isZero = data_1 == data_3;\n  }\n  if (!isZero) {\n    result = data_2 ^ data_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = data_2 == data_4;\n    }\n    isNegative = -1 < (int)result && data_4 <= data_2;\n    if (isZero) {\n      isNegative = data_3 <= data_1;\n    }\n    data_4 = (int)data_4 >> 0x1f;\n    if (!isNegative) {\n      data_4 = ~data_4;\n    }\n    return data_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000904": "check_data_equality_08000904",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000980": {
            "entrypoint": "0x08000980",
            "current_name": "compare_floating_point_numbers_08000980",
            "code": "\nvoid compareFloatingPointNumbers_08000980(undefined4 result,undefined4 status,undefined4 number1,undefined4 number2)\n\n{\n  __aeabi_cdcmpeq(number1,number2,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000980": "compare_floating_point_numbers_08000980",
                "param_1": "result",
                "param_2": "status",
                "param_3": "number1",
                "param_4": "number2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000990": {
            "entrypoint": "0x08000990",
            "current_name": "calculate_result_08000990",
            "code": "\nundefined4 calculate_result_08000990(undefined4 input_value)\n\n{\n  perform_calculation();\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08000990": "calculate_result_08000990",
                "param_1": "input_value",
                "__nedf2": "perform_calculation"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a0": {
            "entrypoint": "0x080009a0",
            "current_name": "check_if_not_zero_080009a0",
            "code": "\nbool check_if_not_zero_080009a0(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009a0": "check_if_not_zero_080009a0",
                "in_ZR": "input_character"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b4": {
            "entrypoint": "0x080009b4",
            "current_name": "check_if_zero_080009b4",
            "code": "\nbool check_if_zero_080009b4(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009b4": "check_if_zero_080009b4",
                "in_CY": "input_character"
            },
            "calling": [
                "pow",
                "sqrt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "is_comparison_true_080009c8",
            "code": "\nbool is_comparison_true_080009c8(void)\n\n{\n  undefined zero_result;\n  undefined carry_result;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)carry_result || (bool)zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c8": "is_comparison_true_080009c8",
                "in_ZR": "zero_result",
                "in_CY": "carry_result"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "compare_and_return_080009dc",
            "code": "\nbool compareAndReturn_080009dc(void)\n\n{\n  undefined zeroResult;\n  undefined comparisonResult;\n  \n  __aeabi_cdrcmple();\n  return !(bool)comparisonResult || (bool)zeroResult;\n}\n\n",
            "renaming": {
                "FUN_080009dc": "compare_and_return_080009dc",
                "in_CY": "comparisonResult",
                "in_ZR": "zeroResult"
            },
            "calling": [],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_if_null_character_080009f0",
            "code": "\nbool check_if_null_character_080009f0(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_if_null_character_080009f0",
                "in_CY": "input_character"
            },
            "calling": [
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_params_08000a04",
            "code": "\nundefined4 checkParams_08000a04(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_params_08000a04",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a30": {
            "entrypoint": "0x08000a30",
            "current_name": "calculate_modified_value_08000a30",
            "code": "\nuint calculateModifiedValue_08000a30(uint inputValue,uint modifierValue)\n\n{\n  uint result;\n  uint doubledModifier;\n  uint newModifier;\n  uint adjustedModifier;\n  bool isZero;\n  bool isLessThanThreshold;\n  \n  doubledModifier = modifierValue * 2;\n  isLessThanThreshold = doubledModifier < 0x70000000;\n  newModifier = doubledModifier + 0x90000000;\n  result = newModifier;\n  if (!isLessThanThreshold) {\n    adjustedModifier = doubledModifier + 0x8fe00000;\n    result = adjustedModifier;\n  }\n  isZero = result == 0;\n  if (!isLessThanThreshold && newModifier >= 0x200000) {\n    isZero = adjustedModifier == 0x1fc00000;\n  }\n  if (((isLessThanThreshold || newModifier < 0x200000) || 0x1fc00000 < adjustedModifier) || isZero) {\n    if ((modifierValue & 0x40000000) != 0) {\n      if (((int)doubledModifier >> 0x15 == -1) && ((inputValue | modifierValue << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return modifierValue & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(doubledModifier + 0x92e00000) < 0 != SCARRY4(newModifier,0x2e00000)) {\n      return modifierValue & 0x80000000;\n    }\n    doubledModifier = 0x18 - (doubledModifier + 0x92e00000 >> 0x15);\n    result = inputValue >> (doubledModifier & 0xff);\n    if (inputValue << (0x20 - doubledModifier & 0xff) != 0) {\n      result = result | 1;\n    }\n    newModifier = modifierValue & 0x1fffff | 0x100000;\n    inputValue = result | newModifier << (0x20 - doubledModifier & 0xff);\n    newModifier = (newModifier >> (doubledModifier & 0xff)) << 1;\n  }\n  result = (modifierValue & 0x80000000 | inputValue >> 0x1d) + newModifier * 4 + (uint)(0x7fffffff < inputValue * 8);\n  if (inputValue * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000a30": "calculate_modified_value_08000a30",
                "param_1": "inputValue",
                "param_2": "modifierValue",
                "uVar1": "result",
                "uVar2": "doubledModifier",
                "uVar3": "newModifier",
                "in_r12": "adjustedModifier",
                "bVar4": "isZero",
                "bVar5": "isLessThanThreshold"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad0": {
            "entrypoint": "0x08000ad0",
            "current_name": "convert_to_absolute_value_08000ad0",
            "code": "\nvoid convertToAbsoluteValue_08000ad0(uint num)\n\n{\n  __addsf3(num ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ad0": "convert_to_absolute_value_08000ad0",
                "param_1": "num"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad8": {
            "entrypoint": "0x08000ad8",
            "current_name": "reverse_bits_08000ad8",
            "code": "\nuint reverseBits_08000ad8(uint input,uint mask,undefined4 param,uint temp)\n\n{\n  int shiftCount1;\n  int shiftCount2;\n  uint temp1;\n  uint temp2;\n  uint result;\n  uint bitDifference;\n  uint shiftDifference;\n  bool isZero;\n  \n  temp1 = mask ^ 0x80000000;\n  result = input << 1;\n  isZero = result == 0;\n  if (!isZero) {\n    temp = mask << 1;\n    isZero = temp == 0;\n  }\n  if (!isZero) {\n    isZero = result == temp;\n  }\n  shiftCount1 = (int)result >> 0x18;\n  if (!isZero) {\n    isZero = shiftCount1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)temp >> 0x18 == -1;\n  }\n  if (isZero) {\n    shiftCount2 = (int)(mask << 1) >> 0x18;\n    if (shiftCount1 == -1 || shiftCount2 == -1) {\n      result = temp1;\n      if (shiftCount1 == -1) {\n        result = input;\n      }\n      if (shiftCount1 != -1 || shiftCount2 != -1) {\n        temp1 = result;\n      }\n      isZero = (result & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (temp1 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = result == temp1;\n      }\n      if (!isZero) {\n        result = result | 0x400000;\n      }\n      return result;\n    }\n    if (((input ^ temp1) & 0x7fffffff) != 0) {\n      if (result == 0) {\n        input = temp1;\n      }\n      return input;\n    }\n    if (input != temp1) {\n      return 0;\n    }\n    if ((result & 0xff000000) == 0) {\n      temp1 = input << 1;\n      if ((input & 0x80000000) != 0) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return temp1;\n    }\n    if (result < 0xfe000000) {\n      return input + 0x800000;\n    }\n    input = input & 0x80000000;\nLAB_08000c12:\n    return input | 0x7f800000;\n  }\n  result = result >> 0x18;\n  temp = temp >> 0x18;\n  shiftDifference = temp - result;\n  isZero = shiftDifference != 0;\n  bitDifference = result;\n  if (isZero && result <= temp) {\n    bitDifference = result + shiftDifference;\n  }\n  if (isZero && result <= temp) {\n    temp1 = temp1 ^ input;\n  }\n  if (isZero && result <= temp) {\n    input = input ^ temp1;\n  }\n  if (isZero && result <= temp) {\n    temp1 = temp1 ^ input;\n  }\n  if (temp < result) {\n    shiftDifference = -shiftDifference;\n  }\n  if (0x19 < shiftDifference) {\n    return input;\n  }\n  result = input & 0xffffff | 0x800000;\n  if ((input & 0x80000000) != 0) {\n    result = -result;\n  }\n  temp2 = temp1 & 0xffffff | 0x800000;\n  if ((temp1 & 0x80000000) != 0) {\n    temp2 = -temp2;\n  }\n  if (bitDifference == shiftDifference) {\n    temp2 = temp2 ^ 0x800000;\n    if (bitDifference == 0) {\n      result = result ^ 0x800000;\n      bitDifference = 1;\n    }\n    else {\n      shiftDifference = shiftDifference - 1;\n    }\n  }\n  result = result + ((int)temp2 >> (shiftDifference & 0xff));\n  temp2 = temp2 << (0x20 - shiftDifference & 0xff);\n  input = result & 0x80000000;\n  if ((int)result < 0) {\n    isZero = temp2 != 0;\n    temp2 = -temp2;\n    result = -result - (uint)isZero;\n  }\n  if (result < 0x800000) {\n    temp1 = temp2 & 0x80000000;\n    temp2 = temp2 << 1;\n    result = result * 2 + (uint)(temp1 != 0);\n    temp1 = bitDifference - 2;\n    if ((result & 0x800000) == 0) {\n      shiftDifference = leadingZeroCount(result) - 8;\n      result = result << (shiftDifference & 0xff);\n      if ((int)temp1 < (int)shiftDifference) {\n        result = result >> (-(temp1 - shiftDifference) & 0xff);\n      }\n      else {\n        result = result + (temp1 - shiftDifference) * 0x800000;\n      }\n      return result | input;\n    }\n  }\n  else {\n    temp1 = bitDifference - 1;\n    if (0xffffff < result) {\n      temp1 = result & 1;\n      result = result >> 1;\n      temp2 = (uint)(temp1 != 0) << 0x1f | temp2 >> 1;\n      temp1 = bitDifference;\n      if (0xfd < bitDifference) goto LAB_08000c12;\n    }\n  }\n  result = result + temp1 * 0x800000 + (uint)(0x7fffffff < temp2);\n  if (temp2 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result | input;\n}\n\n",
            "renaming": {
                "FUN_08000ad8": "reverse_bits_08000ad8",
                "param_1": "input",
                "param_2": "mask",
                "param_3": "param",
                "param_4": "temp",
                "iVar1": "shiftCount1",
                "iVar2": "shiftCount2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "result",
                "uVar6": "bitDifference",
                "uVar7": "shiftDifference",
                "bVar8": "isZero",
                "LZCOUNT": "leadingZeroCount"
            },
            "calling": [
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "AHRS_GetYaw"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000adc": {
            "entrypoint": "0x08000adc",
            "current_name": "calculate_floating_point_08000adc",
            "code": "\nuint calculateFloatingPoint_08000adc(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shifted1;\n  int shifted2;\n  uint result;\n  uint input1_shifted;\n  uint shifted1_temp;\n  uint difference;\n  bool isZero;\n  \n  input1_shifted = input1 << 1;\n  isZero = input1_shifted == 0;\n  if (!isZero) {\n    input4 = input2 << 1;\n    isZero = input4 == 0;\n  }\n  if (!isZero) {\n    isZero = input1_shifted == input4;\n  }\n  shifted1 = (int)input1_shifted >> 0x18;\n  if (!isZero) {\n    isZero = shifted1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)input4 >> 0x18 == -1;\n  }\n  if (isZero) {\n    shifted2 = (int)(input2 << 1) >> 0x18;\n    if (shifted1 == -1 || shifted2 == -1) {\n      input1_shifted = input2;\n      if (shifted1 == -1) {\n        input1_shifted = input1;\n      }\n      if (shifted1 != -1 || shifted2 != -1) {\n        input2 = input1_shifted;\n      }\n      isZero = (input1_shifted & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (input2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = input1_shifted == input2;\n      }\n      if (!isZero) {\n        input1_shifted = input1_shifted | 0x400000;\n      }\n      return input1_shifted;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (input1_shifted == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((input1_shifted & 0xff000000) == 0) {\n      input1_shifted = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        input1_shifted = input1_shifted | 0x80000000;\n      }\n      return input1_shifted;\n    }\n    if (input1_shifted < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000c12:\n    return input1 | 0x7f800000;\n  }\n  input1_shifted = input1_shifted >> 0x18;\n  input4 = input4 >> 0x18;\n  difference = input4 - input1_shifted;\n  isZero = difference != 0;\n  shifted1_temp = input1_shifted;\n  if (isZero && input1_shifted <= input4) {\n    shifted1_temp = input1_shifted + difference;\n  }\n  if (isZero && input1_shifted <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (isZero && input1_shifted <= input4) {\n    input1 = input1 ^ input2;\n  }\n  if (isZero && input1_shifted <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (input4 < input1_shifted) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input1;\n  }\n  input1_shifted = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    input1_shifted = -input1_shifted;\n  }\n  result = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    result = -result;\n  }\n  if (shifted1_temp == difference) {\n    result = result ^ 0x800000;\n    if (shifted1_temp == 0) {\n      input1_shifted = input1_shifted ^ 0x800000;\n      shifted1_temp = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  input1_shifted = input1_shifted + ((int)result >> (difference & 0xff));\n  result = result << (0x20 - difference & 0xff);\n  input1 = input1_shifted & 0x80000000;\n  if ((int)input1_shifted < 0) {\n    isZero = result != 0;\n    result = -result;\n    input1_shifted = -input1_shifted - (uint)isZero;\n  }\n  if (input1_shifted < 0x800000) {\n    difference = result & 0x80000000;\n    result = result << 1;\n    input1_shifted = input1_shifted * 2 + (uint)(difference != 0);\n    difference = shifted1_temp - 2;\n    if ((input1_shifted & 0x800000) == 0) {\n      shifted1_temp = LZCOUNT(input1_shifted) - 8;\n      input1_shifted = input1_shifted << (shifted1_temp & 0xff);\n      if ((int)difference < (int)shifted1_temp) {\n        input1_shifted = input1_shifted >> (-(difference - shifted1_temp) & 0xff);\n      }\n      else {\n        input1_shifted = input1_shifted + (difference - shifted1_temp) * 0x800000;\n      }\n      return input1_shifted | input1;\n    }\n  }\n  else {\n    difference = shifted1_temp - 1;\n    if (0xffffff < input1_shifted) {\n      difference = input1_shifted & 1;\n      input1_shifted = input1_shifted >> 1;\n      result = (uint)(difference != 0) << 0x1f | result >> 1;\n      difference = shifted1_temp;\n      if (0xfd < shifted1_temp) goto LAB_08000c12;\n    }\n  }\n  input1_shifted = input1_shifted + difference * 0x800000 + (uint)(0x7fffffff < result);\n  if (result == 0x80000000) {\n    input1_shifted = input1_shifted & 0xfffffffe;\n  }\n  return input1_shifted | input1;\n}\n\n",
            "renaming": {
                "FUN_08000adc": "calculate_floating_point_08000adc",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar4": "input1_shifted",
                "bVar7": "isZero",
                "iVar1": "shifted1",
                "iVar2": "shifted2",
                "uVar3": "result",
                "uVar5": "shifted1_temp",
                "uVar6": "difference"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_Init",
                "MadgwickQuaternionUpdate",
                "__aeabi_frsub",
                "AHRS_GetYaw",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_modified_value_08000c3c",
            "code": "\nuint calculateModifiedValue_08000c3c(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  int intermediateValue;\n  uint carry;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(inputValue);\n  shiftAmount = leadingZeros - 8;\n  intermediateValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    carry = 0 << (shiftAmount & 0xff);\n    leadingZeros = intermediateValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < carry);\n    if (carry == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  leadingZeros = intermediateValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_modified_value_08000c3c",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "iVar3": "intermediateValue",
                "uVar4": "carry",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c44": {
            "entrypoint": "0x08000c44",
            "current_name": "extract_bits_08000c44",
            "code": "\nuint extract_bits_08000c44(uint input_value)\n\n{\n  uint leading_zeros;\n  uint shift_amount;\n  uint sign_bit;\n  int result;\n  \n  sign_bit = input_value & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_value = -input_value;\n  }\n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zeros = count_leading_zeros(input_value);\n  shift_amount = leading_zeros - 8;\n  result = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeros) {\n    leading_zeros = 0 << (shift_amount & 0xff);\n    sign_bit = result + (input_value << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n    if (leading_zeros == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_amount = input_value << leading_zeros + 0x18;\n  sign_bit = result + ((input_value >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c44": "extract_bits_08000c44",
                "param_1": "input_value",
                "uVar1": "leading_zeros",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "result",
                "LZCOUNT": "count_leading_zeros"
            },
            "calling": [
                "PID_Compute",
                "AK8963_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c60": {
            "entrypoint": "0x08000c60",
            "current_name": "calculate_modified_value_08000c60",
            "code": "\nuint calculateModifiedValue_08000c60(uint value1,uint value2)\n\n{\n  uint modifiedValue1;\n  uint modifiedValue2;\n  uint shiftCount;\n  uint shiftedValue;\n  int constantValue;\n  \n  if ((value1 | value2) == 0) {\n    return value1;\n  }\n  modifiedValue1 = value1;\n  modifiedValue2 = value2;\n  if (value2 == 0) {\n    modifiedValue1 = 0;\n    modifiedValue2 = value1;\n  }\n  constantValue = 0x5b000000;\n  if (value2 == 0) {\n    constantValue = 0x4b000000;\n  }\n  shiftCount = LZCOUNT(modifiedValue2);\n  shiftedValue = shiftCount - 8;\n  constantValue = constantValue + -0x800000 + shiftedValue * -0x800000;\n  if (shiftCount < 8) {\n    shiftedValue = modifiedValue2 << shiftCount + 0x18;\n    modifiedValue2 = constantValue + ((modifiedValue2 >> (0x20 - (shiftCount + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n    if ((modifiedValue1 | shiftedValue << 1) == 0) {\n      modifiedValue2 = modifiedValue2 & ~(shiftedValue >> 0x1f);\n    }\n    return modifiedValue2;\n  }\n  shiftCount = modifiedValue1 << (shiftedValue & 0xff);\n  modifiedValue2 = constantValue + (modifiedValue2 << (shiftedValue & 0xff)) +\n          (modifiedValue1 >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < shiftCount);\n  if (shiftCount == 0x80000000) {\n    modifiedValue2 = modifiedValue2 & 0xfffffffe;\n  }\n  return modifiedValue2;\n}\n\n",
            "renaming": {
                "FUN_08000c60": "calculate_modified_value_08000c60",
                "param_1": "value1",
                "param_2": "value2",
                "uVar1": "modifiedValue1",
                "uVar2": "modifiedValue2",
                "uVar3": "shiftCount",
                "uVar4": "shiftedValue",
                "iVar5": "constantValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c70": {
            "entrypoint": "0x08000c70",
            "current_name": "calculate_result_08000c70",
            "code": "\nuint calculate_result_08000c70(uint input_number1,uint input_number2)\n\n{\n  uint result1;\n  uint result2;\n  uint bit_count;\n  uint shift_amount;\n  uint flag;\n  int offset;\n  bool is_nonzero;\n  \n  if ((input_number1 | input_number2) == 0) {\n    return input_number1;\n  }\n  flag = input_number2 & 0x80000000;\n  if ((int)flag < 0) {\n    is_nonzero = input_number1 != 0;\n    input_number1 = -input_number1;\n    input_number2 = -input_number2 - (uint)is_nonzero;\n  }\n  result2 = input_number1;\n  result1 = input_number2;\n  if (input_number2 == 0) {\n    result2 = 0;\n    result1 = input_number1;\n  }\n  flag = flag | 0x5b000000;\n  if (input_number2 == 0) {\n    flag = flag + 0xf0000000;\n  }\n  bit_count = LZCOUNT(result1);\n  shift_amount = bit_count - 8;\n  offset = (flag - 0x800000) + shift_amount * -0x800000;\n  if (bit_count < 8) {\n    shift_amount = result1 << bit_count + 0x18;\n    flag = offset + ((result1 >> (0x20 - (bit_count + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((result2 | shift_amount << 1) == 0) {\n      flag = flag & ~(shift_amount >> 0x1f);\n    }\n    return flag;\n  }\n  bit_count = result2 << (shift_amount & 0xff);\n  flag = offset + (result1 << (shift_amount & 0xff)) +\n          (result2 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < bit_count);\n  if (bit_count == 0x80000000) {\n    flag = flag & 0xfffffffe;\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_08000c70": "calculate_result_08000c70",
                "param_1": "input_number1",
                "param_2": "input_number2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "bit_count",
                "uVar4": "shift_amount",
                "uVar5": "flag",
                "iVar6": "offset",
                "bVar7": "is_nonzero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cec": {
            "entrypoint": "0x08000cec",
            "current_name": "calculate_floating_point_08000cec",
            "code": "\nuint calculateFloatingPoint_08000cec(uint input1,uint input2,undefined4 param3,uint param4)\n\n{\n  longlong product;\n  uint result;\n  uint shifted1;\n  int shiftSum;\n  int shiftDiff;\n  uint shiftedProduct;\n  int shift;\n  uint combined;\n  bool isZero;\n  bool shiftCarry;\n  \n  shifted1 = input1 >> 0x17 & 0xff;\n  isZero = shifted1 == 0;\n  if (!isZero) {\n    param4 = input2 >> 0x17 & 0xff;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = shifted1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = param4 == 0xff;\n  }\n  if (isZero) {\n    param4 = input2 >> 0x17 & 0xff;\n    if (shifted1 == 0xff || param4 == 0xff) {\n      isZero = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZero = input2 == 0;\n        result = input1;\n      }\n      if (!isZero) {\n        isZero = input2 == 0x80000000;\n      }\n      combined = result;\n      if (((isZero) || ((shifted1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param4 == 0xff && (combined = input2, (input2 & 0x7fffff) != 0)))) {\n        return combined | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e3c;\n    }\n    isZero = (input1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZero = shifted1 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input1 = input1 << 1;\n        isZero = (input1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      shifted1 = shifted1 - 1;\n    }\n    input1 = input1 | result;\n    isZero = param4 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input2 = input2 << 1;\n        isZero = (input2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      param4 = param4 - 1;\n    }\n    input2 = input2 | result;\n  }\n  shiftSum = shifted1 + param4;\n  combined = input1 ^ input2;\n  shifted1 = input1 << 9;\n  isZero = shifted1 == 0;\n  if (!isZero) {\n    input2 = input2 << 9;\n    isZero = input2 == 0;\n  }\n  if (isZero) {\n    if (shifted1 == 0) {\n      input2 = input2 << 9;\n    }\n    result = combined & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    shiftCarry = SBORROW4(shiftSum,0x7f);\n    shiftDiff = shiftSum + -0x7f;\n    isZero = shiftDiff == 0;\n    shift = shiftDiff;\n    if (!isZero && 0x7e < shiftSum) {\n      shiftCarry = SBORROW4(0xff,shiftDiff);\n      shift = 0xff - shiftDiff;\n      isZero = shiftDiff == 0xff;\n    }\n    if (!isZero && shift < 0 == shiftCarry) {\n      result = result | shiftDiff * 0x800000;\n    }\n    if (!isZero && shift < 0 == shiftCarry) {\n      return result;\n    }\n    result = result | 0x800000;\n    shiftedProduct = 0;\n    shiftCarry = SBORROW4(shiftDiff,1);\n    combined = shiftSum - 0x80;\n    isZero = combined == 0;\n    shifted1 = combined;\n  }\n  else {\n    product = (ulonglong)(shifted1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    shiftedProduct = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | shiftedProduct >> 0x1f;\n      shiftedProduct = shiftedProduct << 1;\n    }\n    result = combined & 0x80000000 | result;\n    combined = (shiftSum + -0x7f) - (uint)isZero;\n    shiftCarry = SBORROW4(combined,0xfd);\n    isZero = combined == 0xfd;\n    shifted1 = combined - 0xfd;\n    if (combined < 0xfe) {\n      result = result + combined * 0x800000 + (uint)(0x7fffffff < shiftedProduct);\n      if (shiftedProduct == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)shifted1 < 0 != shiftCarry) {\n    isZero = (int)(combined + 0x19) < 0;\n    if (combined == 0xffffffe7 || isZero != SCARRY4(combined,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (combined != 0xffffffe7 && isZero == SCARRY4(combined,0x19)) {\n      shifted1 = (result << 1) >> (-combined & 0xff);\n      combined = result << (combined + 0x20 & 0xff);\n      shifted1 = ((uint)((result & 0x80000000) != 0) << 0x1f | shifted1 >> 1) + (uint)((byte)shifted1 & 1);\n      if ((shiftedProduct | combined << 1) == 0) {\n        shifted1 = shifted1 & ~(combined >> 0x1f);\n      }\n      return shifted1;\n    }\n    return result;\n  }\nLAB_08000e3c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cec": "calculate_floating_point_08000cec",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "shifted1",
                "iVar4": "shiftSum",
                "iVar5": "shiftDiff",
                "uVar6": "shiftedProduct",
                "iVar7": "shift",
                "uVar8": "combined",
                "bVar9": "isZero",
                "bVar10": "shiftCarry"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "AK8963_Init",
                "AHRS_ComputeAngles",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e54": {
            "entrypoint": "0x08000e54",
            "current_name": "floating_point_operation_08000e54",
            "code": "\nuint floatingPointOperation_08000e54(uint input1,uint input2,undefined4 ignored,uint ignored)\n\n{\n  uint normalizedInput2;\n  uint normalizedInput1;\n  int difference;\n  uint overflowCheck1;\n  int overflowCheck2;\n  uint result;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  normalizedInput1 = input1 >> 0x17 & 0xff;\n  condition1 = normalizedInput1 == 0;\n  if (!condition1) {\n    ignored = input2 >> 0x17 & 0xff;\n    condition1 = ignored == 0;\n  }\n  if (!condition1) {\n    condition1 = normalizedInput1 == 0xff;\n  }\n  if (!condition1) {\n    condition1 = ignored == 0xff;\n  }\n  if (condition1) {\n    ignored = input2 >> 0x17 & 0xff;\n    result = input1;\n    if (normalizedInput1 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (result = input2, ignored == 0xff)) {\nLAB_08000e4a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (ignored == 0xff) {\n        result = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      condition1 = (input1 & 0x7fffffff) == 0;\n      if (!condition1) {\n        condition1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!condition1) {\n        condition1 = normalizedInput1 == 0;\n        result = input1 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input1 = input1 << 1;\n            condition1 = (input1 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          normalizedInput1 = normalizedInput1 - 1;\n        }\n        input1 = input1 | result;\n        condition1 = ignored == 0;\n        result = input2 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input2 = input2 << 1;\n            condition1 = (input2 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          ignored = ignored - 1;\n        }\n        input2 = input2 | result;\n        goto LAB_08000e6c;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e6c:\n    difference = normalizedInput1 - ignored;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      condition3 = SCARRY4(difference,0x7f);\n      overflowCheck2 = difference + 0x7f;\n      condition1 = overflowCheck2 < 0;\n      condition2 = overflowCheck2 == 0;\n      if (!condition2 && condition1 == condition3) {\n        condition3 = SBORROW4(0xff,overflowCheck2);\n        condition1 = 0xff - overflowCheck2 < 0;\n        condition2 = overflowCheck2 == 0xff;\n      }\n      if (!condition2 && condition1 == condition3) {\n        input1 = input1 | overflowCheck2 * 0x800000;\n      }\n      if (!condition2 && condition1 == condition3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      normalizedInput1 = 0;\n      condition2 = SBORROW4(overflowCheck2,1);\n      overflowCheck1 = difference + 0x7e;\n      condition1 = overflowCheck1 == 0;\n      result = overflowCheck1;\n    }\n    else {\n      normalizedInput2 = (input2 << 9) >> 4 | 0x10000000;\n      normalizedInput1 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      condition1 = normalizedInput2 <= normalizedInput1;\n      if (!condition1) {\n        normalizedInput1 = normalizedInput1 << 1;\n      }\n      overflowCheck1 = difference + 0x7d + (uint)condition1;\n      result = 0x800000;\n      do {\n        if (normalizedInput2 <= normalizedInput1) {\n          normalizedInput1 = normalizedInput1 - normalizedInput2;\n          input1 = input1 | result;\n        }\n        condition1 = normalizedInput2 >> 1 <= normalizedInput1;\n        if (condition1) {\n          normalizedInput1 = normalizedInput1 - (normalizedInput2 >> 1);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 1;\n        }\n        condition1 = normalizedInput2 >> 2 <= normalizedInput1;\n        if (condition1) {\n          normalizedInput1 = normalizedInput1 - (normalizedInput2 >> 2);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 2;\n        }\n        condition1 = normalizedInput2 >> 3 <= normalizedInput1;\n        if (condition1) {\n          normalizedInput1 = normalizedInput1 - (normalizedInput2 >> 3);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 3;\n        }\n        normalizedInput1 = normalizedInput1 * 0x10;\n        condition1 = normalizedInput1 == 0;\n        if (!condition1) {\n          result = result >> 4;\n          condition1 = result == 0;\n        }\n      } while (!condition1);\n      condition2 = SBORROW4(overflowCheck1,0xfd);\n      condition1 = overflowCheck1 == 0xfd;\n      result = overflowCheck1 - 0xfd;\n      if (overflowCheck1 < 0xfe) {\n        input1 = input1 + overflowCheck1 * 0x800000 + (uint)(normalizedInput2 <= normalizedInput1);\n        if (normalizedInput1 - normalizedInput2 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (condition1 || (int)result < 0 != condition2) {\n      condition1 = (int)(overflowCheck1 + 0x19) < 0;\n      if (overflowCheck1 == 0xffffffe7 || condition1 != SCARRY4(overflowCheck1,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (overflowCheck1 == 0xffffffe7 || condition1 != SCARRY4(overflowCheck1,0x19)) {\n        return input1;\n      }\n      result = (input1 << 1) >> (-overflowCheck1 & 0xff);\n      overflowCheck1 = input1 << (overflowCheck1 + 0x20 & 0xff);\n      result = ((uint)((input1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((normalizedInput1 | overflowCheck1 << 1) == 0) {\n        result = result & ~(overflowCheck1 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e54": "floating_point_operation_08000e54",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "ignored",
                "param_4": "ignored",
                "uVar1": "normalizedInput2",
                "uVar2": "normalizedInput1",
                "iVar3": "difference",
                "uVar4": "overflowCheck1",
                "iVar5": "overflowCheck2",
                "uVar6": "result",
                "bVar7": "condition1",
                "bVar8": "condition2",
                "bVar9": "condition3"
            },
            "calling": [
                "PID_Compute",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "calculate_carry_08000f8c",
            "code": "\nuint calculate_carry_08000f8c(uint number1,uint number2)\n\n{\n  bool is_overflow;\n  uint number1_doubled;\n  uint number2_doubled;\n  uint result;\n  bool is_zero;\n  \n  number1_doubled = number1 * 2;\n  number2_doubled = number2 * 2;\n  if (((int)number1_doubled >> 0x18 == -1 || (int)number2_doubled >> 0x18 == -1) &&\n     ((((int)number1_doubled >> 0x18 == -1 && ((number1 & 0x7fffff) != 0)) ||\n      (((int)number2_doubled >> 0x18 == -1 && ((number2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  result = number1_doubled | number2 & 0x7fffffff;\n  is_zero = result == 0;\n  if (!is_zero) {\n    result = number1 ^ number2;\n    is_zero = result == 0;\n  }\n  is_overflow = -1 < (int)result;\n  if (is_overflow) {\n    number1 = number1_doubled + number2 * -2;\n    is_zero = number1 == 0;\n  }\n  if ((is_overflow && number2_doubled <= number1_doubled) && !is_zero) {\n    number1 = (int)number2 >> 0x1f;\n  }\n  if (!is_overflow || number2_doubled > number1_doubled) {\n    number1 = ~((int)number2 >> 0x1f);\n  }\n  if (!is_zero) {\n    number1 = number1 | 1;\n  }\n  return number1;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "calculate_carry_08000f8c",
                "param_1": "number1",
                "param_2": "number2",
                "uVar2": "number1_doubled",
                "uVar3": "number2_doubled",
                "uVar4": "result",
                "bVar1": "is_overflow",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f94": {
            "entrypoint": "0x08000f94",
            "current_name": "calculate_result_08000f94",
            "code": "\nuint calculate_result_08000f94(uint input1,uint input2)\n\n{\n  bool isNegative;\n  uint input1Times2;\n  uint input2Times2;\n  uint combinedResult;\n  bool isZero;\n  \n  input1Times2 = input1 * 2;\n  input2Times2 = input2 * 2;\n  if (((int)input1Times2 >> 0x18 == -1 || (int)input2Times2 >> 0x18 == -1) &&\n     ((((int)input1Times2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2Times2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combinedResult = input1Times2 | input2 & 0x7fffffff;\n  isZero = combinedResult == 0;\n  if (!isZero) {\n    combinedResult = input1 ^ input2;\n    isZero = combinedResult == 0;\n  }\n  isNegative = -1 < (int)combinedResult;\n  if (isNegative) {\n    input1 = input1Times2 + input2 * -2;\n    isZero = input1 == 0;\n  }\n  if ((isNegative && input2Times2 <= input1Times2) && !isZero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!isNegative || input2Times2 > input1Times2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!isZero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_08000f94": "calculate_result_08000f94",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "isNegative",
                "uVar2": "input1Times2",
                "uVar3": "input2Times2",
                "uVar4": "combinedResult",
                "bVar5": "isZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f9c": {
            "entrypoint": "0x08000f9c",
            "current_name": "check_overflow_and_comparison_08000f9c",
            "code": "\nuint check_overflow_and_comparison_08000f9c(uint input1,uint input2)\n\n{\n  bool is_negative_result;\n  uint input1_times_2;\n  uint input2_times_2;\n  uint combined_input_masked;\n  bool is_zero_result;\n  \n  input1_times_2 = input1 * 2;\n  input2_times_2 = input2 * 2;\n  if (((int)input1_times_2 >> 0x18 == -1 || (int)input2_times_2 >> 0x18 == -1) &&\n     ((((int)input1_times_2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2_times_2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_input_masked = input1_times_2 | input2 & 0x7fffffff;\n  is_zero_result = combined_input_masked == 0;\n  if (!is_zero_result) {\n    combined_input_masked = input1 ^ input2;\n    is_zero_result = combined_input_masked == 0;\n  }\n  is_negative_result = -1 < (int)combined_input_masked;\n  if (is_negative_result) {\n    input1 = input1_times_2 + input2 * -2;\n    is_zero_result = input1 == 0;\n  }\n  if ((is_negative_result && input2_times_2 <= input1_times_2) && !is_zero_result) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!is_negative_result || input2_times_2 > input1_times_2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!is_zero_result) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_08000f9c": "check_overflow_and_comparison_08000f9c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "input1_times_2",
                "uVar3": "input2_times_2",
                "uVar4": "combined_input_masked",
                "bVar1": "is_negative_result",
                "bVar5": "is_zero_result"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ffc": {
            "entrypoint": "0x08000ffc",
            "current_name": "compare_floats_08000ffc",
            "code": "\nvoid compareFloats_08000ffc(undefined4 firstFloat,undefined4 secondFloat)\n\n{\n  __aeabi_cfcmpeq(secondFloat,firstFloat);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ffc": "compare_floats_08000ffc",
                "param_1": "firstFloat",
                "param_2": "secondFloat"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001004": {
            "entrypoint": "0x08001004",
            "current_name": "concatenate_params_08001004",
            "code": "\nundefined8 concatenateParams_08001004(undefined4 firstParam,undefined4 secondParam)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParam,firstParam);\n}\n\n",
            "renaming": {
                "FUN_08001004": "concatenate_params_08001004",
                "param_1": "firstParam",
                "param_2": "secondParam"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001014": {
            "entrypoint": "0x08001014",
            "current_name": "check_comparison_08001014",
            "code": "\nbool checkComparison_08001014(void)\n\n{\n  char comparisonResult;\n  \n  __aeabi_cfcmpeq();\n  return comparisonResult != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001014": "check_comparison_08001014",
                "in_ZR": "comparisonResult"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001028": {
            "entrypoint": "0x08001028",
            "current_name": "check_for_null_character_08001028",
            "code": "\nbool check_for_null_character_08001028(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001028": "check_for_null_character_08001028",
                "in_CY": "input_character"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800103c": {
            "entrypoint": "0x0800103c",
            "current_name": "compare_floats_0800103c",
            "code": "\nbool compareFloats_0800103c(void)\n\n{\n  undefined isZero;\n  undefined carry;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)carry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_0800103c": "compare_floats_0800103c",
                "in_CY": "carry",
                "in_ZR": "isZero"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001050": {
            "entrypoint": "0x08001050",
            "current_name": "check_float_comparison_08001050",
            "code": "\nbool checkFloatComparison_08001050(void)\n\n{\n  undefined isZeroResult;\n  undefined carryFlag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carryFlag || (bool)isZeroResult;\n}\n\n",
            "renaming": {
                "FUN_08001050": "check_float_comparison_08001050",
                "in_ZR": "isZeroResult",
                "in_CY": "carryFlag"
            },
            "calling": [
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001064": {
            "entrypoint": "0x08001064",
            "current_name": "is_null_termination_08001064",
            "code": "\nbool is_null_termination_08001064(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001064": "is_null_termination_08001064",
                "in_CY": "input_character"
            },
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001078": {
            "entrypoint": "0x08001078",
            "current_name": "convert_to_signed_int_08001078",
            "code": "\nuint convertToSignedInt_08001078(uint value)\n\n{\n  uint shiftedValue;\n  uint difference;\n  \n  if (value << 1 < 0x7f000000) {\n    return 0;\n  }\n  shiftedValue = (value << 1) >> 0x18;\n  difference = 0x9e - shiftedValue;\n  if (shiftedValue < 0x9f && difference != 0) {\n    shiftedValue = (value << 8 | 0x80000000) >> (difference & 0xff);\n    if ((value & 0x80000000) != 0) {\n      shiftedValue = -shiftedValue;\n    }\n    return shiftedValue;\n  }\n  if ((difference == 0xffffff9f) && ((value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  value = value & 0x80000000;\n  if (value == 0) {\n    value = 0x7fffffff;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_08001078": "convert_to_signed_int_08001078",
                "param_1": "value",
                "uVar1": "shiftedValue",
                "uVar2": "difference"
            },
            "calling": [
                "Motor_DistributeSpeed",
                "AHRS_ComputeAngles",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080010c4": {
            "entrypoint": "0x080010c4",
            "current_name": "check_param1_080010c4",
            "code": "\nuint check_param1_080010c4(uint input_value)\n\n{\n  uint shift_amount;\n  \n  if (((input_value & 0x80000000) != 0) || (input_value << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((input_value << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (input_value << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080010c4": "check_param1_080010c4",
                "param_1": "input_value",
                "uVar1": "shift_amount"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001104": {
            "entrypoint": "0x08001104",
            "current_name": "configure_sys_tick_08001104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSysTick_08001104(uint32_t priority)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001104": "configure_sys_tick_08001104",
                "TickPriority": "priority",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001128": {
            "entrypoint": "0x08001128",
            "current_name": "initialize_hal_08001128",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeHAL_08001128(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initializeTick(0);\n  initializeMsp();\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08001128": "initialize_hal_08001128",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMsp",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800114c": {
            "entrypoint": "0x0800114c",
            "current_name": "increment_tick_count_0800114c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTickCount_0800114c(void)\n\n{\n  tickCounter = tickCounter + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800114c": "increment_tick_count_0800114c",
                "uwTick": "tickCounter"
            },
            "calling": [
                "SysTick_Handler",
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800115c": {
            "entrypoint": "0x0800115c",
            "current_name": "get_system_tick_0800115c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_0800115c(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_0800115c": "get_system_tick_0800115c",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Read",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "millis",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001168": {
            "entrypoint": "0x08001168",
            "current_name": "FUNC_08001168",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001168": "FUNC_08001168"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "configure_priority_group_08001170",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08001170(uint32_t priority)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | 0x5fa0000 | (priority & 7) << 8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001170": "configure_priority_group_08001170",
                "PriorityGroup": "priority"
            },
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001194": {
            "entrypoint": "0x08001194",
            "current_name": "configure_interrupt_priority_08001194",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterruptPriority_08001194(interruptNumber IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint interruptValue;\n  undefined priorityValue;\n  uint32_t preemptPriorityBits;\n  uint tempValue;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint subPriorityValue;\n  \n  interruptValue = (uint)IRQn;\n  subPriorityBits = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - subPriorityBits;\n  subPriorityValue = subPriorityBits + 4;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (subPriorityValue < 7) {\n    subPriorityBits = 0;\n  }\n  tempValue = (1 << (preemptPriorityBits & 0xff)) - 1;\n  if (6 < subPriorityValue) {\n    subPriorityBits = subPriorityBits - 3;\n  }\n  priorityValue = (undefined)\n          ((subPriority & (1 << (subPriorityBits & 0xff)) - 1U |\n           (preemptPriority & tempValue) << (subPriorityBits & 0xff)) << 4);\n  if (-1 < (int)interruptValue) {\n    subPriorityValue = interruptValue + 0xe000e100;\n  }\n  else {\n    tempValue = 0xe000ed14;\n    subPriorityValue = interruptValue & 0xf;\n  }\n  if (-1 < (int)interruptValue) {\n    *(undefined *)(subPriorityValue + 0x300) = priorityValue;\n  }\n  else {\n    *(undefined *)(tempValue + subPriorityValue) = priorityValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001194": "configure_interrupt_priority_08001194",
                "IRQn_Type": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PreemptPriorityBits": "preemptPriorityBits",
                "SubPriorityBits": "subPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp",
                "uVar1": "interruptValue",
                "uVar2": "priorityValue",
                "uVar3": "tempValue",
                "uVar4": "subPriorityValue"
            },
            "calling": [
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011fc": {
            "entrypoint": "0x080011fc",
            "current_name": "set_interrupt_mask_080011fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptMask_080011fc(interruptNumber_Type interruptNumber)\n\n{\n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011fc": "set_interrupt_mask_080011fc",
                "IRQn": "interruptNumber"
            },
            "calling": [
                "HAL_UART_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001214": {
            "entrypoint": "0x08001214",
            "current_name": "initialize_timer_08001214",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTimer_08001214(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001214": "initialize_timer_08001214",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001240": {
            "entrypoint": "0x08001240",
            "current_name": "set_clock_source_08001240",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08001240(uint32_t source)\n\n{\n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001240": "set_clock_source_08001240",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001258": {
            "entrypoint": "0x08001258",
            "current_name": "FUNC_08001258",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001258(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001258": "FUNC_08001258"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800125a": {
            "entrypoint": "0x0800125a",
            "current_name": "handle_sys_tick_interrupt_0800125a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_0800125a(void)\n\n{\n  processSysTickEvent();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800125a": "handle_sys_tick_interrupt_0800125a",
                "HAL_SYSTICK_Callback": "processSysTickEvent"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001264": {
            "entrypoint": "0x08001264",
            "current_name": "configure_gpio_08001264",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08001264(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  uint32_t *configRegister;\n  uint32_t speedBitMask;\n  uint pinBitMask;\n  uint modeValue;\n  int portIndex;\n  uint pinIndex;\n  uint pinMask;\n  uint pullValue;\n  GPIO_TypeDef *gpioRegister;\n  int shiftValue;\n  uint32_t tempRegister;\n  \n  speedBitMask = 0;\n  pinIndex = 0;\n  do {\n    pinMask = 1 << (pinIndex & 0xff);\n    pinBitMask = pinMask & gpioConfig->Pin;\n    if (pinMask == pinBitMask) {\n      modeValue = gpioConfig->Mode;\n      if (modeValue == 0x12) {\n        speedBitMask = gpioConfig->Speed + 0xc;\n      }\n      else if (modeValue < 0x13) {\n        if (modeValue == 2) {\n          speedBitMask = gpioConfig->Speed + 8;\n        }\n        else if (modeValue < 3) {\n          if (modeValue == 0) goto LAB_080013be;\n          if (modeValue == 1) {\n            speedBitMask = gpioConfig->Speed;\n          }\n        }\n        else if (modeValue == 3) {\n          speedBitMask = 0;\n        }\n        else if (modeValue == 0x11) {\n          speedBitMask = gpioConfig->Speed + 4;\n        }\n      }\n      else {\n        if (modeValue != 0x10210000) {\n          if (modeValue < 0x10210001) {\n            if (modeValue != 0x10110000) {\n              pullValue = 0x10120000;\nLAB_080013b8:\n              if (modeValue != pullValue) goto LAB_080012a8;\n            }\n          }\n          else if ((modeValue != 0x10310000) && (modeValue != 0x10320000)) {\n            pullValue = 0x10220000;\n            goto LAB_080013b8;\n          }\n        }\nLAB_080013be:\n        speedBitMask = gpioConfig->Pull;\n        if (speedBitMask == 0) {\n          speedBitMask = 4;\n        }\n        else {\n          if (speedBitMask == 1) {\n            gpioPort->BSRR = pinMask;\n          }\n          if (speedBitMask != 1) {\n            gpioPort->BRR = pinMask;\n          }\n          speedBitMask = 8;\n        }\n      }\nLAB_080012a8:\n      if (pinBitMask < 0x100) {\n        pinMask = gpioPort->CRL;\n        modeValue = pinIndex << 2;\n        gpioRegister = gpioPort;\n      }\n      else {\n        pinMask = gpioPort->CRH;\n        modeValue = (pinIndex + 0x3ffffff8) * 4;\n      }\n      if (0xff < pinBitMask) {\n        gpioRegister = (GPIO_TypeDef *)&gpioPort->CRH;\n      }\n      gpioRegister->CRL = pinMask & ~(0xf << (modeValue & 0xff)) | speedBitMask << (modeValue & 0xff);\n      gpioRegister = (GPIO_TypeDef *)gpioConfig->Mode;\n      if (((uint)gpioRegister & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shiftValue = (pinIndex & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          portIndex = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          portIndex = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          portIndex = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          portIndex = 3;\n        }\n        else {\n          portIndex = 4;\n        }\n        *(uint *)((pinIndex & 0xfffffffc) + 0x40010008) =\n             portIndex << shiftValue | *(uint *)((pinIndex & 0xfffffffc) + 0x40010008) & ~(0xf << shiftValue);\n        if (((uint)gpioRegister & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinBitMask;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinBitMask;\n        }\n        if (((uint)gpioRegister & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinBitMask;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinBitMask;\n        }\n        if (((uint)gpioRegister & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinBitMask;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinBitMask;\n        }\n        if (((uint)gpioRegister & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinBitMask;\n        }\n        else {\n          _DAT_4001040c = pinBitMask | _DAT_4001040c;\n        }\n      }\n    }\n    pinIndex = pinIndex + 1;\n    if (pinIndex == 0x10) {\n      return;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001264": "configure_gpio_08001264",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "configregister": "configRegister",
                "uVar1": "speedBitMask",
                "uVar2": "pinBitMask",
                "uVar3": "modeValue",
                "iVar4": "portIndex",
                "uVar5": "pinIndex",
                "uVar6": "pinMask",
                "uVar7": "pullValue",
                "unaff_r10": "gpioRegister",
                "iVar8": "shiftValue",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_I2C_MspInit",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001424": {
            "entrypoint": "0x08001424",
            "current_name": "set_pin_state_08001424",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001424(GPIO_TypeDef *gpioPort,uint16_t pinNumber,pinNumberState newPinState)\n\n{\n  uint32_t combinedValue;\n  \n  combinedValue = (uint32_t)pinNumber;\n  if (newPinState == GPIO_PIN_RESET) {\n    combinedValue = combinedValue << 0x10;\n  }\n  gpioPort->BSRR = combinedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001424": "set_pin_state_08001424",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "newPinState",
                "uVar1": "combinedValue"
            },
            "calling": [
                "Peripherals_Init",
                "toggleLED",
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800142e": {
            "entrypoint": "0x0800142e",
            "current_name": "toggle_gpio_pin_state_0800142e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid toggleGPIO_PinState_0800142e(GPIO_TypeDef *gpioPort,uint16_t pinNumber)\n\n{\n  gpioPort->ODR = (uint)pinNumber ^ gpioPort->ODR;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800142e": "toggle_gpio_pin_state_0800142e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001436": {
            "entrypoint": "0x08001436",
            "current_name": "check_and_reset_i2_c_error_08001436",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatusTypeDef checkAndResetI2CError_08001436(I2C_HandleTypeDef *i2cHandler)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  i2cInstance = i2cHandler->Instance;\n  if ((i2cInstance->statusRegister1 & 0x400) != 0) {\n    i2cInstance->statusRegister1 = i2cInstance->statusRegister1 & 0xfffffbff;\n    i2cHandler->error = 4;\n    i2cHandler->currentState = READY_STATE;\n    i2cHandler->lockStatus = UNLOCKED;\n    return ERROR;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08001436": "check_and_reset_i2_c_error_08001436",
                "hi2c": "i2cHandler",
                "pIVar1": "i2cInstance",
                "SR1": "statusRegister1",
                "ErrorCode": "error",
                "State": "currentState",
                "Lock": "lockStatus",
                "HAL_StatusTypeDef": "StatusTypeDef",
                "HAL_I2C_STATE_READY": "READY_STATE",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "check_i2_c_bus_status_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CBusStatus_08001460(I2C_HandleTypeDef *i2cHandle,uint32_t statusFlag,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t endTime;\n  uint statusRegValue;\n  I2C_TypeDef *i2cInstance;\n  \n  startTime = HAL_GetTick();\n  do {\n    i2cInstance = i2cHandle->Instance;\n    if ((statusFlag << 8) >> 0x18 == 1) {\n      statusRegValue = i2cInstance->SR1;\n    }\n    else {\n      statusRegValue = i2cInstance->SR2;\n    }\n    if ((statusFlag & 0xffff & ~statusRegValue) == 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x15) < 0) {\n      i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n      i2cInstance->SR1 = i2cInstance->SR1 & 0xfffffbff;\n      i2cHandle->ErrorCode = 4;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (endTime = HAL_GetTick(), endTime - startTime <= timeout))));\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001460": "check_i2_c_bus_status_08001460",
                "hi2c": "i2cHandle",
                "Flag": "statusFlag",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "endTime",
                "uVar3": "statusRegValue",
                "pIVar4": "i2cInstance"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014e2": {
            "entrypoint": "0x080014e2",
            "current_name": "wait_for_i2_c_response_080014e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CResponse_080014e2(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t tickStart;\n  \n  startTime = HAL_GetTick();\n  while( true ) {\n    if ((int)(i2cHandle->Instance->SR1 << 0x18) < 0) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080014e2": "wait_for_i2_c_response_080014e2",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "tickstart": "tickStart"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001530": {
            "entrypoint": "0x08001530",
            "current_name": "write_data_to_i2_c_device_08001530",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nwriteDataToI2CDevice_08001530(I2C_HandleTypeDef *i2cDevice,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  i2cDevice->Instance->CR1 = i2cDevice->Instance->CR1 | 0x100;\n  startTick = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cDevice->Instance->SR1 << 0x1f) < 0) {\n        i2cDevice->Instance->DR = deviceAddress & 0xfe;\n        status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cDevice,0x10002,timeout);\n        if (status == HAL_OK) {\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cDevice,timeout);\n          if (status == HAL_OK) {\n            i2cInstance = i2cDevice->Instance;\n            if (memoryAddressSize == 1) {\nLAB_080015ca:\n              i2cInstance->DR = (uint)(byte)memoryAddress;\n              return HAL_OK;\n            }\n            i2cInstance->DR = (uint)(memoryAddress >> 8);\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cDevice,timeout);\n            if (status == HAL_OK) {\n              i2cInstance = i2cDevice->Instance;\n              goto LAB_080015ca;\n            }\n          }\n          if (i2cDevice->ErrorCode != 4) {\n            return HAL_TIMEOUT;\n          }\n          i2cDevice->Instance->CR1 = i2cDevice->Instance->CR1 | 0x200;\n        }\n        else if (i2cDevice->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        return HAL_ERROR;\n      }\n    } while (timeout == 0xffffffff);\n    if ((timeout == 0) || (currentTick = HAL_GetTick(), timeout < currentTick - startTick)) {\n      i2cDevice->State = HAL_I2C_STATE_READY;\n      i2cDevice->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001530": "write_data_to_i2_c_device_08001530",
                "hi2c": "i2cDevice",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "pIVar4": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015e8": {
            "entrypoint": "0x080015e8",
            "current_name": "transmit_data_080015e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_080015e8(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  i2cInstance = i2cHandle->Instance;\n  i2cInstance->CR1 = i2cInstance->CR1 | 0x400;\n  i2cInstance->CR1 = i2cInstance->CR1 | 0x100;\n  startTime = HAL_GetTick();\nLAB_0800160e:\n  while (-1 < (int)(i2cHandle->Instance->SR1 << 0x1f)) {\n    if (timeout != 0xffffffff) goto code_r0x08001658;\n  }\n  i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n  status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n  if (status != HAL_OK) goto LAB_080016ba;\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cInstance = i2cHandle->Instance;\n    if (memoryAddressSize != 1) {\n      i2cInstance->DR = (uint)(memoryAddress >> 8);\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001642;\n      i2cInstance = i2cHandle->Instance;\n    }\n    i2cInstance->DR = (uint)(byte)memoryAddress;\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      startTime = HAL_GetTick();\n      do {\n        do {\n          if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n            i2cHandle->Instance->DR = (byte)deviceAddress | 1;\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n            if (status == HAL_OK) {\n              return HAL_OK;\n            }\nLAB_080016ba:\n            if (i2cHandle->ErrorCode != 4) {\n              return HAL_TIMEOUT;\n            }\n            return HAL_ERROR;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout));\nLAB_0800165a:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001642:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\ncode_r0x08001658:\n  if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) goto LAB_0800165a;\n  goto LAB_0800160e;\n}\n\n",
            "renaming": {
                "FUN_080015e8": "transmit_data_080015e8",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016f4": {
            "entrypoint": "0x080016f4",
            "current_name": "wait_for_i2_c_flag_080016f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CFlag_080016f4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  \n  startTime = HAL_GetTick();\n  while( true ) {\n    i2cInstance = i2cHandle->Instance;\n    if ((i2cInstance->SR1 & 0x40) != 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x1b) < 0) break;\n    if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cInstance->SR1 = i2cInstance->SR1 & 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080016f4": "wait_for_i2_c_flag_080016f4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001754": {
            "entrypoint": "0x08001754",
            "current_name": "initialize_i2_c_08001754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus initializeI2C_08001754(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint32_t pclk1Freq;\n  uint extraOutR1;\n  uint speedFactor;\n  I2C_TypeDef *i2cInstance;\n  uint clockSpeed;\n  uint prescaler;\n  \n  if (i2cHandler != (I2C_HandleTypeDef *)0x0) {\n    if (i2cHandler->State == HAL_I2C_STATE_RESET) {\n      i2cHandler->Lock = HAL_UNLOCKED;\n      i2cMspInit(i2cHandler);\n    }\n    i2cHandler->State = HAL_I2C_STATE_BUSY;\n    i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = getAPB1Clock();\n    clockSpeed = (i2cHandler->Init).ClockSpeed;\n    prescaler = pclk1Freq / 1000000;\n    speedFactor = extraOutR1;\n    if (100000 < clockSpeed) {\n      speedFactor = 300;\n    }\n    i2cInstance = i2cHandler->Instance;\n    if (100000 < clockSpeed) {\n      speedFactor = prescaler * speedFactor;\n    }\n    i2cInstance->CR2 = prescaler;\n    if (100000 < clockSpeed) {\n      prescaler = speedFactor / 1000;\n    }\n    i2cInstance->TRISE = prescaler + 1;\n    if (clockSpeed < 0x186a1) {\n      pclk1Freq = pclk1Freq / (clockSpeed << 1);\n      if ((pclk1Freq & 0xfff) < 4) {\n        pclk1Freq = 4;\n      }\n    }\n    else {\n      if ((i2cHandler->Init).DutyCycle == 0) {\n        pclk1Freq = pclk1Freq / (clockSpeed * 3) | 0x8000;\n      }\n      else {\n        pclk1Freq = pclk1Freq / (clockSpeed * 0x19) | 0xc000;\n      }\n      if ((pclk1Freq & 0xfff) == 0) {\n        pclk1Freq = 1;\n      }\n    }\n    prescaler = (i2cHandler->Init).NoStretchMode;\n    speedFactor = (i2cHandler->Init).GeneralCallMode;\n    i2cInstance->CCR = pclk1Freq;\n    i2cInstance->CR1 = speedFactor | prescaler;\n    i2cInstance->OAR1 = (i2cHandler->Init).AddressingMode | (i2cHandler->Init).OwnAddress1;\n    i2cInstance->OAR2 = (i2cHandler->Init).DualAddressMode | (i2cHandler->Init).OwnAddress2;\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n    i2cHandler->ErrorCode = 0;\n    i2cHandler->State = HAL_I2C_STATE_READY;\n    i2cHandler->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001754": "initialize_i2_c_08001754",
                "hi2c": "i2cHandler",
                "uVar1": "pclk1Freq",
                "extraout_r1": "extraOutR1",
                "uVar2": "speedFactor",
                "pIVar3": "i2cInstance",
                "uVar4": "clockSpeed",
                "uVar5": "prescaler",
                "HAL_StatusTypeDef": "Status",
                "HAL_RCC_GetPCLK1Freq": "getAPB1Clock",
                "HAL_I2C_MspInit": "i2cMspInit"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001828": {
            "entrypoint": "0x08001828",
            "current_name": "write_memory_data_08001828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nwriteMemoryData_08001828(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint tempVar;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      return HAL_ERROR;\n    }\n    if (dataSize == 0) {\n      return HAL_ERROR;\n    }\n    startTime = HAL_GetTick();\n    do {\n      i2cInstance = i2cHandle->Instance;\n      if ((~i2cInstance->SR2 & 2) != 0) {\n        if (i2cHandle->Lock == HAL_LOCKED) {\n          return HAL_BUSY;\n        }\n        tempVar = i2cInstance->CR1;\n        i2cHandle->Lock = HAL_LOCKED;\n        i2cInstance->CR1 = tempVar & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n        if (status != HAL_OK) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          if (i2cHandle->ErrorCode == 4) {\n            return HAL_ERROR;\n          }\n          return HAL_TIMEOUT;\n        }\n        goto LAB_080018e2;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 0x2711);\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n  }\n  return HAL_BUSY;\n  while (dataSize != 0) {\nLAB_080018e2:\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status != HAL_OK) goto LAB_080018ee;\n    i2cInstance = i2cHandle->Instance;\n    i2cInstance->DR = (uint)*data;\n    if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n      if ((uint16_t)(dataSize - 1) == 0) break;\n      dataSize = dataSize - 2;\n      i2cInstance->DR = (uint)data[1];\n      data = data + 2;\n    }\n    else {\n      data = data + 1;\n      dataSize = dataSize - 1;\n    }\n  }\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\nLAB_080018ee:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001828": "write_memory_data_08001828",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "uVar5": "tempVar"
            },
            "calling": [
                "I2C_WriteByte"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryWrite",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001938": {
            "entrypoint": "0x08001938",
            "current_name": "read_memory_block_from_i2_c_08001938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nreadMemoryBlockFromI2C_08001938(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  uint8_t *tempVar1;\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint crReg;\n  uint8_t *tempVar2;\n  bool flag;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  uint32_t tempReg3;\n  \n  if (i2cHandle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  startTime = HAL_GetTick();\n  while (i2cInstance = i2cHandle->Instance, (~i2cInstance->SR2 & 2) == 0) {\n    currentTime = HAL_GetTick();\n    if (10000 < currentTime - startTime) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (i2cHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  crReg = i2cInstance->CR1;\n  i2cHandle->Lock = HAL_LOCKED;\n  i2cInstance->CR1 = crReg & 0xfffff7ff;\n  i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n  i2cHandle->Mode = HAL_I2C_MODE_MEM;\n  i2cHandle->ErrorCode = 0;\n  status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n  if (status != HAL_OK) {\n    i2cHandle->Lock = HAL_UNLOCKED;\n    if (i2cHandle->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  i2cInstance = i2cHandle->Instance;\n  crReg = i2cInstance->CR1;\n  if (dataSize == 1) {\n    i2cInstance->CR1 = crReg & 0xfffffbff;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      *dataBuffer = (uint8_t)i2cHandle->Instance->DR;\nLAB_08001ab8:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (i2cHandle->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (dataSize == 2) {\n    i2cInstance->CR1 = crReg | 0x800;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    i2cInstance->CR1 = crReg | 0x400;\n    while (3 < dataSize) {\n      status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001a18;\n      *dataBuffer = (uint8_t)i2cHandle->Instance->DR;\n      i2cInstance = i2cHandle->Instance;\n      flag = (int)(i2cInstance->SR1 << 0x1d) < 0;\n      if (flag) {\n        i2cInstance = (I2C_TypeDef *)i2cInstance->DR;\n        tempVar2 = dataBuffer + 2;\n        dataSize = dataSize - 2;\n      }\n      else {\n        tempVar2 = dataBuffer + 1;\n        dataSize = dataSize - 1;\n      }\n      tempVar1 = dataBuffer + 1;\n      dataBuffer = tempVar2;\n      if (flag) {\n        *tempVar1 = (uint8_t)i2cInstance;\n      }\n    }\n    if (dataSize != 2) {\n      startTime = HAL_GetTick();\n      do {\n        i2cInstance = i2cHandle->Instance;\n        do {\n          if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *dataBuffer = (uint8_t)i2cHandle->Instance->DR;\n            startTime = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout));\n      goto LAB_08001afa;\n    }\n  }\n  startTime = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        i2cInstance = i2cHandle->Instance;\n        i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n        *dataBuffer = (uint8_t)i2cInstance->DR;\n        enableIRQinterrupts();\n        dataBuffer[1] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout));\nLAB_08001afa:\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    i2cInstance = i2cHandle->Instance;\n    do {\n      if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n        dataBuffer[1] = (uint8_t)i2cInstance->DR;\n        enableIRQinterrupts();\n        dataBuffer[2] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout));\n  goto LAB_08001afa;\n}\n\n",
            "renaming": {
                "FUN_08001938": "read_memory_block_from_i2_c_08001938",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "puVar1": "tempVar1",
                "HVar2": "status",
                "uVar3": "startTime",
                "uVar4": "currentTime",
                "pIVar5": "i2cInstance",
                "uVar6": "crReg",
                "puVar7": "tempVar2",
                "bVar8": "flag",
                "tmpreg": "tempReg1",
                "tmpreg_1": "tempReg2",
                "tmpreg_2": "tempReg3"
            },
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b58": {
            "entrypoint": "0x08001b58",
            "current_name": "configure_rcc_oscillators_08001b58",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) configureRCCOscillators_08001b58\n/* WARNING: Removing unreachable block (ram,0x08001ee8) configureRCCOscillators_08001b58\n\n/* WARNING: Unknown calling convention configureRCCOscillators_08001b58\n\nHAL_StatusTypeDef configureRCCOscillators_08001b58(RCC_OscInitTypeDef *oscillatorConfig)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint32_t tmpreg;\n  \n  if ((int)(oscillatorConfig->OscillatorType << 0x1f) < 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((int)(_DAT_40021004 << 0xf) < 0)))) {\n      if (((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) && (oscillatorConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar1 = oscillatorConfig->HSEState;\n      if (uVar1 == 0x10000) {\nLAB_08001c1e:\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else {\n        if (uVar1 == 0) {\n          _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n          uVar1 = HAL_GetTick();\n          while ((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) {\n            uVar2 = HAL_GetTick();\n            if (100 < uVar2 - uVar1) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (uVar1 == 0x50000) {\n          _DAT_40021000 = _DAT_40021000 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      uVar1 = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 0x11) << 0x1f)) {\n        uVar2 = HAL_GetTick();\n        if (100 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  if ((int)(oscillatorConfig->OscillatorType << 0x1e) < 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && (-1 < (int)(_DAT_40021004 << 0xf))))) {\n      if (((int)((_DAT_40021000 >> 1) << 0x1f) < 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      HSIState = oscillatorConfig->HSIState;\n      if (HSIState == 0) {\n        uVar1 = HAL_GetTick();\n        while ((int)((_DAT_40021000 >> 1) << 0x1f) < 0) {\n          uVar2 = HAL_GetTick();\n          if (2 < uVar2 - uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      HSIState = 1;\n      uVar1 = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 1) << 0x1f)) {\n        uVar2 = HAL_GetTick();\n        if (2 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    _DAT_40021000 = oscillatorConfig->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n  }\nLAB_08001b6c:\n  if ((int)(oscillatorConfig->OscillatorType << 0x1c) < 0) {\n    LSIState = oscillatorConfig->LSIState;\n    if (LSIState == 0) {\n      uVar1 = HAL_GetTick();\n      while ((int)((_DAT_40021024 >> 1) << 0x1f) < 0) {\n        uVar2 = HAL_GetTick();\n        if (2 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      LSIState = 1;\n      uVar1 = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021024 >> 1) << 0x1f)) {\n        uVar2 = HAL_GetTick();\n        if (2 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n      HAL_Delay(1);\n    }\n  }\n  if (-1 < (int)(oscillatorConfig->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  _DAT_4002101c = _DAT_4002101c | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0x100;\n  uVar1 = HAL_GetTick();\n  while (-1 < (int)(_DAT_40007000 << 0x17)) {\n    uVar2 = HAL_GetTick();\n    if (100 < uVar2 - uVar1) {\n      return HAL_TIMEOUT;\n    }\n  }\n  uVar1 = oscillatorConfig->LSEState;\n  if (uVar1 == 1) {\nLAB_08001e1a:\n    _DAT_40021020 = _DAT_40021020 | 1;\n  }\n  else {\n    if (uVar1 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n      uVar1 = HAL_GetTick();\n      while ((int)((_DAT_40021020 >> 1) << 0x1f) < 0) {\n        uVar2 = HAL_GetTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (uVar1 == 5) {\n      _DAT_40021020 = _DAT_40021020 | 4;\n      goto LAB_08001e1a;\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n  }\n  uVar1 = HAL_GetTick();\n  while (-1 < (int)((_DAT_40021020 >> 1) << 0x1f)) {\n    uVar2 = HAL_GetTick();\n    if (5000 < uVar2 - uVar1) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  uVar1 = (oscillatorConfig->PLL).PLLState;\n  if (uVar1 == 0) {\n    return HAL_OK;\n  }\n  if ((_DAT_40021004 & 0xc) != 8) {\n    if (uVar1 != 2) {\n      PLLConfigStatus = 0;\n      uVar1 = HAL_GetTick();\n      do {\n        if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n          return HAL_OK;\n        }\n        uVar2 = HAL_GetTick();\n      } while (uVar2 - uVar1 < 3);\n      return HAL_TIMEOUT;\n    }\n    PLLConfigStatus = 0;\n    uVar1 = HAL_GetTick();\n    do {\n      if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n        uVar3 = (oscillatorConfig->PLL).PLLSource;\n        if (uVar3 == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillatorConfig->HSEPredivValue;\n        }\n        _DAT_40021004 = uVar3 | (oscillatorConfig->PLL).PLLMUL | _DAT_40021004 & 0xffc2ffff;\n        PLLConfigStatus = 1;\n        uVar1 = HAL_GetTick();\n        do {\n          if ((int)((_DAT_40021000 >> 0x19) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          uVar2 = HAL_GetTick();\n        } while (uVar2 - uVar1 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar2 = HAL_GetTick();\n    } while (uVar2 - uVar1 < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001b58": "configure_rcc_oscillators_08001b58",
                "RCC_OscInitStruct": "oscillatorConfig",
                "uRam42420000": "HSIState",
                "uRam42420480": "LSIState",
                "uRam42420060": "PLLConfigStatus"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002008": {
            "entrypoint": "0x08002008",
            "current_name": "calculate_clock_frequency_08002008",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08002008(void)\n\n{\n  undefined4 tempValue1;\n  uint32_t clockFrequency;\n  undefined4 tempValue2;\n  undefined4 *ptrPLLMULFactorTable;\n  uint predivFactor;\n  undefined4 *ptrTempPLLMULFactorTable;\n  uint8_t predivFactorTable [2];\n  uint8_t PLLMULFactorTable [16];\n  \n  ptrPLLMULFactorTable = &DAT_080072f0;\n  ptrTempPLLMULFactorTable = (undefined4 *)PLLMULFactorTable;\n  do {\n    tempValue1 = *ptrPLLMULFactorTable;\n    tempValue2 = ptrPLLMULFactorTable[1];\n    ptrPLLMULFactorTable = ptrPLLMULFactorTable + 2;\n    *ptrTempPLLMULFactorTable = tempValue1;\n    ptrTempPLLMULFactorTable[1] = tempValue2;\n    ptrTempPLLMULFactorTable = ptrTempPLLMULFactorTable + 2;\n  } while (ptrPLLMULFactorTable != (undefined4 *)\"../Src/MPU9250.c\");\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((int)(_DAT_40021004 << 0xf) < 0) {\n      predivFactor = 8000000 / predivFactorTable[(_DAT_40021004 & 0x20000) >> 0x11];\n    }\n    else {\n      predivFactor = 4000000;\n    }\n    clockFrequency = predivFactor * PLLMULFactorTable[(_DAT_40021004 & 0x3c0000) >> 0x12];\n  }\n  else {\n    clockFrequency = 8000000;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08002008": "calculate_clock_frequency_08002008",
                "puVar4": "ptrPLLMULFactorTable",
                "puVar6": "ptrTempPLLMULFactorTable",
                "uVar1": "tempValue1",
                "uVar3": "tempValue2",
                "uVar2": "clockFrequency",
                "uVar5": "predivFactor",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "PLLMULFactorTable"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800209c": {
            "entrypoint": "0x0800209c",
            "current_name": "configure_clock_0800209c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureClock_0800209c(RCC_ClkInitTypeDef *clockConfig,uint32_t latency)\n\n{\n  char flag1;\n  char flag2;\n  uint32_t sysClockFreq;\n  uint32_t currentTick;\n  uint sysClockSource;\n  \n  if ((latency <= (_DAT_40022000 & 7)) ||\n     (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | latency, latency == (latency & 7))) {\n    if ((int)(clockConfig->ClockType << 0x1e) < 0) {\n      _DAT_40021004 = _DAT_40021004 & 0xffffff0f | clockConfig->AHBCLKDivider;\n    }\n    if (-1 < (int)(clockConfig->ClockType << 0x1f)) {\nLAB_080020ba:\n      if ((latency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | latency, latency != (latency & 7))) {\n        return HAL_ERROR;\n      }\n      if ((clockConfig->ClockType & 4) != 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | clockConfig->APB1CLKDivider;\n      }\n      if ((int)(clockConfig->ClockType << 0x1c) < 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | clockConfig->APB2CLKDivider << 3;\n      }\n      sysClockFreq = HAL_RCC_GetSysClockFreq();\n      SystemCoreClock = sysClockFreq >> \"\"[(_DAT_40021004 & 0xf0) >> 4];\n      HAL_InitTick(0);\n      return HAL_OK;\n    }\n    sysClockSource = clockConfig->SYSCLKSource;\n    if (sysClockSource == 1) {\n      flag2 = '\\x01';\n      flag1 = '\\0';\n    }\n    else {\n      if (sysClockSource == 2) goto LAB_08002176;\n      flag2 = '\\0';\n      flag1 = '\\x01';\n    }\n    if ((int)((_DAT_40021000 >>\n              (LZCOUNT((uint)(byte)(flag1 << 6) << 0x18 | (uint)(byte)(flag2 << 6) << 8) & 0x1fU))\n             << 0x1f) < 0) {\nLAB_08002176:\n      _DAT_40021004 = _DAT_40021004 & 0xfffffffc | sysClockSource;\n      sysClockFreq = HAL_GetTick();\n      if (clockConfig->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_080020ba;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n      }\n      else if (clockConfig->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_080020ba;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_080020ba;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n      }\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800209c": "configure_clock_0800209c",
                "RCC_ClkInitStruct": "clockConfig",
                "FLatency": "latency",
                "cVar1": "flag1",
                "cVar2": "flag2",
                "uVar3": "sysClockFreq",
                "uVar4": "currentTick",
                "uVar5": "sysClockSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002214": {
            "entrypoint": "0x08002214",
            "current_name": "get_system_core_clock_08002214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08002214(void)\n\n{\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08002214": "get_system_core_clock_08002214",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002220": {
            "entrypoint": "0x08002220",
            "current_name": "get_adjusted_clock_08002220",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedClock_08002220(void)\n\n{\n  return coreClock >> \"\"[(_DAT_40021004 & 0x700) >> 8];\n}\n\n",
            "renaming": {
                "FUN_08002220": "get_adjusted_clock_08002220",
                "SystemCoreClock": "coreClock"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002250": {
            "entrypoint": "0x08002250",
            "current_name": "get_adjusted_system_clock_08002250",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedSystemClock_08002250(void)\n\n{\n  return systemClock >> \"\"[(_DAT_40021004 & 0x3800) >> 0xb];\n}\n\n",
            "renaming": {
                "FUN_08002250": "get_adjusted_system_clock_08002250",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002280": {
            "entrypoint": "0x08002280",
            "current_name": "configure_timer_output_08002280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_08002280(TimerTypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t modifiedCCER;\n  uint32_t modifiedCR2;\n  uint mode;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  modifiedCR2 = timer->CR2;\n  mode = outputConfig->OCMode;\n  modifiedCCER = timer->CCER & 0xfffffffd | outputConfig->OCPolarity;\n  if (timer == (TimerTypeDef *)0x40012c00) {\n    modifiedCCER = (modifiedCCER & 0xfffffff7 | outputConfig->OCNPolarity) & 0xfffffffb;\n    modifiedCR2 = modifiedCR2 & 0xfffffcff | outputConfig->OCIdleState | outputConfig->OCNIdleState;\n  }\n  timer->CR2 = modifiedCR2;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | mode;\n  timer->CCR1 = outputConfig->Pulse;\n  timer->CCER = modifiedCCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002280": "configure_timer_output_08002280",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "modifiedCCER",
                "uVar2": "modifiedCR2",
                "uVar3": "mode",
                "TIM_TypeDef": "TimerTypeDef"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022d0": {
            "entrypoint": "0x080022d0",
            "current_name": "configure_timer_080022d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_080022d0(TIM_TypeDef *timer,TIM_OC_InitTypeDef *ocConfiguration)\n\n{\n  uint32_t updatedCCER;\n  uint32_t updatedCR2;\n  uint ocMode;\n  \n  timer->captureCompareEnableRegister = timer->captureCompareEnableRegister & 0xfffffeff;\n  updatedCR2 = timer->controlRegister2;\n  ocMode = ocConfiguration->outputCompareMode;\n  updatedCCER = timer->captureCompareEnableRegister & 0xfffffdff | ocConfiguration->ocPolarity << 8;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    updatedCCER = (updatedCCER & 0xfffff7ff | ocConfiguration->ocNegativePolarity << 8) & 0xfffffbff;\n    updatedCR2 = updatedCR2 & 0xffffcfff | (ocConfiguration->ocIdleState | ocConfiguration->ocNegativeIdleState) << 4;\n  }\n  timer->controlRegister2 = updatedCR2;\n  timer->captureCompareModeRegister2 = timer->captureCompareModeRegister2 & 0xffffff8c | ocMode;\n  timer->CCR3 = ocConfiguration->pulse;\n  timer->captureCompareEnableRegister = updatedCCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022d0": "configure_timer_080022d0",
                "TIMx": "timer",
                "OC_Config": "ocConfiguration",
                "uVar1": "updatedCCER",
                "uVar2": "updatedCR2",
                "uVar3": "ocMode",
                "CCER": "captureCompareEnableRegister",
                "CR2": "controlRegister2",
                "OCMode": "outputCompareMode",
                "OCPolarity": "ocPolarity",
                "OCNPolarity": "ocNegativePolarity",
                "OCIdleState": "ocIdleState",
                "OCNIdleState": "ocNegativeIdleState",
                "CCMR2": "captureCompareModeRegister2",
                "Pulse": "pulse"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002324": {
            "entrypoint": "0x08002324",
            "current_name": "configure_timer_output_channel_08002324",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutputChannel_08002324(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t controlRegister1;\n  uint32_t outputMode;\n  uint32_t outputPolarity;\n  uint32_t outputIdleState;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  controlRegister1 = timer->CR2;\n  outputMode = outputConfig->OCMode;\n  outputPolarity = outputConfig->OCPolarity;\n  outputIdleState = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    outputIdleState = outputConfig->OCIdleState;\n    controlRegister1 = controlRegister1 & 0xffffbfff;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    controlRegister1 = controlRegister1 | outputIdleState << 6;\n  }\n  timer->CR2 = controlRegister1;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | outputMode << 8;\n  timer->CCR4 = outputConfig->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | outputPolarity << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002324": "configure_timer_output_channel_08002324",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "controlRegister1",
                "uVar2": "outputMode",
                "uVar3": "outputPolarity",
                "uVar4": "outputIdleState"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002368": {
            "entrypoint": "0x08002368",
            "current_name": "initialize_timer_08002368",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08002368(TIM_TypeDef *timer,timerConfig *Structure)\n\n{\n  uint32_t controlRegisterValue;\n  \n  controlRegisterValue = timer->CR1;\n  if (((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n       (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) &&\n     (((controlRegisterValue = controlRegisterValue & 0xffffff8f | Structure->CounterMode, timer == (TIM_TypeDef *)0x40012c00 ||\n       (timer == (TIM_TypeDef *)0x40000000)) ||\n      ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))))) {\n    controlRegisterValue = controlRegisterValue & 0xfffffcff | Structure->ClockDivision;\n  }\n  timer->CR1 = controlRegisterValue;\n  timer->ARR = Structure->Period;\n  timer->PSC = Structure->Prescaler;\n  controlRegisterValue = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    controlRegisterValue = Structure->RepetitionCounter;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    timer->RCR = controlRegisterValue;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002368": "initialize_timer_08002368",
                "TIMx": "timer",
                "TIM_Base_InitTypeDef": "timerConfig",
                "uVar1": "controlRegisterValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023d0": {
            "entrypoint": "0x080023d0",
            "current_name": "initialize_tim_080023d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initialize_TIM_080023d0(TIM_HandleTypeDef *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef *)0x0) {\n    if (timer->State == reset_state) {\n      timer->Lock = unlocked;\n      initialize_tim_pwm(timer);\n    }\n    timer->State = busy_state;\n    configure_timer(timer->Instance,&timer->Init);\n    timer->State = ready_state;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_080023d0": "initialize_tim_080023d0",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "reset_state",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_PWM_MspInit": "initialize_tim_pwm",
                "HAL_TIM_STATE_BUSY": "busy_state",
                "HAL_TIM_STATE_READY": "ready_state",
                "HAL_OK": "success",
                "HAL_ERROR": "error",
                "TIM_Base_SetConfig": "configure_timer"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002404": {
            "entrypoint": "0x08002404",
            "current_name": "configure_timer_output_compare_08002404",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutputCompare_08002404(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint32_t ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2Value = timer->CR2;\n  ocModeValue = outputCompareConfig->OCMode;\n  ccerValue = timer->CCER & 0xffffffdf | outputCompareConfig->OCPolarity << 4;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xffffff7f | outputCompareConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2Value = cr2Value & 0xfffff3ff | (outputCompareConfig->OCIdleState | outputCompareConfig->OCNIdleState) << 2;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocModeValue << 8;\n  timer->CCR2 = outputCompareConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002404": "configure_timer_output_compare_08002404",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800245c": {
            "entrypoint": "0x0800245c",
            "current_name": "configure_timer_channel_0800245c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_0800245c(TIM_HandleTypeDef *timerHandle,TIM_OC_InitTypeDef *outputConfig,uint32_t channel)\n\n{\n  int temp1;\n  int temp2;\n  int temp3;\n  uint value1;\n  int temp4;\n  int value2;\n  uint32_t config1;\n  TIM_TypeDef *timerInstance;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  timerHandle->State = HAL_TIM_STATE_BUSY;\n  timerHandle->Lock = HAL_LOCKED;\n  switch(channel) {\n  case 0:\n    TIM_OC1_SetConfig(timerHandle->Instance,outputConfig);\n    timerInstance = timerHandle->Instance;\n    value1 = *(uint *)(temp1 + 0x10);\n    timerInstance->CCMR1 = timerInstance->CCMR1 | 8;\n    timerInstance->CCMR1 = timerInstance->CCMR1 & 0xfffffffb;\n    config1 = timerInstance->CCMR1 | value1;\n    break;\n  default:\n    goto switchD_0800247a_caseD_1;\n  case 4:\n    TIM_OC2_SetConfig(timerHandle->Instance,outputConfig);\n    timerInstance = timerHandle->Instance;\n    value2 = *(int *)(temp2 + 0x10);\n    timerInstance->CCMR1 = timerInstance->CCMR1 | 0x800;\n    timerInstance->CCMR1 = timerInstance->CCMR1 & 0xfffffbff;\n    config1 = timerInstance->CCMR1 | value2 << 8;\n    break;\n  case 8:\n    TIM_OC3_SetConfig(timerHandle->Instance,outputConfig);\n    timerInstance = timerHandle->Instance;\n    value1 = *(uint *)(temp3 + 0x10);\n    timerInstance->CCMR2 = timerInstance->CCMR2 | 8;\n    timerInstance->CCMR2 = timerInstance->CCMR2 & 0xfffffffb;\n    config1 = timerInstance->CCMR2 | value1;\n    goto LAB_080024fa;\n  case 0xc:\n    TIM_OC4_SetConfig(timerHandle->Instance,outputConfig);\n    timerInstance = timerHandle->Instance;\n    value2 = *(int *)(temp4 + 0x10);\n    timerInstance->CCMR2 = timerInstance->CCMR2 | 0x800;\n    timerInstance->CCMR2 = timerInstance->CCMR2 & 0xfffffbff;\n    config1 = timerInstance->CCMR2 | value2 << 8;\nLAB_080024fa:\n    timerInstance->CCMR2 = config1;\n    goto switchD_0800247a_caseD_1;\n  }\n  timerInstance->CCMR1 = config1;\nswitchD_0800247a_caseD_1:\n  timerHandle->State = HAL_TIM_STATE_READY;\n  timerHandle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800245c": "configure_timer_channel_0800245c",
                "htim": "timerHandle",
                "sConfig": "outputConfig",
                "Channel": "channel",
                "extraout_r1": "temp1",
                "extraout_r1_00": "temp2",
                "extraout_r1_01": "temp3",
                "extraout_r1_02": "temp4",
                "uVar1": "value1",
                "iVar2": "value2",
                "uVar3": "config1",
                "pTVar4": "timerInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002520": {
            "entrypoint": "0x08002520",
            "current_name": "update_channel_state_08002520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08002520(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = state << (channel & 0xff) | timer->CCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002520": "update_channel_state_08002520",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002538": {
            "entrypoint": "0x08002538",
            "current_name": "initialize_timer_channel_08002538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeTimerChannel_08002538(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  uint32_t controlValue;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelNumberCmd(timerHandle->Instance,channelNumber,1);\n  timerInstance = timerHandle->Instance;\n  controlValue = 0x40012c00;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    controlValue = uRam40012c44 | 0x8000;\n  }\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    timerInstance->BDTR = controlValue;\n  }\n  timerInstance->CR1 = timerInstance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002538": "initialize_timer_channel_08002538",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "uVar1": "controlValue",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "PWM_Init"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002564": {
            "entrypoint": "0x08002564",
            "current_name": "configure_break_dead_time_08002564",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureBreakDeadTime_08002564(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeSettings)\n\n{\n  HAL_StatusTypeDef status;\n  \n  status = HAL_BUSY;\n  if (timer->Lock != HAL_LOCKED) {\n    timer->State = HAL_TIM_STATE_BUSY;\n    timer->Instance->BDTR =\n         breakDeadTimeSettings->OffStateRunMode | breakDeadTimeSettings->OffStateIDLEMode |\n         breakDeadTimeSettings->LockLevel | breakDeadTimeSettings->DeadTime |\n         breakDeadTimeSettings->BreakState | breakDeadTimeSettings->BreakPolarity |\n         breakDeadTimeSettings->AutomaticOutput;\n    timer->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002564": "configure_break_dead_time_08002564",
                "htim": "timer",
                "sBreakDeadTimeConfig": "breakDeadTimeSettings",
                "HVar1": "status"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025a4": {
            "entrypoint": "0x080025a4",
            "current_name": "configure_timer_080025a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimer_080025a4(TIM_HandleTypeDef *timer,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  uint masterSlaveMode;\n  HAL_StatusTypeDef status;\n  TIM_TypeDef *timerInstance;\n  uint masterOutputTrigger;\n  \n  status = HAL_BUSY;\n  if (timer->Lock != HAL_LOCKED) {\n    timer->State = HAL_TIM_STATE_BUSY;\n    timerInstance = timer->Instance;\n    masterOutputTrigger = masterConfig->MasterOutputTrigger;\n    masterSlaveMode = masterConfig->MasterSlaveMode;\n    timerInstance->CR2 = timerInstance->CR2 & 0xffffff8f;\n    timerInstance->CR2 = timerInstance->CR2 | masterOutputTrigger;\n    timerInstance->SMCR = timerInstance->SMCR & 0xffffff7f;\n    timerInstance->SMCR = timerInstance->SMCR | masterSlaveMode;\n    timer->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080025a4": "configure_timer_080025a4",
                "htim": "timer",
                "sMasterConfig": "masterConfig",
                "HVar2": "status",
                "pTVar3": "timerInstance",
                "uVar1": "masterSlaveMode",
                "uVar4": "masterOutputTrigger"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "initialize_uart_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_080025e8(UART_HandleTypeDef *UART_handle)\n\n{\n  uint32_t pclk_freq;\n  uint32_t baud_div;\n  uint parity;\n  int oversampling;\n  uint32_t baud_rate;\n  int baud_error;\n  USART_TypeDef *uart_instance;\n  \n  uart_instance = UART_handle->Instance;\n  parity = (UART_handle->Init).Parity;\n  uart_instance->CR2 = uart_instance->CR2 & 0xffffcfff | (UART_handle->Init).StopBits;\n  uart_instance->CR1 = (UART_handle->Init).WordLength | parity | (UART_handle->Init).Mode | uart_instance->CR1 & 0xffffe9f3;\n  uart_instance->CR3 = uart_instance->CR3 & 0xfffffcff | (UART_handle->Init).HwFlowCtl;\n  if (uart_instance == (USART_TypeDef *)0x40013800) {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    oversampling = (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100);\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (UART_handle->Init).BaudRate;\n    baud_div = HAL_RCC_GetPCLK2Freq();\n    baud_error = (pclk_freq * 0x19) / (baud_rate << 2) +\n            (int)(((ulonglong)(baud_div * 0x19) / (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    parity = (pclk_freq * 0x19) / ((UART_handle->Init).BaudRate << 2);\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n  }\n  else {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    oversampling = (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100);\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (UART_handle->Init).BaudRate;\n    baud_div = HAL_RCC_GetPCLK1Freq();\n    baud_error = (pclk_freq * 0x19) / (baud_rate << 2) +\n            (int)(((ulonglong)(baud_div * 0x19) / (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    parity = (pclk_freq * 0x19) / ((UART_handle->Init).BaudRate << 2);\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n  }\n  uart_instance->BRR = (((parity + (int)(((ulonglong)(pclk_freq * 0x19) /\n                                 (ulonglong)((UART_handle->Init).BaudRate << 2)) / 100) * -100) * 0x10 +\n                 0x32) / 100 & 0xf | (baud_error * 0x10 + 0x32U) / 100 & 0xf0) + oversampling * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "initialize_uart_080025e8",
                "huart": "UART_handle",
                "uVar1": "pclk_freq",
                "uVar2": "baud_div",
                "uVar3": "parity",
                "iVar4": "oversampling",
                "uVar5": "baud_rate",
                "iVar6": "baud_error",
                "pUVar7": "uart_instance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002724": {
            "entrypoint": "0x08002724",
            "current_name": "configure_and_initialize_uart_08002724",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureAndInitializeUART_08002724(UART_HandleTypeDef *uartHandle)\n\n{\n  uartTypeDef *uartInstance;\n  \n  if (uartHandle != (UART_HandleTypeDef *)0x0) {\n    if (uartHandle->State == Reset) {\n      uartHandle->Lock = Unlocked;\n      initializeUartMsp(uartHandle);\n    }\n    uartHandle->State = Busy;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    setUartConfig(uartHandle);\n    uartInstance = uartHandle->Instance;\n    uartInstance->CR2 = uartInstance->CR2 & 0xffffb7ff;\n    uartInstance->CR3 = uartInstance->CR3 & 0xffffffd5;\n    uartInstance->CR1 = uartInstance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->State = Ready;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002724": "configure_and_initialize_uart_08002724",
                "huart": "uartHandle",
                "USART_TypeDef": "uartTypeDef",
                "pUVar1": "uartInstance",
                "HAL_UART_STATE_RESET": "Reset",
                "HAL_UNLOCKED": "Unlocked",
                "HAL_UART_MspInit": "initializeUartMsp",
                "HAL_UART_STATE_BUSY": "Busy",
                "HAL_UART_STATE_READY": "Ready",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR",
                "UART_SetConfig": "setUartConfig"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800277c": {
            "entrypoint": "0x0800277c",
            "current_name": "transmit_data_0800277c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_0800277c(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  HAL_UART_StateTypeDef state;\n  USART_TypeDef *usartInstance;\n  uint16_t *temp;\n  \n  if ((uartHandle->State == HAL_UART_STATE_READY) || (uartHandle->State == HAL_UART_STATE_BUSY_RX)) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      return HAL_ERROR;\n    }\n    if (uartHandle->Lock != HAL_LOCKED) {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->TxXfersize = size;\n      if (uartHandle->State == HAL_UART_STATE_BUSY_RX) {\n        state = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        state = HAL_UART_STATE_BUSY_TX;\n      }\n      uartHandle->TxXferCount = size;\n      uartHandle->State = state;\nLAB_080027c4:\n      if (uartHandle->TxXferCount == 0) {\n        uVar1 = HAL_GetTick();\n        do {\n          do {\n            if ((int)(uartHandle->Instance->SR << 0x19) < 0) {\n              if (uartHandle->State == HAL_UART_STATE_BUSY_TX_RX) {\n                state = HAL_UART_STATE_BUSY_RX;\n              }\n              else {\n                state = HAL_UART_STATE_READY;\n              }\n              uartHandle->State = state;\n              uartHandle->Lock = HAL_UNLOCKED;\n              return HAL_OK;\n            }\n          } while (timeout == 0xffffffff);\n        } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n      }\n      else {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n                if ((uartHandle->Init).Parity == 0) {\n                  data = (uint8_t *)((int)data + 2);\n                }\n                else {\nLAB_08002812:\n                  data = (uint8_t *)((int)data + 1);\n                }\n                goto LAB_080027c4;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n        else {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = (uint)*data;\n                goto LAB_08002812;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n      }\n      usartInstance = uartHandle->Instance;\n      usartInstance->CR1 = usartInstance->CR1 & 0xffffff7f;\n      usartInstance->CR1 = usartInstance->CR1 & 0xffffffdf;\n      usartInstance->CR1 = usartInstance->CR1 & 0xfffffeff;\n      usartInstance->CR3 = usartInstance->CR3 & 0xfffffffe;\n      uartHandle->State = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800277c": "transmit_data_0800277c",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar3": "state",
                "pUVar4": "usartInstance",
                "tmp": "temp"
            },
            "calling": [
                "serialWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028a6": {
            "entrypoint": "0x080028a6",
            "current_name": "configure_uart_080028a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configure_UART_080028a6(UART_HandleTypeDef *UART_handle,uint8_t *data_buffer,uint16_t data_size)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  uint control_reg;\n  USART_TypeDef *uart_instance;\n  \n  if ((UART_handle->State == HAL_UART_STATE_READY) || (UART_handle->State == HAL_UART_STATE_BUSY_TX)) {\n    if ((data_buffer == (uint8_t *)0x0) || (data_size == 0)) {\n      return HAL_ERROR;\n    }\n    if (UART_handle->Lock != HAL_LOCKED) {\n      UART_handle->Lock = HAL_LOCKED;\n      UART_handle->ErrorCode = 0;\n      UART_handle->RxXferdata_size = data_size;\n      UART_handle->RxXferCount = data_size;\n      UART_handle->Lock = HAL_UNLOCKED;\n      if (UART_handle->State == HAL_UART_STATE_BUSY_TX) {\n        uart_state = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uart_state = HAL_UART_STATE_BUSY_RX;\n      }\n      uart_instance = UART_handle->Instance;\n      UART_handle->State = uart_state;\n      control_reg = uart_instance->CR1;\n      UART_handle->pRxBuffPtr = data_buffer;\n      uart_instance->CR1 = control_reg | 0x100;\n      uart_instance->CR3 = uart_instance->CR3 | 1;\n      uart_instance->CR1 = uart_instance->CR1 | 0x20;\n      return HAL_OK;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080028a6": "configure_uart_080028a6",
                "huart": "UART_handle",
                "pData": "data_buffer",
                "Size": "data_size",
                "HVar1": "uart_state",
                "uVar2": "control_reg",
                "pUVar3": "uart_instance"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800290a": {
            "entrypoint": "0x0800290a",
            "current_name": "FUNC_0800290a",
            "code": "\nvoid FUNC_0800290a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800290a": "FUNC_0800290a"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800290c": {
            "entrypoint": "0x0800290c",
            "current_name": "receive_data_0800290c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef receiveData_0800290c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t parity;\n  byte byteValue;\n  USART_TypeDef *usartInstance;\n  uint16_t count;\n  ushort *rxBuffer;\n  uint16_t *tmp;\n  ushort *newRxBuffer;\n  bool flag;\n  \n  if ((uartHandle->State & 0xef) != 0x22) {\n    return HAL_BUSY;\n  }\n  parity = (uartHandle->Init).Parity;\n  usartInstance = uartHandle->Instance;\n  rxBuffer = (ushort *)uartHandle->pRxBuffPtr;\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if (parity == 0) {\n      newRxBuffer = rxBuffer + 1;\n      *rxBuffer = (ushort)((usartInstance->DR << 0x17) >> 0x17);\n    }\n    else {\n      newRxBuffer = (ushort *)((int)rxBuffer + 1);\n      *rxBuffer = (ushort)usartInstance->DR & 0xff;\n    }\n    uartHandle->pRxBuffPtr = (uint8_t *)newRxBuffer;\n  }\n  else {\n    if (parity == 0) {\n      byteValue = (byte)usartInstance->DR;\n      uartHandle->pRxBuffPtr = (uint8_t *)((int)rxBuffer + 1);\n    }\n    else {\n      parity = usartInstance->DR;\n      uartHandle->pRxBuffPtr = (uint8_t *)((int)rxBuffer + 1);\n      byteValue = (byte)parity & 0x7f;\n    }\n    *(byte *)rxBuffer = byteValue;\n  }\n  count = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = count;\n  if (count == 0) {\n    usartInstance = uartHandle->Instance;\n    usartInstance->CR1 = usartInstance->CR1 & 0xffffffdf;\n    flag = uartHandle->State != HAL_UART_STATE_BUSY_TX_RX;\n    if (flag) {\n      parity = usartInstance->CR1 & 0xfffffeff;\n    }\n    else {\n      usartInstance = (USART_TypeDef *)0x12;\n      parity = 0x32;\n    }\n    if (flag) {\n      usartInstance->CR1 = parity;\n      parity = usartInstance->CR3 & 0xfffffffe;\n    }\n    if (flag) {\n      usartInstance->CR3 = parity;\n      usartInstance = (USART_TypeDef *)0x1;\n    }\n    uartHandle->State = (HAL_UART_StateTypeDef)usartInstance;\n    HAL_UART_RxCpltCallback(uartHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800290c": "receive_data_0800290c",
                "huart": "uartHandle",
                "uVar1": "parity",
                "bVar2": "byteValue",
                "pUVar3": "usartInstance",
                "uVar4": "count",
                "puVar5": "rxBuffer",
                "puVar6": "newRxBuffer",
                "bVar7": "flag"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002998": {
            "entrypoint": "0x08002998",
            "current_name": "FUNC_08002998",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002998": "FUNC_08002998"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800299a": {
            "entrypoint": "0x0800299a",
            "current_name": "handle_uart_interrupt_0800299a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_0800299a(UART_HandleTypeDef *UART_handle)\n\n{\n  uint status_register;\n  uint32_t bitwise_cleared_status_register;\n  uint16_t temp_value;\n  uint status;\n  uint32_t interrupt_status_flags;\n  ushort *pointer_to_TX_buffer;\n  uint16_t *temp_pointer;\n  HAL_UART_StateTypeDef UART_state;\n  USART_TypeDef *UART_instance;\n  uint32_t error_code;\n  uint32_t bitwise_cleared_CR3;\n  uint UART_CR3_value;\n  bool error_flag;\n  \n  UART_instance = UART_handle->Instance;\n  status = UART_instance->SR;\n  status_register = UART_instance->CR1;\n  if ((status & 0xf) == 0) {\n    if (((int)(status << 0x1a) < 0) && ((int)(status_register << 0x1a) < 0)) {\n      UART_Receive_IT(UART_handle);\n      return;\n    }\n  }\n  else {\n    UART_CR3_value = UART_instance->CR3 & 1;\n    if ((UART_CR3_value != 0) || ((status_register & 0x120) != 0)) {\n      error_code = status << 0x1f;\n      if ((int)error_code < 0) {\n        error_flag = (int)(status_register << 0x17) < 0;\n        if (error_flag) {\n          error_code = UART_handle->ErrorCode | 1;\n        }\n        if (error_flag) {\n          UART_handle->ErrorCode = error_code;\n        }\n      }\n      if (((int)(status << 0x1d) < 0) && (UART_CR3_value != 0)) {\n        UART_handle->ErrorCode = UART_handle->ErrorCode | 2;\n      }\n      if (((int)(status << 0x1e) < 0) && (UART_CR3_value != 0)) {\n        UART_handle->ErrorCode = UART_handle->ErrorCode | 4;\n      }\n      if (((int)(status << 0x1c) < 0) && (UART_CR3_value != 0)) {\n        UART_handle->ErrorCode = UART_handle->ErrorCode | 8;\n      }\n      if (UART_handle->ErrorCode == 0) {\n        return;\n      }\n      if (((int)(status << 0x1a) < 0) && ((int)(status_register << 0x1a) < 0)) {\n        UART_Receive_IT(UART_handle);\n      }\n      UART_instance = UART_handle->Instance;\n      if ((-1 < (int)(UART_handle->ErrorCode << 0x1c)) && ((UART_instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UART_handle);\n        UART_handle->ErrorCode = 0;\n        return;\n      }\n      UART_instance->CR1 = UART_instance->CR1 & 0xfffffedf;\n      UART_instance->CR3 = UART_instance->CR3 & 0xfffffffe;\n      UART_handle->State = HAL_UART_STATE_READY;\n      HAL_UART_ErrorCallback(UART_handle);\n      return;\n    }\n  }\n  if (((int)(status << 0x18) < 0) && ((int)(status_register << 0x18) < 0)) {\n    if ((UART_handle->State & 0xdf) == 0x12) {\n      pointer_to_TX_buffer = (ushort *)UART_handle->pTxBuffPtr;\n      if ((UART_handle->Init).WordLength == 0x1000) {\n        UART_instance->DR = *pointer_to_TX_buffer & 0x1ff;\n        if ((UART_handle->Init).Parity == 0) {\n          pointer_to_TX_buffer = pointer_to_TX_buffer + 1;\n        }\n        else {\n          pointer_to_TX_buffer = (ushort *)((int)pointer_to_TX_buffer + 1);\n        }\n        UART_handle->pTxBuffPtr = (uint8_t *)pointer_to_TX_buffer;\n      }\n      else {\n        UART_handle->pTxBuffPtr = (byte *)((int)pointer_to_TX_buffer + 1);\n        UART_instance->DR = (uint)*(byte *)pointer_to_TX_buffer;\n      }\n      temp_value = UART_handle->TxXferCount - 1;\n      UART_handle->TxXferCount = temp_value;\n      if (temp_value == 0) {\n        UART_instance->CR1 = UART_instance->CR1 & 0xffffff7f;\n        UART_instance->CR1 = UART_instance->CR1 | 0x40;\n        return;\n      }\n    }\n  }\n  else if (((int)(status << 0x19) < 0) && ((int)(status_register << 0x19) < 0)) {\n    UART_instance->CR1 = UART_instance->CR1 & 0xffffffbf;\n    if (UART_handle->State == HAL_UART_STATE_BUSY_TX_RX) {\n      UART_state = HAL_UART_STATE_BUSY_RX;\n    }\n    else {\n      UART_state = HAL_UART_STATE_READY;\n    }\n    UART_handle->State = UART_state;\n    HAL_UART_TxCpltCallback(UART_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800299a": "handle_uart_interrupt_0800299a",
                "huart": "UART_handle",
                "uVar1": "status_register",
                "cr1its": "bitwise_cleared_status_register",
                "uVar2": "temp_value",
                "uVar3": "status",
                "isrflags": "interrupt_status_flags",
                "puVar4": "pointer_to_TX_buffer",
                "tmp": "temp_pointer",
                "HVar5": "UART_state",
                "pUVar6": "UART_instance",
                "uVar7": "error_code",
                "cr3its": "bitwise_cleared_CR3",
                "uVar8": "UART_CR3_value",
                "bVar9": "error_flag"
            },
            "calling": [
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad0": {
            "entrypoint": "0x08002ad0",
            "current_name": "initialize_mpu9250_08002ad0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMPU9250_08002ad0(void)\n\n{\n  readByteFromI2C(0xd0,0x75,\"../Src/MPU9250.c\",0x3b);\n  writeByteToI2C(0xd0,0x6b,0x80,'\\x01');\n  writeByteToI2C(0xd0,0x6b,'\\x01','\\x01');\n  writeByteToI2C(0xd0,0x6c,'\\0','\\x01');\n  writeByteToI2C(0xd0,0x19,'\\0','\\x01');\n  writeByteToI2C(0xd0,0x1d,'\\x03','\\x01');\n  writeByteToI2C(0xd0,0x1a,'\\x03','\\x01');\n  writeByteToI2C(0xd0,0x1b,'\\x10','\\x01');\n  writeByteToI2C(0xd0,0x1c,'\\b','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ad0": "initialize_mpu9250_08002ad0",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_WriteByte": "writeByteToI2C"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "I2C_WriteByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b48": {
            "entrypoint": "0x08002b48",
            "current_name": "read_accelerometer_data_08002b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAccelerometerData_08002b48(void)\n\n{\n  undefined4 floatConversion;\n  uint inputValue;\n  int yValue;\n  int zValue;\n  uint8_t accelRawData [6];\n  \n  accelRawData[0] = '\\0';\n  accelRawData[1] = '\\0';\n  accelRawData[2] = '\\0';\n  accelRawData[3] = '\\0';\n  tempValue = inputValue & 0xffff0000;\n  I2C_ReadByteArray(0xd0,0x3b,accelRawData,6,\"../Src/MPU9250.c\",0x58);\n  accelerationY = CONCAT11(accelRawData[2],accelRawData[3]);\n  accelerationX = CONCAT11(accelRawData[0],accelRawData[1]);\n  accelerationZ = CONCAT11(accelRawData[4],accelRawData[5]);\n  zValue = (int)accelerationY;\n  yValue = (int)accelerationZ;\n  floatConversion = __floatsisf();\n  floatConversion = __aeabi_fmul(floatConversion,0x40800000);\n  processedAccelerationX = (float)__aeabi_fmul(floatConversion,0x38000000);\n  floatConversion = __floatsisf(zValue);\n  floatConversion = __aeabi_fmul(floatConversion,0x40800000);\n  processedAccelerationY = (float)__aeabi_fmul(floatConversion,0x38000000);\n  floatConversion = __floatsisf(yValue);\n  floatConversion = __aeabi_fmul(floatConversion,0x40800000);\n  processedAccelerationZ = (float)__aeabi_fmul(floatConversion,0x38000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b48": "read_accelerometer_data_08002b48",
                "in_r3": "inputValue",
                "raw_data": "accelRawData",
                "stack0xffffffec": "tempValue",
                "accelRaw.y": "accelerationY",
                "accelRaw.x": "accelerationX",
                "accelRaw.z": "accelerationZ",
                "accelData.x": "processedAccelerationX",
                "accelData.y": "processedAccelerationY",
                "accelData.z": "processedAccelerationZ",
                "iVar2": "yValue",
                "iVar3": "zValue",
                "uVar1": "floatConversion"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bf0": {
            "entrypoint": "0x08002bf0",
            "current_name": "read_and_process_gyro_data_08002bf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndProcessGyroData_08002bf0(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  uint8_t gyroRawData [6];\n  \n  gyroRawData[0] = '\\0';\n  gyroRawData[1] = '\\0';\n  gyroRawData[2] = '\\0';\n  gyroRawData[3] = '\\0';\n  gyroRawData[4] = '\\0';\n  gyroRawData[5] = '\\0';\n  readByteArrayUsingI2C(0xd0,0x43,gyroRawData,6,\"../Src/MPU9250.c\",0x7b);\n  gyroRawDataY = CONCAT11(gyroRawData[2],gyroRawData[3]);\n  gyroRawDataX = CONCAT11(gyroRawData[0],gyroRawData[1]);\n  gyroRawDataZ = CONCAT11(gyroRawData[4],gyroRawData[5]);\n  iVar3 = (int)gyroRawDataY;\n  iVar2 = (int)gyroRawDataZ;\n  uVar1 = __floatsisf();\n  uVar1 = __aeabi_fmul(uVar1,0x447a0000);\n  uVar1 = __aeabi_fmul(uVar1,0x38000000);\n  gyroProcessedDataX = (float)__aeabi_fsub(uVar1,gyroBiasX);\n  uVar1 = __floatsisf(iVar3);\n  uVar1 = __aeabi_fmul(uVar1,0x447a0000);\n  uVar1 = __aeabi_fmul(uVar1,0x38000000);\n  gyroProcessedDataY = (float)__aeabi_fsub(uVar1,gyroBiasY);\n  uVar1 = __floatsisf(iVar2);\n  uVar1 = __aeabi_fmul(uVar1,0x447a0000);\n  uVar1 = __aeabi_fmul(uVar1,0x38000000);\n  gyroProcessedDataZ = (float)__aeabi_fsub(uVar1,gyroBiasZ);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002bf0": "read_and_process_gyro_data_08002bf0",
                "raw_data": "gyroRawData",
                "I2C_ReadByteArray": "readByteArrayUsingI2C",
                "gyroRaw.y": "gyroRawDataY",
                "gyroRaw.x": "gyroRawDataX",
                "gyroRaw.z": "gyroRawDataZ",
                "gyroData.x": "gyroProcessedDataX",
                "gyroData.y": "gyroProcessedDataY",
                "gyroData.z": "gyroProcessedDataZ",
                "gyroBias.x": "gyroBiasX",
                "gyroBias.y": "gyroBiasY",
                "gyroBias.z": "gyroBiasZ"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb0": {
            "entrypoint": "0x08002cb0",
            "current_name": "calibrate_magnetometer_08002cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calibrate_magnetometer_08002cb0(void)\n\n{\n  undefined4 uVar1;\n  uint rawData;\n  uint8_t rawDataArray [3];\n  \n  rawDataValue = rawData;\n  writeByte(0xd0,0x37,'\\\"','\\x01');\n  writeByte(0xd0,0x6a,'\\x01','\\x01');\n  readByte(0x18,0,\"../Src/MPU9250.c\",0xad);\n  writeByte(0x18,0xb,'\\x01','\\x01');\n  writeByte(0x18,10,'\\0','\\x01');\n  writeByte(0x18,10,'\\x0f','\\x01');\n  readByteArray(0x18,0x10,rawDataArray,3,\"../Src/MPU9250.c\",0xb6);\n  uVar1 = convertToFloat((rawDataValue & 0xff) - 0x80);\n  uVar1 = multiplyFloat(uVar1,0x3b800000);\n  magnetometerCalibration.x = (float)addFloat(uVar1,0x3f800000);\n  uVar1 = convertToFloat((rawDataValue >> 8 & 0xff) - 0x80);\n  uVar1 = multiplyFloat(uVar1,0x3b800000);\n  magnetometerCalibration.y = (float)addFloat(uVar1,0x3f800000);\n  uVar1 = convertToFloat(rawDataArray[2] - 0x80);\n  uVar1 = multiplyFloat(uVar1,0x3b800000);\n  magnetometerCalibration.z = (float)addFloat(uVar1,0x3f800000);\n  writeByte(0x18,10,'\\0','\\x01');\n  writeByte(0x18,10,'\\x16','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cb0": "calibrate_magnetometer_08002cb0",
                "in_r3": "rawData",
                "rawData": "rawDataArray",
                "_rawData": "rawDataValue",
                "I2C_WriteByte": "writeByte",
                "I2C_ReadByte": "readByte",
                "I2C_ReadByteArray": "readByteArray",
                "__floatsisf": "convertToFloat",
                "__aeabi_fmul": "multiplyFloat",
                "__addsf3": "addFloat",
                "magCalib.x": "magnetometerCalibration.x",
                "magCalib.y": "magnetometerCalibration.y",
                "magCalib.z": "magnetometerCalibration.z"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "__addsf3",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d88": {
            "entrypoint": "0x08002d88",
            "current_name": "update_mag_data_08002d88",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMagData_08002d88(void)\n\n{\n  float fVar1;\n  byte byte_value;\n  undefined4 uVar3;\n  undefined4 input_param;\n  int iVar4;\n  int iVar5;\n  int16_t magData_x;\n  undefined temp_var1;\n  undefined temp_var2;\n  undefined magRaw_z1;\n  undefined magRaw_z2;\n  uint8_t overflow_flag;\n  undefined uStack_21;\n  \n  uStack_21 = (undefined)((uint)input_param >> 0x18);\n  magData_x = 0;\n  temp_var1 = 0;\n  temp_var2 = 0;\n  magRaw_z1 = 0;\n  magRaw_z2 = 0;\n  overflow_flag = '\\0';\n  byte_value = readByteFromI2C(0x18,2,\"../Src/MPU9250.c\",0xd7);\n  if ((int)((uint)byte_value << 0x1f) < 0) {\n    readByteArrayFromI2C(0x18,3,(uint8_t *)&magData_x,7,\"../Src/MPU9250.c\",0xda);\n    fVar1 = measurement_resolution;\n    if ((int)((uint)overflow_flag << 0x1c) < 0) {\n      i2c_error_count = i2c_error_count + 1;\n    }\n    else {\n      magRaw_y = CONCAT11(temp_var2,temp_var1);\n      magRaw_z = CONCAT11(magRaw_z2,magRaw_z1);\n      iVar5 = (int)magRaw_y;\n      iVar4 = (int)magRaw_z;\n      magRaw_x = magData_x;\n      uVar3 = convertFloatToInt();\n      uVar3 = multiplyFloat(uVar3,fVar1);\n      uVar3 = multiplyFloat(uVar3,magCalibration_x);\n      uVar3 = subtractFloat(uVar3,magBias_x);\n      updatedMagData_x = (float)multiplyFloat(uVar3,magScale_x);\n      uVar3 = convertFloatToInt(iVar5);\n      uVar3 = multiplyFloat(uVar3,fVar1);\n      uVar3 = multiplyFloat(uVar3,magCalibration_y);\n      uVar3 = subtractFloat(uVar3,magBias_y);\n      updatedMagData_y = (float)multiplyFloat(uVar3,magScale_y);\n      uVar3 = convertFloatToInt(iVar4);\n      uVar3 = multiplyFloat(uVar3,fVar1);\n      uVar3 = multiplyFloat(uVar3,magCalibration_z);\n      uVar3 = subtractFloat(uVar3,magBias_z);\n      updatedMagData_z = (float)multiplyFloat(uVar3,magScale_z);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d88": "update_mag_data_08002d88",
                "in_r3": "input_param",
                "local_28": "magData_x",
                "uStack_26": "temp_var1",
                "uStack_25": "temp_var2",
                "local_24": "magRaw_z1",
                "local_23": "magRaw_z2",
                "OVF": "overflow_flag",
                "bVar2": "byte_value",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_ReadByteArray": "readByteArrayFromI2C",
                "mRes": "measurement_resolution",
                "msp_txf_status.i2c_errors_count": "i2c_error_count",
                "magRaw.y": "magRaw_y",
                "magRaw.z": "magRaw_z",
                "magRaw.x": "magRaw_x",
                "__floatsisf": "convertFloatToInt",
                "__aeabi_fmul": "multiplyFloat",
                "__aeabi_fsub": "subtractFloat",
                "magCalib.x": "magCalibration_x",
                "magBias.x": "magBias_x",
                "magScale.x": "magScale_x",
                "magCalib.y": "magCalibration_y",
                "magBias.y": "magBias_y",
                "magScale.y": "magScale_y",
                "magCalib.z": "magCalibration_z",
                "magBias.z": "magBias_z",
                "magScale.z": "magScale_z",
                "magData.x": "updatedMagData_x",
                "magData.y": "updatedMagData_y",
                "magData.z": "updatedMagData_z"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "I2C_ReadByte",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ea0": {
            "entrypoint": "0x08002ea0",
            "current_name": "initialize_sensor_08002ea0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSensor_08002ea0(void)\n\n{\n  initializeMPU9250();\n  initializeAK8963();\n  setMadgwickBeta(0.6);\n  setMadgwickDelta(0.0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ea0": "initialize_sensor_08002ea0",
                "MPU9250_Init": "initializeMPU9250",
                "AK8963_Init": "initializeAK8963",
                "MadgwickSetBeta": "setMadgwickBeta",
                "MadgwickSetDelta": "setMadgwickDelta"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "MPU9250_Init",
                "AK8963_Init",
                "MadgwickSetDelta",
                "MadgwickSetBeta"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec0": {
            "entrypoint": "0x08002ec0",
            "current_name": "filter_pitch_angle_08002ec0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat filterPitchAngle_08002ec0(void)\n\n{\n  float fVar1;\n  \n  fVar1 = lowPassFilter(&lowPassFilterPitch,sensorAngles[1]);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ec0": "filter_pitch_angle_08002ec0",
                "lpf_pitch": "lowPassFilterPitch",
                "AHRS_Angle": "sensorAngles"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed4": {
            "entrypoint": "0x08002ed4",
            "current_name": "calculate_filtered_angle_08002ed4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateFilteredAngle_08002ed4(void)\n\n{\n  float fVar1;\n  \n  fVar1 = lowPassFilter(&lowPassFilterRoll,angleMeasurement);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ed4": "calculate_filtered_angle_08002ed4",
                "lpf_roll": "lowPassFilterRoll",
                "AHRS_Angle[0]": "angleMeasurement"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ee8": {
            "entrypoint": "0x08002ee8",
            "current_name": "calculate_adjusted_angle_08002ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateAdjustedAngle_08002ee8(void)\n\n{\n  int comparisonResult;\n  float originalAngle;\n  float adjustedAngle;\n  \n  adjustedAngle = angleArray[2];\n  comparisonResult = __aeabi_fcmpge(angleArray[2],0xc3340000);\n  if ((comparisonResult != 0) && (comparisonResult = __aeabi_fcmplt(adjustedAngle,0x42b40000), comparisonResult != 0)) {\n    adjustedAngle = (float)__addsf3(adjustedAngle,0x42b40000);\n    return adjustedAngle;\n  }\n  adjustedAngle = (float)__aeabi_fsub(adjustedAngle,0x43870000);\n  return adjustedAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ee8": "calculate_adjusted_angle_08002ee8",
                "AHRS_Angle": "angleArray",
                "iVar1": "comparisonResult",
                "angle": "originalAngle",
                "fVar2": "adjustedAngle"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fcmpge",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f28": {
            "entrypoint": "0x08002f28",
            "current_name": "update_ahrs_data_08002f28",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAHRSData_08002f28(void)\n\n{\n  undefined4 timeDiff;\n  float timeDelta;\n  \n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n  currentTime = micros();\n  timeDiff = __floatunsisf(currentTime - lastUpdateTime);\n  timeDelta = (float)__aeabi_fdiv(timeDiff,0x447a0000);\n  MadgwickSetDelta(timeDelta);\n  lastUpdateTime = currentTime;\n  MadgwickQuaternionUpdate\n            ((float)((int)accelerationData.y + -0x80000000),(float)((int)accelerationData.x + -0x80000000),\n             accelerationData.z,gyroData.y,gyroData.x,(float)((int)gyroData.z + -0x80000000),magnetometerData.x,\n             magnetometerData.y,magnetometerData.z,angleData);\n  mspDataRawIMU.accx = (int16_t)((uint)(int)rawAcceleration.x / 100);\n  mspDataRawIMU.accz = (int16_t)((uint)(int)rawAcceleration.z / 100);\n  mspDataRawIMU.accy = (int16_t)((uint)(int)rawAcceleration.y / 100);\n  mspDataRawIMU.gyrx = rawGyro.x;\n  mspDataRawIMU.gyry = rawGyro.y;\n  mspDataRawIMU.gyrz = rawGyro.z;\n  mspDataRawIMU.magx = rawMagnetometer.x;\n  mspDataRawIMU.magy = rawMagnetometer.y;\n  mspDataRawIMU.magz = rawMagnetometer.z;\n  AHRS_GetRoll();\n  __aeabi_fmul();\n  mspDataAttitude.angx = __aeabi_f2iz();\n  AHRS_GetPitch();\n  __aeabi_fmul();\n  mspDataAttitude.angy = __aeabi_f2iz();\n  AHRS_GetYaw();\n  mspDataAttitude.heading = __aeabi_f2iz();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f28": "update_ahrs_data_08002f28",
                "uVar1": "timeDiff",
                "_deltat": "timeDelta",
                "AHRS_timeNow": "currentTime",
                "AHRS_lastUpdate": "lastUpdateTime",
                "accelData": "accelerationData",
                "magData": "magnetometerData",
                "AHRS_Angle": "angleData",
                "msp_txf_raw_imu": "mspDataRawIMU",
                "accelRaw": "rawAcceleration",
                "gyroRaw": "rawGyro",
                "magRaw": "rawMagnetometer",
                "msp_txf_attitude": "mspDataAttitude"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__aeabi_fmul",
                "MPU9250_ReadAccelData",
                "micros",
                "MPU9250_ReadGyroData",
                "AHRS_GetRoll",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AK8963_ReadData",
                "AHRS_GetYaw",
                "MadgwickSetDelta",
                "__floatunsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003034": {
            "entrypoint": "0x08003034",
            "current_name": "read_and_combine_bytes_08003034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t read_and_combine_bytes_08003034(void)\n\n{\n  undefined4 input_value;\n  uint8_t received_bytes [3];\n  \n  received_bytes = input_value;\n  read_I2C_bytes(0xee,0,received_bytes,3,\"../Src/MS5611.c\",0x8c);\n  return (uint)combine_three_bytes(received_bytes[0],combine_two_bytes(received_bytes[1],received_bytes[2]));\n}\n\n",
            "renaming": {
                "FUN_08003034": "read_and_combine_bytes_08003034",
                "in_r3": "input_value",
                "rxbuf": "received_bytes",
                "_rxbuf": "received_bytes",
                "I2C_ReadBytes": "read_I2C_bytes",
                "CONCAT12": "combine_three_bytes",
                "CONCAT11": "combine_two_bytes"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "I2C_ReadBytes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003068": {
            "entrypoint": "0x08003068",
            "current_name": "calculate_float_value_08003068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateFloatValue_08003068(void)\n\n{\n  float inputFloat;\n  \n  return inputFloat;\n}\n\n",
            "renaming": {
                "FUN_08003068": "calculate_float_value_08003068",
                "in_s0": "inputFloat"
            },
            "calling": [
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003078": {
            "entrypoint": "0x08003078",
            "current_name": "calculate_altitude_08003078",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateAltitude_08003078(void)\n\n{\n  float *pfVar1;\n  longlong var7;\n  uint var15;\n  uint var4;\n  uint var5;\n  undefined4 var10;\n  float var12;\n  uint32_t var9;\n  undefined4 extraout_r1;\n  uint var1;\n  undefined4 unaff_r4;\n  uint var2;\n  uint var3;\n  uint var6;\n  float *pointerVar;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  int var14;\n  int32_t temp;\n  int var8;\n  int var13;\n  int32_t dT;\n  bool bVar17;\n  undefined8 var11;\n  \n  if ((tempReady != '\\0') && (pressureReady != '\\0')) {\n    var13 = rawTemperature + (uint)coefficients[5] * -0x100;\n    var1 = (uint)((longlong)(int)(uint)coefficients[6] * (longlong)var13) >> 0x17 |\n            (int)((ulonglong)((longlong)(int)(uint)coefficients[6] * (longlong)var13) >>\n                 0x20) << 9;\n    var2 = (uint)((longlong)(int)(uint)coefficients[4] * (longlong)var13 >> 7);\n    var3 = var2 + (uint)coefficients[2] * 0x10000;\n    var4 = (uint)((ulonglong)((longlong)(int)(uint)coefficients[3] * (longlong)var13) >> 8)\n    ;\n    var14 = var1 + 2000;\n    var5 = var4 + (uint)coefficients[1] * 0x8000;\n    bVar17 = (int)var1 < 0;\n    if (1999 < var14) {\n      var1 = 0;\n    }\n    var15 = var1;\n    if (bVar17 != SBORROW4(var14,2000)) {\n      var8 = var1 * var1 * 5;\n      var1 = var8 >> 2;\n      var15 = var8 >> 1;\n    }\n    var6 = var3 - var15;\n    var7 = (ulonglong)(var5 - var1) * (ulonglong)rawPressure;\n    var8 = rawPressure *\n             ((((int)((longlong)(int)(uint)coefficients[3] * (longlong)var13 >> 0x28) +\n               (uint)CARRY4(var4,(uint)coefficients[1] * 0x8000)) - ((int)var1 >> 0x1f)) -\n             (uint)(var5 < var1)) + (int)((ulonglong)var7 >> 0x20);\n    var4 = (uint)var7 >> 0x15 | var8 * 0x800;\n    var10 = __floatsisf(var4 - var6 >> 0xf |\n                        (((var8 >> 0x15) -\n                         ((((int)((longlong)(int)(uint)coefficients[4] * (longlong)var13 >>\n                                 0x27) + (uint)CARRY4(var2,(uint)coefficients[2] * 0x10000)\n                           ) - ((int)var15 >> 0x1f)) - (uint)(var3 < var15))) -\n                        (uint)(var4 < var6)) * 0x20000);\n    var12 = (float)__aeabi_fdiv(var10,0x42c80000);\n    compensatedPressure = var12;\n    var10 = __floatsisf(var14);\n    compensatedTemperature = (float)__aeabi_fdiv(var10,0x42c80000);\n    __aeabi_fdiv(var12,0x447d5000);\n    var10 = __aeabi_f2d();\n    pow((double)CONCAT44(unaff_r5,unaff_r4),(double)CONCAT44(unaff_r7,unaff_r6));\n    var11 = __subdf3(0,0x3ff00000,var10,extraout_r1);\n    __muldf3((int)var11,(int)((ulonglong)var11 >> 0x20),0,0x40e5a540);\n    var12 = (float)__truncdfsf2();\n    var10 = 0;\n    pointerVar = filter;\n    altitude = var12;\n    do {\n      pfVar1 = pointerVar + 1;\n      *pointerVar = *pfVar1;\n      var10 = __addsf3(var10);\n      pointerVar = pfVar1;\n    } while (pfVar1 != filter + 0x13);\n    filter[19] = var12;\n    var10 = __addsf3(var10,var12);\n    filteredAltitude = (float)__aeabi_fdiv(var10,0x41a00000);\n    var14 = __aeabi_f2iz();\n    estimatedAltitude = var14 * 100;\n    tempReady = '\\0';\n    pressureReady = '\\0';\n    writeByte(0xee,osrValue + 0x50,'\\x01','\\0');\n    tempTime = millis();\n  }\n  var9 = millis();\n  if (((10 < var9 - tempTime) && (tempReady == '\\0')) && (pressureReady == '\\0')) {\n    rawTemperature = readADC();\n    tempReady = '\\x01';\n    writeByte(0xee,osrValue + 0x40,'\\x01','\\0');\n    pressureTime = millis();\n  }\n  var9 = millis();\n  if (((10 < var9 - pressureTime) && (tempReady != '\\0')) && (pressureReady == '\\0')) {\n    rawPressure = readADC();\n    pressureReady = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003078": "calculate_altitude_08003078",
                "MS5611_RawTemperature": "rawTemperature",
                "MS5611_Coefficients": "coefficients",
                "MS5611_RawPressure": "rawPressure",
                "uVar9": "var1",
                "uVar10": "var2",
                "uVar11": "var3",
                "uVar4": "var4",
                "uVar5": "var5",
                "uVar12": "var6",
                "lVar2": "var7",
                "iVar15": "var8",
                "uVar8": "var9",
                "uVar6": "var10",
                "uVar18": "var11",
                "fVar7": "var12",
                "pfVar13": "pointerVar",
                "TEMP_READY": "tempReady",
                "PRESSURE_READY": "pressureReady",
                "iVar16": "var13",
                "iVar14": "var14",
                "uVar3": "var15",
                "TEMP": "temp",
                "MS5611_CompensatedPressure": "compensatedPressure",
                "MS5611_CompensatedTemperature": "compensatedTemperature",
                "MS5611_Altitude": "altitude",
                "alt_filter": "filter",
                "MS5611_FilteredAltitude": "filteredAltitude",
                "msp_txf_altitude.est_alt": "estimatedAltitude",
                "MS5611_OSR": "osrValue",
                "temp_time": "tempTime",
                "pressure_time": "pressureTime",
                "I2C_WriteByte": "writeByte",
                "MS5611_ReadADC": "readADC"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2d",
                "pow",
                "__truncdfsf2",
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__addsf3",
                "__floatsisf",
                "__muldf3",
                "millis",
                "MS5611_ReadADC",
                "I2C_WriteByte",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003298": {
            "entrypoint": "0x08003298",
            "current_name": "initialize_ms5611_sensor_08003298",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_MS5611_sensor_08003298(void)\n\n{\n  int i;\n  int counter;\n  uint8_t received_data [2];\n  \n  counter = 0;\n  write_byte_to_I2C(0xee,0x1e,'\\x01','\\x01');\n  delay_milliseconds(10);\n  oversampling_ratio = '\\b';\n  do {\n    received_data[0] = '\\0';\n    received_data[1] = '\\0';\n    read_byte_array_from_I2C(0xee,(short)counter + 0xa0,received_data,2,\"../Src/MS5611.c\",0x7c);\n    *(ushort *)((int)sensor_coefficients + counter) = CONCAT11(received_data[0],received_data[1]);\n    counter = counter + 2;\n  } while (counter != 0x10);\n  counter = 0;\n  do {\n    altitude_filter[counter] = 0.0;\n    counter = counter + 1;\n  } while (counter != 0x14);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003298": "initialize_ms5611_sensor_08003298",
                "rxbuf": "received_data",
                "iVar1": "counter",
                "I2C_WriteByte": "write_byte_to_I2C",
                "delay_ms": "delay_milliseconds",
                "MS5611_OSR": "oversampling_ratio",
                "I2C_ReadByteArray": "read_byte_array_from_I2C",
                "MS5611_Coefficients": "sensor_coefficients",
                "alt_filter": "altitude_filter"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "delay_ms",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003314": {
            "entrypoint": "0x08003314",
            "current_name": "set_beta_08003314",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setBeta_08003314(float newBeta)\n\n{\n  beta = newBeta;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "newBeta"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003320": {
            "entrypoint": "0x08003320",
            "current_name": "update_delta_time_08003320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDeltaTime_08003320(float deltaTime)\n\n{\n  deltat = deltaTime;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003320": "update_delta_time_08003320",
                "_deltat": "deltaTime"
            },
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003330": {
            "entrypoint": "0x08003330",
            "current_name": "calculate_angles_08003330",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateAngles_08003330(float acceleration_x,float acceleration_y,float acceleration_z,float gyroscope_x,float gyroscope_y,float gyroscope_z,float magneticField_x,float magneticField_y,float magneticField_z,\n                 float *result_angle)\n\n{\n  float temp1;\n  float temp2;\n  undefined4 norm1;\n  undefined4 norm2;\n  float norm;\n  undefined4 norm3;\n  int normZero1;\n  undefined4 norm4;\n  undefined4 norm5;\n  undefined4 norm6;\n  int normZero2;\n  undefined4 norm7;\n  undefined4 f1Mul1;\n  undefined4 f1Mul2;\n  undefined4 f1Mul3;\n  undefined4 f2Mul1;\n  undefined4 f2Mul2;\n  undefined4 f2Mul3;\n  undefined4 f3Mul1;\n  undefined4 inverse1;\n  undefined4 inverse2;\n  int temp3;\n  float temp4;\n  undefined4 temp5;\n  float temp6;\n  undefined4 temp7;\n  float temp8;\n  undefined4 temp9;\n  float temp10;\n  undefined4 temp11;\n  undefined4 temp12;\n  undefined4 temp13;\n  int normZero3;\n  float temp14;\n  float temp15;\n  float temp16;\n  float s1;\n  float s2;\n  float s3;\n  float s4;\n  float temp17;\n  float temp18;\n  float temp19;\n  float quaternion1;\n  float quaternion2;\n  float quaternion4;\n  float quaternion3;\n  undefined8 temp20;\n  undefined8 temp21;\n  undefined4 temp22;\n  float temp23;\n  float gyroscope_y_corrected;\n  float gyroscope_x_corrected;\n  \n  temp19 = q[3];\n  temp18 = q[2];\n  temp17 = q[0];\n  temp23 = q[1];\n  norm1 = __aeabi_fmul(acceleration_x,acceleration_x);\n  norm2 = __aeabi_fmul(acceleration_y);\n  norm1 = __addsf3(norm1,norm2);\n  norm2 = __aeabi_fmul(acceleration_z);\n  __addsf3(norm1,norm2);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(temp23,temp22));\n  norm1 = __truncdfsf2();\n  norm = (float)__aeabi_fcmpeq(norm1,0);\n  if (norm == 0.0) {\n    norm2 = __aeabi_fmul(magneticField_x);\n    norm3 = __aeabi_fmul(magneticField_y);\n    norm2 = __addsf3(norm2,norm3);\n    norm3 = __aeabi_fmul(magneticField_z);\n    __addsf3(norm2,norm3);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(temp23,temp22));\n    norm2 = __truncdfsf2();\n    normZero1 = __aeabi_fcmpeq(norm2,0);\n    if (normZero1 == 0) {\n      temp20 = __aeabi_f2d(gyroscope_x);\n      __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xa2529d39,0x3f91df46);\n      norm3 = __truncdfsf2();\n      temp20 = __aeabi_f2d(gyroscope_y);\n      __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xa2529d39,0x3f91df46);\n      norm4 = __truncdfsf2();\n      temp20 = __aeabi_f2d(gyroscope_z);\n      __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xa2529d39,0x3f91df46);\n      norm5 = __truncdfsf2();\n      normZero1 = __addsf3(temp17);\n      norm6 = __addsf3(temp23);\n      normZero2 = __addsf3(temp18,temp18);\n      norm7 = __addsf3(temp19,temp19);\n      f1Mul1 = __aeabi_fmul(temp17);\n      f1Mul2 = __aeabi_fmul(temp17,temp23);\n      f1Mul3 = __aeabi_fmul(temp17,temp18);\n      f2Mul1 = __aeabi_fmul(temp23);\n      f2Mul2 = __aeabi_fmul(temp23,temp19);\n      f2Mul3 = __aeabi_fmul(temp18,temp18);\n      f3Mul1 = __aeabi_fmul(temp19,temp19);\n      norm1 = __aeabi_fdiv(0x3f800000,norm1);\n      norm2 = __aeabi_fdiv(0x3f800000,norm2);\n      inverse1 = __aeabi_fmul(magneticField_x,norm2);\n      inverse2 = __aeabi_fmul(magneticField_y,norm2);\n      norm2 = __aeabi_fmul(magneticField_z,norm2);\n      temp3 = __aeabi_fmul(normZero1,inverse1);\n      temp5 = __aeabi_fmul(normZero1,inverse2);\n      temp7 = __aeabi_fmul(normZero1,norm2);\n      temp9 = __aeabi_fmul(norm6,inverse1);\n      temp11 = __aeabi_fmul(f1Mul1,inverse1);\n      temp12 = __aeabi_fmul(temp19,temp5);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp12 = __aeabi_fmul(temp18,temp7);\n      temp11 = __addsf3(temp11,temp12);\n      temp12 = __aeabi_fmul(f2Mul1,inverse1);\n      temp11 = __addsf3(temp11,temp12);\n      temp12 = __aeabi_fmul(norm6,inverse2);\n      temp12 = __aeabi_fmul(temp12,temp18);\n      temp11 = __addsf3(temp11,temp12);\n      temp12 = __aeabi_fmul(norm6,norm2);\n      temp12 = __aeabi_fmul(temp12,temp19);\n      temp11 = __addsf3(temp11,temp12);\n      temp12 = __aeabi_fmul(f2Mul3,inverse1);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp12 = __aeabi_fmul(f3Mul1,inverse1);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp12 = __aeabi_fmul(temp19,temp3);\n      temp13 = __aeabi_fmul(f1Mul1,inverse2);\n      temp12 = __addsf3(temp12,temp13);\n      temp7 = __aeabi_fmul(temp23,temp7);\n      temp7 = __aeabi_fsub(temp12,temp7);\n      temp12 = __aeabi_fmul(temp18,temp9);\n      temp7 = __addsf3(temp7,temp12);\n      temp12 = __aeabi_fmul(f2Mul1,inverse2);\n      temp7 = __aeabi_fsub(temp7,temp12);\n      temp12 = __aeabi_fmul(f2Mul3,inverse2);\n      temp7 = __addsf3(temp7,temp12);\n      temp12 = __aeabi_fmul(normZero2,norm2);\n      temp12 = __aeabi_fmul(temp12,temp19);\n      temp7 = __addsf3(temp7,temp12);\n      temp12 = __aeabi_fmul(f3Mul1,inverse2);\n      temp7 = __aeabi_fsub(temp7,temp12);\n      temp11 = __aeabi_fmul(temp11,temp11);\n      temp7 = __aeabi_fmul(temp7,temp7);\n      __addsf3(temp11,temp7);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(temp23,temp22));\n      normZero3 = __truncdfsf2();\n      temp7 = __aeabi_fmul(temp3 + -0x80000000,temp18);\n      temp5 = __aeabi_fmul(temp23,temp5);\n      temp5 = __addsf3(temp7,temp5);\n      f1Mul1 = __aeabi_fmul(f1Mul1,norm2);\n      f1Mul1 = __addsf3(temp5,f1Mul1);\n      temp5 = __aeabi_fmul(temp19,temp9);\n      f1Mul1 = __addsf3(f1Mul1,temp5);\n      temp5 = __aeabi_fmul(f2Mul1,norm2);\n      f1Mul1 = __aeabi_fsub(f1Mul1,temp5);\n      temp5 = __aeabi_fmul(normZero2,inverse2);\n      temp5 = __aeabi_fmul(temp5,temp19);\n      f1Mul1 = __addsf3(f1Mul1,temp5);\n      temp5 = __aeabi_fmul(f2Mul3,norm2);\n      f1Mul1 = __aeabi_fsub(f1Mul1,temp5);\n      temp5 = __aeabi_fmul(f3Mul1,norm2);\n      f1Mul1 = __addsf3(f1Mul1,temp5);\n      temp15 = (float)__addsf3(f1Mul1,f1Mul1);\n      temp5 = __addsf3(f2Mul2);\n      temp7 = __aeabi_fmul(temp18,normZero1);\n      temp5 = __aeabi_fsub(temp5,temp7);\n      temp7 = __aeabi_fmul(acceleration_x,norm1);\n      temp5 = __aeabi_fsub(temp5,temp7);\n      temp7 = __aeabi_fmul(temp19,normZero2);\n      temp9 = __addsf3(f1Mul2);\n      temp7 = __addsf3(temp7,temp9);\n      temp9 = __aeabi_fmul(acceleration_y,norm1);\n      temp7 = __aeabi_fsub(temp7,temp9);\n      temp9 = __aeabi_fmul(temp18,f1Mul1);\n      temp11 = __aeabi_fsub(0x3f000000,f2Mul3);\n      f3Mul1 = __aeabi_fsub(temp11,f3Mul1);\n      f3Mul1 = __aeabi_fmul(f3Mul1,normZero3);\n      temp11 = __aeabi_fsub(f2Mul2,f1Mul3);\n      temp11 = __aeabi_fmul(temp11,f1Mul1);\n      f3Mul1 = __addsf3(f3Mul1,temp11);\n      f3Mul1 = __aeabi_fsub(f3Mul1,inverse1);\n      inverse1 = __aeabi_fmul(temp23,f1Mul1);\n      temp11 = __aeabi_fmul(temp23,temp18);\n      temp12 = __aeabi_fmul(temp17,temp19);\n      temp11 = __aeabi_fsub(temp11,temp12);\n      temp11 = __aeabi_fmul(temp11,normZero3);\n      temp12 = __aeabi_fmul(temp18,temp19);\n      f1Mul2 = __addsf3(temp12,f1Mul2);\n      f1Mul2 = __aeabi_fmul(f1Mul2,f1Mul1);\n      f1Mul2 = __addsf3(temp11,f1Mul2);\n      f1Mul2 = __aeabi_fsub(f1Mul2,inverse2);\n      inverse2 = __aeabi_fmul(temp18,normZero3);\n      temp11 = __aeabi_fsub(0x3f000000,f2Mul1);\n      temp11 = __aeabi_fsub(temp11,f2Mul3);\n      temp11 = __aeabi_fmul(temp11,f1Mul1);\n      f1Mul3 = __addsf3(f1Mul3,f2Mul2);\n      f1Mul3 = __aeabi_fmul(f1Mul3,normZero3);\n      f1Mul3 = __addsf3(temp11,f1Mul3);\n      norm2 = __aeabi_fsub(f1Mul3,norm2);\n      f1Mul3 = __aeabi_fmul(normZero2 + -0x80000000,temp5);\n      f2Mul2 = __aeabi_fmul(norm6,temp7);\n      f1Mul3 = __addsf3(f1Mul3,f2Mul2);\n      f2Mul2 = __aeabi_fmul(temp9,f3Mul1);\n      f1Mul3 = __aeabi_fsub(f1Mul3,f2Mul2);\n      f2Mul2 = __aeabi_fmul(temp19,normZero3 + -0x80000000);\n      f2Mul2 = __addsf3(f2Mul2,inverse1);\n      f2Mul2 = __aeabi_fmul(f2Mul2,f1Mul2);\n      f1Mul3 = __addsf3(f1Mul3,f2Mul2);\n      f2Mul2 = __aeabi_fmul(inverse2,norm2);\n      f1Mul3 = __addsf3(f1Mul3,f2Mul2);\n      f2Mul1 = __addsf3(f2Mul1);\n      f2Mul1 = __aeabi_fsub(0x3f800000,f2Mul1);\n      f2Mul2 = __addsf3(f2Mul3);\n      f2Mul1 = __aeabi_fsub(f2Mul1,f2Mul2);\n      norm1 = __aeabi_fmul(acceleration_z,norm1);\n      norm1 = __aeabi_fsub(f2Mul1,norm1);\n      f2Mul1 = __aeabi_fmul(temp19,f1Mul1);\n      f1Mul1 = __aeabi_fmul(temp17,f1Mul1);\n      f2Mul2 = __aeabi_fmul(norm7,temp5);\n      f2Mul3 = __aeabi_fmul(normZero1,temp7);\n      f2Mul2 = __addsf3(f2Mul2,f2Mul3);\n      f2Mul3 = __aeabi_fmul(temp23,0x40800000);\n      f2Mul3 = __aeabi_fmul(f2Mul3,norm1);\n      f2Mul2 = __aeabi_fsub(f2Mul2,f2Mul3);\n      f2Mul3 = __aeabi_fmul(f3Mul1,f2Mul1);\n      f2Mul2 = __addsf3(f2Mul2,f2Mul3);\n      f2Mul3 = __addsf3(inverse2,f1Mul1);\n      f2Mul3 = __aeabi_fmul(f2Mul3,f1Mul2);\n      f2Mul2 = __addsf3(f2Mul2,f2Mul3);\n      f2Mul3 = __aeabi_fmul(temp19,normZero3);\n      inverse2 = __aeabi_fmul(temp23,temp15);\n      f2Mul3 = __aeabi_fsub(f2Mul3,inverse2);\n      f2Mul3 = __aeabi_fmul(f2Mul3,norm2);\n      f2Mul2 = __addsf3(f2Mul2,f2Mul3);\n      temp3 = __addsf3(normZero3,normZero3);\n      f2Mul3 = __aeabi_fmul(temp23,normZero3);\n      inverse2 = __aeabi_fmul(normZero1 + -0x80000000,temp5);\n      norm7 = __aeabi_fmul(norm7,temp7);\n      norm7 = __addsf3(inverse2,norm7);\n      inverse2 = __aeabi_fmul(temp18,0x40800000);\n      norm1 = __aeabi_fmul(inverse2,norm1);\n      norm1 = __aeabi_fsub(norm7,norm1);\n      norm7 = __aeabi_fmul(temp18,temp3 + -0x80000000);\n      norm7 = __aeabi_fsub(norm7,f1Mul1);\n      norm7 = __aeabi_fmul(norm7,f3Mul1);\n      norm1 = __addsf3(norm1,norm7);\n      norm7 = __addsf3(f2Mul1,f2Mul3);\n      norm7 = __aeabi_fmul(norm7,f1Mul2);\n      norm1 = __addsf3(norm1,norm7);\n      norm7 = __aeabi_fmul(temp17,normZero3);\n      f1Mul1 = __aeabi_fmul(temp18,temp15);\n      norm7 = __aeabi_fsub(norm7,f1Mul1);\n      norm7 = __aeabi_fmul(norm7,norm2);\n      norm1 = __addsf3(norm1,norm7);\n      norm6 = __aeabi_fmul(norm6,temp5);\n      norm7 = __aeabi_fmul(normZero2,temp7);\n      norm6 = __addsf3(norm6,norm7);\n      norm7 = __aeabi_fmul(temp19,temp3 + -0x80000000);\n      norm7 = __addsf3(norm7,inverse1);\n      norm7 = __aeabi_fmul(norm7,f3Mul1);\n      norm6 = __addsf3(norm6,norm7);\n      norm7 = __aeabi_fmul(temp17,normZero3 + -0x80000000);\n      norm7 = __addsf3(norm7,temp9);\n      norm7 = __aeabi_fmul(norm7,f1Mul2);\n      norm6 = __addsf3(norm6,norm7);\n      norm2 = __aeabi_fmul(norm2,f2Mul3);\n      norm2 = __addsf3(norm6,norm2);\n      norm6 = __aeabi_fmul(f1Mul3);\n      norm7 = __aeabi_fmul(f2Mul2);\n      norm6 = __addsf3(norm6,norm7);\n      norm7 = __aeabi_fmul(norm1,norm1);\n      norm6 = __addsf3(norm6,norm7);\n      norm7 = __aeabi_fmul(norm2,norm2);\n      __addsf3(norm6,norm7);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(temp23,temp22));\n      norm6 = __truncdfsf2();\n      norm6 = __aeabi_fdiv(0x3f800000,norm6);\n      temp1 = beta;\n      norm7 = __aeabi_fmul((int)temp23 + -0x80000000,norm3);\n      f1Mul1 = __aeabi_fmul(temp18,norm4);\n      norm7 = __aeabi_fsub(norm7,f1Mul1);\n      f1Mul1 = __aeabi_fmul(temp19,norm5);\n      norm7 = __aeabi_fsub(norm7,f1Mul1);\n      norm7 = __aeabi_fmul(norm7,0x3f000000);\n      f1Mul1 = __aeabi_fmul(f1Mul3,norm6);\n      temp2 = deltat;\n      f1Mul1 = __aeabi_fmul(f1Mul1,temp1);\n      norm7 = __aeabi_fsub(norm7,f1Mul1);\n      norm7 = __aeabi_fmul(norm7,temp2);\n      norm7 = __addsf3(norm7,temp17);\n      f1Mul1 = __aeabi_fmul(temp17,norm3);\n      f1Mul2 = __aeabi_fmul(temp18,norm5);\n      temp2 = deltat;\n      f1Mul1 = __addsf3(f1Mul1,f1Mul2);\n      f1Mul2 = __aeabi_fmul(temp19,norm4);\n      f1Mul1 = __aeabi_fsub(f1Mul1,f1Mul2);\n      f1Mul1 = __aeabi_fmul(f1Mul1,0x3f000000);\n      f1Mul2 = __aeabi_fmul(f2Mul2,norm6);\n      f1Mul2 = __aeabi_fmul(f1Mul2,temp1);\n      f1Mul1 = __aeabi_fsub(f1Mul1,f1Mul2);\n      f1Mul1 = __aeabi_fmul(f1Mul1,temp2);\n      f1Mul1 = __addsf3(f1Mul1,temp23);\n      temp2 = deltat;\n      f1Mul2 = __aeabi_fmul(temp17,norm4);\n      f1Mul3 = __aeabi_fmul(temp23,norm5);\n      f1Mul2 = __aeabi_fsub(f1Mul2,f1Mul3);\n      f1Mul3 = __aeabi_fmul(temp19,norm3);\n      f1Mul2 = __addsf3(f1Mul2,f1Mul3);\n      f1Mul2 = __aeabi_fmul(f1Mul2,0x3f000000);\n      norm1 = __aeabi_fmul(norm1,norm6);\n      norm1 = __aeabi_fmul(norm1,temp1);\n      norm1 = __aeabi_fsub(f1Mul2,norm1);\n      norm1 = __aeabi_fmul(norm1,temp2);\n      norm1 = __addsf3(norm1,temp18);\n      norm5 = __aeabi_fmul(temp17,norm5);\n      norm4 = __aeabi_fmul(temp23,norm4);\n      norm4 = __addsf3(norm5,norm4);\n      norm3 = __aeabi_fmul(temp18,norm3);\n      norm3 = __aeabi_fsub(norm4,norm3);\n      norm3 = __aeabi_fmul(norm3,0x3f000000);\n      norm2 = __aeabi_fmul(norm2,norm6);\n      norm2 = __aeabi_fmul(norm2,temp1);\n      temp17 = deltat;\n      norm2 = __aeabi_fsub(norm3,norm2);\n      norm2 = __aeabi_fmul(norm2,temp17);\n      norm2 = __addsf3(norm2,temp19);\n      norm3 = __aeabi_fmul(norm7,norm7);\n      norm5 = __aeabi_fmul(f1Mul1,f1Mul1);\n      norm3 = __addsf3(norm3,norm5);\n      norm5 = __aeabi_fmul(norm1,norm1);\n      norm3 = __addsf3(norm3,norm5);\n      norm5 = __aeabi_fmul(norm2,norm2);\n      __addsf3(norm3,norm5);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(norm4,temp22));\n      norm3 = __truncdfsf2();\n      norm3 = __aeabi_fdiv(0x3f800000,norm3);\n      temp17 = (float)__aeabi_fmul(norm7,norm3);\n      q[0] = temp17;\n      temp18 = (float)__aeabi_fmul(f1Mul1,norm3);\n      q[1] = temp18;\n      temp19 = (float)__aeabi_fmul(norm1,norm3);\n      q[2] = temp19;\n      q[3] = (float)__aeabi_fmul(norm2,norm3);\n      norm1 = __aeabi_fmul(temp18,q[3]);\n      norm2 = __aeabi_fmul(temp17,temp19);\n      norm1 = __aeabi_fsub(norm1,norm2);\n      __addsf3(norm1,norm1);\n      __aeabi_f2d();\n      asin((double)CONCAT44(norm4,temp22));\n      temp20 = __muldf3();\n      __divdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x54442d18,0x400921fb);\n      temp17 = (float)__truncdfsf2();\n      *result_angle = temp17;\n      temp18 = q[1];\n      temp17 = q[0];\n      norm1 = __aeabi_fmul(q[0],q[0]);\n      norm2 = __aeabi_fmul(temp18,temp18);\n      norm1 = __aeabi_fsub(norm1,norm2);\n      temp19 = q[2];\n      norm2 = __aeabi_fmul(q[2],q[2]);\n      norm1 = __aeabi_fsub(norm1,norm2);\n      temp23 = q[3];\n      norm2 = __aeabi_fmul(q[3],q[3]);\n      __addsf3(norm1,norm2);\n      temp20 = __aeabi_f2d();\n      norm1 = __aeabi_fmul(temp17,temp18);\n      norm2 = __aeabi_fmul(temp19,temp23);\n      norm1 = __addsf3(norm1,norm2);\n      __addsf3(norm1,norm1);\n      temp21 = __aeabi_f2d();\n      temp20 = atan2((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp20,\n                     (int)((ulonglong)temp20 >> 0x20));\n      temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0,0x40668000);\n      __divdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x54442d18,0x400921fb);\n      temp17 = (float)__truncdfsf2();\n      result_angle[1] = temp17;\n      temp18 = q[1];\n      temp17 = q[0];\n      norm1 = __aeabi_fmul(q[0],q[0]);\n      norm2 = __aeabi_fmul(temp18,temp18);\n      norm1 = __addsf3(norm1,norm2);\n      temp19 = q[2];\n      norm2 = __aeabi_fmul(q[2],q[2]);\n      norm1 = __aeabi_fsub(norm1,norm2);\n      temp23 = q[3];\n      norm2 = __aeabi_fmul(q[3],q[3]);\n      __aeabi_fsub(norm1,norm2);\n      temp20 = __aeabi_f2d();\n      norm1 = __aeabi_fmul(temp18,temp19);\n      norm2 = __aeabi_fmul(temp17,temp23);\n      norm1 = __addsf3(norm1,norm2);\n      __addsf3(norm1,norm1);\n      temp21 = __aeabi_f2d();\n      temp20 = atan2((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp20,\n                     (int)((ulonglong)temp20 >> 0x20));\n      temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0,0x40668000);\n      __divdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x54442d18,0x400921fb);\n      temp17 = (float)__truncdfsf2();\n      result_angle[2] = temp17;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003330": "calculate_angles_08003330",
                "ax": "acceleration_x",
                "ay": "acceleration_y",
                "az": "acceleration_z",
                "gx": "gyroscope_x",
                "gy": "gyroscope_y",
                "gz": "gyroscope_z",
                "mx": "magneticField_x",
                "my": "magneticField_y",
                "mz": "magneticField_z",
                "angle": "result_angle",
                "fVar1": "temp1",
                "fVar2": "temp2",
                "uVar3": "norm1",
                "uVar4": "norm2",
                "uVar5": "norm3",
                "iVar6": "normZero1",
                "uVar7": "norm4",
                "uVar8": "norm5",
                "uVar9": "norm6",
                "iVar10": "normZero2",
                "uVar11": "norm7",
                "uVar12": "f1Mul1",
                "uVar13": "f1Mul2",
                "uVar14": "f1Mul3",
                "uVar15": "f2Mul1",
                "uVar16": "f2Mul2",
                "uVar17": "f2Mul3",
                "uVar18": "f3Mul1",
                "uVar19": "inverse1",
                "uVar20": "inverse2",
                "iVar21": "temp3",
                "_2q1mx": "temp4",
                "uVar22": "temp5",
                "_2q1my": "temp6",
                "uVar23": "temp7",
                "_2q1mz": "temp8",
                "uVar24": "temp9",
                "_2q2mx": "temp10",
                "uVar25": "temp11",
                "uVar26": "temp12",
                "uVar27": "temp13",
                "iVar28": "normZero3",
                "_2bx": "temp14",
                "_2bz": "temp15",
                "_4bz": "temp16",
                "fVar29": "temp17",
                "fVar30": "temp18",
                "fVar31": "temp19",
                "q1": "quaternion1",
                "q2": "quaternion2",
                "q3": "quaternion3",
                "q4": "quaternion4",
                "uVar32": "temp20",
                "uVar33": "temp21",
                "in_stack_ffffff78": "temp22",
                "fVar34": "temp23",
                "hy": "gyroscope_y_corrected",
                "hx": "gyroscope_x_corrected"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fdiv",
                "__aeabi_fcmpeq",
                "__addsf3",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_fmul",
                "atan2",
                "sqrt",
                "__divdf3",
                "asin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "execute_software_interrupt_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_08003eac(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "execute_software_interrupt_08003eac"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eb0": {
            "entrypoint": "0x08003eb0",
            "current_name": "execute_afl_call_08003eb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_08003eb0(int ticks)\n\n{\n  uint32_t aflReturnValue;\n  \n  if (isHyperCallDisabled == 0) {\n    aflReturnValue = aflCall(1,ticks,0);\n    return aflReturnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003eb0": "execute_afl_call_08003eb0",
                "noHyperCall": "isHyperCallDisabled",
                "uVar1": "aflReturnValue"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ec8": {
            "entrypoint": "0x08003ec8",
            "current_name": "append_to_circular_buffer_08003ec8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint appendToCircularBuffer_08003ec8(CircularBuffer *cb,uint8_t newData)\n\n{\n  cb->bufferSize = cb->bufferSize + 1;\n  cb->buffer[cb->writeIndex] = newData;\n  cb->writeIndex = cb->writeIndex + 1 & 0x7ff;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003ec8": "append_to_circular_buffer_08003ec8",
                "data": "newData",
                "size": "bufferSize",
                "tail": "writeIndex"
            },
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ef2": {
            "entrypoint": "0x08003ef2",
            "current_name": "initialize_circular_buffer_08003ef2",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeCircularBuffer_08003ef2(CindexrcularBuffer *cb)\n\n{\n  indexnt index;\n  \n  index = 0;\n  cb->head = 0;\n  cb->taindexl = 0;\n  cb->sindexze = 0;\n  do {\n    cb->buffer[index] = '\\0';\n    index = index + 1;\n  } whindexle (index != 0x800);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ef2": "initialize_circular_buffer_08003ef2",
                "i": "index"
            },
            "calling": [
                "serialFlush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0e": {
            "entrypoint": "0x08003f0e",
            "current_name": "update_last_value_08003f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat updateLastValue_08003f0e(LPF *pointerToLPF,float input)\n\n{\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  float betaValue;\n  float returnValue;\n  \n  betaValue = pointerToLPF->beta;\n  tempVar1 = __aeabi_fsub(0x3f800000,betaValue);\n  tempVar1 = __aeabi_fmul(tempVar1,input);\n  tempVar2 = __aeabi_fmul(betaValue,pointerToLPF->last);\n  betaValue = (float)__addsf3(tempVar2,tempVar1);\n  pointerToLPF->last = betaValue;\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003f0e": "update_last_value_08003f0e",
                "var": "pointerToLPF",
                "current": "input",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "fVar3": "betaValue",
                "extraout_s0": "returnValue"
            },
            "calling": [
                "AHRS_GetRoll",
                "AHRS_GetPitch"
            ],
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f3c": {
            "entrypoint": "0x08003f3c",
            "current_name": "set_led_pins_08003f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_led_pins_08003f3c(int is_white_led_on,int is_red_led_on,int is_blue_led_on)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,is_white_led_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,is_red_led_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,is_blue_led_on == 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f3c": "set_led_pins_08003f3c",
                "led_white": "is_white_led_on",
                "led_red": "is_red_led_on",
                "led_blue": "is_blue_led_on"
            },
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f7c": {
            "entrypoint": "0x08003f7c",
            "current_name": "blink_le_ds_08003f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid blinkLEDs_08003f7c(void)\n\n{\n  int count;\n  \n  count = 3;\n  do {\n    toggleLED(1,0,0);\n    delay_ms(100);\n    toggleLED(0,1,0);\n    delay_ms(100);\n    toggleLED(0,0,1);\n    delay_ms(100);\n    count = count + -1;\n  } while (count != 0);\n  toggleLED(1,1,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f7c": "blink_le_ds_08003f7c",
                "iVar1": "count"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fc4": {
            "entrypoint": "0x08003fc4",
            "current_name": "set_pwm_value_08003fc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_PWM_value_08003fc4(int new_PWM_value)\n\n{\n  (htim4.Instance)->CCR4 = new_PWM_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fc4": "set_pwm_value_08003fc4",
                "pwm": "new_PWM_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd0": {
            "entrypoint": "0x08003fd0",
            "current_name": "set_pwm_value_08003fd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPwmValue_08003fd0(int pwmValue)\n\n{\n  (htim4.Instance)->CCR3 = pwmValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd0": "set_pwm_value_08003fd0",
                "pwm": "pwmValue"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fdc": {
            "entrypoint": "0x08003fdc",
            "current_name": "set_pwm_08003fdc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_08003fdc(int new_pwm)\n\n{\n  (timer2.Instance)->CCR2 = new_pwm;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fdc": "set_pwm_08003fdc",
                "pwm": "new_pwm",
                "htim2": "timer2"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fe8": {
            "entrypoint": "0x08003fe8",
            "current_name": "set_pwm_value_08003fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPwmValue_08003fe8(int pwmValue)\n\n{\n  (htim3.Instance)->CCR3 = pwmValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fe8": "set_pwm_value_08003fe8",
                "pwm": "pwmValue"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff4": {
            "entrypoint": "0x08003ff4",
            "current_name": "start_pwm_timers_08003ff4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid start_PWM_timers_08003ff4(void)\n\n{\n  HAL_TIM_PWM_Start(timer2_PWM_channel4,4);\n  HAL_TIM_PWM_Start(timer3_PWM_channel8,8);\n  HAL_TIM_PWM_Start(timer4_PWM_channel8,8);\n  HAL_TIM_PWM_Start(timer4_PWM_channel8,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff4": "start_pwm_timers_08003ff4",
                "&htim2": "timer2_PWM_channel4",
                "&htim3": "timer3_PWM_channel8",
                "&htim4": "timer4_PWM_channel8"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004028": {
            "entrypoint": "0x08004028",
            "current_name": "initialize_peripheral_devices_08004028",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_peripheral_devices_08004028(void)\n\n{\n  initialize_peripherals();\n  initialize_PWM();\n  perform_LED_startup_sequence();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004028": "initialize_peripheral_devices_08004028",
                "Peripherals_Init": "initialize_peripherals",
                "PWM_Init": "initialize_PWM",
                "LED_StartupSequence": "perform_LED_startup_sequence"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "Peripherals_Init",
                "LED_StartupSequence",
                "PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800403c": {
            "entrypoint": "0x0800403c",
            "current_name": "write_register_to_i2_c_device_0800403c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeRegisterToI2CDevice_0800403c(uint16_t deviceAddress,uint16_t registerAddress,uint8_t registerValue,uint8_t enableDelay)\n\n{\n  HAL_StatusTypeDef writeStatus;\n  uint8_t returnValue;\n  uint8_t dataByte [1];\n  \n  dataByte[0] = registerValue;\n  writeStatus = HAL_I2C_Mem_Write(&hi2c1,deviceAddress,registerAddress,1,dataByte,1,200);\n  if (writeStatus != HAL_OK) {\n    _Error_Handler(\"../Src/i2c.c\",0x1b);\n  }\n  if (enableDelay != '\\0') {\n    delay_ms(0x32);\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_0800403c": "write_register_to_i2_c_device_0800403c",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "register_val": "registerValue",
                "delay_mode": "enableDelay",
                "HVar1": "writeStatus",
                "ret": "returnValue",
                "byte": "dataByte"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "MS5611_Init",
                "MS5611_Update"
            ],
            "called": [
                "delay_ms",
                "HAL_I2C_Mem_Write",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "read_i2c_byte_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t read_i2c_byte_0800407c(uint16_t device_address,uint16_t register_address,char *file_name,int line_number)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t result;\n  uint8_t data [1];\n  \n  data[0] = '\\0';\n  status = HAL_I2C_Mem_Read(&hi2c1,device_address,register_address,1,data,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(file_name,line_number);\n  }\n  resulturn data[0];\n}\n\n",
            "renaming": {
                "FUN_0800407c": "read_i2c_byte_0800407c",
                "device_add": "device_address",
                "register_add": "register_address",
                "file": "file_name",
                "line": "line_number",
                "HVar1": "status",
                "ret": "result",
                "byte": "data"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b8": {
            "entrypoint": "0x080040b8",
            "current_name": "read_i2_c_memory_080040b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readI2CMemory_080040b8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *data,uint16_t dataSize,char *fileName,\n                 int lineNumber)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t ret;\n  \n  status = HAL_I2C_Mem_Read(&hi2c1,deviceAddress,registerAddress,1,data,dataSize,200);\n  if (status != HAL_OK) {\n    _Error_Handler(fileName,lineNumber);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040b8": "read_i2_c_memory_080040b8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "bytes": "data",
                "size": "dataSize",
                "file": "fileName",
                "line": "lineNumber",
                "HVar1": "status"
            },
            "calling": [
                "MS5611_ReadADC"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "read_and_save_byte_array_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndSaveByteArray_080040e8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *dataArray,uint16_t arraySize,\n                 char *filePath,int lineNumber)\n\n{\n  uint8_t readValue;\n  int index;\n  uint8_t *outputArray;\n  \n  outputArray = dataArray + -1;\n  for (index = 0; index < (int)(uint)arraySize; index = index + 1) {\n    readValue = I2C_ReadByte(deviceAddress,registerAddress + (short)index,\"../Src/i2c.c\",0x4c);\n    outputArray = outputArray + 1;\n    *outputArray = readValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "read_and_save_byte_array_080040e8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "byte_array": "dataArray",
                "size": "arraySize",
                "file": "filePath",
                "line": "lineNumber",
                "uVar1": "readValue",
                "iVar2": "index",
                "puVar3": "outputArray"
            },
            "calling": [
                "AK8963_Init",
                "MS5611_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData"
            ],
            "called": [
                "I2C_ReadByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800411c": {
            "entrypoint": "0x0800411c",
            "current_name": "update_sensors_data_0800411c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateSensorsData_0800411c(void)\n\n{\n  uint32_t currentTime;\n  \n  currentTime = millis();\n  if (1 < currentTime - previousTick1) {\n    previousTick1 = millis();\n    AHRS_ComputeAngles();\n  }\n  currentTime = millis();\n  if (2 < currentTime - previousTick3) {\n    previousTick3 = millis();\n    PID_Update();\n  }\n  currentTime = millis();\n  if (3 < currentTime - previousTick2) {\n    previousTick2 = millis();\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800411c": "update_sensors_data_0800411c",
                "uVar1": "currentTime",
                "last_tick1": "previousTick1",
                "last_tick2": "previousTick2",
                "last_tick3": "previousTick3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "MSP_SendMotor",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendAltitude",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendPID",
                "millis",
                "MSP_SendIdent",
                "MS5611_Update",
                "MSP_SendRawIMU"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004194": {
            "entrypoint": "0x08004194",
            "current_name": "initialize_system_08004194",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08004194(void)\n\n{\n  initializeDevices();\n  initializeSerial();\n  initializeIMU();\n  initializeMS5611();\n  initializePID();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004194": "initialize_system_08004194",
                "Devices_Init": "initializeDevices",
                "serialBegin": "initializeSerial",
                "IMU_Init": "initializeIMU",
                "MS5611_Init": "initializeMS5611",
                "PID_Init": "initializePID"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PID_Init",
                "Devices_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ae": {
            "entrypoint": "0x080041ae",
            "current_name": "continuous_task_080041ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint continuousTask_080041ae(void)\n\n{\n  initializeForkserver(0);\n  initialize();\n  do {\n    incrementSystemTick();\n    executeTaskScheduler();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080041ae": "continuous_task_080041ae",
                "startForkserver": "initializeForkserver",
                "setup": "initialize",
                "HAL_IncTick": "incrementSystemTick",
                "taskScheduler": "executeTaskScheduler"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "taskScheduler",
                "HAL_IncTick",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041c4": {
            "entrypoint": "0x080041c4",
            "current_name": "stop_motors_080041c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopMotors_080041c4(void)\n\n{\n  setMotor1PWM(0);\n  setMotor2PWM(0);\n  setMotor3PWM(0);\n  setMotor4PWM(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041c4": "stop_motors_080041c4",
                "Motor1_SetPWM": "setMotor1PWM",
                "Motor2_SetPWM": "setMotor2PWM",
                "Motor3_SetPWM": "setMotor3PWM",
                "Motor4_SetPWM": "setMotor4PWM"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041e4": {
            "entrypoint": "0x080041e4",
            "current_name": "set_motor_pwm_080041e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_motor_pwm_080041e4(int motor1_pwm,int motor2_pwm,int motor3_pwm,int motor4_pwm)\n\n{\n  if (999 < motor1_pwm) {\n    motor1_pwm = 1000;\n  }\n  if (999 < motor2_pwm) {\n    motor2_pwm = 1000;\n  }\n  if (999 < motor3_pwm) {\n    motor3_pwm = 1000;\n  }\n  if (999 < motor4_pwm) {\n    motor4_pwm = 1000;\n  }\n  motor_pwm_values[2] = motor3_pwm & ~(motor3_pwm >> 0x1f);\n  motor_pwm_values[3] = motor4_pwm & ~(motor4_pwm >> 0x1f);\n  motor_pwm_values[1] = motor2_pwm & ~(motor2_pwm >> 0x1f);\n  motor_pwm_values[0] = motor1_pwm & ~(motor1_pwm >> 0x1f);\n  set_motor1_pwm(motor_pwm_values[0]);\n  set_motor2_pwm(motor_pwm_values[1]);\n  set_motor3_pwm(motor_pwm_values[2]);\n  set_motor4_pwm(motor_pwm_values[3]);\n  msp_transmitting_motor.motor[0] = (short)motor_pwm_values[0] + 1000;\n  msp_transmitting_motor.motor[1] = (short)motor_pwm_values[1] + 1000;\n  msp_transmitting_motor.motor[2] = (short)motor_pwm_values[2] + 1000;\n  msp_transmitting_motor.motor[3] = (short)motor_pwm_values[3] + 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041e4": "set_motor_pwm_080041e4",
                "m1": "motor1_pwm",
                "m2": "motor2_pwm",
                "m3": "motor3_pwm",
                "m4": "motor4_pwm",
                "motor_pwm": "motor_pwm_values",
                "Motor1_SetPWM": "set_motor1_pwm",
                "Motor2_SetPWM": "set_motor2_pwm",
                "Motor3_SetPWM": "set_motor3_pwm",
                "Motor4_SetPWM": "set_motor4_pwm",
                "msp_txf_motor": "msp_transmitting_motor"
            },
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800426c": {
            "entrypoint": "0x0800426c",
            "current_name": "update_motor_speeds_0800426c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMotorSpeeds_0800426c(float throttleInput,float pitchInput,float rollInput,float yawInput)\n\n{\n  undefined4 throttleMinusRoll;\n  undefined4 throttlePlusPitch;\n  undefined4 throttleMinusRollPlusYaw;\n  int motor4Speed;\n  int motor3Speed;\n  int motor2Speed;\n  int motor1Speed;\n  \n  throttleMinusRoll = __aeabi_fsub();\n  throttlePlusPitch = __addsf3(throttleInput,pitchInput);\n  throttleMinusRollPlusYaw = __aeabi_fsub(throttleMinusRoll,rollInput);\n  throttleMinusRollPlusYaw = __addsf3(throttleMinusRollPlusYaw,yawInput);\n  __aeabi_fsub(throttleMinusRollPlusYaw,0x447a0000);\n  motor4Speed = __aeabi_f2iz();\n  throttleMinusRollPlusYaw = __aeabi_fsub(throttlePlusPitch,rollInput);\n  throttleMinusRollPlusYaw = __aeabi_fsub(throttleMinusRollPlusYaw,yawInput);\n  __aeabi_fsub(throttleMinusRollPlusYaw,0x447a0000);\n  motor3Speed = __aeabi_f2iz();\n  throttleMinusRoll = __addsf3(throttleMinusRoll,rollInput);\n  throttleMinusRoll = __aeabi_fsub(throttleMinusRoll,yawInput);\n  __aeabi_fsub(throttleMinusRoll,0x447a0000);\n  motor2Speed = __aeabi_f2iz();\n  throttleMinusRoll = __addsf3(rollInput,throttlePlusPitch);\n  throttleMinusRoll = __addsf3(throttleMinusRoll,yawInput);\n  __aeabi_fsub(throttleMinusRoll,0x447a0000);\n  motor1Speed = __aeabi_f2iz();\n  Motor_SetSpeed(motor1Speed,motor2Speed,motor3Speed,motor4Speed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800426c": "update_motor_speeds_0800426c",
                "throttle": "throttleInput",
                "pitch": "pitchInput",
                "roll": "rollInput",
                "yaw": "yawInput",
                "uVar1": "throttleMinusRoll",
                "uVar2": "throttlePlusPitch",
                "uVar3": "throttleMinusRollPlusYaw",
                "m4": "motor4Speed",
                "m3": "motor3Speed",
                "m2": "motor2Speed",
                "m1": "motor1Speed"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_f2iz",
                "__addsf3",
                "__aeabi_fsub",
                "Motor_SetSpeed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004300": {
            "entrypoint": "0x08004300",
            "current_name": "send_encoded_data_08004300",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendEncodedData_08004300(uint8_t encryptionKey,uint8_t *inputData,uint16_t inputDataLength)\n\n{\n  byte checksum;\n  byte *currentByte;\n  \n  serialPrint(\"$M>\");\n  serialWrite((byte)inputDataLength);\n  checksum = (byte)inputDataLength ^ encryptionKey;\n  serialWrite(encryptionKey);\n  for (currentByte = inputData; (int)currentByte - (int)inputData < (int)(uint)inputDataLength; currentByte = currentByte + 1) {\n    serialWrite(*currentByte);\n    checksum = checksum ^ *currentByte;\n  }\n  serialWrite(checksum);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004300": "send_encoded_data_08004300",
                "code": "encryptionKey",
                "data": "inputData",
                "data_length": "inputDataLength",
                "ch": "checksum",
                "pbVar1": "currentByte"
            },
            "calling": [
                "MSP_SendMotor",
                "MSP_SendAttitude",
                "MSP_SendStatus",
                "MSP_SendAltitude",
                "MSP_SendPID",
                "MSP_SendIdent",
                "MSP_SendRawIMU"
            ],
            "called": [
                "serialWrite",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004348": {
            "entrypoint": "0x08004348",
            "current_name": "transmit_data_08004348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08004348(void)\n\n{\n  uint inputData;\n  uint8_t buffer [7];\n  undefined4 transmitIdent;\n  uint maskedInputData;\n  \n  msp_txf_ident._0_4_ = 0x40003e9;\n  msp_txf_ident.capability._1_2_ = 0;\n  msp_txf_ident.capability._3_1_ = 0;\n  transmitIdent = 0x40003e9;\n  maskedInputData = inputData & 0xff000000;\n  MSP_SendFrame('d',(uint8_t *)&transmitIdent,7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004348": "transmit_data_08004348",
                "in_r1": "inputData",
                "buff": "buffer",
                "local_10": "transmitIdent",
                "local_c": "maskedInputData"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004384": {
            "entrypoint": "0x08004384",
            "current_name": "send_frame_with_data_08004384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameWithData_08004384(void)\n\n{\n  uint inputValue;\n  undefined4 statusPart1;\n  undefined4 statusPart2;\n  uint maskedInput;\n  \n  txStatusPart1 = 0x2a0007;\n  statusPart1 = txStatusPart2;\n  statusPart2 = 0x2a0007;\n  txFlag = 0;\n  txCurrentSet = '\\0';\n  maskedInput = inputValue & 0xff000000;\n  MSP_SendFrame('e',(uint8_t *)&statusPart1,0xb);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004384": "send_frame_with_data_08004384",
                "in_r3": "inputValue",
                "local_14": "statusPart1",
                "uStack_10": "statusPart2",
                "local_c": "maskedInput",
                "msp_txf_status._4_4_": "txStatusPart1",
                "msp_txf_status._0_4_": "txStatusPart2",
                "msp_txf_status.flag._2_2_": "txFlag",
                "msp_txf_status.current_set": "txCurrentSet"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043bc": {
            "entrypoint": "0x080043bc",
            "current_name": "copy_imu_data_and_send_frame_080043bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid copyImuDataAndSendFrame_080043bc(void)\n\n{\n  undefined4 sensorValue1;\n  undefined4 sensorValue2;\n  undefined4 *bufferPointer;\n  msp_raw_imu *imuPointer;\n  uint8_t buffer [18];\n  \n  imuPointer = &msp_txf_raw_imu;\n  bufferPointer = (undefined4 *)buffer;\n  do {\n    sensorValue1 = *(undefined4 *)imuPointer;\n    sensorValue2 = *(undefined4 *)&imuPointer->accz;\n    imuPointer = (msp_raw_imu *)&imuPointer->gyry;\n    *bufferPointer = sensorValue1;\n    bufferPointer[1] = sensorValue2;\n    bufferPointer = bufferPointer + 2;\n  } while (imuPointer != (msp_raw_imu *)&msp_txf_raw_imu.magz);\n  *(int16_t *)bufferPointer = msp_txf_raw_imu.magz;\n  MSP_SendFrame('f',buffer,0x12);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043bc": "copy_imu_data_and_send_frame_080043bc",
                "uVar1": "sensorValue1",
                "uVar2": "sensorValue2",
                "puVar3": "bufferPointer",
                "pmVar4": "imuPointer",
                "buff": "buffer"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043f0": {
            "entrypoint": "0x080043f0",
            "current_name": "send_motor_data_080043f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendMotorData_080043f0(void)\n\n{\n  uint8_t buffer [8];\n  undefined4 motorData1;\n  undefined4 motorData2;\n  \n  motorData1 = msp_txf_motor.motor._0_4_;\n  motorData2 = msp_txf_motor.motor._4_4_;\n  MSP_SendFrame('h',(uint8_t *)&motorData1,8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "buff": "buffer",
                "local_10": "motorData1",
                "uStack_c": "motorData2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004410": {
            "entrypoint": "0x08004410",
            "current_name": "send_attitude_data_08004410",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid send_attitude_data_08004410(void)\n\n{\n  undefined4 input_data;\n  uint8_t data_buffer [6];\n  undefined4 attitude_value_1;\n  undefined4 attitude_value_2;\n  \n  attitude_value_1 = msp_txf_attitude._0_4_;\n  attitude_value_2 = CONCAT22((short)((uint)input_data >> 0x10),msp_txf_attitude.heading);\n  MSP_SendFrame('l',(uint8_t *)&attitude_value_1,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004410": "send_attitude_data_08004410",
                "in_r1": "input_data",
                "buff": "data_buffer",
                "local_10": "attitude_value_1",
                "local_c": "attitude_value_2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004434": {
            "entrypoint": "0x08004434",
            "current_name": "send_altitude_frame_08004434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAltitudeFrame_08004434(void)\n\n{\n  undefined4 conversionFactor;\n  uint8_t altitudeBuffer [6];\n  int32_t estimatedAltitude;\n  undefined4 varioData;\n  \n  estimatedAltitude = msp_txf_altitude.est_alt;\n  varioData = CONCAT22((short)((uint)conversionFactor >> 0x10),msp_txf_altitude.vario);\n  MSP_SendFrame('m',(uint8_t *)&estimatedAltitude,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004434": "send_altitude_frame_08004434",
                "in_r1": "conversionFactor",
                "buff": "altitudeBuffer",
                "local_10": "estimatedAltitude",
                "local_c": "varioData"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004458": {
            "entrypoint": "0x08004458",
            "current_name": "send_pid_data_08004458",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid send_pid_data_08004458(void)\n\n{\n  undefined4 *local_pid_array;\n  undefined4 pitch_data;\n  undefined4 *buffer;\n  msp_pid *current_pid;\n  msp_pid *next_pid;\n  uint8_t data_buffer [30];\n  undefined4 pid_parameters [3];\n  undefined2 yaw_parameters [10];\n  \n  local_pid_array = pid_parameters;\n  next_pid = &msp_txf_pid;\n  do {\n    current_pid = next_pid;\n    buffer = local_pid_array;\n    pitch_data = *(undefined4 *)&(current_pid->pitch).i;\n    next_pid = (msp_pid *)&(current_pid->yaw).d;\n    *buffer = *(undefined4 *)current_pid;\n    buffer[1] = pitch_data;\n    local_pid_array = buffer + 2;\n  } while (next_pid != (msp_pid *)&msp_txf_pid.mag);\n  buffer[2] = msp_txf_pid._24_4_;\n  *(undefined2 *)(buffer + 3) = *(undefined2 *)&current_pid->pos;\n  MSP_SendFrame('p',(uint8_t *)pid_parameters,0x1e);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004458": "send_pid_data_08004458",
                "puVar1": "local_pid_array",
                "uVar2": "pitch_data",
                "puVar3": "buffer",
                "pmVar4": "current_pid",
                "pmVar5": "next_pid",
                "buff": "data_buffer",
                "local_30": "pid_parameters",
                "local_24": "yaw_parameters"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004490": {
            "entrypoint": "0x08004490",
            "current_name": "handle_error_08004490",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleError_08004490(char *errorFile,int errorLine)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,GPIO_PIN_SET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,GPIO_PIN_RESET);\n  do {\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x4000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x8000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x2000);\n    serialPrint(\"Error with \");\n    serialPrint(errorFile);\n    serialPrint(\" at errorLine: \");\n    serialInt(errorLine);\n    serialWrite('\\n');\n    delay_ms(500);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004490": "handle_error_08004490",
                "file": "errorFile",
                "line": "errorLine"
            },
            "calling": [
                "Peripherals_Init",
                "I2C_ReadByte",
                "I2C_ReadBytes",
                "I2C_WriteByte",
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "serialWrite",
                "delay_ms",
                "serialInt",
                "serialPrint",
                "HAL_GPIO_TogglePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004514": {
            "entrypoint": "0x08004514",
            "current_name": "initialize_clocks_08004514",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08004514(void)\n\n{\n  HAL_StatusTypeDef status;\n  char *errorFile;\n  uint32_t hclkFreq;\n  int currentLine;\n  uint flashLatency;\n  RCC_ClkInitTypeDef rccClockInit;\n  RCC_OscInitTypeDef rccOscInit;\n  \n  rccOscInit.HSIState = 1;\n  rccOscInit.HSICalibrationValue = 0x10;\n  flashLatency = 2;\n  rccOscInit.PLL.PLLSource = 0;\n  rccOscInit.OscillatorType = 2;\n  rccOscInit.PLL.PLLState = 2;\n  rccOscInit.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig(&rccOscInit);\n  errorFile = (char *)(uint)status;\n  if (errorFile == (char *)0x0) goto LAB_08004540;\n  currentLine = 0x3c;\n  while( true ) {\n    errorFile = \"../Src/peripherals.c\";\n    _Error_Handler(\"../Src/peripherals.c\",currentLine);\nLAB_08004540:\n    rccClockInit.ClockType = 0xf;\n    rccClockInit.APB1CLKDivider = 0x400;\n    rccClockInit.SYSCLKSource = flashLatency;\n    rccClockInit.AHBCLKDivider = (uint32_t)errorFile;\n    rccClockInit.APB2CLKDivider = (uint32_t)errorFile;\n    status = HAL_RCC_ClockConfig(&rccClockInit,flashLatency);\n    flashLatency = (uint)status;\n    if (flashLatency == 0) break;\n    currentLine = 0x49;\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004514": "initialize_clocks_08004514",
                "HVar1": "status",
                "pcVar2": "errorFile",
                "uVar3": "hclkFreq",
                "line": "currentLine",
                "FLatency": "flashLatency",
                "RCC_ClkInitStruct": "rccClockInit",
                "RCC_OscInitStruct": "rccOscInit"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_peripherals_0800458c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_0800458c(void)\n\n{\n  HAL_Status result;\n  char *uartInitResult;\n  uint status;\n  int currentLine;\n  uint prescalerValue;\n  uint32_t tempReg;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_OC_InitTypeDef configOC;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  HAL_Init();\n  SystemClock_Config();\n  prescalerValue = 2;\n  _DAT_40021018 = _DAT_40021018 | 0x1c;\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0xe000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,0x20,GPIO_PIN_RESET);\n  gpioInitStruct.Pin = 0xe000;\n  gpioInitStruct.Mode = 1;\n  gpioInitStruct.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40011000,&gpioInitStruct);\n  gpioInitStruct.Pin = 0x20;\n  gpioInitStruct.Mode = 1;\n  gpioInitStruct.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioInitStruct);\n  i2c1.Instance = (I2C_TypeDef *)0x40005400;\n  i2c1.Init.ClockSpeed = 400000;\n  i2c1.Init.AddressingMode = 0x4000;\n  i2c1.Init.DutyCycle = 0;\n  i2c1.Init.OwnAddress1 = 0;\n  i2c1.Init.DualAddressMode = 0;\n  i2c1.Init.OwnAddress2 = 0;\n  i2c1.Init.GeneralCallMode = 0;\n  i2c1.Init.NoStretchMode = 0;\n  result = HAL_I2C_Init(&i2c1);\n  uartInitResult = (char *)(uint)result;\n  if (uartInitResult == (char *)0x0) goto LAB_0800463a;\n  currentLine = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  uartInitResult = \"../Src/peripherals.c\";\n                                  _Error_Handler(\"../Src/peripherals.c\",currentLine);\nLAB_0800463a:\n                                  uart1.Instance = (USART_TypeDef *)0x40013800;\n                                  uart1.Init.BaudRate = 0x1c200;\n                                  uart1.Init.Mode = 0xc;\n                                  uart1.Init.WordLength = (uint32_t)uartInitResult;\n                                  uart1.Init.StopBits = (uint32_t)uartInitResult;\n                                  uart1.Init.Parity = (uint32_t)uartInitResult;\n                                  uart1.Init.HwFlowCtl = (uint32_t)uartInitResult;\n                                  uart1.Init.OverSampling = (uint32_t)uartInitResult;\n                                  result = HAL_UART_Init(&uart1);\n                                  status = (uint)result;\n                                  if (status == 0) break;\n                                  currentLine = 0x151;\n                                }\n                                tim1.Instance = (TIM_TypeDef *)0x40012c00;\n                                tim1.Init.Period = 1000;\n                                tim1.Init.Prescaler = prescalerValue;\n                                tim1.Init.CounterMode = status;\n                                tim1.Init.ClockDivision = status;\n                                tim1.Init.RepetitionCounter = status;\n                                result = HAL_TIM_PWM_Init(&tim1);\n                                status = (uint)result;\n                                if (status == 0) break;\n                                currentLine = 0x88;\n                              }\n                              masterConfig.MasterOutputTrigger = status;\n                              masterConfig.MasterSlaveMode = status;\n                              result = HAL_TIMEx_MasterConfigSynchronization(&tim1,&masterConfig);\n                              status = (uint)result;\n                              if (status == 0) break;\n                              currentLine = 0x8f;\n                            }\n                            configOC.OCMode = 0x60;\n                            configOC.Pulse = status;\n                            configOC.OCPolarity = status;\n                            configOC.OCFastMode = status;\n                            configOC.OCIdleState = status;\n                            configOC.OCNIdleState = status;\n                            result = HAL_TIM_PWM_ConfigChannel(&tim1,&configOC,0xc);\n                            status = (uint)result;\n                            if (status == 0) break;\n                            currentLine = 0x9a;\n                          }\n                          gpioInitStruct.Pin = status;\n                          gpioInitStruct.Mode = status;\n                          gpioInitStruct.Pull = status;\n                          gpioInitStruct.Speed = status;\n                          result = HAL_TIMEx_ConfigBreakDeadTime\n                                            (&tim1,(TIM_BreakDeadTimeConfigTypeDef *)\n                                                    &gpioInitStruct);\n                          status = (uint)result;\n                          if (status == 0) break;\n                          currentLine = 0xa6;\n                        }\n                        HAL_TIM_MspPostInit(&tim1);\n                        tim2.Instance = (TIM_TypeDef *)0x40000000;\n                        tim2.Init.Period = 1000;\n                        tim2.Init.Prescaler = prescalerValue;\n                        tim2.Init.CounterMode = status;\n                        tim2.Init.ClockDivision = status;\n                        result = HAL_TIM_PWM_Init(&tim2);\n                        status = (uint)result;\n                        if (status == 0) break;\n                        currentLine = 0xc3;\n                      }\n                      configOC.OCMode = status;\n                      configOC.Pulse = status;\n                      result = HAL_TIMEx_MasterConfigSynchronization\n                                        (&tim2,(TIM_MasterConfigTypeDef *)&configOC);\n                      status = (uint)result;\n                      if (status == 0) break;\n                      currentLine = 0xca;\n                    }\n                    gpioInitStruct.Pin = 0x60;\n                    gpioInitStruct.Mode = status;\n                    gpioInitStruct.Pull = status;\n                    result = HAL_TIM_PWM_ConfigChannel\n                                      (&tim2,(TIM_OC_InitTypeDef *)&gpioInitStruct,4);\n                    status = (uint)result;\n                    if (status == 0) break;\n                    currentLine = 0xd3;\n                  }\n                  HAL_TIM_MspPostInit(&tim2);\n                  tim3.Init.Period = 1000;\n                  tim3.Instance = (TIM_TypeDef *)0x40000400;\n                  tim3.Init.Prescaler = prescalerValue;\n                  tim3.Init.CounterMode = status;\n                  tim3.Init.ClockDivision = status;\n                  result = HAL_TIM_PWM_Init(&tim3);\n                  if (result == HAL_OK) break;\n                  currentLine = 0xf0;\n                }\n                configOC.OCMode = 0;\n                configOC.Pulse = 0;\n                result = HAL_TIMEx_MasterConfigSynchronization\n                                  (&tim3,(TIM_MasterConfigTypeDef *)&configOC);\n                status = (uint)result;\n                if (status == 0) break;\n                currentLine = 0xf7;\n              }\n              gpioInitStruct.Pin = 0x60;\n              gpioInitStruct.Mode = status;\n              gpioInitStruct.Pull = status;\n              result = HAL_TIM_PWM_ConfigChannel(&tim3,(TIM_OC_InitTypeDef *)&gpioInitStruct,8);\n              if (result == HAL_OK) break;\n              currentLine = 0x100;\n            }\n            result = HAL_TIM_PWM_ConfigChannel(&tim3,(TIM_OC_InitTypeDef *)&gpioInitStruct,0xc);\n            prescalerValue = (uint)result;\n            if (prescalerValue == 0) break;\n            currentLine = 0x105;\n          }\n          HAL_TIM_MspPostInit(&tim3);\n          tim4.Instance = (TIM_TypeDef *)0x40000800;\n          tim4.Init.Prescaler = 2;\n          tim4.Init.Period = 1000;\n          tim4.Init.CounterMode = prescalerValue;\n          tim4.Init.ClockDivision = prescalerValue;\n          result = HAL_TIM_PWM_Init(&tim4);\n          status = (uint)result;\n          if (status == 0) break;\n          currentLine = 0x122;\n        }\n        configOC.OCMode = status;\n        configOC.Pulse = status;\n        result = HAL_TIMEx_MasterConfigSynchronization(&tim4,(TIM_MasterConfigTypeDef *)&configOC);\n        status = (uint)result;\n        if (status == 0) break;\n        currentLine = 0x129;\n      }\n      gpioInitStruct.Pin = 0x60;\n      gpioInitStruct.Mode = status;\n      gpioInitStruct.Pull = status;\n      result = HAL_TIM_PWM_ConfigChannel(&tim4,(TIM_OC_InitTypeDef *)&gpioInitStruct,8);\n      if (result == HAL_OK) break;\n      currentLine = 0x132;\n    }\n    result = HAL_TIM_PWM_ConfigChannel(&tim4,(TIM_OC_InitTypeDef *)&gpioInitStruct,0xc);\n    if (result == HAL_OK) break;\n    currentLine = 0x137;\n  }\n  HAL_TIM_MspPostInit(&tim4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_peripherals_0800458c",
                "HAL_StatusTypeDef": "HAL_Status",
                "pcVar2": "uartInitResult",
                "uVar3": "status",
                "line": "currentLine",
                "uVar4": "prescalerValue",
                "tmpreg": "tempReg",
                "tmpreg_1": "tempReg1",
                "tmpreg_2": "tempReg2",
                "sMasterConfig": "masterConfig",
                "sConfigOC": "configOC",
                "GPIO_InitStruct": "gpioInitStruct",
                "hi2c1": "i2c1",
                "HVar1": "result",
                "huart1": "uart1",
                "htim1": "tim1",
                "htim2": "tim2",
                "htim3": "tim3",
                "htim4": "tim4"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_UART_Init",
                "HAL_Init",
                "HAL_GPIO_Init",
                "HAL_I2C_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_ConfigChannel",
                "_Error_Handler",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_MspPostInit",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800483c": {
            "entrypoint": "0x0800483c",
            "current_name": "calculate_pid_output_0800483c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculatePIDOutput_0800483c(PIDData *pidData)\n\n{\n  undefined4 tempValue1;\n  int tempValue2;\n  undefined4 tempValue3;\n  float tempFloat1;\n  float tempFloat2;\n  float tempFloat3;\n  \n  tempFloat1 = pidData->input;\n  tempValue1 = __addsf3(pidData->set_point,pidData->offset);\n  tempFloat1 = (float)__aeabi_fsub(tempValue1,tempFloat1);\n  pidData->error = tempFloat1;\n  if (pidData->instance == 3) {\n    tempValue2 = __aeabi_fcmpgt(pidData->error,0);\n    if (tempValue2 == 0) {\n      tempValue2 = __aeabi_fcmplt(pidData->error,0xc3340000);\n    }\n    else {\n      tempValue2 = __aeabi_fcmpgt(pidData->error,0x43340000);\n    }\n    if (tempValue2 != 0) {\n      tempFloat2 = pidData->error;\n      tempValue1 = __aeabi_fmul(pidData->error,0x43b40000);\n      tempValue2 = __aeabi_fcmpgt(pidData->error,0);\n      tempFloat1 = pidData->error;\n      if (tempValue2 == 0) {\n        tempFloat1 = (float)((int)tempFloat1 + -0x80000000);\n      }\n      tempValue1 = __aeabi_fdiv(tempValue1,tempFloat1);\n      tempFloat1 = (float)__aeabi_fsub(tempFloat2,tempValue1);\n      pidData->error = tempFloat1;\n    }\n  }\n  tempFloat3 = pidData->con_KI;\n  tempFloat2 = pidData->con_KD;\n  tempFloat1 = (float)__aeabi_fmul(pidData->con_KP,pidData->error);\n  pidData->proportional = tempFloat1;\n  tempFloat1 = (float)__addsf3(pidData->error,pidData->integral);\n  pidData->integral = tempFloat1;\n  tempValue2 = __aeabi_fcmplt(pidData->integral,0xc3fa0000);\n  if (tempValue2 == 0) {\n    tempValue2 = __aeabi_fcmpgt(pidData->integral,0x43fa0000);\n    if (tempValue2 == 0) {\n      tempFloat1 = pidData->integral;\n    }\n    else {\n      tempFloat1 = 500.0;\n    }\n  }\n  else {\n    tempFloat1 = -500.0;\n  }\n  pidData->integral = tempFloat1;\n  tempFloat1 = (float)__aeabi_fsub(pidData->input,pidData->last_input);\n  pidData->derivative = tempFloat1;\n  tempFloat1 = pidData->proportional;\n  tempValue1 = __aeabi_fmul(tempFloat3,pidData->integral);\n  tempValue1 = __addsf3(tempValue1,tempFloat1);\n  tempValue3 = __aeabi_fmul(tempFloat2,pidData->derivative);\n  tempFloat1 = (float)__aeabi_fsub(tempValue1,tempValue3);\n  pidData->output = tempFloat1;\n  tempValue1 = __floatsisf(pidData->direction);\n  tempValue2 = __aeabi_fcmplt(pidData->output,0xc3fa0000);\n  if (tempValue2 == 0) {\n    tempValue2 = __aeabi_fcmpgt(pidData->output,0x43fa0000);\n    if (tempValue2 == 0) {\n      tempFloat1 = pidData->output;\n    }\n    else {\n      tempFloat1 = 500.0;\n    }\n  }\n  else {\n    tempFloat1 = -500.0;\n  }\n  tempFloat1 = (float)__aeabi_fmul(tempFloat1,tempValue1);\n  pidData->output = tempFloat1;\n  pidData->last_input = pidData->input;\n  pidData->last_error = pidData->error;\n  pidData->last_time = pidData->time;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800483c": "calculate_pid_output_0800483c",
                "PID_TypeDef": "PIDData",
                "pid": "pidData",
                "uVar1": "tempValue1",
                "iVar2": "tempValue2",
                "uVar3": "tempValue3",
                "fVar4": "tempFloat1",
                "fVar5": "tempFloat2",
                "fVar6": "tempFloat3"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "initialize_pid_constants_08004978",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePidConstants_08004978(void)\n\n{\n  pitchPid.direction = 1;\n  rollPid.direction = 1;\n  yawPid.direction = -1;\n  altitudePid.direction = 1;\n  pitchPid.breakpoint = 1500.0;\n  rollPid.breakpoint = 1450.0;\n  yawPid.breakpoint = 2000.0;\n  altitudePid.breakpoint = 0.0;\n  pitchPid.control_KP = 4.4;\n  pitchPid.control_KI = 0.02;\n  pitchPid.control_KD = 280.0;\n  pitchPid.aggressive_KP = 4.5;\n  pitchPid.aggressive_KI = 0.02;\n  pitchPid.aggressive_KD = 360.0;\n  rollPid.control_KP = 3.8;\n  rollPid.control_KI = 0.02;\n  rollPid.control_KD = 260.0;\n  rollPid.aggressive_KP = 3.8;\n  rollPid.aggressive_KI = 0.02;\n  rollPid.aggressive_KD = 320.0;\n  yawPid.control_KP = 3.0;\n  yawPid.control_KI = 0.01;\n  yawPid.control_KD = 280.0;\n  yawPid.aggressive_KP = 0.0;\n  yawPid.aggressive_KI = 0.0;\n  yawPid.aggressive_KD = 0.0;\n  altitudePid.control_KP = 10.0;\n  altitudePid.control_KI = 0.0;\n  altitudePid.control_KD = 0.0;\n  altitudePid.aggressive_KP = 0.0;\n  altitudePid.aggressive_KI = 0.0;\n  altitudePid.aggressive_KD = 0.0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004978": "initialize_pid_constants_08004978",
                "pid_pitch": "pitchPid",
                "pid_roll": "rollPid",
                "pid_yaw": "yawPid",
                "pid_altitude": "altitudePid",
                "pid_pitch.direction": "pitchPid.direction",
                "pid_roll.direction": "rollPid.direction",
                "pid_yaw.direction": "yawPid.direction",
                "pid_altitude.direction": "altitudePid.direction",
                "pid_pitch.breakpoint": "pitchPid.breakpoint",
                "pid_roll.breakpoint": "rollPid.breakpoint",
                "pid_yaw.breakpoint": "yawPid.breakpoint",
                "pid_altitude.breakpoint": "altitudePid.breakpoint",
                "pid_pitch.con_KP": "pitchPid.control_KP",
                "pid_pitch.con_KI": "pitchPid.control_KI",
                "pid_pitch.con_KD": "pitchPid.control_KD",
                "pid_pitch.agr_KP": "pitchPid.aggressive_KP",
                "pid_pitch.agr_KI": "pitchPid.aggressive_KI",
                "pid_pitch.agr_KD": "pitchPid.aggressive_KD",
                "pid_roll.con_KP": "rollPid.control_KP",
                "pid_roll.con_KI": "rollPid.control_KI",
                "pid_roll.con_KD": "rollPid.control_KD",
                "pid_roll.agr_KP": "rollPid.aggressive_KP",
                "pid_roll.agr_KI": "rollPid.aggressive_KI",
                "pid_roll.agr_KD": "rollPid.aggressive_KD",
                "pid_yaw.con_KP": "yawPid.control_KP",
                "pid_yaw.con_KI": "yawPid.control_KI",
                "pid_yaw.con_KD": "yawPid.control_KD",
                "pid_yaw.agr_KP": "yawPid.aggressive_KP",
                "pid_yaw.agr_KI": "yawPid.aggressive_KI",
                "pid_yaw.agr_KD": "yawPid.aggressive_KD",
                "pid_altitude.con_KP": "altitudePid.control_KP",
                "pid_altitude.con_KI": "altitudePid.control_KI",
                "pid_altitude.con_KD": "altitudePid.control_KD",
                "pid_altitude.agr_KP": "altitudePid.aggressive_KP",
                "pid_altitude.agr_KI": "altitudePid.aggressive_KI",
                "pid_altitude.agr_KD": "altitudePid.aggressive_KD"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a30": {
            "entrypoint": "0x08004a30",
            "current_name": "handle_altitude_08004a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_altitude_08004a30(void)\n\n{\n  if (alt_hold_flag != '\\0') {\n    if (alt_flag == '\\0') {\n      get_filtered_altitude();\n      altitude_set_point = (float)__aeabi_fmul();\n      alt_flag = '\\x01';\n    }\n    else {\n      get_filtered_altitude();\n      altitude_input = (float)__aeabi_fmul();\n    }\n  }\n  if (alt_hold_flag == '\\0') {\n    if (alt_flag != '\\0') {\n      alt_flag = alt_hold_flag;\n    }\n    altitude_output = throttle_value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a30": "handle_altitude_08004a30",
                "joystick.ALT_HOLD": "alt_hold_flag",
                "ALT_FLAG": "alt_flag",
                "MS5611_GetFilteredAltitude": "get_filtered_altitude",
                "pid_altitude.set_point": "altitude_set_point",
                "pid_altitude.input": "altitude_input",
                "pid_altitude.output": "altitude_output",
                "joystick.throttle": "throttle_value"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "MS5611_GetFilteredAltitude",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "flight_controller_08004a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid flightController_08004a84(void)\n\n{\n  float pitch_input;\n  int comparison_result;\n  \n  AHRS_GetPitch();\n  pitch_input = pitch_input;\n  AHRS_GetRoll();\n  roll_input = pitch_input;\n  AHRS_GetYaw();\n  yaw_input = pitch_input;\n  updateAltitude();\n  comparison_result = compareGreater(pitch_input,0);\n  if (comparison_result == 0) {\n    comparison_result = compareLess(pitch_input,0xc2a00000);\n  }\n  else {\n    comparison_result = compareGreater(pitch_input,0x42a00000);\n  }\n  if (comparison_result == 0) {\n    comparison_result = compareGreater(roll_input,0);\n    if (comparison_result == 0) {\n      comparison_result = compareLess(roll_input,0xc2a00000);\n    }\n    else {\n      comparison_result = compareGreater(roll_input,0x42a00000);\n    }\n    if (comparison_result == 0) {\n      toggleLED(1,1,1);\n      computePID(&pid_pitch);\n      computePID(&pid_roll);\n      computePID(&pid_yaw);\n      if (altHold != '\\0') {\n        computePID(&pid_altitude);\n        __addsf3(altitude_output,0x44bb8000);\n      }\n      altitude_output = throttle;\n      if (motorArm == '\\0') {\n        stopMotors();\n      }\n      else {\n        distributeSpeed(throttle,pid_pitch.output,pid_roll.output,pid_yaw.output);\n      }\n      multiplyFloats(pitch_KP,0x437f0000);\n      msp_pitch_p = __fixunssfsi();\n      multiplyFloats(pitch_KI,0x437f0000);\n      msp_pitch_i = __fixunssfsi();\n      multiplyFloats(roll_KP,0x437f0000);\n      msp_roll_p = __fixunssfsi();\n      multiplyFloats(roll_KI,0x437f0000);\n      msp_roll_i = __fixunssfsi();\n      multiplyFloats(roll_KD,0x437f0000);\n      msp_roll_d = __fixunssfsi();\n      multiplyFloats(yaw_KP,0x437f0000);\n      msp_yaw_p = __fixunssfsi();\n      multiplyFloats(yaw_KI,0x437f0000);\n      msp_yaw_i = __fixunssfsi();\n      multiplyFloats(yaw_KD,0x437f0000);\n      msp_yaw_d = __fixunssfsi();\n      multiplyFloats(altitude_KP,0x437f0000);\n      msp_alt_p = __fixunssfsi();\n      multiplyFloats(altitude_KI,0x437f0000);\n      msp_alt_i = __fixunssfsi();\n      multiplyFloats(altitude_KD,0x437f0000);\n      msp_alt_d = __fixunssfsi();\n      return;\n    }\n  }\n  stopMotors();\n  toggleLED(0,1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "flight_controller_08004a84",
                "in_r0": "pitch_input",
                "iVar1": "comparison_result",
                "pid_pitch.input": "pitch_input",
                "pid_roll.input": "roll_input",
                "pid_yaw.input": "yaw_input",
                "PID_UpdateAltitude": "updateAltitude",
                "__aeabi_fcmpgt": "compareGreater",
                "__aeabi_fcmplt": "compareLess",
                "PID_Compute": "computePID",
                "joystick.ALT_HOLD": "altHold",
                "pid_altitude.output": "altitude_output",
                "joystick.throttle": "throttle",
                "joystick.MOTOR_ARM": "motorArm",
                "Motor_StopAll": "stopMotors",
                "Motor_DistributeSpeed": "distributeSpeed",
                "__aeabi_fmul": "multiplyFloats",
                "pid_pitch.con_KP": "pitch_KP",
                "pid_pitch.con_KI": "pitch_KI",
                "pid_roll.con_KP": "roll_KP",
                "pid_roll.con_KI": "roll_KI",
                "pid_roll.con_KD": "roll_KD",
                "pid_yaw.con_KP": "yaw_KP",
                "pid_yaw.con_KI": "yaw_KI",
                "pid_yaw.con_KD": "yaw_KD",
                "pid_altitude.con_KP": "altitude_KP",
                "pid_altitude.con_KI": "altitude_KI",
                "pid_altitude.con_KD": "altitude_KD",
                "msp_txf_pid.pitch.p": "msp_pitch_p",
                "msp_txf_pid.pitch.i": "msp_pitch_i",
                "msp_txf_pid.roll.p": "msp_roll_p",
                "msp_txf_pid.roll.i": "msp_roll_i",
                "msp_txf_pid.roll.d": "msp_roll_d",
                "msp_txf_pid.yaw.p": "msp_yaw_p",
                "msp_txf_pid.yaw.i": "msp_yaw_i",
                "msp_txf_pid.yaw.d": "msp_yaw_d",
                "msp_txf_pid.alt.p": "msp_alt_p",
                "msp_txf_pid.alt.i": "msp_alt_i",
                "msp_txf_pid.alt.d": "msp_alt_d"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "Motor_StopAll",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "AHRS_GetRoll",
                "PID_Compute",
                "__addsf3",
                "toggleLED",
                "Motor_DistributeSpeed",
                "AHRS_GetPitch",
                "__fixunssfsi",
                "AHRS_GetYaw",
                "PID_UpdateAltitude"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c18": {
            "entrypoint": "0x08004c18",
            "current_name": "transmit_single_character_08004c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitSingleCharacter_08004c18(ucharacterar character)\n\n{\n  transmitBuffer[0] = character;\n  transmitUARTData(UARTHandle,(uint8_t *)transmitBuffer,1,5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c18": "transmit_single_character_08004c18",
                "ch": "character",
                "tx_buffer": "transmitBuffer",
                "HAL_UART_Transmit": "transmitUARTData",
                "&huart1": "UARTHandle"
            },
            "calling": [
                "MSP_SendFrame",
                "serialPrint",
                "_Error_Handler"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "handle_uart_receive_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_receive_08004c30(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle->uart_instance == (uart_typedef *)0x40013800) {\n    write_to_circular_buffer(&circular_buffer,receive_buffer[0]);\n    uart_receive_interrupt(&uart_handle_1,receive_buffer,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "handle_uart_receive_08004c30",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "USART_TypeDef": "uart_typedef",
                "CB_Write": "write_to_circular_buffer",
                "rxc": "circular_buffer",
                "rx_buffer": "receive_buffer",
                "HAL_UART_Receive_IT": "uart_receive_interrupt",
                "huart1": "uart_handle_1"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "CB_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c64": {
            "entrypoint": "0x08004c64",
            "current_name": "initialize_communication_08004c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeCommunication_08004c64(void)\n\n{\n  CB_Init(communicationContext);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c64": "initialize_communication_08004c64",
                "&rxc": "communicationContext"
            },
            "calling": [
                "serialBegin"
            ],
            "called": [
                "CB_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c70": {
            "entrypoint": "0x08004c70",
            "current_name": "initialize_serial_communication_08004c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08004c70(void)\n\n{\n  flushSerialBuffer();\n  receiveDataInterrupt(&uartHandle,receiveBuffer,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c70": "initialize_serial_communication_08004c70",
                "serialFlush": "flushSerialBuffer",
                "HAL_UART_Receive_IT": "receiveDataInterrupt",
                "&huart1": "&uartHandle",
                "rx_buffer": "receiveBuffer"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8c": {
            "entrypoint": "0x08004c8c",
            "current_name": "write_data_to_serial_08004c8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeDataToSerial_08004c8c(char *inputData)\n\n{\n  size_t dataLength;\n  uchar *currentChar;\n  \n  for (currentChar = (uchar *)inputData; dataLength = strlen(inputData), (uint)((int)currentChar - (int)inputData) < dataLength;\n      currentChar = currentChar + 1) {\n    serialWrite(*currentChar);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c8c": "write_data_to_serial_08004c8c",
                "data": "inputData",
                "sVar1": "dataLength",
                "puVar2": "currentChar"
            },
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "called": [
                "strlen",
                "serialWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cac": {
            "entrypoint": "0x08004cac",
            "current_name": "print_integer_08004cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printInteger_08004cac(int value)\n\n{\n  siprintf(textBuffer,\"%i\",value);\n  serialPrint(textBuffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004cac": "print_integer_08004cac",
                "val": "value",
                "tx_buffer": "textBuffer"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "initialize_interrupts_08004ccc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterrupts_08004ccc(void)\n\n{\n  uint32_t tmpreg;\n  \n  _DAT_40021018 = _DAT_40021018 | 1;\n  configurePriorityGrouping(3);\n  HAL_NVIC_SetPriority(MemoryManagementInterrupt,0,0);\n  HAL_NVIC_SetPriority(BusFaultInterrupt,0,0);\n  HAL_NVIC_SetPriority(UsageFaultInterrupt,0,0);\n  HAL_NVIC_SetPriority(SVCallInterrupt,0,0);\n  HAL_NVIC_SetPriority(DebugMonitorInterrupt,0,0);\n  HAL_NVIC_SetPriority(PendSVInterrupt,0,0);\n  HAL_NVIC_SetPriority(SysTickInterrupt,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "initialize_interrupts_08004ccc",
                "HAL_NVIC_SetPriorityGrouping": "configurePriorityGrouping",
                "MemoryManagement_IRQn": "MemoryManagementInterrupt",
                "BusFault_IRQn": "BusFaultInterrupt",
                "UsageFault_IRQn": "UsageFaultInterrupt",
                "SVCall_IRQn": "SVCallInterrupt",
                "DebugMonitor_IRQn": "DebugMonitorInterrupt",
                "PendSV_IRQn": "PendSVInterrupt",
                "SysTick_IRQn": "SysTickInterrupt"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d48": {
            "entrypoint": "0x08004d48",
            "current_name": "initialize_i2_c_08004d48",
            "code": "\n/* WARNING: Variable defined which should be unmapped: gpioInitStruct */\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_08004d48(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t temporaryRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (i2cHandle->Instance == (I2C_TypeDef *)0x40005400) {\n    gpioInitStruct.Pin = 0xc0;\n    gpioInitStruct.Mode = 0x12;\n    gpioInitStruct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010c00,&gpioInitStruct);\n    _DAT_4002101c = _DAT_4002101c | 0x200000;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d48": "initialize_i2_c_08004d48",
                "hi2c": "i2cHandle",
                "tmpreg": "temporaryRegister",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d8c": {
            "entrypoint": "0x08004d8c",
            "current_name": "configure_tim_08004d8c",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid configureTIM_08004d8c(TIM_HandleTypeDef *timHandle)\n\n{\n  TIM_Type *timInstance;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  \n  timInstance = timHandle->Instance;\n  if (timInstance == (TIM_Type *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n  }\n  else if (timInstance == (TIM_Type *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n  }\n  else if (timInstance == (TIM_Type *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n  }\n  else if (timInstance == (TIM_Type *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d8c": "configure_tim_08004d8c",
                "htim_pwm": "timHandle",
                "TIM_TypeDef": "TIM_Type",
                "pTVar1": "timInstance",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e14": {
            "entrypoint": "0x08004e14",
            "current_name": "configure_gpio_08004e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08004e14(TIM_HandleTypeDef *timer)\n\n{\n  GPIO_TypeDef *GPIO_port;\n  TIM_TypeDef *timer_instance;\n  GPIO_InitTypeDef GPIO_config;\n  \n  timer_instance = timer->Instance;\n  if (timer_instance == (TIM_TypeDef *)0x40012c00) {\n    GPIO_config.Pin = 0x800;\n  }\n  else {\n    if (timer_instance != (TIM_TypeDef *)0x40000000) {\n      if (timer_instance == (TIM_TypeDef *)0x40000400) {\n        GPIO_config.Pin = 3;\n      }\n      else {\n        if (timer_instance != (TIM_TypeDef *)0x40000800) {\n          return;\n        }\n        GPIO_config.Pin = 0x300;\n      }\n      GPIO_port = (GPIO_TypeDef *)0x40010c00;\n      goto LAB_08004e2e;\n    }\n    GPIO_config.Pin = 2;\n  }\n  GPIO_port = (GPIO_TypeDef *)0x40010800;\nLAB_08004e2e:\n  GPIO_config.Speed = 2;\n  GPIO_config.Mode = 2;\n  HAL_GPIO_Init(GPIO_port,&GPIO_config);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e14": "configure_gpio_08004e14",
                "htim": "timer",
                "GPIOx": "GPIO_port",
                "pTVar1": "timer_instance",
                "GPIO_InitStruct": "GPIO_config"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e7c": {
            "entrypoint": "0x08004e7c",
            "current_name": "initialize_uart_gpio_08004e7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_gpio_08004e7c(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_register;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (uart_handle->Instance == (USART_TypeDef *)0x40013800) {\n    _DAT_40021018 = _DAT_40021018 | 0x4000;\n    gpio_init_struct.Pin = 0x200;\n    gpio_init_struct.Mode = 2;\n    gpio_init_struct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpio_init_struct);\n    gpio_init_struct.Pin = 0x400;\n    gpio_init_struct.Mode = 0;\n    gpio_init_struct.Pull = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpio_init_struct);\n    HAL_NVIC_SetPriority(USART1_IRQn,0,0);\n    HAL_NVIC_EnableIRQ(USART1_IRQn);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e7c": "initialize_uart_gpio_08004e7c",
                "huart": "uart_handle",
                "tmpreg": "temporary_register",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_GPIO_Init",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee4": {
            "entrypoint": "0x08004ee4",
            "current_name": "FUNC_08004ee4",
            "code": "\nvoid FUNC_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee4": "FUNC_08004ee4"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee6": {
            "entrypoint": "0x08004ee6",
            "current_name": "infinite_loop_08004ee6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004ee6(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee6": "infinite_loop_08004ee6"
            },
            "calling": [
                "HardFault_Handler"
            ],
            "called": [
                "HardFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "run_infinite_loop_08004ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runInfiniteLoop_08004ee8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "run_infinite_loop_08004ee8"
            },
            "calling": [
                "MemManage_Handler"
            ],
            "called": [
                "MemManage_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eea": {
            "entrypoint": "0x08004eea",
            "current_name": "infinite_loop_08004eea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eea(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eea": "infinite_loop_08004eea"
            },
            "calling": [
                "BusFault_Handler"
            ],
            "called": [
                "BusFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eec": {
            "entrypoint": "0x08004eec",
            "current_name": "run_infinite_loop_08004eec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid run_infinite_loop_08004eec(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eec": "run_infinite_loop_08004eec"
            },
            "calling": [
                "UsageFault_Handler"
            ],
            "called": [
                "UsageFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eee": {
            "entrypoint": "0x08004eee",
            "current_name": "FUNC_08004eee",
            "code": "\nvoid FUNC_08004eee(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004eee": "FUNC_08004eee"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef0": {
            "entrypoint": "0x08004ef0",
            "current_name": "FUNC_08004ef0",
            "code": "\nvoid FUNC_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef0": "FUNC_08004ef0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef2": {
            "entrypoint": "0x08004ef2",
            "current_name": "FUNC_08004ef2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef2": "FUNC_08004ef2"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "handle_tick_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTickInterrupt_08004ef4(void)\n\n{\n  incrementSystemTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "handle_tick_interrupt_08004ef4",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f04": {
            "entrypoint": "0x08004f04",
            "current_name": "handle_uart_interrupt_08004f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08004f04(void)\n\n{\n  HAL_UART_IRQHandler(UART_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f04": "handle_uart_interrupt_08004f04",
                "&huart1": "UART_handler"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f10": {
            "entrypoint": "0x08004f10",
            "current_name": "setup_peripheral_registers_08004f10",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setupPeripheralRegisters_08004f10(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f10": "setup_peripheral_registers_08004f10"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f5c": {
            "entrypoint": "0x08004f5c",
            "current_name": "FUN_08004f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
            "renaming": {},
            "calling": [
                "taskScheduler",
                "MS5611_Update"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "get_system_uptime_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemUptime_08004f60(void)\n\n{\n  return systemUptime;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "get_system_uptime_08004f60",
                "uwTick": "systemUptime"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f64": {
            "entrypoint": "0x08004f64",
            "current_name": "FUNC_08004f64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f64": "FUNC_08004f64"
            },
            "calling": [
                "LED_StartupSequence",
                "MS5611_Init",
                "I2C_WriteByte",
                "_Error_Handler"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f68": {
            "entrypoint": "0x08004f68",
            "current_name": "initialize_system_and_execute_main_08004f68",
            "code": "\nvoid initializeSystemAndExecuteMain_08004f68(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumptableFunction;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8672; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (pointer = &completed_8672; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptableFunction = (code *)0x8004f9a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08004f9a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptableFunction)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f68": "initialize_system_and_execute_main_08004f68",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumptableFunction"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb0": {
            "entrypoint": "0x08004fb0",
            "current_name": "endless_loop_08004fb0",
            "code": "\nvoid endless_loop_08004fb0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004fb0": "endless_loop_08004fb0"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb4": {
            "entrypoint": "0x08004fb4",
            "current_name": "initialize_crypto_08004fb4",
            "code": "\nvoid initializeCrypto_08004fb4(EVP_PKEY_CTX *cryptoContext)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    cryptoContext = (EVP_PKEY_CTX *)(*(code *)(&__frame_dummy_init_array_entry)[index])();\n  }\n  _init(cryptoContext);\n  for (index = 0; index != 1; index = index + 1) {\n    (*(code *)(&__frame_dummy_init_array_entry)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fb4": "initialize_crypto_08004fb4",
                "param_1": "cryptoContext",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ffc": {
            "entrypoint": "0x08004ffc",
            "current_name": "clear_formatted_string_08004ffc",
            "code": "\nint clearFormattedString_08004ffc(char *stringBuffer,char *formatString,...)\n\n{\n  int result;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *outputBuffer [2];\n  undefined4 maxOutputSize;\n  undefined2 maxFormatSize;\n  undefined2 maxPrecision;\n  char *currentOutput;\n  undefined4 currentFormatSize;\n  char *currentFormat;\n  undefined4 additionalArg1;\n  undefined4 additionalArg2;\n  \n  maxFormatSize = 0x208;\n  maxOutputSize = 0x7fffffff;\n  currentFormatSize = 0x7fffffff;\n  maxPrecision = 0xffff;\n  outputBuffer[0] = stringBuffer;\n  currentOutput = stringBuffer;\n  currentFormat = formatString;\n  additionalArg1 = in_r2;\n  additionalArg2 = in_r3;\n  result = _svfiprintf_r(_impure_ptr,outputBuffer,formatString);\n  *outputBuffer[0] = '\\0';\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004ffc": "clear_formatted_string_08004ffc",
                "__s": "stringBuffer",
                "__format": "formatString",
                "local_78": "outputBuffer",
                "local_70": "maxOutputSize",
                "local_6c": "maxFormatSize",
                "local_6a": "maxPrecision",
                "local_68": "currentOutput",
                "local_64": "currentFormatSize",
                "pcStack_c": "currentFormat",
                "uStack_8": "additionalArg1",
                "uStack_4": "additionalArg2",
                "iVar1": "result"
            },
            "calling": [
                "serialInt"
            ],
            "called": [
                "_svfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005044": {
            "entrypoint": "0x08005044",
            "current_name": "resize_and_copy_memory_08005044",
            "code": "\nundefined4 resizeAndCopyMemory_08005044(undefined4 *errorCode,void **dataPtr,void *sourceData,void *sourceDataSize)\n\n{\n  void *newDataPtr;\n  void *currentDataPtr;\n  size_t sourceDataOffset;\n  \n  currentDataPtr = dataPtr[2];\n  if ((currentDataPtr <= sourceDataSize) && ((*(ushort *)(dataPtr + 3) & 0x480) != 0)) {\n    sourceDataOffset = (int)*dataPtr - (int)dataPtr[4];\n    currentDataPtr = (void *)((uint)((int)dataPtr[5] * 3) / 2);\n    newDataPtr = (void *)((int)sourceDataSize + sourceDataOffset + 1);\n    if (currentDataPtr < newDataPtr) {\n      currentDataPtr = newDataPtr;\n    }\n    if ((int)((uint)*(ushort *)(dataPtr + 3) << 0x15) < 0) {\n      newDataPtr = (void *)allocateMemory(errorCode,currentDataPtr);\n      if (newDataPtr == (void *)0x0) {\nLAB_0800508a:\n        *errorCode = 0xc;\n        *(ushort *)(dataPtr + 3) = *(ushort *)(dataPtr + 3) | 0x40;\n        return 0xffffffff;\n      }\n      memcpy(newDataPtr,dataPtr[4],sourceDataOffset);\n      *(ushort *)(dataPtr + 3) = *(ushort *)(dataPtr + 3) & 0xfb7f | 0x80;\n    }\n    else {\n      newDataPtr = (void *)reallocateMemory(errorCode,dataPtr[4],currentDataPtr);\n      if (newDataPtr == (void *)0x0) {\n        freeMemory(errorCode,dataPtr[4]);\n        goto LAB_0800508a;\n      }\n    }\n    dataPtr[4] = newDataPtr;\n    *dataPtr = (void *)((int)newDataPtr + sourceDataOffset);\n    dataPtr[5] = currentDataPtr;\n    dataPtr[2] = (void *)((int)currentDataPtr - sourceDataOffset);\n    currentDataPtr = sourceDataSize;\n  }\n  if (sourceDataSize <= currentDataPtr) {\n    currentDataPtr = sourceDataSize;\n  }\n  memmove(*dataPtr,sourceData,(size_t)currentDataPtr);\n  dataPtr[2] = (void *)((int)dataPtr[2] - (int)currentDataPtr);\n  *dataPtr = (void *)((int)currentDataPtr + (int)*dataPtr);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005044": "resize_and_copy_memory_08005044",
                "param_1": "errorCode",
                "param_2": "dataPtr",
                "param_3": "sourceData",
                "param_4": "sourceDataSize",
                "pvVar1": "newDataPtr",
                "pvVar2": "currentDataPtr",
                "__n": "sourceDataOffset",
                "_malloc_r": "allocateMemory",
                "_realloc_r": "reallocateMemory",
                "_free_r": "freeMemory"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050fc": {
            "entrypoint": "0x080050fc",
            "current_name": "parse_format_string_080050fc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005294) */\n\nint parseFormatString_080050fc(undefined4 *param_ptr,int *value_ptr,byte *format_str,int *format_ptr)\n\n{\n  bool is_digit;\n  int num_value;\n  int ssputs_result;\n  void *char_ptr;\n  int *value_ptr2;\n  byte *char_ptr2;\n  byte *char_ptr3;\n  int unaff_r9;\n  int *format_ptr_loc;\n  uint flag;\n  int precision;\n  undefined4 arg_loc;\n  int width;\n  int total_length;\n  byte conversion_specifier;\n  undefined modifier_1;\n  undefined modifier_2;\n  undefined sign_char;\n  undefined4 end_ptr;\n  \n  format_ptr_loc = format_ptr;\n  if (((int)((uint)*(ushort *)(value_ptr + 3) << 0x18) < 0) && (value_ptr[4] == 0)) {\n    num_value = _malloc_r(param_ptr,0x40);\n    *value_ptr = num_value;\n    value_ptr[4] = num_value;\n    if (num_value == 0) {\n      *param_ptr = 0xc;\n      return -1;\n    }\n    value_ptr[5] = 0x40;\n  }\n  total_length = 0;\n  modifier_1 = 0x20;\n  modifier_2 = 0x30;\n  char_ptr2 = format_str;\nLAB_08005146:\n  char_ptr3 = char_ptr2;\n  if (*char_ptr3 != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  char_ptr2 = char_ptr3 + 1;\n  if (*char_ptr3 != 0x25) goto LAB_08005146;\nLAB_08005150:\n  num_value = (int)char_ptr3 - (int)format_str;\n  if (num_value != 0) {\n    ssputs_result = __ssputs_r(param_ptr,value_ptr,format_str,num_value);\n    if (ssputs_result == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(value_ptr + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return total_length;\n    }\n    total_length = total_length + num_value;\n  }\n  if (*char_ptr3 == 0) goto LAB_080052ac;\n  flag = 0;\n  width = 0;\n  precision = -1;\n  arg_loc = 0;\n  sign_char = 0;\n  end_ptr = 0;\n  char_ptr2 = char_ptr3 + 1;\n  while( true ) {\n    char_ptr = memchr(&DAT_08007379,(uint)*char_ptr2,5);\n    format_str = char_ptr2 + 1;\n    if (char_ptr == (void *)0x0) break;\n    flag = 1 << ((int)char_ptr + 0xf7ff8c87U & 0xff) | flag;\n    char_ptr2 = format_str;\n  }\n  if ((int)(flag << 0x1b) < 0) {\n    sign_char = 0x20;\n  }\n  if ((int)(flag << 0x1c) < 0) {\n    sign_char = 0x2b;\n  }\n  if (*char_ptr2 == 0x2a) {\n    value_ptr2 = format_ptr_loc + 1;\n    num_value = *format_ptr_loc;\n    format_ptr_loc = value_ptr2;\n    if (num_value < 0) {\n      width = -num_value;\n      flag = flag | 2;\n      goto LAB_080051fc;\n    }\n  }\n  else {\n    is_digit = false;\n    num_value = width;\n    format_str = char_ptr2;\n    while( true ) {\n      if (9 < *format_str - 0x30) break;\n      num_value = num_value * 10 + (*format_str - 0x30);\n      is_digit = true;\n      format_str = format_str + 1;\n    }\n    if (!is_digit) goto LAB_080051fc;\n  }\n  width = num_value;\nLAB_080051fc:\n  if (*format_str == 0x2e) {\n    if (format_str[1] == 0x2a) {\n      format_str = format_str + 2;\n      value_ptr2 = format_ptr_loc + 1;\n      precision = *format_ptr_loc;\n      format_ptr_loc = value_ptr2;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      is_digit = false;\n      num_value = 0;\n      precision = 0;\n      while( true ) {\n        format_str = format_str + 1;\n        if (9 < *format_str - 0x30) break;\n        num_value = num_value * 10 + (*format_str - 0x30);\n        is_digit = true;\n      }\n      if (is_digit) {\n        precision = num_value;\n      }\n    }\n  }\n  char_ptr = memchr(&DAT_0800737f,(uint)*format_str,3);\n  if (char_ptr != (void *)0x0) {\n    format_str = format_str + 1;\n    flag = flag | 0x40 << ((int)char_ptr + 0xf7ff8c81U & 0xff);\n  }\n  conversion_specifier = *format_str;\n  format_str = format_str + 1;\n  char_ptr = memchr(\"efgEFG\",(uint)conversion_specifier,6);\n  if (char_ptr == (void *)0x0) {\n    unaff_r9 = _printf_i(param_ptr,&flag,value_ptr,0x8005045,&format_ptr_loc);\n    if (unaff_r9 == -1) goto LAB_080052ac;\n  }\n  else {\n    format_ptr_loc = (int *)(((int)format_ptr_loc + 7U & 0xfffffff8) + 8);\n  }\n  total_length = total_length + unaff_r9;\n  char_ptr2 = format_str;\n  goto LAB_08005146;\n}\n\n",
            "renaming": {
                "FUN_080050fc": "parse_format_string_080050fc",
                "param_1": "param_ptr",
                "param_2": "value_ptr",
                "param_3": "format_str",
                "param_4": "format_ptr",
                "bVar1": "is_digit",
                "iVar2": "num_value",
                "iVar3": "ssputs_result",
                "pvVar4": "char_ptr",
                "piVar5": "value_ptr2",
                "pbVar6": "char_ptr2",
                "pbVar7": "char_ptr3",
                "local_8c": "format_ptr_loc",
                "local_88": "flag",
                "local_84": "precision",
                "local_80": "arg_loc",
                "local_7c": "width",
                "local_74": "total_length",
                "local_70": "conversion_specifier",
                "local_6f": "modifier_1",
                "local_6e": "modifier_2",
                "local_45": "sign_char",
                "local_30": "end_ptr"
            },
            "calling": [
                "siprintf"
            ],
            "called": [
                "__ssputs_r",
                "memchr",
                "_malloc_r",
                "_printf_i"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052e4": {
            "entrypoint": "0x080052e4",
            "current_name": "decode_and_process_data_080052e4",
            "code": "\nundefined4\ndecode_and_process_data_080052e4(undefined4 input_value,uint *data_array,uint *result,undefined4 flag,code *callback_function)\n\n{\n  int loop_counter;\n  int callback_result;\n  uint max_value;\n  uint additional_value;\n  bool is_condition_met;\n  \n  max_value = data_array[4];\n  if ((int)data_array[4] < (int)data_array[2]) {\n    max_value = data_array[2];\n  }\n  *result = max_value;\n  if (*(char *)((int)data_array + 0x43) != '\\0') {\n    *result = max_value + 1;\n  }\n  if ((int)(*data_array << 0x1a) < 0) {\n    *result = *result + 2;\n  }\n  if ((*data_array & 6) == 0) {\n    for (loop_counter = 0; loop_counter < (int)(data_array[3] - *result); loop_counter = loop_counter + 1) {\n      callback_result = (*callback_function)(input_value,flag,(int)data_array + 0x19,1);\n      if (callback_result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  max_value = (uint)*(byte *)((int)data_array + 0x43);\n  if (max_value != 0) {\n    max_value = 1;\n  }\n  additional_value = max_value;\n  if ((int)(*data_array << 0x1a) < 0) {\n    *(undefined *)((int)data_array + max_value + 0x43) = 0x30;\n    additional_value = max_value + 2;\n    *(undefined *)((int)data_array + max_value + 0x44) = *(undefined *)((int)data_array + 0x45);\n  }\n  loop_counter = (*callback_function)(input_value,flag,(int)data_array + 0x43,additional_value);\n  if (loop_counter != -1) {\n    max_value = data_array[3];\n    is_condition_met = (*data_array & 6) != 4;\n    if (is_condition_met) {\n      max_value = 0;\n    }\n    additional_value = 0;\n    if (!is_condition_met) {\n      max_value = max_value - *result;\n    }\n    if (!is_condition_met) {\n      max_value = max_value & ~((int)max_value >> 0x1f);\n    }\n    if ((int)data_array[4] < (int)data_array[2]) {\n      max_value = max_value + (data_array[2] - data_array[4]);\n    }\n    while( true ) {\n      if (max_value == additional_value) {\n        return 0;\n      }\n      loop_counter = (*callback_function)(input_value,flag,(int)data_array + 0x1a,1);\n      if (loop_counter == -1) break;\n      additional_value = additional_value + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080052e4": "decode_and_process_data_080052e4",
                "param_1": "input_value",
                "param_2": "data_array",
                "param_3": "result",
                "param_4": "flag",
                "param_5": "callback_function",
                "iVar1": "loop_counter",
                "iVar2": "callback_result",
                "uVar3": "max_value",
                "uVar4": "additional_value",
                "bVar5": "is_condition_met"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "print_formatted_080053d4",
            "code": "\nuint print_formatted_080053d4(undefined4 format_string,uint *args,undefined4 n,code *put_char,uint **argptr)\n\n{\n  byte byte_val;\n  int result;\n  uint *arg_ptr;\n  void *mem_ptr;\n  int char_count;\n  char *hex_digits;\n  uint val;\n  uint **arg_pptr;\n  char **str_pptr;\n  uint num;\n  uint len;\n  char *str;\n  char *str_arg;\n  uint local_array [2];\n  \n  byte_val = *(byte *)(args + 6);\n  str_arg = (char *)((int)args + 0x43);\n  if (byte_val != 0x6e) {\n    if (byte_val < 0x6f) {\n      if (byte_val != 99) {\n        if (byte_val < 100) {\n          if (byte_val == 0) goto LAB_0800558e;\n          if (byte_val != 0x58) goto LAB_08005404;\n          *(undefined *)((int)args + 0x45) = 0x58;\n          hex_digits = \"0123456789ABCDEF\";\nLAB_0800551e:\n          val = *args;\n          arg_ptr = *argptr;\n          *argptr = arg_ptr + 1;\n          if (((val & 0x80) == 0) && ((int)(val << 0x19) < 0)) {\n            num = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            num = *arg_ptr;\n          }\n          if ((int)(val << 0x1f) < 0) {\n            *args = val | 0x20;\n          }\n          if (num == 0) {\n            *args = *args & 0xffffffdf;\n          }\n          val = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)args + 0x43) = 0;\n        }\n        else {\n          if ((byte_val != 100) && (byte_val != 0x69)) goto LAB_08005404;\n          num = *args;\n          arg_ptr = *argptr;\n          if ((num & 0x80) == 0) {\n            *argptr = arg_ptr + 1;\n            if ((num & 0x40) == 0) goto LAB_08005424;\n            num = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *argptr = arg_ptr + 1;\nLAB_08005424:\n            num = *arg_ptr;\n          }\n          if ((int)num < 0) {\n            num = -num;\n            *(undefined *)((int)args + 0x43) = 0x2d;\n          }\n          hex_digits = \"0123456789ABCDEF\";\n          val = 10;\n        }\n        len = args[1];\n        args[2] = len;\n        str = str_arg;\n        if ((int)len < 0) {\n          if (num != 0) goto LAB_08005552;\nLAB_08005600:\n          *(char *)((int)args + 0x42) = *hex_digits;\n          str = (char *)((int)args + 0x42);\n        }\n        else {\n          *args = *args & 0xfffffffb;\n          if (num == 0) {\n            if (len != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              len = num / val;\n              str = str + -1;\n              *str = hex_digits[num - val * len];\n              num = len;\n            } while (len != 0);\n          }\n        }\n        if (((val == 8) && ((int)(*args << 0x1f) < 0)) && ((int)args[1] <= (int)args[4]))\n        {\n          str[-1] = '0';\n          str = str + -1;\n        }\n        args[4] = (int)str_arg - (int)str;\n        str_arg = str;\n        goto LAB_080054fa;\n      }\n      arg_ptr = *argptr;\n      *argptr = arg_ptr + 1;\n      *(char *)((int)args + 0x42) = (char)*arg_ptr;\nLAB_08005464:\n      str_arg = (char *)((int)args + 0x42);\n      num = 1;\n    }\n    else {\n      if (byte_val != 0x73) {\n        if (byte_val < 0x74) {\n          if (byte_val == 0x6f) {\nLAB_0800548a:\n            num = *args;\n            arg_ptr = *argptr;\n            if ((num & 0x80) == 0) {\n              *argptr = arg_ptr + 1;\n              if ((num & 0x40) == 0) goto LAB_08005498;\n              num = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *argptr = arg_ptr + 1;\nLAB_08005498:\n              num = *arg_ptr;\n            }\n            if (byte_val == 0x6f) {\n              val = 8;\n            }\n            else {\n              val = 10;\n            }\n            hex_digits = \"0123456789ABCDEF\";\n            goto LAB_080054b4;\n          }\n          if (byte_val == 0x70) {\n            *args = *args | 0x20;\nLAB_0800544a:\n            hex_digits = \"0123456789abcdef\";\n            *(undefined *)((int)args + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (byte_val == 0x75) goto LAB_0800548a;\n          if (byte_val == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)args + 0x42) = byte_val;\n        goto LAB_08005464;\n      }\n      str_pptr = (char **)*argptr;\n      *argptr = (uint *)(str_pptr + 1);\n      str_arg = *str_pptr;\n      mem_ptr = memchr(str_arg,0,args[1]);\n      if (mem_ptr != (void *)0x0) {\n        args[1] = (int)mem_ptr - (int)str_arg;\n      }\n      num = args[1];\n    }\n    args[4] = num;\n    *(undefined *)((int)args + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  num = *args;\n  arg_pptr = (uint **)*argptr;\n  val = args[5];\n  if ((num & 0x80) == 0) {\n    *argptr = (uint *)(arg_pptr + 1);\n    arg_ptr = *arg_pptr;\n    if ((num & 0x40) == 0) goto LAB_0800557a;\n    *(short *)arg_ptr = (short)val;\n  }\n  else {\n    *argptr = (uint *)(arg_pptr + 1);\n    arg_ptr = *arg_pptr;\nLAB_0800557a:\n    *arg_ptr = val;\n  }\nLAB_0800558e:\n  args[4] = 0;\nLAB_080054fa:\n  result = _printf_common(format_string,args,local_array,n,put_char);\n  if ((result == -1) || (result = (*put_char)(format_string,n,str_arg,args[4]), result == -1)) {\nLAB_0800550e:\n    num = 0xffffffff;\n  }\n  else {\n    if ((int)(*args << 0x1e) < 0) {\n      for (result = 0; result < (int)(args[3] - local_array[0]); result = result + 1) {\n        char_count = (*put_char)(format_string,n,(int)args + 0x19,1);\n        if (char_count == -1) goto LAB_0800550e;\n      }\n    }\n    num = args[3];\n    if ((int)args[3] < (int)local_array[0]) {\n      num = local_array[0];\n    }\n  }\n  return num;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "print_formatted_080053d4",
                "param_1": "format_string",
                "param_2": "args",
                "param_3": "n",
                "param_4": "put_char",
                "param_5": "argptr",
                "bVar1": "byte_val",
                "iVar2": "result",
                "puVar3": "arg_ptr",
                "pvVar4": "mem_ptr",
                "iVar5": "char_count",
                "pcVar6": "hex_digits",
                "uVar7": "val",
                "ppuVar8": "arg_pptr",
                "ppcVar9": "str_pptr",
                "uVar10": "num",
                "uVar11": "len",
                "pcVar12": "str",
                "__s": "str_arg",
                "local_24": "local_array"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005614": {
            "entrypoint": "0x08005614",
            "current_name": "find_byte_in_memory_08005614",
            "code": "\nvoid * find_byte_in_memory_08005614(void *memory,int byte_to_find,size_t memory_size)\n\n{\n  byte *ptr_start;\n  byte *ptr_current;\n  \n  ptr_start = (byte *)memory;\n  do {\n    ptr_current = ptr_start;\n    if (ptr_current == (byte *)(memory_size + (int)memory)) {\n      return (void *)0x0;\n    }\n    ptr_start = ptr_current + 1;\n  } while ((uint)*ptr_current != (byte_to_find & 0xffU));\n  return ptr_current;\n}\n\n",
            "renaming": {
                "FUN_08005614": "find_byte_in_memory_08005614",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "memory_size",
                "pbVar1": "ptr_start",
                "pbVar2": "ptr_current"
            },
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005630": {
            "entrypoint": "0x08005630",
            "current_name": "copy_memory_08005630",
            "code": "\nvoid * copyMemory_08005630(void *destination,void *source,size_t length)\n\n{\n  undefined *destPointer;\n  undefined *srcPointer;\n  \n  srcPointer = (undefined *)((int)destination + -1);\n  destPointer = (undefined *)(length + (int)source);\n  for (; (undefined *)source != destPointer; source = (void *)((int)source + 1)) {\n    srcPointer = srcPointer + 1;\n    *srcPointer = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005630": "copy_memory_08005630",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "destPointer",
                "puVar2": "srcPointer"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005646": {
            "entrypoint": "0x08005646",
            "current_name": "memmove_reverse_08005646",
            "code": "\nvoid * memmove_reverse_08005646(void *dest,void *src,size_t size)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  undefined *puVar3;\n  \n  puVar3 = (undefined *)((int)src + size);\n  if ((src < dest) && (dest < puVar3)) {\n    puVar1 = (undefined *)((int)dest + size);\n    iVar2 = size - (int)puVar3;\n    while (puVar3 + iVar2 != (undefined *)0x0) {\n      puVar3 = puVar3 + -1;\n      puVar1 = puVar1 + -1;\n      *puVar1 = *puVar3;\n    }\n    return dest;\n  }\n  puVar1 = (undefined *)((int)dest + -1);\n  for (; (undefined *)src != puVar3; src = (void *)((int)src + 1)) {\n    puVar1 = puVar1 + 1;\n    *puVar1 = *src;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08005646": "memmove_reverse_08005646",
                "__dest": "dest",
                "__src": "src",
                "__n": "size"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800567c": {
            "entrypoint": "0x0800567c",
            "current_name": "allocate_memory_0800567c",
            "code": "\nvoid allocateMemory_0800567c(undefined4 *errorCode,int size,undefined4 param3,undefined4 param4)\n\n{\n  int **tempPtr;\n  int **freeList;\n  int **currentPtr;\n  int *nextPtr;\n  int **prevPtr;\n  int **allocatedPtr;\n  \n  if (size == 0) {\n    return;\n  }\n  allocatedPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    allocatedPtr = (int **)((int)allocatedPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  currentPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    allocatedPtr[1] = (int *)0x0;\n    freeList = tempPtr;\n    __malloc_free_list = allocatedPtr;\n  }\n  else {\n    currentPtr = __malloc_free_list;\n    if (allocatedPtr < __malloc_free_list) {\n      freeList = (int **)*allocatedPtr;\n      currentPtr = (int **)((int)allocatedPtr + (int)freeList);\n      if (__malloc_free_list == currentPtr) {\n        nextPtr = *__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n        currentPtr = (int **)((int)nextPtr + (int)freeList);\n        *allocatedPtr = (int *)currentPtr;\n      }\n      allocatedPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = allocatedPtr;\n    }\n    else {\n      do {\n        prevPtr = currentPtr;\n        currentPtr = (int **)prevPtr[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= allocatedPtr);\n      freeList = (int **)*prevPtr;\n      if ((int **)((int)prevPtr + (int)freeList) == allocatedPtr) {\n        freeList = (int **)((int)freeList + (int)*allocatedPtr);\n        *prevPtr = (int *)freeList;\n        if (currentPtr == (int **)((int)prevPtr + (int)freeList)) {\n          nextPtr = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          freeList = (int **)((int)freeList + (int)nextPtr);\n          *prevPtr = (int *)freeList;\n          prevPtr[1] = (int *)currentPtr;\n        }\n      }\n      else if (allocatedPtr < (int **)((int)prevPtr + (int)freeList)) {\n        *errorCode = 0xc;\n      }\n      else {\n        freeList = (int **)((int)allocatedPtr + (int)*allocatedPtr);\n        if (currentPtr == freeList) {\n          nextPtr = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          freeList = (int **)((int)nextPtr + (int)*allocatedPtr);\n          *allocatedPtr = (int *)freeList;\n        }\n        allocatedPtr[1] = (int *)currentPtr;\n        prevPtr[1] = (int *)allocatedPtr;\n      }\n    }\n  }\n  __malloc_unlock(errorCode,freeList,currentPtr,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800567c": "allocate_memory_0800567c",
                "param_1": "errorCode",
                "param_2": "size",
                "param_3": "param3",
                "param_4": "param4",
                "extraout_r1": "tempPtr",
                "ppiVar1": "freeList",
                "ppiVar2": "currentPtr",
                "piVar3": "nextPtr",
                "ppiVar4": "prevPtr",
                "ppiVar5": "allocatedPtr"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "allocate_memory_08005714",
            "code": "\nuint allocate_memory_08005714(undefined4 *result_ptr,uint size)\n\n{\n  uint *free_list_prev;\n  int remaining_space;\n  uint *current_block;\n  uint remaining_block_size;\n  uint *block_prev;\n  uint allocated_block_size;\n  \n  allocated_block_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_block_size < 0xc) {\n    allocated_block_size = 0xc;\n  }\n  if (((int)allocated_block_size < 0) || (allocated_block_size < size)) {\n    *result_ptr = 0xc;\n  }\n  else {\n    __malloc_lock();\n    free_list_prev = __malloc_free_list;\n    block_prev = __malloc_free_list;\n    while (current_block = free_list_prev, current_block != (uint *)0x0) {\n      remaining_block_size = *current_block - allocated_block_size;\n      if (-1 < (int)remaining_block_size) {\n        if (remaining_block_size < 0xc) {\n          if (block_prev == current_block) {\n            free_list_prev = (uint *)block_prev[1];\n            __malloc_free_list = free_list_prev;\n          }\n          else {\n            free_list_prev = (uint *)current_block[1];\n          }\n          if (block_prev != current_block) {\n            block_prev[1] = (uint)free_list_prev;\n            block_prev = current_block;\n          }\n        }\n        else {\n          *current_block = remaining_block_size;\n          *(uint *)((int)current_block + remaining_block_size) = allocated_block_size;\n          block_prev = (uint *)((int)current_block + remaining_block_size);\n        }\n        goto LAB_08005778;\n      }\n      block_prev = current_block;\n      free_list_prev = (uint *)current_block[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(result_ptr);\n    }\n    free_list_prev = (uint *)_sbrk_r(result_ptr,allocated_block_size);\n    if ((free_list_prev != (uint *)0xffffffff) &&\n       ((block_prev = (uint *)((int)free_list_prev + 3U & 0xfffffffc), free_list_prev == block_prev ||\n        (remaining_space = _sbrk_r(result_ptr,(int)block_prev - (int)free_list_prev), remaining_space != -1)))) {\n      *block_prev = allocated_block_size;\nLAB_08005778:\n      __malloc_unlock(result_ptr);\n      allocated_block_size = (int)block_prev + 0xbU & 0xfffffff8;\n      remaining_space = allocated_block_size - (int)(block_prev + 1);\n      if (remaining_space != 0) {\n        *(int *)((int)block_prev + remaining_space) = -remaining_space;\n        return allocated_block_size;\n      }\n      return allocated_block_size;\n    }\n    *result_ptr = 0xc;\n    __malloc_unlock(result_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005714": "allocate_memory_08005714",
                "param_1": "result_ptr",
                "param_2": "size",
                "puVar1": "free_list_prev",
                "iVar2": "remaining_space",
                "puVar3": "current_block",
                "uVar4": "remaining_block_size",
                "puVar5": "block_prev",
                "uVar6": "allocated_block_size"
            },
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057d0": {
            "entrypoint": "0x080057d0",
            "current_name": "copy_and_free_memory_080057d0",
            "code": "\nvoid * copyAndFreeMemory_080057d0(undefined4 context,void *source,uint size,undefined4 extraParam)\n\n{\n  void *newMemory;\n  uint usableSize;\n  \n  if (source != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      newMemory = (void *)0x0;\n    }\n    else {\n      usableSize = _malloc_usable_size_r();\n      newMemory = source;\n      if ((usableSize < size) && (newMemory = (void *)_malloc_r(context,size), newMemory != (void *)0x0))\n      {\n        memcpy(newMemory,source,size);\n        _free_r(context,source);\n      }\n    }\n    return newMemory;\n  }\n  newMemory = (void *)_malloc_r(context,size,size,extraParam);\n  return newMemory;\n}\n\n",
            "renaming": {
                "FUN_080057d0": "copy_and_free_memory_080057d0",
                "param_1": "context",
                "param_2": "source",
                "param_3": "size",
                "param_4": "extraParam",
                "pvVar1": "newMemory",
                "uVar2": "usableSize"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800581c": {
            "entrypoint": "0x0800581c",
            "current_name": "allocate_memory_0800581c",
            "code": "\nvoid allocate_memory_0800581c(int *error_code,intptr_t size)\n\n{\n  void *allocated_memory;\n  \n  errno = 0;\n  allocated_memory = _sbrk(size);\n  if ((allocated_memory == (void *)0xffffffff) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "error_code",
                "param_2": "size",
                "pvVar1": "allocated_memory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "FUNC_0800583c",
            "code": "\nvoid FUNC_0800583c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "FUNC_0800583c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800583e": {
            "entrypoint": "0x0800583e",
            "current_name": "FUNC_0800583e",
            "code": "\nvoid FUNC_0800583e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583e": "FUNC_0800583e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_sum_08005840",
            "code": "\nint calculateSum_08005840(undefined4 input,int array)\n\n{\n  int sum;\n  \n  sum = *(int *)(array + -4) + -4;\n  if (*(int *)(array + -4) < 0) {\n    sum = sum + *(int *)(array + sum);\n  }\n  return sum;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_sum_08005840",
                "param_1": "input",
                "param_2": "array",
                "iVar1": "sum"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005854": {
            "entrypoint": "0x08005854",
            "current_name": "calculate_asin_08005854",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080058d4) */\n\ndouble calculate_asin_08005854(double input_value)\n\n{\n  int comparison_result;\n  undefined4 *error_code_ptr;\n  double result;\n  double temp_result_1;\n  double temp_result_2;\n  double temp_result_3;\n  double temp_result_4;\n  int stack_value_1;\n  char *stack_value_2;\n  \n  result = (double)__ieee754_asin();\n  if ((__fdlib_version != -1) && (comparison_result = __unorddf2(), result = temp_result_1, comparison_result == 0)) {\n    fabs((double)CONCAT44(stack_value_2,stack_value_1));\n    comparison_result = __aeabi_dcmpgt();\n    result = temp_result_2;\n    if ((comparison_result != 0) &&\n       ((nan(\"\"), __fdlib_version == '\\x02' ||\n        (comparison_result = matherr((exception *)&stack0xffffffb8), result = temp_result_4, comparison_result == 0)))) {\n      error_code_ptr = (undefined4 *)__errno();\n      *error_code_ptr = 0x21;\n      result = temp_result_3;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005854": "calculate_asin_08005854",
                "__x": "input_value",
                "iVar1": "comparison_result",
                "puVar2": "error_code_ptr",
                "dVar3": "result",
                "extraout_d0": "temp_result_1",
                "extraout_d0_00": "temp_result_2",
                "extraout_d0_01": "temp_result_3",
                "extraout_d0_02": "temp_result_4",
                "in_stack_ffffffb8": "stack_value_1",
                "in_stack_ffffffbc": "stack_value_2"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__errno",
                "fabs",
                "matherr",
                "__aeabi_dcmpgt",
                "nan",
                "__ieee754_asin",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058fc": {
            "entrypoint": "0x080058fc",
            "current_name": "FUN_080058fc",
            "code": "\nundefined8 __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  undefined4 uVar1;\n  undefined4 extraout_r1;\n  int extraout_r1_00;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  uVar5 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar5 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar3 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar3 | (-param_1 | param_1) >> 0x1f))) {\n    uVar6 = __aeabi_dadd(param_1,param_2);\n    return uVar6;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    atan(param_5);\n    return CONCAT44(extraout_r1,param_1);\n  }\n  uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((param_1 | uVar3) == 0) {\n    if (uVar2 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (uVar2 != 3) {\n      return CONCAT44(param_2,param_1);\n    }\nLAB_0800613e:\n    uVar6 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((param_3 | uVar5) != 0) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 0x7ff00000) {\n          if (uVar2 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (uVar2 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (uVar2 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (uVar2 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (uVar2 != 3) {\n          if (uVar2 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (uVar3 != 0x7ff00000) {\n        iVar4 = (int)(uVar3 - uVar5) >> 0x14;\n        if (iVar4 < 0x3d) {\n          if (((int)param_4 < 0) && (iVar4 + 0x3c < 0 != SCARRY4(iVar4,0x3c))) {\n            uVar1 = 0;\n            iVar4 = 0;\n          }\n          else {\n            uVar1 = __divdf3(param_1,param_2);\n            fabs((double)CONCAT44(unaff_r4,param_4));\n            atan((double)CONCAT44(unaff_r4,param_4));\n            iVar4 = extraout_r1_00;\n          }\n        }\n        else {\n          uVar1 = 0x54442d18;\n          iVar4 = 0x3ff921fb;\n        }\n        if (uVar2 == 1) {\n          return CONCAT44(iVar4 + -0x80000000,uVar1);\n        }\n        if (uVar2 == 2) {\n          uVar7 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar6 = 0x400921fb54442d18;\n        }\n        else {\n          if (uVar2 == 0) {\n            return CONCAT44(iVar4,uVar1);\n          }\n          uVar6 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar7 = 0x400921fb54442d18;\n        }\n        uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                         (int)((ulonglong)uVar7 >> 0x20));\n        return uVar6;\n      }\n    }\n    if ((int)param_2 < 0) {\n      uVar6 = 0xbff921fb54442d18;\n    }\n    else {\n      uVar6 = 0x3ff921fb54442d18;\n    }\n  }\n  return uVar6;\n}\n\n",
            "renaming": {},
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "calculate_pow_08005900",
            "code": "\ndouble calculatePow_08005900(double base,double exponent)\n\n{\n  char version;\n  int comparisonResult;\n  int *errnoPtr;\n  undefined4 *errnoValuePtr;\n  int finiteResult;\n  undefined4 tmp1;\n  undefined4 tmp2;\n  undefined4 errorCode;\n  double powResult;\n  double tmp3;\n  double tmp4;\n  double powResult_02;\n  double powResult_03;\n  double powResult_04;\n  double powResult_05;\n  double powResult_06;\n  double powResult_07;\n  double powResult_08;\n  double powResult_09;\n  double powResult_10;\n  double powResult_11;\n  double powResult_12;\n  double result;\n  undefined8 mulResult;\n  undefined exceptionInfo [24];\n  undefined8 limits;\n  int errorFlag;\n  \n  result = (double)__ieee754_pow();\n  version = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return powResult;\n  }\n  comparisonResult = __unorddf2();\n  if (comparisonResult != 0) {\n    return tmp3;\n  }\n  comparisonResult = __unorddf2();\n  if (comparisonResult != 0) {\n    comparisonResult = __aeabi_dcmpeq();\n    if (comparisonResult == 0) {\n      return tmp4;\n    }\n    exceptionInfo._0_4_ = 1;\n    exceptionInfo._4_4_ = \"pow\";\n    limits = 1.0;\n    errorFlag = 0;\n    if (version == '\\x02') {\n      return tmp4;\n    }\n    goto LAB_08005978;\n  }\n  comparisonResult = __aeabi_dcmpeq();\n  if (comparisonResult == 0) {\n    comparisonResult = finite(result);\n    if ((comparisonResult == 0) && (finiteResult = finite(result), finiteResult != 0)) {\n      finiteResult = finite(result);\n      if (finiteResult == 0) goto LAB_08005b4c;\n      errorFlag = __unorddf2(SUB84(result,0),(int)((ulonglong)result >> 0x20));\n      version = __fdlib_version;\n      if (errorFlag != 0) {\n        exceptionInfo._4_4_ = \"pow\";\n        exceptionInfo._0_4_ = 1;\n        errorFlag = comparisonResult;\n        if (__fdlib_version == '\\0') goto LAB_08005a22;\n        limits = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      exceptionInfo._4_4_ = \"pow\";\n      exceptionInfo._0_4_ = 3;\n      if (__fdlib_version != '\\0') {\n        limits._0_4_ = 0;\n        limits._4_4_ = 0x7ff00000;\n        comparisonResult = __aeabi_dcmplt();\n        if (comparisonResult != 0) {\n          mulResult = __muldf3();\n          errorCode = (int)mulResult;\n          rint(result);\n          comparisonResult = __aeabi_dcmpeq((int)mulResult,(int)((ulonglong)mulResult >> 0x20),errorCode,tmp2);\n          if (comparisonResult == 0) {\n            limits._0_4_ = 0;\n            limits._4_4_ = 0xfff00000;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      limits._0_4_ = 0xe0000000;\n      limits._4_4_ = 0x47efffff;\n      comparisonResult = __aeabi_dcmplt();\n      if (comparisonResult != 0) {\n        mulResult = __muldf3();\n        errorCode = (int)mulResult;\n        rint(result);\n        comparisonResult = __aeabi_dcmpeq((int)mulResult,(int)((ulonglong)mulResult >> 0x20),errorCode,tmp1);\n        if (comparisonResult == 0) {\n          limits._0_4_ = 0xe0000000;\n          limits._4_4_ = 0xc7efffff;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      comparisonResult = matherr((exception *)exceptionInfo);\n      result = powResult_12;\n      if (comparisonResult != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      comparisonResult = __aeabi_dcmpeq(SUB84(result,0),(int)((ulonglong)result >> 0x20),0,0);\n      if (comparisonResult == 0) {\n        return powResult_09;\n      }\n      comparisonResult = finite(result);\n      if (comparisonResult == 0) {\n        return powResult_10;\n      }\n      comparisonResult = finite(result);\n      if (comparisonResult == 0) {\n        return powResult_11;\n      }\n      exceptionInfo._0_4_ = 4;\n      exceptionInfo._4_4_ = \"pow\";\n      errorFlag = 0;\n      limits._0_4_ = 0;\n      limits._4_4_ = 0;\nLAB_08005afa:\n      if (__fdlib_version != '\\x02') goto LAB_08005b98;\n    }\n    errnoValuePtr = (undefined4 *)__errno();\n    errorCode = 0x22;\n    result = powResult_08;\n  }\n  else {\n    comparisonResult = __aeabi_dcmpeq();\n    if (comparisonResult == 0) {\n      comparisonResult = finite(result);\n      if (comparisonResult == 0) {\n        return powResult_05;\n      }\n      comparisonResult = __aeabi_dcmplt();\n      if (comparisonResult == 0) {\n        return powResult_06;\n      }\n      exceptionInfo._0_4_ = 1;\n      exceptionInfo._4_4_ = \"pow\";\n      errorFlag = 0;\n      if (__fdlib_version == '\\0') {\nLAB_08005a22:\n        exceptionInfo._4_4_ = \"pow\";\n        exceptionInfo._0_4_ = 1;\n        limits = 0.0;\n        goto LAB_08005978;\n      }\n      limits = -INFINITY;\n      errorFlag = 0;\n      version = __fdlib_version;\nLAB_08005a32:\n      if (version != '\\x02') goto LAB_08005978;\n    }\n    else {\n      exceptionInfo._0_4_ = 1;\n      exceptionInfo._4_4_ = \"pow\";\n      limits = 0.0;\n      errorFlag = 0;\n      if (version != '\\0') {\n        limits = 1.0;\n        result = powResult_03;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      comparisonResult = matherr((exception *)exceptionInfo);\n      result = powResult_02;\n      if (comparisonResult != 0) goto LAB_080059d0;\n    }\n    errnoValuePtr = (undefined4 *)__errno();\n    errorCode = 0x21;\n    result = powResult_07;\n  }\n  *errnoValuePtr = errorCode;\nLAB_080059d0:\n  if (errorFlag != 0) {\n    errnoPtr = (int *)__errno();\n    *errnoPtr = errorFlag;\n    result = powResult_04;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005900": "calculate_pow_08005900",
                "__x": "base",
                "__y": "exponent",
                "cVar1": "version",
                "iVar2": "comparisonResult",
                "piVar3": "errnoPtr",
                "puVar4": "errnoValuePtr",
                "iVar5": "finiteResult",
                "extraout_r1": "tmp1",
                "extraout_r1_00": "tmp2",
                "uVar6": "errorCode",
                "extraout_d0": "powResult",
                "extraout_d0_00": "tmp3",
                "extraout_d0_01": "tmp4",
                "local_50": "exceptionInfo",
                "local_38": "limits",
                "local_30": "errorFlag",
                "dVar7": "result",
                "uVar8": "mulResult"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__errno",
                "rint",
                "matherr",
                "__muldf3",
                "finite",
                "__ieee754_pow",
                "__unorddf2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc8": {
            "entrypoint": "0x08005bc8",
            "current_name": "calculate_root_08005bc8",
            "code": "\ndouble calculateRoot_08005bc8(double inputValue)\n\n{\n  char versionFlag;\n  int comparisonResult;\n  int *errorPtr;\n  undefined4 *errnoPtr;\n  double result;\n  double exceptionResult;\n  double comparisonResult1;\n  double exceptionResult1;\n  double exceptionResult2;\n  double exceptionResult3;\n  undefined exceptionDetails [24];\n  undefined8 zeroValue;\n  int unorderedFlag;\n  \n  result = (double)__ieee754_sqrt();\n  versionFlag = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return result;\n  }\n  unorderedFlag = __unorddf2();\n  if (unorderedFlag != 0) {\n    return exceptionResult;\n  }\n  comparisonResult = __aeabi_dcmplt();\n  if (comparisonResult == 0) {\n    return comparisonResult1;\n  }\n  exceptionDetails._0_4_ = 1;\n  exceptionDetails._4_4_ = \"sqrt\";\n  if (versionFlag == '\\0') {\n    zeroValue = 0.0;\nLAB_08005c26:\n    comparisonResult = matherr((exception *)exceptionDetails);\n    result = exceptionResult1;\n    if (comparisonResult != 0) goto LAB_08005c2e;\n  }\n  else {\n    zeroValue = (double)__divdf3(0,0,0,0);\n    if (versionFlag != '\\x02') goto LAB_08005c26;\n  }\n  errnoPtr = (undefined4 *)__errno();\n  *errnoPtr = 0x21;\n  result = exceptionResult3;\nLAB_08005c2e:\n  if (unorderedFlag != 0) {\n    errorPtr = (int *)__errno();\n    *errorPtr = unorderedFlag;\n    result = exceptionResult2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005bc8": "calculate_root_08005bc8",
                "__x": "inputValue",
                "cVar1": "versionFlag",
                "iVar2": "comparisonResult",
                "piVar3": "errorPtr",
                "puVar4": "errnoPtr",
                "dVar5": "result",
                "extraout_d0": "exceptionResult",
                "extraout_d0_00": "comparisonResult1",
                "extraout_d0_01": "exceptionResult1",
                "extraout_d0_02": "exceptionResult2",
                "extraout_d0_03": "exceptionResult3",
                "local_50": "exceptionDetails",
                "local_38": "zeroValue",
                "local_30": "unorderedFlag"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__ieee754_sqrt",
                "__divdf3",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c70": {
            "entrypoint": "0x08005c70",
            "current_name": "calculate_square_root_08005c70",
            "code": "\nundefined8 calculateSquareRoot_08005c70(uint input1,uint input2)\n\n{\n  int iVar1;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  undefined4 temp7;\n  uint temp8;\n  undefined8 result;\n  undefined8 temp9;\n  undefined8 temp10;\n  undefined4 temp_input;\n  \n  result = CONCAT44(input2,input1);\n  temp8 = input2 & 0x7fffffff;\n  if (temp8 < 0x3ff00000) {\n    if (temp8 < 0x3fe00000) {\n      if (0x3e3fffff < temp8) {\n        temp9 = __muldf3(input1,input2,input1,input2);\n        temp7 = (undefined4)((ulonglong)temp9 >> 0x20);\n        temp6 = (undefined4)temp9;\n        temp9 = __muldf3(temp6,temp7,0xdfdf709,0x3f023de1);\n        temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x7501b288,0x3f49efe0);\n        temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp7);\n        temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0xb5688f3b,0x3fa48228);\n        temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp7);\n        temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0xe884455,0x3fc9c155);\n        temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp7);\n        temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x3eb6f7d,0x3fd4d612);\n        temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp7);\n        temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x55555555,0x3fc55555);\n        temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp7);\n        temp10 = __muldf3(temp6,temp7,0xb12e9282,0x3fb3b8c5);\n        temp10 = __subdf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),0x1b8d0159,0x3fe6066c);\n        temp10 = __muldf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),temp6,temp7);\n        temp10 = __aeabi_dadd((int)temp10,(int)((ulonglong)temp10 >> 0x20),0x9c598ac8,0x40002ae5);\n        temp10 = __muldf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),temp6,temp7);\n        temp10 = __subdf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),0x1c8a2d4b,0x40033a27);\n        temp10 = __muldf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),temp6,temp7);\n        temp10 = __aeabi_dadd((int)temp10,(int)((ulonglong)temp10 >> 0x20),0,0x3ff00000);\n        temp9 = __divdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                          (int)((ulonglong)temp10 >> 0x20));\n        temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),input1,input2);\n        goto LAB_08005cba;\n      }\n      temp9 = __aeabi_dadd(input1,input2,0x8800759c,0x7e37e43c);\n      iVar1 = __aeabi_dcmpgt((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x3ff00000);\n      if (iVar1 != 0) {\n        return result;\n      }\n    }\n    fabs((double)CONCAT44(input2,temp_input));\n    result = __subdf3(0,0x3ff00000,input1,temp1);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x3fe00000);\n    temp2 = (undefined4)((ulonglong)result >> 0x20);\n    temp6 = (undefined4)result;\n    result = __muldf3(temp6,temp2,0xdfdf709,0x3f023de1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x7501b288,0x3f49efe0);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp6,temp2);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0xb5688f3b,0x3fa48228);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp6,temp2);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0xe884455,0x3fc9c155);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp6,temp2);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x3eb6f7d,0x3fd4d612);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp6,temp2);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x55555555,0x3fc55555);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp6,temp2);\n    temp3 = (undefined4)((ulonglong)result >> 0x20);\n    temp9 = __muldf3(temp6,temp2,0xb12e9282,0x3fb3b8c5);\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x1b8d0159,0x3fe6066c);\n    temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp2);\n    temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x9c598ac8,0x40002ae5);\n    temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp2);\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x1c8a2d4b,0x40033a27);\n    temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp6,temp2);\n    temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x3ff00000);\n    temp4 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp10 = __ieee754_sqrt(temp6,temp2);\n    temp5 = (undefined4)((ulonglong)temp10 >> 0x20);\n    temp7 = (undefined4)temp10;\n    if (temp8 < 0x3fef3333) {\n      result = __divdf3((int)result,temp3,(int)temp9,temp4);\n      temp9 = __aeabi_dadd(temp7,temp5,temp7,temp5);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),(int)temp9,\n                       (int)((ulonglong)temp9 >> 0x20));\n      temp9 = __muldf3(0,temp5,0,temp5);\n      temp9 = __subdf3(temp6,temp2,(int)temp9,(int)((ulonglong)temp9 >> 0x20));\n      temp10 = __aeabi_dadd(temp7,temp5,0,temp5);\n      temp9 = __divdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                        (int)((ulonglong)temp10 >> 0x20));\n      temp6 = (undefined4)((ulonglong)temp9 >> 0x20);\n      temp9 = __aeabi_dadd((int)temp9,temp6,(int)temp9,temp6);\n      temp9 = __subdf3(0x33145c07,0x3c91a626,(int)temp9,(int)((ulonglong)temp9 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)temp9,\n                       (int)((ulonglong)temp9 >> 0x20));\n      temp9 = __aeabi_dadd(0,temp5,0,temp5);\n      temp9 = __subdf3(0x54442d18,0x3fe921fb,(int)temp9,(int)((ulonglong)temp9 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)temp9,\n                       (int)((ulonglong)temp9 >> 0x20));\n      temp6 = 0x3fe921fb;\n    }\n    else {\n      result = __divdf3((int)result,temp3,(int)temp9,temp4);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp7,temp5);\n      result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),temp7,temp5);\n      temp6 = (undefined4)((ulonglong)result >> 0x20);\n      result = __aeabi_dadd((int)result,temp6,(int)result,temp6);\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x33145c07,0x3c91a626);\n      temp6 = 0x3ff921fb;\n    }\n    result = __subdf3(0x54442d18,temp6,(int)result,(int)((ulonglong)result >> 0x20));\n    if ((int)input2 < 1) {\n      result = CONCAT44((int)((ulonglong)result >> 0x20) + -0x80000000,(int)result);\n    }\n  }\n  else {\n    if ((temp8 + 0xc0100000 | input1) != 0) {\n      result = __subdf3(input1,input2,input1,input2);\n      temp6 = (undefined4)((ulonglong)result >> 0x20);\n      result = __divdf3((int)result,temp6,(int)result,temp6);\n      return result;\n    }\n    result = __muldf3(input1,input2,0x54442d18,0x3ff921fb);\n    temp9 = __muldf3(input1,input2,0x33145c07,0x3c91a626);\nLAB_08005cba:\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),(int)temp9,\n                         (int)((ulonglong)temp9 >> 0x20));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005c70": "calculate_square_root_08005c70",
                "param_1": "input1",
                "param_2": "input2",
                "extraout_r1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "uVar8": "temp8",
                "uVar9": "result",
                "uVar10": "temp9",
                "uVar11": "temp10",
                "in_stack_ffffffc8": "temp_input"
            },
            "calling": [
                "asin"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006070": {
            "entrypoint": "0x08006070",
            "current_name": "calculate_result_08006070",
            "code": "\nundefined8 calculateResult_08006070(uint input1,uint input2,uint input3,uint input4,double input5)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  int result3;\n  undefined4 result4;\n  uint var1;\n  uint var2;\n  int var3;\n  uint var4;\n  undefined8 var5;\n  undefined8 var6;\n  \n  var4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (var4 | (-input3 | input3) >> 0x1f)) ||\n     (var2 = input2 & 0x7fffffff, 0x7ff00000 < (var2 | (-input1 | input1) >> 0x1f))) {\n    var5 = __aeabi_dadd(input1,input2);\n    return var5;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    atan(input5);\n    return CONCAT44(result2,input1);\n  }\n  var1 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((input1 | var2) == 0) {\n    if (var1 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (var1 != 3) {\n      return CONCAT44(input2,input1);\n    }\nLAB_0800613e:\n    var5 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((input3 | var4) != 0) {\n      if (var4 == 0x7ff00000) {\n        if (var2 == 0x7ff00000) {\n          if (var1 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (var1 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (var1 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (var1 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (var1 != 3) {\n          if (var1 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (var2 != 0x7ff00000) {\n        var3 = (int)(var2 - var4) >> 0x14;\n        if (var3 < 0x3d) {\n          if (((int)input4 < 0) && (var3 + 0x3c < 0 != SCARRY4(var3,0x3c))) {\n            result1 = 0;\n            var3 = 0;\n          }\n          else {\n            result1 = __divdf3(input1,input2);\n            fabs((double)CONCAT44(result4,input4));\n            atan((double)CONCAT44(result4,input4));\n            var3 = result3;\n          }\n        }\n        else {\n          result1 = 0x54442d18;\n          var3 = 0x3ff921fb;\n        }\n        if (var1 == 1) {\n          return CONCAT44(var3 + -0x80000000,result1);\n        }\n        if (var1 == 2) {\n          var6 = __subdf3(result1,var3,0x33145c07,0x3ca1a626);\n          var5 = 0x400921fb54442d18;\n        }\n        else {\n          if (var1 == 0) {\n            return CONCAT44(var3,result1);\n          }\n          var5 = __subdf3(result1,var3,0x33145c07,0x3ca1a626);\n          var6 = 0x400921fb54442d18;\n        }\n        var5 = __subdf3((int)var5,(int)((ulonglong)var5 >> 0x20),(int)var6,\n                         (int)((ulonglong)var6 >> 0x20));\n        return var5;\n      }\n    }\n    if ((int)input2 < 0) {\n      var5 = 0xbff921fb54442d18;\n    }\n    else {\n      var5 = 0x3ff921fb54442d18;\n    }\n  }\n  return var5;\n}\n\n",
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "uVar1": "result1",
                "extraout_r1": "result2",
                "extraout_r1_00": "result3",
                "unaff_r4": "result4",
                "uVar2": "var1",
                "uVar3": "var2",
                "iVar4": "var3",
                "uVar5": "var4",
                "uVar6": "var5",
                "uVar7": "var6"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006228": {
            "entrypoint": "0x08006228",
            "current_name": "compute_floating_point_08006228",
            "code": "\nvoid computeFloatingPoint_08006228(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint absParameter1;\n  undefined4 extraOut1;\n  uint extraOut2;\n  undefined4 absParameter2;\n  undefined4 extraOut3;\n  undefined4 extraOut4;\n  uint extraOut5;\n  undefined4 extraOut6;\n  undefined4 result;\n  int iterator1;\n  uint value;\n  int iterator2;\n  undefined4 absParameter3;\n  uint absParameter4;\n  undefined4 temp1;\n  uint temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined8 temp5;\n  undefined8 temp6;\n  undefined8 temp7;\n  undefined8 temp8;\n  longlong temp9;\n  ulonglong temp10;\n  undefined8 temp11;\n  undefined4 temp12;\n  undefined4 extraParam;\n  undefined4 local_68;\n  undefined4 local_64;\n  int local_54;\n  \n  temp2 = value4 & 0x7fffffff;\n  if ((temp2 | value3) == 0) {\n    return;\n  }\n  absParameter4 = value2 & 0x7fffffff;\n  if (absParameter4 < 0x7ff00001) {\n    if (absParameter4 == 0x7ff00000) {\n      if (value1 == 0) {\n        if (0x7ff00000 < temp2) goto LAB_08006278;\nLAB_08006262:\n        if ((temp2 != 0x7ff00000) || (value3 == 0)) {\n          if (-1 < (int)value2) goto LAB_0800632a;\n          if (temp2 < 0x43400000) {\n            if (temp2 < 0x3ff00000) {\nLAB_0800632a:\n              absParameter1 = 0;\n              goto LAB_080062ba;\n            }\n            iterator1 = ((int)temp2 >> 0x14) + -0x3ff;\n            if (0x14 < iterator1) {\n              absParameter1 = value3 >> (0x34U - iterator1 & 0xff);\n              if (value3 == absParameter1 << (0x34U - iterator1 & 0xff)) {\n                absParameter1 = 2 - (absParameter1 & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (value3 == 0) {\n              absParameter1 = (int)temp2 >> (0x14U - iterator1 & 0xff);\n              if (temp2 == absParameter1 << (0x14U - iterator1 & 0xff)) {\n                absParameter1 = 2 - (absParameter1 & 1);\n              }\n              else {\n                absParameter1 = 0;\n              }\n              goto LAB_0800630c;\n            }\n            absParameter1 = 0;\n          }\n          else {\n            absParameter1 = 2;\nLAB_080062ba:\n            if (value3 == 0) {\n              if (temp2 == 0x7ff00000) {\n                return;\n              }\nLAB_0800630c:\n              if (temp2 == 0x3ff00000) {\n                if (-1 < (int)value4) {\n                  return;\n                }\n                temp5 = 0x3ff0000000000000;\n                temp6 = CONCAT44(value2,value1);\n                goto LAB_08006320;\n              }\n              if (value4 == 0x40000000) goto LAB_0800634a;\n              if ((value4 == 0x3fe00000) && (-1 < (int)value2)) {\n                __ieee754_sqrt(value1,value2);\n                return;\n              }\n            }\n          }\n          value = value1;\n          fabs((double)CONCAT44(extraParam,absParameter1));\n          temp10 = CONCAT44(value2,value) & 0x7fffffffffffffff;\n          if ((value1 == 0) && ((absParameter4 == 0 || ((value2 & 0x3fffffff) == 0x3ff00000)))) {\n            if ((int)value4 < 0) {\n              __divdf3(0,0x3ff00000,value,extraOut1);\n            }\n            if (-1 < (int)value2) {\n              return;\n            }\n            if ((absParameter1 | absParameter4 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            value = 0xffffffff - ((int)value2 >> 0x1f);\n            if ((absParameter1 | value) != 0) {\n              if (temp2 < 0x41e00001) {\n                local_54 = 0;\n                if (absParameter4 < 0x100000) {\n                  temp10 = __muldf3();\n                  local_54 = -0x35;\n                }\n                temp2 = (uint)(temp10 >> 0x20);\n                local_54 = ((int)temp2 >> 0x14) + -0x3ff + local_54;\n                temp2 = temp2 & 0xfffff;\n                absParameter4 = temp2 | 0x3ff00000;\n                if (temp2 < 0x3988f) {\nLAB_08006628:\n                  iterator1 = 0;\n                }\n                else {\n                  if (0xbb679 < temp2) {\n                    absParameter4 = absParameter4 - 0x100000;\n                    local_54 = local_54 + 1;\n                    goto LAB_08006628;\n                  }\n                  iterator1 = 1;\n                }\n                iterator2 = iterator1 * 8;\n                absParameter3 = (&bp)[iterator1 * 2];\n                temp12 = (&DAT_080073c4)[iterator1 * 2];\n                temp5 = __subdf3();\n                temp3 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp6 = __aeabi_dadd((int)temp10,absParameter4,absParameter3,temp12);\n                temp6 = __divdf3(0,0x3ff00000,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n                temp4 = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp7 = __muldf3((int)temp5,temp3,(int)temp6,temp4);\n                absParameter2 = (undefined4)((ulonglong)temp7 >> 0x20);\n                temp1 = (undefined4)temp7;\n                temp7 = __muldf3(0,absParameter2);\n                temp5 = __subdf3((int)temp5,temp3,(int)temp7,(int)((ulonglong)temp7 >> 0x20));\n                temp7 = __subdf3(0,((int)absParameter4 >> 1 | 0x20000000U) + 0x80000 + iterator1 * 0x40000,\n                                  absParameter3,temp12);\n                temp7 = __subdf3((int)temp10,absParameter4,(int)temp7,(int)((ulonglong)temp7 >> 0x20));\n                temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),0,absParameter2);\n                temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp7,\n                                  (int)((ulonglong)temp7 >> 0x20));\n                temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp6,temp4);\n                temp4 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp6 = __muldf3(temp1,absParameter2);\n                absParameter3 = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp3 = (undefined4)temp6;\n                temp6 = __muldf3(temp3,absParameter3,0x4a454eef,0x3fca7e28);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x93c9db65,\n                                      0x3fcd864a);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp3,absParameter3);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0xa91d4101,\n                                      0x3fd17460);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp3,absParameter3);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x518f264d,\n                                      0x3fd55555);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp3,absParameter3);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0xdb6fabff,\n                                      0x3fdb6db6);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp3,absParameter3);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x33333303,\n                                      0x3fe33333);\n                temp7 = __muldf3(temp3,absParameter3,temp3,absParameter3);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp7,\n                                  (int)((ulonglong)temp7 >> 0x20));\n                temp7 = __aeabi_dadd(temp1,absParameter2,0,absParameter2);\n                temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp5,temp4);\n                temp6 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp6,\n                                      (int)((ulonglong)temp6 >> 0x20));\n                temp3 = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp7 = __muldf3(0,absParameter2,0,absParameter2);\n                absParameter3 = (undefined4)((ulonglong)temp7 >> 0x20);\n                temp8 = __aeabi_dadd((int)temp7,absParameter3,0,0x40080000);\n                __aeabi_dadd((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp6,temp3);\n                temp8 = __muldf3(0,absParameter2,0,extraOut3);\n                temp12 = (undefined4)((ulonglong)temp8 >> 0x20);\n                temp11 = __subdf3(0,extraOut3,0,0x40080000);\n                temp7 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp7,absParameter3);\n                temp6 = __subdf3((int)temp6,temp3,(int)temp7,(int)((ulonglong)temp7 >> 0x20));\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp1,absParameter2);\n                temp5 = __muldf3((int)temp5,temp4,0,extraOut3);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp5,\n                                      (int)((ulonglong)temp5 >> 0x20));\n                temp1 = (undefined4)((ulonglong)temp6 >> 0x20);\n                __aeabi_dadd((int)temp8,temp12,(int)temp6,temp1);\n                temp5 = __muldf3(0,extraOut4,0xe0000000,0x3feec709);\n                temp7 = __subdf3(0,extraOut4,(int)temp8,temp12);\n                temp6 = __subdf3((int)temp6,temp1,(int)temp7,(int)((ulonglong)temp7 >> 0x20));\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),0xdc3a03fd,0x3feec709\n                                 );\n                temp7 = __muldf3(0,extraOut4,0x145b01f5,0xbe3e2fe0);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp7,\n                                      (int)((ulonglong)temp7 >> 0x20));\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),\n                                      *(undefined4 *)(&dp_l + iterator2),\n                                      *(undefined4 *)(&DAT_080073e4 + iterator2));\n                temp7 = __aeabi_i2d(local_54);\n                temp1 = (undefined4)((ulonglong)temp7 >> 0x20);\n                temp3 = *(undefined4 *)(&dp_h + iterator2);\n                temp4 = *(undefined4 *)(&DAT_080073d4 + iterator2);\n                temp8 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp6,\n                                      (int)((ulonglong)temp6 >> 0x20));\n                temp8 = __aeabi_dadd((int)temp8,(int)((ulonglong)temp8 >> 0x20),temp3,temp4);\n                __aeabi_dadd((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp7,temp1);\n                temp7 = __subdf3(0,extraOut5,(int)temp7,temp1);\n                temp9 = __subdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp3,temp4);\n                temp2 = extraOut5;\n              }\n              else {\n                if (0x43f00000 < temp2) {\n                  if (0x3fefffff < absParameter4) {\nLAB_08006418:\n                    if ((int)value4 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)value4) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if (absParameter4 < 0x3fefffff) goto LAB_080063fa;\n                if (0x3ff00000 < absParameter4) goto LAB_08006418;\n                temp5 = __subdf3();\n                temp3 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp1 = (undefined4)temp5;\n                temp5 = __muldf3(temp1,temp3,0x60000000,0x3ff71547);\n                temp6 = __muldf3(temp1,temp3,0xf85ddf44,0x3e54ae0b);\n                temp7 = __muldf3(temp1,temp3,0,0x3fd00000);\n                temp7 = __subdf3(0x55555555,0x3fd55555,(int)temp7,(int)((ulonglong)temp7 >> 0x20)\n                                 );\n                temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp1,temp3);\n                temp7 = __subdf3(0,0x3fe00000,(int)temp7,(int)((ulonglong)temp7 >> 0x20));\n                temp8 = __muldf3(temp1,temp3,temp1,temp3);\n                temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp8,\n                                  (int)((ulonglong)temp8 >> 0x20));\n                temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),0x652b82fe,0x3ff71547\n                                 );\n                temp6 = __subdf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp7,\n                                  (int)((ulonglong)temp7 >> 0x20));\n                __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp6,\n                             (int)((ulonglong)temp6 >> 0x20));\n                temp9 = (ulonglong)extraOut2 << 0x20;\n                temp2 = extraOut2;\n              }\n              temp5 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp5,\n                                (int)((ulonglong)temp5 >> 0x20));\n              temp5 = __subdf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp5,\n                                (int)((ulonglong)temp5 >> 0x20));\n              if ((absParameter1 - 1 | value) == 0) {\n                temp1 = 0xbff00000;\n              }\n              else {\n                temp1 = 0x3ff00000;\n              }\n              temp12 = 0;\n              temp6 = __subdf3(value3,value4,0,value4);\n              temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),0,temp2);\n              temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),value3,value4);\n              temp5 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp5,\n                                    (int)((ulonglong)temp5 >> 0x20));\n              absParameter2 = (undefined4)((ulonglong)temp5 >> 0x20);\n              temp3 = (undefined4)temp5;\n              temp5 = __muldf3(0,temp2,0,value4);\n              absParameter3 = (undefined4)((ulonglong)temp5 >> 0x20);\n              temp4 = (undefined4)temp5;\n              temp9 = __aeabi_dadd(temp3,absParameter2,temp4,absParameter3);\n              absParameter4 = (uint)((ulonglong)temp9 >> 0x20);\n              temp2 = (uint)temp9;\n              if (0x408fffffffffffff < temp9) {\n                if ((absParameter4 + 0xbf700000 | temp2) == 0) {\n                  temp6 = __aeabi_dadd(temp3,absParameter2,0x652b82fe,0x3c971547);\n                  temp7 = __subdf3(temp2,absParameter4,temp4,absParameter3);\n                  iterator1 = __aeabi_dcmpgt((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp7,\n                                         (int)((ulonglong)temp7 >> 0x20));\n                  if (iterator1 == 0) goto LAB_08006968;\n                }\n                __muldf3(temp12,temp1,0x8800759c,0x7e37e43c);\n                goto LAB_0800634a;\n              }\n              if ((absParameter4 & 0x7fffffff) < 0x4090cc00) {\nLAB_08006968:\n                if ((absParameter4 & 0x7fffffff) < 0x3fe00001) {\n                  iterator1 = 0;\n                }\n                else {\n                  absParameter4 = (0x100000 >> (((int)(absParameter4 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          absParameter4;\n                  temp2 = (absParameter4 * 2 >> 0x15) - 0x3ff;\n                  iterator1 = (int)(absParameter4 & 0xfffff | 0x100000) >> (0x14 - temp2 & 0xff);\n                  if (temp9 < 0) {\n                    iterator1 = -iterator1;\n                  }\n                  temp5 = __subdf3(temp4,absParameter3,0,absParameter4 & ~(0xfffff >> (temp2 & 0xff)));\n                }\n                local_64 = (undefined4)((ulonglong)temp5 >> 0x20);\n                local_68 = (undefined4)temp5;\n                __aeabi_dadd(local_68,local_64,temp3,absParameter2);\n                temp5 = __muldf3(0,extraOut6,0,0x3fe62e43);\n                temp4 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp6 = __subdf3(0,extraOut6,local_68,local_64);\n                temp6 = __subdf3(temp3,absParameter2,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),0xfefa39ef,0x3fe62e42\n                                 );\n                temp7 = __muldf3(0,extraOut6,0xca86c39,0xbe205c61);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp7,\n                                      (int)((ulonglong)temp7 >> 0x20));\n                absParameter2 = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp7 = __aeabi_dadd((int)temp5,temp4,(int)temp6,absParameter2);\n                absParameter3 = (undefined4)((ulonglong)temp7 >> 0x20);\n                temp3 = (undefined4)temp7;\n                temp5 = __subdf3(temp3,absParameter3,(int)temp5,temp4);\n                temp5 = __subdf3((int)temp6,absParameter2,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                absParameter2 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp6 = __muldf3(temp3,absParameter3,temp3,absParameter3);\n                result = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp4 = (undefined4)temp6;\n                temp6 = __muldf3(temp4,result,0x72bea4d0,0x3e663769);\n                temp6 = __subdf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),0xc5d26bf1,0x3ebbbd41\n                                 );\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp4,result);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0xaf25de2c,\n                                      0x3f11566a);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp4,result);\n                temp6 = __subdf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x16bebd93,0x3f66c16c\n                                 );\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp4,result);\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x5555553e,\n                                      0x3fc55555);\n                temp6 = __muldf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp4,result);\n                temp6 = __subdf3(temp3,absParameter3,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n                temp4 = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp7 = __muldf3(temp3,absParameter3,(int)temp6,temp4);\n                temp6 = __subdf3((int)temp6,temp4,0,0x40000000);\n                temp6 = __divdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp6,\n                                  (int)((ulonglong)temp6 >> 0x20));\n                temp7 = __muldf3(temp3,absParameter3,(int)temp5,absParameter2);\n                temp5 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp5,absParameter2\n                                     );\n                temp5 = __subdf3((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp5,\n                                  (int)((ulonglong)temp5 >> 0x20));\n                temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),temp3,absParameter3);\n                temp5 = __subdf3(0,0x3ff00000,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                if ((int)((ulonglong)temp5 >> 0x20) + iterator1 * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(temp1,temp12),(int)temp5);\n                }\n              }\n              else {\n                if ((absParameter4 + 0x3f6f3400 | temp2) == 0) {\n                  temp6 = __subdf3(temp2,absParameter4,temp4,absParameter3);\n                  iterator1 = __aeabi_dcmple(temp3,absParameter2,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n                  if (iterator1 == 0) goto LAB_08006968;\n                }\n                __muldf3(temp12,temp1,0xc2f8f359,0x1a56e1f);\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          temp5 = __subdf3();\n          temp6 = temp5;\nLAB_08006320:\n          __divdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp6,\n                   (int)((ulonglong)temp6 >> 0x20));\n          return;\n        }\n      }\n    }\n    else if (temp2 < 0x7ff00001) goto LAB_08006262;\n  }\n  if ((absParameter4 + 0xc0100000 | value1) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(\"\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006228": "compute_floating_point_08006228",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "absParameter1",
                "extraout_r1": "extraOut1",
                "extraout_r1_00": "extraOut2",
                "uVar2": "absParameter2",
                "extraout_r1_01": "extraOut3",
                "extraout_r1_02": "extraOut4",
                "extraout_r1_03": "extraOut5",
                "extraout_r1_04": "extraOut6",
                "uVar3": "result",
                "iVar4": "iterator1",
                "uVar5": "value",
                "iVar6": "iterator2",
                "uVar7": "absParameter3",
                "uVar8": "absParameter4",
                "uVar9": "temp1",
                "uVar10": "temp2",
                "uVar11": "temp3",
                "uVar12": "temp4",
                "uVar13": "temp5",
                "uVar14": "temp6",
                "uVar15": "temp7",
                "uVar16": "temp8",
                "lVar17": "temp9",
                "uVar18": "temp10",
                "uVar19": "temp11",
                "uVar20": "temp12",
                "in_stack_ffffff94": "extraParam"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_i2d",
                "scalbn",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__aeabi_dcmple",
                "nan",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c0c": {
            "entrypoint": "0x08006c0c",
            "current_name": "calculate_float_08006c0c",
            "code": "\nundefined8 calculate_float_08006c0c(uint input1,uint input2)\n\n{\n  undefined4 temp1;\n  uint temp2;\n  int shift;\n  int count;\n  uint mask;\n  uint temp3;\n  int result;\n  uint temp4;\n  uint temp5;\n  int bitCount;\n  uint temp6;\n  undefined8 output;\n  \n  if ((~input2 & 0x7ff00000) == 0) {\n    output = __muldf3(input1,input2,input1,input2);\n    output = __aeabi_dadd(input1,input2,(int)output,(int)((ulonglong)output >> 0x20));\n    return output;\n  }\n  if ((int)input2 < 1) {\n    if ((input2 & 0x7fffffff | input1) == 0) {\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != 0) {\n      output = __subdf3(input1,input2,input1,input2);\n      temp1 = (undefined4)((ulonglong)output >> 0x20);\n      output = __divdf3((int)output,temp1,(int)output,temp1);\n      return output;\n    }\n  }\n  shift = (int)input2 >> 0x14;\n  if (shift == 0) {\n    while (input2 == 0) {\n      shift = shift + -0x15;\n      input2 = input1 >> 0xb;\n      input1 = input1 << 0x15;\n    }\n    temp2 = 0;\n    for (; -1 < (int)(input2 << 0xb); input2 = input2 << 1) {\n      temp2 = temp2 + 1;\n    }\n    shift = shift - (temp2 - 1);\n    input2 = input2 | input1 >> (0x20 - temp2 & 0xff);\n    input1 = input1 << (temp2 & 0xff);\n  }\n  result = 0;\n  temp2 = input2 & 0xfffff | 0x100000;\n  if ((shift + -0x3ff) * -0x80000000 < 0) {\n    temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n    input1 = input1 << 1;\n  }\n  temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n  count = 0x16;\n  mask = 0;\n  temp4 = 0x200000;\n  input1 = input1 << 1;\n  do {\n    bitCount = mask + temp4;\n    if (bitCount <= (int)temp2) {\n      temp2 = temp2 - bitCount;\n      mask = bitCount + temp4;\n      result = result + temp4;\n    }\n    count = count + -1;\n    temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n    temp4 = temp4 >> 1;\n    input1 = input1 << 1;\n  } while (count != 0);\n  bitCount = 0x20;\n  temp5 = 0x80000000;\n  temp4 = 0;\n  count = 0;\n  do {\n    temp6 = temp5 + count;\n    temp3 = mask;\n    if (((int)mask < (int)temp2) || ((temp2 == mask && (temp6 <= input1)))) {\n      count = temp6 + temp5;\n      if (((int)temp6 < 0) && (-1 < count)) {\n        temp3 = mask + 1;\n      }\n      temp2 = temp2 - mask;\n      if (input1 < temp6) {\n        temp2 = temp2 - 1;\n      }\n      input1 = input1 - temp6;\n      temp4 = temp4 + temp5;\n    }\n    temp2 = temp2 * 2 - ((int)input1 >> 0x1f);\n    bitCount = bitCount + -1;\n    input1 = input1 << 1;\n    temp5 = temp5 >> 1;\n    mask = temp3;\n  } while (bitCount != 0);\n  if ((input1 | temp2) != 0) {\n    if (temp4 == 0xffffffff) {\n      result = result + 1;\n      temp4 = 0;\n    }\n    else {\n      temp4 = temp4 + 1 & 0xfffffffe;\n    }\n  }\n  temp4 = temp4 >> 1;\n  if (result << 0x1f < 0) {\n    temp4 = temp4 | 0x80000000;\n  }\n  return CONCAT44((result >> 1) + 0x3fe00000 + (shift + -0x3ff >> 1) * 0x100000,temp4);\n}\n\n",
            "renaming": {
                "FUN_08006c0c": "calculate_float_08006c0c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "shift",
                "iVar4": "count",
                "uVar5": "mask",
                "uVar6": "temp3",
                "iVar7": "result",
                "uVar8": "temp4",
                "uVar9": "temp5",
                "iVar10": "bitCount",
                "uVar11": "temp6",
                "uVar12": "output"
            },
            "calling": [
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d68": {
            "entrypoint": "0x08006d68",
            "current_name": "calculate_square_root_08006d68",
            "code": "\ndouble calculateSquareRoot_08006d68(double inputValue)\n\n{\n  int integerPart;\n  int comparisonResult;\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  uint fractionalPart;\n  undefined4 tempVar3;\n  undefined4 tempVar4;\n  undefined4 tempVar5;\n  undefined4 tempVar6;\n  undefined4 tempVar7;\n  undefined4 tempVar8;\n  undefined4 tempVar9;\n  uint absoluteValue;\n  double result;\n  double tempVar10;\n  undefined8 tempVar11;\n  undefined8 tempVar12;\n  \n  tempVar12 = CONCAT44(fractionalPart,integerPart);\n  absoluteValue = fractionalPart & 0x7fffffff;\n  if (absoluteValue < 0x44100000) {\n    if (absoluteValue < 0x3fdc0000) {\n      if (absoluteValue < 0x3e200000) {\n        tempVar11 = __aeabi_dadd(integerPart,fractionalPart,0x8800759c,0x7e37e43c);\n        comparisonResult = __aeabi_dcmpgt((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0,0x3ff00000);\n        if (comparisonResult != 0) {\n          return tempVar10;\n        }\n      }\n      comparisonResult = -1;\n    }\n    else {\n      fabs((double)CONCAT44(tempVar7,tempVar6));\n      if (absoluteValue < 0x3ff30000) {\n        if (absoluteValue < 0x3fe60000) {\n          tempVar12 = __aeabi_dadd();\n          tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0,0x3ff00000);\n          tempVar11 = __aeabi_dadd(integerPart,tempVar3,0,0x40000000);\n          tempVar12 = __divdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),(int)tempVar11,\n                            (int)((ulonglong)tempVar11 >> 0x20));\n          comparisonResult = 0;\n        }\n        else {\n          tempVar12 = __subdf3();\n          tempVar11 = __aeabi_dadd(integerPart,tempVar3,0,0x3ff00000);\n          tempVar12 = __divdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),(int)tempVar11,\n                            (int)((ulonglong)tempVar11 >> 0x20));\n          comparisonResult = 1;\n        }\n      }\n      else if (absoluteValue < 0x40038000) {\n        tempVar12 = __subdf3();\n        tempVar11 = __muldf3(integerPart,tempVar3,0,0x3ff80000);\n        tempVar11 = __aeabi_dadd((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0,0x3ff00000);\n        tempVar12 = __divdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),(int)tempVar11,\n                          (int)((ulonglong)tempVar11 >> 0x20));\n        comparisonResult = 2;\n      }\n      else {\n        tempVar12 = __divdf3(0,0xbff00000,integerPart,tempVar3);\n        comparisonResult = 3;\n      }\n    }\n    tempVar9 = (undefined4)((ulonglong)tempVar12 >> 0x20);\n    tempVar8 = (undefined4)tempVar12;\n    tempVar12 = __muldf3(tempVar8,tempVar9,tempVar8,tempVar9);\n    tempVar4 = (undefined4)((ulonglong)tempVar12 >> 0x20);\n    tempVar1 = (undefined4)tempVar12;\n    tempVar12 = __muldf3(tempVar1,tempVar4,tempVar1,tempVar4);\n    tempVar5 = (undefined4)((ulonglong)tempVar12 >> 0x20);\n    tempVar2 = (undefined4)tempVar12;\n    tempVar12 = __muldf3(tempVar2,tempVar5,0xe322da11,0x3f90ad3a);\n    tempVar12 = __aeabi_dadd((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0x24760deb,0x3fa97b4b);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar2,tempVar5);\n    tempVar12 = __aeabi_dadd((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0xa0d03d51,0x3fb10d66);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar2,tempVar5);\n    tempVar12 = __aeabi_dadd((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0xc54c206e,0x3fb745cd);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar2,tempVar5);\n    tempVar12 = __aeabi_dadd((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0x920083ff,0x3fc24924);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar2,tempVar5);\n    tempVar12 = __aeabi_dadd((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0x5555550d,0x3fd55555);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar1,tempVar4);\n    tempVar1 = (undefined4)((ulonglong)tempVar12 >> 0x20);\n    tempVar11 = __muldf3(tempVar2,tempVar5,0x2c6a6c2f,0xbfa2b444);\n    tempVar11 = __subdf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0x52defd9a,0x3fadde2d);\n    tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar2,tempVar5);\n    tempVar11 = __subdf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar2,tempVar5);\n    tempVar11 = __subdf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0xfe231671,0x3fbc71c6);\n    tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar2,tempVar5);\n    tempVar11 = __subdf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),0x9998ebc4,0x3fc99999);\n    tempVar11 = __muldf3((int)tempVar11,(int)((ulonglong)tempVar11 >> 0x20),tempVar2,tempVar5);\n    tempVar2 = (undefined4)((ulonglong)tempVar11 >> 0x20);\n    if (comparisonResult == -1) {\n      tempVar12 = __aeabi_dadd((int)tempVar12,tempVar1,(int)tempVar11,tempVar2);\n      tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar8,tempVar9);\n      result = (double)__subdf3(tempVar8,tempVar9,(int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20));\n    }\n    else {\n      tempVar12 = __aeabi_dadd((int)tempVar12,tempVar1,(int)tempVar11,tempVar2);\n      tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar8,tempVar9);\n      comparisonResult = comparisonResult * 8;\n      tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),\n                        *(undefined4 *)(&atanlo + comparisonResult),*(undefined4 *)(&UNK_08007414 + comparisonResult));\n      tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar8,tempVar9);\n      result = (double)__subdf3(*(undefined4 *)(&atanhi + comparisonResult),\n                               *(undefined4 *)(&UNK_080073f4 + comparisonResult),(int)tempVar12,\n                               (int)((ulonglong)tempVar12 >> 0x20));\n    }\n  }\n  else if ((0x7ff00000 < absoluteValue) || ((absoluteValue == 0x7ff00000 && (integerPart != 0)))) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d68": "calculate_square_root_08006d68",
                "__x": "inputValue",
                "in_r0": "integerPart",
                "iVar1": "comparisonResult",
                "uVar2": "tempVar1",
                "uVar3": "tempVar2",
                "in_r1": "fractionalPart",
                "extraout_r1": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "in_r3": "tempVar6",
                "unaff_r4": "tempVar7",
                "uVar6": "tempVar8",
                "uVar7": "tempVar9",
                "uVar8": "absoluteValue",
                "in_d0": "result",
                "extraout_d0": "tempVar10",
                "uVar9": "tempVar11",
                "uVar10": "tempVar12"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800708c": {
            "entrypoint": "0x0800708c",
            "current_name": "calculate_0800708c",
            "code": "\ndouble calculate_0800708c(double input_value)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800708c": "calculate_0800708c",
                "__x": "input_value",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007092": {
            "entrypoint": "0x08007092",
            "current_name": "extract_sign_bit_08007092",
            "code": "\nint extract_sign_bit_08007092(double input_value)\n\n{\n  uint sign_bit;\n  \n  return (sign_bit | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_08007092": "extract_sign_bit_08007092",
                "__value": "input_value",
                "in_r1": "sign_bit"
            },
            "calling": [
                "pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800709e": {
            "entrypoint": "0x0800709e",
            "current_name": "handle_exception_0800709e",
            "code": "\nint handle_exception_0800709e(exception *exception_obj)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800709e": "handle_exception_0800709e",
                "__exc": "exception_obj"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070a4": {
            "entrypoint": "0x080070a4",
            "current_name": "calculate_tag_value_080070a4",
            "code": "\ndouble calculateTagValue_080070a4(char *tag)\n\n{\n  double tagValue;\n  \n  return tagValue;\n}\n\n",
            "renaming": {
                "FUN_080070a4": "calculate_tag_value_080070a4",
                "__tagb": "tag",
                "in_d0": "tagValue"
            },
            "calling": [
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070b0": {
            "entrypoint": "0x080070b0",
            "current_name": "calculate_inverse_square_root_080070b0",
            "code": "\ndouble calculate_inverse_square_root_080070b0(double input_value)\n\n{\n  int sign_bit;\n  uint lower_bits;\n  uint higher_bits;\n  undefined4 two52_ptr;\n  undefined4 data_ptr;\n  uint exponent;\n  uint mask;\n  double result;\n  double difference;\n  undefined8 sum;\n  \n  mask = (higher_bits << 1) >> 0x15;\n  exponent = mask - 0x3ff;\n  sign_bit = (int)higher_bits >> 0x1f;\n  if ((int)exponent < 0x14) {\n    if ((int)exponent < 0) {\n      if ((higher_bits & 0x7fffffff | lower_bits) == 0) {\n        return result;\n      }\n      exponent = higher_bits & 0xfffff | lower_bits;\n      sign_bit = sign_bit * -8;\n      two52_ptr = *(undefined4 *)(&TWO52 + sign_bit);\n      data_ptr = *(undefined4 *)(&DAT_08007434 + sign_bit);\n      sum = __aeabi_dadd(lower_bits,(-exponent | exponent) >> 0xc & 0x80000 | higher_bits & 0xfffe0000,two52_ptr,data_ptr)\n      ;\n      difference = (double)__subdf3((int)sum,(int)((ulonglong)sum >> 0x20),two52_ptr,data_ptr);\n      return difference;\n    }\n    mask = 0xfffff >> (exponent & 0xff);\n    if ((higher_bits & mask | lower_bits) == 0) {\n      return result;\n    }\n    mask = mask >> 1;\n    lower_bits = higher_bits & mask | lower_bits;\n    if (lower_bits != 0) {\n      if (exponent == 0x13) {\n        lower_bits = 0x80000000;\n      }\n      else {\n        lower_bits = 0;\n      }\n      higher_bits = 0x40000 >> (exponent & 0xff) | higher_bits & ~mask;\n    }\n  }\n  else {\n    if (0x33 < (int)exponent) {\n      if (exponent != 0x400) {\n        return result;\n      }\n      difference = (double)__aeabi_dadd();\n      return difference;\n    }\n    mask = mask - 0x413;\n    exponent = 0xffffffff >> (mask & 0xff);\n    if ((lower_bits & exponent) == 0) {\n      return result;\n    }\n    exponent = exponent >> 1;\n    if ((lower_bits & exponent) != 0) {\n      lower_bits = 0x40000000 >> (mask & 0xff) | lower_bits & ~exponent;\n    }\n  }\n  sign_bit = sign_bit * -8;\n  two52_ptr = *(undefined4 *)(&TWO52 + sign_bit);\n  data_ptr = *(undefined4 *)(&DAT_08007434 + sign_bit);\n  sum = __aeabi_dadd(lower_bits,higher_bits,two52_ptr,data_ptr);\n  difference = (double)__subdf3((int)sum,(int)((ulonglong)sum >> 0x20),two52_ptr,data_ptr);\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080070b0": "calculate_inverse_square_root_080070b0",
                "__x": "input_value",
                "iVar1": "sign_bit",
                "in_r0": "lower_bits",
                "in_r1": "higher_bits",
                "in_d0": "result",
                "uVar2": "two52_ptr",
                "uVar3": "data_ptr",
                "uVar4": "exponent",
                "uVar5": "mask",
                "dVar6": "difference",
                "uVar7": "sum"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071c0": {
            "entrypoint": "0x080071c0",
            "current_name": "calculate_exponential_080071c0",
            "code": "\ndouble calculateExponential_080071c0(double input,int power)\n\n{\n  uint temp1;\n  int temp2;\n  int temp3;\n  uint shiftedTemp1;\n  int combinedTemp;\n  undefined4 in_r3;\n  undefined4 unused1;\n  undefined4 unused2;\n  undefined4 unused3;\n  double result;\n  double finalResult;\n  \n  shiftedTemp1 = (temp1 << 1) >> 0x15;\n  if (shiftedTemp1 == 0) {\n    if ((temp1 & 0x7fffffff | power) == 0) {\n      return result;\n    }\n    result = (double)multiplyDouble(power,temp1,0,0x43500000);\n    if (temp3 < -50000) goto LAB_0800722e;\n    shiftedTemp1 = ((uint)(temp2 << 1) >> 0x15) - 0x36;\n  }\n  else if (shiftedTemp1 == 0x7ff) {\n    finalResult = (double)addDouble(power,temp1,power);\n    return finalResult;\n  }\n  combinedTemp = shiftedTemp1 + temp3;\n  if (combinedTemp < 0x7ff) {\n    if (0 < combinedTemp) {\n      return result;\n    }\n    if (combinedTemp + 0x35 < 0 == checkOverflow(combinedTemp,0x35)) goto LAB_0800722e;\n    if (temp3 < 0xc351) {\n      copySign((double)concatenate(unused1,in_r3),(double)concatenate(unused3,unused2));\n      goto LAB_0800722e;\n    }\n  }\n  copySign((double)concatenate(unused1,in_r3),(double)concatenate(unused3,unused2));\nLAB_0800722e:\n  finalResult = (double)multiplyDouble();\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080071c0": "calculate_exponential_080071c0",
                "__x": "input",
                "__n": "power",
                "in_r1": "temp1",
                "extraout_r1": "temp2",
                "in_r2": "temp3",
                "uVar1": "shiftedTemp1",
                "iVar2": "combinedTemp",
                "in_d0": "result",
                "dVar3": "finalResult",
                "__muldf3": "multiplyDouble",
                "__aeabi_dadd": "addDouble",
                "unaff_r4": "unused1",
                "unaff_r5": "unused2",
                "unaff_r6": "unused3",
                "copysign": "copySign",
                "SCARRY4": "checkOverflow",
                "CONCAT44": "concatenate"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "copysign"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800729c": {
            "entrypoint": "0x0800729c",
            "current_name": "compute_hypotenuse_0800729c",
            "code": "\ndouble compute_hypotenuse_0800729c(double length_of_side_a,double length_of_side_b)\n\n{\n  double hypotenuse_length;\n  \n  return hypotenuse_length;\n}\n\n",
            "renaming": {
                "FUN_0800729c": "compute_hypotenuse_0800729c",
                "__x": "length_of_side_a",
                "__y": "length_of_side_b",
                "in_d0": "hypotenuse_length"
            },
            "calling": [
                "scalbn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072ac": {
            "entrypoint": "0x080072ac",
            "current_name": "get_impure_pointer_080072ac",
            "code": "\nundefined4 getImpurePointer_080072ac(void)\n\n{\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_080072ac": "get_impure_pointer_080072ac",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072b8": {
            "entrypoint": "0x080072b8",
            "current_name": "allocate_memory_080072b8",
            "code": "\nvoid * allocateMemory_080072b8(intptr_t memorySize)\n\n{\n  undefined *previousHeapEnd;\n  \n  if (currentHeapEnd == (undefined *)0x0) {\n    currentHeapEnd = &_ebss;\n  }\n  previousHeapEnd = currentHeapEnd;\n  currentHeapEnd = currentHeapEnd + memorySize;\n  return previousHeapEnd;\n}\n\n",
            "renaming": {
                "FUN_080072b8": "allocate_memory_080072b8",
                "__delta": "memorySize",
                "puVar1": "previousHeapEnd",
                "heap_end_4116": "currentHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d4": {
            "entrypoint": "0x080072d4",
            "current_name": "get_evp_key_context_pointer_080072d4",
            "code": "\nint getEVPKeyContextPointer_080072d4(EVP_PKEY_CTX *contextPointer)\n\n{\n  return (int)contextPointer;\n}\n\n",
            "renaming": {
                "FUN_080072d4": "get_evp_key_context_pointer_080072d4",
                "ctx": "contextPointer"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072e0": {
            "entrypoint": "0x080072e0",
            "current_name": "FUNC_080072e0",
            "code": "\nvoid FUNC_080072e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072e0": "FUNC_080072e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 172226,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000160",
            "FUN_08000168",
            "FUN_0800016c",
            "FUN_080003e4",
            "FUN_08000404",
            "FUN_08000428",
            "FUN_08000464",
            "FUN_08000474",
            "FUN_080006ac",
            "FUN_08000892",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000904",
            "FUN_08000980",
            "FUN_08000990",
            "FUN_080009a0",
            "FUN_080009b4",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a30",
            "FUN_08000ad0",
            "FUN_08000ad8",
            "FUN_08000adc",
            "FUN_08000c3c",
            "FUN_08000c44",
            "FUN_08000c60",
            "FUN_08000c70",
            "FUN_08000cec",
            "FUN_08000e54",
            "FUN_08000f8c",
            "FUN_08000f94",
            "FUN_08000f9c",
            "FUN_08000ffc",
            "FUN_08001004",
            "FUN_08001014",
            "FUN_08001028",
            "FUN_0800103c",
            "FUN_08001050",
            "FUN_08001064",
            "FUN_08001078",
            "FUN_080010c4",
            "FUN_08001104",
            "FUN_08001128",
            "FUN_0800114c",
            "FUN_0800115c",
            "FUN_08001170",
            "FUN_08001194",
            "FUN_080011fc",
            "FUN_08001214",
            "FUN_08001240",
            "FUN_0800125a",
            "FUN_08001264",
            "FUN_08001424",
            "FUN_0800142e",
            "FUN_08001436",
            "FUN_08001460",
            "FUN_080014e2",
            "FUN_08001530",
            "FUN_080015e8",
            "FUN_080016f4",
            "FUN_08001754",
            "FUN_08001828",
            "FUN_08001938",
            "FUN_08001b58",
            "FUN_08002008",
            "FUN_0800209c",
            "FUN_08002214",
            "FUN_08002220",
            "FUN_08002250",
            "FUN_08002280",
            "FUN_080022d0",
            "FUN_08002324",
            "FUN_08002368",
            "FUN_080023d0",
            "FUN_08002404",
            "FUN_0800245c",
            "FUN_08002520",
            "FUN_08002538",
            "FUN_08002564",
            "FUN_080025a4",
            "FUN_080025e8",
            "FUN_08002724",
            "FUN_0800277c",
            "FUN_080028a6",
            "FUN_0800290c",
            "FUN_0800299a",
            "FUN_08002ad0",
            "FUN_08002b48",
            "FUN_08002bf0",
            "FUN_08002cb0",
            "FUN_08002d88",
            "FUN_08002ea0",
            "FUN_08002ec0",
            "FUN_08002ed4",
            "FUN_08002ee8",
            "FUN_08002f28",
            "FUN_08003034",
            "FUN_08003068",
            "FUN_08003078",
            "FUN_08003298",
            "FUN_08003314",
            "FUN_08003320",
            "FUN_08003330",
            "FUN_08003eac",
            "FUN_08003eb0",
            "FUN_08003ec8",
            "FUN_08003ef2",
            "FUN_08003f0e",
            "FUN_08003f3c",
            "FUN_08003f7c",
            "FUN_08003fc4",
            "FUN_08003fd0",
            "FUN_08003fdc",
            "FUN_08003fe8",
            "FUN_08003ff4",
            "FUN_08004028",
            "FUN_0800403c",
            "FUN_0800407c",
            "FUN_080040b8",
            "FUN_080040e8",
            "FUN_0800411c",
            "FUN_08004194",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_080041e4",
            "FUN_0800426c",
            "FUN_08004300",
            "FUN_08004348",
            "FUN_08004384",
            "FUN_080043bc",
            "FUN_080043f0",
            "FUN_08004410",
            "FUN_08004434",
            "FUN_08004458",
            "FUN_08004490",
            "FUN_08004514",
            "FUN_0800458c",
            "FUN_0800483c",
            "FUN_08004978",
            "FUN_08004a30",
            "FUN_08004a84",
            "FUN_08004c18",
            "FUN_08004c30",
            "FUN_08004c64",
            "FUN_08004c70",
            "FUN_08004c8c",
            "FUN_08004cac",
            "FUN_08004ccc",
            "FUN_08004d48",
            "FUN_08004d8c",
            "FUN_08004e14",
            "FUN_08004e7c",
            "FUN_08004ee6",
            "FUN_08004ee8",
            "FUN_08004eea",
            "FUN_08004eec",
            "FUN_08004ef4",
            "FUN_08004f04",
            "FUN_08004f10",
            "FUN_08004f60",
            "FUN_08004f68",
            "FUN_08004fb0",
            "FUN_08004fb4",
            "FUN_08004ffc",
            "FUN_08005044",
            "FUN_080050fc",
            "FUN_080052e4",
            "FUN_080053d4",
            "FUN_08005614",
            "FUN_08005630",
            "FUN_08005646",
            "FUN_0800567c",
            "FUN_08005714",
            "FUN_080057d0",
            "FUN_0800581c",
            "FUN_08005840",
            "FUN_08005854",
            "FUN_08005900",
            "FUN_08005bc8",
            "FUN_08005c70",
            "FUN_08006070",
            "FUN_08006228",
            "FUN_08006c0c",
            "FUN_08006d68",
            "FUN_0800708c",
            "FUN_08007092",
            "FUN_0800709e",
            "FUN_080070a4",
            "FUN_080070b0",
            "FUN_080071c0",
            "FUN_0800729c",
            "FUN_080072ac",
            "FUN_080072b8",
            "FUN_080072d4"
        ],
        [
            "FUN_080004d0",
            "FUN_08000724"
        ]
    ],
    "locked_functions": []
}