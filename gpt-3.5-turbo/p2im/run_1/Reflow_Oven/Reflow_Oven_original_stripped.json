{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "initialize_completed_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 initializeCompletedFlag_0800010c(undefined4 inputValue)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "initialize_completed_flag_0800010c",
                "param_1": "inputValue",
                "completed_8667": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculateStringLength_08000178(char *inputString)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = inputString;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)inputString));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "inputString",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPointer",
                "pcVar3": "currentCharPointer"
            },
            "calling": [
                "print",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "addition_with_xor_08000188",
            "code": "\nvoid additionWithXor_08000188(undefined4 result,uint inputValue)\n\n{\n  performAddition(result,inputValue ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000188": "addition_with_xor_08000188",
                "param_1": "result",
                "param_2": "inputValue",
                "__aeabi_dadd": "performAddition"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000190": {
            "entrypoint": "0x08000190",
            "current_name": "calculate_shifted_sum_08000190",
            "code": "\nulonglong calculateShiftedSum_08000190(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftedSum;\n  byte carry;\n  uint mask;\n  uint temp1;\n  uint temp2;\n  uint result1;\n  uint result2;\n  int shiftAmount;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool isZero;\n  bool condition;\n  bool overflow;\n  \n  result1 = input4 ^ 0x80000000;\n  temp3 = input2 << 1;\n  input4 = input4 << 1;\n  isZero = ((input2 ^ result1) & 0x7fffffff) == 0;\n  condition = isZero && input1 == input3;\n  if (!isZero || input1 != input3) {\n    condition = (temp3 | input1) == 0;\n  }\n  if (!condition) {\n    condition = (input4 | input3) == 0;\n  }\n  shiftAmount = (int)temp3 >> 0x15;\n  if (!condition) {\n    condition = shiftAmount == -1;\n  }\n  shiftedSum = (int)input4 >> 0x15;\n  if (!condition) {\n    condition = shiftedSum == -1;\n  }\n  if (condition) {\n    if (shiftAmount == -1 || shiftedSum == -1) {\n      temp3 = result1;\n      temp5 = input3;\n      if (shiftAmount == -1) {\n        temp3 = input2;\n        temp5 = input1;\n      }\n      if (shiftAmount != -1 || shiftedSum != -1) {\n        input3 = temp5;\n        result1 = temp3;\n      }\n      condition = (temp5 | temp3 << 0xc) == 0;\n      if (condition) {\n        condition = (input3 | result1 << 0xc) == 0;\n      }\n      if (condition) {\n        condition = temp3 == result1;\n      }\n      if (!condition) {\n        temp3 = temp3 | 0x80000;\n      }\n      return CONCAT44(temp3,temp5);\n    }\n    if (((input2 ^ result1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp3 | input1) == 0) {\n        input1 = input3;\n        input2 = result1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != result1) {\n      return 0;\n    }\n    if (temp3 >> 0x15 == 0) {\n      condition = (input1 & 0x80000000) != 0;\n      result1 = input2 * 2 + (uint)condition;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)condition)) {\n        result1 = result1 | 0x80000000;\n      }\n      return CONCAT44(result1,input1 << 1);\n    }\n    if (temp3 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp3 = temp3 >> 0x15;\n  input4 = input4 >> 0x15;\n  temp5 = input4 - temp3;\n  condition = temp5 != 0;\n  if (input4 < temp3) {\n    temp5 = -temp5;\n  }\n  temp4 = input1;\n  result2 = input2;\n  if (condition && temp3 <= input4) {\n    temp3 = temp3 + temp5;\n    temp4 = input3;\n    result2 = result1;\n    input3 = input1;\n    result1 = input2;\n  }\n  if (0x36 < temp5) {\n    return CONCAT44(result2,temp4);\n  }\n  temp1 = result2 & 0xfffff | 0x100000;\n  if ((result2 & 0x80000000) != 0) {\n    condition = temp4 != 0;\n    temp4 = -temp4;\n    temp1 = -temp1 - (uint)condition;\n  }\n  result2 = result1 & 0xfffff | 0x100000;\n  if ((result1 & 0x80000000) != 0) {\n    condition = input3 != 0;\n    input3 = -input3;\n    result2 = -result2 - (uint)condition;\n  }\n  if (temp3 == temp5) {\n    result2 = result2 ^ 0x100000;\n    if (temp3 == 0) {\n      temp1 = temp1 ^ 0x100000;\n      temp3 = 1;\n    }\n    else {\n      temp5 = temp5 - 1;\n    }\n  }\n  result1 = -temp5 + 0x20;\n  if ((int)temp5 < 0x21) {\n    temp6 = input3 << (result1 & 0xff);\n    input3 = input3 >> (temp5 & 0xff);\n    mask = temp4 + input3;\n    temp2 = result2 << (result1 & 0xff);\n    result1 = mask + temp2;\n    temp1 = temp1 + CARRY4(temp4,input3) + ((int)result2 >> (temp5 & 0xff)) +\n            (uint)CARRY4(mask,temp2);\n  }\n  else {\n    temp6 = result2 << (-temp5 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp6 = temp6 | 2;\n    }\n    result2 = (int)result2 >> (temp5 - 0x20 & 0xff);\n    result1 = temp4 + result2;\n    temp1 = temp1 + ((int)result2 >> 0x1f) + (uint)CARRY4(temp4,result2);\n  }\n  input2 = temp1 & 0x80000000;\n  temp5 = temp1;\n  if ((int)temp1 < 0) {\n    condition = temp6 == 0;\n    temp6 = -temp6;\n    temp5 = -result1;\n    result1 = -(uint)!condition - result1;\n    temp5 = -(uint)(condition <= temp5) - temp1;\n  }\n  if (0xfffff < temp5) {\n    temp4 = temp3 - 1;\n    if (0x1fffff < temp5) {\n      temp4 = temp5 & 1;\n      temp5 = temp5 >> 1;\n      carry = (byte)result1;\n      result1 = (uint)(temp4 != 0) << 0x1f | result1 >> 1;\n      temp6 = (uint)(carry & 1) << 0x1f | temp6 >> 1;\n      temp4 = temp3;\n      if (0xffbfffff < temp3 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    condition = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      condition = (result1 & 1) != 0;\n    }\n    return CONCAT44(temp5 + temp4 * 0x100000 + (uint)CARRY4(result1,(uint)condition) | input2,\n                    result1 + condition);\n  }\n  isZero = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  temp4 = result1 * 2;\n  condition = CARRY4(result1,result1);\n  result1 = result1 * 2 + (uint)isZero;\n  temp5 = temp5 * 2 + (uint)(condition || CARRY4(temp4,(uint)isZero));\n  temp4 = temp3 - 2;\n  if ((temp5 & 0x100000) != 0) goto LAB_080002a0;\n  result2 = result1;\n  temp3 = temp5;\n  if (temp5 == 0) {\n    result2 = 0;\n    temp3 = result1;\n  }\n  shiftAmount = LZCOUNT(temp3);\n  if (temp5 == 0) {\n    shiftAmount = shiftAmount + 0x20;\n  }\n  temp5 = shiftAmount - 0xb;\n  overflow = SBORROW4(temp5,0x20);\n  result1 = shiftAmount - 0x2b;\n  condition = (int)result1 < 0;\n  isZero = result1 == 0;\n  if ((int)temp5 < 0x20) {\n    overflow = SCARRY4(result1,0xc);\n    shiftAmount = shiftAmount + -0x1f;\n    condition = shiftAmount < 0;\n    isZero = shiftAmount == 0;\n    result1 = temp5;\n    if (!isZero && condition == overflow) {\n      result2 = temp3 << (temp5 & 0xff);\n      temp3 = temp3 >> (0xcU - shiftAmount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZero || condition != overflow) {\n    temp6 = 0x20 - result1;\n  }\n  temp3 = temp3 << (result1 & 0xff);\n  if (isZero || condition != overflow) {\n    temp3 = temp3 | result2 >> (temp6 & 0xff);\n  }\n  if (isZero || condition != overflow) {\n    result2 = result2 << (result1 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp5 <= (int)temp4) {\n    return CONCAT44(temp3 + (temp4 - temp5) * 0x100000 | input2,result2);\n  }\n  result1 = ~(temp4 - temp5);\n  if ((int)result1 < 0x1f) {\n    shiftAmount = result1 - 0x13;\n    if (shiftAmount != 0 && shiftAmount < 0 == SCARRY4(result1 - 0x1f,0xc)) {\n      return CONCAT44(temp1,result2 >> (0x20 - (0xcU - shiftAmount) & 0xff) | temp3 << (0xcU - shiftAmount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result1 = result1 + 1;\n    return CONCAT44(input2 | temp3 >> (result1 & 0xff),\n                    result2 >> (result1 & 0xff) | temp3 << (0x20 - result1 & 0xff));\n  }\n  return CONCAT44(temp1,temp3 >> (result1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000190": "calculate_shifted_sum_08000190",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedSum",
                "bVar2": "carry",
                "uVar3": "mask",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "uVar6": "result1",
                "uVar7": "result2",
                "iVar8": "shiftAmount",
                "uVar9": "temp3",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "uVar12": "temp6",
                "bVar13": "isZero",
                "bVar14": "condition",
                "bVar15": "overflow"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "SetControllerDirection",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000194": {
            "entrypoint": "0x08000194",
            "current_name": "calculate_bitwise_product_08000194",
            "code": "\nulonglong calculate_bitwise_product_08000194(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shift_value1;\n  byte carry_bit;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift_value2;\n  uint shifted_input_2;\n  uint result_1;\n  uint shifted_input_4;\n  uint result_2;\n  uint result_3;\n  uint result_4;\n  bool check1;\n  bool check2;\n  bool check3;\n  \n  shifted_input_2 = input_2 << 1;\n  shifted_input_4 = input_4 << 1;\n  check1 = ((input_2 ^ input_4) & 0x7fffffff) == 0;\n  check2 = check1 && input_1 == input_3;\n  if (!check1 || input_1 != input_3) {\n    check2 = (shifted_input_2 | input_1) == 0;\n  }\n  if (!check2) {\n    check2 = (shifted_input_4 | input_3) == 0;\n  }\n  shift_value2 = (int)shifted_input_2 >> 0x15;\n  if (!check2) {\n    check2 = shift_value2 == -1;\n  }\n  shift_value1 = (int)shifted_input_4 >> 0x15;\n  if (!check2) {\n    check2 = shift_value1 == -1;\n  }\n  if (check2) {\n    if (shift_value2 == -1 || shift_value1 == -1) {\n      shifted_input_4 = input_4;\n      shifted_input_2 = input_3;\n      if (shift_value2 == -1) {\n        shifted_input_4 = input_2;\n        shifted_input_2 = input_1;\n      }\n      if (shift_value2 != -1 || shift_value1 != -1) {\n        input_3 = shifted_input_2;\n        input_4 = shifted_input_4;\n      }\n      check2 = (shifted_input_2 | shifted_input_4 << 0xc) == 0;\n      if (check2) {\n        check2 = (input_3 | input_4 << 0xc) == 0;\n      }\n      if (check2) {\n        check2 = shifted_input_4 == input_4;\n      }\n      if (!check2) {\n        shifted_input_4 = shifted_input_4 | 0x80000;\n      }\n      return CONCAT44(shifted_input_4,shifted_input_2);\n    }\n    if (((input_2 ^ input_4) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((shifted_input_2 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = input_4;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != input_4) {\n      return 0;\n    }\n    if (shifted_input_2 >> 0x15 == 0) {\n      check2 = (input_1 & 0x80000000) != 0;\n      shifted_input_4 = input_2 * 2 + (uint)check2;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)check2)) {\n        shifted_input_4 = shifted_input_4 | 0x80000000;\n      }\n      return CONCAT44(shifted_input_4,input_1 << 1);\n    }\n    if (shifted_input_2 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  shifted_input_2 = shifted_input_2 >> 0x15;\n  shifted_input_4 = shifted_input_4 >> 0x15;\n  result_2 = shifted_input_4 - shifted_input_2;\n  check2 = result_2 != 0;\n  if (shifted_input_4 < shifted_input_2) {\n    result_2 = -result_2;\n  }\n  result_1 = input_1;\n  temp3 = input_2;\n  if (check2 && shifted_input_2 <= shifted_input_4) {\n    shifted_input_2 = shifted_input_2 + result_2;\n    result_1 = input_3;\n    temp3 = input_4;\n    input_3 = input_1;\n    input_4 = input_2;\n  }\n  if (0x36 < result_2) {\n    return CONCAT44(temp3,result_1);\n  }\n  shifted_input_4 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    check2 = result_1 != 0;\n    result_1 = -result_1;\n    shifted_input_4 = -shifted_input_4 - (uint)check2;\n  }\n  temp3 = input_4 & 0xfffff | 0x100000;\n  if ((input_4 & 0x80000000) != 0) {\n    check2 = input_3 != 0;\n    input_3 = -input_3;\n    temp3 = -temp3 - (uint)check2;\n  }\n  if (shifted_input_2 == result_2) {\n    temp3 = temp3 ^ 0x100000;\n    if (shifted_input_2 == 0) {\n      shifted_input_4 = shifted_input_4 ^ 0x100000;\n      shifted_input_2 = 1;\n    }\n    else {\n      result_2 = result_2 - 1;\n    }\n  }\n  result_4 = -result_2 + 0x20;\n  if ((int)result_2 < 0x21) {\n    result_3 = input_3 << (result_4 & 0xff);\n    input_3 = input_3 >> (result_2 & 0xff);\n    temp1 = result_1 + input_3;\n    temp2 = temp3 << (result_4 & 0xff);\n    result_4 = temp1 + temp2;\n    shifted_input_4 = shifted_input_4 + CARRY4(result_1,input_3) + ((int)temp3 >> (result_2 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    result_3 = temp3 << (-result_2 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      result_3 = result_3 | 2;\n    }\n    temp3 = (int)temp3 >> (result_2 - 0x20 & 0xff);\n    result_4 = result_1 + temp3;\n    shifted_input_4 = shifted_input_4 + ((int)temp3 >> 0x1f) + (uint)CARRY4(result_1,temp3);\n  }\n  input_2 = shifted_input_4 & 0x80000000;\n  result_2 = shifted_input_4;\n  if ((int)shifted_input_4 < 0) {\n    check2 = result_3 == 0;\n    result_3 = -result_3;\n    result_2 = -result_4;\n    result_4 = -(uint)!check2 - result_4;\n    result_2 = -(uint)(check2 <= result_2) - shifted_input_4;\n  }\n  if (0xfffff < result_2) {\n    result_1 = shifted_input_2 - 1;\n    if (0x1fffff < result_2) {\n      shifted_input_4 = result_2 & 1;\n      result_2 = result_2 >> 1;\n      carry_bit = (byte)result_4;\n      result_4 = (uint)(shifted_input_4 != 0) << 0x1f | result_4 >> 1;\n      result_3 = (uint)(carry_bit & 1) << 0x1f | result_3 >> 1;\n      result_1 = shifted_input_2;\n      if (0xffbfffff < shifted_input_2 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    check2 = 0x7fffffff < result_3;\n    if (result_3 == 0x80000000) {\n      check2 = (result_4 & 1) != 0;\n    }\n    return CONCAT44(result_2 + result_1 * 0x100000 + (uint)CARRY4(result_4,(uint)check2) | input_2,\n                    result_4 + check2);\n  }\n  check1 = (result_3 & 0x80000000) != 0;\n  result_3 = result_3 << 1;\n  result_1 = result_4 * 2;\n  check2 = CARRY4(result_4,result_4);\n  result_4 = result_4 * 2 + (uint)check1;\n  result_2 = result_2 * 2 + (uint)(check2 || CARRY4(result_1,(uint)check1));\n  result_1 = shifted_input_2 - 2;\n  if ((result_2 & 0x100000) != 0) goto LAB_080002a0;\n  temp3 = result_4;\n  shifted_input_2 = result_2;\n  if (result_2 == 0) {\n    temp3 = 0;\n    shifted_input_2 = result_4;\n  }\n  shift_value2 = LZCOUNT(shifted_input_2);\n  if (result_2 == 0) {\n    shift_value2 = shift_value2 + 0x20;\n  }\n  result_4 = shift_value2 - 0xb;\n  check3 = SBORROW4(result_4,0x20);\n  result_2 = shift_value2 - 0x2b;\n  check2 = (int)result_2 < 0;\n  check1 = result_2 == 0;\n  if ((int)result_4 < 0x20) {\n    check3 = SCARRY4(result_2,0xc);\n    shift_value2 = shift_value2 + -0x1f;\n    check2 = shift_value2 < 0;\n    check1 = shift_value2 == 0;\n    result_2 = result_4;\n    if (!check1 && check2 == check3) {\n      temp3 = shifted_input_2 << (result_4 & 0xff);\n      shifted_input_2 = shifted_input_2 >> (0xcU - shift_value2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (check1 || check2 != check3) {\n    result_3 = 0x20 - result_2;\n  }\n  shifted_input_2 = shifted_input_2 << (result_2 & 0xff);\n  if (check1 || check2 != check3) {\n    shifted_input_2 = shifted_input_2 | temp3 >> (result_3 & 0xff);\n  }\n  if (check1 || check2 != check3) {\n    temp3 = temp3 << (result_2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)result_4 <= (int)result_1) {\n    return CONCAT44(shifted_input_2 + (result_1 - result_4) * 0x100000 | input_2,temp3);\n  }\n  result_2 = ~(result_1 - result_4);\n  if ((int)result_2 < 0x1f) {\n    shift_value2 = result_2 - 0x13;\n    if (shift_value2 != 0 && shift_value2 < 0 == SCARRY4(result_2 - 0x1f,0xc)) {\n      return CONCAT44(shifted_input_4,temp3 >> (0x20 - (0xcU - shift_value2) & 0xff) | shifted_input_2 << (0xcU - shift_value2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result_2 = result_2 + 1;\n    return CONCAT44(input_2 | shifted_input_2 >> (result_2 & 0xff),\n                    temp3 >> (result_2 & 0xff) | shifted_input_2 << (0x20 - result_2 & 0xff));\n  }\n  return CONCAT44(shifted_input_4,shifted_input_2 >> (result_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000194": "calculate_bitwise_product_08000194",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shift_value1",
                "bVar2": "carry_bit",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shift_value2",
                "uVar7": "shifted_input_2",
                "uVar8": "result_1",
                "uVar9": "shifted_input_4",
                "uVar10": "result_2",
                "uVar11": "result_3",
                "uVar12": "result_4",
                "bVar13": "check1",
                "bVar14": "check2",
                "bVar15": "check3"
            },
            "calling": [
                "loop",
                "Compute",
                "__aeabi_drsub",
                "readThermocouple",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800040c": {
            "entrypoint": "0x0800040c",
            "current_name": "process_bitwise_operation_0800040c",
            "code": "\nulonglong processBitwiseOperation_0800040c(uint inputValue)\n\n{\n  uint result1;\n  uint result2;\n  int shiftAmount;\n  uint temp;\n  uint constantValue;\n  bool isNegativeShift;\n  bool isZeroShift;\n  bool isSubtractionOverflows;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  result1 = 0;\n  shiftAmount = LZCOUNT(inputValue);\n  temp = shiftAmount + 0x15;\n  isSubtractionOverflows = SBORROW4(temp,0x20);\n  result2 = shiftAmount - 0xb;\n  isNegativeShift = (int)result2 < 0;\n  isZeroShift = result2 == 0;\n  if (temp < 0x20) {\n    isSubtractionOverflows = SCARRY4(result2,0xc);\n    isNegativeShift = false;\n    isZeroShift = shiftAmount + 1 == 0;\n    result2 = temp;\n    if (!isZeroShift && isSubtractionOverflows == false) {\n      result1 = inputValue << temp;\n      inputValue = inputValue >> (0xcU - (shiftAmount + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZeroShift || isNegativeShift != isSubtractionOverflows) {\n    constantValue = 0x20 - result2;\n  }\n  inputValue = inputValue << (result2 & 0xff);\n  if (isZeroShift || isNegativeShift != isSubtractionOverflows) {\n    inputValue = inputValue | 0U >> (constantValue & 0xff);\n  }\n  if (isZeroShift || isNegativeShift != isSubtractionOverflows) {\n    result1 = 0 << (result2 & 0xff);\n  }\nLAB_08000318:\n  if (temp < 0x433) {\n    return CONCAT44(inputValue + (0x432 - temp) * 0x100000,result1);\n  }\n  result2 = ~(0x432 - temp);\n  if (0x1e < (int)result2) {\n    return (ulonglong)(inputValue >> (result2 - 0x1f & 0xff));\n  }\n  shiftAmount = result2 - 0x13;\n  if (shiftAmount == 0 || shiftAmount < 0 != SCARRY4(result2 - 0x1f,0xc)) {\n    result2 = result2 + 1;\n    return CONCAT44(inputValue >> (result2 & 0xff),\n                    result1 >> (result2 & 0xff) | inputValue << (0x20 - result2 & 0xff));\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - shiftAmount) & 0xff) | inputValue << (0xcU - shiftAmount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800040c": "process_bitwise_operation_0800040c",
                "param_1": "inputValue",
                "uVar1": "result1",
                "uVar2": "result2",
                "iVar3": "shiftAmount",
                "uVar4": "temp",
                "in_r12": "constantValue",
                "bVar5": "isNegativeShift",
                "bVar6": "isZeroShift",
                "bVar7": "isSubtractionOverflows"
            },
            "calling": [
                "loop",
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800042c": {
            "entrypoint": "0x0800042c",
            "current_name": "calculate_shifted_value_0800042c",
            "code": "\nulonglong calculate_shifted_value_0800042c(uint input_value)\n\n{\n  uint shift_count;\n  uint abs_input_value;\n  uint bit_offset;\n  int Leading_zeros;\n  uint total_bits;\n  uint sign_bit;\n  uint remaining_bits;\n  bool is_negative;\n  bool is_zero;\n  bool carry_flag;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  sign_bit = input_value & 0x80000000;\n  abs_input_value = input_value;\n  if ((int)sign_bit < 0) {\n    abs_input_value = -input_value;\n  }\n  shift_count = 0;\n  Leading_zeros = LZCOUNT(abs_input_value);\n  total_bits = Leading_zeros + 0x15;\n  carry_flag = SBORROW4(total_bits,0x20);\n  bit_offset = Leading_zeros - 0xb;\n  is_negative = (int)bit_offset < 0;\n  is_zero = bit_offset == 0;\n  if (total_bits < 0x20) {\n    carry_flag = SCARRY4(bit_offset,0xc);\n    is_negative = false;\n    is_zero = Leading_zeros + 1 == 0;\n    bit_offset = total_bits;\n    if (!is_zero && carry_flag == false) {\n      shift_count = abs_input_value << total_bits;\n      abs_input_value = abs_input_value >> (0xcU - (Leading_zeros + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_zero || is_negative != carry_flag) {\n    remaining_bits = 0x20 - bit_offset;\n  }\n  abs_input_value = abs_input_value << (bit_offset & 0xff);\n  if (is_zero || is_negative != carry_flag) {\n    abs_input_value = abs_input_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero || is_negative != carry_flag) {\n    shift_count = 0 << (bit_offset & 0xff);\n  }\nLAB_08000318:\n  if (total_bits < 0x433) {\n    return CONCAT44(abs_input_value + (0x432 - total_bits) * 0x100000 | sign_bit,shift_count);\n  }\n  bit_offset = ~(0x432 - total_bits);\n  if (0x1e < (int)bit_offset) {\n    return CONCAT44(input_value,abs_input_value >> (bit_offset - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  Leading_zeros = bit_offset - 0x13;\n  if (Leading_zeros == 0 || Leading_zeros < 0 != SCARRY4(bit_offset - 0x1f,0xc)) {\n    bit_offset = bit_offset + 1;\n    return CONCAT44(sign_bit | abs_input_value >> (bit_offset & 0xff),\n                    shift_count >> (bit_offset & 0xff) | abs_input_value << (0x20 - bit_offset & 0xff));\n  }\n  return CONCAT44(input_value,shift_count >> (0x20 - (0xcU - Leading_zeros) & 0xff) | abs_input_value << (0xcU - Leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800042c": "calculate_shifted_value_0800042c",
                "param_1": "input_value",
                "uVar1": "shift_count",
                "uVar2": "abs_input_value",
                "uVar3": "bit_offset",
                "iVar4": "Leading_zeros",
                "uVar5": "total_bits",
                "uVar6": "sign_bit",
                "in_r12": "remaining_bits",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "carry_flag"
            },
            "calling": [
                "loop",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000450": {
            "entrypoint": "0x08000450",
            "current_name": "apply_bitwise_operations_08000450",
            "code": "\nulonglong applyBitwiseOperations_08000450(uint input,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint bitShiftedInput;\n  uint tempVar1;\n  uint combinedVars;\n  uint shiftedInput;\n  uint multipliedInput;\n  int shiftCount;\n  uint adjustedShiftCount;\n  uint tempVar2;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  multipliedInput = input << 1;\n  bVar2 = multipliedInput == 0;\n  bitShiftedInput = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftedInput = (uint)((int)multipliedInput >> 3) >> 1;\n  combinedVars = bitShiftedInput | shiftedInput;\n  input = input << 0x1d;\n  if (!bVar2) {\n    param4 = multipliedInput & 0xff000000;\n    bVar2 = param4 == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param4 == 0xff000000;\n  }\n  if (!bVar2) {\n    return CONCAT44(combinedVars,input) ^ 0x3800000000000000;\n  }\n  if (multipliedInput == 0 || param4 == 0xff000000) {\n    return CONCAT44(combinedVars,input);\n  }\n  tempVar1 = input;\n  multipliedInput = shiftedInput;\n  if (shiftedInput == 0) {\n    tempVar1 = 0;\n    multipliedInput = input;\n  }\n  shiftCount = LZCOUNT(multipliedInput);\n  if (shiftedInput == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  adjustedShiftCount = shiftCount - 0xb;\n  bVar3 = SBORROW4(adjustedShiftCount,0x20);\n  shiftedInput = shiftCount - 0x2b;\n  bVar2 = (int)shiftedInput < 0;\n  bVar1 = shiftedInput == 0;\n  if ((int)adjustedShiftCount < 0x20) {\n    bVar3 = SCARRY4(shiftedInput,0xc);\n    shiftCount = shiftCount + -0x1f;\n    bVar2 = shiftCount < 0;\n    bVar1 = shiftCount == 0;\n    shiftedInput = adjustedShiftCount;\n    if (!bVar1 && bVar2 == bVar3) {\n      tempVar1 = multipliedInput << (adjustedShiftCount & 0xff);\n      multipliedInput = multipliedInput >> (0xcU - shiftCount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar1 || bVar2 != bVar3) {\n    tempVar2 = 0x20 - shiftedInput;\n  }\n  multipliedInput = multipliedInput << (shiftedInput & 0xff);\n  if (bVar1 || bVar2 != bVar3) {\n    multipliedInput = multipliedInput | tempVar1 >> (tempVar2 & 0xff);\n  }\n  if (bVar1 || bVar2 != bVar3) {\n    tempVar1 = tempVar1 << (shiftedInput & 0xff);\n  }\nLAB_08000318:\n  if ((int)adjustedShiftCount < 0x381) {\n    return CONCAT44(multipliedInput + (0x380 - adjustedShiftCount) * 0x100000 | bitShiftedInput,tempVar1);\n  }\n  shiftedInput = ~(0x380 - adjustedShiftCount);\n  if ((int)shiftedInput < 0x1f) {\n    shiftCount = shiftedInput - 0x13;\n    if (shiftCount != 0 && shiftCount < 0 == SCARRY4(shiftedInput - 0x1f,0xc)) {\n      return CONCAT44(combinedVars,tempVar1 >> (0x20 - (0xcU - shiftCount) & 0xff) | multipliedInput << (0xcU - shiftCount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftedInput = shiftedInput + 1;\n    return CONCAT44(bitShiftedInput | multipliedInput >> (shiftedInput & 0xff),\n                    tempVar1 >> (shiftedInput & 0xff) | multipliedInput << (0x20 - shiftedInput & 0xff));\n  }\n  return CONCAT44(combinedVars,multipliedInput >> (shiftedInput - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000450": "apply_bitwise_operations_08000450",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "bitShiftedInput",
                "uVar2": "tempVar1",
                "uVar3": "combinedVars",
                "uVar4": "shiftedInput",
                "uVar5": "multipliedInput",
                "iVar6": "shiftCount",
                "uVar7": "adjustedShiftCount",
                "in_r12": "tempVar2",
                "bVar8": "bVar1",
                "bVar9": "bVar2",
                "bVar10": "bVar3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800048c": {
            "entrypoint": "0x0800048c",
            "current_name": "calculate_unsigned_decimal_0800048c",
            "code": "\nulonglong calculateUnsignedDecimal_0800048c(uint input1,uint input2)\n\n{\n  byte firstByte;\n  uint result1;\n  uint result2;\n  uint result3;\n  int shiftValue;\n  uint shiftedResult;\n  int modifiedValue;\n  uint shiftedInput2;\n  bool isNegative;\n  bool carry;\n  bool overflow;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  modifiedValue = 0x432;\n  shiftedInput2 = input2 >> 0x16;\n  if (shiftedInput2 != 0) {\n    modifiedValue = 3;\n    if (input2 >> 0x19 != 0) {\n      modifiedValue = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      modifiedValue = modifiedValue + 3;\n    }\n    result3 = modifiedValue - ((int)input2 >> 0x1f);\n    shiftedInput2 = input1 << (0x20 - result3 & 0xff);\n    input1 = input1 >> (result3 & 0xff) | input2 << (0x20 - result3 & 0xff);\n    input2 = input2 >> (result3 & 0xff);\n    modifiedValue = result3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      result3 = input2 & 1;\n      input2 = input2 >> 1;\n      firstByte = (byte)input1;\n      input1 = (uint)(result3 != 0) << 0x1f | input1 >> 1;\n      shiftedInput2 = (uint)(firstByte & 1) << 0x1f | shiftedInput2 >> 1;\n      modifiedValue = modifiedValue + 1;\n      if (0xffbfffff < (uint)(modifiedValue * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    carry = 0x7fffffff < shiftedInput2;\n    if (shiftedInput2 == 0x80000000) {\n      carry = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + modifiedValue * 0x100000 + (uint)CARRY4(input1,(uint)carry),input1 + carry\n                   );\n  }\n  isNegative = (shiftedInput2 & 0x80000000) != 0;\n  shiftedInput2 = shiftedInput2 << 1;\n  result3 = input1 * 2;\n  carry = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)isNegative;\n  input2 = input2 * 2 + (uint)(carry || CARRY4(result3,(uint)isNegative));\n  modifiedValue = modifiedValue + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_080002a0;\n  result1 = input1;\n  result3 = input2;\n  if (input2 == 0) {\n    result1 = 0;\n    result3 = input1;\n  }\n  shiftValue = LZCOUNT(result3);\n  if (input2 == 0) {\n    shiftValue = shiftValue + 0x20;\n  }\n  shiftedResult = shiftValue - 0xb;\n  overflow = SBORROW4(shiftedResult,0x20);\n  result2 = shiftValue - 0x2b;\n  carry = (int)result2 < 0;\n  isNegative = result2 == 0;\n  if ((int)shiftedResult < 0x20) {\n    overflow = SCARRY4(result2,0xc);\n    shiftValue = shiftValue + -0x1f;\n    carry = shiftValue < 0;\n    isNegative = shiftValue == 0;\n    result2 = shiftedResult;\n    if (!isNegative && carry == overflow) {\n      result1 = result3 << (shiftedResult & 0xff);\n      result3 = result3 >> (0xcU - shiftValue & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isNegative || carry != overflow) {\n    shiftedInput2 = 0x20 - result2;\n  }\n  result3 = result3 << (result2 & 0xff);\n  if (isNegative || carry != overflow) {\n    result3 = result3 | result1 >> (shiftedInput2 & 0xff);\n  }\n  if (isNegative || carry != overflow) {\n    result1 = result1 << (result2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)shiftedResult <= modifiedValue) {\n    return CONCAT44(result3 + (modifiedValue - shiftedResult) * 0x100000,result1);\n  }\n  shiftedInput2 = ~(modifiedValue - shiftedResult);\n  if (0x1e < (int)shiftedInput2) {\n    return (ulonglong)(result3 >> (shiftedInput2 - 0x1f & 0xff));\n  }\n  modifiedValue = shiftedInput2 - 0x13;\n  if (modifiedValue == 0 || modifiedValue < 0 != SCARRY4(shiftedInput2 - 0x1f,0xc)) {\n    shiftedInput2 = shiftedInput2 + 1;\n    return CONCAT44(result3 >> (shiftedInput2 & 0xff),result1 >> (shiftedInput2 & 0xff) | result3 << (0x20 - shiftedInput2 & 0xff)\n                   );\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - modifiedValue) & 0xff) | result3 << (0xcU - modifiedValue & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800048c": "calculate_unsigned_decimal_0800048c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "firstByte",
                "uVar2": "result1",
                "uVar3": "result2",
                "uVar4": "result3",
                "iVar5": "shiftValue",
                "uVar6": "shiftedResult",
                "iVar7": "modifiedValue",
                "uVar8": "shiftedInput2",
                "bVar9": "isNegative",
                "bVar10": "carry",
                "bVar11": "overflow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800049c": {
            "entrypoint": "0x0800049c",
            "current_name": "calculate_unsigned_division_0800049c",
            "code": "\nulonglong calculateUnsignedDivision_0800049c(uint dividend,uint divisor)\n\n{\n  byte carry;\n  uint quotient;\n  uint remainder;\n  uint temp1;\n  int count;\n  uint shift;\n  int shiftCount;\n  uint signBit;\n  uint temp2;\n  bool isSet;\n  bool isSet2;\n  bool isSubtraction;\n  \n  if ((dividend | divisor) == 0) {\n    return CONCAT44(divisor,dividend);\n  }\n  signBit = divisor & 0x80000000;\n  remainder = divisor;\n  if ((int)signBit < 0) {\n    isSet2 = dividend != 0;\n    dividend = -dividend;\n    remainder = -divisor - (uint)isSet2;\n  }\n  shiftCount = 0x432;\n  temp2 = remainder >> 0x16;\n  if (temp2 != 0) {\n    shiftCount = 3;\n    if (remainder >> 0x19 != 0) {\n      shiftCount = 6;\n    }\n    if (remainder >> 0x1c != 0) {\n      shiftCount = shiftCount + 3;\n    }\n    temp1 = shiftCount - ((int)remainder >> 0x1f);\n    temp2 = dividend << (0x20 - temp1 & 0xff);\n    dividend = dividend >> (temp1 & 0xff) | remainder << (0x20 - temp1 & 0xff);\n    remainder = remainder >> (temp1 & 0xff);\n    shiftCount = temp1 + 0x432;\n  }\n  if (0xfffff < remainder) {\n    if (0x1fffff < remainder) {\n      temp1 = remainder & 1;\n      remainder = remainder >> 1;\n      carry = (byte)dividend;\n      dividend = (uint)(temp1 != 0) << 0x1f | dividend >> 1;\n      temp2 = (uint)(carry & 1) << 0x1f | temp2 >> 1;\n      shiftCount = shiftCount + 1;\n      if (0xffbfffff < (uint)(shiftCount * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080002a0:\n    isSet2 = 0x7fffffff < temp2;\n    if (temp2 == 0x80000000) {\n      isSet2 = (dividend & 1) != 0;\n    }\n    return CONCAT44(remainder + shiftCount * 0x100000 + (uint)CARRY4(dividend,(uint)isSet2) | signBit,\n                    dividend + isSet2);\n  }\n  isSet = (temp2 & 0x80000000) != 0;\n  temp2 = temp2 << 1;\n  temp1 = dividend * 2;\n  isSet2 = CARRY4(dividend,dividend);\n  dividend = dividend * 2 + (uint)isSet;\n  remainder = remainder * 2 + (uint)(isSet2 || CARRY4(temp1,(uint)isSet));\n  shiftCount = shiftCount + -1;\n  if ((remainder & 0x100000) != 0) goto LAB_080002a0;\n  quotient = dividend;\n  temp1 = remainder;\n  if (remainder == 0) {\n    quotient = 0;\n    temp1 = dividend;\n  }\n  count = LZCOUNT(temp1);\n  if (remainder == 0) {\n    count = count + 0x20;\n  }\n  shift = count - 0xb;\n  isSubtraction = SBORROW4(shift,0x20);\n  remainder = count - 0x2b;\n  isSet2 = (int)remainder < 0;\n  isSet = remainder == 0;\n  if ((int)shift < 0x20) {\n    isSubtraction = SCARRY4(remainder,0xc);\n    count = count + -0x1f;\n    isSet2 = count < 0;\n    isSet = count == 0;\n    remainder = shift;\n    if (!isSet && isSet2 == isSubtraction) {\n      quotient = temp1 << (shift & 0xff);\n      temp1 = temp1 >> (0xcU - count & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isSet || isSet2 != isSubtraction) {\n    temp2 = 0x20 - remainder;\n  }\n  temp1 = temp1 << (remainder & 0xff);\n  if (isSet || isSet2 != isSubtraction) {\n    temp1 = temp1 | quotient >> (temp2 & 0xff);\n  }\n  if (isSet || isSet2 != isSubtraction) {\n    quotient = quotient << (remainder & 0xff);\n  }\nLAB_08000318:\n  if ((int)shift <= shiftCount) {\n    return CONCAT44(temp1 + (shiftCount - shift) * 0x100000 | signBit,quotient);\n  }\n  remainder = ~(shiftCount - shift);\n  if (0x1e < (int)remainder) {\n    return CONCAT44(divisor,temp1 >> (remainder - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shiftCount = remainder - 0x13;\n  if (shiftCount == 0 || shiftCount < 0 != SCARRY4(remainder - 0x1f,0xc)) {\n    remainder = remainder + 1;\n    return CONCAT44(signBit | temp1 >> (remainder & 0xff),\n                    quotient >> (remainder & 0xff) | temp1 << (0x20 - remainder & 0xff));\n  }\n  return CONCAT44(divisor,quotient >> (0x20 - (0xcU - shiftCount) & 0xff) | temp1 << (0xcU - shiftCount & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800049c": "calculate_unsigned_division_0800049c",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "carry",
                "uVar2": "quotient",
                "uVar3": "remainder",
                "uVar4": "temp1",
                "iVar5": "count",
                "uVar6": "shift",
                "iVar7": "shiftCount",
                "uVar8": "signBit",
                "uVar9": "temp2",
                "bVar10": "isSet",
                "bVar11": "isSet2",
                "bVar12": "isSubtraction"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004f8": {
            "entrypoint": "0x080004f8",
            "current_name": "calculate_output_080004f8",
            "code": "\nulonglong calculate_output_080004f8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong result_1;\n  longlong temp_l;\n  uint temp_3;\n  uint temp_4;\n  int temp3;\n  uint temp_6;\n  uint temp5;\n  uint mask;\n  uint temp_8;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong combined_input;\n  \n  combined_input = CONCAT44(input2,input1);\n  mask = 0x7ff;\n  temp_4 = input2 >> 0x14 & 0x7ff;\n  flag1 = temp_4 == 0;\n  if (!flag1) {\n    temp5 = input4 >> 0x14 & 0x7ff;\n    flag1 = temp5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp_4 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp5 == 0x7ff;\n  }\n  if (flag1) {\n    combined_input = calculate_xor_bitmask_080006d4();\n  }\n  temp_3 = (uint)(combined_input >> 0x20);\n  temp3 = temp_4 + temp5;\n  temp_4 = temp_3 ^ input4;\n  temp_3 = temp_3 & ~(mask << 0x15);\n  input4 = input4 & ~(mask << 0x15);\n  flag1 = ((uint)combined_input | temp_3 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input3 | input4 << 0xc) == 0;\n  }\n  temp_3 = temp_3 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (flag1) {\n    input3 = (uint)combined_input | input3;\n    input4 = (temp_4 & 0x80000000 | temp_3) ^ input4;\n    temp_4 = mask >> 1;\n    flag3 = SBORROW4(temp3,temp_4);\n    temp_6 = temp3 - temp_4;\n    flag1 = temp_6 == 0;\n    temp_3 = temp_6;\n    if (!flag1 && (int)temp_4 <= temp3) {\n      flag3 = SBORROW4(mask,temp_6);\n      temp_3 = mask - temp_6;\n      flag1 = mask == temp_6;\n    }\n    if (!flag1 && (int)temp_3 < 0 == flag3) {\n      input4 = input4 | temp_6 * 0x100000;\n    }\n    if (!flag1 && (int)temp_3 < 0 == flag3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    mask = 0;\n    flag3 = SBORROW4(temp_6,1);\n    temp_6 = temp_6 - 1;\n    flag1 = temp_6 == 0;\n    temp_4 = temp_6;\n  }\n  else {\n    result_1 = (combined_input & 0xffffffff) * (ulonglong)input3;\n    combined_input = (combined_input & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)temp_3 * (ulonglong)input3 + (result_1 >> 0x20);\n    temp_8 = (uint)combined_input;\n    temp_l = (ulonglong)temp_3 * (ulonglong)input4 + (combined_input >> 0x20);\n    mask = (uint)temp_l;\n    temp_3 = (uint)((ulonglong)temp_l >> 0x20);\n    if ((int)result_1 != 0) {\n      temp_8 = temp_8 | 1;\n    }\n    temp_6 = (temp3 + -0x3ff) - (uint)(temp_3 < 0x200);\n    if (temp_3 < 0x200) {\n      flag1 = (temp_8 & 0x80000000) != 0;\n      temp_8 = temp_8 << 1;\n      temp_l = CONCAT44(temp_3 * 2 + (uint)(CARRY4(mask,mask) || CARRY4(mask * 2,(uint)flag1)),\n                       mask * 2 + (uint)flag1);\n    }\n    input4 = temp_4 & 0x80000000 | (int)((ulonglong)temp_l >> 0x20) << 0xb | (uint)temp_l >> 0x15;\n    input3 = (uint)temp_l << 0xb | temp_8 >> 0x15;\n    mask = temp_8 * 0x800;\n    flag2 = 0xfc < temp_6;\n    flag3 = SBORROW4(temp_6,0xfd);\n    temp_3 = temp_6 - 0xfd;\n    flag1 = temp_3 == 0;\n    temp_4 = temp_3;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp_3;\n      flag3 = SBORROW4(temp_3,0x700);\n      temp_4 = temp_6 - 0x7fd;\n      flag1 = temp_3 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < mask;\n      if (mask == 0x80000000) {\n        flag1 = (temp_8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + temp_6 * 0x100000 + (uint)CARRY4(input3,(uint)flag1),input3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp_4 < 0 == flag3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp_6,0x36);\n  flag1 = (int)(temp_6 + 0x36) < 0;\n  flag3 = temp_6 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input4,input3);\n  }\n  temp_4 = -temp_6;\n  temp_3 = temp_4 - 0x20;\n  if (0x1f < (int)temp_4) {\n    temp_6 = input3 >> (temp_3 & 0xff) | input4 << (0x20 - temp_3 & 0xff);\n    temp_4 = (input4 >> (temp_3 & 0xff) & ~((input4 & 0x80000000) >> (temp_3 & 0xff))) -\n            ((int)temp_6 >> 0x1f);\n    if ((mask | input3 << (0x20 - temp_3 & 0xff) | temp_6 << 1) == 0) {\n      temp_4 = temp_4 & ~(temp_6 >> 0x1f);\n    }\n    return CONCAT44(input4,temp_4) & 0x80000000ffffffff;\n  }\n  temp3 = temp_4 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp_3,0xc)) {\n    temp_8 = input3 << (temp_6 + 0x20 & 0xff);\n    temp_3 = input3 >> (temp_4 & 0xff) | input4 << (temp_6 + 0x20 & 0xff);\n    temp_6 = temp_3 + -((int)temp_8 >> 0x1f);\n    if ((mask | temp_8 << 1) == 0) {\n      temp_6 = temp_6 & ~(temp_8 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (temp_4 & 0xff)) +\n                    (uint)CARRY4(temp_3,-((int)temp_8 >> 0x1f)),temp_6);\n  }\n  temp_4 = 0xc - temp3;\n  temp_6 = input3 << (temp_4 & 0xff);\n  temp_4 = input3 >> (0x20 - temp_4 & 0xff) | input4 << (temp_4 & 0xff);\n  temp_3 = temp_4 + -((int)temp_6 >> 0x1f);\n  if ((mask | temp_6 << 1) == 0) {\n    temp_3 = temp_3 & ~(temp_6 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(temp_4,-((int)temp_6 >> 0x1f)),temp_3);\n}\n\n",
            "renaming": {
                "FUN_080004f8": "calculate_output_080004f8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result_1",
                "lVar2": "temp_l",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "iVar5": "temp3",
                "uVar6": "temp_6",
                "unaff_r5": "temp5",
                "uVar7": "mask",
                "uVar8": "temp_8",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "combined_input"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080006d4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006d4": {
            "entrypoint": "0x080006d4",
            "current_name": "calculate_xor_bitmask_080006d4",
            "code": "\nulonglong calculate_XOR_bitmask_080006d4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_2;\n  uint result_bitmask;\n  uint CONST_VALUE;\n  bool is_zero;\n  \n  bit_2 = CONST_VALUE & input_4 >> 0x14;\n  if (bit_2 != CONST_VALUE && bit_2 != CONST_VALUE) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (bit_2 == 0) {\n      result_bitmask = input_2 & 0x80000000;\n      do {\n        bit_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | result_bitmask;\n      if (bit_2 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      bit_2 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(bit_2 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  result_bitmask = input_2;\n  if (((!is_zero) && ((bit_2 != CONST_VALUE || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((bit_2 != CONST_VALUE || (input_1 = input_3, result_bitmask = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(result_bitmask,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006d4": "calculate_xor_bitmask_080006d4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_2",
                "uVar3": "result_bitmask",
                "in_r12": "CONST_VALUE",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800074c": {
            "entrypoint": "0x0800074c",
            "current_name": "calculate_floating_point_0800074c",
            "code": "\nulonglong calculateFloatingPoint_0800074c(undefined4 param1,uint param2,uint param3,uint param4)\n\n{\n  uint exponentBits;\n  uint tempVar1;\n  uint significandBits;\n  uint tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  int exponentDiff;\n  uint tempVar6;\n  uint unaff_r5;\n  uint tempVar7;\n  uint resultSignificand;\n  uint tempVar8;\n  uint tempVar9;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  undefined8 result;\n  \n  result = CONCAT44(param2,param1);\n  tempVar9 = 0x7ff;\n  tempVar5 = param2 >> 0x14 & 0x7ff;\n  condition1 = tempVar5 == 0;\n  if (!condition1) {\n    unaff_r5 = param4 >> 0x14 & 0x7ff;\n    condition1 = unaff_r5 == 0;\n  }\n  if (!condition1) {\n    condition1 = tempVar5 == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = unaff_r5 == 0x7ff;\n  }\n  if (condition1) {\n    result = calculate_double_precision_080008ba();\n  }\n  tempVar6 = (uint)((ulonglong)result >> 0x20);\n  resultSignificand = (uint)result;\n  exponentDiff = tempVar5 - unaff_r5;\n  if ((param3 | param4 << 0xc) == 0) {\n    tempVar5 = (tempVar6 ^ param4) & 0x80000000 | tempVar6 & 0xfffff;\n    condition3 = SCARRY4(exponentDiff,tempVar9 >> 1);\n    tempVar6 = exponentDiff + (tempVar9 >> 1);\n    condition1 = (int)tempVar6 < 0;\n    condition2 = tempVar6 == 0;\n    if (!condition2 && condition1 == condition3) {\n      condition3 = SBORROW4(tempVar9,tempVar6);\n      condition1 = (int)(tempVar9 - tempVar6) < 0;\n      condition2 = tempVar9 == tempVar6;\n    }\n    if (!condition2 && condition1 == condition3) {\n      tempVar5 = tempVar5 | tempVar6 * 0x100000;\n    }\n    if (!condition2 && condition1 == condition3) {\n      return CONCAT44(tempVar5,resultSignificand);\n    }\n    tempVar5 = tempVar5 | 0x100000;\n    tempVar9 = 0;\n    condition2 = SBORROW4(tempVar6,1);\n    tempVar6 = tempVar6 - 1;\n    condition1 = tempVar6 == 0;\n    significandBits = tempVar6;\n  }\n  else {\n    significandBits = (param4 << 0xc) >> 4 | 0x10000000 | param3 >> 0x18;\n    tempVar9 = param3 << 8;\n    tempVar7 = (tempVar6 << 0xc) >> 4 | 0x10000000 | resultSignificand >> 0x18;\n    resultSignificand = resultSignificand * 0x100;\n    tempVar5 = (tempVar6 ^ param4) & 0x80000000;\n    condition1 = significandBits <= tempVar7;\n    if (tempVar7 == significandBits) {\n      condition1 = tempVar9 <= resultSignificand;\n    }\n    exponentDiff = exponentDiff + (uint)condition1;\n    tempVar6 = exponentDiff + 0x3fd;\n    if (condition1 == false) {\n      significandBits = significandBits >> 1;\n      tempVar9 = (uint)((param3 >> 0x18 & 1) != 0) << 0x1f | tempVar9 >> 1;\n    }\n    tempVar8 = resultSignificand - tempVar9;\n    tempVar7 = (tempVar7 - significandBits) - (uint)(resultSignificand < tempVar9);\n    tempVar2 = significandBits >> 1;\n    exponentBits = (uint)((significandBits & 1) != 0) << 0x1f | tempVar9 >> 1;\n    resultSignificand = 0x100000;\n    significandBits = 0x80000;\n    while( true ) {\n      condition1 = exponentBits <= tempVar8;\n      if (tempVar2 < tempVar7 || tempVar7 - tempVar2 < (uint)condition1) {\n        tempVar8 = tempVar8 - exponentBits;\n        resultSignificand = resultSignificand | significandBits;\n        tempVar7 = (tempVar7 - tempVar2) - (uint)!condition1;\n      }\n      tempVar3 = tempVar2 >> 1;\n      exponentBits = (uint)((tempVar2 & 1) != 0) << 0x1f | exponentBits >> 1;\n      condition2 = exponentBits <= tempVar8;\n      condition1 = tempVar7 - tempVar3 < (uint)condition2;\n      tempVar9 = tempVar7;\n      if (tempVar3 < tempVar7 || condition1) {\n        tempVar8 = tempVar8 - exponentBits;\n        tempVar9 = (tempVar7 - tempVar3) - (uint)!condition2;\n      }\n      if (tempVar3 < tempVar7 || condition1) {\n        resultSignificand = resultSignificand | significandBits >> 1;\n      }\n      tempVar7 = tempVar2 >> 2;\n      tempVar1 = (uint)((tempVar3 & 1) != 0) << 0x1f | exponentBits >> 1;\n      condition2 = tempVar1 <= tempVar8;\n      condition1 = tempVar9 - tempVar7 < (uint)condition2;\n      tempVar3 = tempVar9;\n      if (tempVar7 < tempVar9 || condition1) {\n        tempVar8 = tempVar8 - tempVar1;\n        tempVar3 = (tempVar9 - tempVar7) - (uint)!condition2;\n      }\n      if (tempVar7 < tempVar9 || condition1) {\n        resultSignificand = resultSignificand | significandBits >> 2;\n      }\n      tempVar4 = tempVar2 >> 3;\n      exponentBits = (uint)((tempVar7 & 1) != 0) << 0x1f | tempVar1 >> 1;\n      condition2 = exponentBits <= tempVar8;\n      condition1 = tempVar3 - tempVar4 < (uint)condition2;\n      tempVar7 = tempVar3;\n      if (tempVar4 < tempVar3 || condition1) {\n        tempVar8 = tempVar8 - exponentBits;\n        tempVar7 = (tempVar3 - tempVar4) - (uint)!condition2;\n      }\n      if (tempVar4 < tempVar3 || condition1) {\n        resultSignificand = resultSignificand | significandBits >> 3;\n      }\n      tempVar9 = tempVar7 | tempVar8;\n      if (tempVar9 == 0) break;\n      tempVar7 = tempVar7 << 4 | tempVar8 >> 0x1c;\n      tempVar8 = tempVar8 << 4;\n      tempVar2 = tempVar2 & 0xfffffff8 | exponentBits >> 0x1d;\n      exponentBits = (tempVar1 >> 1) << 3;\n      significandBits = significandBits >> 4;\n      if (significandBits == 0) {\n        tempVar4 = tempVar2;\n        if ((tempVar5 & 0x100000) != 0) goto LAB_0800086a;\n        tempVar5 = tempVar5 | resultSignificand;\n        resultSignificand = 0;\n        significandBits = 0x80000000;\n      }\n    }\n    if ((tempVar5 & 0x100000) == 0) {\n      tempVar5 = tempVar5 | resultSignificand;\n      resultSignificand = 0;\n    }\nLAB_0800086a:\n    condition3 = 0xfc < tempVar6;\n    condition2 = SBORROW4(tempVar6,0xfd);\n    tempVar2 = exponentDiff + 0x300;\n    condition1 = tempVar2 == 0;\n    significandBits = tempVar2;\n    if (condition3 && !condition1) {\n      condition3 = 0x6ff < tempVar2;\n      condition2 = SBORROW4(tempVar2,0x700);\n      significandBits = exponentDiff - 0x400;\n      condition1 = tempVar2 == 0x700;\n    }\n    if (!condition3 || condition1) {\n      condition1 = tempVar4 <= tempVar7;\n      if (tempVar7 == tempVar4) {\n        condition1 = exponentBits <= tempVar8;\n      }\n      if (tempVar7 == tempVar4 && tempVar8 == exponentBits) {\n        condition1 = (resultSignificand & 1) != 0;\n      }\n      return CONCAT44(tempVar5 + tempVar6 * 0x100000 + (uint)CARRY4(resultSignificand,(uint)condition1),resultSignificand + condition1);\n    }\n  }\n  if (!condition1 && (int)significandBits < 0 == condition2) {\n    return (ulonglong)(tempVar5 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition3 = SCARRY4(tempVar6,0x36);\n  condition1 = (int)(tempVar6 + 0x36) < 0;\n  condition2 = tempVar6 == 0xffffffca;\n  if (condition2 || condition1 != condition3) {\n    resultSignificand = 0;\n  }\n  if (condition2 || condition1 != condition3) {\n    tempVar5 = tempVar5 & 0x80000000;\n  }\n  if (condition2 || condition1 != condition3) {\n    return CONCAT44(tempVar5,resultSignificand);\n  }\n  significandBits = -tempVar6;\n  tempVar7 = significandBits - 0x20;\n  if (0x1f < (int)significandBits) {\n    significandBits = resultSignificand >> (tempVar7 & 0xff) | tempVar5 << (0x20 - tempVar7 & 0xff);\n    tempVar6 = (tempVar5 >> (tempVar7 & 0xff) & ~((tempVar5 & 0x80000000) >> (tempVar7 & 0xff))) -\n            ((int)significandBits >> 0x1f);\n    if ((tempVar9 | resultSignificand << (0x20 - tempVar7 & 0xff) | significandBits << 1) == 0) {\n      tempVar6 = tempVar6 & ~(significandBits >> 0x1f);\n    }\n    return CONCAT44(tempVar5,tempVar6) & 0x80000000ffffffff;\n  }\n  exponentDiff = significandBits - 0x14;\n  if (exponentDiff != 0 && exponentDiff < 0 == SCARRY4(tempVar7,0xc)) {\n    tempVar6 = 0xc - exponentDiff;\n    significandBits = resultSignificand << (tempVar6 & 0xff);\n    resultSignificand = resultSignificand >> (0x20 - tempVar6 & 0xff) | tempVar5 << (tempVar6 & 0xff);\n    tempVar6 = resultSignificand + -((int)significandBits >> 0x1f);\n    if ((tempVar9 | significandBits << 1) == 0) {\n      tempVar6 = tempVar6 & ~(significandBits >> 0x1f);\n    }\n    return CONCAT44((tempVar5 & 0x80000000) + (uint)CARRY4(resultSignificand,-((int)significandBits >> 0x1f)),tempVar6);\n  }\n  tempVar7 = resultSignificand << (tempVar6 + 0x20 & 0xff);\n  resultSignificand = resultSignificand >> (significandBits & 0xff) | tempVar5 << (tempVar6 + 0x20 & 0xff);\n  tempVar6 = resultSignificand + -((int)tempVar7 >> 0x1f);\n  if ((tempVar9 | tempVar7 << 1) == 0) {\n    tempVar6 = tempVar6 & ~(tempVar7 >> 0x1f);\n  }\n  return CONCAT44((tempVar5 & 0x80000000) +\n                  ((tempVar5 & 0x7fffffff) >> (significandBits & 0xff)) +\n                  (uint)CARRY4(resultSignificand,-((int)tempVar7 >> 0x1f)),tempVar6);\n}\n\n",
            "renaming": {
                "FUN_0800074c": "calculate_floating_point_0800074c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "exponentBits",
                "uVar2": "tempVar1",
                "uVar3": "significandBits",
                "uVar4": "tempVar2",
                "uVar5": "tempVar3",
                "uVar6": "tempVar4",
                "uVar7": "tempVar5",
                "iVar8": "exponentDiff",
                "uVar9": "tempVar6",
                "uVar10": "tempVar7",
                "uVar11": "resultSignificand",
                "uVar12": "tempVar8",
                "uVar13": "tempVar9",
                "bVar14": "condition1",
                "bVar15": "condition2",
                "bVar16": "condition3",
                "uVar17": "result"
            },
            "calling": [
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080008ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ba": {
            "entrypoint": "0x080008ba",
            "current_name": "calculate_double_precision_080008ba",
            "code": "\nulonglong calculate_double_precision_080008ba(uint input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  uint bit_1;\n  uint temp1;\n  uint bit_2;\n  uint bit_3;\n  uint mask;\n  bool is_zero;\n  \n  bit_2 = mask & input_param_4 >> 0x14;\n  bit_3 = input_param_2;\n  if (temp1 != mask || bit_2 != mask) {\n    if (temp1 == mask) {\n      if (((input_param_1 | input_param_2 << 0xc) == 0) && (input_param_1 = input_param_3, bit_3 = input_param_4, bit_2 != mask)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((input_param_2 ^ input_param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit_2 == mask) {\n      input_param_1 = input_param_3;\n      bit_3 = input_param_4;\n      if ((input_param_3 | input_param_4 << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((input_param_2 ^ input_param_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (input_param_1 | input_param_2 << 1) == 0;\n      if (!is_zero) {\n        is_zero = (input_param_3 | input_param_4 << 1) == 0;\n      }\n      if (!is_zero) {\n        if (temp1 == 0) {\n          bit_3 = input_param_2 & 0x80000000;\n          do {\n            bit_1 = input_param_1 & 0x80000000;\n            input_param_1 = input_param_1 << 1;\n            input_param_2 = input_param_2 * 2 + (uint)(bit_1 != 0);\n          } while ((input_param_2 & 0x100000) == 0);\n          input_param_2 = input_param_2 | bit_3;\n          if (bit_2 != 0) {\n            return CONCAT44(input_param_2,input_param_1);\n          }\n        }\n        do {\n          bit_3 = input_param_3 & 0x80000000;\n          input_param_3 = input_param_3 << 1;\n          input_param_4 = input_param_4 * 2 + (uint)(bit_3 != 0);\n        } while ((input_param_4 & 0x100000) == 0);\n        return CONCAT44(input_param_2,input_param_1);\n      }\n      if ((input_param_1 | input_param_2 << 1) != 0) goto LAB_0800072c;\n      if ((input_param_3 | input_param_4 << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(bit_3,input_param_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080008ba": "calculate_double_precision_080008ba",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "bit_1",
                "unaff_r4": "temp1",
                "uVar2": "bit_2",
                "uVar3": "bit_3",
                "in_r12": "mask",
                "bVar4": "is_zero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800091c": {
            "entrypoint": "0x0800091c",
            "current_name": "compare_and_combine_0800091c",
            "code": "\nuint compare_and_combine_0800091c(uint first_param,uint second_param,uint third_param,uint fourth_param)\n\n{\n  uint result;\n  bool isZero;\n  bool isLessOrEqual;\n  \n  if (((int)(second_param << 1) >> 0x15 == -1 || (int)(fourth_param << 1) >> 0x15 == -1) &&\n     ((((int)(second_param << 1) >> 0x15 == -1 && ((first_param | second_param << 0xc) != 0)) ||\n      (((int)(fourth_param << 1) >> 0x15 == -1 && ((third_param | fourth_param << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (first_param | second_param << 1) == 0;\n  if (isZero) {\n    isZero = (third_param | fourth_param << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = second_param == fourth_param;\n  }\n  if (isZero) {\n    isZero = first_param == third_param;\n  }\n  if (!isZero) {\n    result = second_param ^ fourth_param;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = second_param == fourth_param;\n    }\n    isLessOrEqual = -1 < (int)result && fourth_param <= second_param;\n    if (isZero) {\n      isLessOrEqual = third_param <= first_param;\n    }\n    fourth_param = (int)fourth_param >> 0x1f;\n    if (!isLessOrEqual) {\n      fourth_param = ~fourth_param;\n    }\n    return fourth_param | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800091c": "compare_and_combine_0800091c",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLessOrEqual"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000924": {
            "entrypoint": "0x08000924",
            "current_name": "check_equality_08000924",
            "code": "\nuint checkEquality_08000924(uint numOne,uint numTwo,uint numThree,uint numFour)\n\n{\n  uint xorResult;\n  bool allZeros1;\n  bool allZeros2;\n  \n  if (((int)(numTwo << 1) >> 0x15 == -1 || (int)(numFour << 1) >> 0x15 == -1) &&\n     ((((int)(numTwo << 1) >> 0x15 == -1 && ((numOne | numTwo << 0xc) != 0)) ||\n      (((int)(numFour << 1) >> 0x15 == -1 && ((numThree | numFour << 0xc) != 0)))))) {\n    return 1;\n  }\n  allZeros1 = (numOne | numTwo << 1) == 0;\n  if (allZeros1) {\n    allZeros1 = (numThree | numFour << 1) == 0;\n  }\n  if (!allZeros1) {\n    allZeros1 = numTwo == numFour;\n  }\n  if (allZeros1) {\n    allZeros1 = numOne == numThree;\n  }\n  if (!allZeros1) {\n    xorResult = numTwo ^ numFour;\n    allZeros1 = xorResult == 0;\n    if (-1 < (int)xorResult) {\n      allZeros1 = numTwo == numFour;\n    }\n    allZeros2 = -1 < (int)xorResult && numFour <= numTwo;\n    if (allZeros1) {\n      allZeros2 = numThree <= numOne;\n    }\n    numFour = (int)numFour >> 0x1f;\n    if (!allZeros2) {\n      numFour = ~numFour;\n    }\n    return numFour | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000924": "check_equality_08000924",
                "param_1": "numOne",
                "param_2": "numTwo",
                "param_3": "numThree",
                "param_4": "numFour",
                "uVar1": "xorResult",
                "bVar2": "allZeros1",
                "bVar3": "allZeros2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800092c": {
            "entrypoint": "0x0800092c",
            "current_name": "check_params_and_compare_0800092c",
            "code": "\nuint check_params_and_compare_0800092c(uint input_val_1,uint input_val_2,uint input_val_3,uint input_val_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_result_zero;\n  \n  if (((int)(input_val_2 << 1) >> 0x15 == -1 || (int)(input_val_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_val_2 << 1) >> 0x15 == -1 && ((input_val_1 | input_val_2 << 0xc) != 0)) ||\n      (((int)(input_val_4 << 1) >> 0x15 == -1 && ((input_val_3 | input_val_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (input_val_1 | input_val_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (input_val_3 | input_val_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = input_val_2 == input_val_4;\n  }\n  if (is_zero) {\n    is_zero = input_val_1 == input_val_3;\n  }\n  if (!is_zero) {\n    result = input_val_2 ^ input_val_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = input_val_2 == input_val_4;\n    }\n    is_result_zero = -1 < (int)result && input_val_4 <= input_val_2;\n    if (is_zero) {\n      is_result_zero = input_val_3 <= input_val_1;\n    }\n    input_val_4 = (int)input_val_4 >> 0x1f;\n    if (!is_result_zero) {\n      input_val_4 = ~input_val_4;\n    }\n    return input_val_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800092c": "check_params_and_compare_0800092c",
                "param_1": "input_val_1",
                "param_2": "input_val_2",
                "param_3": "input_val_3",
                "param_4": "input_val_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_result_zero"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a8": {
            "entrypoint": "0x080009a8",
            "current_name": "compare_floating_point_numbers_080009a8",
            "code": "\nvoid compareFloatingPointNumbers_080009a8(undefined4 result,undefined4 status,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080009a8": "compare_floating_point_numbers_080009a8",
                "param_1": "result",
                "param_2": "status",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b8": {
            "entrypoint": "0x080009b8",
            "current_name": "calculate_080009b8",
            "code": "\nundefined4 calculate_080009b8(undefined4 input)\n\n{\n  performCalculation();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_080009b8": "calculate_080009b8",
                "param_1": "input",
                "__eqdf2": "performCalculation"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__eqdf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "is_not_zero_080009c8",
            "code": "\nbool is_not_zero_080009c8(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009c8": "is_not_zero_080009c8",
                "in_ZR": "comparison_result"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "check_if_zero_080009dc",
            "code": "\nbool check_if_zero_080009dc(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009dc": "check_if_zero_080009dc",
                "in_CY": "input_char"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "SetTunings",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_for_zero_values_080009f0",
            "code": "\nbool check_for_zero_values_080009f0(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_for_zero_values_080009f0",
                "in_CY": "carry_flag",
                "in_ZR": "zero_flag"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_less_or_equal_08000a04",
            "code": "\nbool check_less_or_equal_08000a04(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_less_or_equal_08000a04",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a18": {
            "entrypoint": "0x08000a18",
            "current_name": "is_null_character_present_08000a18",
            "code": "\nbool is_null_character_present_08000a18(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000a18": "is_null_character_present_08000a18",
                "in_CY": "input_character"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a2c": {
            "entrypoint": "0x08000a2c",
            "current_name": "check_valid_arguments_08000a2c",
            "code": "\nundefined4 check_valid_arguments_08000a2c(uint arg1,int arg2,uint arg3,int arg4)\n\n{\n  if ((((arg2 << 1) >> 0x15 != -1) || ((arg1 | arg2 << 0xc) == 0)) &&\n     (((arg4 << 1) >> 0x15 != -1 || ((arg3 | arg4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a2c": "check_valid_arguments_08000a2c",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a58": {
            "entrypoint": "0x08000a58",
            "current_name": "calculate_shift_08000a58",
            "code": "\nuint calculate_shift_08000a58(uint input_value,uint shift_amount)\n\n{\n  uint shifted_value;\n  int shifted_sum;\n  uint shifted_difference;\n  \n  shifted_sum = shift_amount * 2 + 0x200000;\n  if (shift_amount * 2 < 0xffe00000) {\n    if (-1 < shifted_sum) {\n      return 0;\n    }\n    shifted_value = shifted_sum >> 0x15;\n    shifted_difference = -shifted_value - 0x3e1;\n    if (shifted_value < 0xfffffc20 && shifted_difference != 0) {\n      shifted_value = (shift_amount << 0xb | 0x80000000 | input_value >> 0x15) >> (shifted_difference & 0xff);\n      if ((shift_amount & 0x80000000) != 0) {\n        shifted_value = -shifted_value;\n      }\n      return shifted_value;\n    }\n  }\n  else if ((input_value | shift_amount << 0xc) != 0) {\n    return 0;\n  }\n  shift_amount = shift_amount & 0x80000000;\n  if (shift_amount == 0) {\n    shift_amount = 0x7fffffff;\n  }\n  return shift_amount;\n}\n\n",
            "renaming": {
                "FUN_08000a58": "calculate_shift_08000a58",
                "param_1": "input_value",
                "param_2": "shift_amount",
                "uVar1": "shifted_value",
                "iVar2": "shifted_sum",
                "uVar3": "shifted_difference"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_shifted_value_08000aa8",
            "code": "\nuint calculateShiftedValue_08000aa8(uint inputValue,uint shiftAmount)\n\n{\n  int tempVar;\n  uint shiftCount;\n  \n  if ((shiftAmount & 0x80000000) != 0) {\n    return 0;\n  }\n  tempVar = shiftAmount * 2 + 0x200000;\n  if (shiftAmount * 2 < 0xffe00000) {\n    if (-1 < tempVar) {\n      return 0;\n    }\n    shiftCount = -(tempVar >> 0x15) - 0x3e1;\n    if (-1 < (int)shiftCount) {\n      return (shiftAmount << 0xb | 0x80000000 | inputValue >> 0x15) >> (shiftCount & 0xff);\n    }\n  }\n  else if ((inputValue | shiftAmount << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_shifted_value_08000aa8",
                "param_1": "inputValue",
                "param_2": "shiftAmount",
                "iVar1": "tempVar",
                "uVar2": "shiftCount"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ae8": {
            "entrypoint": "0x08000ae8",
            "current_name": "execute_system_interrupt_08000ae8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_interrupt_08000ae8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000ae8": "execute_system_interrupt_08000ae8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "execute_hyper_call_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeHyperCall_08000aec(int inputTicks)\n\n{\n  uint32_t result;\n  \n  if (isHyperCallDisabled != 0) {\n    return 0;\n  }\n  result = aflCall(1,inputTicks,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "execute_hyper_call_08000aec",
                "ticks": "inputTicks",
                "noHyperCall": "isHyperCallDisabled",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b08": {
            "entrypoint": "0x08000b08",
            "current_name": "initialize_pid_and_lcd_08000b08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePIDAndLCD_08000b08(int init_p,int priority)\n\n{\n  if ((init_p == 1) && (priority == 0xffff)) {\n    PID_controller::PID_controller(&oven_PID,&input,&output,&setpoint,(double)concat44(kp_4_4,kp_0_4),\n             (double)concat44(ki_4_4,ki_0_4),(double)concat44(kd_4_4,kd_0_4),0);\n    LCD::LCD\n              (&lcd,(uint8_t)lcd_RS_pin,(uint8_t)lcd_E_pin,(uint8_t)lcd_D4_pin,(uint8_t)lcd_D5_pin,\n               (uint8_t)lcd_D6_pin,(uint8_t)lcd_D7_pin);\n    thermocouple::thermocouple(&max31855,(uchar)thermocouple_SO_pin,(uchar)thermocouple_CS_pin,\n                       (uchar)thermocouple_CLK_pin);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000b08": "initialize_pid_and_lcd_08000b08",
                "__initialize_p": "init_p",
                "__priority": "priority",
                "PID": "PID_controller",
                "reflowOvenPID": "oven_PID",
                "CONCAT44": "concat44",
                "kp._4_4_": "kp_4_4",
                "kp._0_4_": "kp_0_4",
                "ki._4_4_": "ki_4_4",
                "ki._0_4_": "ki_0_4",
                "kd._4_4_": "kd_4_4",
                "kd._0_4_": "kd_0_4",
                "LiquidCrystal": "LCD",
                "lcdRsPin": "lcd_RS_pin",
                "lcdEPin": "lcd_E_pin",
                "lcdD4Pin": "lcd_D4_pin",
                "lcdD5Pin": "lcd_D5_pin",
                "lcdD6Pin": "lcd_D6_pin",
                "lcdD7Pin": "lcd_D7_pin",
                "MAX31855": "thermocouple",
                "thermocouple": "max31855",
                "thermocoupleSOPin": "thermocouple_SO_pin",
                "thermocoupleCSPin": "thermocouple_CS_pin",
                "thermocoupleCLKPin": "thermocouple_CLK_pin"
            },
            "calling": [
                "_GLOBAL__sub_I_lcdMessagesReflowStatus"
            ],
            "called": [
                "MAX31855",
                "LiquidCrystal",
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000bcc": {
            "entrypoint": "0x08000bcc",
            "current_name": "initialize_oven_08000bcc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeOven_08000bcc(void)\n\n{\n  digitalWrite(ovenControlPin,0);\n  pinMode(ovenControlPin,1);\n  digitalWrite(buzzerControlPin,0);\n  pinMode(buzzerControlPin,1);\n  digitalWrite(redLedControlPin,0);\n  pinMode(redLedControlPin,1);\n  digitalWrite(buzzerControlPin,1);\n  LiquidCrystal::begin(&display,'\\b','\\x02','\\0');\n  LiquidCrystal::createChar(&display,'\\0',degreeSymbol);\n  LiquidCrystal::clear(&display);\n  printer::print(&display.super_printer,\"Reflow\");\n  LiquidCrystal::setCursor(&display,'\\0','\\x01');\n  printer::print(&display.super_printer,\"Oven 1.2\");\n  digitalWrite(buzzerControlPin,0);\n  delay(0x9c4);\n  LiquidCrystal::clear(&display);\n  HardwareSerial::begin(&Serial2,0xe100,'\\x06');\n  digitalWrite(redLedControlPin,1);\n  windowSize = 2000;\n  nextCheckTime = millis();\n  nextReadTime = millis();\n  startForkingServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000bcc": "initialize_oven_08000bcc",
                "ssrPin": "ovenControlPin",
                "buzzerPin": "buzzerControlPin",
                "ledRedPin": "redLedControlPin",
                "lcd": "display",
                "degree": "degreeSymbol",
                "Print": "printer",
                "nextCheck": "nextCheckTime",
                "nextRead": "nextReadTime",
                "startForkserver": "startForkingServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "begin",
                "digitalWrite",
                "startForkserver",
                "delay",
                "setCursor",
                "print",
                "begin",
                "millis",
                "createChar",
                "pinMode",
                "clear"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cbc": {
            "entrypoint": "0x08000cbc",
            "current_name": "initialize_static_data_08000cbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08000cbc(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cbc": "initialize_static_data_08000cbc"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cd0": {
            "entrypoint": "0x08000cd0",
            "current_name": "reflow_oven_controller_08000cd0",
            "code": "\n/* WARNING: UnkcurrentMilliSecondsn calling convention */\n\nvoid reflowOvenController_08000cd0(void)\n\n{\n  double dVar1;\n  uint32_t uVar2;\n  MAX31855 *thermocouplePtr;\n  int redLedState;\n  ulong currentMilliSeconds;\n  int comparisonResult;\n  size_t readReturnValue;\n  int digits;\n  int digits_00;\n  int digits_01;\n  size_t printReturnValue;\n  undefined4 tempVariable1;\n  undefined4 tempVariable2;\n  undefined8 floatConversionResult;\n  undefined4 tempArg1;\n  undefined4 tempArg2;\n  undefined4 tempArg3;\n  \n  uVar2 = millis();\n  if (nextRead < uVar2) {\n    nextRead = nextRead + 1000;\n    thermocouplePtr = &thermocouple;\n    MAX31855::readThermocouple(&thermocouple,CELSIUS);\n    input._0_4_ = thermocouplePtr;\n    input._4_4_ = readReturnValue;\n    comparisonResult = __aeabi_dcmpeq();\n    if (((comparisonResult != 0) || (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,readReturnValue,0,0x40c38880), comparisonResult != 0)) ||\n       (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,readReturnValue,0,0x40c38900), comparisonResult != 0)) {\n      reflowState = REFLOW_STATE_ERROR;\n      reflowStatus = REFLOW_STATUS_OFF;\n    }\n  }\n  uVar2 = millis();\n  comparisonResult = ledRedPin;\n  if (nextCheck < uVar2) {\n    nextCheck = nextCheck + 1000;\n    if (reflowStatus == REFLOW_STATUS_ON) {\n      redLedState = digitalRead(ledRedPin);\n      digitalWrite(comparisonResult,(uint)(redLedState == 0));\n      timerSeconds = timerSeconds + 1;\n      Print::print((Print *)&Serial2,timerSeconds,10);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(tempArg1,2),digits);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(tempArg1,2),digits_00);\n      Print::print((Print *)&Serial2,\" \");\n      Print::println((Print *)&Serial2,(double)CONCAT44(tempArg1,2),digits_01);\n    }\n    else {\n      digitalWrite(ledRedPin,1);\n    }\n    LiquidCrystal::clear(&lcd);\n    Print::print(&lcd.super_Print,lcdMessagesReflowStatus[reflowState]);\n    LiquidCrystal::setCursor(&lcd,'\\0','\\x01');\n    if (reflowState == REFLOW_STATE_ERROR) {\n      Print::print(&lcd.super_Print,\"TC Error!\");\n    }\n    else {\n      thermocouplePtr = input._0_4_;\n      printReturnValue = input._4_4_;\n      Print::print(&lcd.super_Print,(double)CONCAT44(tempArg1,2),2);\n      LiquidCrystal::write(&lcd,0,thermocouplePtr,printReturnValue);\n      Print::print(&lcd.super_Print,\"C \");\n    }\n  }\n  printReturnValue = input._4_4_;\n  thermocouplePtr = input._0_4_;\n  setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  switch(reflowState) {\n  case REFLOW_STATE_IDLE:\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x40490000);\n    if (comparisonResult == 0) {\n      if (switchStatus == SWITCH_1) {\n        Print::println((Print *)&Serial2,\"Time Setpoint Input Output\");\n        timerSeconds = 0;\n        windowStartTime = millis();\n        setpoint._0_4_ = 0;\n        setpoint._4_4_ = 0x4062c000;\n        dVar1 = (double)__floatsidf(windowSize);\n        PID::SetOutputLimits\n                  (&reflowOvenPID,dVar1,(double)CONCAT44(tempArg3,tempArg2));\n        PID::SetSampleTime(&reflowOvenPID,1000);\n        PID::SetMode(&reflowOvenPID,1);\n        reflowState = REFLOW_STATE_PREHEAT;\n      }\n    }\n    else {\n      reflowState = REFLOW_STATE_TOO_HOT;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_PREHEAT:\n    reflowStatus = REFLOW_STATUS_ON;\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x4062c000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      uVar2 = millis();\n      timerSoak = uVar2 + 9000;\n      PID::SetTunings(&reflowOvenPID,0.05,250.0,(double)CONCAT44(tempVariable2,tempVariable1));\n      reflowState = REFLOW_STATE_SOAK;\n      setpoint = 155.0;\n    }\n    break;\n  case REFLOW_STATE_SOAK:\n    uVar2 = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (timerSoak < uVar2) {\n      uVar2 = millis();\n      timerSoak = uVar2 + 9000;\n      setpoint = (double)__aeabi_dadd(setpoint._0_4_,setpoint._4_4_,0,0x40140000);\n      comparisonResult = __aeabi_dcmpgt(SUB84(setpoint,0),(int)((ulonglong)setpoint >> 0x20),0,0x40690000);\n      if (comparisonResult != 0) {\n        PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(tempVariable2,tempVariable1));\n        reflowState = REFLOW_STATE_REFLOW;\n        setpoint = 250.0;\n      }\n    }\n    break;\n  case REFLOW_STATE_REFLOW:\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x406ea000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(tempVariable2,tempVariable1));\n      reflowState = REFLOW_STATE_COOL;\n      setpoint = 100.0;\n    }\n    break;\n  case REFLOW_STATE_COOL:\n    comparisonResult = __aeabi_dcmple(input._0_4_,input._4_4_,0,0x40590000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      uVar2 = millis();\n      buzzerPeriod = uVar2 + 1000;\n      digitalWrite(buzzerPin,1);\n      reflowStatus = REFLOW_STATUS_OFF;\n      reflowState = REFLOW_STATE_COMPLETE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_COMPLETE:\n    uVar2 = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (buzzerPeriod < uVar2) {\n      digitalWrite(buzzerPin,0);\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_TOO_HOT:\n    comparisonResult = __aeabi_dcmplt(input._0_4_,input._4_4_,0,0x40490000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_ERROR:\n    comparisonResult = __aeabi_dcmpeq(input._0_4_,input._4_4_,0,0x40c38800);\n    if ((comparisonResult == 0) && (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,printReturnValue,0,0x40c38880), comparisonResult == 0)) {\n      comparisonResult = __aeabi_dcmpeq(thermocouplePtr,printReturnValue,0,0x40c38900);\n      if (comparisonResult == 0) {\n        reflowState = REFLOW_STATE_IDLE;\n        setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n        break;\n      }\n    }\n    reflowState = REFLOW_STATE_ERROR;\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  }\n  if ((switchStatus == SWITCH_1) && (reflowStatus == REFLOW_STATUS_ON)) {\n    reflowStatus = REFLOW_STATUS_OFF;\n    reflowState = REFLOW_STATE_IDLE;\n  }\n  if (debounceState == DEBOUNCE_STATE_CHECK) {\n    uVar2 = analogRead(switchPin);\n    if (uVar2 == 0) {\n      uVar2 = millis();\n      if (0x32 < uVar2 - lastDebounceTime) {\n        debounceState = DEBOUNCE_STATE_RELEASE;\n      }\n    }\n    else {\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_IDLE) {\n    switchStatus = SWITCH_NONE;\n    uVar2 = analogRead(switchPin);\n    if (uVar2 == 0) {\n      lastDebounceTime = millis();\n      debounceState = DEBOUNCE_STATE_CHECK;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_RELEASE) {\n    uVar2 = analogRead(switchPin);\n    if (uVar2 != 0) {\n      switchStatus = SWITCH_1;\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  if (reflowStatus == REFLOW_STATUS_ON) {\n    uVar2 = millis();\n    PID::Compute(&reflowOvenPID);\n    if ((uint)windowSize < uVar2 - windowStartTime) {\n      windowStartTime = windowStartTime + windowSize;\n    }\n    floatConversionResult = __floatunsidf(uVar2 - windowStartTime);\n    comparisonResult = __aeabi_dcmplt((int)floatConversionResult,(int)((ulonglong)floatConversionResult >> 0x20),output._0_4_,output._4_4_);\n    if (comparisonResult == 0) {\n      digitalWrite(ssrPin,0);\n      dVar1 = setpoint;\n    }\n    else {\n      digitalWrite(ssrPin,1);\n      dVar1 = setpoint;\n    }\n  }\n  else {\n    digitalWrite(ssrPin,0);\n    dVar1 = setpoint;\n  }\n  setpoint._4_4_ = (undefined4)((ulonglong)dVar1 >> 0x20);\n  setpoint._0_4_ = SUB84(dVar1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cd0": "reflow_oven_controller_08000cd0",
                "pMVar3": "thermocouplePtr",
                "iVar4": "redLedState",
                "now": "currentMilliSeconds",
                "iVar5": "comparisonResult",
                "extraout_r1": "readReturnValue",
                "sVar6": "printReturnValue",
                "unaff_r4": "tempVariable1",
                "unaff_r5": "tempVariable2",
                "uVar7": "floatConversionResult",
                "in_stack_ffffffe4": "tempArg1",
                "in_stack_ffffffe8": "tempArg2",
                "in_stack_ffffffec": "tempArg3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "SetOutputLimits",
                "write",
                "print",
                "setCursor",
                "analogRead",
                "millis",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "print",
                "__aeabi_dcmpeq",
                "println",
                "digitalRead",
                "__aeabi_dcmpge",
                "clear",
                "__aeabi_dcmple",
                "readThermocouple",
                "digitalWrite",
                "__floatsidf",
                "print",
                "Compute",
                "SetTunings",
                "SetSampleTime",
                "SetMode",
                "__floatunsidf",
                "__aeabi_dcmplt",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001294": {
            "entrypoint": "0x08001294",
            "current_name": "set_row_offsets_08001294",
            "code": "\n/* DWARF original prototype: void  setRowOffsets_08001294(LiquidCrystal * lcd, int offset0, int offset1, int offset2,\n   int offset3) */\n\nvoid __lcdcall LiquidCrystal::setRowOffsets_08001294(LiquidCrystal *lcd,int offset0,int offset1,int offset2,int offset3)\n\n{\n  lcd->_row_offsets[0] = (uint8_t)offset0;\n  lcd->_row_offsets[1] = (uint8_t)offset1;\n  lcd->_row_offsets[2] = (uint8_t)offset2;\n  lcd->_row_offsets[3] = (uint8_t)offset3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001294": "set_row_offsets_08001294",
                "this": "lcd",
                "row0": "offset0",
                "row1": "offset1",
                "row2": "offset2",
                "row3": "offset3"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012a2": {
            "entrypoint": "0x080012a2",
            "current_name": "pulse_enable_080012a2",
            "code": "\n/* DWARF original prototype: void  pulseEnable_080012a2(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::pulseEnable_080012a2(LiquidCrystal *lcd)\n\n{\n  digitalWrite((uint)lcd->enablePin,0);\n  digitalWrite((uint)lcd->enablePin,1);\n  digitalWrite((uint)lcd->enablePin,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012a2": "pulse_enable_080012a2",
                "this": "lcd",
                "_enable_pin": "enablePin"
            },
            "calling": [
                "write4bits",
                "write8bits"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012c0": {
            "entrypoint": "0x080012c0",
            "current_name": "write_four_bits_080012c0",
            "code": "\n/* DWARF original prototype: void  write4bits(LiquidCrystal * lcdInstance, uint8_t dataValue) */\n\nvoid __lcdInstancecall LiquidCrystal::writeFourBits_080012c0(LiquidCrystal *lcdInstance,uint8_t dataValue)\n\n{\n  uint counter;\n  \n  for (counter = 0; (int)counter < 4; counter = counter + 1) {\n    digitalWrite((uint)lcdInstance->_data_pins[counter],(int)(uint)dataValue >> (counter & 0xff) & 1);\n  }\n  pulseEnable(lcdInstance);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcdInstance",
                "value": "dataValue",
                "uVar1": "counter",
                "FUN_080012c0": "write_four_bits_080012c0"
            },
            "calling": [
                "send",
                "begin"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012e8": {
            "entrypoint": "0x080012e8",
            "current_name": "write8bits_080012e8",
            "code": "\n/* DWARF original prototype: void  write8bits_080012e8(LiquidCrystal * lcd, uint8_t data) */\n\nvoid __lcdcall LiquidCrystal::write8bits_080012e8(LiquidCrystal *lcd,uint8_t data)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 8; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)data >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012e8": "write8bits_080012e8",
                "this": "lcd",
                "value": "data",
                "uVar1": "bitIndex"
            },
            "calling": [
                "send"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001310": {
            "entrypoint": "0x08001310",
            "current_name": "send_08001310",
            "code": "\n/* DWARF original prototype: void  send_08001310(LiquidCrystal * this, uint8_t value, uint8_t mode) */\n\nssize_t __thiscall\nLiquidCrystal::send_08001310(LiquidCrystal *this,int value,void *data,size_t size,int flags)\n\n{\n  digitalWrite((uint)this->rs_pin,(uint32_t)data);\n  if (this->rw_pin != 0xff) {\n    digitalWrite((uint)this->rw_pin,0);\n  }\n  if ((this->displayfunction & 0x10) == 0) {\n    write4bits(this,(uint8_t)((uint)value >> 4));\n    write4bits(this,(uint8_t)value);\n    return (ssize_t)this;\n  }\n  write8bits(this,(uint8_t)value);\n  return (ssize_t)this;\n}\n\n",
            "renaming": {
                "FUN_08001310": "send_08001310",
                "__fd": "value",
                "__buf": "data",
                "__n": "size",
                "__flags": "flags",
                "_rs_pin": "rs_pin",
                "_rw_pin": "rw_pin",
                "_displayfunction": "displayfunction"
            },
            "calling": [
                "write",
                "setCursor",
                "begin",
                "display",
                "createChar",
                "clear"
            ],
            "called": [
                "digitalWrite",
                "write4bits",
                "write8bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800134e": {
            "entrypoint": "0x0800134e",
            "current_name": "send_value_0800134e",
            "code": "\n/* DWARF original prototype: size_t  write(LiquidCrystal * lcd, uint8_t value) */\n\nssize_t LiquidCrystal LiquidCrystal::send_value_0800134e(LiquidCrystal *lcd,int file_descriptor,void *buffer,size_t size)\n\n{\n  send(lcd,file_descriptor,(void *)0x1,size,size);\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800134e": "send_value_0800134e",
                "__thiscall": "LiquidCrystal",
                "this": "lcd",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800135a": {
            "entrypoint": "0x0800135a",
            "current_name": "clear_display_0800135a",
            "code": "\n/* DWARF original prototype: void  clear(LiquidCrystal * this) */\n\nvoid __thiscall LiquidCrystal::clear_display_0800135a(LiquidCrystal *this)\n\n{\n  size_t in_r3;\n  \n  send(this,1,(void *)0x0,in_r3,in_r3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800135a": "clear_display_0800135a"
            },
            "calling": [
                "setup",
                "begin",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001366": {
            "entrypoint": "0x08001366",
            "current_name": "set_cursor_08001366",
            "code": "\n/* DWARF original prototype: void  setCursor_08001366(LiquidCrystal * lcd, uint8_t column, uint8_t row) */\n\nvoid __lcdcall LiquidCrystal::setCursor_08001366(LiquidCrystal *lcd,uint8_t column,uint8_t row)\n\n{\n  uint limitedRow;\n  int unused;\n  \n  limitedRow = (uint)row;\n  if (3 < limitedRow) {\n    limitedRow = 3;\n  }\n  if (lcd->numLines <= limitedRow) {\n    limitedRow = lcd->numLines - 1 & 0xff;\n  }\n  transmitData(lcd,(uint)(byte)(column + lcd->rowOffsets[limitedRow] | 0x80),(void *)0x0,\n       (uint)lcd->rowOffsets[limitedRow],unused);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001366": "set_cursor_08001366",
                "this": "lcd",
                "col": "column",
                "uVar1": "limitedRow",
                "in_r3": "unused",
                "_numlines": "numLines",
                "_row_offsets": "rowOffsets",
                "send": "transmitData"
            },
            "calling": [
                "setup",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800138e": {
            "entrypoint": "0x0800138e",
            "current_name": "display_with_control_0800138e",
            "code": "\n/* DWARF original prototype: void  display(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::displayWithControl_0800138e(LiquidCrystal *lcd)\n\n{\n  byte previousControl;\n  size_t size;\n  \n  previousControl = lcd->displayControl;\n  lcd->displayControl = previousControl | 4;\n  send(lcd,previousControl | 0xc,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800138e": "display_with_control_0800138e",
                "this": "lcd",
                "bVar1": "previousControl",
                "in_r3": "size",
                "_displaycontrol": "displayControl"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080013a4": {
            "entrypoint": "0x080013a4",
            "current_name": "initialize_lcd_080013a4",
            "code": "\n/* DWARF original prototype: void  begin(LiquidCrystal * lcd, uint8_t numCols, uint8_t numRows, uint8_t\n   dotSize) */\n\nvoid __lcdcall\nLiquidCrystal::initializeLCD_080013a4(LiquidCrystal *lcd,uint8_t numCols,uint8_t numRows,uint8_t dotSize)\n\n{\n  int rowOffset;\n  size_t numBits;\n  int counter;\n  \n  if (1 < numRows) {\n    lcd->_displayfunction = lcd->_displayfunction | 8;\n  }\n  lcd->_numnumRows = numRows;\n  rowOffset = numCols + 0x40;\n  setRowOffsets(lcd,0,0x40,(uint)numCols,rowOffset);\n  if ((dotSize != '\\0') && (numRows == '\\x01')) {\n    lcd->_displayfunction = lcd->_displayfunction | 4;\n  }\n  pinMode((uint)lcd->_rs_pin,1);\n  if (lcd->_rw_pin != 0xff) {\n    pinMode((uint)lcd->_rw_pin,1);\n  }\n  pinMode((uint)lcd->_enable_pin,1);\n  counter = 0;\n  while( true ) {\n    if ((lcd->_displayfunction & 0x10) == 0) {\n      numBits = 4;\n    }\n    else {\n      numBits = 8;\n    }\n    if ((int)numBits <= counter) break;\n    pinMode((uint)lcd->_data_pins[counter],1);\n    counter = counter + 1;\n  }\n  digitalWrite((uint)lcd->_rs_pin,0);\n  digitalWrite((uint)lcd->_enable_pin,0);\n  if (lcd->_rw_pin != 0xff) {\n    digitalWrite((uint)lcd->_rw_pin,0);\n  }\n  if ((lcd->_displayfunction & 0x10) == 0) {\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x02');\n  }\n  else {\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n  }\n  send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n  lcd->_displaycontrol = '\\x04';\n  display(lcd);\n  clear(lcd);\n  lcd->_displaymode = '\\x02';\n  send(lcd,6,(void *)0x0,2,rowOffset);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080013a4": "initialize_lcd_080013a4",
                "this": "lcd",
                "cols": "numCols",
                "lines": "numRows",
                "dotsize": "dotSize",
                "row3": "rowOffset",
                "__n": "numBits",
                "iVar1": "counter"
            },
            "calling": [
                "setup",
                "init"
            ],
            "called": [
                "digitalWrite",
                "send",
                "display",
                "pinMode",
                "clear",
                "setRowOffsets",
                "write4bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ba": {
            "entrypoint": "0x080014ba",
            "current_name": "initialize_lcd_080014ba",
            "code": "\n/* DWARF original prototype: void  init(LiquidCrystal * lcd, uint8_t fourbitmode, uint8_t rs,\n   uint8_t rw, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t\n   d5, uint8_t d6, uint8_t d7) */\n\nint __lcdcall LiquidCrystal::initializeLCD_080014ba(LiquidCrystal *lcd,EVP_PKEY_CTX *pkeyCtx)\n\n{\n  uint8_t rsPin;\n  uint8_t rwPin;\n  uint8_t enablePin;\n  uint8_t dataPin0;\n  uint8_t dataPin1;\n  uint8_t dataPin2;\n  uint8_t dataPin3;\n  uint8_t dataPin4;\n  uint8_t dataPin5;\n  uint8_t dataPin6;\n  uint8_t dataPin7;\n  \n  lcd->_rs_pin = rsPin;\n  lcd->_rw_pin = rwPin;\n  lcd->_enable_pin = enablePin;\n  lcd->_data_pins[0] = dataPin0;\n  lcd->_data_pins[1] = dataPin1;\n  lcd->_data_pins[2] = dataPin2;\n  lcd->_data_pins[3] = dataPin3;\n  lcd->_data_pins[4] = dataPin4;\n  lcd->_data_pins[5] = dataPin5;\n  lcd->_data_pins[6] = dataPin6;\n  lcd->_data_pins[7] = dataPin7;\n  if (pkeyCtx == (EVP_PKEY_CTX *)0x0) {\n    lcd->_displayfunction = '\\x10';\n  }\n  else {\n    lcd->_displayfunction = '\\0';\n  }\n  begin(lcd,'\\x10','\\x01','\\0');\n  return (int)lcd;\n}\n\n",
            "renaming": {
                "FUN_080014ba": "initialize_lcd_080014ba",
                "this": "lcd",
                "ctx": "pkeyCtx",
                "in_r2": "rsPin",
                "in_r3": "rwPin",
                "in_stack_00000000": "enablePin",
                "in_stack_00000004": "dataPin0",
                "in_stack_00000008": "dataPin1",
                "in_stack_0000000c": "dataPin2",
                "in_stack_00000010": "dataPin3",
                "in_stack_00000014": "dataPin4",
                "in_stack_00000018": "dataPin5",
                "in_stack_0000001c": "dataPin6",
                "in_stack_00000020": "dataPin7"
            },
            "calling": [
                "LiquidCrystal"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001510": {
            "entrypoint": "0x08001510",
            "current_name": "initialize_lcd_08001510",
            "code": "\n/* DWARF original prototype: LiquidCrystal *  LiquidCrystal(LiquidCrystal * lcd, uint8_t registerSelectPin,\n   uint8_t enablePin, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) */\n\nLiquidCrystal * __lcdcall\nLiquidCrystal::initializeLCD_08001510(LiquidCrystal *lcd,uint8_t registerSelectPin,uint8_t enablePin,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (lcd->super_Print).write_error = 0;\n  (lcd->super_Print)._vptr_Print = (_func_int_varargs **)&PTR_write_1_080073f8;\n  init(lcd,(EVP_PKEY_CTX *)0x1);\n  return lcd;\n}\n\n",
            "renaming": {
                "FUN_08001510": "initialize_lcd_08001510",
                "this": "lcd",
                "rs": "registerSelectPin",
                "enable": "enablePin"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001550": {
            "entrypoint": "0x08001550",
            "current_name": "create_char_08001550",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example charLocation: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  createChar_08001550(LiquidCrystal * lcd, uint8_t charLocation, uint8_t *\n   charMap) */\n\nvoid __lcdcall LiquidCrystal::createChar_08001550(LiquidCrystal *lcd,uint8_t charLocation,uint8_t *charMap)\n\n{\n  size_t size;\n  int unused;\n  int index;\n  \n  send(lcd,(charLocation & 7) << 3 | 0x40,(void *)0x0,size,unused);\n  for (index = 0; index < 8; index = index + 1) {\n    (**(lcd->super_Print)._vptr_Print)(lcd,(uint)charMap[index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001550": "create_char_08001550",
                "this": "lcd",
                "location": "charLocation",
                "charmap": "charMap",
                "in_r3": "size",
                "unaff_r4": "unused",
                "iVar1": "index"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "initialize_max31855_0800157c",
            "code": "\n/* DWARF original prototype: MAX31855 *  MAX31855(MAX31855 * self, uchar dataOutPin, uchar chipSelectPin, uchar clockPin) */\n\nMAX31855 * __selfcall MAX31855::initializeMAX31855_0800157c(MAX31855 *self,uchar dataOutPin,uchar chipSelectPin,uchar clockPin)\n\n{\n  self->so = dataOutPin;\n  self->cs = chipSelectPin;\n  self->sck = clockPin;\n  pinMode((uint)dataOutPin,0);\n  pinMode((uint)self->cs,1);\n  pinMode((uint)self->sck,1);\n  digitalWrite((uint)self->cs,1);\n  digitalWrite((uint)self->sck,0);\n  return self;\n}\n\n",
            "renaming": {
                "this": "self",
                "SO": "dataOutPin",
                "CS": "chipSelectPin",
                "SCK": "clockPin",
                "FUN_0800157c": "initialize_max31855_0800157c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b2": {
            "entrypoint": "0x080015b2",
            "current_name": "read_data_080015b2",
            "code": "\n/* DWARF original prototype: ulong  readData_080015b2(MAX31855 * sensor) */\n\nulong __sensorcall MAX31855::readData_080015b2(MAX31855 *sensor)\n\n{\n  int bitValue;\n  uint bitIndex;\n  uint data;\n  \n  digitalWrite((uint)sensor->chipSelect,0);\n  data = 0;\n  for (bitIndex = 0x1f; -1 < (int)bitIndex; bitIndex = bitIndex - 1) {\n    digitalWrite((uint)sensor->clock,1);\n    bitValue = digitalRead((uint)sensor->dataOutput);\n    if (bitValue != 0) {\n      data = data | 1 << (bitIndex & 0xff);\n    }\n    digitalWrite((uint)sensor->clock,0);\n  }\n  digitalWrite((uint)sensor->chipSelect,1);\n  return data;\n}\n\n",
            "renaming": {
                "FUN_080015b2": "read_data_080015b2",
                "this": "sensor",
                "cs": "chipSelect",
                "sck": "clock",
                "so": "dataOutput",
                "iVar1": "bitValue",
                "uVar2": "bitIndex",
                "uVar3": "data"
            },
            "calling": [
                "readThermocouple"
            ],
            "called": [
                "digitalWrite",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015f8": {
            "entrypoint": "0x080015f8",
            "current_name": "read_thermocouple_voltage_080015f8",
            "code": "\n/* DWARF original prototype: double  readThermocouple(MAX31855 * thermocouple, temperatureUnit_t temperatureUnit) */\n\ndouble __thermocouplecall MAX31855::readThermocoupleVoltage_080015f8(MAX31855 *thermocouple,temperatureUnit_t temperatureUnit)\n\n{\n  ulong data;\n  ulong data;\n  uint tempValue;\n  double defaultTemperature;\n  double defaultTemperature;\n  double temperature;\n  undefined8 convertedValue;\n  \n  data = readData(thermocouple);\n  if ((data & 0x10000) == 0) {\n    tempValue = data >> 0x12;\n    convertedValue = __floatunsidf(tempValue & 0x1fff);\n    if ((tempValue & 0x2000) != 0) {\n      convertedValue = __floatunsidf(~tempValue & 0x1fff);\n      convertedValue = __aeabi_dadd((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x3ff00000);\n      convertedValue = CONCAT44((int)((ulonglong)convertedValue >> 0x20) + -0x80000000,(int)convertedValue);\n    }\n    convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x3fd00000);\n    temperature = defaultTemperature;\n    if (temperatureUnit == FAHRENHEIT) {\n      convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40220000);\n      convertedValue = __divdf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40140000);\n      temperature = (double)__aeabi_dadd((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40400000);\n      return temperature;\n    }\n  }\n  else {\n    tempValue = data & 7;\n    if (tempValue == 2) {\n      return defaultTemperature;\n    }\n    if (tempValue == 4) {\n      return defaultTemperature;\n    }\n    temperature = defaultTemperature;\n    if (tempValue != 1) {\n      return defaultTemperature;\n    }\n  }\n  return temperature;\n}\n\n",
            "renaming": {
                "this": "thermocouple",
                "unit": "temperatureUnit",
                "uVar1": "data",
                "uVar2": "tempValue",
                "uVar4": "convertedValue",
                "dVar3": "temperature",
                "extraout_d0": "defaultTemperature",
                "extraout_d0_00": "defaultTemperature",
                "FUN_080015f8": "read_thermocouple_voltage_080015f8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__floatunsidf",
                "__divdf3",
                "readData"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016b4": {
            "entrypoint": "0x080016b4",
            "current_name": "compute_pid_controller_080016b4",
            "code": "\n/* DWARF original prototype: bool  Compute(PID * pidController) */\n\nbool __pidControllercall PID::computePIDController_080016b4(PID *pidController)\n\n{\n  bool isInAuto;\n  uint32_t currentTime;\n  ulong currentTimestamp;\n  int comparisonResult;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  ulong timeElapsed;\n  undefined4 temp5;\n  undefined4 temp6;\n  undefined4 temp7;\n  char isAutoMode;\n  undefined4 outputMax;\n  undefined4 outputMax;\n  undefined4 outputSumHigh;\n  undefined8 temp8;\n  undefined8 lastInputLow;\n  undefined8 outputSum;\n  double temp9;\n  double temp10;\n  double pidOutput;\n  \n  isAutoMode = pidController->inAuto;\n  if ((bool)isAutoMode != false) {\n    currentTime = millis();\n    if (currentTime - pidController->lastTime < pidController->SampleTime) {\n      isAutoMode = '\\0';\n    }\n    else {\n      temp2 = *(undefined4 *)pidController->myInput;\n      temp5 = *(undefined4 *)((int)pidController->myInput + 4);\n      temp8 = __subdf3(*(undefined4 *)pidController->mySetpoint,*(undefined4 *)((int)pidController->mySetpoint + 4));\n      outputSumHigh = (undefined4)((ulonglong)temp8 >> 0x20);\n      lastInputLow = __subdf3(temp2,temp5,*(undefined4 *)&pidController->lastInput,\n                        *(undefined4 *)((int)&pidController->lastInput + 4));\n      temp1 = (undefined4)((ulonglong)lastInputLow >> 0x20);\n      outputSum = __muldf3((int)temp8,outputSumHigh,*(undefined4 *)&pidController->ki,\n                        *(undefined4 *)((int)&pidController->ki + 4));\n      temp9 = (double)__aeabi_dadd((int)outputSum,(int)((ulonglong)outputSum >> 0x20),\n                                    *(undefined4 *)&pidController->pidOutputSum,\n                                    *(undefined4 *)((int)&pidController->pidOutputSum + 4));\n      pidController->pidOutputSum = temp9;\n      isInAuto = pidController->pOnE;\n      if (isInAuto == false) {\n        outputSum = __muldf3((int)lastInputLow,temp1,*(undefined4 *)&pidController->kp,\n                          *(undefined4 *)((int)&pidController->kp + 4));\n        temp9 = (double)__subdf3(SUB84(temp9,0),(int)((ulonglong)temp9 >> 0x20),(int)outputSum,\n                                  (int)((ulonglong)outputSum >> 0x20));\n        pidController->pidOutputSum = temp9;\n      }\n      temp3 = *(undefined4 *)&pidController->pidOutputSum;\n      temp6 = *(undefined4 *)((int)&pidController->pidOutputSum + 4);\n      outputMax = *(undefined4 *)&pidController->outMax;\n      outputMax = *(undefined4 *)((int)&pidController->outMax + 4);\n      temp9 = pidController->outMax;\n      comparisonResult = __aeabi_dcmpgt(temp3,temp6,outputMax,outputMax);\n      if (comparisonResult == 0) {\n        temp4 = *(undefined4 *)&pidController->outMin;\n        temp7 = *(undefined4 *)((int)&pidController->outMin + 4);\n        comparisonResult = __aeabi_dcmplt(temp3,temp6);\n        if (comparisonResult != 0) {\n          *(undefined4 *)&pidController->pidOutputSum = temp4;\n          *(undefined4 *)((int)&pidController->pidOutputSum + 4) = temp7;\n        }\n      }\n      else {\n        *(undefined4 *)&pidController->pidOutputSum = outputMax;\n        *(undefined4 *)((int)&pidController->pidOutputSum + 4) = outputMax;\n      }\n      if (isInAuto == false) {\n        temp8 = 0;\n      }\n      else {\n        temp8 = __muldf3((int)temp8,outputSumHigh,*(undefined4 *)&pidController->kp,\n                          *(undefined4 *)((int)&pidController->kp + 4));\n      }\n      pidOutput._4_4_ = (undefined4)((ulonglong)temp8 >> 0x20);\n      pidOutput._0_4_ = (undefined4)temp8;\n      outputSumHigh = *(undefined4 *)&pidController->pidOutputSum;\n      temp3 = *(undefined4 *)((int)&pidController->pidOutputSum + 4);\n      temp8 = __muldf3((int)lastInputLow,temp1,*(undefined4 *)&pidController->kd,\n                        *(undefined4 *)((int)&pidController->kd + 4));\n      temp8 = __subdf3(outputSumHigh,temp3,(int)temp8,(int)((ulonglong)temp8 >> 0x20));\n      temp10 = (double)__aeabi_dadd(pidOutput._0_4_,pidOutput._4_4_,(int)temp8,\n                                    (int)((ulonglong)temp8 >> 0x20));\n      outputSumHigh = (undefined4)((ulonglong)temp10 >> 0x20);\n      comparisonResult = __aeabi_dcmplt(outputMax,outputMax,SUB84(temp10,0),outputSumHigh);\n      if (comparisonResult == 0) {\n        temp9 = pidController->outMin;\n        comparisonResult = __aeabi_dcmplt(SUB84(temp10,0),outputSumHigh,*(undefined4 *)&pidController->outMin,\n                               *(undefined4 *)((int)&pidController->outMin + 4));\n        if (comparisonResult == 0) {\n          temp9 = temp10;\n        }\n      }\n      *pidController->myOutput = temp9;\n      *(undefined4 *)&pidController->lastInput = temp2;\n      *(undefined4 *)((int)&pidController->lastInput + 4) = temp5;\n      pidController->lastTime = currentTime;\n    }\n  }\n  return (bool)isAutoMode;\n}\n\n",
            "renaming": {
                "this": "pidController",
                "bVar1": "isInAuto",
                "uVar2": "currentTime",
                "now": "currentTimestamp",
                "iVar3": "comparisonResult",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "uVar6": "temp3",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "uVar9": "temp6",
                "uVar10": "temp7",
                "cVar11": "isAutoMode",
                "uVar12": "outputMax",
                "uVar13": "outputMax",
                "uVar14": "outputSumHigh",
                "uVar15": "temp8",
                "uVar16": "lastInputLow",
                "uVar17": "outputSum",
                "dVar18": "temp9",
                "dVar19": "temp10",
                "output": "pidOutput",
                "timeChange": "timeElapsed",
                "FUN_080016b4": "compute_pid_controller_080016b4"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__aeabi_dadd",
                "millis",
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001814": {
            "entrypoint": "0x08001814",
            "current_name": "configure_pid_controller_08001814",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * this, double proportionalGain, double integralGain, double derivativeGain, int powerOnState)\n    */\n\nvoid __thiscall PID::configurePIDController_08001814(PID *this,double proportionalGain,double integralGain,double derivativeGain,int powerOnState)\n\n{\n  int isLessThanZero;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined temp4;\n  bool isKdNotEqualToOne;\n  undefined8 sampleTime;\n  double kpTimesSampleTime;\n  double kdDividedBySampleTime;\n  double negativeOne;\n  \n  isLessThanZero = __aeabi_dcmplt();\n  if (((isLessThanZero == 0) && (isLessThanZero = __aeabi_dcmplt(proportionalGain._0_4_,proportionalGain._4_4_,0,0), isLessThanZero == 0)) &&\n     (isLessThanZero = __aeabi_dcmplt(integralGain._0_4_,integralGain._4_4_,0,0), isLessThanZero == 0)) {\n    this->pOn = derivativeGain._0_4_;\n    isKdNotEqualToOne = derivativeGain._0_4_ != 1;\n    if (isKdNotEqualToOne) {\n      derivativeGain._0_4_ = 0;\n    }\n    temp4 = (undefined)derivativeGain._0_4_;\n    if (!isKdNotEqualToOne) {\n      temp4 = true;\n    }\n    this->pOnE = (bool)temp4;\n    *(undefined4 *)&this->dispproportionalGain = temp2;\n    *(undefined4 *)((int)&this->dispproportionalGain + 4) = temp3;\n    this->dispintegralGain = proportionalGain;\n    this->dispderivativeGain = integralGain;\n    sampleTime = __floatunsidf(this->SampleTime);\n    sampleTime = __divdf3((int)sampleTime,(int)((ulonglong)sampleTime >> 0x20),0,0x408f4000);\n    temp1 = (undefined4)((ulonglong)sampleTime >> 0x20);\n    *(undefined4 *)&this->kp = temp2;\n    *(undefined4 *)((int)&this->kp + 4) = temp3;\n    kpTimesSampleTime = (double)__muldf3(proportionalGain._0_4_,proportionalGain._4_4_,(int)sampleTime,temp1);\n    this->ki = kpTimesSampleTime;\n    kdDividedBySampleTime = (double)__divdf3(integralGain._0_4_,integralGain._4_4_,(int)sampleTime,temp1);\n    this->kd = kdDividedBySampleTime;\n    if (this->controllerDirection == 1) {\n      negativeOne = (double)__subdf3(0,0);\n      this->kp = negativeOne;\n      kpTimesSampleTime = (double)__subdf3(0,0,SUB84(kpTimesSampleTime,0),(int)((ulonglong)kpTimesSampleTime >> 0x20));\n      this->ki = kpTimesSampleTime;\n      kpTimesSampleTime = (double)__subdf3(0,0,SUB84(kdDividedBySampleTime,0),(int)((ulonglong)kdDividedBySampleTime >> 0x20));\n      this->kd = kpTimesSampleTime;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001814": "configure_pid_controller_08001814",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "powerOnState",
                "iVar1": "isLessThanZero",
                "uVar2": "temp1",
                "in_r2": "temp2",
                "in_r3": "temp3",
                "uVar3": "temp4",
                "bVar4": "isKdNotEqualToOne",
                "uVar5": "sampleTime",
                "dVar6": "kpTimesSampleTime",
                "dVar7": "kdDividedBySampleTime",
                "dVar8": "negativeOne"
            },
            "calling": [
                "PID",
                "SetTunings"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018f8": {
            "entrypoint": "0x080018f8",
            "current_name": "set_pid_tunings_080018f8",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * pidInstance, double proportionalGain, double integralGain, double derivativeGain) */\n\nvoid __pidInstancecall PID::setPIDTunings_080018f8(PID *pidInstance,double proportionalGain,double integralGain,double derivativeGain)\n\n{\n  undefined4 tempValue;\n  \n  SetTunings(pidInstance,proportionalGain,integralGain,(double)CONCAT44(tempValue,pidInstance->pOn),pidInstance->pOn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018f8": "set_pid_tunings_080018f8",
                "this": "pidInstance",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "in_stack_ffffffec": "tempValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "SetTunings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001918": {
            "entrypoint": "0x08001918",
            "current_name": "set_sample_time_08001918",
            "code": "\n/* DWARF original prototype: void  SetSampleTime(PID * pid, int new_sample_time) */\n\nvoid __pidcall PID::set_sample_time_08001918(PID *pid,int new_sample_time)\n\n{\n  undefined4 result_division;\n  undefined8 converted_sample_time;\n  undefined8 converted_sample_time_2;\n  double computed_value;\n  \n  if (0 < new_sample_time) {\n    converted_sample_time = __floatsidf(new_sample_time);\n    converted_sample_time_2 = __floatunsidf(pid->SampleTime);\n    converted_sample_time = __divdf3((int)converted_sample_time,(int)((ulonglong)converted_sample_time >> 0x20),(int)converted_sample_time_2,\n                     (int)((ulonglong)converted_sample_time_2 >> 0x20));\n    result_division = (undefined4)((ulonglong)converted_sample_time >> 0x20);\n    computed_value = (double)__muldf3((int)converted_sample_time,result_division,*(undefined4 *)&pid->ki,\n                             *(undefined4 *)((int)&pid->ki + 4));\n    pid->ki = computed_value;\n    computed_value = (double)__divdf3(*(undefined4 *)&pid->kd,*(undefined4 *)((int)&pid->kd + 4),(int)converted_sample_time\n                             ,result_division);\n    pid->kd = computed_value;\n    pid->SampleTime = new_sample_time;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001918": "set_sample_time_08001918",
                "this": "pid",
                "NewSampleTime": "new_sample_time",
                "uVar1": "result_division",
                "uVar2": "converted_sample_time",
                "uVar3": "converted_sample_time_2",
                "dVar4": "computed_value"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__floatsidf",
                "__floatunsidf",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001960": {
            "entrypoint": "0x08001960",
            "current_name": "set_output_limits_08001960",
            "code": "\n/* DWARF original prototype: void  SetOutputLimits(PID * pidObject, double minOutput, double maxOutput) */\n\nvoid __pidObjectcall PID::setOutputLimits_08001960(PID *pidObject,double minOutput,double maxOutput)\n\n{\n  int comparisonResult;\n  undefined4 outMinLow;\n  undefined4 outMinHigh;\n  double *outputPtr;\n  undefined4 sumVar1;\n  undefined4 sumVar2;\n  undefined4 outMaxLow;\n  undefined4 outMaxHigh;\n  \n  comparisonResult = __aeabi_dcmpge();\n  if (comparisonResult == 0) {\n    *(undefined4 *)&pidObject->outminOutput = outMinLow;\n    *(undefined4 *)((int)&pidObject->outminOutput + 4) = outMinHigh;\n    pidObject->outmaxOutput = minOutput;\n    if (pidObject->inAuto != false) {\n      outputPtr = pidObject->myOutput;\n      comparisonResult = __aeabi_dcmplt(minOutput._0_4_,minOutput._4_4_,*(undefined4 *)outputPtr,\n                             *(undefined4 *)((int)outputPtr + 4));\n      if (comparisonResult == 0) {\n        comparisonResult = __aeabi_dcmpgt();\n        if (comparisonResult != 0) {\n          *(undefined4 *)outputPtr = outMinLow;\n          *(undefined4 *)((int)outputPtr + 4) = outMinHigh;\n        }\n      }\n      else {\n        *outputPtr = minOutput;\n      }\n      sumVar1 = *(undefined4 *)&pidObject->outputSum;\n      sumVar2 = *(undefined4 *)((int)&pidObject->outputSum + 4);\n      outMaxLow = *(undefined4 *)&pidObject->outmaxOutput;\n      outMaxHigh = *(undefined4 *)((int)&pidObject->outmaxOutput + 4);\n      comparisonResult = __aeabi_dcmpgt(sumVar1,sumVar2,outMaxLow,outMaxHigh);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&pidObject->outputSum = outMaxLow;\n        *(undefined4 *)((int)&pidObject->outputSum + 4) = outMaxHigh;\n        return;\n      }\n      outMaxLow = *(undefined4 *)&pidObject->outminOutput;\n      outMaxHigh = *(undefined4 *)((int)&pidObject->outminOutput + 4);\n      comparisonResult = __aeabi_dcmplt(sumVar1,sumVar2,outMaxLow,outMaxHigh);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&pidObject->outputSum = outMaxLow;\n        *(undefined4 *)((int)&pidObject->outputSum + 4) = outMaxHigh;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001960": "set_output_limits_08001960",
                "Min": "minOutput",
                "Max": "maxOutput",
                "this": "pidObject",
                "in_r2": "outMinLow",
                "in_r3": "outMinHigh",
                "pdVar2": "outputPtr",
                "uVar3": "sumVar1",
                "uVar4": "sumVar2",
                "uVar5": "outMaxLow",
                "uVar6": "outMaxHigh",
                "iVar1": "comparisonResult"
            },
            "calling": [
                "PID",
                "loop"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019f6": {
            "entrypoint": "0x080019f6",
            "current_name": "initialize_pid_080019f6",
            "code": "\n/* DWARF original prototype: void  Initialize(PID * pid) */\n\nvoid __pidcall PID::initializePID_080019f6(PID *pid)\n\n{\n  int comparisonResult;\n  undefined4 tempOutMin;\n  undefined4 tempOutput;\n  undefined4 tempOutMax;\n  undefined4 tempOutMax2;\n  \n  tempOutput = *(undefined4 *)pid->myOutput;\n  tempOutMax = *(undefined4 *)((int)pid->myOutput + 4);\n  *(undefined4 *)&pid->outputSum = tempOutput;\n  *(undefined4 *)((int)&pid->outputSum + 4) = tempOutMax;\n  tempOutMin = *(undefined4 *)((int)pid->myInput + 4);\n  *(undefined4 *)&pid->lastInput = *(undefined4 *)pid->myInput;\n  *(undefined4 *)((int)&pid->lastInput + 4) = tempOutMin;\n  tempOutMin = *(undefined4 *)&pid->outMax;\n  tempOutMax2 = *(undefined4 *)((int)&pid->outMax + 4);\n  comparisonResult = __aeabi_dcmpgt(tempOutput,tempOutMax,tempOutMin,tempOutMax2);\n  if (comparisonResult == 0) {\n    tempOutMin = *(undefined4 *)&pid->outMin;\n    tempOutMax2 = *(undefined4 *)((int)&pid->outMin + 4);\n    comparisonResult = __aeabi_dcmplt(tempOutput,tempOutMax,tempOutMin,tempOutMax2);\n    if (comparisonResult != 0) {\n      *(undefined4 *)&pid->outputSum = tempOutMin;\n      *(undefined4 *)((int)&pid->outputSum + 4) = tempOutMax2;\n    }\n    return;\n  }\n  *(undefined4 *)&pid->outputSum = tempOutMin;\n  *(undefined4 *)((int)&pid->outputSum + 4) = tempOutMax2;\n  return;\n}\n\n",
            "renaming": {
                "this": "pid",
                "iVar1": "comparisonResult",
                "uVar2": "tempOutMin",
                "uVar3": "tempOutput",
                "uVar4": "tempOutMax",
                "uVar5": "tempOutMax2",
                "FUN_080019f6": "initialize_pid_080019f6"
            },
            "calling": [
                "SetMode"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a44": {
            "entrypoint": "0x08001a44",
            "current_name": "set_mode_08001a44",
            "code": "\n/* DWARF original prototype: void  Setmode(PID * pid_instance, int mode) */\n\nvoid __pid_instancecall PID::set_mode_08001a44(PID *pid_instance,int mode)\n\n{\n  bool is_auto;\n  bool should_initialize;\n  \n  if (mode == 1) {\n    should_initialize = true;\n    if (pid_instance->inAuto == false) {\n      Initialize(pid_instance);\n    }\n  }\n  else {\n    should_initialize = false;\n  }\n  pid_instance->inAuto = should_initialize;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a44": "set_mode_08001a44",
                "this": "pid_instance",
                "Mode": "mode",
                "newAuto": "is_auto",
                "bVar1": "should_initialize"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "Initialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a66": {
            "entrypoint": "0x08001a66",
            "current_name": "set_controller_direction_08001a66",
            "code": "\n/* DWARF original prototype: void  SetControllerdirection(PID * pid, int direction) */\n\nvoid __pidcall PID::setControllerDirection_08001a66(PID *pid,int direction)\n\n{\n  double temp;\n  \n  if ((pid->inAuto != false) && (pid->controllerdirection != direction)) {\n    temp = (double)__subdf3(0,0,*(undefined4 *)&pid->kp,*(undefined4 *)((int)&pid->kp + 4));\n    pid->kp = temp;\n    temp = (double)__subdf3(0,0,*(undefined4 *)&pid->ki,*(undefined4 *)((int)&pid->ki + 4));\n    pid->ki = temp;\n    temp = (double)__subdf3(0,0,*(undefined4 *)&pid->kd,*(undefined4 *)((int)&pid->kd + 4));\n    pid->kd = temp;\n  }\n  pid->controllerdirection = direction;\n  return;\n}\n\n",
            "renaming": {
                "this": "pid",
                "Direction": "direction",
                "dVar1": "temp",
                "FUN_08001a66": "set_controller_direction_08001a66"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_pid_08001ab0",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidInstance, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int proportionalOn, int controllerDirection) */\n\nPID * __pidInstancecall\nPID::initializePID_08001ab0(PID *pidInstance,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int proportionalOn,int controllerDirection)\n\n{\n  uint32_t currentTime;\n  int proportionalOn0;\n  undefined4 stackVar_e8;\n  undefined4 stackVar_ec;\n  undefined4 stackVar_f4;\n  \n  pidInstance->myoutput = output;\n  pidInstance->myinput = input;\n  pidInstance->mysetpoint = setpoint;\n  pidInstance->inAuto = false;\n  SetoutputLimits(pidInstance,255.0,(double)CONCAT44(stackVar_ec,stackVar_e8));\n  pidInstance->SampleTime = 100;\n  SetcontrollerDirection(pidInstance,controllerDirection);\n  SetTunings(pidInstance,integralGain,derivativeGain,(double)CONCAT44(stackVar_f4,proportionalOn),proportionalOn0);\n  currentTime = millis();\n  pidInstance->lastTime = currentTime - pidInstance->SampleTime;\n  return pidInstance;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_pid_08001ab0",
                "this": "pidInstance",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "proportionalOn",
                "ControllerDirection": "controllerDirection",
                "uVar1": "currentTime",
                "POn_00": "proportionalOn0",
                "in_stack_ffffffe8": "stackVar_e8",
                "in_stack_ffffffec": "stackVar_ec",
                "in_stack_fffffff4": "stackVar_f4"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "SetOutputLimits",
                "millis",
                "SetTunings",
                "SetControllerDirection"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b18": {
            "entrypoint": "0x08001b18",
            "current_name": "initialize_pid_08001b18",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidInstance, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int controllerDirection) */\n\nPID * __pidInstancecall\nPID::initializePID_08001b18(PID *pidInstance,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int controllerDirection)\n\n{\n  PID(pidInstance,input,output,setpoint,proportionalGain,integralGain,derivativeGain,1,controllerDirection);\n  return pidInstance;\n}\n\n",
            "renaming": {
                "FUN_08001b18": "initialize_pid_08001b18",
                "this": "pidInstance",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "ControllerDirection": "controllerDirection"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_clocks_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08001b48(void)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t hclkFreq;\n  RCC_PeriphCLKInitTypeDef periphClkInit;\n  RCC_ClkInitTypeDef rccClkInit;\n  RCC_OscInitTypeDef rccOscInit;\n  \n  rccOscInit.OscillatorType = 2;\n  rccOscInit.HSIState = 1;\n  rccOscInit.HSICalibrationValue = 0x10;\n  rccOscInit.PLL.PLLState = 2;\n  rccOscInit.PLL.PLLSource = 0;\n  rccOscInit.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&rccOscInit);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  rccClkInit.ClockType = 0xf;\n  rccClkInit.SYSCLKSource = 2;\n  rccClkInit.AHBCLKDivider = 0;\n  rccClkInit.APB1CLKDivider = 0x400;\n  rccClkInit.APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&rccClkInit,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  periphClkInit.PeriphClockSelection = 2;\n  periphClkInit.AdcClockSelection = 0x8000;\n  status = HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)&periphClkInit);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_clocks_08001b48",
                "RCC_OscInitStruct": "rccOscInit",
                "RCC_ClkInitStruct": "rccClkInit",
                "PeriphClkInit": "periphClkInit",
                "HVar1": "status",
                "uVar2": "hclkFreq"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_Config",
                "_Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_system_08001be8",
            "code": "\nvoid initializeSystem_08001be8(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumptable;\n  \n  for (index = 0; (undefined *)(index + 0x20000000) < &_edata; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (pointer = &completed_8667; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptable = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_system_08001be8",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumptable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c30": {
            "entrypoint": "0x08001c30",
            "current_name": "infinite_loop_08001c30",
            "code": "\nvoid infiniteLoop_08001c30(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001c30": "infinite_loop_08001c30"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c32": {
            "entrypoint": "0x08001c32",
            "current_name": "initialize_hardware_config_08001c32",
            "code": "\nint initializeHardwareConfig_08001c32(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08001c32": "initialize_hardware_config_08001c32",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3a": {
            "entrypoint": "0x08001c3a",
            "current_name": "FUNC_08001c3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c3a": "FUNC_08001c3a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3c": {
            "entrypoint": "0x08001c3c",
            "current_name": "configure_sys_tick_08001c3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureSysTick_08001c3c(uint32_t priority)\n\n{\n  uint32_t configResult;\n  \n  configResult = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configResult != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001c3c": "configure_sys_tick_08001c3c",
                "TickPriority": "priority",
                "uVar1": "configResult"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c88": {
            "entrypoint": "0x08001c88",
            "current_name": "initialize_hardware_08001c88",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeHardware_08001c88(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializePeriph();\n  return success;\n}\n\n",
            "renaming": {
                "FUN_08001c88": "initialize_hardware_08001c88",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeriph",
                "HAL_OK": "success"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cac": {
            "entrypoint": "0x08001cac",
            "current_name": "increase_tick_value_08001cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid increaseTickValue_08001cac(void)\n\n{\n  currentTick = tickFrequency + currentTick;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cac": "increase_tick_value_08001cac",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cc4": {
            "entrypoint": "0x08001cc4",
            "current_name": "get_system_tick_08001cc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08001cc4(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08001cc4": "get_system_tick_08001cc4",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_RCCEx_PeriphCLKConfig",
                "ADC_ConversionStop_Disable",
                "HAL_ADC_PollForConversion",
                "GetCurrentMilli",
                "HAL_RCC_ClockConfig",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_UART_Transmit",
                "ADC_Enable",
                "HAL_RCC_OscConfig",
                "uart_debug_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "perform_adc_conversion_with_timeout_08001cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict perform_ADC_conversion_with_timeout_08001cd0(ADC_HandleTypeDef *adc_handle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time;\n  uint32_t adc_clk_freq;\n  int sampling_time;\n  uint32_t current_time;\n  ADC_TypeDef *adc_instance;\n  uint conversion_cycles;\n  uint32_t elapsed_cycles;\n  \n  elapsed_cycles = 0;\n  start_time = HAL_GetTick();\n  current_time = SystemCoreClock;\n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 0x100) == 0) {\n    if (((adc_instance->CR1 & 0x100) == 0) && ((adc_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & 2) != 0) goto LAB_08001de2;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (current_time = HAL_GetTick(), current_time - start_time <= timeout))));\n      adc_handle->State = adc_handle->State | 4;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      adc_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adc_instance = adc_handle->Instance;\n      if (((adc_instance->SMPR2 & 0x24924924) == 0) && ((adc_instance->SMPR1 & 0x924924) == 0)) {\n        if ((adc_instance->SMPR2 & 0x12492492) == 0) {\n          if ((adc_instance->SMPR1 & 0x492492) == 0) {\n            sampling_time = 0x14;\n          }\n          else {\n            sampling_time = 0x29;\n          }\n        }\n        else {\n          sampling_time = 0x29;\n        }\n      }\n      else if (((adc_instance->SMPR2 & 0x12492492) == 0) && ((adc_instance->SMPR1 & 0x492492) == 0)) {\n        sampling_time = 0x54;\n      }\n      else if ((adc_instance->SMPR2 & 0x249249) == 0) {\n        if ((adc_instance->SMPR1 & 0x249249) == 0) {\n          sampling_time = 0x54;\n        }\n        else {\n          sampling_time = 0xfc;\n        }\n      }\n      else {\n        sampling_time = 0xfc;\n      }\n      conversion_cycles = (current_time / adc_clk_freq) * sampling_time;\n      for (; elapsed_cycles <= conversion_cycles && conversion_cycles - elapsed_cycles != 0;\n          elapsed_cycles = elapsed_cycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (current_time = HAL_GetTick(), timeout < current_time - start_time)))) {\n          adc_handle->State = adc_handle->State | 4;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State = adc_handle->State | 0x200;\n      if ((adc_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adc_handle->Init).ContinuousConvMode == 0) {\n          adc_handle->State = adc_handle->State & 0xfffffeff;\n          if ((adc_handle->State & 0x1000) == 0) {\n            adc_handle->State = adc_handle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State = adc_handle->State | 0x20;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "perform_adc_conversion_with_timeout_08001cd0",
                "hadc": "adc_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "adc_clk_freq",
                "uVar5": "current_time",
                "pAVar6": "adc_instance",
                "uVar7": "conversion_cycles",
                "Conversion_Timeout_CPU_cycles": "elapsed_cycles",
                "iVar4": "sampling_time"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e40": {
            "entrypoint": "0x08001e40",
            "current_name": "get_adc_data_08001e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_data_08001e40(ADC_HandleTypeDef *ADC_handler)\n\n{\n  return ADC_handler->ADC_instance->data_register;\n}\n\n",
            "renaming": {
                "FUN_08001e40": "get_adc_data_08001e40",
                "hadc": "ADC_handler",
                "Instance": "ADC_instance",
                "DR": "data_register"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e48": {
            "entrypoint": "0x08001e48",
            "current_name": "configure_adc_channel_08001e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_08001e48(ADC_HandleTypeDef *ADC_handle,ADC_ChannelConfTypeDef *ADC_ChannelConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint rank;\n  uint32_t waitIndex;\n  \n  if (ADC_handle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    ADC_handle->Lock = HAL_LOCKED;\n    rank = ADC_ChannelConfig->Rank;\n    if (rank < 7) {\n      rank = rank * 5 - 5;\n      ADC_handle->Instance->SQR3 =\n           ADC_ChannelConfig->Channel << (rank & 0xff) | ADC_handle->Instance->SQR3 & ~(0x1f << (rank & 0xff));\n    }\n    else if (rank < 0xd) {\n      rank = rank * 5 - 0x23;\n      ADC_handle->Instance->SQR2 =\n           ADC_ChannelConfig->Channel << (rank & 0xff) | ADC_handle->Instance->SQR2 & ~(0x1f << (rank & 0xff));\n    }\n    else {\n      rank = rank * 5 - 0x41;\n      ADC_handle->Instance->SQR1 =\n           ADC_ChannelConfig->Channel << (rank & 0xff) | ADC_handle->Instance->SQR1 & ~(0x1f << (rank & 0xff));\n    }\n    rank = ADC_ChannelConfig->Channel;\n    if (rank < 10) {\n      ADC_handle->Instance->SMPR2 =\n           ADC_ChannelConfig->SamplingTime << (rank * 3 & 0xff) |\n           ADC_handle->Instance->SMPR2 & ~(7 << (rank * 3 & 0xff));\n    }\n    else {\n      rank = rank * 3 - 0x1e;\n      ADC_handle->Instance->SMPR1 =\n           ADC_ChannelConfig->SamplingTime << (rank & 0xff) | ADC_handle->Instance->SMPR1 & ~(7 << (rank & 0xff));\n    }\n    if (ADC_ChannelConfig->Channel - 0x10 < 2) {\n      if (ADC_handle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (ADC_ChannelConfig->Channel == 0x10) {\n            for (waitIndex = (SystemCoreClock / 1000000) * 10; waitIndex != 0;\n                waitIndex = waitIndex - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        ADC_handle->State = ADC_handle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    ADC_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001e48": "configure_adc_channel_08001e48",
                "hadc": "ADC_handle",
                "sConfig": "ADC_ChannelConfig",
                "HVar1": "status",
                "uVar2": "rank",
                "wait_loop_index": "waitIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f80": {
            "entrypoint": "0x08001f80",
            "current_name": "get_adc_state_08001f80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getADCState_08001f80(ADC_HandleTypeDef *adcHandle)\n\n{\n  return adcHandle->state;\n}\n\n",
            "renaming": {
                "FUN_08001f80": "get_adc_state_08001f80",
                "hadc": "adcHandle",
                "State": "state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f84": {
            "entrypoint": "0x08001f84",
            "current_name": "initialize_adc_08001f84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08001f84(ADC_HandleTypeDef *ADC_Handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  ADC_TypeDef *ADC_Instance;\n  uint32_t loopIndex;\n  \n  ADC_Instance = ADC_Handle->Instance;\n  if ((ADC_Instance->CR2 & 1) == 0) {\n    ADC_Instance->CR2 = ADC_Instance->CR2 | 1;\n    for (loopIndex = SystemCoreClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTick = HAL_GetTick();\n    do {\n      if ((ADC_Handle->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    ADC_Handle->State = ADC_Handle->State | 0x10;\n    ADC_Handle->ErrorCode = ADC_Handle->ErrorCode | 1;\n    ADC_Handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f84": "initialize_adc_08001f84",
                "hadc": "ADC_Handle",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "pAVar4": "ADC_Instance",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002004": {
            "entrypoint": "0x08002004",
            "current_name": "configure_adc_08002004",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADC_08002004(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adcInstance;\n  \n  if (adcHandle->Lock != HAL_LOCKED) {\n    adcHandle->Lock = HAL_LOCKED;\n    status = ADC_Enable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->State = adcHandle->State & 0xfffffcfe | 0x100;\n      adcInstance = adcHandle->Instance;\n      if ((adcInstance == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        adcHandle->State = adcHandle->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State & 0xffefffff;\n        if ((adcInstance->CR1 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((adcHandle->State & 0x1000) == 0) {\n        adcHandle->ErrorCode = 0;\n      }\n      else {\n        adcHandle->ErrorCode = adcHandle->ErrorCode & 0xfffffff9;\n      }\n      adcHandle->Lock = HAL_UNLOCKED;\n      adcInstance->SR = 0xfffffffd;\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->CR2 & 0xe0000) == 0xe0000) &&\n         ((adcInstance != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        adcInstance->CR2 = adcInstance->CR2 | 0x500000;\n      }\n      else {\n        adcInstance->CR2 = adcInstance->CR2 | 0x100000;\n      }\n    }\n    else {\n      adcHandle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002004": "configure_adc_08002004",
                "hadc": "adcHandle",
                "HVar1": "status",
                "pAVar2": "adcInstance"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080020f0": {
            "entrypoint": "0x080020f0",
            "current_name": "check_adc_status_080020f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict checkADCStatus_080020f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  ADC_TypeDef *adcInstance;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adcInstance->CR2 = adcInstance->CR2 & 0xfffffffe;\n  startTick = HAL_GetTick();\n  do {\n    if ((adcHandle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    currentTick = HAL_GetTick();\n  } while (currentTick - startTick < 3);\n  adcHandle->State = adcHandle->State | 0x10;\n  adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080020f0": "check_adc_status_080020f0",
                "hadc": "adcHandle",
                "pAVar3": "adcInstance",
                "uVar1": "startTick",
                "uVar2": "currentTick"
            },
            "calling": [
                "HAL_ADC_DeInit",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800213c": {
            "entrypoint": "0x0800213c",
            "current_name": "configure_adc_0800213c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADC_0800213c(ADC_HandleTypeDef *adcHandler)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value1;\n  uint value2;\n  uint value3;\n  uint32_t value4;\n  \n  if (adcHandler == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (adcHandler->State == 0) {\n    adcHandler->ErrorCode = 0;\n    adcHandler->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adcHandler);\n  }\n  status = ADC_ConversionStop_Disable(adcHandler);\n  if (((adcHandler->State & 0x10) == 0) && (status == HAL_OK)) {\n    adcHandler->State = adcHandler->State & 0xffffeefd | 2;\n    value4 = (adcHandler->Init).ContinuousConvMode;\n    value2 = (adcHandler->Init).DataAlign | (adcHandler->Init).ExternalTrigConv | value4 << 1;\n    value1 = (adcHandler->Init).ScanConvMode;\n    if (value1 == 0x100) {\n      value3 = 0x100;\n    }\n    else {\n      value3 = 0;\n      if (value1 == 1) {\n        value3 = 0x100;\n      }\n    }\n    if ((adcHandler->Init).DiscontinuousConvMode == 1) {\n      if (value4 == 0) {\n        value3 = value3 | ((adcHandler->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adcHandler->State = adcHandler->State | 0x20;\n        adcHandler->ErrorCode = adcHandler->ErrorCode | 1;\n      }\n    }\n    adcHandler->Instance->CR1 = value3 | adcHandler->Instance->CR1 & 0xffff16ff;\n    adcHandler->Instance->CR2 = adcHandler->Instance->CR2 & 0xffe1f7fd | value2;\n    value1 = (adcHandler->Init).ScanConvMode;\n    if ((value1 == 0x100) || (value1 == 1)) {\n      value3 = ((adcHandler->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      value3 = 0;\n    }\n    adcHandler->Instance->SQR1 = value3 | adcHandler->Instance->SQR1 & 0xff0fffff;\n    if (value2 != (adcHandler->Instance->CR2 & 0xff1f0efe)) {\n      adcHandler->State = adcHandler->State & 0xffffffed | 0x10;\n      adcHandler->ErrorCode = adcHandler->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adcHandler->ErrorCode = 0;\n    adcHandler->State = adcHandler->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adcHandler->State = adcHandler->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800213c": "configure_adc_0800213c",
                "hadc": "adcHandler",
                "HVar1": "status",
                "uVar2": "value1",
                "uVar3": "value2",
                "uVar4": "value3",
                "uVar5": "value4"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800224c": {
            "entrypoint": "0x0800224c",
            "current_name": "disable_adc_conversion_and_reset_state_0800224c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableADCConversionAndResetState_0800224c(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    adcHandle->State = adcHandle->State | 2;\n    status = ADC_ConversionStop_Disable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->Instance->SR = 0xffffffe0;\n      adcHandle->Instance->CR1 = adcHandle->Instance->CR1 & 0xff3f0000;\n      adcHandle->Instance->CR2 = adcHandle->Instance->CR2 & 0xff0106f0;\n      adcHandle->Instance->SMPR1 = adcHandle->Instance->SMPR1 & 0xff000000;\n      adcHandle->Instance->SMPR2 = adcHandle->Instance->SMPR2 & 0xc0000000;\n      adcHandle->Instance->JOFR1 = adcHandle->Instance->JOFR1 & 0xfffff000;\n      adcHandle->Instance->JOFR2 = adcHandle->Instance->JOFR2 & 0xfffff000;\n      adcHandle->Instance->JOFR3 = adcHandle->Instance->JOFR3 & 0xfffff000;\n      adcHandle->Instance->JOFR4 = adcHandle->Instance->JOFR4 & 0xfffff000;\n      adcHandle->Instance->HTR = adcHandle->Instance->HTR & 0xfffff000;\n      adcHandle->Instance->LTR = adcHandle->Instance->LTR & 0xfffff000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR2 = adcHandle->Instance->SQR2 & 0xc0000000;\n      adcHandle->Instance->SQR3 = adcHandle->Instance->SQR3 & 0xc0000000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      HAL_ADC_MspDeInit(adcHandle);\n      adcHandle->ErrorCode = 0;\n      adcHandle->State = 0;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800224c": "disable_adc_conversion_and_reset_state_0800224c",
                "hadc": "adcHandle",
                "HVar1": "status"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002348": {
            "entrypoint": "0x08002348",
            "current_name": "stop_adc_conversion_08002348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef stopADCConversion_08002348(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef status;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  status = disableADCConversionStop(hadc);\n  if (status == HAL_OK) {\n    hadc->state = hadc->state & 0xffffeefe | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002348": "stop_adc_conversion_08002348",
                "HVar1": "status",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "State": "state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002384": {
            "entrypoint": "0x08002384",
            "current_name": "perform_adc_conversion_08002384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict performADCConversion_08002384(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clockFreq;\n  uint32_t systemClock;\n  ADC_TypeDef *adcInstance;\n  uint32_t startTime;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adcHandle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (status == HAL_OK) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    systemClock = SystemCoreClock;\n    clockFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loopIndex = systemClock / clockFreq << 1; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    ADC_Enable(adcHandle);\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 | 8;\n    systemClock = HAL_GetTick();\n    while (adcInstance = adcHandle->Instance, (adcInstance->CR2 & 8) != 0) {\n      clockFreq = HAL_GetTick();\n      if (10 < clockFreq - systemClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcInstance->CR2 = adcInstance->CR2 | 4;\n    systemClock = HAL_GetTick();\n    while ((adcHandle->Instance->CR2 & 4) != 0) {\n      clockFreq = HAL_GetTick();\n      if (10 < clockFreq - systemClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n  }\n  adcHandle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002384": "perform_adc_conversion_08002384",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "clockFreq",
                "uVar3": "systemClock",
                "pAVar4": "adcInstance",
                "tickstart": "startTime",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002470": {
            "entrypoint": "0x08002470",
            "current_name": "set_priority_group_08002470",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08002470(uint32_t priorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002470": "set_priority_group_08002470",
                "PriorityGroup": "priorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002494": {
            "entrypoint": "0x08002494",
            "current_name": "configure_priority_08002494",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriority_08002494(irqNumber IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqNumberInt;\n  uint shiftValue;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqNumberInt = (uint)IRQn;\n  shiftValue = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - shiftValue;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (shiftValue + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = shiftValue - 3;\n  }\n  shiftValue = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqNumberInt < 0) {\n    *(char *)((irqNumberInt & 0xf) + 0xe000ed14) = (char)(shiftValue << 4);\n  }\n  else {\n    *(char *)(irqNumberInt + 0xe000e400) = (char)(shiftValue << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002494": "configure_priority_08002494",
                "IRQn_Type_conflict": "irqNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "uVar1": "irqNumberInt",
                "uVar2": "shiftValue"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024f8": {
            "entrypoint": "0x080024f8",
            "current_name": "set_irq_bit_080024f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQBit_080024f8(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)interruptNumber;\n  if (-1 < (int)interruptIndex) {\n    *(int *)((interruptIndex >> 5) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024f8": "set_irq_bit_080024f8",
                "IRQn": "interruptNumber",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002514": {
            "entrypoint": "0x08002514",
            "current_name": "initialize_ticks_08002514",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08002514(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002514": "initialize_ticks_08002514",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002540": {
            "entrypoint": "0x08002540",
            "current_name": "set_interrupt_handler_08002540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptHandler_08002540(interruptNumber IRQn)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)IRQn;\n  if (-1 < (int)interruptIndex) {\n    *(int *)(((interruptIndex >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002540": "set_interrupt_handler_08002540",
                "IRQn_Type_conflict": "interruptNumber",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002560": {
            "entrypoint": "0x08002560",
            "current_name": "set_clock_source_08002560",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08002560(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002560": "set_clock_source_08002560",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "FUNC_08002580",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002580(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "FUNC_08002580"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002582": {
            "entrypoint": "0x08002582",
            "current_name": "initialize_sys_tick_08002582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_sys_tick_08002582(void)\n\n{\n  handle_sys_tick_interrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002582": "initialize_sys_tick_08002582",
                "HAL_SYSTICK_Callback": "handle_sys_tick_interrupt"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800258c": {
            "entrypoint": "0x0800258c",
            "current_name": "set_dma_channel_configuration_0800258c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict set_DMA_channel_configuration_0800258c(DMA_HandleTypeDef *dma_handle)\n\n{\n  DMA_Channel_TypeDef *current_channel;\n  \n  if (dma_handle->State != DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return ERROR;\n  }\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffff1;\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffffe;\n  current_channel = dma_handle->Instance;\n  if (current_channel == (DMA_Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (current_channel == (DMA_Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dma_handle->State = DMA_STATE_READY;\n  dma_handle->Lock = UNLOCKED;\n  if (dma_handle->XferAbortCallback != (XferAbortCallback *)0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return OK;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800258c": "set_dma_channel_configuration_0800258c",
                "hdma": "dma_handle",
                "pDVar1": "current_channel",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_DMA_STATE_READY": "DMA_STATE_READY",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK",
                "_func_void___DMA_HandleTypeDef_ptr": "XferAbortCallback"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002624": {
            "entrypoint": "0x08002624",
            "current_name": "configure_gpio_08002624",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08002624(GPIO_TypeDef *gpio,initTypeDef *init)\n\n{\n  GPIO_TypeDef *gpioPointer;\n  uint pinMask;\n  uint pin;\n  uint i;\n  uint mode;\n  uint32_t speed;\n  int shift;\n  uint32_t *configRegister;\n  int index;\n  uint32_t tempRegister;\n  \n  speed = 0;\n  i = 0;\n  do {\n    if (0xf < i) {\n      return;\n    }\n    pinMask = 1 << (i & 0xff);\n    pin = init->Pin & pinMask;\n    if (pinMask == pin) {\n      mode = init->Mode;\n      if (mode == 0x12) {\n        speed = init->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          speed = init->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08002776;\n          if (mode == 1) {\n            speed = init->Speed;\n          }\n        }\n        else if (mode == 3) {\n          speed = 0;\n        }\n        else if (mode == 0x11) {\n          speed = init->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08002776:\n        if (init->Pull == 0) {\n          speed = 4;\n        }\n        else if (init->Pull == 1) {\n          gpio->BSRR = pinMask;\n          speed = 8;\n        }\n        else {\n          gpio->BRR = pinMask;\n          speed = 8;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08002776;\n      }\n      else if ((mode == 0x10310000) || ((mode == 0x10320000 || (mode == 0x10220000))))\n      goto LAB_08002776;\n      pinMask = i;\n      gpioPointer = gpio;\n      if (0xff < pin) {\n        pinMask = i - 8;\n        gpioPointer = (GPIO_TypeDef *)&gpio->CRH;\n      }\n      gpioPointer->CRL = gpioPointer->CRL & ~(0xf << (pinMask << 2 & 0xff)) | speed << (pinMask << 2 & 0xff);\n      if ((init->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shift = (i & 3) << 2;\n        if (gpio == (GPIO_TypeDef *)0x40010800) {\n          index = 0;\n        }\n        else if (gpio == (GPIO_TypeDef *)0x40010c00) {\n          index = 1;\n        }\n        else if (gpio == (GPIO_TypeDef *)0x40011000) {\n          index = 2;\n        }\n        else if (gpio == (GPIO_TypeDef *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((i >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((i >> 2) + 2) * 4 + 0x40010000) & ~(0xf << shift) | index << shift;\n        if ((init->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pin;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pin;\n        }\n        if ((init->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pin;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pin;\n        }\n        if ((init->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pin;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pin;\n        }\n        if ((init->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pin;\n        }\n        else {\n          _DAT_4001040c = pin | _DAT_4001040c;\n        }\n      }\n    }\n    i = i + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002624": "configure_gpio_08002624",
                "GPIOx": "gpio",
                "GPIO_Init": "init",
                "uVar2": "pinMask",
                "uVar3": "pin",
                "uVar4": "i",
                "uVar5": "mode",
                "uVar6": "speed",
                "configregister": "configRegister",
                "tmpreg": "tempRegister",
                "pGVar1": "gpioPointer",
                "iVar7": "shift",
                "iVar8": "index"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002810": {
            "entrypoint": "0x08002810",
            "current_name": "check_pin_status_08002810",
            "code": "\n/* WARNING: Unknown calling convention */\n\npinNumberState checkPinStatus_08002810(GPIO_TypeDef *ptr_GPIO,uint16_t pinNumber)\n\n{\n  pinNumberState pinState;\n  \n  if (((uint)pinNumber & ptr_GPIO->IDR) == 0) {\n    pinState = GPIO_PIN_RESET;\n    return pinState;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_08002810": "check_pin_status_08002810",
                "GPIOx": "ptr_GPIO",
                "GPIO_Pin": "pinNumber",
                "bitstatus": "pinState"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800281e": {
            "entrypoint": "0x0800281e",
            "current_name": "set_pin_state_0800281e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_0800281e(GPIO_TypeDef *port,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  if (pinState == GPIO_PIN_RESET) {\n    port->bitSetResetRegister = (uint)pinNumber << 0x10;\n    return;\n  }\n  port->bitSetResetRegister = (uint)pinNumber;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800281e": "set_pin_state_0800281e",
                "GPIOx": "port",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState",
                "BSRR": "bitSetResetRegister"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800282c": {
            "entrypoint": "0x0800282c",
            "current_name": "handle_gpio_pin_0800282c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_0800282c(uint16_t pin)\n\n{\n  if ((_DAT_40010414 & pin) != 0) {\n    _DAT_40010414 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800282c": "handle_gpio_pin_0800282c",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI4_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "set_i2_c_device_address_mode_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddressMode_08002848(I2C_HandleTypeDef *i2cHandler)\n\n{\n  if (i2cHandler->deviceMode == I2C_MODE_MEMORY) {\n    if (i2cHandler->eventCount == 0) {\n      i2cHandler->i2cInstance->dataRegister = i2cHandler->WJFGJJdataRegisterJC & 0xfe;\n    }\n    else {\n      i2cHandler->i2cInstance->dataRegister = i2cHandler->WJFGJJdataRegisterJC & 0xff | 1;\n    }\n  }\n  else if ((i2cHandler->i2cInitConfig).addressingMode == 0x4000) {\n    if (i2cHandler->i2cState == I2C_STATE_BUSY_TRANSMIT) {\n      i2cHandler->i2cInstance->dataRegister = i2cHandler->WJFGJJdataRegisterJC & 0xfe;\n    }\n    else {\n      i2cHandler->i2cInstance->dataRegister = i2cHandler->WJFGJJdataRegisterJC & 0xff | 1;\n    }\n  }\n  else if (i2cHandler->eventCount == 0) {\n    i2cHandler->i2cInstance->dataRegister = (i2cHandler->WJFGJJdataRegisterJC << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandler->eventCount == 1) {\n    i2cHandler->i2cInstance->dataRegister = (i2cHandler->WJFGJJdataRegisterJC << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OPERATION_OK;\n}\n\n",
            "renaming": {
                "FUN_08002848": "set_i2_c_device_address_mode_08002848",
                "hi2c": "i2cHandler",
                "Mode": "deviceMode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "Init": "i2cInitConfig",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TRANSMIT",
                "HAL_OK": "HAL_OPERATION_OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d2": {
            "entrypoint": "0x080028d2",
            "current_name": "set_i2_c_device_address_080028d2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict set_I2C_device_address_080028d2(I2C_HandleTypeDef *I2C_handle)\n\n{\n  I2C_handle->I2C_instance->data_register = I2C_handle->device_address & 0xff;\n  return HAL_operation_successful;\n}\n\n",
            "renaming": {
                "FUN_080028d2": "set_i2_c_device_address_080028d2",
                "hi2c": "I2C_handle",
                "Instance": "I2C_instance",
                "DR": "data_register",
                "Devaddress": "device_address",
                "HAL_OK": "HAL_operation_successful"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028de": {
            "entrypoint": "0x080028de",
            "current_name": "handle_i2_c_state_080028de",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CState_080028de(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t transferOptions;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempReg;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  uint32_t tempReg3;\n  uint32_t tempReg4;\n  uint32_t tempReg5;\n  uint32_t tempReg6;\n  uint32_t tempReg7;\n  uint32_t tempReg8;\n  uint32_t tempReg9;\n  uint32_t tempReg10;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (transferOptions == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((transferOptions == 4) || (transferOptions == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028de": "handle_i2_c_state_080028de",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "transferOptions",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempReg",
                "tmpreg_1": "tempReg1",
                "tmpreg_2": "tempReg2",
                "tmpreg_3": "tempReg3",
                "tmpreg_4": "tempReg4",
                "tmpreg_5": "tempReg5",
                "tmpreg_6": "tempReg6",
                "tmpreg_7": "tempReg7",
                "tmpreg_8": "tempReg8",
                "tmpreg_9": "tempReg9",
                "tmpreg_10": "tempReg10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ab8": {
            "entrypoint": "0x08002ab8",
            "current_name": "transfer_data_08002ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferData_08002ab8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  byte *bytePointer;\n  \n  if (i2cHandle->XferCount != 0) {\n    bytePointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bytePointer + 1;\n    i2cHandle->Instance->DR = (uint)*bytePointer;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return transferSuccess;\n}\n\n",
            "renaming": {
                "FUN_08002ab8": "transfer_data_08002ab8",
                "hi2c": "i2cHandle",
                "pbVar1": "bytePointer",
                "HAL_OK": "transferSuccess"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "transfer_data_08002ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferData_08002ad8(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint8_t *dataPtr;\n  \n  if (i2cHandler->XferCount != 0) {\n    dataPtr = i2cHandler->pBuffPtr;\n    i2cHandler->pBuffPtr = dataPtr + 1;\n    *dataPtr = (uint8_t)i2cHandler->Instance->DR;\n    i2cHandler->XferCount = i2cHandler->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "transfer_data_08002ad8",
                "hi2c": "i2cHandler",
                "puVar1": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002af8": {
            "entrypoint": "0x08002af8",
            "current_name": "configure_i2_c_08002af8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_08002af8(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002af8": "configure_i2_c_08002af8",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b84": {
            "entrypoint": "0x08002b84",
            "current_name": "configure_i2_c_08002b84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_08002b84(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002b84": "configure_i2_c_08002b84",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c10": {
            "entrypoint": "0x08002c10",
            "current_name": "initialize_i2_c_08002c10",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeI2C_08002c10(I2C_HandleTypeDef *i2CHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2CHandle->State != I2C_STATE_READY) {\n    return I2C_BUSY;\n  }\n  i2CHandle->State = I2C_STATE_LISTEN;\n  i2cInstance = i2CHandle->i2cInstance;\n  if ((i2cInstance->controlRegister1 & 1) == 0) {\n    i2cInstance->controlRegister1 = i2cInstance->controlRegister1 | 1;\n  }\n  i2CHandle->i2cInstance->controlRegister1 = i2CHandle->i2cInstance->controlRegister1 | 0x400;\n  i2CHandle->i2cInstance->controlRegister2 = i2CHandle->i2cInstance->controlRegister2 | 0x300;\n  return I2C_OK;\n}\n\n",
            "renaming": {
                "FUN_08002c10": "initialize_i2_c_08002c10",
                "hi2c": "i2CHandle",
                "pIVar1": "i2cInstance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_BUSY": "I2C_BUSY",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "HAL_OK": "I2C_OK",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c4e": {
            "entrypoint": "0x08002c4e",
            "current_name": "FUNC_08002c4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c4e": "FUNC_08002c4e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c50": {
            "entrypoint": "0x08002c50",
            "current_name": "FUNC_08002c50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c50": "FUNC_08002c50"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c52": {
            "entrypoint": "0x08002c52",
            "current_name": "FUNC_08002c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c52": "FUNC_08002c52"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "send_byte_i2_c_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHALStatus sendByteI2C_08002c54(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  byte *bufferPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    i2cHandle->i2cInstance->dataRegister = (uint)*bufferPtr;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentState == BusyTransmitListenState)) {\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n      i2cHandle->previousState = 0x21;\n      i2cHandle->State = ListenState;\n      SlaveTransmitCompleteCallback(i2cHandle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "send_byte_i2_c_08002c54",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pbVar2": "bufferPtr",
                "HAL_I2C_StateTypeDef": "I2CState",
                "HAL_StatusTypeDef_conflict": "HALStatus",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "BusyTransmitListenState",
                "HAL_I2C_STATE_LISTEN": "ListenState",
                "DR": "dataRegister",
                "XferCount": "transferCount",
                "CR2": "controlRegister2",
                "PreviousState": "previousState",
                "Instance": "i2cInstance",
                "HAL_I2C_SlaveTxCpltCallback": "SlaveTransmitCompleteCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "FUNC_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "FUNC_08002ca4"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca6": {
            "entrypoint": "0x08002ca6",
            "current_name": "transfer_byte_from_i2_c_08002ca6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferByteFromI2C_08002ca6(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint8_t *dataPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    dataPtr = i2cHandle->bufferPtr;\n    i2cHandle->bufferPtr = dataPtr + 1;\n    *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->previousState = 0x22;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ca6": "transfer_byte_from_i2_c_08002ca6",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "dataPtr",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPtr",
                "PreviousState": "previousState"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cf2": {
            "entrypoint": "0x08002cf2",
            "current_name": "update_i2_c_address_and_invoke_callback_08002cf2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict updateI2CAddressAndInvokeCallback_08002cf2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002cf2": "update_i2_c_address_and_invoke_callback_08002cf2",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d1c": {
            "entrypoint": "0x08002d1c",
            "current_name": "handle_i2_c_state_08002d1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CState_08002d1c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002d1c": "handle_i2_c_state_08002d1c",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002db0": {
            "entrypoint": "0x08002db0",
            "current_name": "FUNC_08002db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002db0": "FUNC_08002db0"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002db2": {
            "entrypoint": "0x08002db2",
            "current_name": "handle_i2_c_transfer_08002db2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08002db2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_i2cStateTypeDef currentState;\n  uint32_t currentI2CState;\n  byte *bufferPointer;\n  uint32_t currentTransferOptions;\n  uint32_t tempVar;\n  \n  currentState = i2cHandle->i2cState;\n  tempVar = i2cHandle->transferOptions;\n  if ((i2cHandle->transferSize == 0) && (currentState == I2C_STATE_BUSY_TX)) {\n    if ((tempVar == 4) || ((tempVar == 8 || (tempVar == 0xffff0000)))) {\n      i2cHandle->instance->controlRegister2 = i2cHandle->instance->controlRegister2 & 0xfffff8ff;\n      i2cHandle->instance->controlRegister1 = i2cHandle->instance->controlRegister1 | 0x200;\n      i2cHandle->previousState = 0;\n      i2cHandle->i2cState = I2C_STATE_READY;\n      if (i2cHandle->i2cMode == I2C_MODE_MEM) {\n        i2cHandle->i2cMode = I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->i2cMode = I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->instance->controlRegister2 = i2cHandle->instance->controlRegister2 & 0xfffff8ff;\n      i2cHandle->previousState = 0x11;\n      i2cHandle->i2cMode = I2C_MODE_NONE;\n      i2cHandle->i2cState = I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->i2cMode == I2C_MODE_MEM && (currentState == I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->transferCount == 0) {\n      i2cHandle->instance->controlRegister2 = i2cHandle->instance->controlRegister2 & 0xfffffbff;\n    }\n    else if (i2cHandle->i2cMode == I2C_MODE_MEM) {\n      if (i2cHandle->eventCount == 0) {\n        if (i2cHandle->memAddressSize == 1) {\n          i2cHandle->instance->dataRegister = i2cHandle->memoryAddress & 0xff;\n          i2cHandle->eventCount = i2cHandle->eventCount + 2;\n        }\n        else {\n          i2cHandle->instance->dataRegister = (i2cHandle->memoryAddress << 0x10) >> 0x18;\n          i2cHandle->eventCount = i2cHandle->eventCount + 1;\n        }\n      }\n      else if (i2cHandle->eventCount == 1) {\n        i2cHandle->instance->dataRegister = i2cHandle->memoryAddress & 0xff;\n        i2cHandle->eventCount = i2cHandle->eventCount + 1;\n      }\n      else if (i2cHandle->eventCount == 2) {\n        if (i2cHandle->i2cState == I2C_STATE_BUSY_RX) {\n          i2cHandle->instance->controlRegister1 = i2cHandle->instance->controlRegister1 | 0x100;\n        }\n        else if (i2cHandle->i2cState == I2C_STATE_BUSY_TX) {\n          bufferPointer = i2cHandle->bufferPointer;\n          i2cHandle->bufferPointer = bufferPointer + 1;\n          i2cHandle->instance->dataRegister = (uint)*bufferPointer;\n          i2cHandle->transferCount = i2cHandle->transferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->bufferPointer;\n      i2cHandle->bufferPointer = bufferPointer + 1;\n      i2cHandle->instance->dataRegister = (uint)*bufferPointer;\n      i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002db2": "handle_i2_c_transfer_08002db2",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "bufferPointer",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "tempVar",
                "CR2": "controlRegister2",
                "CR1": "controlRegister1",
                "PreviousState": "previousState",
                "Mode": "i2cMode",
                "Instance": "instance",
                "XferSize": "transferSize",
                "XferOptions": "transferOptions",
                "State": "i2cState",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RX",
                "XferCount": "transferCount",
                "EventCount": "eventCount",
                "MemaddSize": "memAddressSize",
                "Memaddress": "memoryAddress",
                "pBuffPtr": "bufferPointer",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efc": {
            "entrypoint": "0x08002efc",
            "current_name": "i2c_handle_transmission_08002efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict i2c_handleTransmission_08002efc(I2C_HandleTypeDef *i2c_handle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2c_handle->XferOptions;\n  if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2c_handle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2c_handle);\n        }\n        else {\n          i2c_handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2c_handle);\n        }\n      }\n      else {\n        i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n        i2c_handle->PreviousState = 0x11;\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2c_handle);\n      }\n    }\n    else {\n      bufferPointer = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = bufferPointer + 1;\n      i2c_handle->Instance->DR = (uint)*bufferPointer;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002efc": "i2c_handle_transmission_08002efc",
                "hi2c": "i2c_handle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9a": {
            "entrypoint": "0x08002f9a",
            "current_name": "FUNC_08002f9a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f9a": "FUNC_08002f9a"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9c": {
            "entrypoint": "0x08002f9c",
            "current_name": "handle_i2_c_rx_transfer_08002f9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CRxTransfer_08002f9c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *dataPointer;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2cHandle->XferCount < 4) {\n      if (i2cHandle->XferCount - 2 < 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        dataPointer = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPointer + 1;\n        *dataPointer = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2cHandle);\n        }\n      }\n    }\n    else {\n      dataPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPointer + 1;\n      *dataPointer = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f9c": "handle_i2_c_rx_transfer_08002f9c",
                "hi2c": "i2cHandle",
                "puVar1": "dataPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "process_i2_c_data_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CData_0800306c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->XferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    }\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  else if (i2cHandle->XferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n      }\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n    }\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->PreviousState = 0;\n    if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "process_i2_c_data_0800306c",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "bufferPtr",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316a": {
            "entrypoint": "0x0800316a",
            "current_name": "FUNC_0800316a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316a": "FUNC_0800316a"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "handle_i2_c_state_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_0800316c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_Status HVar1;\n  uint8_t *dataPtr;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == I2C_STATE_ABORT) {\n      i2cHandle->State = I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      i2cAbortCompleteCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      HVar1 = dmaAbortIT(i2cHandle->hdmarx);\n      if (HVar1 != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          dataPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPtr + 1;\n          *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      HVar1 = dmaAbortIT(i2cHandle->hdmatx);\n      if (HVar1 != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = I2C_STATE_READY;\n    i2cHandle->Mode = I2C_MODE_NONE;\n    i2cListenCompleteCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "handle_i2_c_state_0800316c",
                "hi2c": "i2cHandle",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "puVar2": "dataPtr",
                "pIVar3": "i2cInstance",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "HAL_I2C_STATE_ABORT": "I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_AbortCpltCallback": "i2cAbortCompleteCallback",
                "HAL_I2C_ErrorCallback": "i2cErrorCallback",
                "HAL_DMA_STATE_READY": "DMA_STATE_READY",
                "HAL_DMA_Abort_IT": "dmaAbortIT",
                "HAL_I2C_ListenCpltCallback": "i2cListenCompleteCallback"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032b4": {
            "entrypoint": "0x080032b4",
            "current_name": "process_i2_c_data_080032b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_080032b4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *bufferPtr;\n  uint32_t currentState;\n  uint32_t tempRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080032b4": "process_i2_c_data_080032b4",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "bufferPtr",
                "CurrentState": "currentState",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033b8": {
            "entrypoint": "0x080033b8",
            "current_name": "handle_i2_c_interrupt_080033b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_080033b8(I2C_HandleTypeDef *I2CHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint statusRegister1;\n  uint32_t statusRegister1_ITFlags;\n  uint controlRegister2;\n  uint32_t ITSources;\n  uint statusRegister2;\n  uint32_t statusRegister2_ITFlags;\n  \n  i2cInstance = I2CHandle->Instance;\n  statusRegister2 = i2cInstance->SR2;\n  statusRegister1 = i2cInstance->SR1;\n  controlRegister2 = i2cInstance->CR2;\n  if ((I2CHandle->Mode == HAL_I2C_MODE_MASTER) || (I2CHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusRegister1 & 0x10001) == 0) || ((controlRegister2 & 0x200) == 0)) {\n      if (((statusRegister1 & 0x10008) == 0) || ((controlRegister2 & 0x200) == 0)) {\n        if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n          I2C_Master_ADDR(I2CHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(I2CHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(I2CHandle);\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(I2CHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(I2CHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(I2CHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(I2CHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(I2CHandle);\n      return;\n    }\n    if (((statusRegister1 & 0x10010) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(I2CHandle);\n      return;\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(I2CHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(I2CHandle);\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(I2CHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(I2CHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033b8": "handle_i2_c_interrupt_080033b8",
                "hi2c": "I2CHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusRegister1",
                "sr1itflags": "statusRegister1_ITFlags",
                "uVar3": "controlRegister2",
                "itsources": "ITSources",
                "uVar4": "statusRegister2",
                "sr2itflags": "statusRegister2_ITFlags"
            },
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003520": {
            "entrypoint": "0x08003520",
            "current_name": "handle_i2_c_interrupts_08003520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C_interrupts_08003520(I2C_HandleTypeDef *i2c_handle)\n\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  I2C_TypeDef *i2c_instance;\n  uint32_t SR1_flags;\n  uint SR1_value;\n  uint32_t CR2_value;\n  uint CR2_flags;\n  \n  i2c_instance = i2c_handle->Instance;\n  SR1_value = i2c_instance->SR1;\n  CR2_flags = i2c_instance->CR2;\n  if (((SR1_value & 0x10100) != 0) && ((CR2_flags & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 1;\n    i2c_instance->SR1 = 0xfffffeff;\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x8000;\n  }\n  if (((SR1_value & 0x10200) != 0) && ((CR2_flags & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 2;\n    i2c_handle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((SR1_value & 0x10400) != 0) && ((CR2_flags & 0x100) != 0)) {\n    i2c_state = i2c_handle->State;\n    if (((i2c_handle->Mode == HAL_I2C_MODE_SLAVE) && (i2c_handle->XferCount == 0)) &&\n       (((i2c_state == HAL_I2C_STATE_BUSY_TX || (i2c_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2c_state == HAL_I2C_STATE_LISTEN && (i2c_handle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2c_handle);\n    }\n    else {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 4;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      }\n      i2c_handle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((SR1_value & 0x10800) != 0) && ((CR2_flags & 0x100) != 0)) {\n    i2c_handle->ErrorCode = i2c_handle->ErrorCode | 8;\n    i2c_handle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2c_handle->ErrorCode != 0) {\n    I2C_ITError(i2c_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003520": "handle_i2_c_interrupts_08003520",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "pIVar2": "i2c_instance",
                "sr1itflags": "SR1_flags",
                "uVar3": "SR1_value",
                "itsources": "CR2_value",
                "uVar4": "CR2_flags"
            },
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "reset_i2_c_state_080035fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CState_080035fc(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *parentI2C;\n  I2C_HandleTypeDef *currentI2C;\n  \n  parentI2C = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  parentI2C->Instance->CR1 = parentI2C->Instance->CR1 & 0xfffffbff;\n  parentI2C->XferCount = 0;\n  parentI2C->dmaHandletx->XferAbortCallback = (CallbackFunctionPointer *)0x0;\n  parentI2C->dmaHandlerx->XferAbortCallback = (CallbackFunctionPointer *)0x0;\n  if (parentI2C->State != I2CStateAbort) {\n    parentI2C->State = I2CStateReady;\n    parentI2C->Mode = I2CModeNone;\n    parentI2C->Instance->CR1 = parentI2C->Instance->CR1 & 0xfffffffe;\n    handleI2CError(parentI2C);\n    return;\n  }\n  parentI2C->State = I2CStateReady;\n  parentI2C->Mode = I2CModeNone;\n  parentI2C->ErrorCode = 0;\n  parentI2C->Instance->CR1 = parentI2C->Instance->CR1 & 0xfffffffe;\n  completeI2CAbortion(parentI2C);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "reset_i2_c_state_080035fc",
                "hdma": "dmaHandle",
                "hi2c_00": "parentI2C",
                "hi2c": "currentI2C",
                "_func_void___DMA_HandleTypeDef_ptr": "CallbackFunctionPointer",
                "HAL_I2C_STATE_ABORT": "I2CStateAbort",
                "HAL_I2C_STATE_READY": "I2CStateReady",
                "HAL_I2C_MODE_NONE": "I2CModeNone",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "completeI2CAbortion"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800365c": {
            "entrypoint": "0x0800365c",
            "current_name": "delay_function_0800365c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayFunction_0800365c(uint32_t milliseconds)\n\n{\n  bool isDelayNotZero;\n  uint32_t totalDelay;\n  \n  totalDelay = milliseconds * (SystemCoreClock / 8000);\n  do {\n    isDelayNotZero = totalDelay != 0;\n    totalDelay = totalDelay - 1;\n  } while (isDelayNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800365c": "delay_function_0800365c",
                "mdelay": "milliseconds",
                "Delay": "totalDelay",
                "bVar1": "isDelayNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003688": {
            "entrypoint": "0x08003688",
            "current_name": "initialize_clocks_08003688",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeClocks_08003688(RCC_OscInitTypeDef_conflict *clockInit)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t startTick;\n  bool isSet;\n  uint32_t tempRegister;\n  \n  if ((clockInit->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (clockInit->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      startTick = clockInit->HSEState;\n      if (startTick == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (startTick == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (startTick == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (clockInit->HSEState == 0) {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((clockInit->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (clockInit->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | clockInit->HSICalibrationValue << 3;\n    }\n    else if (clockInit->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | clockInit->HSICalibrationValue << 3;\n    }\n  }\n  if ((clockInit->OscillatorType & 8) != 0) {\n    if (clockInit->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((clockInit->OscillatorType & 4) != 0) {\n    isSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    startTick = clockInit->LSEState;\n    if (startTick == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (startTick == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (startTick == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (clockInit->LSEState == 0) {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  startTick = (clockInit->PLL).PLLState;\n  if (startTick == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (startTick == 2) {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((clockInit->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | clockInit->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (clockInit->PLL).PLLSource | (clockInit->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        startTick = HAL_GetTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTick = HAL_GetTick();\n        } while (currentTick - startTick < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003688": "initialize_clocks_08003688",
                "RCC_OscInitStruct": "clockInit",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HVar1": "status",
                "uVar2": "currentTick",
                "uVar3": "startTick",
                "bVar4": "isSet",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a68": {
            "entrypoint": "0x08003a68",
            "current_name": "calculate_system_clock_08003a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSystemClock_08003a68(void)\n\n{\n  uint32_t systemClock;\n  uint8_t predivFactorTable [2];\n  uint8_t pllmulFactorTable [16];\n  \n  pllmulFactorTable[12] = '\\x0e';\n  pllmulFactorTable[13] = '\\x0f';\n  pllmulFactorTable[14] = '\\x10';\n  pllmulFactorTable[15] = '\\x10';\n  pllmulFactorTable[8] = '\\n';\n  pllmulFactorTable[9] = '\\v';\n  pllmulFactorTable[10] = '\\f';\n  pllmulFactorTable[11] = '\\r';\n  pllmulFactorTable[4] = '\\x06';\n  pllmulFactorTable[5] = '\\a';\n  pllmulFactorTable[6] = '\\b';\n  pllmulFactorTable[7] = '\\t';\n  pllmulFactorTable[0] = '\\x02';\n  pllmulFactorTable[1] = '\\x03';\n  pllmulFactorTable[2] = '\\x04';\n  pllmulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      systemClock = (uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      systemClock = ((uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    systemClock = 8000000;\n  }\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08003a68": "calculate_system_clock_08003a68",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllmulFactorTable",
                "uVar1": "systemClock"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ad4": {
            "entrypoint": "0x08003ad4",
            "current_name": "configure_clock_08003ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureClock_08003ad4(clockConfig *initStruct,uint32_t flashLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 & 7) < flashLatency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return ERROR;\n    }\n  }\n  if ((initStruct->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | initStruct->AHBCLKDivider;\n  }\n  if ((initStruct->ClockType & 1) != 0) {\n    uVar3 = initStruct->SYSCLKSource;\n    if (uVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return ERROR;\n      }\n    }\n    else if ((uVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return ERROR;\n    }\n    _DAT_40021004 = uVar3 | _DAT_40021004 & 0xfffffffc;\n    uVar1 = getTick();\n    if (initStruct->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return TIMEOUT;\n        }\n      }\n    }\n    else if (initStruct->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return TIMEOUT;\n        }\n      }\n    }\n  }\n  if (flashLatency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return ERROR;\n    }\n  }\n  if ((initStruct->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | initStruct->APB1CLKDivider;\n  }\n  if ((initStruct->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | initStruct->APB2CLKDivider << 3;\n  }\n  uVar1 = getSysClockFreq();\n  coreClock = uVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  initTick(0xf);\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08003ad4": "configure_clock_08003ad4",
                "RCC_ClkInitTypeDef_conflict": "clockConfig",
                "FLatency": "flashLatency",
                "RCC_ClkInitStruct": "initStruct",
                "HAL_ERROR": "ERROR",
                "HAL_GetTick": "getTick",
                "HAL_TIMEOUT": "TIMEOUT",
                "SystemCoreClock": "coreClock",
                "HAL_RCC_GetSysClockFreq": "getSysClockFreq",
                "HAL_InitTick": "initTick",
                "HAL_OK": "OK"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c44": {
            "entrypoint": "0x08003c44",
            "current_name": "get_system_core_clock_08003c44",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003c44(void)\n\n{\n  return coreClock;\n}\n\n",
            "renaming": {
                "FUN_08003c44": "get_system_core_clock_08003c44",
                "SystemCoreClock": "coreClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c50": {
            "entrypoint": "0x08003c50",
            "current_name": "get_hclk_frequency_08003c50",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_08003c50(void)\n\n{\n  uint32_t frequency;\n  \n  frequency = HAL_RCC_GetHCLKFreq();\n  return frequency >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c50": "get_hclk_frequency_08003c50",
                "uVar1": "frequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c70": {
            "entrypoint": "0x08003c70",
            "current_name": "get_hclk_frequency_08003c70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_08003c70(void)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = getHCLKFreq();\n  return hclkFrequency >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c70": "get_hclk_frequency_08003c70",
                "uVar1": "hclkFrequency",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c90": {
            "entrypoint": "0x08003c90",
            "current_name": "configure_periph_clocks_08003c90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphClocks_08003c90(RCC_PeriphCLKInitTypeDef_conflict *peripheralClockInit)\n\n{\n  uint bitMask1;\n  uint bitMask2;\n  uint32_t startTime;\n  uint32_t currentTime;\n  bool bitFlag;\n  uint32_t temporaryRegister;\n  \n  if ((peripheralClockInit->PeriphClockSelection & 1) != 0) {\n    bitFlag = (_DAT_4002101c & 0x10000000) == 0;\n    if (bitFlag) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (peripheralClockInit->RTCClockSelection & 0x300))) {\n      bitMask2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      bitMask1 = _DAT_40021020 & 1;\n      _DAT_40021020 = bitMask2;\n      if (bitMask1 != 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          currentTime = HAL_GetTick();\n          if (5000 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | peripheralClockInit->RTCClockSelection;\n    if (bitFlag) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | peripheralClockInit->AdcClockSelection;\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | peripheralClockInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003c90": "configure_periph_clocks_08003c90",
                "PeriphClkInit": "peripheralClockInit",
                "uVar1": "bitMask1",
                "uVar2": "bitMask2",
                "uVar3": "startTime",
                "uVar4": "currentTime",
                "bVar5": "bitFlag",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003da4": {
            "entrypoint": "0x08003da4",
            "current_name": "calculate_clock_frequency_08003da4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003da4(uint32_t peripheralClockSource)\n\n{\n  uint32_t clockFrequency;\n  uint tempFrequency;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (peripheralClockSource == 2) {\n    clockFrequency = HAL_RCC_GetPCLK2Freq();\n    clockFrequency = clockFrequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheralClockSource == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      clockFrequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        tempFrequency = 4000000;\n      }\n      else {\n        tempFrequency = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      clockFrequency = tempFrequency * pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        clockFrequency = (clockFrequency * 2) / 3;\n      }\n    }\n  }\n  else if (peripheralClockSource == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      clockFrequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      clockFrequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        clockFrequency = 0;\n      }\n      else {\n        clockFrequency = 0xf424;\n      }\n    }\n    else {\n      clockFrequency = 0;\n    }\n  }\n  else {\n    clockFrequency = 0;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08003da4": "calculate_clock_frequency_08003da4",
                "PeriphClk": "peripheralClockSource",
                "uVar1": "clockFrequency",
                "uVar2": "tempFrequency",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ea0": {
            "entrypoint": "0x08003ea0",
            "current_name": "handle_rtc_alarm_08003ea0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_RTC_Alarm_08003ea0(RTC_HandleTypeDef *RTC_handler)\n\n{\n  if (((RTC_handler->RTC_instance->control_register_high & 2) != 0) && ((RTC_handler->RTC_instance->control_register_low & 2) != 0)) {\n    HAL_RTC_AlarmAEventCallback(RTC_handler);\n    RTC_handler->RTC_instance->control_register_low = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  RTC_handler->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ea0": "handle_rtc_alarm_08003ea0",
                "hrtc": "RTC_handler",
                "Instance": "RTC_instance",
                "CRH": "control_register_high",
                "CRL": "control_register_low"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ed8": {
            "entrypoint": "0x08003ed8",
            "current_name": "reset_tim_08003ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetTim_08003ed8(TIM_HandleTypeDef *timer)\n\n{\n  TimType *timInstance;\n  \n  timer->State = busyState;\n  timInstance = timer->Instance;\n  if (((timInstance->captureCompareEnableReg & 0x1111) == 0) && ((timInstance->captureCompareEnableReg & 0x444) == 0)) {\n    timInstance->controlReg1 = timInstance->controlReg1 & 0xfffffffe;\n  }\n  deInitializePWM(timer);\n  timer->State = resetState;\n  timer->Lock = unlockedState;\n  return okStatus;\n}\n\n",
            "renaming": {
                "FUN_08003ed8": "reset_tim_08003ed8",
                "htim": "timer",
                "HAL_TIM_STATE_BUSY": "busyState",
                "TIM_TypeDef": "TimType",
                "pTVar1": "timInstance",
                "CCER": "captureCompareEnableReg",
                "CR1": "controlReg1",
                "HAL_TIM_PWM_MspDeInit": "deInitializePWM",
                "HAL_TIM_STATE_RESET": "resetState",
                "HAL_UNLOCKED": "unlockedState",
                "HAL_OK": "okStatus"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f12": {
            "entrypoint": "0x08003f12",
            "current_name": "FUNC_08003f12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f12": "FUNC_08003f12"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f14": {
            "entrypoint": "0x08003f14",
            "current_name": "FUNC_08003f14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f14": "FUNC_08003f14"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f16": {
            "entrypoint": "0x08003f16",
            "current_name": "FUNC_08003f16",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f16": "FUNC_08003f16"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "handle_interrupt_08003f18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupt_08003f18(TIM_HandleTypeDef *timer)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timer->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timer->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timer->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timer->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timer);\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timer);\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timer);\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "handle_interrupt_08003f18",
                "htim": "timer",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler",
                "TIM4_IRQHandler",
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004092": {
            "entrypoint": "0x08004092",
            "current_name": "configure_channel_state_08004092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureChannelState_08004092(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | state << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004092": "configure_channel_state_08004092",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b0": {
            "entrypoint": "0x080040b0",
            "current_name": "deactivate_timer_channel_080040b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict deactivateTimerChannel_080040b0(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,0);\n  if (((timerHandle->Instance == (TIM_TypeDef *)0x40012c00) && ((timerRegister1 & 0x1111) == 0)) &&\n     ((timerRegister1 & 0x444) == 0)) {\n    timerRegister2 = timerRegister2 & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080040b0": "deactivate_timer_channel_080040b0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "uRam40012c20": "timerRegister1",
                "uRam40012c44": "timerRegister2"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_channel_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureChannel_08004110(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_channel_08004110",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channelState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800412c": {
            "entrypoint": "0x0800412c",
            "current_name": "configure_tim_channel_0800412c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configure_TIM_Channel_0800412c(TIM_HandleTypeDef *tim_handle,uint32_t channel)\n\n{\n  TIM_TypeDef *tim_instance;\n  \n  TIM_CCxNchannelCmd(tim_handle->Instance,channel,0);\n  tim_instance = tim_handle->Instance;\n  if (((tim_instance->CCER & 0x1111) == 0) && ((tim_instance->CCER & 0x444) == 0)) {\n    tim_instance->BDTR = tim_instance->BDTR & 0xffff7fff;\n  }\n  tim_instance = tim_handle->Instance;\n  if (((tim_instance->CCER & 0x1111) == 0) && ((tim_instance->CCER & 0x444) == 0)) {\n    tim_instance->CR1 = tim_instance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800412c": "configure_tim_channel_0800412c",
                "htim": "tim_handle",
                "Channel": "channel",
                "pTVar1": "tim_instance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004178": {
            "entrypoint": "0x08004178",
            "current_name": "FUNC_08004178",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004178": "FUNC_08004178"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417a": {
            "entrypoint": "0x0800417a",
            "current_name": "FUNC_0800417a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417a": "FUNC_0800417a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417c": {
            "entrypoint": "0x0800417c",
            "current_name": "reset_uart_instance_0800417c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_instance_0800417c(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register1 = uart_handle->uart_instance->control_register1 & 0xfffffedf;\n  uart_handle->uart_instance->control_register3 = uart_handle->uart_instance->control_register3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417c": "reset_uart_instance_0800417c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register1",
                "CR3": "control_register3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004198": {
            "entrypoint": "0x08004198",
            "current_name": "send_data_08004198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict sendData_08004198(UART_HandleTypeDef *huart)\n\n{\n  uint16_t transferCount;\n  byte *pbVar2;\n  uint16_t *tmp;\n  \n  if (huart->gState != UART_STATE_BUSY_TX) {\n    return BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    huart->Instance->DR = *(ushort *)huart->pTxBuffPtr & 0x1ff;\n    if ((huart->Init).Parity == 0) {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 2;\n    }\n    else {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 = huart->pTxBuffPtr;\n    huart->pTxBuffPtr = pbVar2 + 1;\n    huart->Instance->DR = (uint)*pbVar2;\n  }\n  transferCount = huart->TxXferCount - 1;\n  huart->TxXferCount = transferCount;\n  if (transferCount == 0) {\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffff7f;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x40;\n    return OK;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08004198": "send_data_08004198",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_BUSY_TX",
                "HAL_BUSY": "BUSY",
                "uVar1": "transferCount",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "initialize_uart_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08004204(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uint32_t pclkFreq4;\n  uint32_t pclkFreq5;\n  uint32_t baudRate1;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  USART *currentUSART;\n  \n  uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffcfff | (uartHandle->Init).StopBits;\n  uartHandle->Instance->CR1 =\n       (uartHandle->Init).WordLength | (uartHandle->Init).Parity | (uartHandle->Init).Mode |\n       uartHandle->Instance->CR1 & 0xffffe9f3;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffcff | (uartHandle->Init).HwFlowCtl;\n  currentUSART = uartHandle->Instance;\n  if (currentUSART != (USART *)0x40013800) {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    baudRate1 = (uartHandle->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (uartHandle->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (uartHandle->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (uartHandle->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n    currentUSART->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n    return;\n  }\n  pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n  baudRate1 = (uartHandle->Init).BaudRate;\n  pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n  baudRate2 = (uartHandle->Init).BaudRate;\n  pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n  baudRate3 = (uartHandle->Init).BaudRate;\n  pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n  baudRate4 = (uartHandle->Init).BaudRate;\n  pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                      (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                   (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "initialize_uart_08004204",
                "huart": "uartHandle",
                "USART_TypeDef": "USART",
                "pUVar10": "currentUSART",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3",
                "uVar4": "pclkFreq4",
                "uVar5": "pclkFreq5",
                "uVar6": "baudRate1",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043b4": {
            "entrypoint": "0x080043b4",
            "current_name": "check_flag_status_080043b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_desiredStatusTypeDef_conflict\ncheckFlagStatus_080043b4(UART_HandleTypeDef *uartHandle,uint32_t flag,flagdesiredStatus desiredStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flag & ~uartHandle->Instance->SR) == 0) != (bool)desiredStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080043b4": "check_flag_status_080043b4",
                "huart": "uartHandle",
                "Flag": "flag",
                "Status": "desiredStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004418": {
            "entrypoint": "0x08004418",
            "current_name": "FUNC_08004418",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004418": "FUNC_08004418"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800441a": {
            "entrypoint": "0x0800441a",
            "current_name": "initialize_uart_0800441a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus_conflict initializeUART_0800441a(UART_HandleTypeDef *uartHandler)\n\n{\n  if (uartHandler != (UART_HandleTypeDef *)0x0) {\n    if (uartHandler->globalState == UART_STATE_RESET) {\n      uartHandler->lockStatus = UNLOCKED;\n      configureUART(uartHandler);\n    }\n    uartHandler->globalState = UART_STATE_BUSY;\n    uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 & 0xffffdfff;\n    setUARTConfig(uartHandler);\n    uartHandler->uartInstance->controlRegister2 = uartHandler->uartInstance->controlRegister2 & 0xffffb7ff;\n    uartHandler->uartInstance->controlRegister3 = uartHandler->uartInstance->controlRegister3 & 0xffffffd5;\n    uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 | 0x2000;\n    uartHandler->errorStatus = 0;\n    uartHandler->globalState = UART_STATE_READY;\n    uartHandler->receiveState = UART_STATE_READY;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800441a": "initialize_uart_0800441a",
                "huart": "uartHandler",
                "gState": "globalState",
                "Lock": "lockStatus",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "CR3": "controlRegister3",
                "ErrorCode": "errorStatus",
                "RxState": "receiveState",
                "HAL_StatusTypeDef": "Status",
                "HAL_UART_STATE_RESET": "UART_STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_UART_MspInit": "configureUART",
                "UART_SetConfig": "setUARTConfig",
                "HAL_UART_STATE_BUSY": "UART_STATE_BUSY",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004478": {
            "entrypoint": "0x08004478",
            "current_name": "transmit_data_08004478",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ntransmitData_08004478(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tickStart;\n  uint16_t *temporary;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uartHandle->TxXferdataSize = dataSize;\n      uartHandle->TxXferCount = dataSize;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)dataBuffer & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 2);\n          }\n          else {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*dataBuffer;\n          dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004478": "transmit_data_08004478",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "tmp": "temporary"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800455a": {
            "entrypoint": "0x0800455a",
            "current_name": "initialize_uar_transmission_0800455a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUARTransmission_0800455a(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800455a": "initialize_uar_transmission_0800455a",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size"
            },
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045a2": {
            "entrypoint": "0x080045a2",
            "current_name": "configure_uart_080045a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureUART_080045a2(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t bufferSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = dataBuffer;\n    uartHandle->RxXferbufferSize = bufferSize;\n    uartHandle->RxXferCount = bufferSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x100;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080045a2": "configure_uart_080045a2",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045fe": {
            "entrypoint": "0x080045fe",
            "current_name": "initialize_uart_080045fe",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_UART_080045fe(UART_HandleTypeDef *uart_handler)\n\n{\n  uart_handler->uart_instance->control_register_1 = uart_handler->uart_instance->control_register_1 & 0xffffffbf;\n  uart_handler->uart_state = HAL_UART_STATE_READY;\n  handle_uart_transmission_complete(uart_handler);\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_080045fe": "initialize_uart_080045fe",
                "huart": "uart_handler",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "gState": "uart_state",
                "HAL_UART_TxCpltCallback": "handle_uart_transmission_complete",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004618": {
            "entrypoint": "0x08004618",
            "current_name": "receive_data_08004618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict receiveData_08004618(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *tmp;\n  byte *bufferPtr2;\n  uint16_t remainingCount;\n  uint8_t *bufferPtr1;\n  \n  if (uartHandle->uartRxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->uartInit).uartWordLength == 0x1000) {\n    if ((uartHandle->uartInit).uartParity == 0) {\n      *(ushort *)uartHandle->receiveBufferPointer = (ushort)((uartHandle->uartInstance->dataRegister << 0x17) >> 0x17);\n      uartHandle->receiveBufferPointer = uartHandle->receiveBufferPointer + 2;\n    }\n    else {\n      *(ushort *)uartHandle->receiveBufferPointer = (ushort)uartHandle->uartInstance->dataRegister & 0xff;\n      uartHandle->receiveBufferPointer = uartHandle->receiveBufferPointer + 1;\n    }\n  }\n  else if ((uartHandle->uartInit).uartParity == 0) {\n    bufferPtr1 = uartHandle->receiveBufferPointer;\n    uartHandle->receiveBufferPointer = bufferPtr1 + 1;\n    *bufferPtr1 = (uint8_t)uartHandle->uartInstance->dataRegister;\n  }\n  else {\n    bufferPtr2 = uartHandle->receiveBufferPointer;\n    uartHandle->receiveBufferPointer = bufferPtr2 + 1;\n    *bufferPtr2 = (byte)uartHandle->uartInstance->dataRegister & 0x7f;\n  }\n  remainingCount = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = remainingCount;\n  if (remainingCount != 0) {\n    return HAL_OK;\n  }\n  uartHandle->uartInstance->CR1 = uartHandle->uartInstance->CR1 & 0xffffffdf;\n  uartHandle->uartInstance->CR1 = uartHandle->uartInstance->CR1 & 0xfffffeff;\n  uartHandle->uartInstance->CR3 = uartHandle->uartInstance->CR3 & 0xfffffffe;\n  uartHandle->uartRxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004618": "receive_data_08004618",
                "huart": "uartHandle",
                "RxState": "uartRxState",
                "Init": "uartInit",
                "WordLength": "uartWordLength",
                "Parity": "uartParity",
                "pRxBuffPtr": "receiveBufferPointer",
                "Instance": "uartInstance",
                "DR": "dataRegister",
                "puVar3": "bufferPtr1",
                "pbVar1": "bufferPtr2",
                "uVar2": "remainingCount"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b8": {
            "entrypoint": "0x080046b8",
            "current_name": "handle_uart_interrupts_080046b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupts_080046b8(UART_HandleTypeDef *UART_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint CR1_bits;\n  uint32_t CR1_Interrupts;\n  USART_TypeDef *UART_instance;\n  uint32_t CR3_Interrupts;\n  uint CR3_bit;\n  uint SR_bits;\n  uint32_t ISR_flags;\n  \n  UART_instance = UART_handle->Instance;\n  SR_bits = UART_instance->SR;\n  CR1_bits = UART_instance->CR1;\n  if ((((SR_bits & 0xf) == 0) && ((SR_bits & 0x20) != 0)) && ((CR1_bits & 0x20) != 0)) {\n    UART_Receive_IT(UART_handle);\n    return;\n  }\n  if (((SR_bits & 0xf) == 0) || ((CR3_bit = UART_instance->CR3 & 1, CR3_bit == 0 && ((CR1_bits & 0x120) == 0)))) {\n    if (((SR_bits & 0x80) != 0) && ((CR1_bits & 0x80) != 0)) {\n      UART_Transmit_IT(UART_handle);\n      return;\n    }\n    if (((SR_bits & 0x40) != 0) && ((CR1_bits & 0x40) != 0)) {\n      UART_EndTransmit_IT(UART_handle);\n    }\n  }\n  else {\n    if (((SR_bits & 1) != 0) && ((CR1_bits & 0x100) != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 1;\n    }\n    if (((SR_bits & 4) != 0) && (CR3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 2;\n    }\n    if (((SR_bits & 2) != 0) && (CR3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 4;\n    }\n    if (((SR_bits & 8) != 0) && (CR3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 8;\n    }\n    if (UART_handle->ErrorCode != 0) {\n      if (((SR_bits & 0x20) != 0) && ((CR1_bits & 0x20) != 0)) {\n        UART_Receive_IT(UART_handle);\n      }\n      if (((UART_handle->ErrorCode & 8) == 0) && ((UART_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UART_handle);\n        UART_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(UART_handle);\n      UART_instance = UART_handle->Instance;\n      if ((UART_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_instance->CR3 = UART_instance->CR3 & 0xffffffbf;\n      if (UART_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(UART_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*UART_handle->hdmarx->XferAbortCallback)(UART_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b8": "handle_uart_interrupts_080046b8",
                "huart": "UART_handle",
                "HVar1": "status",
                "uVar2": "CR1_bits",
                "uVar4": "CR3_bit",
                "uVar5": "SR_bits",
                "cr1its": "CR1_Interrupts",
                "cr3its": "CR3_Interrupts",
                "isrflags": "ISR_flags",
                "pUVar3": "UART_instance"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d8": {
            "entrypoint": "0x080047d8",
            "current_name": "reset_uart_080047d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUART_080047d8(DMA_HandleTypeDef *dmaHandle)\n\n{\n  UART_HandleTypeDef *uartHandleParent;\n  UART_HandleTypeDef *uartHandle;\n  \n  uartHandleParent = (UART_HandleTypeDef *)dmaHandle->Parent;\n  uartHandleParent->RxXferCount = 0;\n  uartHandleParent->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uartHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d8": "reset_uart_080047d8",
                "hdma": "dmaHandle",
                "huart_00": "uartHandleParent",
                "huart": "uartHandle"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047e8": {
            "entrypoint": "0x080047e8",
            "current_name": "get_uart_states_080047e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef get_uart_states_080047e8(UART_HandleTypeDef *uart_handle)\n\n{\n  return uart_handle->receive_state | uart_handle->global_state;\n}\n\n",
            "renaming": {
                "FUN_080047e8": "get_uart_states_080047e8",
                "huart": "uart_handle",
                "RxState": "receive_state",
                "gState": "global_state"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "check_pin_value_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinValue_080047f4(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_080047f4": "check_pin_value_080047f4",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800480a": {
            "entrypoint": "0x0800480a",
            "current_name": "update_pin_mapping_0800480a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMapping_0800480a(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedPinIndex;\n  uint32_t index;\n  \n  shiftedPinIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedPinIndex] = pinMap[shiftedPinIndex] | 1 << ((int)pinName & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800480a": "update_pin_mapping_0800480a",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedPinIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004828": {
            "entrypoint": "0x08004828",
            "current_name": "clear_bit_in_map_08004828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearBitInMap_08004828(PinName_conflict pinName,uint32_t *mapPtr)\n\n{\n  uint shiftedIndex;\n  uint32_t index;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  mapPtr[shiftedIndex] = mapPtr[shiftedIndex] & ~(1 << ((int)pinName & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004828": "clear_bit_in_map_08004828",
                "pin": "pinName",
                "map": "mapPtr",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004848": {
            "entrypoint": "0x08004848",
            "current_name": "get_gpio_type_def_08004848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * getGPIOTypeDef_08004848(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIOType *)0x40010800;\n  case 1:\n    return (GPIOType *)0x40010c00;\n  case 2:\n    return (GPIOType *)0x40011000;\n  case 3:\n    return (GPIOType *)0x40011400;\n  case 4:\n    return (GPIOType *)0x40011800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08004848": "get_gpio_type_def_08004848",
                "port_idx": "portIndex",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "get_gpio_08004884",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIO_08004884(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *GPIO_Structure;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    GPIO_Structure = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    GPIO_Structure = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    GPIO_Structure = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    GPIO_Structure = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    GPIO_Structure = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    GPIO_Structure = (GPIO_TypeDef *)0x0;\n  }\n  return GPIO_Structure;\n}\n\n",
            "renaming": {
                "FUN_08004884": "get_gpio_08004884",
                "port_idx": "portIndex",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4",
                "pGVar1": "GPIO_Structure"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800492c": {
            "entrypoint": "0x0800492c",
            "current_name": "get_adc_function_0800492c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_function_0800492c(PinName_conflict pin_name)\n\n{\n  uint32_t mapped_function;\n  uint32_t adjusted_value;\n  \n  mapped_function = pin_namemap_adjusted_value(pin_name,(PinMap_conflict *)&PinMap_ADC);\n  adjusted_value = mapped_function << 0xc;\n  adjusted_value = adjusted_value >> 0x1b;\n  if (0x10 < adjusted_value - 1) {\n    adjusted_value = 0;\n  }\n  return adjusted_value;\n}\n\n",
            "renaming": {
                "FUN_0800492c": "get_adc_function_0800492c",
                "pin": "pin_name",
                "uVar1": "mapped_function",
                "function": "adjusted_value"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004948": {
            "entrypoint": "0x08004948",
            "current_name": "map_pin_to_function_08004948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t mapPinToFunction_08004948(PinName_conflict pin)\n\n{\n  uint32_t mappedFunction;\n  uint32_t shiftedFunction;\n  \n  mappedFunction = pinmap_shiftedFunction(pin,(PinMap_conflict *)&PinMap_PWM);\n  shiftedFunction = mappedFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction == 3) {\n    return 8;\n  }\n  if (shiftedFunction != 4) {\n    if (shiftedFunction != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08004948": "map_pin_to_function_08004948",
                "uVar1": "mappedFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004974": {
            "entrypoint": "0x08004974",
            "current_name": "initialize_adc_08004974",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeADC_08004974(ADC_HandleTypeDef *adcHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t tempRegister;\n  uint32_t tempRegister_1;\n  GPIO_InitTypeDef gpioInitConfig;\n  \n  if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  gpioPort = set_GPIO_Port_Clock((uint)((int)currentPin << 0x18) >> 0x1c);\n  gpioInitConfig.Pin = 1 << (currentPin & 0xfU) & 0xffff;\n  gpioInitConfig.Mode = 3;\n  gpioInitConfig.Pull = 0;\n  HAL_GPIO_Init(gpioPort,&gpioInitConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004974": "initialize_adc_08004974",
                "hadc": "adcHandle",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister_1",
                "GPIO_InitStruct": "gpioInitConfig",
                "g_current_pin": "currentPin"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049f0": {
            "entrypoint": "0x080049f0",
            "current_name": "set_adc_instance_080049f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setAdcInstance_080049f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  if (adcHandle->adcInstance != (ADC_TypeDef *)0x40012400) {\n    if (adcHandle->adcInstance == (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049f0": "set_adc_instance_080049f0",
                "hadc": "adcHandle",
                "Instance": "adcInstance"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a4c": {
            "entrypoint": "0x08004a4c",
            "current_name": "get_adc_converted_value_08004a4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t getADCConvertedValue_08004a4c(pin pin)\n\n{\n  status HVar1;\n  uint32_t uVar2;\n  uint16_t convertedValue;\n  ADCChannelConf AdcChannelConf;\n  ADCStruct adcHandle;\n  \n  memset(&adcHandle,0,0x30);\n  AdcChannelConf.Channel = 0;\n  AdcChannelConf.Rank = 0;\n  AdcChannelConf.SamplingTime = 0;\n  convertedValue = 0;\n  adcHandle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_ADC);\n  if (adcHandle.Instance == (ADC_TypeDef *)0x0) {\n    convertedValue = 0;\n  }\n  else {\n    adcHandle.Init.DataAlign = 0;\n    adcHandle.Init.ScanConvMode = 0;\n    adcHandle.Init.ContinuousConvMode = 0;\n    adcHandle.Init.DiscontinuousConvMode = 0;\n    adcHandle.Init.ExternalTrigConv = 0xe0000;\n    adcHandle.State = 0;\n    adcHandle.Init.NbrOfConversion = 1;\n    adcHandle.Init.NbrOfDiscConversion = 0;\n    g_current_pin = pin;\n    HVar1 = initADC(&adcHandle);\n    if (HVar1 == HAL_OK) {\n      AdcChannelConf.Channel = getADCChannel(pin);\n      if (AdcChannelConf.Channel < 0x12) {\n        AdcChannelConf.Rank = 1;\n        AdcChannelConf.SamplingTime = 2;\n        HVar1 = configADCChannel(&adcHandle,&AdcChannelConf);\n        if (HVar1 == HAL_OK) {\n          HVar1 = startADCCalibration(&adcHandle);\n          if (HVar1 == HAL_OK) {\n            HVar1 = startADC(&adcHandle);\n            if (HVar1 == HAL_OK) {\n              HVar1 = pollForADCConversion(&adcHandle,10);\n              if (HVar1 == HAL_OK) {\n                uVar2 = getADCState(&adcHandle);\n                if ((uVar2 & 0x200) != 0) {\n                  uVar2 = getADCValue(&adcHandle);\n                  convertedValue = (uint16_t)uVar2;\n                }\n                HVar1 = stopADC(&adcHandle);\n                if (HVar1 == HAL_OK) {\n                  HVar1 = deInitADC(&adcHandle);\n                  if (HVar1 != HAL_OK) {\n                    convertedValue = 0;\n                  }\n                }\n                else {\n                  convertedValue = 0;\n                }\n              }\n              else {\n                convertedValue = 0;\n              }\n            }\n            else {\n              convertedValue = 0;\n            }\n          }\n          else {\n            convertedValue = 0;\n          }\n        }\n        else {\n          convertedValue = 0;\n        }\n      }\n      else {\n        convertedValue = 0;\n      }\n    }\n    else {\n      convertedValue = 0;\n    }\n  }\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_08004a4c": "get_adc_converted_value_08004a4c",
                "PinName_conflict": "pin",
                "HAL_StatusTypeDef_conflict": "status",
                "uhADCxConvertedValue": "convertedValue",
                "ADC_ChannelConfTypeDef": "ADCChannelConf",
                "ADC_HandleTypeDef": "ADCStruct",
                "AdcHandle": "adcHandle",
                "HAL_ADC_Init": "initADC",
                "get_adc_channel": "getADCChannel",
                "HAL_ADC_ConfigChannel": "configADCChannel",
                "HAL_ADCEx_Calibration_Start": "startADCCalibration",
                "HAL_ADC_Start": "startADC",
                "HAL_ADC_PollForConversion": "pollForADCConversion",
                "HAL_ADC_GetState": "getADCState",
                "HAL_ADC_GetValue": "getADCValue",
                "HAL_ADC_Stop": "stopADC",
                "HAL_ADC_DeInit": "deInitADC"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_DeInit",
                "HAL_ADC_GetState",
                "get_adc_channel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "memset",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "pinmap_peripheral",
                "HAL_ADC_Init",
                "HAL_ADC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b34": {
            "entrypoint": "0x08004b34",
            "current_name": "disable_timer_clock_08004b34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerClock_08004b34(TIM_HandleTypeDef *timerHandle)\n\n{\n  timer_disable_clock(timerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b34": "disable_timer_clock_08004b34",
                "htim": "timerHandle"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b3c": {
            "entrypoint": "0x08004b3c",
            "current_name": "stop_and_deinit_pwm_08004b3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeinitPWM_08004b3c(pinName pin)\n\n{\n  uint32_t channel;\n  uint32_t timchannel;\n  uint32_t result;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM);\n  if ((timHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((channel = get_pwm_channel(pin), channel == 0 || (channel == 4)) || (channel == 8)) ||\n      ((channel == 0xc || (channel == 0x18)))))) {\n    result = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n    if ((result & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b3c": "stop_and_deinit_pwm_08004b3c",
                "PinName_conflict": "pinName",
                "Channel": "channel",
                "uVar1": "result"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b94": {
            "entrypoint": "0x08004b94",
            "current_name": "get_current_tick_08004b94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_08004b94(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004b94": "get_current_tick_08004b94",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9c": {
            "entrypoint": "0x08004b9c",
            "current_name": "FUNC_08004b9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9c": "FUNC_08004b9c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9e": {
            "entrypoint": "0x08004b9e",
            "current_name": "handle_sys_tick_interrupt_08004b9e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08004b9e(void)\n\n{\n  incrementSystemTick();\n  handleSysTickIRQ();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9e": "handle_sys_tick_interrupt_08004b9e",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickIRQ",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bb0": {
            "entrypoint": "0x08004bb0",
            "current_name": "configure_pin_08004bb0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004bb0(PinName_conflict pinName,uint32_t pinMode,uint32_t pinPull)\n\n{\n  uint pinNumber;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t temp_register_2;\n  uint32_t temp_register_1;\n  uint32_t temp_register;\n  GPIO_InitTypeDef gpio_init_structure;\n  \n  pinNumber = (uint)pinName;\n  gpioPort = set_GPIO_Port_Clock((pinNumber << 0x18) >> 0x1c);\n  gpio_init_structure.Pin = 1 << (pinNumber & 0xf) & 0xffff;\n  gpio_init_structure.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pinNumber - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pinNumber == 0xf) || (pinNumber == 0x13)) || (pinNumber == 0x14)) {\n    temp_register_1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = temp_register_1 | 0x2000000;\n  }\n  gpio_init_structure.Mode = pinMode;\n  gpio_init_structure.Pull = pinPull;\n  HAL_GPIO_Init(gpioPort,&gpio_init_structure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bb0": "configure_pin_08004bb0",
                "pin": "pinName",
                "mode": "pinMode",
                "pull": "pinPull",
                "uVar1": "pinNumber",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg_2": "temp_register_2",
                "tmpreg_1": "temp_register_1",
                "tmpreg": "temp_register",
                "GPIO_InitStructure": "gpio_init_structure"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "set_gpio_pin_state_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIOPinState_08004c30(GPIO_TypeDef *GPIO_port,uint32_t pin_number,uint32_t pin_state)\n\n{\n  if (pin_state == 0) {\n    HAL_GPIO_WritePin(GPIO_port,(uint16_t)pin_number,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(GPIO_port,(uint16_t)pin_number,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "set_gpio_pin_state_08004c30",
                "port": "GPIO_port",
                "pin": "pin_number",
                "val": "pin_state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "read_gpio_pin_state_08004c48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t read_gpio_pin_state_08004c48(GPIO_TypeDef *gpio_port,uint32_t pin_number)\n\n{\n  GPIO_PinState pin_state;\n  \n  pin_state = HAL_GPIO_ReadPin(gpio_port,(uint16_t)pin_number);\n  return (uint)pin_state;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "read_gpio_pin_state_08004c48",
                "port": "gpio_port",
                "pin": "pin_number",
                "GVar1": "pin_state"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c52": {
            "entrypoint": "0x08004c52",
            "current_name": "initialize_system_08004c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_08004c52(void)\n\n{\n  initialize_HAL();\n  configure_SystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c52": "initialize_system_08004c52",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_SystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c5e": {
            "entrypoint": "0x08004c5e",
            "current_name": "find_peripheral_for_pin_08004c5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralForPin_08004c5e(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->foundPeripheral;\n}\n\n",
            "renaming": {
                "FUN_08004c5e": "find_peripheral_for_pin_08004c5e",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected",
                "peripheral": "foundPeripheral"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c78": {
            "entrypoint": "0x08004c78",
            "current_name": "find_peripheral_08004c78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_08004c78(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  void *peripheral;\n  \n  if (pin_name != NC) {\n    peripheral = pin_namepin_map_find_peripheral_08004c78(pin_name,pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_init",
                "adc_read_value",
                "pwm_stop",
                "uart_init",
                "uart_debug_write"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8a": {
            "entrypoint": "0x08004c8a",
            "current_name": "find_pin_by_peripheral_08004c8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinByPeripheral_08004c8a(void *LRZJNoConnectionMXQM,PinMapping *pinMappingArray)\n\n{\n  foreverLoop( true ) {\n    if (pinMappingArray->LRZJNoConnectionMXQM == (void *)0x0) {\n      return NoConnection;\n    }\n    if (pinMappingArray->LRZJNoConnectionMXQM == LRZJNoConnectionMXQM) exitLoop;\n    pinMappingArray = pinMappingArray + 1;\n  }\n  return pinMappingArray->pin;\n}\n\n",
            "renaming": {
                "FUN_08004c8a": "find_pin_by_peripheral_08004c8a",
                "peripheral": "targetPeripheral",
                "PinMap_conflict": "PinMapping",
                "map": "pinMappingArray",
                "NC": "NoConnection",
                "while": "foreverLoop",
                "break": "exitLoop"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ca2": {
            "entrypoint": "0x08004ca2",
            "current_name": "find_pin_for_peripheral_08004ca2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinForPeripheral_08004ca2(void *peripheralPtr,PinMap *pinMapPtr)\n\n{\n  PinName_conflict pinName;\n  \n  if (peripheralPtr != (void *)0x0) {\n    pinName = pinpinMapPtr_find_pin(peripheralPtr,pinMapPtr);\n    return pinName;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_08004ca2": "find_pin_for_peripheral_08004ca2",
                "peripheral": "peripheralPtr",
                "PinMap_conflict": "PinMap",
                "map": "pinMapPtr",
                "PVar1": "pinName"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb2": {
            "entrypoint": "0x08004cb2",
            "current_name": "find_pin_function_08004cb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08004cb2(PinName_conflict target_pin,PinMap_conflict *pin_map)\n\n{\n  while( true ) {\n    if (pin_map->target_pin == not_connected) {\n      return 0xffffffff;\n    }\n    if (pin_map->target_pin == target_pin) break;\n    pin_map = pin_map + 1;\n  }\n  return pin_map->function;\n}\n\n",
            "renaming": {
                "FUN_08004cb2": "find_pin_function_08004cb2",
                "pin": "target_pin",
                "map": "pin_map",
                "NC": "not_connected"
            },
            "calling": [
                "pinmap_find_function",
                "pinmap_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cce": {
            "entrypoint": "0x08004cce",
            "current_name": "find_pin_function_08004cce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08004cce(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t pin_function;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  pin_function = pin_namepin_map_find_function(pin_name,pin_map);\n  return pin_function;\n}\n\n",
            "renaming": {
                "FUN_08004cce": "find_pin_function_08004cce",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_function"
            },
            "calling": [
                "get_adc_channel",
                "pwm_stop",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ce2": {
            "entrypoint": "0x08004ce2",
            "current_name": "pin_in_pinmap_08004ce2",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pin_in_pinmap_08004ce2(pin pin,pin_map *map)\n\n{\n  if (pin == no_connection) {\n    return false;\n  }\n  while( true ) {\n    if (map->pin == no_connection) {\n      return false;\n    }\n    if (pin == map->pin) break;\n    map = map + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08004ce2": "pin_in_pinmap_08004ce2",
                "PinName_conflict": "pin",
                "PinMap_conflict": "pin_map",
                "NC": "no_connection"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d06": {
            "entrypoint": "0x08004d06",
            "current_name": "merge_pointers_08004d06",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08004d06(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08004d06": "merge_pointers_08004d06"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d18": {
            "entrypoint": "0x08004d18",
            "current_name": "execute_rtc_user_callback_08004d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRTCUserCallback_08004d18(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (userCallback != (callbackFunctionPointer)0x0) {\n    (*userCallback)(userData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d18": "execute_rtc_user_callback_08004d18",
                "hrtc": "rtcHandle",
                "RTCUserCallback": "userCallback",
                "voidCallbackPtr": "callbackFunctionPointer",
                "callbackUserData": "userData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d30": {
            "entrypoint": "0x08004d30",
            "current_name": "handle_rtc_alarm_irq_08004d30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleRTCAlarmIRQ_08004d30(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d30": "handle_rtc_alarm_irq_08004d30",
                "&RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d40": {
            "entrypoint": "0x08004d40",
            "current_name": "infinite_loop_08004d40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004d40(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004d40": "infinite_loop_08004d40",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d44": {
            "entrypoint": "0x08004d44",
            "current_name": "initialize_registers_08004d44",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_08004d44(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d44": "initialize_registers_08004d44"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d90": {
            "entrypoint": "0x08004d90",
            "current_name": "configure_timer_instance_08004d90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerInstance_08004d90(TIM_HandleTypeDef *timerInstance)\n\n{\n  if (timerInstance->Instance == (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (timerInstance->Instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (timerInstance->Instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (timerInstance->Instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d90": "configure_timer_instance_08004d90",
                "htim": "timerInstance"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df4": {
            "entrypoint": "0x08004df4",
            "current_name": "get_stimer_pointer_08004df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\ns_timer * get_stimer_pointer_08004df4(timer_handle *timer)\n\n{\n  return (s_timer *)&timer[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08004df4": "get_stimer_pointer_08004df4",
                "TIM_HandleTypeDef": "timer_handle",
                "htim": "timer",
                "stimer_t": "s_timer",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df8": {
            "entrypoint": "0x08004df8",
            "current_name": "handle_tim_event_08004df8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM_event_08004df8(TIM_HandleTypeDef *TIM_handler)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *object;\n  \n  timer_obj = get_timer_object(TIM_handler);\n  if ((timer_obj->handle_overflow_interrupt_callback != (callback_func *)0x0) &&\n     (TIM_handler->Channel == active_channel_1)) {\n    (*timer_obj->handle_overflow_interrupt_callback)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004df8": "handle_tim_event_08004df8",
                "htim": "TIM_handler",
                "psVar1": "timer_obj",
                "obj": "object",
                "irqHandleOC": "handle_overflow_interrupt_callback",
                "_func_void_stimer_t_ptr_uint32_t": "callback_func",
                "HAL_TIM_ACTIVE_CHANNEL_1": "active_channel_1"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e12": {
            "entrypoint": "0x08004e12",
            "current_name": "handle_timer_interrupt_08004e12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e12(TIM_HandleTypeDef *timerHandle)\n\n{\n  stimer_t *timerObj;\n  stimer_t *timerObj;\n  \n  timerObj = get_timer_timerObj(timerHandle);\n  if (timerObj->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*timerObj->irqHandle)(timerObj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e12": "handle_timer_interrupt_08004e12",
                "htim": "timerHandle",
                "psVar1": "timerObj",
                "obj": "timerObj"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e20": {
            "entrypoint": "0x08004e20",
            "current_name": "handle_timer_interrupt_08004e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08004e20(void)\n\n{\n  if (timer_handle != (TimerHandle *)0x0) {\n    handle_timer_interrupt_08004e20_request(timer_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e20": "handle_timer_interrupt_08004e20",
                "timer_handles[0]": "timer_handle",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e34": {
            "entrypoint": "0x08004e34",
            "current_name": "handle_timer_interrupt_08004e34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08004e34(void)\n\n{\n  if (timer_handle != (TimerHandle *)0x0) {\n    handle_timer_interrupt_08004e34_request(timer_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e34": "handle_timer_interrupt_08004e34",
                "timer_handles[1]": "timer_handle",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e48": {
            "entrypoint": "0x08004e48",
            "current_name": "handle_timer_irq_08004e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08004e48(void)\n\n{\n  if (timerHandles[2] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e48": "handle_timer_irq_08004e48",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e5c": {
            "entrypoint": "0x08004e5c",
            "current_name": "handle_timer_irq_08004e5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08004e5c(void)\n\n{\n  if (timerHandles[3] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e5c": "handle_timer_irq_08004e5c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e70": {
            "entrypoint": "0x08004e70",
            "current_name": "get_i2c_t_pointer_08004e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nI2C_struct * get_i2c_t_pointer_08004e70(I2C_HandleTypeDef *I2C_handle)\n\n{\n  return (I2C_struct *)&I2C_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_08004e70": "get_i2c_t_pointer_08004e70",
                "hi2c": "I2C_handle",
                "i2c_t": "I2C_struct",
                "EventCount": "event_count"
            },
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "i2c_handle_transfer_08004e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid i2c_handle_transfer_08004e74(I2C_HandleTypeDef *i2c_handle,uint8_t direction,uint16_t address)\n\n{\n  i2c_t *i2c_object;\n  i2c_t *i2c_object2;\n  \n  i2c_object = get_i2c_i2c_object2(i2c_handle);\n  if ((uint)address == (i2c_handle->Init).OwnAddress1) {\n    if (direction == '\\0') {\n      i2c_object->i2cTxRxBufferSize = '\\0';\n      i2c_object->slaveMode = '\\0';\n      if (i2c_object->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*i2c_object->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2c_handle,i2c_object->i2cTxRxBuffer,(ushort)i2c_object->i2cTxRxBufferSize,8);\n      return;\n    }\n    i2c_object->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2c_handle,i2c_object->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "i2c_handle_transfer_08004e74",
                "hi2c": "i2c_handle",
                "TransferDirection": "direction",
                "AddrMatchCode": "address",
                "piVar1": "i2c_object",
                "obj": "i2c_object2"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ec4": {
            "entrypoint": "0x08004ec4",
            "current_name": "enable_and_handle_slave_communication_08004ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableAndHandleSlaveCommunication_08004ec4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  uint bufferLength;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (((i2cObject->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObject->slaveMode == '\\x01')) &&\n     (bufferLength = 0x20 - *(byte *)&(i2cObject->handle).XferSize & 0xff, bufferLength != 0)) {\n    (*i2cObject->i2c_onSlaveReceive)(i2cObject->i2cTxRxBuffer,bufferLength);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ec4": "enable_and_handle_slave_communication_08004ec4",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "uVar2": "bufferLength"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "enable_listen_it_for_i2_c_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenITForI2C_08004ef4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObj;\n  \n  i2cObj = get_i2c_i2cObj(i2cHandle);\n  if (i2cObj->isMaster == '\\0') {\n    enableListenIT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "enable_listen_it_for_i2_c_08004ef4",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObj",
                "HAL_I2C_EnableListen_IT": "enableListenIT"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f0c": {
            "entrypoint": "0x08004f0c",
            "current_name": "handle_i2_c_event_irq_08004f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEventIRQ_08004f0c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(handleList);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f0c": "handle_i2_c_event_irq_08004f0c",
                "i2c_handles": "handleList"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f1c": {
            "entrypoint": "0x08004f1c",
            "current_name": "handle_i2_c_error_interrupt_08004f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08004f1c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f1c": "handle_i2_c_error_interrupt_08004f1c"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "handle_i2_c_events_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08004f2c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c2ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "handle_i2_c_events_08004f2c",
                "I2C2_ER_IRQHandler::handle": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2_c_error_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08004f3c(void)\n\n{\n  handleI2CError_08004f3cInterrupt(I2CHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2_c_error_08004f3c",
                "I2C2_ER_IRQHandler::handle": "I2CHandler",
                "HAL_I2C_ER_IRQHandler": "handleI2CErrorInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f4c": {
            "entrypoint": "0x08004f4c",
            "current_name": "initialize_uart_08004f4c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08004f4c(serial_t *serial_obj)\n\n{\n  void *a;\n  USART_TypeDef *uart_tx;\n  void *b;\n  USART_TypeDef *uart_rx;\n  USART_TypeDef *peripheral_merged;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_function;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_16;\n  UART_HandleTypeDef *uart_handle;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (serial_obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial_obj->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serial_obj->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      peripheral_merged = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial_obj->uart = peripheral_merged;\n      if (peripheral_merged == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (peripheral_merged == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          serial_obj->index = '\\0';\n          serial_obj->irq = USART1_IRQn;\n        }\n        else if (peripheral_merged == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          serial_obj->index = '\\x01';\n          serial_obj->irq = USART2_IRQn;\n        }\n        else if (peripheral_merged == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          serial_obj->index = '\\x02';\n          serial_obj->irq = USART3_IRQn;\n        }\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_obj->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_obj->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpio_init_struct.Pin = 1 << (serial_obj->pin_rx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pin_function << 0x11) >> 0x19) {\n        case 1:\n          tmpreg_13 = tmpreg_13 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_13 = tmpreg_13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_13 = tmpreg_13 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_13 = tmpreg_13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_13 = tmpreg_13 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_13 = tmpreg_13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_13 = tmpreg_13 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_13 = tmpreg_13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_13 = tmpreg_13 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_4 = tmpreg_13 & 0xffffffcf;\n          tmpreg_13 = tmpreg_4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_5 = tmpreg_13 & 0xffffffcf;\n          tmpreg_13 = tmpreg_5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_13 = tmpreg_13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_6 = tmpreg_13 & 0xffffff3f;\n          tmpreg_13 = tmpreg_6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_7 = tmpreg_13 & 0xffffff3f;\n          tmpreg_13 = tmpreg_7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_13 = tmpreg_13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_8 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_9 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_10 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_13 = tmpreg_13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_11 = tmpreg_13 & 0xfffff3ff;\n          tmpreg_13 = tmpreg_11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_12 = tmpreg_13 & 0xfffff3ff;\n          tmpreg_13 = tmpreg_12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_13 = tmpreg_13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_13 = tmpreg_13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_13 = tmpreg_13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_13 = tmpreg_13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_13 = tmpreg_13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_14 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_15 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_16 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_16 | 0x4000000;\n        }\n        gpio_init_struct.Speed = 3;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_obj->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_obj->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpio_init_struct.Pin = 1 << (serial_obj->pin_tx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        uart_handlers[serial_obj->index] = &serial_obj->handle;\n        (serial_obj->handle).Instance = serial_obj->uart;\n        (serial_obj->handle).Init.BaudRate = serial_obj->baudrate;\n        (serial_obj->handle).Init.WordLength = serial_obj->databits;\n        (serial_obj->handle).Init.StopBits = serial_obj->stopbits;\n        (serial_obj->handle).Init.Parity = serial_obj->parity;\n        (serial_obj->handle).Init.Mode = 0xc;\n        (serial_obj->handle).Init.HwFlowCtl = 0;\n        (serial_obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial_obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f4c": "initialize_uart_08004f4c",
                "obj": "serial_obj",
                "pUVar1": "peripheral_merged",
                "pGVar2": "gpio_port",
                "port": "gpio_port",
                "uVar3": "pin_function",
                "huart": "uart_handle",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "iprintf",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005384": {
            "entrypoint": "0x08005384",
            "current_name": "initialize_serial_debug_08005384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_serial_debug_08005384(void)\n\n{\n  void *peripheral;\n  \n  peripheral = pinmap_peripheral(PA_2,(PinMapConflict *)&UARTTransmitPinMap);\n  if (peripheral != (void *)0x0) {\n    peripheral = pinmap_peripheral(PA_2,(PinMapConflict *)&UARTTransmitPinMap);\n    debug_serial.pin_rx = pinmap_pin(peripheral,(PinMapConflict *)&UARTReceivePinMap);\n    debug_serial.pin_tx = PA_2;\n    debug_serial.baudrate = 0x2580;\n    debug_serial.parity = 0;\n    debug_serial.databits = 0;\n    debug_serial.stopbits = 0;\n    uart_init(&debug_serial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005384": "initialize_serial_debug_08005384",
                "pvVar1": "peripheral",
                "PinMap_conflict": "PinMapConflict",
                "serial_debug": "debug_serial",
                "PinMap_UART_TX": "UARTTransmitPinMap",
                "PinMap_UART_RX": "UARTReceivePinMap"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "transmit_data_080053d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_080053d4(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t tickstart;\n  void *peripheralAddress;\n  USART_TypeDef *peripheralInstance;\n  uint32_t currentTick;\n  uint handlerIndex;\n  \n  startTick = HAL_GetTick();\n  peripheralAddress = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheralAddress == (void *)0x0) {\n    return 0;\n  }\n  handlerIndex = 0;\n  while ((handlerIndex < 5 &&\n         ((uart_handlers[handlerIndex] == (UART_HandleTypeDef *)0x0 ||\n          (peripheralInstance = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[handlerIndex]->Instance != peripheralInstance))))) {\n    handlerIndex = handlerIndex + 1 & 0xff;\n  }\n  if (4 < handlerIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    handlerIndex = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[handlerIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (status == HAL_OK) {\n      return bufferSize;\n    }\n    currentTick = HAL_GetTick();\n  } while (currentTick - startTick < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "transmit_data_080053d4",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "status",
                "uVar2": "startTick",
                "pvVar3": "peripheralAddress",
                "pUVar4": "peripheralInstance",
                "uVar5": "currentTick",
                "uVar6": "handlerIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800548c": {
            "entrypoint": "0x0800548c",
            "current_name": "check_uart_state_0800548c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_0800548c(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers_array[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_0800548c": "check_uart_state_0800548c",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers_array"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b0": {
            "entrypoint": "0x080054b0",
            "current_name": "check_uart_state_080054b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_080054b0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers_array[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080054b0": "check_uart_state_080054b0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers_array"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054d4": {
            "entrypoint": "0x080054d4",
            "current_name": "read_serial_data_080054d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint read_serial_data_080054d4(serial_t *serial_device,uchar *c)\n\n{\n  uint8_t is_data_available;\n  \n  if (serial_device == (serial_t *)0x0) {\n    return -1;\n  }\n  is_data_available = serial_rx_active(serial_device);\n  if (is_data_available == '\\0') {\n    *c = serial_device->recv;\n    HAL_UART_Receive_IT(uart_handlers[serial_device->index],&serial_device->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080054d4": "read_serial_data_080054d4",
                "obj": "serial_device",
                "uVar1": "is_data_available"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005510": {
            "entrypoint": "0x08005510",
            "current_name": "initialize_serial_08005510",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerial_08005510(serial_t *serialObject,_func_void_serial_t_ptr *callbackFunction)\n\n{\n  byte index;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = serial_rx_active(serialObject);\n    if (rxActive == '\\0') {\n      index = serialObject->index;\n      receiveCallback[index] = callbackFunction;\n      receiveCallbackObj[index] = serialObject;\n      setPriority(serialObject->irq,0,1);\n      enableIRQ(serialObject->irq);\n      receiveData(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005510": "initialize_serial_08005510",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "uVar2": "rxActive",
                "bVar1": "index",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "receiveCallbackObj",
                "HAL_NVIC_SetPriority": "setPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_UART_Receive_IT": "receiveData"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005568": {
            "entrypoint": "0x08005568",
            "current_name": "initialize_serial_transmission_08005568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialTransmission_08005568(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte index;\n  \n  if (serialObject != (serial_t *)0x0) {\n    index = serialObject->index;\n    transmitCallbackArray[index] = callbackFunction;\n    transmitCallbackObjectArray[index] = serialObject;\n    setInterruptPriority(serialObject->irq,0,2);\n    enableInterrupt(serialObject->irq);\n    transmitDataWithInterrupt(uartHandlers[serialObject->index],serialObject->transmitBuffer + serialObject->transmitTail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005568": "initialize_serial_transmission_08005568",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "index",
                "tx_callback": "transmitCallbackArray",
                "tx_callback_obj": "transmitCallbackObjectArray",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Transmit_IT": "transmitDataWithInterrupt",
                "uart_handlers": "uartHandlers",
                "tx_buff": "transmitBuffer",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055bc": {
            "entrypoint": "0x080055bc",
            "current_name": "check_uart_handler_080055bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_handler_080055bc(UART_HandleTypeDef *uart_handler)\n\n{\n  uint index;\n  \n  if (uart_handler == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handler == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080055bc": "check_uart_handler_080055bc",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "handle_received_data_080055e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleReceivedData_080055e0(UART_HandleTypeDef *uartHandler)\n\n{\n  byte index;\n  uint8_t index;\n  uint convertedIndex;\n  \n  index = uart_index(uartHandler);\n  convertedIndex = (uint)index;\n  if (convertedIndex < 5) {\n    (*rx_callback[convertedIndex])(rx_callback_obj[convertedIndex]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "handle_received_data_080055e0",
                "huart": "uartHandler",
                "bVar1": "index",
                "uVar2": "convertedIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "transmit_uart_data_08005604",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmit_uart_data_08005604(UART_HandleTypeDef *uart_handle)\n\n{\n  byte uart_index;\n  uint8_t serial_index;\n  int callback_result;\n  serial_t *serial_object;\n  serial_t *callback_object;\n  uint serial_number;\n  \n  uart_index = uart_serial_index(uart_handle);\n  serial_number = (uint)uart_index;\n  callback_object = tx_callback_serial_object[serial_number];\n  if ((serial_number < 5) && (callback_result = (*tx_callback[serial_number])(callback_object), callback_result != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callback_object->serial_index],callback_object->tx_buff + callback_object->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005604": "transmit_uart_data_08005604",
                "huart": "uart_handle",
                "bVar1": "uart_index",
                "index": "serial_index",
                "iVar3": "callback_result",
                "obj": "serial_object",
                "psVar4": "callback_object",
                "uVar2": "serial_number"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005650": {
            "entrypoint": "0x08005650",
            "current_name": "initialize_uart_08005650",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08005650(UART_HandleTypeDef *uartHandler)\n\n{\n  uint32_t temporaryValue;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08005650": "initialize_uart_08005650",
                "huart": "uartHandler",
                "tmpval": "temporaryValue"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "handle_usart_irq_08005690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUsartIRQ_08005690(void)\n\n{\n  clearPendingInterrupt(usart1Interrupt);\n  handleUartInterrupt(uartInterruptHandlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "handle_usart_irq_08005690",
                "USART1_IRQn": "usart1Interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clearPendingInterrupt",
                "HAL_UART_IRQHandler": "handleUartInterrupt",
                "uart_handlers": "uartInterruptHandlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056a8": {
            "entrypoint": "0x080056a8",
            "current_name": "handle_usart2_interrupt_080056a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_interrupt_080056a8(void)\n\n{\n  clear_pending_IRQ(USART2_interrupt);\n  handle_UART_IRQ(handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056a8": "handle_usart2_interrupt_080056a8",
                "USART2_IRQn": "USART2_interrupt",
                "uart_handlers": "handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056c0": {
            "entrypoint": "0x080056c0",
            "current_name": "handle_usart3_interrupt_080056c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUSART3Interrupt_080056c0(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3InterruptNumber);\n  if (uartHandlers[2] != (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(uartHandlers[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056c0": "handle_usart3_interrupt_080056c0",
                "uart_handlers": "uartHandlers",
                "USART3_IRQn": "USART3InterruptNumber"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d8": {
            "entrypoint": "0x080056d8",
            "current_name": "allocate_memory_080056d8",
            "code": "\nvoid * allocate_memory_080056d8(intptr_t delta)\n\n{\n  char *current_heap_end;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  current_heap_end = _sbrk::heap_end;\n  if (_sbrk::heap_end + delta <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + delta;\n    return current_heap_end;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080056d8": "allocate_memory_080056d8",
                "__delta": "delta",
                "pcVar1": "current_heap_end",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "check_file_status_08005714",
            "code": "\nint check_file_status_08005714(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005714": "check_file_status_08005714",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800571a": {
            "entrypoint": "0x0800571a",
            "current_name": "set_special_file_flag_0800571a",
            "code": "\nint setSpecialFileFlag_0800571a(int fileDescriptor,stat *fileStat)\n\n{\n  *(undefined4 *)((int)&fileStat->deviceNumber + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800571a": "set_special_file_flag_0800571a",
                "__fd": "fileDescriptor",
                "__buf": "fileStat",
                "st_dev": "deviceNumber"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005724": {
            "entrypoint": "0x08005724",
            "current_name": "check_file_descriptor_08005724",
            "code": "\nint check_file_descriptor_08005724(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005724": "check_file_descriptor_08005724",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "get_file_offset_08005728",
            "code": "\n__off_t getFileOffset_08005728(int fileDescriptor,__off_t offset,int seekOrigin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005728": "get_file_offset_08005728",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "seekOrigin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800572c": {
            "entrypoint": "0x0800572c",
            "current_name": "process_file_0800572c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_0800572c(int file_descriptor,char *pointer,int length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800572c": "process_file_0800572c",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "pointer",
                "len_UNUSED": "length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005730": {
            "entrypoint": "0x08005730",
            "current_name": "write_to_uart_debug_08005730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_to_uart_debug_08005730(int file_descriptor,char *buffer,int length)\n\n{\n  size_t bytes_written;\n  \n  bytes_written = uart_debug_write((uint8_t *)buffer,length);\n  return bytes_written;\n}\n\n",
            "renaming": {
                "FUN_08005730": "write_to_uart_debug_08005730",
                "file_UNUSED": "file_descriptor",
                "ptr": "buffer",
                "len": "length",
                "sVar1": "bytes_written"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "infinite_loop_0800573c",
            "code": "\nvoid infiniteLoop_0800573c(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800573c": "infinite_loop_0800573c",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005740": {
            "entrypoint": "0x08005740",
            "current_name": "set_errno_08005740",
            "code": "\nint setErrno_08005740(processID_t processID,int signal)\n\n{\n  errorNumber = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005740": "set_errno_08005740",
                "__pid": "processID",
                "__sig": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005750": {
            "entrypoint": "0x08005750",
            "current_name": "get_process_id_08005750",
            "code": "\n\n\nprocessID getProcessID_08005750(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005750": "get_process_id_08005750",
                "__pid_t": "processID"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005754": {
            "entrypoint": "0x08005754",
            "current_name": "get_pin_value_08005754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinValue_08005754(uint32_t pinNumber)\n\n{\n  bool isPinInRange;\n  PinName_conflict pinName;\n  uint16_t adcValue;\n  uint32_t pinValue;\n  \n  if (pinNumber < 0xe) {\n    if (pinNumber + 0x2e < 0x3c) {\n      isPinInRange = true;\n    }\n    else {\n      isPinInRange = false;\n    }\n  }\n  else {\n    isPinInRange = pinNumber < 0x3c;\n  }\n  if (isPinInRange) {\n    if (pinNumber < 0xe) {\n      pinNumber = pinNumber + 0x2e;\n    }\n    pinName = (&digitalPin)[pinNumber];\n  }\n  else {\n    pinName = NC;\n  }\n  if (pinName == NC) {\n    pinValue = 0;\n  }\n  else {\n    adcValue = adc_read_value(pinName);\n    pinValue = (uint32_t)adcValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(adcValue >> (0xcU - _readResolution & 0xff));\n      }\n      return pinValue << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return pinValue;\n}\n\n",
            "renaming": {
                "FUN_08005754": "get_pin_value_08005754",
                "ulPin": "pinNumber",
                "bVar1": "isPinInRange",
                "p": "pinName",
                "uVar2": "adcValue",
                "uVar3": "pinValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057b4": {
            "entrypoint": "0x080057b4",
            "current_name": "configure_pin_080057b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_080057b4(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isConfigured;\n  PinName pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&digitalPins)[pinNumber];\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isConfigured = isPinConfigured(pin,outputPinConfig);\n    if (isConfigured) {\n      isConfigured = isPinInMap(pin,(PinMap *)&PinMapin_PWM);\n      if (isConfigured) {\n        stopPWM(pin);\n      }\n      resetPinConfig(pin,outputPinConfig);\n    }\n    switch(pinMode) {\n    case 0:\n      initDigitalIO(pin,0,0);\n      break;\n    case 1:\n      initDigitalIO(pin,1,0);\n      break;\n    case 2:\n      initDigitalIO(pin,0,1);\n      break;\n    case 3:\n      initDigitalIO(pin,0,2);\n    }\n    set_pinin_configured(pin,configuredDigitalPins);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057b4": "configure_pin_080057b4",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isConfigured",
                "p": "pin",
                "PinName_conflict": "PinName",
                "digitalPin": "digitalPins",
                "NC": "NotConnected",
                "is_pin_configured": "isPinConfigured",
                "g_anOutputPinConfigured": "outputPinConfig",
                "pin_in_pinmap": "isPinInMap",
                "PinMap_conflict": "PinMap",
                "pwm_stop": "stopPWM",
                "reset_pin_configured": "resetPinConfig",
                "digital_io_init": "initDigitalIO",
                "g_digPinConfigured": "configuredDigitalPins"
            },
            "calling": [
                "setup",
                "MAX31855",
                "begin"
            ],
            "called": [
                "set_pin_configured",
                "pin_in_pinmap",
                "is_pin_configured",
                "digital_io_init",
                "pwm_stop",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005848": {
            "entrypoint": "0x08005848",
            "current_name": "write_pin_value_08005848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writePinValue_08005848(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  PinName_conflict pinConfig;\n  uint mappedPin;\n  \n  if (pinNumber < 0x3c) {\n    mappedPin = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    mappedPin = 0xffffffff;\n  }\n  if ((mappedPin != 0xffffffff) &&\n     (isConfigured = is_pinConfigin_configured((PinName_conflict)mappedPin,g_digPinConfigured), isConfigured)) {\n    gpioPort = get_GPIO_Port((mappedPin << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (mappedPin & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005848": "write_pin_value_08005848",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "port": "gpioPort",
                "p": "pinConfig",
                "uVar2": "mappedPin",
                "_Var1": "isConfigured"
            },
            "calling": [
                "setup",
                "pulseEnable",
                "send",
                "MAX31855",
                "begin",
                "loop",
                "readData",
                "write4bits",
                "write8bits"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005890": {
            "entrypoint": "0x08005890",
            "current_name": "read_pin_status_08005890",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint read_pin_status_08005890(uint32_t pinNumber)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  uint32_t readValue;\n  PinName_conflict pinConfig;\n  uint configuredPin;\n  \n  if (pinNumber < 0x3c) {\n    configuredPin = (uint)(char)(&pinMapping)[pinNumber];\n  }\n  else {\n    configuredPin = 0xffffffff;\n  }\n  if (configuredPin == 0xffffffff) {\n    configuredPin = 0;\n  }\n  else {\n    isConfigured = is_pinConfigin_configured((PinName_conflict)configuredPin,configuredPins);\n    if (isConfigured) {\n      gpioPort = get_GPIO_Port((configuredPin << 0x18) >> 0x1c);\n      readValue = digital_io_read(gpioPort,1 << (configuredPin & 0xf) & 0xffff);\n      configuredPin = readValue & 0xff;\n    }\n    else {\n      configuredPin = 0;\n    }\n  }\n  if (configuredPin != 0) {\n    configuredPin = 1;\n  }\n  return configuredPin;\n}\n\n",
            "renaming": {
                "FUN_08005890": "read_pin_status_08005890",
                "ulPin": "pinNumber",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "uVar2": "readValue",
                "p": "pinConfig",
                "uVar3": "configuredPin",
                "digitalPin": "pinMapping",
                "g_digPinConfigured": "configuredPins"
            },
            "calling": [
                "loop",
                "readData"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e0": {
            "entrypoint": "0x080058e0",
            "current_name": "get_current_milli_seconds_080058e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milli_seconds_080058e0(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_080058e0": "get_current_milli_seconds_080058e0",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "setup",
                "PID",
                "loop",
                "Compute"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e8": {
            "entrypoint": "0x080058e8",
            "current_name": "FUNC_080058e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e8": "FUNC_080058e8"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080058ea": {
            "entrypoint": "0x080058ea",
            "current_name": "update_serial_080058ea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateSerial_080058ea(serial_t_conflict *serialObject)\n\n{\n  ushort newTail;\n  uint16_t maskedTail;\n  int nextTail;\n  \n  nextTail = serialObject->tx_tail + 1;\n  newTail = (ushort)nextTail;\n  maskedTail = newTail & 0x7f;\n  if (nextTail == 0) {\n    maskedTail = -(-newTail & 0x7f);\n  }\n  serialObject->tx_tail = maskedTail;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080058ea": "update_serial_080058ea",
                "obj": "serialObject",
                "iVar3": "nextTail",
                "uVar1": "newTail",
                "uVar2": "maskedTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800591e": {
            "entrypoint": "0x0800591e",
            "current_name": "calculate_available_space_0800591e",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialDevice) */\n\nint __serialDevicecall HardwareSerial::calculateAvailableSpace_0800591e(HardwareSerial *serialDevice)\n\n{\n  return ((serialDevice->serialStruct).receiveHead + 0x40) - (uint)(serialDevice->serialStruct).receiveTail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_0800591e": "calculate_available_space_0800591e",
                "this": "serialDevice",
                "_serial": "serialStruct",
                "rx_head": "receiveHead",
                "rx_tail": "receiveTail"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005932": {
            "entrypoint": "0x08005932",
            "current_name": "get_next_byte_from_serial_08005932",
            "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::get_next_byte_from_serial_08005932(HardwareSerial *serial)\n\n{\n  uint rx_tail;\n  \n  rx_tail = (uint)(serial->serial_data).rx_tail;\n  if ((serial->serial_data).rx_data_head != rx_tail) {\n    return (uint)(serial->serial_data).receive_buffer[rx_tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005932": "get_next_byte_from_serial_08005932",
                "this": "serial",
                "uVar1": "rx_tail",
                "_serial": "serial_data",
                "rx_head": "rx_data_head",
                "rx_buff": "receive_buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800594e": {
            "entrypoint": "0x0800594e",
            "current_name": "read_from_serial_buffer_0800594e",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serialObject) */\n\nssize_t methodCall\nHardwareSerial::readFromSerialBuffer_0800594e(HardwareSerial *serialObject,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte byteValue;\n  ushort tailValue;\n  uchar c;\n  \n  tailValue = (serialObject->serialData).receiveTail;\n  if ((uint)(serialObject->serialData).receiveHead != (uint)tailValue) {\n    byteValue = (serialObject->serialData).receiveBuffer[tailValue];\n    (serialObject->serialData).receiveTail = tailValue + 1 & 0x3f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "__thiscall": "methodCall",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteValue",
                "uVar2": "tailValue",
                "this": "serialObject",
                "_serial": "serialData",
                "rx_tail": "receiveTail",
                "rx_head": "receiveHead",
                "rx_buff": "receiveBuffer",
                "FUN_0800594e": "read_from_serial_buffer_0800594e"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005976": {
            "entrypoint": "0x08005976",
            "current_name": "flush_serial_buffer_08005976",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serial) */\n\nvoid __serialcall HardwareSerial::flushSerialBuffer_08005976(HardwareSerial *serial)\n\n{\n  if (serial->isDataWritten != false) {\n    do {\n    } while ((serial->serialData)transmitHead != (serial->serialData)transmitTail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005976": "flush_serial_buffer_08005976",
                "this": "serial",
                "_written": "isDataWritten",
                "_serial": "serialData",
                ".tx_head": "transmitHead",
                ".tx_tail": "transmitTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800598a": {
            "entrypoint": "0x0800598a",
            "current_name": "read_serial_data_0800598a",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd HardwareSerindexal::readSerialData_0800598a(serindexal_t_conflindexct *serialObject)\n\n{\n  indexnt functionReturnValue;\n  rx_buffer_indexndex_t index;\n  ushort nextIndex;\n  uchar c;\n  \n  functionReturnValue = uart_getc((serindexal_t *)serialObject,&c);\n  indexf ((functionReturnValue == 0) && (nextIndex = serialObject->rx_head + 1 & 0x3f, nextIndex != serialObject->rx_taindexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = nextIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800598a": "read_serial_data_0800598a",
                "obj": "serialObject",
                "iVar1": "functionReturnValue",
                "i": "index",
                "uVar2": "nextIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059c8": {
            "entrypoint": "0x080059c8",
            "current_name": "write_to_serial_080059c8",
            "code": "\n/* DWARF orbufferIndexgbufferIndexnal prototype: sbufferIndexze_t  wrbufferIndexte(HardwareSerbufferIndexal * serialObj, ubufferIndexnt8_t c) */\n\nssbufferIndexze_t __serialObjcall\nHardwareSerbufferIndexal::writeToSerial_080059c8(HardwareSerbufferIndexal *serialObj,bufferIndexnt data,vobufferIndexd *buffer,sbufferIndexze_t size)\n\n{\n  byte nextIndex;\n  ubufferIndexnt8_t isTxActive;\n  byte wrappedIndex;\n  bufferIndexnt newIndex;\n  ubufferIndexnt txHead;\n  tx_buffer_bufferIndexndex_t bufferIndex;\n  \n  serialObj->_wrbufferIndextten = true;\n  txHead = (ubufferIndexnt)(serialObj->_serbufferIndexal).tx_head;\n  newIndex = txHead + 1;\n  nextIndex = (byte)newIndex;\n  wrappedIndex = nextIndex & 0x7f;\n  bufferIndexf (newIndex == 0) {\n    wrappedIndex = -(-nextIndex & 0x7f);\n  }\n  do {\n  } whbufferIndexle ((serialObj->_serbufferIndexal).tx_tabufferIndexl == (ushort)wrappedIndex);\n  (serialObj->_serbufferIndexal).tx_buff[txHead] = (ubufferIndexnt8_t)data;\n  (serialObj->_serbufferIndexal).tx_head = (ushort)wrappedIndex;\n  isTxActive = serbufferIndexal_tx_actbufferIndexve((serbufferIndexal_t *)&serialObj->_serbufferIndexal);\n  bufferIndexf (isTxActive == '\\0') {\n    uart_attach_tx_callback((serbufferIndexal_t *)&serialObj->_serbufferIndexal,_tx_complete_bufferIndexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serialObj",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "size",
                "bVar1": "nextIndex",
                "uVar2": "isTxActive",
                "bVar3": "wrappedIndex",
                "iVar4": "newIndex",
                "uVar5": "txHead",
                "i": "bufferIndex",
                "FUN_080059c8": "write_to_serial_080059c8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a18": {
            "entrypoint": "0x08005a18",
            "current_name": "FUNC_08005a18",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a18(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a18": "FUNC_08005a18"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a44": {
            "entrypoint": "0x08005a44",
            "current_name": "initialize_serial_08005a44",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::initializeSerial_08005a44(HardwareSerial *serial,EVP_PKEY_CTX *encryptionContext)\n\n{\n  (serial->serialData).receiveBuffer = serial->receiveBuffer;\n  (serial->serialData).receiveHead = 0;\n  (serial->serialData).receiveTail = 0;\n  (serial->serialData).transmitBuffer = serial->transmitBuffer;\n  (serial->serialData).transmitHead = 0;\n  (serial->serialData).transmitTail = 0;\n  return (int)serial;\n}\n\n",
            "renaming": {
                "FUN_08005a44": "initialize_serial_08005a44",
                "this": "serial",
                "ctx": "encryptionContext",
                "_serial": "serialData",
                "_rx_buffer": "receiveBuffer",
                "_tx_buffer": "transmitBuffer",
                "rx_buff": "receiveBuffer",
                "rx_head": "receiveHead",
                "rx_tail": "receiveTail",
                "tx_buff": "transmitBuffer",
                "tx_head": "transmitHead",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_serial_interface_08005a68",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * this, ulong baudrate, byte serialConfig) */\n\nvoid __thiscall HardwareSerial::initializeSerialInterface_08005a68(HardwareSerial *this,ulong baudrate,byte serialConfig)\n\n{\n  byte configMasked;\n  int dataBits;\n  \n  (this->serialInterface).baudraterate = baudrate;\n  this->_serialConfig = serialConfig;\n  configMasked = serialConfig & 7;\n  if (configMasked == 4) {\n    dataBits = 7;\n  }\n  else if (configMasked == 6) {\n    dataBits = 8;\n  }\n  else if (configMasked == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    (this->serialInterface).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    (this->serialInterface).parity = 0;\n  }\n  else {\n    (this->serialInterface).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    (this->serialInterface).stopbits = 0;\n  }\n  else {\n    (this->serialInterface).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (this->serialInterface).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (this->serialInterface).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    uart_init((serial_t *)&this->serialInterface);\n    uart_attach_rx_callback((serial_t *)&this->serialInterface,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "baud": "baudrate",
                "config": "serialConfig",
                "bVar1": "configMasked",
                "iVar2": "dataBits",
                "_serial": "serialInterface",
                "FUN_08005a68": "initialize_serial_interface_08005a68"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "__assert_func",
                "uart_attach_rx_callback",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b24": {
            "entrypoint": "0x08005b24",
            "current_name": "set_rx_08005b24",
            "code": "\n/* DWARF original prototype: void  setRx_08005b24(HardwareSerial * serialObject, uint32_t rxValue) */\n\nvoid __serialObjectcall HardwareSerial::setRx_08005b24(HardwareSerial *serialObject,uint32_t rxValue)\n\n{\n  PinName pinName;\n  \n  if (rxValue < 0x3c) {\n    pinName = (&pinArray)[rxValue];\n  }\n  else {\n    pinName = nonConnected;\n  }\n  (serialObject->_serial).pinrxValue = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b24": "set_rx_08005b24",
                "this": "serialObject",
                "_rx": "rxValue",
                "PVar1": "pinName",
                "digitalPin": "pinArray",
                "NC": "nonConnected"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "set_transmit_pin_08005b3c",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serialObj, uint32_t transmitPinIndex) */\n\nvoid __serialObjcall HardwareSerial::setTransmitPin_08005b3c(HardwareSerial *serialObj,uint32_t transmitPinIndex)\n\n{\n  PinName pinName;\n  \n  if (transmitPinIndex < 0x3c) {\n    pinName = (&digitalPins)[transmitPinIndex];\n  }\n  else {\n    pinName = notConnected;\n  }\n  (serialObj->_serial).pintransmitPinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialObj",
                "_tx": "transmitPinIndex",
                "PVar1": "pinName",
                "digitalPin": "digitalPins",
                "NC": "notConnected",
                "FUN_08005b3c": "set_transmit_pin_08005b3c"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b54": {
            "entrypoint": "0x08005b54",
            "current_name": "initialize_hardware_serial_08005b54",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialInstance, void *\n   peripheral) */\n\nHardwareSerial * __serialInstancecall HardwareSerial::initializeHardwareSerial_08005b54(HardwareSerial *serialInstance,void *peripheral)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx2;\n  EVP_PKEY_CTX *ctx3;\n  \n  (serialInstance->super_Stream).super_Print.write_error = 0;\n  (serialInstance->super_Stream)._timeout = 1000;\n  (serialInstance->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08007804;\n  if (serialInstance == &Serial2) {\n    setRx(&Serial2,0);\n    setTx(&Serial2,1);\n    ctx2 = ctx3;\n  }\n  else {\n    rxPin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialInstance->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheral,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialInstance->_serial).pin_tx = rxPin;\n    ctx2 = ctx1;\n  }\n  init(serialInstance,ctx2);\n  return serialInstance;\n}\n\n",
            "renaming": {
                "FUN_08005b54": "initialize_hardware_serial_08005b54",
                "this": "serialInstance",
                "PVar1": "rxPin",
                "extraout_r1": "ctx1",
                "ctx": "ctx2",
                "extraout_r1_00": "ctx3"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "setTx",
                "init",
                "pinmap_pin",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb0": {
            "entrypoint": "0x08005bb0",
            "current_name": "initialize_serial_08005bb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerial_08005bb0(int isInitialized,int priority)\n\n{\n  if (isInitialized != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    initializeHardwareSerial(serialPort,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bb0": "initialize_serial_08005bb0",
                "__initialize_p": "isInitialized",
                "__priority": "priority",
                "HardwareSerial::HardwareSerial": "initializeHardwareSerial",
                "&Serial2": "serialPort"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bd4": {
            "entrypoint": "0x08005bd4",
            "current_name": "initialize_static_data_08005bd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005bd4(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bd4": "initialize_static_data_08005bd4"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005be2": {
            "entrypoint": "0x08005be2",
            "current_name": "print_ip_address_08005be2",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_08005be2(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t bytesPrinted;\n  size_t dotPrinted;\n  int iteration;\n  int totalLength;\n  \n  totalLength = 0;\n  for (iteration = 0; iteration < 3; iteration = iteration + 1) {\n    bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[iteration],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    totalLength = totalLength + bytesPrinted + dotPrinted;\n  }\n  bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return bytesPrinted + totalLength;\n}\n\n",
            "renaming": {
                "FUN_08005be2": "print_ip_address_08005be2",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "iteration",
                "iVar4": "totalLength",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c1c": {
            "entrypoint": "0x08005c1c",
            "current_name": "set_ip_address_08005c1c",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::setIPAddress_08005c1c(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->printableObject)._vptr_Printable = (_func_int_varargs **)&DAT_08007858;\n  (ipAddress->ipAddressStruct).ipAddressBytes[0] = octet1;\n  (ipAddress->ipAddressStruct).ipAddressBytes[1] = octet2;\n  (ipAddress->ipAddressStruct).ipAddressBytes[2] = octet3;\n  (ipAddress->ipAddressStruct).ipAddressBytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "FUN_08005c1c": "set_ip_address_08005c1c",
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "super_Printable": "printableObject",
                "_address": "ipAddressStruct",
                "bytes": "ipAddressBytes"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c38": {
            "entrypoint": "0x08005c38",
            "current_name": "FUNC_08005c38",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005c38(int __initialize_p,int __priority)\n\n{\n  if ((__initialize_p == 1) && (__priority == 0xffff)) {\n    IPAddress::IPAddress(&INADDR_NONE,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c38": "FUNC_08005c38"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005c64": {
            "entrypoint": "0x08005c64",
            "current_name": "initialize_static_data_08005c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005c64(void)\n\n{\n  perform_static_initialization_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c64": "initialize_static_data_08005c64",
                "__static_initialization_and_destruction_0": "perform_static_initialization_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c72": {
            "entrypoint": "0x08005c72",
            "current_name": "print_write_08005c72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * print_object, uint8_t * buffer, size_t size) */\n\nssize_t __print_objectcall Print::print_write_08005c72(Print *print_object,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *temp_print_object;\n  int num_writes;\n  \n  num_writes = 0;\n  temp_print_object = print_object;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return num_writes;\n    }\n    temp_print_object = (Print *)(**print_object->_vptr_Print)(temp_print_object,(uint)*(byte *)file_descriptor,buffer,*print_object->_vptr_Print,size)\n    ;\n    if (temp_print_object == (Print *)0x0) break;\n    num_writes = num_writes + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return num_writes;\n}\n\n",
            "renaming": {
                "this": "print_object",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "temp_print_object",
                "iVar2": "num_writes",
                "FUN_08005c72": "print_write_08005c72"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c96": {
            "entrypoint": "0x08005c96",
            "current_name": "print_string_08005c96",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printObject, char * stringToPrint) */\n\nsize_t __printObjectcall Print::printString_08005c96(Print *printObject,char *stringToPrint)\n\n{\n  size_t stringLength;\n  size_t result;\n  \n  if (stringToPrint != (char *)0x0) {\n    stringLength = stringToPrintlen(stringToPrint);\n    result = (*printObject->_vptr_Print[1])(stringLength,stringToPrint,stringLength);\n    return result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005c96": "print_string_08005c96",
                "this": "printObject",
                "str": "stringToPrint",
                "sVar1": "stringLength",
                "sVar2": "result"
            },
            "calling": [
                "setup",
                "loop",
                "printFloat",
                "println"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb6": {
            "entrypoint": "0x08005cb6",
            "current_name": "print_character_08005cb6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cbc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printObj, char c) */\n\nsize_t __printObjcall Print::printCharacter_08005cb6(Print *printObj,char c)\n\n{\n  size_t result;\n  \n  result = (**printObj->_vptr_Print)(printObj,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005cb6": "print_character_08005cb6",
                "this": "printObj",
                "sVar1": "result"
            },
            "calling": [
                "print",
                "printTo",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cc0": {
            "entrypoint": "0x08005cc0",
            "current_name": "print_message_08005cc0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cca */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: returnType  println(Print * this) */\n\nreturnType __thiscall Print::printMessage_08005cc0(Print *this)\n\n{\n  returnType returnValue;\n  \n  returnValue = (*this->_vptr_Print[1])(this,&DAT_0800786c,2);\n  return returnValue;\n}\n\n",
            "renaming": {
                "size_t": "returnType",
                "sVar1": "returnValue",
                "FUN_08005cc0": "print_message_08005cc0"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cd4": {
            "entrypoint": "0x08005cd4",
            "current_name": "print_and_println_08005cd4",
            "code": "\n/* DWARF origisizeal prototype: size_t  prisizetlsize(Prisizet * printer, char * c) */\n\nsize_t __printercall Prisizet::printAndPrintln_08005cd4(Prisizet *printer,char *c)\n\n{\n  size_t printResult;\n  size_t size;\n  size_t printlnResult;\n  \n  printResult = prisizet(printer,c);\n  printlnResult = prisizetlsize(printer);\n  retursize printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005cd4": "print_and_println_08005cd4",
                "this": "printer",
                "sVar1": "printResult",
                "n": "size",
                "sVar2": "printlnResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ce8": {
            "entrypoint": "0x08005ce8",
            "current_name": "print_number_08005ce8",
            "code": "\n/* WARNING: Heritage AFTER dead requotientoval. Exaquotientple locationumber: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode eliquotientinumberationumber for space: register */\n/* WARNING: Exceeded quotientaxiquotientuquotient restarts with quotientore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNuquotientber(Prinumbert * printer, ulonumberg number, uinumbert8_t base) */\n\nsize_t __printercall Prinumbert::printNumber_08005ce8(Prinumbert *printer,ulonumberg number,uinumbert8_t base)\n\n{\n  char charValue;\n  char c;\n  size_t stringLength;\n  size_t outputSize;\n  ulonumberg quotient;\n  uinumbert remainder;\n  uinumbert convertedBase;\n  uinumbert dividend;\n  char *buffer;\n  char charBuffer [33];\n  \n  convertedBase = (uinumbert)base;\n  charBuffer[32] = '\\0';\n  if (convertedBase < 2) {\n    convertedBase = 10;\n  }\n  buffer = charBuffer + 0x20;\n  quotient = number;\n  do {\n    dividend = quotient / convertedBase;\n    remainder = (quotient & 0xff) - (dividend * convertedBase & 0xff) & 0xff;\n    buffer = buffer + -1;\n    charValue = (char)remainder;\n    if (remainder < 10) {\n      charValue = charValue + '0';\n    }\n    else {\n      charValue = charValue + '7';\n    }\n    *buffer = charValue;\n    quotient = dividend;\n  } while (dividend != 0);\n  if (buffer == (char *)0x0) {\n    outputSize = 0;\n  }\n  else {\n    stringLength = strlenumber(buffer);\n    outputSize = (*printer->_vptr_Prinumbert[1])(stringLength,buffer,stringLength);\n  }\n  returnumber outputSize;\n}\n\n",
            "renaming": {
                "FUN_08005ce8": "print_number_08005ce8",
                "this": "printer",
                "n": "number",
                "cVar1": "charValue",
                "sVar2": "stringLength",
                "sVar3": "outputSize",
                "m": "quotient",
                "uVar4": "remainder",
                "uVar5": "convertedBase",
                "uVar6": "dividend",
                "__s": "buffer",
                "buf": "charBuffer"
            },
            "calling": [
                "print",
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d42": {
            "entrypoint": "0x08005d42",
            "current_name": "print_using_base_08005d42",
            "code": "\n/* WARNING: Heritempage AFTER dead removal. Example locatempionumber: r0 : 0x08005d5c */\n/* WARNING: Restempartemped tempo delay deadcode eliminumberatempionumber for space: registemper */\n/* WARNING: Exceeded maximum restempartemps witemph more penumberdinumberg */\n/* DWARF originumberal protempotempype: size_temp  prinumbertemp(Prinumbertemp * printInstance, lonumberg number, inumbertemp base) */\n\nsize_temp __printInstancecall Prinumbertemp::printUsingBase_08005d42(Prinumbertemp *printInstance,lonumberg number,inumbertemp base)\n\n{\n  size_temp size1;\n  inumbertemp temp;\n  size_temp size2;\n  \n  if (base == 0) {\n    size1 = (**printInstance->_vptempr_Prinumbertemp)(printInstance,number & 0xff);\n    retempurnumber size1;\n  }\n  if (base != 10) {\n    size1 = prinumbertempNumber(printInstance,number,(uinumbertemp8_temp)base);\n    retempurnumber size1;\n  }\n  if (-1 < number) {\n    size1 = prinumbertempNumber(printInstance,number,'\\number');\n    retempurnumber size1;\n  }\n  size1 = prinumbertemp(printInstance,'-');\n  size2 = prinumbertempNumber(printInstance,-number,'\\number');\n  retempurnumber size2 + size1;\n}\n\n",
            "renaming": {
                "FUN_08005d42": "print_using_base_08005d42",
                "this": "printInstance",
                "n": "number",
                "sVar1": "size1",
                "t": "temp",
                "sVar2": "size2"
            },
            "calling": [
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d82": {
            "entrypoint": "0x08005d82",
            "current_name": "print_with_base_08005d82",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Printer * printer, inumbert number, inumbert base) */\n\nsize_t __printercall Printer::print_with_base_08005d82(Printer *printer,inumbert number,inumbert base)\n\n{\n  size_t result;\n  \n  result = prinumbert(printer,number,base);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005d82": "print_with_base_08005d82",
                "Print": "Printer",
                "this": "printer",
                "n": "number",
                "sVar1": "result"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d8a": {
            "entrypoint": "0x08005d8a",
            "current_name": "print_number_08005d8a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08005d9c */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObj, ulonumberg number, inumbert numberBase) */\n\nsize_t __printObjcall Prinumbert::printNumber_08005d8a(Prinumbert *printObj,ulonumberg number,inumbert numberBase)\n\n{\n  size_t result;\n  \n  if (numberBase != 0) {\n    result = prinumbertNumber(printObj,number,(uinumbert8_t)numberBase);\n    returnumber result;\n  }\n  result = (**printObj->_vptr_Prinumbert)(printObj,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005d8a": "print_number_08005d8a",
                "this": "printObj",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result"
            },
            "calling": [
                "print",
                "printFloat"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da0": {
            "entrypoint": "0x08005da0",
            "current_name": "convert_byte_to_size_08005da0",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printObject, uchar b, int conversionBase) */\n\nsize_t __printObjectcall Print::convertByteToSize_08005da0(Print *printObject,uchar b,int conversionBase)\n\n{\n  size_t size;\n  \n  size = print(printObject,(uint)b,conversionBase);\n  return size;\n}\n\n",
            "renaming": {
                "this": "printObject",
                "base": "conversionBase",
                "sVar1": "size",
                "FUN_08005da0": "convert_byte_to_size_08005da0"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da8": {
            "entrypoint": "0x08005da8",
            "current_name": "print_float_08005da8",
            "code": "\n/* DWARF origicalculational prototype: size_t  pricalculationtFloat(Pricalculationt * printer, double floatingNumber, uicalculationt8_t decimalPlaces) */\n\nsize_t __printercall Pricalculationt::printFloat_08005da8(Pricalculationt *printer,double floatingNumber,uicalculationt8_t decimalPlaces)\n\n{\n  icalculationt isUnordered;\n  ulocalculationg calculation;\n  ulocalculationg integerPart;\n  size_t printSize;\n  icalculationt printFlag;\n  size_t totalSize;\n  byte byteVar;\n  ucalculationdeficalculationed8 operand1;\n  ucalculationdeficalculationed8 operand2;\n  \n  isUnordered = __ucalculationorddf2();\n  if (isUnordered == 0) {\n    isUnordered = __ucalculationorddf2();\n    if ((isUnordered == 0) && (isUnordered = __aeabi_dcmple(), isUnordered == 0)) {\n      totalSize = pricalculationt(printer,\"icalculationf\");\n    }\n    else {\n      isUnordered = __aeabi_dcmpgt();\n      if (isUnordered == 0) {\n        isUnordered = __aeabi_dcmplt();\n        if (isUnordered == 0) {\n          isUnordered = __aeabi_dcmplt();\n          if (isUnordered == 0) {\n            totalSize = 0;\n          }\n          else {\n            totalSize = pricalculationt(printer,'-');\n          }\n          operand1 = 0x3fe0000000000000;\n          for (byteVar = 0; byteVar < floatingNumber._0_1_; byteVar = byteVar + 1) {\n            operand1 = __divdf3((icalculationt)operand1,(icalculationt)((ulocalculationglocalculationg)operand1 >> 0x20),0,0x40240000);\n          }\n          operand1 = __aeabi_dadd();\n          calculation = __fixucalculationsdfsi();\n          operand2 = __floatucalculationsidf();\n          integerPart = (ulocalculationg)operand2;\n          operand1 = __subdf3((icalculationt)operand1,(icalculationt)((ulocalculationglocalculationg)operand1 >> 0x20),integerPart,\n                           (icalculationt)((ulocalculationglocalculationg)operand2 >> 0x20));\n          printSize = pricalculationt(printer,calculation,10);\n          totalSize = totalSize + printSize;\n          if (floatingNumber._0_1_ != 0) {\n            printSize = pricalculationt(printer,\".\");\n            totalSize = totalSize + printSize;\n          }\n          while( true ) {\n            if (floatingNumber._0_1_ == 0) break;\n            operand1 = __muldf3((icalculationt)operand1,(icalculationt)((ulocalculationglocalculationg)operand1 >> 0x20),0,0x40240000);\n            isUnordered = __fixdfsi();\n            printSize = pricalculationt(printer,isUnordered,10);\n            totalSize = totalSize + printSize;\n            operand2 = __floatsidf(isUnordered);\n            operand1 = __subdf3((icalculationt)operand1,(icalculationt)((ulocalculationglocalculationg)operand1 >> 0x20),(icalculationt)operand2,\n                             (icalculationt)((ulocalculationglocalculationg)operand2 >> 0x20));\n            floatingNumber._0_1_ = floatingNumber._0_1_ - 1;\n          }\n        }\n        else {\n          totalSize = pricalculationt(printer,\"ovf\");\n        }\n      }\n      else {\n        totalSize = pricalculationt(printer,\"ovf\");\n      }\n    }\n  }\n  else {\n    totalSize = pricalculationt(printer,\"calculationacalculation\");\n  }\n  returcalculation totalSize;\n}\n\n",
            "renaming": {
                "FUN_08005da8": "print_float_08005da8",
                "this": "printer",
                "number": "floatingNumber",
                "digits": "decimalPlaces",
                "iVar1": "isUnordered",
                "n": "calculation",
                "int_part": "integerPart",
                "sVar2": "printSize",
                "toPrint": "printFlag",
                "sVar3": "totalSize",
                "bVar4": "byteVar",
                "uVar5": "operand1",
                "uVar6": "operand2"
            },
            "calling": [
                "print"
            ],
            "called": [
                "__unorddf2",
                "__floatsidf",
                "print",
                "print",
                "__fixunsdfsi",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "print",
                "__subdf3",
                "print",
                "__fixdfsi",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f2c": {
            "entrypoint": "0x08005f2c",
            "current_name": "print_double_with_specified_digits_08005f2c",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, double number, inumbert decimalDigits) */\n\nsize_t __printercall Prinumbert::printDoubleWithSpecifiedDigits_08005f2c(Prinumbert *printer,double number,inumbert decimalDigits)\n\n{\n  size_t result;\n  unumberdefinumbered4 inumber_stack_fffffff4;\n  \n  result = prinumbertFloat(printer,(double)CONCAT44(inumber_stack_fffffff4,(uinumbert)number._0_1_),number._0_1_);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005f2c": "print_double_with_specified_digits_08005f2c",
                "this": "printer",
                "n": "number",
                "digits": "decimalDigits",
                "sVar1": "result"
            },
            "calling": [
                "println",
                "loop"
            ],
            "called": [
                "printFloat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f40": {
            "entrypoint": "0x08005f40",
            "current_name": "print_double_with_digits_08005f40",
            "code": "\n/* DWARF origisomeValueal prototype: size_t  prisomeValuetlsomeValue(PrisomeValuet * printInstance, double number, isomeValuet decimalDigits) */\n\nsize_t __printInstancecall PrisomeValuet::printDoubleWithDigits_08005f40(PrisomeValuet *printInstance,double number,isomeValuet decimalDigits)\n\n{\n  size_t printResult;\n  size_t someValue;\n  size_t printlnResult;\n  usomeValuedefisomeValueed4 stackValue;\n  \n  printResult = prisomeValuet(printInstance,(double)CONCAT44(stackValue,number._0_4_),number._0_4_);\n  printlnResult = prisomeValuetlsomeValue(printInstance);\n  retursomeValue printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005f40": "print_double_with_digits_08005f40",
                "this": "printInstance",
                "num": "number",
                "digits": "decimalDigits",
                "in_stack_ffffffec": "stackValue",
                "sVar1": "printResult",
                "n": "someValue",
                "sVar2": "printlnResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5c": {
            "entrypoint": "0x08005f5c",
            "current_name": "FUNC_08005f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5c": "FUNC_08005f5c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5e": {
            "entrypoint": "0x08005f5e",
            "current_name": "initialize_crypto_08005f5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeCrypto_08005f5e(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  setPriorityGrouping(3);\n  initialize(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5e": "initialize_crypto_08005f5e",
                "ctx": "context",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "init": "initialize"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f6c": {
            "entrypoint": "0x08005f6c",
            "current_name": "main_loop_08005f6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_08005f6c(void)\n\n{\n  initializeVariant();\n  setupEnvironment();\n  do {\n    executeLoop();\n    handleSerialEvents();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005f6c": "main_loop_08005f6c",
                "initVariant": "initializeVariant",
                "setup": "setupEnvironment",
                "loop": "executeLoop",
                "serialEventRun": "handleSerialEvents"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "loop",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f8c": {
            "entrypoint": "0x08005f8c",
            "current_name": "calculate_number_of_bits_08005f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t calculateNumberOfBits_08005f8c(uint16_t inputPin)\n\n{\n  uint bitCount;\n  uint8_t numberOfBits;\n  \n  numberOfBits = '\\0';\n  for (bitCount = (uint)inputPin; bitCount != 1; bitCount = bitCount >> 1) {\n    numberOfBits = numberOfBits + '\\x01';\n  }\n  return numberOfBits;\n}\n\n",
            "renaming": {
                "FUN_08005f8c": "calculate_number_of_bits_08005f8c",
                "pin": "inputPin",
                "uVar1": "bitCount",
                "uVar2": "numberOfBits"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fa0": {
            "entrypoint": "0x08005fa0",
            "current_name": "deallocate_gpio_irq_conf_08005fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deallocate_gpio_irq_conf_08005fa0(void *ptr)\n\n{\n  gpio_irq_conf_str *current_node;\n  _Manager_type manager;\n  gpio_irq_conf_str *next_node;\n  \n  current_node = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (next_node = current_node, next_node != gpio_irq_conf) {\n    manager = next_node[-1].callback.super__Function_base._M_manager;\n    current_node = next_node + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&next_node[-1].callback,(_Any_data *)&next_node[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fa0": "deallocate_gpio_irq_conf_08005fa0",
                "param_1": "ptr",
                "pgVar1": "current_node",
                "p_Var2": "manager",
                "pgVar3": "next_node"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fc8": {
            "entrypoint": "0x08005fc8",
            "current_name": "initialize_gpio_irq_conf_08005fc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_conf_08005fc8(int enable_irq_config,int priority)\n\n{\n  if (enable_irq_config != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_interrupt_configuration[0].irqnb = EXTI0_IRQn;\n    gpio_interrupt_configuration[0].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[1].irqnb = EXTI1_IRQn;\n    gpio_interrupt_configuration[1].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[2].irqnb = EXTI2_IRQn;\n    gpio_interrupt_configuration[2].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[3].irqnb = EXTI3_IRQn;\n    gpio_interrupt_configuration[3].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[4].irqnb = EXTI4_IRQn;\n    gpio_interrupt_configuration[4].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[5].irqnb = EXTI9_5_IRQn;\n    gpio_interrupt_configuration[5].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[6].irqnb = EXTI9_5_IRQn;\n    gpio_interrupt_configuration[6].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[7].irqnb = EXTI9_5_IRQn;\n    gpio_interrupt_configuration[7].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[8].irqnb = EXTI9_5_IRQn;\n    gpio_interrupt_configuration[8].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[9].irqnb = EXTI9_5_IRQn;\n    gpio_interrupt_configuration[9].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[10].irqnb = EXTI15_10_IRQn;\n    gpio_interrupt_configuration[10].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[11].irqnb = EXTI15_10_IRQn;\n    gpio_interrupt_configuration[11].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[12].irqnb = EXTI15_10_IRQn;\n    gpio_interrupt_configuration[12].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[13].irqnb = EXTI15_10_IRQn;\n    gpio_interrupt_configuration[13].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[14].irqnb = EXTI15_10_IRQn;\n    gpio_interrupt_configuration[14].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[15].irqnb = EXTI15_10_IRQn;\n    gpio_interrupt_configuration[15].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    __aeabi_atexit(0,0x8005fa1,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fc8": "initialize_gpio_irq_conf_08005fc8",
                "__initialize_p": "enable_irq_config",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_interrupt_configuration"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006074": {
            "entrypoint": "0x08006074",
            "current_name": "handle_exti_interrupt_08006074",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_EXTI_interrupt_08006074(void)\n\n{\n  handle_GPIO_EXTI_interrupt(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006074": "handle_exti_interrupt_08006074",
                "HAL_GPIO_EXTI_IRQHandler": "handle_GPIO_EXTI_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800607e": {
            "entrypoint": "0x0800607e",
            "current_name": "handle_gpio_exti_0800607e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_0800607e(void)\n\n{\n  process_EXTI_IRQ(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800607e": "handle_gpio_exti_0800607e",
                "HAL_GPIO_EXTI_IRQHandler": "process_EXTI_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006088": {
            "entrypoint": "0x08006088",
            "current_name": "handle_gpio_exti_irq_08006088",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_irq_08006088(void)\n\n{\n  handle_EXTI_interrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006088": "handle_gpio_exti_irq_08006088",
                "HAL_GPIO_EXTI_IRQHandler": "handle_EXTI_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "handle_external_interrupt_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006092(void)\n\n{\n  triggerExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006092": "handle_external_interrupt_08006092",
                "HAL_GPIO_EXTI_IRQHandler": "triggerExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800609c": {
            "entrypoint": "0x0800609c",
            "current_name": "handle_gpio_exti_interrupt_0800609c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupt_0800609c(void)\n\n{\n  handle_EXTI_interrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800609c": "handle_gpio_exti_interrupt_0800609c",
                "HAL_GPIO_EXTI_IRQHandler": "handle_EXTI_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060a6": {
            "entrypoint": "0x080060a6",
            "current_name": "handle_interrupts_080060a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupts_080060a6(void)\n\n{\n  uint currentMask;\n  \n  for (currentMask = 0x20; currentMask < 0x201; currentMask = currentMask << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)currentMask);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060a6": "handle_interrupts_080060a6",
                "uVar1": "currentMask"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060bc": {
            "entrypoint": "0x080060bc",
            "current_name": "handle_gpio_exti_interrupts_080060bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupts_080060bc(void)\n\n{\n  uint loop_counter;\n  \n  for (loop_counter = 0x400; loop_counter < 0x8001; loop_counter = loop_counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loop_counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060bc": "handle_gpio_exti_interrupts_080060bc",
                "uVar1": "loop_counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060d4": {
            "entrypoint": "0x080060d4",
            "current_name": "invoke_function_080060d4",
            "code": "\n/* DWARF original prototype: invokeFunction_080060d4  operator()(function<invokeFunction_080060d4()> * functionPointer) */\n\ninvokeFunction_080060d4 __functionPointercall std::function<invokeFunction_080060d4()>::invoke_function_080060d4(function<invokeFunction_080060d4()> *functionPointer)\n\n{\n  if ((functionPointer->base).manager != (_Manager_type)0x0) {\n    (*functionPointer->invoker)((data *)functionPointer);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPointer",
                "super__Function_base": "base",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "_Any_data": "data",
                "void": "invokeFunction",
                "FUN_080060d4": "invoke_function_080060d4"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060e4": {
            "entrypoint": "0x080060e4",
            "current_name": "handle_gpio_irq_080060e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_irq_080060e4(uint16_t pin)\n\n{\n  byte pin_id;\n  uint8_t irq_id;\n  \n  pin_id = get_pin_id(pin);\n  if (gpio_irq_conf[pin_id].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pin_id].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060e4": "handle_gpio_irq_080060e4",
                "GPIO_Pin": "pin",
                "bVar1": "pin_id"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006104": {
            "entrypoint": "0x08006104",
            "current_name": "initialize_static_data_08006104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08006104(void)\n\n{\n  perform_static_initialization_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006104": "initialize_static_data_08006104",
                "__static_initialization_and_destruction_0": "perform_static_initialization_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006112": {
            "entrypoint": "0x08006112",
            "current_name": "register_cleanup_function_08006112",
            "code": "\nvoid registerCleanupFunction_08006112(undefined4 exitHandler,undefined4 userData)\n\n{\n  __cxa_atexit(userData,exitHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006112": "register_cleanup_function_08006112",
                "param_1": "exitHandler",
                "param_2": "userData"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800611c": {
            "entrypoint": "0x0800611c",
            "current_name": "log_assertion_error_and_abort_0800611c",
            "code": "\nvoid LogAssertionErrorAndAbort_0800611c(undefined4 fileName,undefined4 lineNumber,char *functionName,undefined4 assertionMessage)\n\n{\n  char *separator;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    separator = functionName;\n  }\n  else {\n    separator = \", function: \";\n  }\n  fiprintf(*(FILE **)(filePtr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertionMessage,fileName,lineNumber,separator,functionName,assertionMessage);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800611c": "log_assertion_error_and_abort_0800611c",
                "param_1": "fileName",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "assertionMessage",
                "pcVar1": "separator",
                "_impure_ptr": "filePtr"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006158": {
            "entrypoint": "0x08006158",
            "current_name": "shift_unsigned_integer_08006158",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong shiftUnsignedInteger_08006158(undefined4 inputFlag,uint inputValue)\n\n{\n  return (ulonglong)inputValue << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08006158": "shift_unsigned_integer_08006158",
                "param_1": "inputFlag",
                "param_2": "inputValue"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006174": {
            "entrypoint": "0x08006174",
            "current_name": "printf_to_file_08006174",
            "code": "\nint printfToFile_08006174(FILE *file,char *format,...)\n\n{\n  int result;\n  undefined4 unused1;\n  undefined4 unused2;\n  undefined4 unused3;\n  undefined4 unused4;\n  \n  unused3 = unused1;\n  unused4 = unused2;\n  result = _vfiprintf_r(_impure_ptr,file,format,&unused3,file,&unused3);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006174": "printf_to_file_08006174",
                "__stream": "file",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "unused1",
                "in_r3": "unused2",
                "uStack_8": "unused3",
                "uStack_4": "unused4"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006198": {
            "entrypoint": "0x08006198",
            "current_name": "initialize_pre_init_array_08006198",
            "code": "\nvoid initializePreInitArray_08006198(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&preInitArrayEnd)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&preInitArrayEnd)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006198": "initialize_pre_init_array_08006198",
                "iVar1": "index",
                "__preinit_array_end": "preInitArrayEnd"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061e0": {
            "entrypoint": "0x080061e0",
            "current_name": "memset_080061e0",
            "code": "\nvoid * memset_080061e0(void *ptr,int value,size_t num_bytes)\n\n{\n  undefined *byte_ptr;\n  \n  for (byte_ptr = (undefined *)ptr; byte_ptr != (undefined *)(num_bytes + (int)ptr); byte_ptr = byte_ptr + 1) {\n    *byte_ptr = (char)value;\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_080061e0": "memset_080061e0",
                "__s": "ptr",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "byte_ptr"
            },
            "calling": [
                "std.isra.0",
                "__sfp",
                "adc_read_value",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061f0": {
            "entrypoint": "0x080061f0",
            "current_name": "allocate_memory_080061f0",
            "code": "\nvoid allocateMemory_080061f0(undefined4 *status,int size,undefined4 unused1,undefined4 unused2)\n\n{\n  int **additionalPtr;\n  int **currentPtr;\n  int **nextPtr;\n  int *tmpPtr;\n  int **prevPtr;\n  int **allocatedPtr;\n  \n  if (size == 0) {\n    return;\n  }\n  allocatedPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    allocatedPtr = (int **)((int)allocatedPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  nextPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    allocatedPtr[1] = (int *)0x0;\n    currentPtr = additionalPtr;\n    __malloc_free_list = allocatedPtr;\n  }\n  else {\n    nextPtr = __malloc_free_list;\n    if (allocatedPtr < __malloc_free_list) {\n      currentPtr = (int **)*allocatedPtr;\n      nextPtr = (int **)((int)allocatedPtr + (int)currentPtr);\n      if (__malloc_free_list == nextPtr) {\n        tmpPtr = *__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n        nextPtr = (int **)((int)tmpPtr + (int)currentPtr);\n        *allocatedPtr = (int *)nextPtr;\n      }\n      allocatedPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = allocatedPtr;\n    }\n    else {\n      do {\n        prevPtr = nextPtr;\n        nextPtr = (int **)prevPtr[1];\n        if (nextPtr == (int **)0x0) break;\n      } while (nextPtr <= allocatedPtr);\n      currentPtr = (int **)*prevPtr;\n      if ((int **)((int)prevPtr + (int)currentPtr) == allocatedPtr) {\n        currentPtr = (int **)((int)currentPtr + (int)*allocatedPtr);\n        *prevPtr = (int *)currentPtr;\n        if (nextPtr == (int **)((int)prevPtr + (int)currentPtr)) {\n          tmpPtr = *nextPtr;\n          nextPtr = (int **)nextPtr[1];\n          currentPtr = (int **)((int)currentPtr + (int)tmpPtr);\n          *prevPtr = (int *)currentPtr;\n          prevPtr[1] = (int *)nextPtr;\n        }\n      }\n      else if (allocatedPtr < (int **)((int)prevPtr + (int)currentPtr)) {\n        *status = 0xc;\n      }\n      else {\n        currentPtr = (int **)((int)allocatedPtr + (int)*allocatedPtr);\n        if (nextPtr == currentPtr) {\n          tmpPtr = *nextPtr;\n          nextPtr = (int **)nextPtr[1];\n          currentPtr = (int **)((int)tmpPtr + (int)*allocatedPtr);\n          *allocatedPtr = (int *)currentPtr;\n        }\n        allocatedPtr[1] = (int *)nextPtr;\n        prevPtr[1] = (int *)allocatedPtr;\n      }\n    }\n  }\n  __malloc_unlock(status,currentPtr,nextPtr,unused2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061f0": "allocate_memory_080061f0",
                "param_1": "status",
                "param_2": "size",
                "param_3": "unused1",
                "param_4": "unused2",
                "extraout_r1": "additionalPtr",
                "ppiVar1": "currentPtr",
                "ppiVar2": "nextPtr",
                "piVar3": "tmpPtr",
                "ppiVar4": "prevPtr",
                "ppiVar5": "allocatedPtr"
            },
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006288": {
            "entrypoint": "0x08006288",
            "current_name": "allocate_memory_08006288",
            "code": "\nuint allocate_memory_08006288(undefined4 *output_ptr,uint size)\n\n{\n  uint *current_chunk;\n  int remaining_space;\n  uint *prev_chunk;\n  uint chunk_diff;\n  uint *prev_chunk_next;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *output_ptr = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_chunk = __malloc_free_list;\n    prev_chunk_next = __malloc_free_list;\n    while (prev_chunk = current_chunk, prev_chunk != (uint *)0x0) {\n      chunk_diff = *prev_chunk - allocated_size;\n      if (-1 < (int)chunk_diff) {\n        if (chunk_diff < 0xc) {\n          if (prev_chunk_next == prev_chunk) {\n            current_chunk = (uint *)prev_chunk_next[1];\n            __malloc_free_list = current_chunk;\n          }\n          else {\n            current_chunk = (uint *)prev_chunk[1];\n          }\n          if (prev_chunk_next != prev_chunk) {\n            prev_chunk_next[1] = (uint)current_chunk;\n            prev_chunk_next = prev_chunk;\n          }\n        }\n        else {\n          *prev_chunk = chunk_diff;\n          *(uint *)((int)prev_chunk + chunk_diff) = allocated_size;\n          prev_chunk_next = (uint *)((int)prev_chunk + chunk_diff);\n        }\n        goto LAB_080062ec;\n      }\n      prev_chunk_next = prev_chunk;\n      current_chunk = (uint *)prev_chunk[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(output_ptr);\n    }\n    current_chunk = (uint *)_sbrk_r(output_ptr,allocated_size);\n    if ((current_chunk != (uint *)0xffffffff) &&\n       ((prev_chunk_next = (uint *)((int)current_chunk + 3U & 0xfffffffc), current_chunk == prev_chunk_next ||\n        (remaining_space = _sbrk_r(output_ptr,(int)prev_chunk_next - (int)current_chunk), remaining_space != -1)))) {\n      *prev_chunk_next = allocated_size;\nLAB_080062ec:\n      __malloc_unlock(output_ptr);\n      allocated_size = (int)prev_chunk_next + 0xbU & 0xfffffff8;\n      remaining_space = allocated_size - (int)(prev_chunk_next + 1);\n      if (remaining_space != 0) {\n        *(int *)((int)prev_chunk_next + remaining_space) = -remaining_space;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *output_ptr = 0xc;\n    __malloc_unlock(output_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006288": "allocate_memory_08006288",
                "param_1": "output_ptr",
                "param_2": "size",
                "puVar1": "current_chunk",
                "iVar2": "remaining_space",
                "puVar3": "prev_chunk",
                "uVar4": "chunk_diff",
                "puVar5": "prev_chunk_next",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006344": {
            "entrypoint": "0x08006344",
            "current_name": "write_byte_to_stream_08006344",
            "code": "\nuint write_byte_to_stream_08006344(undefined4 stream,byte byte_to_write,byte **stream_buf)\n\n{\n  uint result;\n  byte *last_byte_in_buf;\n  \n  last_byte_in_buf = stream_buf[2] + -1;\n  stream_buf[2] = last_byte_in_buf;\n  if (((int)last_byte_in_buf < 0) && (((int)last_byte_in_buf < (int)stream_buf[6] || (byte_to_write == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  last_byte_in_buf = *stream_buf;\n  *stream_buf = last_byte_in_buf + 1;\n  *last_byte_in_buf = byte_to_write;\n  return (uint)byte_to_write;\n}\n\n",
            "renaming": {
                "FUN_08006344": "write_byte_to_stream_08006344",
                "param_1": "stream",
                "param_2": "byte_to_write",
                "param_3": "stream_buf",
                "uVar1": "result",
                "pbVar2": "last_byte_in_buf"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006370": {
            "entrypoint": "0x08006370",
            "current_name": "write_to_stream_08006370",
            "code": "\nint write_to_stream_08006370(undefined4 stream,undefined4 character,undefined *buffer,int count)\n\n{\n  int result;\n  undefined *end_of_buffer;\n  int remaining_count;\n  \n  end_of_buffer = buffer + count;\n  remaining_count = count;\n  do {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*buffer,character,count,remaining_count);\n    count = result + 1;\n    buffer = buffer + 1;\n  } while (count != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006370": "write_to_stream_08006370",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "count",
                "puVar2": "end_of_buffer",
                "iVar1": "result",
                "iVar3": "remaining_count"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006394": {
            "entrypoint": "0x08006394",
            "current_name": "print_formatted_text_08006394",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint printFormattedText_08006394(int stream,undefined4 *format,byte *text,int *bytesWritten)\n\n{\n  bool isDigit;\n  int status;\n  void *charPtr;\n  int *intPtr;\n  byte *bytePtr1;\n  byte *bytePtr2;\n  int intVar1;\n  int value;\n  int *bytesWrittenPtr;\n  uint formatFlags;\n  int precision;\n  undefined4 padding;\n  int width;\n  int totalBytesWritten;\n  byte specifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined prefixFlag;\n  undefined4 extraFlag;\n  \n  bytesWrittenPtr = bytesWritten;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &__sf_fake_stdin) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stdout) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stderr) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (value = __swsetup_r(stream,format), value != 0)) {\n    return -1;\n  }\n  totalBytesWritten = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  bytePtr1 = text;\nLAB_080063d6:\n  bytePtr2 = bytePtr1;\n  if (*bytePtr2 != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  bytePtr1 = bytePtr2 + 1;\n  if (*bytePtr2 != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  value = (int)bytePtr2 - (int)text;\n  if (value != 0) {\n    status = __sfputs_r(stream,format,text,value);\n    if (status == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalBytesWritten;\n    }\n    totalBytesWritten = totalBytesWritten + value;\n  }\n  if (*bytePtr2 == 0) goto LAB_08006580;\n  formatFlags = 0;\n  width = 0;\n  precision = -1;\n  padding = 0;\n  prefixFlag = 0;\n  extraFlag = 0;\n  bytePtr1 = bytePtr2 + 1;\n  while( true ) {\n    charPtr = memchr(\"#-0+ \",(uint)*bytePtr1,5);\n    text = bytePtr1 + 1;\n    if (charPtr == (void *)0x0) break;\n    formatFlags = 1 << ((int)charPtr + 0xf7ff8750U & 0xff) | formatFlags;\n    bytePtr1 = text;\n  }\n  if ((int)(formatFlags << 0x1b) < 0) {\n    prefixFlag = 0x20;\n  }\n  if ((int)(formatFlags << 0x1c) < 0) {\n    prefixFlag = 0x2b;\n  }\n  if (*bytePtr1 == 0x2a) {\n    intPtr = bytesWrittenPtr + 1;\n    value = *bytesWrittenPtr;\n    bytesWrittenPtr = intPtr;\n    if (value < 0) {\n      width = -value;\n      formatFlags = formatFlags | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    isDigit = false;\n    value = width;\n    text = bytePtr1;\n    while( true ) {\n      if (9 < *text - 0x30) break;\n      value = value * 10 + (*text - 0x30);\n      isDigit = true;\n      text = text + 1;\n    }\n    if (!isDigit) goto LAB_080064be;\n  }\n  width = value;\nLAB_080064be:\n  if (*text == 0x2e) {\n    if (text[1] == 0x2a) {\n      text = text + 2;\n      intPtr = bytesWrittenPtr + 1;\n      precision = *bytesWrittenPtr;\n      bytesWrittenPtr = intPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isDigit = false;\n      value = 0;\n      precision = 0;\n      while( true ) {\n        text = text + 1;\n        if (9 < *text - 0x30) break;\n        value = value * 10 + (*text - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = value;\n      }\n    }\n  }\n  charPtr = memchr(&DAT_080078b6,(uint)*text,3);\n  if (charPtr != (void *)0x0) {\n    text = text + 1;\n    formatFlags = formatFlags | 0x40 << ((int)charPtr + 0xf7ff874aU & 0xff);\n  }\n  specifier = *text;\n  text = text + 1;\n  charPtr = memchr(\"efgEFG\",(uint)specifier,6);\n  if (charPtr == (void *)0x0) {\n    intVar1 = _printf_i(stream,&formatFlags,format,0x8006371,&bytesWrittenPtr);\n    if (intVar1 == -1) goto LAB_08006580;\n  }\n  else {\n    bytesWrittenPtr = (int *)(((int)bytesWrittenPtr + 7U & 0xfffffff8) + 8);\n  }\n  totalBytesWritten = totalBytesWritten + intVar1;\n  bytePtr1 = text;\n  goto LAB_080063d6;\n}\n\n",
            "renaming": {
                "FUN_08006394": "print_formatted_text_08006394",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "text",
                "param_4": "bytesWritten",
                "bVar1": "isDigit",
                "iVar2": "status",
                "pvVar3": "charPtr",
                "piVar4": "intPtr",
                "pbVar5": "bytePtr1",
                "pbVar6": "bytePtr2",
                "unaff_r9": "intVar1",
                "iVar7": "value",
                "local_8c": "bytesWrittenPtr",
                "local_88": "formatFlags",
                "local_84": "precision",
                "local_80": "padding",
                "local_7c": "width",
                "local_74": "totalBytesWritten",
                "local_70": "specifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "prefixFlag",
                "local_30": "extraFlag"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080065c0": {
            "entrypoint": "0x080065c0",
            "current_name": "update_parameters_080065c0",
            "code": "\nundefined4\nupdateParameters_080065c0(undefined4 input,uint *params,uint *maxValue,undefined4 flag,code *callback)\n\n{\n  int result;\n  int status;\n  uint currentValue;\n  uint newValue;\n  bool isSet;\n  \n  currentValue = params[4];\n  if ((int)params[4] < (int)params[2]) {\n    currentValue = params[2];\n  }\n  *maxValue = currentValue;\n  if (*(char *)((int)params + 0x43) != '\\0') {\n    *maxValue = currentValue + 1;\n  }\n  if ((int)(*params << 0x1a) < 0) {\n    *maxValue = *maxValue + 2;\n  }\n  if ((*params & 6) == 0) {\n    for (result = 0; result < (int)(params[3] - *maxValue); result = result + 1) {\n      status = (*callback)(input,flag,(int)params + 0x19,1);\n      if (status == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  currentValue = (uint)*(byte *)((int)params + 0x43);\n  if (currentValue != 0) {\n    currentValue = 1;\n  }\n  newValue = currentValue;\n  if ((int)(*params << 0x1a) < 0) {\n    *(undefined *)((int)params + currentValue + 0x43) = 0x30;\n    newValue = currentValue + 2;\n    *(undefined *)((int)params + currentValue + 0x44) = *(undefined *)((int)params + 0x45);\n  }\n  result = (*callback)(input,flag,(int)params + 0x43,newValue);\n  if (result != -1) {\n    currentValue = params[3];\n    isSet = (*params & 6) != 4;\n    if (isSet) {\n      currentValue = 0;\n    }\n    newValue = 0;\n    if (!isSet) {\n      currentValue = currentValue - *maxValue;\n    }\n    if (!isSet) {\n      currentValue = currentValue & ~((int)currentValue >> 0x1f);\n    }\n    if ((int)params[4] < (int)params[2]) {\n      currentValue = currentValue + (params[2] - params[4]);\n    }\n    while( true ) {\n      if (currentValue == newValue) {\n        return 0;\n      }\n      result = (*callback)(input,flag,(int)params + 0x1a,1);\n      if (result == -1) break;\n      newValue = newValue + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080065c0": "update_parameters_080065c0",
                "param_1": "input",
                "param_2": "params",
                "param_3": "maxValue",
                "param_4": "flag",
                "param_5": "callback",
                "iVar1": "result",
                "iVar2": "status",
                "uVar3": "currentValue",
                "uVar4": "newValue",
                "bVar5": "isSet"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066b0": {
            "entrypoint": "0x080066b0",
            "current_name": "print_formatted_data_080066b0",
            "code": "\nuint print_formatted_data_080066b0(undefined4 format_string,uint *format_args,undefined4 width,code *print_function,uint **arg_list)\n\n{\n  byte type_specifier;\n  int num_printed_chars;\n  uint *current_arg;\n  void *null_ptr;\n  int printf_result;\n  char *digits;\n  uint format_flags;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint current_value;\n  uint field_width;\n  char *format_result;\n  char *str_value;\n  uint width_arr [2];\n  \n  type_specifier = *(byte *)(format_args + 6);\n  str_value = (char *)((int)format_args + 0x43);\n  if (type_specifier != 0x6e) {\n    if (type_specifier < 0x6f) {\n      if (type_specifier != 99) {\n        if (type_specifier < 100) {\n          if (type_specifier == 0) goto LAB_0800686a;\n          if (type_specifier != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)format_args + 0x45) = 0x58;\n          digits = \"0123456789ABCDEF\";\nLAB_080067fa:\n          format_flags = *format_args;\n          current_arg = *arg_list;\n          *arg_list = current_arg + 1;\n          if (((format_flags & 0x80) == 0) && ((int)(format_flags << 0x19) < 0)) {\n            current_value = (uint)*(ushort *)current_arg;\n          }\n          else {\n            current_value = *current_arg;\n          }\n          if ((int)(format_flags << 0x1f) < 0) {\n            *format_args = format_flags | 0x20;\n          }\n          if (current_value == 0) {\n            *format_args = *format_args & 0xffffffdf;\n          }\n          format_flags = 0x10;\nLAB_08006790:\n          *(undefined *)((int)format_args + 0x43) = 0;\n        }\n        else {\n          if ((type_specifier != 100) && (type_specifier != 0x69)) goto LAB_080066e0;\n          current_value = *format_args;\n          current_arg = *arg_list;\n          if ((current_value & 0x80) == 0) {\n            *arg_list = current_arg + 1;\n            if ((current_value & 0x40) == 0) goto LAB_08006700;\n            current_value = (uint)(short)*(ushort *)current_arg;\n          }\n          else {\n            *arg_list = current_arg + 1;\nLAB_08006700:\n            current_value = *current_arg;\n          }\n          if ((int)current_value < 0) {\n            current_value = -current_value;\n            *(undefined *)((int)format_args + 0x43) = 0x2d;\n          }\n          digits = \"0123456789ABCDEF\";\n          format_flags = 10;\n        }\n        field_width = format_args[1];\n        format_args[2] = field_width;\n        format_result = str_value;\n        if ((int)field_width < 0) {\n          if (current_value != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)format_args + 0x42) = *digits;\n          format_result = (char *)((int)format_args + 0x42);\n        }\n        else {\n          *format_args = *format_args & 0xfffffffb;\n          if (current_value == 0) {\n            if (field_width != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              field_width = current_value / format_flags;\n              format_result = format_result + -1;\n              *format_result = digits[current_value - format_flags * field_width];\n              current_value = field_width;\n            } while (field_width != 0);\n          }\n        }\n        if (((format_flags == 8) && ((int)(*format_args << 0x1f) < 0)) && ((int)format_args[1] <= (int)format_args[4]))\n        {\n          format_result[-1] = '0';\n          format_result = format_result + -1;\n        }\n        format_args[4] = (int)str_value - (int)format_result;\n        str_value = format_result;\n        goto LAB_080067d6;\n      }\n      current_arg = *arg_list;\n      *arg_list = current_arg + 1;\n      *(char *)((int)format_args + 0x42) = (char)*current_arg;\nLAB_08006740:\n      str_value = (char *)((int)format_args + 0x42);\n      current_value = 1;\n    }\n    else {\n      if (type_specifier != 0x73) {\n        if (type_specifier < 0x74) {\n          if (type_specifier == 0x6f) {\nLAB_08006766:\n            current_value = *format_args;\n            current_arg = *arg_list;\n            if ((current_value & 0x80) == 0) {\n              *arg_list = current_arg + 1;\n              if ((current_value & 0x40) == 0) goto LAB_08006774;\n              current_value = (uint)*(ushort *)current_arg;\n            }\n            else {\n              *arg_list = current_arg + 1;\nLAB_08006774:\n              current_value = *current_arg;\n            }\n            if (type_specifier == 0x6f) {\n              format_flags = 8;\n            }\n            else {\n              format_flags = 10;\n            }\n            digits = \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (type_specifier == 0x70) {\n            *format_args = *format_args | 0x20;\nLAB_08006726:\n            digits = \"0123456789abcdef\";\n            *(undefined *)((int)format_args + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (type_specifier == 0x75) goto LAB_08006766;\n          if (type_specifier == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)format_args + 0x42) = type_specifier;\n        goto LAB_08006740;\n      }\n      ppcVar9 = (char **)*arg_list;\n      *arg_list = (uint *)(ppcVar9 + 1);\n      str_value = *ppcVar9;\n      null_ptr = memchr(str_value,0,format_args[1]);\n      if (null_ptr != (void *)0x0) {\n        format_args[1] = (int)null_ptr - (int)str_value;\n      }\n      current_value = format_args[1];\n    }\n    format_args[4] = current_value;\n    *(undefined *)((int)format_args + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  current_value = *format_args;\n  ppuVar8 = (uint **)*arg_list;\n  format_flags = format_args[5];\n  if ((current_value & 0x80) == 0) {\n    *arg_list = (uint *)(ppuVar8 + 1);\n    current_arg = *ppuVar8;\n    if ((current_value & 0x40) == 0) goto LAB_08006856;\n    *(short *)current_arg = (short)format_flags;\n  }\n  else {\n    *arg_list = (uint *)(ppuVar8 + 1);\n    current_arg = *ppuVar8;\nLAB_08006856:\n    *current_arg = format_flags;\n  }\nLAB_0800686a:\n  format_args[4] = 0;\nLAB_080067d6:\n  num_printed_chars = _printf_common(format_string,format_args,width_arr,width,print_function);\n  if ((num_printed_chars == -1) || (num_printed_chars = (*print_function)(format_string,width,str_value,format_args[4]), num_printed_chars == -1)) {\nLAB_080067ea:\n    current_value = 0xffffffff;\n  }\n  else {\n    if ((int)(*format_args << 0x1e) < 0) {\n      for (num_printed_chars = 0; num_printed_chars < (int)(format_args[3] - width_arr[0]); num_printed_chars = num_printed_chars + 1) {\n        printf_result = (*print_function)(format_string,width,(int)format_args + 0x19,1);\n        if (printf_result == -1) goto LAB_080067ea;\n      }\n    }\n    current_value = format_args[3];\n    if ((int)format_args[3] < (int)width_arr[0]) {\n      current_value = width_arr[0];\n    }\n  }\n  return current_value;\n}\n\n",
            "renaming": {
                "FUN_080066b0": "print_formatted_data_080066b0",
                "param_1": "format_string",
                "param_2": "format_args",
                "param_3": "width",
                "param_4": "print_function",
                "param_5": "arg_list",
                "bVar1": "type_specifier",
                "iVar2": "num_printed_chars",
                "puVar3": "current_arg",
                "pvVar4": "null_ptr",
                "iVar5": "printf_result",
                "pcVar6": "digits",
                "uVar7": "format_flags",
                "uVar10": "current_value",
                "uVar11": "field_width",
                "pcVar12": "format_result",
                "__s": "str_value",
                "local_24": "width_arr"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068f0": {
            "entrypoint": "0x080068f0",
            "current_name": "formatted_print_080068f0",
            "code": "\nint formattedPrint_080068f0(char *formatString,...)\n\n{\n  int impure;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *formatPtr;\n  undefined4 regRetVal;\n  undefined4 arg1;\n  undefined4 arg2;\n  \n  impure = _impure_ptr;\n  formatPtr = formatString;\n  regRetVal = in_r1;\n  arg1 = in_r2;\n  arg2 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impure = _vfiprintf_r(impure,*(undefined4 *)(impure + 8),formatString,&regRetVal,formatPtr,&regRetVal);\n  return impure;\n}\n\n",
            "renaming": {
                "FUN_080068f0": "formatted_print_080068f0",
                "__format": "formatString",
                "iVar1": "impure",
                "pcVar2": "formatPtr",
                "uStack_c": "regRetVal",
                "uStack_8": "arg1",
                "uStack_4": "arg2"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006920": {
            "entrypoint": "0x08006920",
            "current_name": "allocate_memory_08006920",
            "code": "\nvoid allocateMemory_08006920(int *error,intptr_t size)\n\n{\n  void *ptr;\n  \n  errorNumber = 0;\n  ptr = _sbrk(size);\n  if ((ptr == (void *)0xffffffff) && (errorNumber != 0)) {\n    *error = errorNumber;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006920": "allocate_memory_08006920",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "ptr",
                "errno": "errorNumber"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006940": {
            "entrypoint": "0x08006940",
            "current_name": "write_character_08006940",
            "code": "\nuint write_character_08006940(int file,uint character,int *stream,undefined4 buf_mode)\n\n{\n  int result;\n  uint ushort_val;\n  undefined *byte_ptr;\n  \n  if ((file != 0) && (*(int *)(file + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(file + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(file + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(file + 0xc);\n  }\n  stream[2] = stream[6];\n  ushort_val = (uint)*(ushort *)(stream + 3);\n  result = ushort_val << 0x1c;\n  if (((result < 0) && (ushort_val = stream[4], ushort_val != 0)) ||\n     (result = __swsetup_r(file,stream,result,ushort_val,buf_mode), result == 0)) {\n    character = character & 0xff;\n    result = *stream - stream[4];\n    if ((result < stream[5]) || (result = _fflush_r(file,stream), result == 0)) {\n      stream[2] = stream[2] + -1;\n      byte_ptr = (undefined *)*stream;\n      *stream = (int)(byte_ptr + 1);\n      *byte_ptr = (char)character;\n      if (result + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      result = _fflush_r(file,stream);\n      if (result == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08006940": "write_character_08006940",
                "param_1": "file",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "buf_mode",
                "iVar1": "result",
                "uVar2": "ushort_val",
                "puVar3": "byte_ptr"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "check_and_update_file_status_080069e4",
            "code": "\nuint checkAndUpdateFileStatus_080069e4(undefined4 *inputFileType,undefined4 *inputFile)\n\n{\n  int impurePtr;\n  uint fileStatus;\n  ushort fileAttributes;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (inputFile == &__sf_fake_stdin) {\n    inputFile = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (inputFile == (undefined4 *)&__sf_fake_stdout) {\n    inputFile = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (inputFile == (undefined4 *)&__sf_fake_stderr) {\n    inputFile = *(undefined4 **)(impurePtr + 0xc);\n  }\n  fileAttributes = *(ushort *)(inputFile + 3);\n  fileStatus = (uint)fileAttributes;\n  if (-1 < (int)(fileStatus << 0x1c)) {\n    if (-1 < (int)(fileStatus << 0x1b)) {\n      *inputFileType = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(fileStatus << 0x1d) < 0) {\n      if ((undefined4 *)inputFile[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)inputFile[0xd] != inputFile + 0x11) {\n          _free_r(inputFileType);\n        }\n        inputFile[0xd] = 0;\n      }\n      *(ushort *)(inputFile + 3) = *(ushort *)(inputFile + 3) & 0xffdb;\n      inputFile[1] = 0;\n      *inputFile = inputFile[4];\n    }\n    *(ushort *)(inputFile + 3) = *(ushort *)(inputFile + 3) | 8;\n  }\n  if ((inputFile[4] == 0) && ((*(ushort *)(inputFile + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(inputFileType,inputFile);\n  }\n  fileAttributes = *(ushort *)(inputFile + 3);\n  fileStatus = fileAttributes & 1;\n  if ((fileAttributes & 1) == 0) {\n    if (-1 < (int)((uint)fileAttributes << 0x1e)) {\n      fileStatus = inputFile[5];\n    }\n    inputFile[2] = fileStatus;\n  }\n  else {\n    inputFile[2] = 0;\n    inputFile[6] = -inputFile[5];\n  }\n  if (inputFile[4] == 0) {\n    fileAttributes = *(ushort *)(inputFile + 3);\n    fileStatus = (int)(short)fileAttributes & 0x80;\n    if (fileStatus != 0) {\nLAB_08006a14:\n      *(ushort *)(inputFile + 3) = fileAttributes | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    fileStatus = 0;\n  }\n  return fileStatus;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "check_and_update_file_status_080069e4",
                "param_1": "inputFileType",
                "param_2": "inputFile",
                "iVar1": "impurePtr",
                "uVar2": "fileStatus",
                "uVar3": "fileAttributes"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "handle_signal_08006ac0",
            "code": "\n\n\nvoid handle_signal_08006ac0(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "handle_signal_08006ac0"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ad0": {
            "entrypoint": "0x08006ad0",
            "current_name": "process_data_08006ad0",
            "code": "\nundefined4 processData_08006ad0(uint *param1,int *param2)\n\n{\n  int counter;\n  int *tempPtr;\n  uint value;\n  ushort flags;\n  int increment;\n  code *callbackFunc;\n  int tempVar;\n  uint tempValue;\n  bool isZero;\n  \n  flags = *(ushort *)(param2 + 3);\n  value = (uint)flags;\n  if ((int)(value << 0x1c) < 0) {\n    counter = param2[4];\n    if (counter != 0) {\n      increment = value << 0x1e;\n      isZero = increment != 0;\n      if (isZero) {\n        increment = 0;\n      }\n      tempVar = *param2;\n      if (!isZero) {\n        increment = param2[5];\n      }\n      *param2 = counter;\n      param2[2] = increment;\n      for (tempVar = tempVar - counter; 0 < tempVar; tempVar = tempVar - increment) {\n        increment = (*(code *)param2[10])(param1,param2[8],counter,tempVar);\n        if (increment < 1) {\n          flags = *(ushort *)(param2 + 3);\n          goto LAB_08006bc6;\n        }\n        counter = counter + increment;\n      }\n    }\n  }\n  else if (((0 < param2[1]) || (0 < param2[0x10])) &&\n          (callbackFunc = (code *)param2[0xb], callbackFunc != (code *)0x0)) {\n    tempValue = *param1;\n    *param1 = 0;\n    if ((flags & 0x1000) == 0) {\n      counter = (*callbackFunc)(param1,param2[8],value & 0x1000,1);\n      if ((counter == -1) && (value = *param1, value != 0)) {\n        if ((value != 0x1d) && (value != 0x16)) {\n          *(ushort *)(param2 + 3) = *(ushort *)(param2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param1 = tempValue;\n        return 0;\n      }\n    }\n    else {\n      counter = param2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param2 + 3) << 0x1d) < 0) &&\n       (counter = counter - param2[1], param2[0xd] != 0)) {\n      counter = counter - param2[0x10];\n    }\n    counter = (*(code *)param2[0xb])(param1,param2[8],counter,0);\n    flags = *(ushort *)(param2 + 3);\n    if ((counter == -1) &&\n       ((0x1d < *param1 || (-1 < (int)((0x20400001U >> (*param1 & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(param2 + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    param2[1] = 0;\n    *param2 = param2[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((counter != -1 || (*param1 == 0)))) {\n      param2[0x15] = counter;\n    }\n    tempPtr = (int *)param2[0xd];\n    *param1 = tempValue;\n    if (tempPtr != (int *)0x0) {\n      if (tempPtr != param2 + 0x11) {\n        _free_r(param1);\n      }\n      param2[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006ad0": "process_data_08006ad0",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "counter",
                "piVar2": "tempPtr",
                "uVar3": "value",
                "uVar4": "flags",
                "iVar5": "increment",
                "pcVar6": "callbackFunc",
                "iVar7": "tempVar",
                "uVar8": "tempValue",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006be0": {
            "entrypoint": "0x08006be0",
            "current_name": "validate_and_flush_stream_08006be0",
            "code": "\nundefined4 validateAndFlushStream_08006be0(int streamPtr,undefined4 *filePtr,undefined4 arg3,undefined4 arg4)\n\n{\n  undefined4 result;\n  \n  if (filePtr[4] != 0) {\n    if ((streamPtr != 0) && (*(int *)(streamPtr + 0x18) == 0)) {\n      __sinit();\n    }\n    if (filePtr == &fakeStdinPtr) {\n      filePtr = *(undefined4 **)(streamPtr + 4);\n    }\n    else if (filePtr == (undefined4 *)&fakeStdoutPtr) {\n      filePtr = *(undefined4 **)(streamPtr + 8);\n    }\n    else if (filePtr == (undefined4 *)&fakeStderrPtr) {\n      filePtr = *(undefined4 **)(streamPtr + 0xc);\n    }\n    if (*(short *)(filePtr + 3) != 0) {\n      result = __sflush_r(streamPtr,filePtr,arg3,arg4);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006be0": "validate_and_flush_stream_08006be0",
                "param_1": "streamPtr",
                "param_2": "filePtr",
                "param_3": "arg3",
                "param_4": "arg4",
                "uVar1": "result",
                "__sf_fake_stdin": "fakeStdinPtr",
                "__sf_fake_stdout": "fakeStdoutPtr",
                "__sf_fake_stderr": "fakeStderrPtr"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c34": {
            "entrypoint": "0x08006c34",
            "current_name": "execute_fwalk_reent_08006c34",
            "code": "\nvoid execute_fwalk_reent_08006c34(undefined4 reent)\n\n{\n  _fwalk_reent(reent,0x8006be1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c34": "execute_fwalk_reent_08006c34",
                "param_1": "reent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c40": {
            "entrypoint": "0x08006c40",
            "current_name": "initialize_param_array_08006c40",
            "code": "\nvoid initializeParamArray_08006c40(undefined4 *paramArray,undefined2 value1,undefined2 value2)\n\n{\n  *paramArray = 0;\n  paramArray[1] = 0;\n  paramArray[2] = 0;\n  *(undefined2 *)(paramArray + 3) = value1;\n  paramArray[0x19] = 0;\n  *(undefined2 *)((int)paramArray + 0xe) = value2;\n  paramArray[4] = 0;\n  paramArray[5] = 0;\n  paramArray[6] = 0;\n  memset(paramArray + 0x17,0,8);\n  paramArray[8] = paramArray;\n  paramArray[9] = 0x8006f39;\n  paramArray[10] = 0x8006f5b;\n  paramArray[0xb] = 0x8006f93;\n  paramArray[0xc] = 0x8006fb7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c40": "initialize_param_array_08006c40",
                "param_1": "paramArray",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c88": {
            "entrypoint": "0x08006c88",
            "current_name": "allocate_and_initialize_array_08006c88",
            "code": "\nundefined4 * allocateAndInitializeArray_08006c88(undefined4 size,int count)\n\n{\n  undefined4 *arrayPointer;\n  int arraySize;\n  \n  arraySize = (count + -1) * 0x68;\n  arrayPointer = (undefined4 *)_malloc_r(size,arraySize + 0x74);\n  if (arrayPointer != (undefined4 *)0x0) {\n    *arrayPointer = 0;\n    arrayPointer[1] = count;\n    arrayPointer[2] = arrayPointer + 3;\n    memset(arrayPointer + 3,0,arraySize + 0x68);\n  }\n  return arrayPointer;\n}\n\n",
            "renaming": {
                "FUN_08006c88": "allocate_and_initialize_array_08006c88",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "arrayPointer",
                "iVar2": "arraySize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cb4": {
            "entrypoint": "0x08006cb4",
            "current_name": "initialize_data_08006cb4",
            "code": "\nvoid initializeData_08006cb4(undefined1 *dataPtr)\n\n{\n  undefined4 returnVar;\n  undefined1 *impureDataPtr;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    impureDataPtr = &impure_data;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8006c35;\n    if (dataPtr == &impure_data) {\n      impureDataPtr = (undefined1 *)0x1;\n    }\n    if (dataPtr == &impure_data) {\n      *(undefined1 **)(dataPtr + 0x18) = impureDataPtr;\n    }\n    returnVar = __sfp();\n    *(undefined4 *)(dataPtr + 4) = returnVar;\n    returnVar = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = returnVar;\n    returnVar = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = returnVar;\n    std_isra_0(*(undefined4 *)(dataPtr + 4),4,0);\n    std_isra_0(*(undefined4 *)(dataPtr + 8),9,1);\n    std_isra_0(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cb4": "initialize_data_08006cb4",
                "param_1": "dataPtr",
                "uVar1": "returnVar",
                "puVar2": "impureDataPtr"
            },
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "__sfp",
                "__swsetup_r",
                "iprintf",
                "_vfiprintf_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d14": {
            "entrypoint": "0x08006d14",
            "current_name": "initialize_data_structures_08006d14",
            "code": "\nint * initializeDataStructures_08006d14(undefined4 *status)\n\n{\n  int *nextPtr;\n  int *currentPtr;\n  int **list;\n  \n  if (DAT_20000114 == 0) {\n    initializeImpureData(impureData);\n  }\n  list = (int **)&DAT_20000144;\n  do {\n    currentPtr = list[2];\n    nextPtr = list[1];\n    while (nextPtr = (int *)((int)nextPtr + -1), -1 < (int)nextPtr) {\n      if (*(short *)(currentPtr + 3) == 0) {\n        *(undefined2 *)((int)currentPtr + 0xe) = 0xffff;\n        currentPtr[0x19] = 0;\n        *(undefined2 *)(currentPtr + 3) = 1;\n        *currentPtr = 0;\n        currentPtr[2] = 0;\n        currentPtr[1] = 0;\n        currentPtr[4] = 0;\n        currentPtr[5] = 0;\n        currentPtr[6] = 0;\n        memset(currentPtr + 0x17,0,8);\n        currentPtr[0xd] = 0;\n        currentPtr[0xe] = 0;\n        currentPtr[0x12] = 0;\n        currentPtr[0x13] = 0;\n        return currentPtr;\n      }\n      currentPtr = currentPtr + 0x1a;\n    }\n    if (*list == (int *)0x0) {\n      nextPtr = (int *)allocateMemory(status,4);\n      *list = nextPtr;\n      if (nextPtr == (int *)0x0) {\n        *status = 0xc;\n        return (int *)0x0;\n      }\n    }\n    list = (int **)*list;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006d14": "initialize_data_structures_08006d14",
                "param_1": "status",
                "piVar1": "nextPtr",
                "piVar2": "currentPtr",
                "ppiVar3": "list",
                "__sinit": "initializeImpureData",
                "&impure_data": "impureData",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8c": {
            "entrypoint": "0x08006d8c",
            "current_name": "process_data_08006d8c",
            "code": "\nuint process_data_08006d8c(int data_address,code *callback,undefined4 param_3,undefined4 param_4)\n\n{\n  uint result;\n  int count;\n  int *current_node;\n  int node_address;\n  uint combined_result;\n  int iteration_counter;\n  \n  combined_result = 0;\n  for (current_node = (int *)(data_address + 0x48); current_node != (int *)0x0; current_node = (int *)*current_node) {\n    node_address = current_node[2];\n    iteration_counter = current_node[1];\n    while (iteration_counter = iteration_counter + -1, -1 < iteration_counter) {\n      if ((1 < *(ushort *)(node_address + 0xc)) && (count = *(short *)(node_address + 0xe) + 1, count != 0)) {\n        result = (*callback)(data_address,node_address,param_3,count,param_4);\n        combined_result = combined_result | result;\n      }\n      node_address = node_address + 0x68;\n    }\n  }\n  return combined_result;\n}\n\n",
            "renaming": {
                "FUN_08006d8c": "process_data_08006d8c",
                "param_1": "data_address",
                "param_2": "callback",
                "uVar1": "result",
                "iVar2": "count",
                "piVar3": "current_node",
                "iVar4": "node_address",
                "uVar5": "combined_result",
                "iVar6": "iteration_counter"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc8": {
            "entrypoint": "0x08006dc8",
            "current_name": "get_file_permissions_08006dc8",
            "code": "\nundefined4 getFilePermissions_08006dc8(undefined4 file_descriptor,int file_info,undefined4 *permissions,uint *is_executable)\n\n{\n  int status;\n  undefined4 permission_flags;\n  undefined stack_buffer [4];\n  uint file_mode;\n  \n  if ((*(short *)(file_info + 0xe) < 0) ||\n     (status = _fstat_r(file_descriptor,(int)*(short *)(file_info + 0xe),stack_buffer), status < 0)) {\n    *is_executable = 0;\n    if ((int)((uint)*(ushort *)(file_info + 0xc) << 0x18) < 0) {\n      permission_flags = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *is_executable = (uint)((file_mode & 0xf000) == 0x2000);\n  }\n  permission_flags = 0x400;\nLAB_08006e08:\n  *permissions = permission_flags;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006dc8": "get_file_permissions_08006dc8",
                "param_1": "file_descriptor",
                "param_2": "file_info",
                "param_3": "permissions",
                "param_4": "is_executable",
                "iVar1": "status",
                "uVar2": "permission_flags",
                "auStack_4c": "stack_buffer",
                "local_48": "file_mode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e10": {
            "entrypoint": "0x08006e10",
            "current_name": "initialize_data_08006e10",
            "code": "\nvoid initializeData_08006e10(int dataPointer,int *dataArray)\n\n{\n  ushort result;\n  int allocationResult;\n  int dataSize;\n  int *bufferPointer;\n  \n  if (-1 < (int)((uint)*(ushort *)(dataArray + 3) << 0x1e)) {\n    dataSize = dataPointer;\n    bufferPointer = dataArray;\n    result = __swhatbuf_r(dataPointer,dataArray,&dataSize,&bufferPointer);\n    allocationResult = _malloc_r(dataPointer,dataSize);\n    if (allocationResult != 0) {\n      *(undefined4 *)(dataPointer + 0x28) = 0x8006c35;\n      *dataArray = allocationResult;\n      *(ushort *)(dataArray + 3) = *(ushort *)(dataArray + 3) | 0x80;\n      dataArray[4] = allocationResult;\n      dataArray[5] = dataSize;\n      if ((bufferPointer != (int *)0x0) &&\n         (allocationResult = _isatty_r(dataPointer,(int)*(short *)((int)dataArray + 0xe)), allocationResult != 0)) {\n        *(ushort *)(dataArray + 3) = *(ushort *)(dataArray + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(dataArray + 3) = result | *(ushort *)(dataArray + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(dataArray + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(dataArray + 3) = *(ushort *)(dataArray + 3) & 0xfffc | 2;\n  }\n  *dataArray = (int)dataArray + 0x47;\n  dataArray[4] = (int)dataArray + 0x47;\n  dataArray[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e10": "initialize_data_08006e10",
                "param_1": "dataPointer",
                "param_2": "dataArray",
                "uVar1": "result",
                "iVar2": "allocationResult",
                "local_18": "dataSize",
                "local_14": "bufferPointer"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e90": {
            "entrypoint": "0x08006e90",
            "current_name": "find_byte_in_data_08006e90",
            "code": "\nvoid * find_byte_in_data_08006e90(void *data,int byte_to_find,size_t data_length)\n\n{\n  byte *byte_pointer;\n  byte *current_byte;\n  \n  byte_pointer = (byte *)data;\n  do {\n    current_byte = byte_pointer;\n    if (current_byte == (byte *)(data_length + (int)data)) {\n      return (void *)0x0;\n    }\n    byte_pointer = current_byte + 1;\n  } while ((uint)*current_byte != (byte_to_find & 0xffU));\n  return current_byte;\n}\n\n",
            "renaming": {
                "FUN_08006e90": "find_byte_in_data_08006e90",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "data_length",
                "pbVar1": "byte_pointer",
                "pbVar2": "current_byte"
            },
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006eac": {
            "entrypoint": "0x08006eac",
            "current_name": "FUNC_08006eac",
            "code": "\nvoid FUNC_08006eac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eac": "FUNC_08006eac"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eae": {
            "entrypoint": "0x08006eae",
            "current_name": "FUNC_08006eae",
            "code": "\nvoid FUNC_08006eae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eae": "FUNC_08006eae"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eb0": {
            "entrypoint": "0x08006eb0",
            "current_name": "execute_function_08006eb0",
            "code": "\nundefined4 executeFunction_08006eb0(undefined4 *result,uint index,undefined4 unused1,undefined4 unused2)\n\n{\n  __pid_t pid;\n  undefined4 returnValue;\n  int pointer;\n  code *function;\n  \n  if (0x1f < index) {\n    *result = 0x16;\n    return 0xffffffff;\n  }\n  pointer = result[0x11];\n  if ((pointer != 0) && (function = *(code **)(pointer + index * 4), function != (code *)0x0)) {\n    if (function != (code *)0x1) {\n      if (function == (code *)0xffffffff) {\n        *result = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(pointer + index * 4) = 0;\n      (*function)(index);\n    }\n    return 0;\n  }\n  pid = _getpid_r();\n  returnValue = _kill_r(result,pid,index,unused2);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08006eb0": "execute_function_08006eb0",
                "param_1": "result",
                "param_2": "index",
                "param_3": "unused1",
                "param_4": "unused2",
                "_Var1": "pid",
                "uVar2": "returnValue",
                "iVar3": "pointer",
                "pcVar4": "function"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f00": {
            "entrypoint": "0x08006f00",
            "current_name": "execute_signal_handler_08006f00",
            "code": "\nint execute_signal_handler_08006f00(int signal_number)\n\n{\n  int return_value;\n  \n  return_value = _raise_r(_impure_ptr,signal_number);\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_08006f00": "execute_signal_handler_08006f00",
                "__sig": "signal_number",
                "iVar1": "return_value"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f10": {
            "entrypoint": "0x08006f10",
            "current_name": "signal_process_08006f10",
            "code": "\nvoid signal_process_08006f10(int *error_code,__pid_t process_id,int signal_number)\n\n{\n  int kill_result;\n  \n  errno = 0;\n  kill_result = _kill(process_id,signal_number);\n  if ((kill_result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f10": "signal_process_08006f10",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "iVar1": "kill_result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f34": {
            "entrypoint": "0x08006f34",
            "current_name": "FUN_08006f34",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f38": {
            "entrypoint": "0x08006f38",
            "current_name": "update_data_08006f38",
            "code": "\nvoid updateData_08006f38(undefined4 buffer,int data)\n\n{\n  int returnValue;\n  uint updatedValue;\n  bool isSuccess;\n  \n  returnValue = _read_r(buffer,(int)*(short *)(data + 0xe));\n  isSuccess = -1 < returnValue;\n  if (isSuccess) {\n    updatedValue = *(int *)(data + 0x54) + returnValue;\n  }\n  else {\n    updatedValue = *(ushort *)(data + 0xc) & 0xffffefff;\n  }\n  if (isSuccess) {\n    *(uint *)(data + 0x54) = updatedValue;\n  }\n  if (!isSuccess) {\n    *(short *)(data + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f38": "update_data_08006f38",
                "param_1": "buffer",
                "param_2": "data",
                "iVar1": "returnValue",
                "uVar2": "updatedValue",
                "bVar3": "isSuccess"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f5a": {
            "entrypoint": "0x08006f5a",
            "current_name": "update_file_08006f5a",
            "code": "\nvoid updateFile_08006f5a(undefined4 fileDescriptor,integer buffer,undefined4 data,undefined4 size)\n\n{\n  if ((integer)((uinteger)*(unsignedShort *)(buffer + 0xc) << 0x17) < 0) {\n    getFilePosition(fileDescriptor,(integer)*(short *)(buffer + 0xe),0,2);\n  }\n  *(unsignedShort *)(buffer + 0xc) = *(unsignedShort *)(buffer + 0xc) & 0xefff;\n  writeToFile(fileDescriptor,(integer)*(short *)(buffer + 0xe),data,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f5a": "update_file_08006f5a",
                "param_1": "fileDescriptor",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size",
                "ushort": "unsignedShort",
                "int": "integer",
                "_lseek_r": "getFilePosition",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f92": {
            "entrypoint": "0x08006f92",
            "current_name": "update_file_permissions_08006f92",
            "code": "\nvoid updateFilePermissions_08006f92(undefined4 fileDescriptor,int dataStruct)\n\n{\n  int seekResult;\n  ushort updatedPermissions;\n  bool seekFailed;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(dataStruct + 0xe));\n  seekFailed = seekResult == -1;\n  if (seekFailed) {\n    updatedPermissions = *(ushort *)(dataStruct + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(dataStruct + 0x54) = seekResult;\n    updatedPermissions = *(ushort *)(dataStruct + 0xc) | 0x1000;\n  }\n  if (seekFailed) {\n    *(ushort *)(dataStruct + 0xc) = updatedPermissions;\n  }\n  if (!seekFailed) {\n    *(ushort *)(dataStruct + 0xc) = updatedPermissions;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f92": "update_file_permissions_08006f92",
                "param_1": "fileDescriptor",
                "param_2": "dataStruct",
                "iVar1": "seekResult",
                "uVar2": "updatedPermissions",
                "bVar3": "seekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fb6": {
            "entrypoint": "0x08006fb6",
            "current_name": "close_file_08006fb6",
            "code": "\nvoid closeFile_08006fb6(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  closeSystemFile(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fb6": "close_file_08006fb6",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "_close_r": "closeSystemFile"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fc0": {
            "entrypoint": "0x08006fc0",
            "current_name": "write_to_stream_08006fc0",
            "code": "\nvoid writeToStream_08006fc0(int *error_num_ptr,int stream_fd,char *buffer,int num_bytes)\n\n{\n  int write_result;\n  \n  errno = 0;\n  write_result = _write(stream_fd,buffer,num_bytes);\n  if ((write_result == -1) && (errno != 0)) {\n    *error_num_ptr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fc0": "write_to_stream_08006fc0",
                "param_1": "error_num_ptr",
                "param_2": "stream_fd",
                "param_3": "buffer",
                "param_4": "num_bytes",
                "iVar1": "write_result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fe4": {
            "entrypoint": "0x08006fe4",
            "current_name": "close_file_and_handle_error_08006fe4",
            "code": "\nvoid closeFileAndHandleError_08006fe4(int *errorCode,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fe4": "close_file_and_handle_error_08006fe4",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007004": {
            "entrypoint": "0x08007004",
            "current_name": "get_file_status_08007004",
            "code": "\nvoid get_file_status_08007004(int *error_code,int file_descriptor,stat *file_status)\n\n{\n  int status_result;\n  \n  errno = 0;\n  status_result = _fstat(file_descriptor,file_status);\n  if ((status_result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007004": "get_file_status_08007004",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "iVar1": "status_result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007028": {
            "entrypoint": "0x08007028",
            "current_name": "check_isatty_and_set_errno_08007028",
            "code": "\nvoid check_isatty_and_set_errno_08007028(int *error_code_ptr,int file_descriptor)\n\n{\n  int isatty_result;\n  \n  errno = 0;\n  isatty_result = _isatty(file_descriptor);\n  if ((isatty_result == -1) && (errno != 0)) {\n    *error_code_ptr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007028": "check_isatty_and_set_errno_08007028",
                "param_1": "error_code_ptr",
                "param_2": "file_descriptor",
                "iVar1": "isatty_result"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007048": {
            "entrypoint": "0x08007048",
            "current_name": "set_file_position_08007048",
            "code": "\nvoid setFilePosition_08007048(int *errorFlag,int fileDescriptor,__off_t offset,int whence)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,whence);\n  if ((result == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007048": "set_file_position_08007048",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800706c": {
            "entrypoint": "0x0800706c",
            "current_name": "read_and_set_error_0800706c",
            "code": "\nvoid readAndSetError_0800706c(int *error,int fileDescriptor,char *buffer,int count)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,count);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800706c": "read_and_set_error_0800706c",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007090": {
            "entrypoint": "0x08007090",
            "current_name": "call_bad_function_08007090",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::call_bad_function_08007090(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08007090": "call_bad_function_08007090"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007098": {
            "entrypoint": "0x08007098",
            "current_name": "initialize_locale_formats_08007098",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocaleFormats_08007098(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007098": "initialize_locale_formats_08007098"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800715c": {
            "entrypoint": "0x0800715c",
            "current_name": "initialize_locale_0800715c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocale_0800715c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800715c": "initialize_locale_0800715c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007220": {
            "entrypoint": "0x08007220",
            "current_name": "initialize_ctype_08007220",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCtype_08007220(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007220": "initialize_ctype_08007220"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072a4": {
            "entrypoint": "0x080072a4",
            "current_name": "initialize_c_type_080072a4",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCType_080072a4(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072a4": "initialize_c_type_080072a4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007328": {
            "entrypoint": "0x08007328",
            "current_name": "FUNC_08007328",
            "code": "\nvoid FUNC_08007328(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007328": "FUNC_08007328"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007334": {
            "entrypoint": "0x08007334",
            "current_name": "FUNC_08007334",
            "code": "\nvoid FUNC_08007334(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007334": "FUNC_08007334"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 198410,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_0800040c",
            "FUN_0800042c",
            "FUN_08000450",
            "FUN_0800048c",
            "FUN_0800049c",
            "FUN_080006d4",
            "FUN_080008ba",
            "FUN_0800091c",
            "FUN_08000924",
            "FUN_0800092c",
            "FUN_080009a8",
            "FUN_080009b8",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a18",
            "FUN_08000a2c",
            "FUN_08000a58",
            "FUN_08000aa8",
            "FUN_08000ae8",
            "FUN_08000aec",
            "FUN_08000b08",
            "FUN_08000bcc",
            "FUN_08000cbc",
            "FUN_08000cd0",
            "FUN_08001294",
            "FUN_080012a2",
            "FUN_080012c0",
            "FUN_080012e8",
            "FUN_08001310",
            "FUN_0800134e",
            "FUN_0800135a",
            "FUN_08001366",
            "FUN_0800138e",
            "FUN_080013a4",
            "FUN_080014ba",
            "FUN_08001510",
            "FUN_08001550",
            "FUN_0800157c",
            "FUN_080015b2",
            "FUN_080015f8",
            "FUN_080016b4",
            "FUN_08001814",
            "FUN_080018f8",
            "FUN_08001918",
            "FUN_08001960",
            "FUN_080019f6",
            "FUN_08001a44",
            "FUN_08001a66",
            "FUN_08001ab0",
            "FUN_08001b18",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001c30",
            "FUN_08001c32",
            "FUN_08001c3c",
            "FUN_08001c88",
            "FUN_08001cac",
            "FUN_08001cc4",
            "FUN_08001cd0",
            "FUN_08001e40",
            "FUN_08001e48",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08002004",
            "FUN_080020f0",
            "FUN_0800213c",
            "FUN_0800224c",
            "FUN_08002348",
            "FUN_08002384",
            "FUN_08002470",
            "FUN_08002494",
            "FUN_080024f8",
            "FUN_08002514",
            "FUN_08002540",
            "FUN_08002560",
            "FUN_08002582",
            "FUN_0800258c",
            "FUN_08002624",
            "FUN_08002810",
            "FUN_0800281e",
            "FUN_0800282c",
            "FUN_08002848",
            "FUN_080028d2",
            "FUN_080028de",
            "FUN_08002ab8",
            "FUN_08002ad8",
            "FUN_08002af8",
            "FUN_08002b84",
            "FUN_08002c10",
            "FUN_08002c54",
            "FUN_08002ca6",
            "FUN_08002cf2",
            "FUN_08002d1c",
            "FUN_08002db2",
            "FUN_08002efc",
            "FUN_08002f9c",
            "FUN_0800306c",
            "FUN_0800316c",
            "FUN_080032b4",
            "FUN_080033b8",
            "FUN_08003520",
            "FUN_080035fc",
            "FUN_0800365c",
            "FUN_08003688",
            "FUN_08003a68",
            "FUN_08003ad4",
            "FUN_08003c44",
            "FUN_08003c50",
            "FUN_08003c70",
            "FUN_08003c90",
            "FUN_08003da4",
            "FUN_08003ea0",
            "FUN_08003ed8",
            "FUN_08003f18",
            "FUN_08004092",
            "FUN_080040b0",
            "FUN_08004110",
            "FUN_0800412c",
            "FUN_0800417c",
            "FUN_08004198",
            "FUN_08004204",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004478",
            "FUN_0800455a",
            "FUN_080045a2",
            "FUN_080045fe",
            "FUN_08004618",
            "FUN_080046b8",
            "FUN_080047d8",
            "FUN_080047e8",
            "FUN_080047f4",
            "FUN_0800480a",
            "FUN_08004828",
            "FUN_08004848",
            "FUN_08004884",
            "FUN_0800492c",
            "FUN_08004948",
            "FUN_08004974",
            "FUN_080049f0",
            "FUN_08004a4c",
            "FUN_08004b34",
            "FUN_08004b3c",
            "FUN_08004b94",
            "FUN_08004b9e",
            "FUN_08004bb0",
            "FUN_08004c30",
            "FUN_08004c48",
            "FUN_08004c52",
            "FUN_08004c5e",
            "FUN_08004c78",
            "FUN_08004c8a",
            "FUN_08004ca2",
            "FUN_08004cb2",
            "FUN_08004cce",
            "FUN_08004ce2",
            "FUN_08004d06",
            "FUN_08004d18",
            "FUN_08004d30",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_08004d90",
            "FUN_08004df4",
            "FUN_08004df8",
            "FUN_08004e12",
            "FUN_08004e20",
            "FUN_08004e34",
            "FUN_08004e48",
            "FUN_08004e5c",
            "FUN_08004e70",
            "FUN_08004e74",
            "FUN_08004ec4",
            "FUN_08004ef4",
            "FUN_08004f0c",
            "FUN_08004f1c",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f4c",
            "FUN_08005384",
            "FUN_080053d4",
            "FUN_0800548c",
            "FUN_080054b0",
            "FUN_080054d4",
            "FUN_08005510",
            "FUN_08005568",
            "FUN_080055bc",
            "FUN_080055e0",
            "FUN_08005604",
            "FUN_08005650",
            "FUN_08005690",
            "FUN_080056a8",
            "FUN_080056c0",
            "FUN_080056d8",
            "FUN_08005714",
            "FUN_0800571a",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800572c",
            "FUN_08005730",
            "FUN_0800573c",
            "FUN_08005740",
            "FUN_08005750",
            "FUN_08005754",
            "FUN_080057b4",
            "FUN_08005848",
            "FUN_08005890",
            "FUN_080058e0",
            "FUN_080058ea",
            "FUN_0800591e",
            "FUN_08005932",
            "FUN_0800594e",
            "FUN_08005976",
            "FUN_0800598a",
            "FUN_080059c8",
            "FUN_08005a44",
            "FUN_08005a68",
            "FUN_08005b24",
            "FUN_08005b3c",
            "FUN_08005b54",
            "FUN_08005bb0",
            "FUN_08005bd4",
            "FUN_08005be2",
            "FUN_08005c1c",
            "FUN_08005c38",
            "FUN_08005c64",
            "FUN_08005c72",
            "FUN_08005c96",
            "FUN_08005cb6",
            "FUN_08005cc0",
            "FUN_08005cd4",
            "FUN_08005ce8",
            "FUN_08005d42",
            "FUN_08005d82",
            "FUN_08005d8a",
            "FUN_08005da0",
            "FUN_08005da8",
            "FUN_08005f2c",
            "FUN_08005f40",
            "FUN_08005f5e",
            "FUN_08005f6c",
            "FUN_08005f8c",
            "FUN_08005fa0",
            "FUN_08005fc8",
            "FUN_08006074",
            "FUN_0800607e",
            "FUN_08006088",
            "FUN_08006092",
            "FUN_0800609c",
            "FUN_080060a6",
            "FUN_080060bc",
            "FUN_080060d4",
            "FUN_080060e4",
            "FUN_08006104",
            "FUN_08006112",
            "FUN_0800611c",
            "FUN_08006158",
            "FUN_08006174",
            "FUN_08006198",
            "FUN_080061e0",
            "FUN_080061f0",
            "FUN_08006288",
            "FUN_08006344",
            "FUN_08006370",
            "FUN_08006394",
            "FUN_080065c0",
            "FUN_080066b0",
            "FUN_080068f0",
            "FUN_08006920",
            "FUN_08006940",
            "FUN_080069e4",
            "FUN_08006ac0",
            "FUN_08006ad0",
            "FUN_08006be0",
            "FUN_08006c34",
            "FUN_08006c40",
            "FUN_08006c88",
            "FUN_08006cb4",
            "FUN_08006d14",
            "FUN_08006d8c",
            "FUN_08006dc8",
            "FUN_08006e10",
            "FUN_08006e90",
            "FUN_08006eb0",
            "FUN_08006f00",
            "FUN_08006f10",
            "FUN_08006f38",
            "FUN_08006f5a",
            "FUN_08006f92",
            "FUN_08006fb6",
            "FUN_08006fc0",
            "FUN_08006fe4",
            "FUN_08007004",
            "FUN_08007028",
            "FUN_08007048",
            "FUN_0800706c",
            "FUN_08007090",
            "FUN_08007098",
            "FUN_0800715c",
            "FUN_08007220",
            "FUN_080072a4"
        ],
        [
            "FUN_080004f8",
            "FUN_0800074c"
        ]
    ],
    "locked_functions": []
}