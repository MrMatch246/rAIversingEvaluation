{
    "functions": {
        "FUN_0800192c": {
            "renaming": {
                "FUN_0800192c": "set_limits_enabled_status_0800192c",
                "PTR_settings_08001954": "settings_ptr",
                "PTR_limits_enabled_08001958": "limits_enabled_ptr"
            },
            "code": "void set_limits_enabled_status_0800192c(void)\n{\n    const int LIMITS_ENABLED_FLAG = 8;\n    int* PTR_limits_enabled_08001958 = (int*)PTR_limits_enabled_08001958;\n    if ((PTR_settings_08001954[0x28] & LIMITS_ENABLED_FLAG) == 0)\n    {\n        *PTR_limits_enabled_08001958 = 0;\n    }\n    else\n    {\n        *PTR_limits_enabled_08001958 = 1;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800192c",
            "calling": [
                "grbl_main",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "set_limits_enabled_status_0800192c"
        },
        "FUN_08006950": {
            "renaming": {
                "FUN_08006950": "set_priority_group_08006950",
                "PriorityGroup": "priority_group",
                "reg_value": "reg_value",
                "PriorityGroupTmp": "priority_group_tmp",
                "DAT_08006994": "DAT_08006994",
                "uint": "uint32_t",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void set_priority_group_08006950(uint32_t priority_group) {\n  uint32_t reg_value;\n  uint32_t priority_group_tmp;\n  uint32_t* ptr = (uint32_t*)(DAT_08006994 + 0xc);\n  uint32_t mask = 0xf8ff;\n  uint32_t value = (priority_group & 7) << 8 | 0x5fa0000;\n  *ptr = (*ptr & mask) | value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006950",
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "imported": false,
            "current_name": "set_priority_group_08006950"
        },
        "FUN_08008ba0": {
            "renaming": {
                "FUN_08008ba0": "convert_to_signed_magnitude_08008ba0",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "iVar2": "shifted_divisor",
                "uVar3": "shift_amount",
                "divisor_magnitude": "divisor_magnitude"
            },
            "code": "uint convert_to_signed_magnitude_08008ba0(uint dividend, uint divisor)\n{\n  uint quotient;\n  int shifted_divisor;\n  uint shift_amount;\n  \n  shifted_divisor = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000) {\n    if (-1 < shifted_divisor) {\n      return 0;\n    }\n    uint divisor_magnitude = -shifted_divisor >> 0x15;\n    uint shift_amount = -divisor_magnitude - 0x3e1;\n    if (divisor_magnitude < 0xfffffc20 && shift_amount != 0) {\n      quotient = (dividend << 0xb | 0x80000000 | divisor >> 0x15) >> (shift_amount & 0xff);\n      if ((divisor & 0x80000000) != 0) {\n        quotient = -quotient;\n      }\n      return quotient;\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0) {\n    return 0;\n  }\n  divisor = divisor & 0x80000000;\n  if (divisor == 0) {\n    divisor = 0x7fffffff;\n  }\n  return divisor;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba0",
            "calling": [
                "calculate_trapezoid_for_block",
                "lround",
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "gc_execute_line",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "convert_to_signed_magnitude_08008ba0"
        },
        "FUN_08005a5c": {
            "renaming": {
                "FUN_08005a5c": "do_nothing_08005a5c"
            },
            "code": "\nvoid do_nothing_08005a5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a5c",
            "calling": [
                "HAL_DeInit"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a5c"
        },
        "FUN_08005b90": {
            "renaming": {
                "FUN_08005b90": "clear_bit_in_uint_at_address_08005b90",
                "DAT_08005ba8": "PTR_dat_address",
                "uint": "unsigned_int",
                "*": "pointer_to",
                "mask": "bit_mask",
                "address": "pointer_to_uint_at_address"
            },
            "code": "void clear_bit_in_uint_at_address_08005b90(void)\n{\n    uint *address = (uint *)(DAT_08005ba8 + 4);\n    uint mask = 0xfffffffb;\n    *address = *address & mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b90",
            "calling": [],
            "imported": false,
            "current_name": "clear_bit_in_uint_at_address_08005b90"
        },
        "FUN_080071d0": {
            "renaming": {
                "FUN_080071d0": "configure_gpio_pins_080071d0",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "pin_mask",
                "tmp": "pin_masked",
                "iocurrent": "gpio_afr",
                "ioposition": "pin_position",
                "position": "pin_position",
                "uVar1": "pin_masked",
                "uVar2": "pin_masked",
                "DAT_08007308": "dat_08007308",
                "DAT_0800730c": "dat_0800730c"
            },
            "code": "void configure_gpio_pins_080071d0(GPIO_TypeDef *gpio_port, uint32_t pin_mask) {\n    uint32_t pin_position;\n    for (pin_position = 0; pin_position < 0x10; pin_position++) {\n        uint32_t pin_masked = 1 << (pin_position & 0xff);\n        if (pin_mask & pin_masked) {\n            uint32_t moder_mask = ~(3 << ((pin_position & 0x7f) << 1));\n            uint32_t afr_mask = ~(0xf << ((pin_position & 7) << 2));\n            uint32_t ospeedr_mask = ~(3 << ((pin_position & 0x7f) << 1));\n            uint32_t otyper_mask = ~(1 << (pin_position & 0xff));\n            uint32_t pupdr_mask = ~(3 << ((pin_position & 0x7f) << 1));\n            uint32_t* gpio_afr = &gpio_port->AFR[pin_position >> 3];\n            gpio_port->MODER &= moder_mask;\n            gpio_afr[0] &= afr_mask;\n            gpio_port->OSPEEDR &= ospeedr_mask;\n            gpio_port->OTYPER &= otyper_mask;\n            gpio_port->PUPDR &= pupdr_mask;\n            uint32_t* DAT_08007308 = (uint32_t*) 0x08007308;\n            DAT_08007308 += ((pin_position >> 2) + 2);\n            *DAT_08007308 = ~(0xf << ((pin_position & 3) << 2)) & *DAT_08007308;\n            uint32_t* DAT_0800730c = (uint32_t*) 0x0800730c;\n            DAT_0800730c[0] = ~pin_masked & DAT_0800730c[0];\n            DAT_0800730c[1] = ~pin_masked & DAT_0800730c[1];\n            DAT_0800730c[2] = ~pin_masked & DAT_0800730c[2];\n            DAT_0800730c[3] = ~pin_masked & DAT_0800730c[3];\n        }\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071d0",
            "calling": [],
            "imported": false,
            "current_name": "configure_gpio_pins_080071d0"
        },
        "FUN_08008e60": {
            "renaming": {
                "FUN_08008e60": "calculate_hash_08008e60",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "hash1",
                "uVar2": "hash2",
                "iVar3": "count_leading_zeroes_output",
                "uVar4": "shift_amount",
                "iVar5": "constant1",
                "uVar6": "shifted_hash1"
            },
            "code": "uint calculate_hash_08008e60(uint input1, uint input2)\n{\n    if ((input1 | input2) == 0) {\n        return input1;\n    }\n    uint hash1 = input1;\n    uint hash2 = input2;\n    if (input2 == 0) {\n        hash1 = 0;\n        hash2 = input1;\n    }\n    int constant1 = 0x5b000000;\n    if (input2 == 0) {\n        constant1 = 0x4b000000;\n    }\n    int count_leading_zeroes_output = count_leading_zeroes(hash2);\n    uint shift_amount = count_leading_zeroes_output - 8;\n    constant1 = constant1 + -0x800000 + shift_amount * -0x800000;\n    if (count_leading_zeroes_output < 8) {\n        uint shifted_hash2 = hash2 << (count_leading_zeroes_output + 0x18U & 0xff);\n        hash2 = constant1 + ((hash2 >> (0x20 - (count_leading_zeroes_output + 0x18U) & 0xff)) - ((int)shifted_hash2 >> 0x1f));\n        if ((hash1 | shifted_hash2 << 1) == 0) {\n            hash2 = hash2 & ~(shifted_hash2 >> 0x1f);\n        }\n        return hash2;\n    }\n    uint shifted_hash1 = hash1 << (shift_amount & 0xff);\n    hash2 = constant1 + (hash2 << (shift_amount & 0xff)) + (hash1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shifted_hash1);\n    if (shifted_hash1 == 0x80000000) {\n        hash2 = hash2 & 0xfffffffe;\n    }\n    return hash2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e60",
            "calling": [],
            "imported": false,
            "current_name": "calculate_hash_08008e60"
        },
        "FUN_08005984": {
            "renaming": {
                "FUN_08005984": "execute_afl_call_if_hypercall_not_present_08005984",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_080059b0": "PTR_noHyperCall_080059b0"
            },
            "code": "uint32_t execute_afl_call_if_hypercall_not_present_08005984(int ticks)\n{\n    uint32_t result;\n\n    if (*(int *)PTR_noHyperCall_080059b0 == 0) {\n        result = aflCall(1, ticks, 0);\n    }\n    else {\n        result = 0;\n    }\n    return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005984",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_afl_call_if_hypercall_not_present_08005984"
        },
        "FUN_080082c8": {
            "renaming": {
                "FUN_080082c8": "FUNC_080082c8"
            },
            "code": "\nulonglong FUNC_080082c8(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar4 = param_2 ^ 0x80000000;\n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((uVar4 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = uVar4;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((uVar4 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        uVar4 = param_4;\n      }\n      return CONCAT44(uVar4,param_1);\n    }\n    if (uVar4 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(uVar4,uVar4) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(uVar4 + 0x100000,param_1);\n    }\n    uVar4 = uVar4 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(uVar4 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar12 = uVar4;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar12 = param_4;\n    param_3 = param_1;\n    param_4 = uVar4;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar12,uVar8);\n  }\n  uVar9 = uVar12 & 0xfffff | 0x100000;\n  if ((uVar12 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar4 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar4 = uVar4 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar5 = uVar4 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar5;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar4 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar11 = uVar4 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar4 = (int)uVar4 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar4;\n    uVar9 = uVar9 + ((int)uVar4 >> 0x1f) + (uint)CARRY4(uVar8,uVar4);\n  }\n  uVar4 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | uVar4,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if (uVar7 - 1 != 0 && 0xfffff < uVar10) goto LAB_080083e0;\n  uVar3 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar3 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar3 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar3 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar3 = uVar3 << (uVar10 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | uVar4,uVar3);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar3 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(uVar4 | uVar7 >> (uVar10 & 0xff),\n                    uVar3 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080082c8",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_080082c8"
        },
        "FUN_08006718": {
            "renaming": {
                "FUN_08006718": "get_RCC_configuration_08006718",
                "*RCC_OscInitStruct": "*RCC_config",
                "uVar1": "leading_zeroes",
                "result": "result_0",
                "result_1": "result_1",
                "result_2": "result_2",
                "result_3": "result_3",
                "result_4": "result_4",
                "result_5": "result_5",
                "result_6": "result_6",
                "result_7": "result_7",
                "*DAT_080068b8": "RCC_CR",
                "RCC_OscInitStruct->OscillatorType": "RCC_config->OscillatorType",
                "RCC_OscInitStruct->HSEState": "RCC_config->HSEState",
                "RCC_OscInitStruct->HSIState": "RCC_config->HSIState",
                "RCC_OscInitStruct->HSICalibrationValue": "RCC_config->HSICalibrationValue",
                "RCC_OscInitStruct->LSEState": "RCC_config->LSEState",
                "RCC_OscInitStruct->LSIState": "RCC_config->LSIState",
                "(RCC_OscInitStruct->PLL).PLLState": "(RCC_config->PLL).PLLState",
                "(RCC_OscInitStruct->PLL).PLLSource": "(RCC_config->PLL).PLLSource",
                "(RCC_OscInitStruct->PLL).PLLM": "(RCC_config->PLL).PLLM",
                "(RCC_OscInitStruct->PLL).PLLN": "(RCC_config->PLL).PLLN",
                "(RCC_OscInitStruct->PLL).PLLP": "(RCC_config->PLL).PLLP",
                "(RCC_OscInitStruct->PLL).PLLQ": "(RCC_config->PLL).PLLQ"
            },
            "code": "void get_RCC_configuration_08006718(RCC_OscInitTypeDef *RCC_config)\n{\n    uint32_t *DAT_080068b8 = *DAT_080068b8;\n    RCC_config->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;\n\n    if ((*DAT_080068b8 & *DAT_080068b8_HSEON) == *DAT_080068b8_HSEON)\n    {\n        RCC_config->HSEState = RCC_HSE_ON;\n    }\n    else if ((*DAT_080068b8 & *DAT_080068b8_HSION) == *DAT_080068b8_HSION)\n    {\n        RCC_config->HSEState = RCC_HSI_ON;\n    }\n    else\n    {\n        RCC_config->HSEState = RCC_HSE_OFF;\n    }\n\n    RCC_config->HSIState = ((*DAT_080068b8 & *DAT_080068b8_HSION) == *DAT_080068b8_HSION) ? RCC_HSI_ON : RCC_HSI_OFF;\n\n    uint32_t HSITrim = (*DAT_080068b8 & *DAT_080068b8_HSITRIM) >> RCC_HSICALIBRATION_DEFAULT;\n    RCC_config->HSICalibrationValue = HSITrim;\n\n    if ((DAT_080068b8[0x1c] & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\n    {\n        RCC_config->LSEState = RCC_LSE_ON;\n    }\n    else if ((DAT_080068b8[0x1c] & RCC_BDCR_LSION) == RCC_BDCR_LSION)\n    {\n        RCC_config->LSEState = RCC_LSI_ON;\n    }\n    else\n    {\n        RCC_config->LSEState = RCC_LSE_OFF;\n    }\n\n    RCC_config->LSIState = ((DAT_080068b8[0x1d] & RCC_CSR_LSION) == RCC_CSR_LSION) ? RCC_LSI_ON : RCC_LSI_OFF;\n\n    if ((*DAT_080068b8 & *DAT_080068b8_PLLON) == *DAT_080068b8_PLLON)\n    {\n        RCC_config->PLL.PLLState = RCC_PLL_ON;\n    }\n    else\n    {\n        RCC_config->PLL.PLLState = RCC_PLL_OFF;\n    }\n\n    RCC_config->PLL.PLLSource = (DAT_080068b8[1] & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC;\n    RCC_config->PLL.PLLM = DAT_080068b8[1] & RCC_CFGR_PLLM;\n    RCC_config->PLL.PLLN = (DAT_080068b8[1] & RCC_CFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;\n    RCC_config->PLL.PLLP = ((DAT_080068b8[1] & RCC_CFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1;\n    RCC_config->PLL.PLLQ = (DAT_080068b8[1] & RCC_CFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006718",
            "calling": [],
            "imported": false,
            "current_name": "get_RCC_configuration_08006718"
        },
        "FUN_08007a10": {
            "renaming": {
                "FUN_08007a10": "set_timer_flag_08007a10",
                "tim": "timer",
                "DAT_40000000": "TIMER_1",
                "DAT_08007a68": "TIMER_2",
                "DAT_08007a6c": "TIMER_3"
            },
            "code": "void set_timer_flag_08007a10(TIM_TypeDef *timer){\n\tuint32_t* flag_register = (uint32_t*)(DAT_08007a64 + 0x40);\n\tif (timer == (TIM_TypeDef *)&DAT_40000000) {\n\t\t*flag_register |= 1;\n\t}\n\telse if (timer == DAT_08007a68) {\n\t\t*flag_register |= 2;\n\t}\n\telse if (timer == DAT_08007a6c) {\n\t\t*flag_register |= 4;\n\t}\n\treturn;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a10",
            "calling": [
                "g540_timer_init",
                "step_timer_init"
            ],
            "imported": false,
            "current_name": "set_timer_flag_08007a10"
        },
        "FUN_0800856c": {
            "renaming": {
                "FUN_0800856c": "improved_function_name_0800856c",
                "param_1": "number",
                "uVar1": "prefix",
                "uVar2": "abs_number",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeroes",
                "uVar5": "shift_amount_2",
                "uVar6": "prefix_mask",
                "in_r12": "remaining_bits",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "is_overflow"
            },
            "code": "ulonglong improved_function_name_0800856c(uint number);\n\nulonglong improved_function_name_0800856c(uint number)\n{\n    uint prefix_mask = 0x80000000;\n    uint abs_number = number;\n    if ((int)number < 0) {\n        abs_number = -number;\n    }\n    if (number == 0) {\n        return 0;\n    }\n    uint prefix = number & prefix_mask;\n    uint leading_zeroes = improved_function_name_0800856c(abs_number);\n    uint shift_amount = leading_zeroes + 0x15;\n    if (shift_amount < 0x20) {\n        prefix = prefix | (abs_number << (shift_amount & 0xff));\n        abs_number = abs_number >> ((0xcU - leading_zeroes + 1) & 0xff);\n    } else {\n        uint remaining_bits = 0x20 - leading_zeroes;\n        abs_number = abs_number << (leading_zeroes & 0xff);\n        prefix = prefix | (abs_number >> (remaining_bits & 0xff));\n        abs_number = abs_number | (0U >> (remaining_bits & 0xff));\n        if (remaining_bits < 0x20) {\n            prefix = prefix | (0 << (leading_zeroes & 0xff));\n        }\n    }\n    if (shift_amount < 0x433) {\n        return ((ulonglong)prefix << 0x20) | abs_number + (0x432 - shift_amount) * 0x100000;\n    }\n    uint remaining_bits = ~(0x432 - shift_amount);\n    if (remaining_bits > 0x1e) {\n        return CONCAT44(number, abs_number >> (remaining_bits - 0x1f & 0xff)) & 0x80000000ffffffff;\n    }\n    int shift_amount_2 = remaining_bits - 0x13;\n    if (shift_amount_2 == 0 || ((shift_amount_2 < 0) != ((remaining_bits - 0x1f) < 0xc))) {\n        remaining_bits = remaining_bits + 1;\n        return ((ulonglong)prefix | (abs_number >> (remaining_bits & 0xff))) << 0x20 | (abs_number << (0x20 - remaining_bits & 0xff)) >> (0x20 - remaining_bits & 0xff);\n    }\n    return CONCAT44(number, abs_number >> (0x20 - (0xcU - shift_amount_2) & 0xff) | abs_number << (0xcU - shift_amount_2 & 0xff)) & 0x80000000ffffffff;\n}\n\nulonglong improved_function_name_0800856c(uint number)\n{\n    uint leading_zeroes = 0;\n    for (int i = 31; i >= 0; i--) {\n        if ((number & (1 << i)) == 0) {\n            leading_zeroes++;\n        } else {\n            break;\n        }\n    }\n    return leading_zeroes;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800856c",
            "calling": [
                "calculate_trapezoid_for_block",
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "improved_function_name_0800856c"
        },
        "FUN_08008b00": {
            "renaming": {
                "FUN_08008b00": "float_conversion_08008b00",
                "param_1": "float_value"
            },
            "code": "undefined4 float_conversion_08008b00(undefined4 float_value)\n{\n  __nedf2();\n  return float_value;\n}",
            "called": [
                "__nedf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b00",
            "calling": [
                "__aeabi_dcmplt",
                "__aeabi_cdrcmple",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple"
            ],
            "imported": false,
            "current_name": "float_conversion_08008b00"
        },
        "FUN_0800585c": {
            "renaming": {
                "FUN_0800585c": "wake_up_if_flag_set_0800585c",
                "PTR_sys_08005878": "PTR_sys",
                "st_wake_up": "wake_up"
            },
            "code": "void wake_up_if_flag_set_0800585c(void)\n{\n  if (PTR_sys_08005878_08005878[1] == '\\x02') {\n    PTR_sys_08005878_08005878[1] = 3;\n    st_wake_up();\n  }\n  return;\n}",
            "called": [
                "st_wake_up"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800585c",
            "calling": [
                "mc_go_home",
                "protocol_execute_runtime",
                "mc_line"
            ],
            "imported": false,
            "current_name": "wake_up_if_flag_set_0800585c"
        },
        "FUN_08008cd0": {
            "renaming": {
                "FUN_08008cd0": "FUNC_08008cd0"
            },
            "code": "\nuint FUNC_08008cd0(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  int iVar7;\n  bool bVar8;\n  \n  uVar2 = param_1 ^ 0x80000000;\n  uVar4 = param_1 << 1;\n  bVar8 = uVar4 == 0;\n  if (!bVar8) {\n    param_4 = param_2 << 1;\n    bVar8 = param_4 == 0;\n  }\n  if (!bVar8) {\n    bVar8 = uVar4 == param_4;\n  }\n  iVar7 = (int)uVar4 >> 0x18;\n  if (!bVar8) {\n    bVar8 = iVar7 == -1;\n  }\n  if (!bVar8) {\n    bVar8 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar8) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar7 == -1 || iVar1 == -1) {\n      uVar4 = param_2;\n      if (iVar7 == -1) {\n        uVar4 = uVar2;\n      }\n      if (iVar7 != -1 || iVar1 != -1) {\n        param_2 = uVar4;\n      }\n      bVar8 = (uVar4 & 0x7fffff) == 0;\n      if (bVar8) {\n        bVar8 = (param_2 & 0x7fffff) == 0;\n      }\n      if (bVar8) {\n        bVar8 = uVar4 == param_2;\n      }\n      if (!bVar8) {\n        uVar4 = uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ param_2) & 0x7fffffff) != 0) {\n      if (uVar4 == 0) {\n        uVar2 = param_2;\n      }\n      return uVar2;\n    }\n    if (uVar2 != param_2) {\n      return 0;\n    }\n    if ((uVar4 & 0xff000000) == 0) {\n      param_1 = param_1 << 1;\n      if ((uVar2 & 0x80000000) != 0) {\n        param_1 = param_1 | 0x80000000;\n      }\n      return param_1;\n    }\n    if (uVar4 < 0xfe000000) {\n      return uVar2 + 0x800000;\n    }\n    uVar2 = uVar2 & 0x80000000;\nLAB_08008e12:\n    return uVar2 | 0x7f800000;\n  }\n  uVar4 = uVar4 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar6 = param_4 - uVar4;\n  bVar8 = uVar6 != 0;\n  uVar5 = uVar4;\n  if (bVar8 && uVar4 <= param_4) {\n    uVar5 = uVar4 + uVar6;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_2 = param_2 ^ uVar2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_2 = param_2 ^ uVar2;\n  }\n  if (param_4 < uVar4) {\n    uVar6 = -uVar6;\n  }\n  if (0x19 < uVar6) {\n    return uVar2;\n  }\n  uVar4 = uVar2 & 0xffffff | 0x800000;\n  if ((uVar2 & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  uVar3 = param_2 & 0xffffff | 0x800000;\n  if ((param_2 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  if (uVar5 == uVar6) {\n    uVar3 = uVar3 ^ 0x800000;\n    if (uVar5 == 0) {\n      uVar4 = uVar4 ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      uVar6 = uVar6 - 1;\n    }\n  }\n  uVar4 = uVar4 + ((int)uVar3 >> (uVar6 & 0xff));\n  uVar3 = uVar3 << (0x20 - uVar6 & 0xff);\n  uVar2 = uVar4 & 0x80000000;\n  if ((int)uVar4 < 0) {\n    bVar8 = uVar3 != 0;\n    uVar3 = -uVar3;\n    uVar4 = -uVar4 - (uint)bVar8;\n  }\n  if (uVar4 < 0x800000) {\n    uVar6 = uVar3 & 0x80000000;\n    uVar3 = uVar3 << 1;\n    uVar4 = uVar4 * 2 + (uint)(uVar6 != 0);\n    uVar6 = uVar5 - 2;\n    if (uVar5 - 1 == 0 || uVar4 < 0x800000) {\n      iVar7 = count_leading_zeroes(uVar4);\n      uVar5 = iVar7 - 8;\n      uVar4 = uVar4 << (uVar5 & 0xff);\n      if ((int)uVar6 < (int)uVar5) {\n        uVar4 = uVar4 >> (-(uVar6 - uVar5) & 0xff);\n      }\n      else {\n        uVar4 = uVar4 + (uVar6 - uVar5) * 0x800000;\n      }\n      return uVar4 | uVar2;\n    }\n  }\n  else {\n    uVar6 = uVar5 - 1;\n    if (0xffffff < uVar4) {\n      uVar6 = uVar4 & 1;\n      uVar4 = uVar4 >> 1;\n      uVar3 = (uint)(uVar6 != 0) << 0x1f | uVar3 >> 1;\n      uVar6 = uVar5;\n      if (0xfd < uVar5) goto LAB_08008e12;\n    }\n  }\n  uVar4 = uVar4 + uVar6 * 0x800000 + (uint)(0x7fffffff < uVar3);\n  if (uVar3 == 0x80000000) {\n    uVar4 = uVar4 & 0xfffffffe;\n  }\n  return uVar4 | uVar2;\n}\n\n",
            "called": [
                "__addsf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008cd0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08008cd0"
        },
        "FUN_0800597c": {
            "renaming": {
                "FUN_0800597c": "interrupt_handler_0800597c",
                "a0": "register_0",
                "a1": "register_1",
                "a2": "register_2"
            },
            "code": "uint32_t interrupt_handler_0800597c(uint32_t register_0, uint32_t register_1, int32_t register_2) {\n  software_interrupt(0x3f);\n  return register_0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800597c",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "interrupt_handler_0800597c"
        },
        "FUN_08009314": {
            "renaming": {
                "FUN_08009314": "infinite_loop_08009314"
            },
            "code": "void infinite_loop_08009314(void)\n{\n  while(true) {\n    //Do nothing\n  }\n}",
            "called": [
                "DMA1_Stream3_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009314",
            "calling": [
                "DMA1_Stream3_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08009314"
        },
        "FUN_08009798": {
            "renaming": {
                "FUN_08009798": "calculate_shifted_double_08009798",
                "__x": "input_double",
                "in_r1": "exponent_shift",
                "iVar1": "exponent_value",
                "in_d0": "output_double"
            },
            "code": "double calculate_shifted_double_08009798(double input_double)\n{\n  int exponent_shift;\n  int exponent_value;\n  double output_double;\n  exponent_value = ((uint)(exponent_shift << 1) >> 0x15) - 0x3ff;\n  if (exponent_value < 0x14) {\n    if (exponent_value < 0) {\n      return output_double;\n    }\n  }\n  else {\n    if (exponent_value < 0x34) {\n      return output_double;\n    }\n    if (exponent_value != 0x400) {\n      return output_double;\n    }\n    output_double = (double)__aeabi_dadd();\n  }\n  return output_double;\n}",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009798",
            "calling": [
                "protocol_execute_line",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "calculate_shifted_double_08009798"
        },
        "FUN_08008cd8": {
            "renaming": {
                "FUN_08008cd8": "FUNC_08008cd8"
            },
            "code": "\nuint FUNC_08008cd8(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  int iVar7;\n  bool bVar8;\n  \n  uVar2 = param_2 ^ 0x80000000;\n  uVar4 = param_1 << 1;\n  bVar8 = uVar4 == 0;\n  if (!bVar8) {\n    param_4 = param_2 << 1;\n    bVar8 = param_4 == 0;\n  }\n  if (!bVar8) {\n    bVar8 = uVar4 == param_4;\n  }\n  iVar7 = (int)uVar4 >> 0x18;\n  if (!bVar8) {\n    bVar8 = iVar7 == -1;\n  }\n  if (!bVar8) {\n    bVar8 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar8) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar7 == -1 || iVar1 == -1) {\n      uVar4 = uVar2;\n      if (iVar7 == -1) {\n        uVar4 = param_1;\n      }\n      if (iVar7 != -1 || iVar1 != -1) {\n        uVar2 = uVar4;\n      }\n      bVar8 = (uVar4 & 0x7fffff) == 0;\n      if (bVar8) {\n        bVar8 = (uVar2 & 0x7fffff) == 0;\n      }\n      if (bVar8) {\n        bVar8 = uVar4 == uVar2;\n      }\n      if (!bVar8) {\n        uVar4 = uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ uVar2) & 0x7fffffff) != 0) {\n      if (uVar4 == 0) {\n        param_1 = uVar2;\n      }\n      return param_1;\n    }\n    if (param_1 != uVar2) {\n      return 0;\n    }\n    if ((uVar4 & 0xff000000) == 0) {\n      uVar2 = param_1 << 1;\n      if ((param_1 & 0x80000000) != 0) {\n        uVar2 = uVar2 | 0x80000000;\n      }\n      return uVar2;\n    }\n    if (uVar4 < 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 = param_1 & 0x80000000;\nLAB_08008e12:\n    return param_1 | 0x7f800000;\n  }\n  uVar4 = uVar4 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar6 = param_4 - uVar4;\n  bVar8 = uVar6 != 0;\n  uVar5 = uVar4;\n  if (bVar8 && uVar4 <= param_4) {\n    uVar5 = uVar4 + uVar6;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_1;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_1 = param_1 ^ uVar2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_1;\n  }\n  if (param_4 < uVar4) {\n    uVar6 = -uVar6;\n  }\n  if (0x19 < uVar6) {\n    return param_1;\n  }\n  uVar4 = param_1 & 0xffffff | 0x800000;\n  if ((param_1 & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  uVar3 = uVar2 & 0xffffff | 0x800000;\n  if ((uVar2 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  if (uVar5 == uVar6) {\n    uVar3 = uVar3 ^ 0x800000;\n    if (uVar5 == 0) {\n      uVar4 = uVar4 ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      uVar6 = uVar6 - 1;\n    }\n  }\n  uVar4 = uVar4 + ((int)uVar3 >> (uVar6 & 0xff));\n  uVar3 = uVar3 << (0x20 - uVar6 & 0xff);\n  param_1 = uVar4 & 0x80000000;\n  if ((int)uVar4 < 0) {\n    bVar8 = uVar3 != 0;\n    uVar3 = -uVar3;\n    uVar4 = -uVar4 - (uint)bVar8;\n  }\n  if (uVar4 < 0x800000) {\n    uVar2 = uVar3 & 0x80000000;\n    uVar3 = uVar3 << 1;\n    uVar4 = uVar4 * 2 + (uint)(uVar2 != 0);\n    uVar2 = uVar5 - 2;\n    if (uVar5 - 1 == 0 || uVar4 < 0x800000) {\n      iVar7 = count_leading_zeroes(uVar4);\n      uVar6 = iVar7 - 8;\n      uVar4 = uVar4 << (uVar6 & 0xff);\n      if ((int)uVar2 < (int)uVar6) {\n        uVar4 = uVar4 >> (-(uVar2 - uVar6) & 0xff);\n      }\n      else {\n        uVar4 = uVar4 + (uVar2 - uVar6) * 0x800000;\n      }\n      return uVar4 | param_1;\n    }\n  }\n  else {\n    uVar2 = uVar5 - 1;\n    if (0xffffff < uVar4) {\n      uVar2 = uVar4 & 1;\n      uVar4 = uVar4 >> 1;\n      uVar3 = (uint)(uVar2 != 0) << 0x1f | uVar3 >> 1;\n      uVar2 = uVar5;\n      if (0xfd < uVar5) goto LAB_08008e12;\n    }\n  }\n  uVar4 = uVar4 + uVar2 * 0x800000 + (uint)(0x7fffffff < uVar3);\n  if (uVar3 == 0x80000000) {\n    uVar4 = uVar4 & 0xfffffffe;\n  }\n  return uVar4 | param_1;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008cd8",
            "calling": [
                "intersection_distance",
                "report_realtime_status",
                "mc_arc",
                "plan_buffer_line",
                "mc_dwell",
                "max_allowable_speed",
                "gc_execute_line",
                "estimate_acceleration_distance"
            ],
            "imported": false,
            "current_name": "FUNC_08008cd8"
        },
        "FUN_08007930": {
            "renaming": {
                "FUN_08007930": "debounce_handler_08007930",
                "puVar1": "debounce_control_ptr",
                "uVar2": "debounce_input_value",
                "uVar3": "current_state_index",
                "iVar4": "current_state_index",
                "off_bits": "previous_state_value",
                "on_bits": "current_state_value",
                "state": "current_state_value",
                "db": "debounce_control_ptr"
            },
            "code": "void debounce_handler_08007930(void)\n{\n    uint32_t debounce_input_value;\n    uint current_state_index;\n    uint32_t current_state_value;\n    uint32_t previous_state_value;\n    DEBOUNCE_CTRL *debounce_control_ptr;\n\n    debounce_control_ptr = PTR_debounce_080079b8;\n    if (*(int *)PTR_debounce_ready_080079bc != 0) {\n        current_state_index = *(int *)(PTR_debounce_080079b8 + 0x14);\n        debounce_input_value = debounce_input();\n        *(uint32_t *)(debounce_control_ptr + current_state_index * 4) = debounce_input_value;\n        if (*(int *)(debounce_control_ptr + 0x14) == 3) {\n            current_state_index = 0;\n        }\n        else {\n            current_state_index = *(int *)(debounce_control_ptr + 0x14) + 1;\n        }\n        *(int *)(debounce_control_ptr + 0x14) = current_state_index;\n        previous_state_value = debounce_rd();\n        current_state_value = *(uint *)(debounce_control_ptr + 0x10);\n        if ((~current_state_value & previous_state_value) != 0) {\n            debounce_on_handler(~current_state_value & previous_state_value);\n        }\n        if ((~previous_state_value & current_state_value) != 0) {\n            debounce_off_handler(~previous_state_value & current_state_value);\n        }\n        *(uint32_t *)(debounce_control_ptr + 0x10) = previous_state_value;\n    }\n    return;\n}",
            "called": [
                "debounce_on_handler",
                "debounce_input",
                "debounce_rd",
                "debounce_off_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007930",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "debounce_handler_08007930"
        },
        "FUN_080082ba": {
            "renaming": {
                "FUN_080082ba": "do_nothing_080082ba"
            },
            "code": "\nvoid do_nothing_080082ba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082ba",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "do_nothing_080082ba"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "check_initialized_08000188",
                "param_1": "input_string",
                "*PTR_completed_8911_080001a0": "is_initialized",
                "DAT_080001a4": "init_status",
                "PTR__init_080001a8": "init_value"
            },
            "code": "char* check_initialized_08000188(char* input_string) {\\n\\tif (*PTR_completed_8911_080001a0 == \"\\0\") {\\n\\t\\tif (DAT_080001a4 != 0) {\\n\\t\\t\\tinput_string = PTR__init_080001a8;\\n\\t\\t}\\n\\t\\t*PTR_completed_8911_080001a0 = 1;\\n\\t}\\n\\treturn input_string;\\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "check_initialized_08000188"
        },
        "FUN_080082d0": {
            "renaming": {
                "FUN_080082d0": "FUNC_080082d0"
            },
            "code": "\nulonglong FUNC_080082d0(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar6 = param_4 ^ 0x80000000;\n  uVar9 = param_2 << 1;\n  param_4 = param_4 << 1;\n  bVar13 = ((param_2 ^ uVar6) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar9 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (param_4 | param_3) == 0;\n  }\n  iVar8 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar8 == -1;\n  }\n  iVar1 = (int)param_4 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar8 == -1 || iVar1 == -1) {\n      uVar9 = uVar6;\n      uVar11 = param_3;\n      if (iVar8 == -1) {\n        uVar9 = param_2;\n        uVar11 = param_1;\n      }\n      if (iVar8 != -1 || iVar1 != -1) {\n        param_3 = uVar11;\n        uVar6 = uVar9;\n      }\n      bVar14 = (uVar11 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | uVar6 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == uVar6;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar11);\n    }\n    if (((param_2 ^ uVar6) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar9 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = uVar6;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != uVar6) {\n      return 0;\n    }\n    if (uVar9 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar6 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar6 = uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,param_1 << 1);\n    }\n    if (uVar9 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar9 = uVar9 >> 0x15;\n  param_4 = param_4 >> 0x15;\n  uVar11 = param_4 - uVar9;\n  bVar14 = uVar11 != 0;\n  if (param_4 < uVar9) {\n    uVar11 = -uVar11;\n  }\n  uVar10 = param_1;\n  uVar7 = param_2;\n  if (bVar14 && uVar9 <= param_4) {\n    uVar9 = uVar9 + uVar11;\n    uVar10 = param_3;\n    uVar7 = uVar6;\n    param_3 = param_1;\n    uVar6 = param_2;\n  }\n  if (0x36 < uVar11) {\n    return CONCAT44(uVar7,uVar10);\n  }\n  uVar4 = uVar7 & 0xfffff | 0x100000;\n  if ((uVar7 & 0x80000000) != 0) {\n    bVar14 = uVar10 != 0;\n    uVar10 = -uVar10;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  uVar7 = uVar6 & 0xfffff | 0x100000;\n  if ((uVar6 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar7 = -uVar7 - (uint)bVar14;\n  }\n  if (uVar9 == uVar11) {\n    uVar7 = uVar7 ^ 0x100000;\n    if (uVar9 == 0) {\n      uVar4 = uVar4 ^ 0x100000;\n      uVar9 = 1;\n    }\n    else {\n      uVar11 = uVar11 - 1;\n    }\n  }\n  uVar6 = -uVar11 + 0x20;\n  if ((int)uVar11 < 0x21) {\n    uVar12 = param_3 << (uVar6 & 0xff);\n    param_3 = param_3 >> (uVar11 & 0xff);\n    uVar3 = uVar10 + param_3;\n    uVar5 = uVar7 << (uVar6 & 0xff);\n    uVar6 = uVar3 + uVar5;\n    uVar4 = uVar4 + CARRY4(uVar10,param_3) + ((int)uVar7 >> (uVar11 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar12 = uVar7 << (-uVar11 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar12 = uVar12 | 2;\n    }\n    uVar7 = (int)uVar7 >> (uVar11 - 0x20 & 0xff);\n    uVar6 = uVar10 + uVar7;\n    uVar4 = uVar4 + ((int)uVar7 >> 0x1f) + (uint)CARRY4(uVar10,uVar7);\n  }\n  param_2 = uVar4 & 0x80000000;\n  uVar11 = uVar4;\n  if ((int)uVar4 < 0) {\n    bVar14 = uVar12 == 0;\n    uVar12 = -uVar12;\n    uVar11 = -uVar6;\n    uVar6 = -(uint)!bVar14 - uVar6;\n    uVar11 = -(uint)(bVar14 <= uVar11) - uVar4;\n  }\n  if (0xfffff < uVar11) {\n    uVar10 = uVar9 - 1;\n    if (0x1fffff < uVar11) {\n      uVar10 = uVar11 & 1;\n      uVar11 = uVar11 >> 1;\n      bVar2 = (byte)uVar6;\n      uVar6 = (uint)(uVar10 != 0) << 0x1f | uVar6 >> 1;\n      uVar12 = (uint)(bVar2 & 1) << 0x1f | uVar12 >> 1;\n      uVar10 = uVar9;\n      if (0xffbfffff < uVar9 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 = 0x7fffffff < uVar12;\n    if (uVar12 == 0x80000000) {\n      bVar14 = (uVar6 & 1) != 0;\n    }\n    return CONCAT44(uVar11 + uVar10 * 0x100000 + (uint)CARRY4(uVar6,(uint)bVar14) | param_2,\n                    uVar6 + bVar14);\n  }\n  bVar13 = (uVar12 & 0x80000000) != 0;\n  uVar12 = uVar12 << 1;\n  uVar10 = uVar6 * 2;\n  bVar14 = CARRY4(uVar6,uVar6);\n  uVar6 = uVar6 * 2 + (uint)bVar13;\n  uVar11 = uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10,(uint)bVar13));\n  uVar10 = uVar9 - 2;\n  if (uVar9 - 1 != 0 && 0xfffff < uVar11) goto LAB_080083e0;\n  uVar7 = uVar6;\n  uVar9 = uVar11;\n  if (uVar11 == 0) {\n    uVar7 = 0;\n    uVar9 = uVar6;\n  }\n  iVar8 = count_leading_zeroes(uVar9);\n  if (uVar11 == 0) {\n    iVar8 = iVar8 + 0x20;\n  }\n  uVar11 = iVar8 - 0xb;\n  bVar15 = SBORROW4(uVar11,0x20);\n  uVar6 = iVar8 - 0x2b;\n  bVar14 = (int)uVar6 < 0;\n  bVar13 = uVar6 == 0;\n  if ((int)uVar11 < 0x20) {\n    bVar15 = SCARRY4(uVar6,0xc);\n    iVar8 = iVar8 + -0x1f;\n    bVar14 = iVar8 < 0;\n    bVar13 = iVar8 == 0;\n    uVar6 = uVar11;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar7 = uVar9 << (uVar11 & 0xff);\n      uVar9 = uVar9 >> (0xcU - iVar8 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar12 = 0x20 - uVar6;\n  }\n  uVar9 = uVar9 << (uVar6 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar9 = uVar9 | uVar7 >> (uVar12 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 << (uVar6 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar11 <= (int)uVar10) {\n    return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2,uVar7);\n  }\n  uVar6 = ~(uVar10 - uVar11);\n  if ((int)uVar6 < 0x1f) {\n    iVar8 = uVar6 - 0x13;\n    if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(uVar4,uVar7 >> (0x20 - (0xcU - iVar8) & 0xff) | uVar9 << (0xcU - iVar8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar6 = uVar6 + 1;\n    return CONCAT44(param_2 | uVar9 >> (uVar6 & 0xff),\n                    uVar7 >> (uVar6 & 0xff) | uVar9 << (0x20 - uVar6 & 0xff));\n  }\n  return CONCAT44(uVar4,uVar9 >> (uVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080082d0",
            "calling": [
                "__ieee754_atan2",
                "mc_arc",
                "cos",
                "__ieee754_sqrt",
                "sin",
                "__ieee754_hypot",
                "report_realtime_status",
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "atan",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "FUNC_080082d0"
        },
        "FUN_08008e70": {
            "renaming": {
                "FUN_08008e70": "calculate_unsigned_division_08008e70",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "uVar2": "remainder",
                "uVar4": "shift_amount",
                "uVar5": "mask",
                "uVar7": "temp",
                "iVar3": "leading_zeroes",
                "iVar6": "adjustment",
                "bVar8": "is_dividend_nonzero"
            },
            "code": "uint calculate_unsigned_division_08008e70(uint dividend, uint divisor)\n{\n  uint quotient = 0;\n  uint remainder = 0;\n  bool is_dividend_negative = false;\n  bool is_divisor_negative = false;\n  if ((dividend | divisor) == 0) {\n    return dividend;\n  }\n  if ((int)(dividend & 0x80000000) < 0) {\n    is_dividend_negative = true;\n    dividend = ~dividend + 1;\n  }\n  if ((int)(divisor & 0x80000000) < 0) {\n    is_divisor_negative = true;\n    divisor = ~divisor + 1;\n  }\n  while (dividend >= divisor) {\n    uint shift_amount = 0;\n    while (dividend >= (divisor << 1)) {\n      divisor <<= 1;\n      shift_amount++;\n    }\n    quotient |= (1 << shift_amount);\n    dividend -= divisor;\n  }\n  if (is_dividend_negative ^ is_divisor_negative) {\n    quotient = ~quotient + 1;\n  }\n  return quotient;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e70",
            "calling": [],
            "imported": false,
            "current_name": "calculate_unsigned_division_08008e70"
        },
        "FUN_08009318": {
            "renaming": {
                "FUN_08009318": "compute_double_from_uints_08009318",
                "__x": "upper_bits",
                "in_r0": "lower_bits",
                "in_r1": "exponent_bits",
                "uVar1": "exponent",
                "uVar2": "exponent_bits_shifted",
                "uVar3": "sum"
            },
            "code": "double compute_double_from_uints_08009318(uint32_t upper_bits, uint32_t lower_bits)\n{\n    uint32_t exponent_bits = (upper_bits << 1) >> 0x15;\n    int32_t exponent = exponent_bits - 0x3ff;\n    if (exponent >= -19 && exponent <= 18)\n    {\n        if (exponent < 0)\n        {\n            double sum = upper_bits + lower_bits + 2.0 * (1 << (exponent_bits - 0x3fe));\n            return sum >= 0.0 ? sum : 0.0;\n        }\n        else if ((lower_bits | (1 << (52 - exponent))) != 0)\n        {\n            double sum = upper_bits + lower_bits + (double)(1 << (52 - exponent));\n            return sum >= 0.0 ? sum : 0.0;\n        }\n    }\n    else if (exponent == 0x400)\n    {\n        return INFINITY;\n    }\n    return 0.0;\n}",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009318",
            "calling": [
                "calculate_trapezoid_for_block",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "compute_double_from_uints_08009318"
        },
        "FUN_080018cc": {
            "renaming": {
                "FUN_080018cc": "update_value_at_offset_080018cc",
                "x": "new_value",
                "val": "value_ptr",
                "*(uint32_t *)(DAT_080018f8 + 0x14)": "value_ptr",
                "*(uint *)(DAT_080018f8 + 0x14)": "value_ptr",
                "0xfffffaaf": "mask"
            },
            "code": "void update_value_at_offset_080018cc(uint32_t new_value)\n{\n  uint32_t **(uint32_t *)(DAT_080018f8 + 0x14) = (uint32_t *)(DAT_080018f8 + 0x14);\n  uint32_t mask = 0xfffffaaf;\n  **(uint32_t *)(DAT_080018f8 + 0x14) = new_value | (**(uint32_t *)(DAT_080018f8 + 0x14) & mask);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018cc",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "update_value_at_offset_080018cc"
        },
        "FUN_080079e0": {
            "renaming": {
                "FUN_080079e0": "set_interrupt_flag_080079e0",
                "IRQn": "irq_num",
                "DAT_08007a0c": "interrupt_flag_base_address",
                "interrupt_flag_ptr": "interrupt_flag_pointer",
                "bit_shift": "interrupt_flag_bit_shift"
            },
            "code": "void set_interrupt_flag_080079e0(IRQn_Type irq_num) {\n    int* interrupt_flag_ptr = (int*)(DAT_08007a0c + ((uint)(int)irq_num >> 5) * 4);\n    int bit_shift = irq_num & 0x1fU;\n    *interrupt_flag_ptr = 1 << bit_shift;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e0",
            "calling": [
                "enable_tim_interrupt"
            ],
            "imported": false,
            "current_name": "set_interrupt_flag_080079e0"
        },
        "FUN_08006a58": {
            "renaming": {
                "FUN_08006a58": "set_irq_enable_bit_08006a58",
                "IRQn": "irq_num",
                "DAT_08006a88": "irq_reg_base_addr",
                "PTR_08000000": "memory_region_base_addr"
            },
            "code": "void set_irq_enable_bit_08006a58(IRQn_Type irq_num) {\n    int* irq_reg_addr = (int*)(DAT_08006a88 + (((uint)(int)irq_num >> 5) + 0x40) * 4);\n    int irq_bit_pos = irq_num & 0x1fU;\n    *irq_reg_addr = 1 << irq_bit_pos;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a58",
            "calling": [
                "HAL_NVIC_SetPendingIRQ"
            ],
            "imported": false,
            "current_name": "set_irq_enable_bit_08006a58"
        },
        "FUN_08005a84": {
            "renaming": {
                "FUN_08005a84": "get_uwTick_value_08005a84",
                "PTR_uwTick_08005a94": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_08005a84(void)\n{\n  uint32_t* PTR_uwTick_08005a94 = (uint32_t*)PTR_uwTick_08005a94;\n  return *PTR_uwTick_08005a94;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a84",
            "calling": [
                "HAL_Delay",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "get_current_usecs",
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08005a84"
        },
        "FUN_08008b10": {
            "renaming": {
                "FUN_08008b10": "is_not_null_08008b10",
                "in_ZR": "input_char"
            },
            "code": "bool is_not_null_08008b10(char input_char) {\n  __aeabi_cdcmpeq();\n  return input_char != '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b10",
            "calling": [
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "is_not_null_08008b10"
        },
        "FUN_08004e30": {
            "renaming": {
                "FUN_08004e30": "FUNC_08004e30"
            },
            "code": "\nuint8_t FUNC_08004e30(int parameter,float value)\n\n{\n  undefined uVar1;\n  undefined2 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  uint in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 extraout_r1_05;\n  undefined4 extraout_r1_06;\n  \n  switch(parameter) {\n  case 0:\n  case 1:\n  case 2:\n    iVar3 = __aeabi_fcmple(value,in_r1,0);\n    if (iVar3 != 0) {\n      return '\\b';\n    }\n    *(uint *)(PTR_settings_080051a8 + parameter * 4) = in_r1;\n    break;\n  case 3:\n    iVar3 = __aeabi_fcmplt(in_r1,DAT_080051ac);\n    if (iVar3 != 0) {\n      return '\\t';\n    }\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1);\n    PTR_settings_080051a8[0xd] = uVar1;\n    break;\n  case 4:\n    *(uint *)(PTR_settings_080051a8 + 0x10) = in_r1;\n    break;\n  case 5:\n    *(uint *)(PTR_settings_080051a8 + 0x14) = in_r1;\n    break;\n  case 6:\n    uVar4 = __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_00);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x18) = uVar2;\n    break;\n  case 7:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1_01);\n    PTR_settings_080051a8[0x3c] = uVar1;\n    break;\n  case 8:\n    uVar4 = __aeabi_fmul(in_r1,DAT_080051b0);\n    uVar4 = __aeabi_fmul(uVar4,DAT_080051b0);\n    *(undefined4 *)(PTR_settings_080051a8 + 0x20) = uVar4;\n    break;\n  case 9:\n    *(uint *)(PTR_settings_080051a8 + 0x24) = in_r1 & 0x7fffffff;\n    break;\n  case 10:\n    *(uint *)(PTR_settings_080051a8 + 0x1c) = in_r1;\n    break;\n  case 0xb:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1_02);\n    PTR_settings_080051a8[0x3e] = uVar1;\n    break;\n  case 0xc:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1_03);\n    PTR_settings_080051a8[0x3d] = uVar1;\n    break;\n  case 0xd:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 1;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfe;\n    }\n    break;\n  case 0xe:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 2;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfd;\n    }\n    break;\n  case 0xf:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 4;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfb;\n    }\n    break;\n  case 0x10:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 8;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 0x10;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xef;\n    }\n    break;\n  case 0x12:\n    uVar4 = __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_04);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x2a) = uVar2;\n    break;\n  case 0x13:\n    *(uint *)(PTR_settings_080051a8 + 0x2c) = in_r1;\n    break;\n  case 0x14:\n    *(uint *)(PTR_settings_080051a8 + 0x30) = in_r1;\n    break;\n  case 0x15:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_05);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x34) = uVar2;\n    break;\n  case 0x16:\n    *(uint *)(PTR_settings_080051a8 + 0x38) = in_r1;\n    break;\n  case 0x17:\n    uVar4 = __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_06);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x1a) = uVar2;\n    break;\n  default:\n    return '\\x06';\n  }\n  write_global_settings();\n  return '\\0';\n}\n\n",
            "called": [
                "__aeabi_fcmple",
                "round",
                "__aeabi_fcmpeq",
                "__aeabi_fmul",
                "limits_init",
                "__aeabi_d2uiz",
                "trunc",
                "__aeabi_f2d",
                "__aeabi_fcmplt",
                "write_global_settings"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08004e30",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "FUNC_08004e30"
        },
        "FUN_0800736c": {
            "renaming": {
                "FUN_0800736c": "toggle_GPIO_pin_state_0800736c",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "pin_number",
                "ODR": "pin_state"
            },
            "code": "void toggle_GPIO_pin_state_0800736c(GPIO_TypeDef *gpio_port, uint16_t pin_number)\n{\n    gpio_port->ODR = gpio_port->ODR ^ (uint)pin_number;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800736c",
            "calling": [],
            "imported": false,
            "current_name": "toggle_GPIO_pin_state_0800736c"
        },
        "FUN_08008c30": {
            "renaming": {
                "FUN_08008c30": "calculate_float_bits_08008c30",
                "param_1": "float_bits",
                "param_2": "float_exponent",
                "uVar1": "result",
                "uVar2": "shifted_exponent",
                "uVar3": "biased_exponent",
                "in_r12": "max_biased_exponent",
                "bVar4": "is_zero",
                "bVar5": "is_less_than_max_exponent",
                "shift_amount": "shift_amount",
                "shifted_bits": "shifted_bits",
                "shifted_exponent_bits": "shifted_exponent_bits"
            },
            "code": "uint calculate_float_bits_08008c30(uint float_bits, uint float_exponent) {\n  uint shifted_exponent = float_exponent * 2;\n  bool is_less_than_max_exponent = shifted_exponent < 0x70000000;\n  uint biased_exponent = shifted_exponent + 0x90000000;\n  uint result = biased_exponent;\n  if (!is_less_than_max_exponent) {\n    uint max_biased_exponent = shifted_exponent + 0x8fe00000;\n    result = max_biased_exponent;\n  }\n  bool is_zero = result == 0;\n  if (!is_less_than_max_exponent && biased_exponent >= 0x200000) {\n    is_zero = max_biased_exponent == 0x1fc00000;\n  }\n  if (((is_less_than_max_exponent || biased_exponent < 0x200000) || 0x1fc00000 < max_biased_exponent) || is_zero) {\n    if ((float_exponent & 0x40000000) != 0) {\n      if (((int)shifted_exponent >> 0x15 == -1) && ((float_bits | float_exponent << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return float_exponent & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(shifted_exponent + 0x92e00000) < 0 != SCARRY4(biased_exponent,0x2e00000)) {\n      return float_exponent & 0x80000000;\n    }\n    uint shift_amount = 0x18 - (shifted_exponent + 0x92e00000 >> 0x15);\n    uint shifted_bits = float_bits >> (shift_amount & 0xff);\n    if (float_bits << (0x20 - shift_amount & 0xff) != 0) {\n      shifted_bits = shifted_bits | 1;\n    }\n    uint shifted_exponent_bits = float_exponent & 0x1fffff | 0x100000;\n    float_bits = shifted_bits | shifted_exponent_bits << (0x20 - shift_amount & 0xff);\n    shifted_exponent_bits = (shifted_exponent_bits >> (shift_amount & 0xff)) << 1;\n  }\n  result = (float_exponent & 0x80000000 | float_bits >> 0x1d) + shifted_exponent_bits * 4 + (uint)(0x7fffffff < float_bits * 8);\n  if (float_bits * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c30",
            "calling": [
                "homing_cycle",
                "report_realtime_status",
                "report_gcode_parameters",
                "mc_arc",
                "plan_buffer_line",
                "to_millimeters",
                "max_allowable_speed",
                "gc_execute_line",
                "read_float",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "calculate_float_bits_08008c30"
        },
        "FUN_080082d4": {
            "renaming": {
                "FUN_080082d4": "FUNC_080082d4"
            },
            "code": "\nulonglong FUNC_080082d4(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = param_2;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar5 = param_2;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar5 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar5 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar5 = -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar4 = uVar5 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar4;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar5;\n    uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if (uVar7 - 1 != 0 && 0xfffff < uVar10) goto LAB_080083e0;\n  uVar5 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar5 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar5 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar5 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar5 = uVar5 << (uVar10 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 >> (uVar10 & 0xff),\n                    uVar5 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080082d4",
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "round",
                "ceil",
                "mc_arc",
                "floor",
                "__ieee754_sqrt",
                "__ieee754_hypot",
                "__kernel_cos",
                "trunc",
                "__ieee754_rem_pio2",
                "__aeabi_drsub",
                "atan",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "FUNC_080082d4"
        },
        "FUN_08007bf0": {
            "renaming": {
                "FUN_08007bf0": "update_timer_08007bf0",
                "ticks": "saved_ticks",
                "TIMx": "timer",
                "_DAT_4000002c": "timer->CNT",
                "_DAT_40000024": "timer->ARR"
            },
            "code": "void update_timer_08007bf0(uint32_t ticks)\n{\n  uint32_t saved_ticks;\n  TIM_TypeDef *timer;\n  \n  _DAT_4000002c = ticks;\n  if (ticks <= _DAT_40000024) {\n    _DAT_40000024 = ticks;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bf0",
            "calling": [
                "set_step_events_per_minute"
            ],
            "imported": false,
            "current_name": "update_timer_08007bf0"
        },
        "FUN_08008590": {
            "renaming": {
                "FUN_08008590": "convert_uint_to_ulonglong_08008590",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "uVar5": "temp_5",
                "uVar7": "temp_7",
                "iVar6": "temp_6",
                "bVar8": "flag_1",
                "bVar9": "flag_2",
                "bVar10": "flag_3"
            },
            "code": "ulonglong convert_uint_to_ulonglong_08008590(uint input_1, undefined4 input_2, undefined4 input_3, uint input_4) {\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  int temp_6;\n  uint temp_7;\n  uint temp_8;\n  bool flag_1;\n  bool flag_2;\n  bool flag_3;\n  // Multiply input_1 by 2\n  temp_5 = input_1 << 1;\n  flag_2 = temp_5 == 0;\n  // Check if input_1 is negative\n  temp_1 = (uint)((input_1 & 0x80000000) != 0) << 0x1f;\n  // Divide temp_5 by 16\n  temp_4 = (uint)((int)temp_5 >> 3) >> 1;\n  // Combine temp_1 and temp_4\n  temp_3 = temp_1 | temp_4;\n  // Shift input_1 left by 29\n  input_1 = input_1 << 0x1d;\n  // Check if temp_5 is divisible by 2^24\n  if (!flag_2) {\n    temp_8 = temp_5 & 0xff000000;\n    flag_2 = temp_8 == 0;\n  }\n  // Check if temp_8 is equal to 0xff000000\n  if (!flag_2) {\n    flag_2 = temp_8 == 0xff000000;\n  }\n  // Return the result of the XOR operation\n  if (!flag_2) {\n    return CONCAT44(temp_3,input_1) ^ 0x3800000000000000;\n  }\n  // Check if the lower 24 bits of temp_5 are equal to 0\n  if ((temp_5 & 0xffffff) == 0) {\n    return CONCAT44(temp_3,input_1);\n  }\n  // Check if temp_8 is equal to 0xff000000\n  if (temp_8 == 0xff000000) {\n    return CONCAT44(temp_3,input_1) | 0x8000000000000;\n  }\n  // If temp_4 is equal to 0, set temp_2 to 0, otherwise set temp_2 to input_1\n  temp_2 = temp_1;\n  temp_5 = temp_4;\n  if (temp_4 == 0) {\n    temp_2 = 0;\n    temp_5 = input_1;\n  }\n  // Count the number of leading zeroes in temp_5\n  temp_6 = count_leading_zeroes(temp_5);\n  // If temp_4 is equal to 0, add 32 to temp_6\n  if (temp_4 == 0) {\n    temp_6 = temp_6 + 0x20;\n  }\n  temp_7 = temp_6 - 0xb;\n  flag_3 = SBORROW4(temp_7,0x20);\n  temp_4 = temp_6 - 0x2b;\n  flag_2 = (int)temp_4 < 0;\n  flag_1 = temp_4 == 0;\n  // If temp_7 is less than 32\n  if ((int)temp_7 < 0x20) {\n    flag_3 = SCARRY4(temp_4,0xc);\n    temp_6 = temp_6 + -0x1f;\n    flag_2 = temp_6 < 0;\n    flag_1 = temp_6 == 0;\n    temp_4 = temp_7;\n    if (!flag_1 && flag_2 == flag_3) {\n      temp_2 = temp_5 << (temp_7 & 0xff);\n      temp_5 = temp_5 >> (0xcU - temp_6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  // If temp_4 is less than 0 or greater than 18, set temp_8 to 32 - temp_4, otherwise set temp_8 to 0\n  if (flag_1 || flag_2 != flag_3) {\n    temp_8 = 0x20 - temp_4;\n  }\n  temp_5 = temp_5 << (temp_4 & 0xff);\n  // If temp_4 is less than 0 or greater than 18, shift temp_5 right by temp_8, otherwise do not shift\n  if (flag_1 || flag_2 != flag_3) {\n    temp_5 = temp_5 | temp_2 >> (temp_8 & 0xff);\n  }\n  // If temp_4 is less than 0 or greater than 18, shift temp_2 left by temp_4, otherwise do not shift\n  if (flag_1 || flag_2 != flag_3) {\n    temp_2 = temp_2 << (temp_4 & 0xff);\n  }\nLAB_08008458:\n  // If temp_7 is less than 897\n  if ((int)temp_7 < 0x381) {\n    return CONCAT44(temp_5 + (0x380 - temp_7) * 0x100000 | temp_1,temp_2);\n  }\n  // If temp_7 is greater than 897, set temp_4 to the complement of 896 - temp_7, otherwise set temp_4 to 0\n  temp_4 = ~(0x380 - temp_7);\n  // If temp_4 is greater than 30, return the result of the AND operation between CONCAT44(temp_3,temp_5) shifted right by temp_4 - 31 and 0x80000000ffffffff\n  if (0x1e < (int)temp_4) {\n    return CONCAT44(temp_3,temp_5 >> (temp_4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  temp_6 = temp_4 - 0x13;\n  // If temp_6 is equal to 0 or less than -12, set temp_4 to temp_4 + 1, and return the result of the OR operation between temp_1 and CONCAT44(temp_5 shifted right by temp_4 and temp_2 shifted left by 32 - temp_4)\n  if (temp_6 == 0 || temp_6 < 0 != SCARRY4(temp_4 - 0x1f,0xc)) {\n    temp_4 = temp_4 + 1;\n    return CONCAT44(temp_1 | temp_5 >> (temp_4 & 0xff),temp_2 >> (temp_4 & 0xff) | temp_5 << (0x20 - temp_4 & 0xff));\n  }\n  // Otherwise, return the result of the AND operation between CONCAT44(temp_3,temp_2 shifted right by 32 - (12 - temp_6) and temp_5 shifted left by 12 - temp_6) and 0x80000000ffffffff\n  return CONCAT44(temp_3,temp_2 >> (0x20 - (0xcU - temp_6) & 0xff) | temp_5 << (0xcU - temp_6 & 0xff)) & 0x80000000ffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008590",
            "calling": [
                "protocol_execute_line",
                "homing_cycle",
                "mc_arc",
                "mc_dwell",
                "max_allowable_speed",
                "read_float",
                "report_gcode_modes",
                "settings_store_global_setting",
                "calculate_trapezoid_for_block",
                "report_realtime_status",
                "report_gcode_parameters",
                "plan_buffer_line",
                "to_millimeters",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "convert_uint_to_ulonglong_08008590"
        },
        "FUN_08007ad0": {
            "renaming": {
                "FUN_08007ad0": "initialize_timer_08007ad0",
                "TIMx": "timer",
                "DAT_40000000": "TIM_CLOCK",
                "_DAT_40000000": "timer->CR1",
                "_DAT_40000004": "timer->CR2",
                "_DAT_40000008": "timer->SMCR",
                "_DAT_4000000c": "timer->DIER",
                "_DAT_40000010": "timer->CNT",
                "_DAT_40000018": "timer->PSC",
                "_DAT_4000001c": "timer->ARR",
                "_DAT_40000020": "timer->RCR",
                "_DAT_40000024": "timer->CCMR1",
                "_DAT_40000028": "timer->CCMR2",
                "_DAT_4000002c": "timer->CCER",
                "_DAT_40000034": "timer->BDTR",
                "_DAT_40000038": "timer->DCR",
                "_DAT_4000003c": "timer->DMAR",
                "PTR_SystemCoreClock_08007b68": "SYS_CLOCK_FREQ_PTR",
                "enable_tim_clock": "enable_tim_clock",
                "enable_tim_interrupt": "enable_tim_interrupt"
            },
            "code": "void initialize_timer_08007ad0(void)\n{\n  TIM_TypeDef *timer;\n  enable_tim_clock((TIM_TypeDef *)&timer);\n  _DAT_40000000 = 0;\n  _DAT_40000004 = 0;\n  _DAT_40000008 = 0;\n  _DAT_4000000c = 0;\n  _DAT_40000010 = 0;\n  _DAT_40000018 = 0;\n  _DAT_4000001c = (uint)((ulonglong)DAT_40000000_CYCLES * (ulonglong)*(uint *)PTR_SystemCoreClock_08007b68 >> 0x38) - 1;\n  _DAT_40000020 = 0;\n  _DAT_40000024 = 0;\n  _DAT_40000028 = 0;\n  _DAT_4000002c = 0;\n  _DAT_40000034 = 0;\n  _DAT_40000038 = 0;\n  _DAT_4000003c = 0;\n  enable_tim_interrupt((TIM_TypeDef *)&timer, 0, 0);\n  return;\n}",
            "called": [
                "enable_tim_interrupt",
                "enable_tim_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ad0",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007ad0"
        },
        "FUN_080005b4": {
            "renaming": {
                "FUN_080005b4": "FUNC_080005b4"
            },
            "code": "\nuint8_t FUNC_080005b4(char *line)\n\n{\n  undefined *puVar1;\n  undefined uVar2;\n  uint8_t uVar3;\n  int iVar4;\n  float fVar5;\n  undefined4 uVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  uint uVar7;\n  float fVar8;\n  float value_00;\n  float seconds;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 uVar9;\n  undefined8 extraout_d0_04;\n  undefined8 extraout_d0_05;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  float extraout_s2_05;\n  float extraout_s3;\n  float extraout_s3_00;\n  float extraout_s3_01;\n  float extraout_s3_02;\n  float extraout_s3_03;\n  float extraout_s3_04;\n  float extraout_s3_05;\n  undefined4 in_stack_ffffff48;\n  undefined4 in_stack_ffffff4c;\n  float coord_data_2 [3];\n  float coord_data_1 [3];\n  float coord_data [3];\n  float offset [3];\n  float target [3];\n  float value;\n  char letter;\n  uint8_t char_counter;\n  float y;\n  float x;\n  uint8_t isclockwise;\n  float h_x2_div_d;\n  uint8_t i_3;\n  uint8_t i_2;\n  uint8_t i_1;\n  uint8_t i;\n  uint8_t l;\n  float r;\n  float p;\n  uint8_t group_number;\n  uint8_t non_modal_action;\n  uint8_t absolute_override;\n  float inverse_feed_rate;\n  uint8_t axis_words;\n  uint16_t modal_group_words;\n  int int_value;\n  \n  if (PTR_sys_08000808[1] == '\\x06') {\n    uVar3 = '\\f';\n  }\n  else {\n    char_counter = '\\0';\n    modal_group_words = 0;\n    axis_words = '\\0';\n    inverse_feed_rate = DAT_0800080c;\n    absolute_override = '\\0';\n    non_modal_action = '\\0';\n    memset(target,0,0xc);\n    memset(offset,0,0xc);\n    *PTR_gc_08000810 = 0;\n    group_number = '\\0';\n    while (iVar4 = next_statement(&letter,&value,line,&char_counter), iVar4 != 0) {\n      uVar6 = __aeabi_f2d(value);\n      trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n      int_value = __aeabi_d2iz(uVar6,extraout_r1);\n      if (letter == 'G') {\n        switch(int_value) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0x50:\n          group_number = '\\x02';\n          break;\n        case 4:\n        case 10:\n        case 0x1c:\n        case 0x1e:\n        case 0x35:\n        case 0x5c:\n          group_number = '\\x01';\n          break;\n        case 0x11:\n        case 0x12:\n        case 0x13:\n          group_number = '\\x03';\n          break;\n        case 0x14:\n        case 0x15:\n          group_number = '\\a';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          group_number = '\\t';\n          break;\n        case 0x5a:\n        case 0x5b:\n          group_number = '\\x04';\n          break;\n        case 0x5d:\n        case 0x5e:\n          group_number = '\\x06';\n        }\n        switch(int_value) {\n        case 0:\n          PTR_gc_08000ca0[1] = 0;\n          break;\n        case 1:\n          PTR_gc_08000ca0[1] = 1;\n          break;\n        case 2:\n          PTR_gc_08000ca0[1] = 2;\n          break;\n        case 3:\n          PTR_gc_08000ca0[1] = 3;\n          break;\n        case 4:\n          non_modal_action = '\\x01';\n          break;\n        default:\n          *PTR_gc_08000ca0 = 3;\n          break;\n        case 10:\n          non_modal_action = '\\x02';\n          break;\n        case 0x11:\n          select_plane('\\0','\\x01','\\x02');\n          break;\n        case 0x12:\n          select_plane('\\x02','\\0','\\x01');\n          break;\n        case 0x13:\n          select_plane('\\x01','\\x02','\\0');\n          break;\n        case 0x14:\n          PTR_gc_08000ca0[3] = 1;\n          break;\n        case 0x15:\n          PTR_gc_08000ca0[3] = 0;\n          break;\n        case 0x1c:\n        case 0x1e:\n          uVar6 = __aeabi_fmul(value,DAT_08000ca4);\n          uVar6 = __aeabi_f2d(uVar6);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_00);\n          switch(int_value) {\n          case 0x118:\n            non_modal_action = '\\x03';\n            break;\n          case 0x119:\n            non_modal_action = '\\x04';\n            break;\n          default:\n            *PTR_gc_08000ca0 = 3;\n            break;\n          case 300:\n            non_modal_action = '\\x05';\n            break;\n          case 0x12d:\n            non_modal_action = '\\x06';\n          }\n          break;\n        case 0x35:\n          absolute_override = '\\x01';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          PTR_gc_08000ca0[0x1c] = (char)int_value + -0x36;\n          break;\n        case 0x50:\n          PTR_gc_08000ca0[1] = 4;\n          break;\n        case 0x5a:\n          PTR_gc_08000ca0[4] = 1;\n          break;\n        case 0x5b:\n          PTR_gc_08000ca0[4] = 0;\n          break;\n        case 0x5c:\n          uVar6 = __aeabi_fmul(value,DAT_08000ca4);\n          uVar6 = __aeabi_f2d(uVar6);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_01);\n          if (int_value == 0x398) {\n            non_modal_action = '\\a';\n          }\n          else if (int_value == 0x399) {\n            non_modal_action = '\\b';\n          }\n          else {\n            *PTR_gc_08000ca0 = 3;\n          }\n          break;\n        case 0x5d:\n          PTR_gc_08000ca0[2] = 1;\n          break;\n        case 0x5e:\n          PTR_gc_08000ca0[2] = 0;\n        }\n      }\n      else if (letter == 'M') {\n        if (int_value == 0x1e) {\nLAB_08000b96:\n          group_number = '\\x05';\n        }\n        else if (int_value < 0x1f) {\n          if (int_value < 3) {\n            if (-1 < int_value) goto LAB_08000b96;\n          }\n          else if (int_value - 3U < 3) {\n            group_number = '\\b';\n          }\n        }\n        switch(int_value) {\n        case 0:\n          PTR_gc_08000ca0[5] = 1;\n          break;\n        case 1:\n          break;\n        case 2:\n        case 0x1e:\n          PTR_gc_08000ca0[5] = 2;\n          break;\n        case 3:\n          PTR_gc_08000ca0[6] = 1;\n          break;\n        case 4:\n          PTR_gc_08000ca0[6] = 0xff;\n          break;\n        case 5:\n          PTR_gc_08000ca0[6] = 0;\n          break;\n        default:\n          *PTR_gc_08000ca0 = 3;\n          break;\n        case 7:\n          PTR_gc_08000ca0[7] = 2;\n          break;\n        case 8:\n          PTR_gc_08000ca0[7] = 1;\n          break;\n        case 9:\n          PTR_gc_08000ca0[7] = 0;\n        }\n      }\n      if (group_number != '\\0') {\n        if (((int)(uint)modal_group_words >> group_number & 1U) == 0) {\n          modal_group_words = modal_group_words | (ushort)(1 << group_number);\n        }\n        else {\n          *PTR_gc_08000ca0 = 5;\n        }\n        group_number = '\\0';\n      }\n    }\n    if (*PTR_gc_08000ff0 == '\\0') {\n      p = 0.0;\n      r = 0.0;\n      l = '\\0';\n      char_counter = '\\0';\nswitchD_08000d18_caseD_47:\n      iVar4 = next_statement(&letter,&value,line,&char_counter);\n      if (iVar4 != 0) {\n        fVar8 = (float)extraout_d0;\n        switch(letter) {\n        case 'F':\n          iVar4 = __aeabi_fcmple(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          if (PTR_gc_08000ff0[2] == '\\0') {\n            fVar8 = value;\n            to_millimeters(value_00);\n            *(float *)(PTR_gc_08000ff0 + 8) = fVar8;\n          }\n          else {\n            fVar8 = value;\n            to_millimeters(value_00);\n            inverse_feed_rate = fVar8;\n          }\n          break;\n        case 'G':\n        case 'M':\n        case 'N':\n          break;\n        default:\n          *PTR_gc_08000ff0 = 3;\n          break;\n        case 'I':\n        case 'J':\n        case 'K':\n          uVar7 = (uint)(byte)letter;\n          fVar5 = value;\n          to_millimeters(fVar8);\n          offset[uVar7 - 0x49] = fVar5;\n          break;\n        case 'L':\n          uVar6 = __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          l = __aeabi_d2uiz(uVar6,extraout_r1_02);\n          break;\n        case 'P':\n          p = value;\n          break;\n        case 'R':\n          fVar5 = value;\n          to_millimeters(fVar8);\n          r = fVar5;\n          break;\n        case 'S':\n          iVar4 = __aeabi_fcmplt(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          break;\n        case 'T':\n          iVar4 = __aeabi_fcmplt(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          uVar6 = __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          uVar2 = __aeabi_d2uiz(uVar6,extraout_r1_03);\n          PTR_gc_08000ff0[0x18] = uVar2;\n          break;\n        case 'X':\n          target[0] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 1;\n          break;\n        case 'Y':\n          target[1] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 2;\n          break;\n        case 'Z':\n          target[2] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 4;\n        }\n        goto switchD_08000d18_caseD_47;\n      }\n      if (*PTR_gc_08000ff0 == '\\0') {\n        uVar9 = extraout_d0;\n        fVar8 = extraout_s2;\n        fVar5 = extraout_s3;\n        if (PTR_sys_08000ff4[1] != '\\a') {\n          spindle_run(PTR_gc_08000ff0[6]);\n          coolant_run(PTR_gc_08000ff0[7]);\n          uVar9 = extraout_d0_00;\n          fVar8 = extraout_s2_00;\n          fVar5 = extraout_s3_00;\n        }\n        if ((modal_group_words & 0x200) != 0) {\n          uVar3 = settings_read_coord_data(PTR_gc_08000ff0[0x1c],coord_data);\n          puVar1 = PTR_gc_08000ff0;\n          if (uVar3 == '\\0') {\n            return '\\n';\n          }\n          *(float *)(PTR_gc_08000ff0 + 0x20) = coord_data[0];\n          *(float *)(puVar1 + 0x24) = coord_data[1];\n          *(float *)(puVar1 + 0x28) = coord_data[2];\n          uVar9 = extraout_d0_01;\n          fVar8 = extraout_s2_01;\n          fVar5 = extraout_s3_01;\n        }\n        switch(non_modal_action) {\n        case '\\x01':\n          iVar4 = __aeabi_fcmplt(p,0);\n          if (iVar4 == 0) {\n            if (PTR_sys_08000ff4[1] != '\\a') {\n              mc_dwell(seconds);\n            }\n          }\n          else {\n            *PTR_gc_08000ff0 = 6;\n          }\n          break;\n        case '\\x02':\n          uVar6 = __aeabi_f2d(p);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_04);\n          if ((((l == '\\x02') || (l == '\\x14')) && (-1 < int_value)) && (int_value < 7)) {\n            if ((axis_words == '\\0') && (l == '\\x02')) {\n              *PTR_gc_08000ff0 = 6;\n            }\n            else {\n              if (int_value < 1) {\n                int_value = (int)(byte)PTR_gc_08001304[0x1c];\n              }\n              else {\n                int_value = int_value + -1;\n              }\n              uVar3 = settings_read_coord_data((uint8_t)int_value,coord_data_2);\n              if (uVar3 == '\\0') {\n                return '\\n';\n              }\n              for (i = '\\0'; i < 3; i = i + '\\x01') {\n                if (((int)(uint)axis_words >> i & 1U) != 0) {\n                  if (l == '\\x14') {\n                    uVar7 = (uint)i;\n                    fVar8 = (float)__aeabi_fsub(*(undefined4 *)(PTR_gc_08001304 + (i + 2) * 4 + 4),\n                                                target[i]);\n                    coord_data_2[uVar7] = fVar8;\n                  }\n                  else {\n                    coord_data_2[i] = target[i];\n                  }\n                }\n              }\n              settings_write_coord_data((uint8_t)int_value,coord_data_2);\n              puVar1 = PTR_gc_08001304;\n              if (int_value == (uint)(byte)PTR_gc_08001304[0x1c]) {\n                *(float *)(PTR_gc_08001304 + 0x20) = coord_data_2[0];\n                *(float *)(puVar1 + 0x24) = coord_data_2[1];\n                *(float *)(puVar1 + 0x28) = coord_data_2[2];\n              }\n            }\n          }\n          else {\n            *PTR_gc_08000ff0 = 3;\n          }\n          axis_words = '\\0';\n          break;\n        case '\\x03':\n        case '\\x05':\n          if (axis_words != '\\0') {\n            for (i_1 = '\\0'; i_1 < 3; i_1 = i_1 + '\\x01') {\n              if (((int)(uint)axis_words >> i_1 & 1U) == 0) {\n                target[i_1] = *(float *)(PTR_gc_08001304 + (i_1 + 2) * 4 + 4);\n              }\n              else if (PTR_gc_08001304[4] == '\\0') {\n                uVar7 = (uint)i_1;\n                fVar8 = (float)__addsf3(target[i_1],\n                                        *(undefined4 *)(PTR_gc_08001304 + (i_1 + 2) * 4 + 4));\n                target[uVar7] = fVar8;\n                uVar9 = extraout_d0_03;\n                fVar8 = extraout_s2_03;\n                fVar5 = extraout_s3_03;\n              }\n              else {\n                fVar8 = target[i_1];\n                uVar6 = __addsf3(*(undefined4 *)(PTR_gc_08001304 + (i_1 + 8) * 4),\n                                 *(undefined4 *)(PTR_gc_08001304 + (i_1 + 10) * 4 + 4));\n                uVar7 = (uint)i_1;\n                fVar8 = (float)__addsf3(fVar8,uVar6);\n                target[uVar7] = fVar8;\n                uVar9 = extraout_d0_02;\n                fVar8 = extraout_s2_02;\n                fVar5 = extraout_s3_02;\n              }\n            }\n            mc_line((float)uVar9,(float)((ulonglong)uVar9 >> 0x20),fVar8,fVar5,SUB41(target[0],0));\n          }\n          if (non_modal_action == '\\x05') {\n            uVar3 = settings_read_coord_data('\\a',coord_data_1);\n            uVar9 = extraout_d0_04;\n            fVar8 = extraout_s2_04;\n            fVar5 = extraout_s3_04;\n            if (uVar3 == '\\0') {\n              return '\\n';\n            }\n          }\n          else {\n            uVar3 = settings_read_coord_data('\\x06',coord_data_1);\n            uVar9 = extraout_d0_05;\n            fVar8 = extraout_s2_05;\n            fVar5 = extraout_s3_05;\n            if (uVar3 == '\\0') {\n              return '\\n';\n            }\n          }\n          mc_line((float)uVar9,(float)((ulonglong)uVar9 >> 0x20),fVar8,fVar5,\n                  SUB41(coord_data_1[0],0));\n          puVar1 = PTR_gc_08001304;\n          *(float *)(PTR_gc_08001304 + 0xc) = coord_data_1[0];\n          *(float *)(puVar1 + 0x10) = coord_data_1[1];\n          *(float *)(puVar1 + 0x14) = coord_data_1[2];\n          axis_words = '\\0';\n          break;\n        case '\\x04':\n        case '\\x06':\n          if (non_modal_action == '\\x06') {\n            settings_write_coord_data('\\a',DAT_0800130c);\n          }\n          else {\n            settings_write_coord_data('\\x06',DAT_0800130c);\n          }\n          break;\n        case '\\a':\n          if (axis_words == '\\0') {\n            *PTR_gc_08001304 = 6;\n          }\n          else {\n            for (i_2 = '\\0'; i_2 < 3; i_2 = i_2 + '\\x01') {\n              if (((int)(uint)axis_words >> i_2 & 1U) != 0) {\n                uVar6 = __aeabi_fsub(*(undefined4 *)(PTR_gc_08001304 + (i_2 + 2) * 4 + 4),\n                                     *(undefined4 *)(PTR_gc_08001304 + (i_2 + 8) * 4));\n                uVar7 = (uint)i_2;\n                uVar6 = __aeabi_fsub(uVar6,target[i_2]);\n                *(undefined4 *)(PTR_gc_08001304 + (uVar7 + 10) * 4 + 4) = uVar6;\n              }\n            }\n          }\n          axis_words = '\\0';\n          break;\n        case '\\b':\n          memset(DAT_08001310,0,0xc);\n        }\n        if (((modal_group_words & 4) != 0) || (axis_words != '\\0')) {\n          if ((PTR_gc_08001574[2] != '\\0') &&\n             ((iVar4 = __aeabi_fcmplt(inverse_feed_rate,0), iVar4 != 0 &&\n              (PTR_gc_08001574[1] != '\\x04')))) {\n            *PTR_gc_08001574 = 6;\n          }\n          if (((absolute_override != '\\0') && (PTR_gc_08001574[1] != '\\0')) &&\n             (PTR_gc_08001574[1] != '\\x01')) {\n            *PTR_gc_08001574 = 6;\n          }\n          if (*PTR_gc_08001574 != '\\0') {\n            return *PTR_gc_08001574;\n          }\n          for (i_3 = '\\0'; puVar1 = PTR_gc_08001840, i_3 < 3; i_3 = i_3 + '\\x01') {\n            if (((int)(uint)axis_words >> i_3 & 1U) == 0) {\n              target[i_3] = *(float *)(PTR_gc_08001574 + (i_3 + 2) * 4 + 4);\n            }\n            else if (absolute_override == '\\0') {\n              if (PTR_gc_08001574[4] == '\\0') {\n                uVar7 = (uint)i_3;\n                fVar8 = (float)__addsf3(target[i_3],\n                                        *(undefined4 *)(PTR_gc_08001574 + (i_3 + 2) * 4 + 4));\n                target[uVar7] = fVar8;\n              }\n              else {\n                fVar8 = target[i_3];\n                uVar6 = __addsf3(*(undefined4 *)(PTR_gc_08001574 + (i_3 + 8) * 4),\n                                 *(undefined4 *)(PTR_gc_08001574 + (i_3 + 10) * 4 + 4));\n                uVar7 = (uint)i_3;\n                fVar8 = (float)__addsf3(fVar8,uVar6);\n                target[uVar7] = fVar8;\n              }\n            }\n          }\n          if ((byte)PTR_gc_08001574[1] < 5) {\n                    /* WARNING: Could not recover jumptable at 0x08001474. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n            uVar3 = (*(code *)(&switchD_08001474::switchdataD_08001478)[(byte)PTR_gc_08001574[1]])()\n            ;\n            return uVar3;\n          }\n          if (*PTR_gc_08001840 != '\\0') {\n            return *PTR_gc_08001840;\n          }\n          *(float *)(PTR_gc_08001840 + 0xc) = target[0];\n          *(float *)(puVar1 + 0x10) = target[1];\n          *(float *)(puVar1 + 0x14) = target[2];\n        }\n        if (PTR_gc_08001840[5] != '\\0') {\n          plan_synchronize();\n          PTR_sys_08001848[0x10] = 0;\n          if (PTR_gc_08001840[5] == '\\x02') {\n            mc_reset();\n          }\n          else {\n            PTR_gc_08001840[5] = 0;\n          }\n        }\n        uVar3 = *PTR_gc_08001840;\n      }\n      else {\n        uVar3 = *PTR_gc_08000ff0;\n      }\n    }\n    else {\n      uVar3 = *PTR_gc_08000ff0;\n    }\n  }\n  return uVar3;\n}\n\n",
            "called": [
                "next_statement",
                "memset",
                "__truncdfsf2",
                "mc_arc",
                "__aeabi_d2iz",
                "mc_dwell",
                "mc_line",
                "__addsf3",
                "__aeabi_fcmpeq",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "hypot",
                "__aeabi_fcmplt",
                "__divdf3",
                "settings_read_coord_data",
                "settings_write_coord_data",
                "plan_synchronize",
                "__aeabi_fcmple",
                "spindle_run",
                "__aeabi_fsub",
                "select_plane",
                "sqrt",
                "coolant_run",
                "__aeabi_fmul",
                "trunc",
                "to_millimeters",
                "mc_reset"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080005b4",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "FUNC_080005b4"
        },
        "FUN_080039a0": {
            "renaming": {
                "FUN_080039a0": "initialize_interface_080039a0",
                "protocol_reset_line_buffer": "reset_line_buffer",
                "report_init_message": "print_init_message",
                "PTR_buttons_enabled_080039b8": "buttons_enabled"
            },
            "code": "void initialize_interface_080039a0(void)\n{\n  reset_line_buffer();\n  print_init_message();\n  *(uint32_t *)PTR_buttons_enabled_080039b8 = 1;\n  return;\n}",
            "called": [
                "protocol_reset_line_buffer",
                "report_init_message"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039a0",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_interface_080039a0"
        },
        "FUN_08009204": {
            "renaming": {
                "FUN_08009204": "concatenate_ints_08009204",
                "param_1": "first_int",
                "param_2": "second_int",
                "CONCAT44": "bitwise_concatenate"
            },
            "code": "uint64_t concatenate_ints_08009204(uint32_t first_int, uint32_t second_int) {\n  __cmpsf2();\n  return ((uint64_t)second_int << 32) | first_int;\n}",
            "called": [
                "__cmpsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009204",
            "calling": [
                "__aeabi_fcmple",
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt"
            ],
            "imported": false,
            "current_name": "concatenate_ints_08009204"
        },
        "FUN_080029d8": {
            "renaming": {
                "FUN_080029d8": "calculate_entry_speed_080029d8",
                "previous": "previous_block",
                "current": "current_block",
                "next": "next_block",
                "iVar1": "compare_result",
                "uVar2": "speed_comparison_value",
                "fVar3": "max_entry_speed",
                "acceleration": "acceleration",
                "acceleration_00": "acceleration_00",
                "target_velocity": "target_velocity",
                "target_velocity_00": "target_velocity_00",
                "distance": "distance",
                "distance_00": "distance_00"
            },
            "code": "void calculate_entry_speed_080029d8(block_t *previous_block, block_t *current_block, block_t *next_block) {\n  int compare_result;\n  uint speed_comparison_value;\n  float acceleration;\n  float acceleration_00;\n  float target_velocity;\n  float target_velocity_00;\n  float distance;\n  float distance_00;\n\n  if (((current_block != NULL) && (next_block != NULL)) && (compare_result = __aeabi_fcmpeq(current_block->entry_speed, current_block->max_entry_speed), compare_result == 0)) {\n    if ((current_block->nominal_length_flag == \"\\0\") && (compare_result = __aeabi_fcmpgt(current_block->max_entry_speed, next_block->entry_speed), compare_result != 0)) {\n      float max_entry_speed = current_block->max_entry_speed;\n      speed_comparison_value = *(uint *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000;\n      max_allowable_speed(acceleration, target_velocity, distance);\n      compare_result = __aeabi_fcmplt(max_entry_speed, speed_comparison_value);\n      if (compare_result == 0) {\n        max_entry_speed = (float)(*(uint *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000);\n        max_allowable_speed(acceleration_00, target_velocity_00, distance_00);\n      }\n      current_block->entry_speed = max_entry_speed;\n    }\n    else {\n      current_block->entry_speed = current_block->max_entry_speed;\n    }\n    current_block->recalculate_flag = \"\\x01\";\n  }\n  return;\n}",
            "called": [
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "max_allowable_speed",
                "__aeabi_fcmpgt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080029d8",
            "calling": [
                "planner_reverse_pass"
            ],
            "imported": false,
            "current_name": "calculate_entry_speed_080029d8"
        },
        "FUN_08007c5e": {
            "renaming": {
                "FUN_08007c5e": "set_timer_ticks_08007c5e",
                "ticks": "timer_ticks",
                "TIMx": "timer"
            },
            "code": "void set_timer_ticks_08007c5e(TIM_TypeDef *timer, uint32_t ticks) {\n  timer->ARR = ticks;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c5e",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "set_timer_ticks_08007c5e"
        },
        "FUN_08005760": {
            "renaming": {
                "FUN_08005760": "step_write_with_settings_08005760",
                "PTR_settings_08005774": "settings_ptr",
                "uint": "uint16_t",
                "*(ushort *)": "*",
                "step_wr": "step_write"
            },
            "code": "void step_write_with_settings_08005760(void)\n{\n  uint16_t* PTR_settings_08005774 = (uint16_t*)(PTR_settings_08005774 + 0x18);\n  uint16_t settings_value = *PTR_settings_08005774;\n  step_write(settings_value);\n  return;\n}",
            "called": [
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005760",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "step_write_with_settings_08005760"
        },
        "FUN_080078d0": {
            "renaming": {
                "FUN_080078d0": "do_nothing_080078d0"
            },
            "code": "\nvoid do_nothing_080078d0(uint32_t bits)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078d0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080078d0"
        },
        "FUN_08008b24": {
            "renaming": {
                "FUN_08008b24": "is_end_of_string_08008b24",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_08008b24(void)\n{\n  char current_char;\n  __aeabi_cdcmpeq();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b24",
            "calling": [
                "__ieee754_hypot",
                "sqrt",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08008b24"
        },
        "FUN_08002814": {
            "renaming": {
                "FUN_08002814": "do_nothing_08002814"
            },
            "code": "\nvoid do_nothing_08002814(uint16_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002814",
            "calling": [
                "limits_go_home",
                "report_alarm_message",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "do_nothing_08002814"
        },
        "FUN_0800587c": {
            "renaming": {
                "FUN_0800587c": "update_sys_status_0800587c",
                "PTR_sys_0800589c": "sys_status"
            },
            "code": "void update_sys_status_0800587c(void)\n{\n  if (PTR_sys_0800589c[1] == '\\x03') {\n    PTR_sys_0800589c[1] = 4;\n    PTR_sys_0800589c[0x10] = 0;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800587c",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "update_sys_status_0800587c"
        },
        "FUN_08008a02": {
            "renaming": {
                "FUN_08008a02": "calculate_result_08008a02",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_var_1",
                "unaff_r4": "PTR_something",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "in_r12": "PTR_something",
                "bVar4": "bool_var_1"
            },
            "code": "ulonglong calculate_result_08008a02(uint input_1, uint input_2, uint input_3, uint input_4)\n{\n    uint temp_var_1;\n    uint temp_var_2;\n    uint temp_var_3;\n    uint temp_var_4;\n    uint temp_var_5;\n    bool bool_var_1;\n\n    temp_var_1 = input_4 >> 0x14;\n    temp_var_2 = input_2;\n    temp_var_3 = 0x7ff00000;\n    temp_var_4 = 0x80000000;\n    temp_var_5 = 0x100000;\n\n    if (input_3 != PTR_something || temp_var_1 != PTR_something)\n    {\n        if (input_3 == PTR_something)\n        {\n            if (((input_1 | (input_2 << 0xc)) == 0) && (input_1 = input_3, temp_var_2 = input_4, temp_var_1 != PTR_something))\n            {\n                return (ulonglong)((input_2 ^ input_4) & temp_var_4 | temp_var_3) << 0x20;\n            }\n        }\n        else if (temp_var_1 == PTR_something)\n        {\n            input_1 = input_3;\n            temp_var_2 = input_4;\n            if ((input_3 | (input_4 << 0xc)) == 0)\n            {\n                return (ulonglong)((input_2 ^ input_4) & temp_var_4) << 0x20;\n            }\n        }\n        else\n        {\n            bool_var_1 = (input_1 | (input_2 << 1)) == 0;\n            if (!bool_var_1)\n            {\n                bool_var_1 = (input_3 | (input_4 << 1)) == 0;\n            }\n            if (!bool_var_1)\n            {\n                if (PTR_something == 0)\n                {\n                    temp_var_2 = input_2 & temp_var_4;\n                    do\n                    {\n                        temp_var_1 = input_1 & temp_var_4;\n                        input_1 = input_1 << 1;\n                        input_2 = input_2 * 2 + (uint)(temp_var_1 != 0);\n                    } while ((input_2 & temp_var_5) == 0);\n                    input_2 = input_2 | temp_var_2;\n                    if (temp_var_1 != PTR_something)\n                    {\n                        return CONCAT44(input_2, input_1);\n                    }\n                }\n                do\n                {\n                    temp_var_2 = input_3 & temp_var_4;\n                    input_3 = input_3 << 1;\n                    input_4 = input_4 * 2 + (uint)(temp_var_2 != 0);\n                } while ((input_4 & temp_var_5) == 0);\n                return CONCAT44(input_2, input_1);\n            }\n            if ((input_1 | (input_2 << 1)) != 0)\n            {\n                return (ulonglong)((input_2 ^ input_4) & temp_var_4 | temp_var_3) << 0x20;\n            }\n            if ((input_3 | (input_4 << 1)) != 0)\n            {\n                return (ulonglong)((input_2 ^ input_4) & temp_var_4) << 0x20;\n            }\n        }\n    }\n    return CONCAT44(temp_var_2, input_1) | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a02",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "calculate_result_08008a02"
        },
        "FUN_0800369c": {
            "renaming": {
                "FUN_0800369c": "print_string_0800369c",
                "s": "str",
                "local_c": "ptr_local",
                "*local_c": "*ptr_local"
            },
            "code": "void print_string_0800369c(char *str)\n{\n  uint8_t *ptr_local;\n  ptr_local = (uint8_t *)str;\n  while (*ptr_local != '\\0') {\n    serial_write(*ptr_local);\n    ptr_local++;\n  }\n  return;\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800369c",
            "calling": [
                "protocol_execute_startup",
                "report_startup_line"
            ],
            "imported": false,
            "current_name": "print_string_0800369c"
        },
        "FUN_08005a98": {
            "renaming": {
                "FUN_08005a98": "delay_until_08005a98",
                "Delay": "target_time",
                "uVar1": "current_time",
                "uVar2": "current_tick",
                "timingdelay": "N/A"
            },
            "code": "void delay_until_08005a98(uint32_t target_time)\n{\n  uint32_t current_time;\n  current_time = HAL_GetTick();\n  while (current_time < target_time)\n  {\n    current_time = HAL_GetTick();\n  }\n  return;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a98",
            "calling": [
                "_delay_ms"
            ],
            "imported": false,
            "current_name": "delay_until_08005a98"
        },
        "FUN_08008cdc": {
            "renaming": {
                "FUN_08008cdc": "FUNC_08008cdc"
            },
            "code": "\nuint FUNC_08008cdc(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  bool bVar7;\n  \n  uVar3 = param_1 << 1;\n  bVar7 = uVar3 == 0;\n  if (!bVar7) {\n    param_4 = param_2 << 1;\n    bVar7 = param_4 == 0;\n  }\n  if (!bVar7) {\n    bVar7 = uVar3 == param_4;\n  }\n  iVar6 = (int)uVar3 >> 0x18;\n  if (!bVar7) {\n    bVar7 = iVar6 == -1;\n  }\n  if (!bVar7) {\n    bVar7 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar7) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar3 = param_2;\n      if (iVar6 == -1) {\n        uVar3 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_2 = uVar3;\n      }\n      bVar7 = (uVar3 & 0x7fffff) == 0;\n      if (bVar7) {\n        bVar7 = (param_2 & 0x7fffff) == 0;\n      }\n      if (bVar7) {\n        bVar7 = uVar3 == param_2;\n      }\n      if (!bVar7) {\n        uVar3 = uVar3 | 0x400000;\n      }\n      return uVar3;\n    }\n    if (((param_1 ^ param_2) & 0x7fffffff) != 0) {\n      if (uVar3 == 0) {\n        param_1 = param_2;\n      }\n      return param_1;\n    }\n    if (param_1 != param_2) {\n      return 0;\n    }\n    if ((uVar3 & 0xff000000) == 0) {\n      uVar3 = param_1 << 1;\n      if ((param_1 & 0x80000000) != 0) {\n        uVar3 = uVar3 | 0x80000000;\n      }\n      return uVar3;\n    }\n    if (uVar3 < 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 = param_1 & 0x80000000;\nLAB_08008e12:\n    return param_1 | 0x7f800000;\n  }\n  uVar3 = uVar3 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar5 = param_4 - uVar3;\n  bVar7 = uVar5 != 0;\n  uVar4 = uVar3;\n  if (bVar7 && uVar3 <= param_4) {\n    uVar4 = uVar3 + uVar5;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_2 = param_2 ^ param_1;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_1 = param_1 ^ param_2;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_2 = param_2 ^ param_1;\n  }\n  if (param_4 < uVar3) {\n    uVar5 = -uVar5;\n  }\n  if (0x19 < uVar5) {\n    return param_1;\n  }\n  uVar3 = param_1 & 0xffffff | 0x800000;\n  if ((param_1 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  uVar2 = param_2 & 0xffffff | 0x800000;\n  if ((param_2 & 0x80000000) != 0) {\n    uVar2 = -uVar2;\n  }\n  if (uVar4 == uVar5) {\n    uVar2 = uVar2 ^ 0x800000;\n    if (uVar4 == 0) {\n      uVar3 = uVar3 ^ 0x800000;\n      uVar4 = 1;\n    }\n    else {\n      uVar5 = uVar5 - 1;\n    }\n  }\n  uVar3 = uVar3 + ((int)uVar2 >> (uVar5 & 0xff));\n  uVar2 = uVar2 << (0x20 - uVar5 & 0xff);\n  param_1 = uVar3 & 0x80000000;\n  if ((int)uVar3 < 0) {\n    bVar7 = uVar2 != 0;\n    uVar2 = -uVar2;\n    uVar3 = -uVar3 - (uint)bVar7;\n  }\n  if (uVar3 < 0x800000) {\n    uVar5 = uVar2 & 0x80000000;\n    uVar2 = uVar2 << 1;\n    uVar3 = uVar3 * 2 + (uint)(uVar5 != 0);\n    uVar5 = uVar4 - 2;\n    if (uVar4 - 1 == 0 || uVar3 < 0x800000) {\n      iVar6 = count_leading_zeroes(uVar3);\n      uVar4 = iVar6 - 8;\n      uVar3 = uVar3 << (uVar4 & 0xff);\n      if ((int)uVar5 < (int)uVar4) {\n        uVar3 = uVar3 >> (-(uVar5 - uVar4) & 0xff);\n      }\n      else {\n        uVar3 = uVar3 + (uVar5 - uVar4) * 0x800000;\n      }\n      return uVar3 | param_1;\n    }\n  }\n  else {\n    uVar5 = uVar4 - 1;\n    if (0xffffff < uVar3) {\n      uVar5 = uVar3 & 1;\n      uVar3 = uVar3 >> 1;\n      uVar2 = (uint)(uVar5 != 0) << 0x1f | uVar2 >> 1;\n      uVar5 = uVar4;\n      if (0xfd < uVar4) goto LAB_08008e12;\n    }\n  }\n  uVar3 = uVar3 + uVar5 * 0x800000 + (uint)(0x7fffffff < uVar2);\n  if (uVar2 == 0x80000000) {\n    uVar3 = uVar3 & 0xfffffffe;\n  }\n  return uVar3 | param_1;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008cdc",
            "calling": [
                "intersection_distance",
                "report_realtime_status",
                "__aeabi_frsub",
                "mc_arc",
                "plan_buffer_line",
                "max_allowable_speed",
                "gc_execute_line",
                "printFloat",
                "estimate_acceleration_distance"
            ],
            "imported": false,
            "current_name": "FUNC_08008cdc"
        },
        "FUN_080044e8": {
            "renaming": {
                "FUN_080044e8": "print_coordinates_080044e8",
                "coord_data": "coordinate_data",
                "coord_select": "coordinate_index",
                "fVar2": "current_coordinate",
                "extraout_s0": "current_coordinate",
                "extraout_s0_00": "x_coordinate",
                "extraout_s0_01": "y_coordinate",
                "extraout_s0_02": "z_coordinate",
                "extraout_s0_03": "current_coordinate",
                "extraout_s0_04": "current_coordinate",
                "extraout_s0_05": "current_coordinate",
                "extraout_s0_06": "current_coordinate",
                "extraout_s0_07": "current_coordinate",
                "extraout_s0_08": "x_coordinate",
                "extraout_s0_09": "y_coordinate",
                "extraout_s0_10": "z_coordinate",
                "extraout_s0_11": "x_coordinate",
                "extraout_s0_12": "y_coordinate",
                "uVar1": "status",
                "i": "index"
            },
            "code": "void print_coordinates_080044e8(void)\n{\n    uint8_t status;\n    float current_coordinate;\n    float previous_coordinate;\n    float feed_rate;\n    float max_feed_rate;\n    float min_feed_rate;\n    float x_coordinate;\n    float y_coordinate;\n    float z_coordinate;\n    uint8_t i;\n    uint8_t coordinate_index;\n    coordinate_index = 0;\n    while( true ) {\n        if (coordinate_index > 6) {\n            printPgmString(PTR_s__G92__080046c8);\n            current_coordinate = z_coordinate;\n            for (i = 0; i < 3; i++) {\n                if ((PTR_settings_080046bc[0x28] & 1) == 0) {\n                    printFloat(current_coordinate);\n                }\n                else {\n                    previous_coordinate = *(float *)(PTR_gc_080046cc + (i + 10) * 4 + 4);\n                    feed_rate = previous_coordinate * DAT_08004690;\n                    max_feed_rate = PTR_settings_080046bc[0x14] * DAT_08004694;\n                    min_feed_rate = PTR_settings_080046bc[0x18] * DAT_08004694;\n                    if (feed_rate > max_feed_rate) {\n                        feed_rate = max_feed_rate;\n                    }\n                    else if (feed_rate < min_feed_rate) {\n                        feed_rate = min_feed_rate;\n                    }\n                    printFloat(feed_rate);\n                }\n                if (i < 2) {\n                    printPgmString(PTR_DAT_080046c0);\n                    current_coordinate = x_coordinate;\n                }\n                else {\n                    printPgmString(PTR_DAT_080046c4);\n                    current_coordinate = y_coordinate;\n                }\n            }\n            return;\n        }\n        status = settings_read_coordinate_data(coordinate_index, &x_coordinate, &y_coordinate, &z_coordinate);\n        if (status == 0) break;\n        printPgmString(PTR_DAT_08004698);\n        current_coordinate = z_coordinate;\n        switch(coordinate_index) {\n        case 0:\n            printPgmString(PTR_DAT_0800469c);\n            current_coordinate = x_coordinate;\n            break;\n        case 1:\n            printPgmString(PTR_DAT_080046a0);\n            current_coordinate = y_coordinate;\n            break;\n        case 2:\n            printPgmString(PTR_DAT_080046a4);\n            break;\n        case 3:\n            printPgmString(PTR_DAT_080046a8);\n            break;\n        case 4:\n            printPgmString(PTR_DAT_080046ac);\n            break;\n        case 5:\n            printPgmString(PTR_DAT_080046b0);\n            break;\n        case 6:\n            printPgmString(PTR_DAT_080046b4);\n            break;\n        case 7:\n            printPgmString(PTR_DAT_080046b8);\n            break;\n        }\n        for (i = 0; i < 3; i++) {\n            if ((PTR_settings_080046bc[0x28] & 1) == 0) {\n                printFloat(current_coordinate);\n            }\n            else {\n                previous_coordinate = *(float *)(PTR_gc_080046cc + (i + 10) * 4 + 4);\n                feed_rate = previous_coordinate * DAT_08004690;\n                max_feed_rate = PTR_settings_080046bc[0x14] * DAT_08004694;\n                min_feed_rate = PTR_settings_080046bc[0x18] * DAT_08004694;\n                if (feed_rate > max_feed_rate) {\n                    feed_rate = max_feed_rate;\n                }\n                else if (feed_rate < min_feed_rate) {\n                    feed_rate = min_feed_rate;\n                }\n                printFloat(feed_rate);\n            }\n            if (i < 2) {\n                printPgmString(PTR_DAT_080046c0);\n                current_coordinate = x_coordinate;\n            }\n            else {\n                printPgmString(PTR_DAT_080046c4);\n                current_coordinate = y_coordinate;\n            }\n        }\n        coordinate_index++;\n    }\n    report_status_message('\\n');\n    return;\n}",
            "called": [
                "settings_read_coord_data",
                "report_status_message",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3",
                "printPgmString",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044e8",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_coordinates_080044e8"
        },
        "FUN_08006c9c": {
            "renaming": {
                "FUN_08006c9c": "check_ticks_08006c9c",
                "ticks": "num_of_ticks",
                "is_less_than_16M": "is_num_of_ticks_less_than_16M",
                "DAT_08006cdc": "data_array"
            },
            "code": "uint32_t check_ticks_08006c9c(uint32_t ticks)\n{\n  bool is_less_than_16M = ticks - 1 < 0x1000000;\n  if (is_less_than_16M) {\n    DAT_08006cdc[1] = ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    DAT_08006cdc[2] = 0;\n    *DAT_08006cdc = 7;\n  }\n  return (uint)!is_less_than_16M;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c9c",
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "imported": false,
            "current_name": "check_ticks_08006c9c"
        },
        "FUN_0800a5a0": {
            "renaming": {
                "FUN_0800a5a0": "FUNC_0800a5a0"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint FUNC_0800a5a0(int param_1,undefined8 *param_2,int param_3,int param_4,int param_5,\n                      int param_6)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined4 extraout_r1;\n  int iVar5;\n  uint *puVar6;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 uVar7;\n  uint **ppuVar8;\n  int iVar9;\n  int iVar10;\n  undefined4 *puVar11;\n  undefined4 uVar12;\n  uint uVar13;\n  uint *puVar14;\n  int iVar15;\n  int iVar16;\n  undefined8 *puVar17;\n  undefined8 *puVar18;\n  undefined8 *puVar19;\n  undefined4 *puVar20;\n  undefined8 *puVar21;\n  undefined4 uVar22;\n  int iVar23;\n  undefined4 *puVar24;\n  bool bVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  undefined8 uVar29;\n  ulonglong uVar30;\n  undefined4 in_stack_fffffd78;\n  int local_280;\n  int local_26c;\n  uint *local_260 [2];\n  uint local_258 [20];\n  undefined8 uStack_208;\n  undefined4 local_168;\n  undefined4 uStack_164;\n  undefined8 local_160;\n  undefined8 uStack_c8;\n  \n  uVar29 = CONCAT44(param_5,param_5);\n  iVar16 = *(int *)(PTR_init_jk_0800a894 + param_5 * 4);\n  iVar9 = param_4 + -1;\n  local_260[1] = (uint *)param_2;\n  if (param_3 + 0x14 < 0 == SCARRY4(param_3,0x14)) {\n    local_26c = (int)((longlong)DAT_0800a898 * (longlong)(param_3 + -3) >> 0x22) -\n                (param_3 + -3 >> 0x1f);\n    iVar10 = (local_26c + 1) * -0x18;\n  }\n  else {\n    iVar10 = -0x18;\n    local_26c = 0;\n  }\n  param_3 = param_3 + iVar10;\n  iVar10 = local_26c - iVar9;\n  if (-1 < iVar16 + iVar9) {\n    iVar23 = iVar16 + iVar9 + 1 + iVar10;\n    puVar19 = &uStack_208;\n    do {\n      while (iVar10 < 0) {\n        iVar10 = iVar10 + 1;\n        *(undefined4 *)puVar19 = 0;\n        *(undefined4 *)((int)puVar19 + 4) = 0;\n        puVar19 = puVar19 + 1;\n        if (iVar10 == iVar23) goto LAB_0800a626;\n      }\n      uVar27 = __aeabi_i2d(*(undefined4 *)(param_6 + iVar10 * 4));\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\nLAB_0800a626:\n  puVar11 = (undefined4 *)(param_1 + -8);\n  if (-1 < iVar16) {\n    puVar17 = &uStack_208 + param_4;\n    iVar23 = iVar16 + param_4;\n    iVar10 = iVar9;\n    puVar19 = &uStack_c8;\n    do {\n      if (iVar9 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        puVar24 = puVar11;\n        puVar21 = puVar17;\n        do {\n          puVar20 = puVar24 + 2;\n          uVar26 = __muldf3(*puVar20,puVar24[3],*(undefined4 *)(puVar21 + -1),\n                            *(undefined4 *)((int)puVar21 + -4));\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          puVar24 = puVar20;\n          puVar21 = puVar21 + -1;\n        } while (puVar20 != puVar11 + param_4 * 2);\n      }\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar17 = puVar17 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\n  local_260[0] = local_258 + iVar16 + -1;\n  local_280 = iVar16;\n  do {\n    iVar23 = *(int *)(&uStack_c8 + local_280);\n    uVar27 = CONCAT44(*(undefined4 *)((int)&uStack_c8 + local_280 * 8 + 4),iVar23);\n    iVar10 = local_280;\n    if (0 < local_280) {\n      puVar19 = &uStack_c8 + local_280;\n      puVar6 = local_258;\n      do {\n        uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        __muldf3((int)uVar27,uVar7,0,DAT_0800a89c);\n        __aeabi_d2iz();\n        uVar26 = __aeabi_i2d();\n        uVar3 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = __muldf3((int)uVar26,uVar3,0,DAT_0800a8a0);\n        __subdf3((int)uVar27,uVar7,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        uVar2 = __aeabi_d2iz();\n        puVar17 = puVar19 + -1;\n        uVar7 = *(undefined4 *)puVar17;\n        uVar12 = *(undefined4 *)((int)puVar19 + -4);\n        *puVar6 = uVar2;\n        uVar27 = __aeabi_dadd((int)uVar26,uVar3,uVar7,uVar12);\n        iVar23 = (int)uVar27;\n        puVar19 = puVar17;\n        puVar6 = puVar6 + 1;\n      } while (puVar17 != &uStack_c8);\n    }\n    scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar23);\n    __muldf3();\n    floor((double)CONCAT44(iVar10,in_stack_fffffd78));\n    uVar27 = __muldf3();\n    uVar27 = __subdf3(iVar23,extraout_r1,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n    uVar2 = __aeabi_d2iz();\n    uVar26 = __aeabi_i2d();\n    uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                      (int)((ulonglong)uVar26 >> 0x20));\n    uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n    uVar3 = (undefined4)uVar27;\n    if (param_3 < 1) {\n      if (param_3 == 0) {\n        iVar23 = (int)local_258[iVar10 + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      iVar23 = __aeabi_dcmpge(uVar3,uVar7,0,DAT_0800ac3c);\n      if (iVar23 != 0) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          iVar23 = 2;\n          goto LAB_0800a7a4;\n        }\n        iVar23 = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      iVar5 = (int)local_258[iVar10 + -1] >> (0x18U - param_3 & 0xff);\n      uVar13 = local_258[iVar10 + -1] - (iVar5 << (0x18U - param_3 & 0xff));\n      iVar23 = (int)uVar13 >> (0x17U - param_3 & 0xff);\n      local_258[iVar10 + -1] = uVar13;\n      uVar2 = uVar2 + iVar5;\njoined_r0x0800a8b8:\n      if (0 < iVar23) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar13 = 0;\n        }\n        else {\nLAB_0800a8c8:\n          uVar13 = local_258[0];\n          if (local_258[0] == 0) {\n            if (iVar10 != 1) {\n              puVar6 = local_258;\n              iVar5 = 1;\n              do {\n                puVar6 = puVar6 + 1;\n                uVar13 = *puVar6;\n                if (uVar13 != 0) {\n                  iVar15 = iVar5 + 1;\n                  goto LAB_0800a8e2;\n                }\n                iVar5 = iVar5 + 1;\n              } while (iVar5 != iVar10);\n            }\n          }\n          else {\n            iVar15 = 1;\n            iVar5 = 0;\nLAB_0800a8e2:\n            local_258[iVar5] = 0x1000000 - uVar13;\n            if (iVar15 < iVar10) {\n              uVar13 = local_258[iVar15];\n              puVar6 = local_258 + iVar15;\n              while( true ) {\n                puVar14 = puVar6 + 1;\n                *puVar6 = 0xffffff - uVar13;\n                if (puVar14 == local_258 + iVar10) break;\n                uVar13 = *puVar14;\n                puVar6 = puVar14;\n              }\n            }\n            uVar13 = 1;\n          }\n        }\n        if (0 < param_3) {\n          if (param_3 == 1) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x7fffff;\n          }\n          else if (param_3 == 2) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x3fffff;\n          }\n        }\n        if (iVar23 == 2) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          if (uVar13 != 0) {\n            uVar3 = 0;\n            scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n            uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,extraout_r1_00);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    iVar15 = (int)uVar27;\n    iVar5 = __aeabi_dcmpeq(iVar15,(int)((ulonglong)uVar27 >> 0x20),0,0);\n    if (iVar5 == 0) {\n      scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar15);\n      iVar9 = __aeabi_dcmpge();\n      if (iVar9 == 0) {\n        iVar5 = iVar10;\n        uVar13 = __aeabi_d2iz(iVar15,extraout_r1_02);\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar5;\n      }\n      else {\n        __muldf3(iVar15,extraout_r1_02,0,DAT_0800ade8);\n        uVar13 = __aeabi_d2iz();\n        uVar27 = __aeabi_i2d();\n        uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,DAT_0800ade4);\n        __subdf3(iVar15,extraout_r1_02,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n        iVar9 = iVar10;\n        uVar4 = __aeabi_d2iz();\n        iVar5 = iVar10 + 1;\n        local_258[iVar10] = uVar4;\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar9;\n      }\n      goto LAB_0800a9f6;\n    }\n    iVar5 = iVar10 + -1;\n    if (iVar16 <= iVar5) {\n      uVar13 = 0;\n      puVar6 = local_258 + iVar10 + 0x3fffffff;\n      do {\n        puVar14 = puVar6 + -1;\n        uVar13 = uVar13 | *puVar6;\n        puVar6 = puVar14;\n      } while (puVar14 != local_260[0]);\n      if (uVar13 != 0) break;\n    }\n    if (local_258[iVar16 + -1] == 0) {\n      local_280 = 1;\n      ppuVar8 = local_260 + iVar16;\n      do {\n        puVar6 = *ppuVar8;\n        local_280 = local_280 + 1;\n        ppuVar8 = ppuVar8 + -1;\n      } while (puVar6 == (uint *)0x0);\n      local_280 = iVar10 + local_280;\n    }\n    else {\n      local_280 = iVar10 + 1;\n    }\n    iVar23 = iVar10 + 1;\n    puVar24 = (undefined4 *)(param_6 + (iVar23 + local_26c + 0x3fffffff) * 4);\n    puVar19 = &uStack_208 + iVar10 + param_4;\n    puVar17 = &uStack_c8 + iVar23;\n    do {\n      puVar24 = puVar24 + 1;\n      uVar27 = __aeabi_i2d(*puVar24);\n      *puVar19 = uVar27;\n      puVar21 = puVar19 + 1;\n      if (iVar9 < 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        puVar20 = puVar11;\n        while( true ) {\n          puVar19 = puVar19 + -1;\n          puVar1 = puVar20 + 2;\n          uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),*puVar1,puVar20[3]);\n          uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                                (int)((ulonglong)uVar27 >> 0x20));\n          if (puVar1 == puVar11 + param_4 * 2) break;\n          uVar27 = *puVar19;\n          puVar20 = puVar1;\n        }\n      }\n      *puVar17 = uVar26;\n      iVar23 = iVar23 + 1;\n      puVar19 = puVar21;\n      puVar17 = puVar17 + 1;\n    } while (iVar23 <= local_280);\n  } while( true );\n  if (local_258[iVar5] == 0) {\n    puVar6 = local_258 + iVar10 + 0x3ffffffe;\n    do {\n      uVar13 = *puVar6;\n      iVar5 = iVar5 + -1;\n      puVar6 = puVar6 + -1;\n    } while (uVar13 == 0);\n  }\nLAB_0800a9f6:\n  uVar3 = 0;\n  scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n  uVar27 = CONCAT44(extraout_r1_01,uVar3);\n  if (iVar5 < 0) {\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        puVar19 = (undefined8 *)&local_168;\n        uVar29 = 0;\nLAB_0800abe4:\n        if (iVar23 == 0) {\n          uVar3 = *(undefined4 *)(puVar19 + 1);\n          uVar7 = *(undefined4 *)((int)puVar19 + 0xc);\n          *local_260[1] = local_168;\n          *(undefined4 *)((int)local_260[1] + 4) = uStack_164;\n          *(undefined8 *)((int)local_260[1] + 0x10) = uVar29;\n          *(undefined4 *)((int)local_260[1] + 8) = uVar3;\n          *(undefined4 *)((int)local_260[1] + 0xc) = uVar7;\n          return uVar2 & 7;\n        }\n        iVar9 = *(int *)((int)puVar19 + 4);\n        *(int *)((int)local_260[1] + 0x10) = (int)uVar29;\n        iVar16 = *(int *)((int)puVar19 + 0xc);\n        *(undefined4 *)((int)local_260[1] + 8) = *(undefined4 *)(puVar19 + 1);\n        *(int *)((int)local_260[1] + 0x14) = (int)((ulonglong)uVar29 >> 0x20) + -0x80000000;\n        uVar3 = *(undefined4 *)puVar19;\n        *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n        *(int *)((int)local_260[1] + 0xc) = iVar16 + -0x80000000;\n        *local_260[1] = uVar3;\n        return uVar2 & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\nLAB_0800aafc:\n      iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n      if (iVar23 != 0) {\n        iVar9 = iVar9 + -0x80000000;\n      }\n      *local_260[1] = (int)uVar29;\n      *(int *)((int)local_260[1] + 4) = iVar9;\nLAB_0800ab0e:\n      return uVar2 & 7;\n    }\n    uVar29 = 0;\n  }\n  else {\n    puVar17 = &uStack_c8 + iVar5;\n    puVar6 = local_258 + iVar5 + 1;\n    puVar19 = &uStack_c8 + iVar5 + 1;\n    do {\n      uVar3 = (undefined4)((ulonglong)uVar27 >> 0x20);\n      puVar6 = puVar6 + -1;\n      uVar26 = __aeabi_i2d(*puVar6);\n      uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,uVar3);\n      puVar19 = puVar19 + -1;\n      *puVar19 = uVar26;\n      uVar27 = __muldf3((int)uVar27,uVar3,0,DAT_0800ac40);\n    } while (puVar6 != local_258);\n    puVar19 = (undefined8 *)&local_168;\n    iVar9 = 0;\n    uVar3 = DAT_0800ac30;\n    uVar7 = DAT_0800ac34;\n    do {\n      DAT_0800ac30 = uVar3;\n      DAT_0800ac34 = uVar7;\n      if (iVar16 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        iVar10 = 0;\n        puVar21 = puVar17;\n        puVar11 = (undefined4 *)PTR_DAT_0800ac44;\n        while( true ) {\n          uVar26 = __muldf3(*(undefined4 *)puVar21,*(undefined4 *)((int)puVar21 + 4),uVar3,uVar7);\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          iVar10 = iVar10 + 1;\n          if ((iVar16 < iVar10) || (iVar9 < iVar10)) break;\n          uVar3 = *puVar11;\n          uVar7 = puVar11[1];\n          puVar21 = puVar21 + 1;\n          puVar11 = puVar11 + 2;\n        }\n      }\n      bVar25 = iVar9 != iVar5;\n      puVar19[iVar9] = uVar27;\n      puVar17 = puVar17 + -1;\n      iVar9 = iVar9 + 1;\n      uVar3 = DAT_0800ac30;\n      uVar7 = DAT_0800ac34;\n    } while (bVar25);\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        if (iVar5 != 0) {\n          puVar17 = puVar19 + iVar5;\n          uVar29 = *puVar17;\n          do {\n            uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n            uVar3 = (undefined4)uVar29;\n            uVar12 = *(undefined4 *)(puVar17 + -1);\n            uVar22 = *(undefined4 *)((int)puVar17 + -4);\n            uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n            uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n            uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n            *puVar17 = uVar27;\n            puVar17 = puVar17 + -1;\n            *puVar17 = uVar29;\n          } while (puVar19 != puVar17);\n          if (1 < iVar5) {\n            puVar21 = puVar19 + iVar5;\n            uVar29 = *puVar21;\n            puVar17 = puVar21;\n            do {\n              uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n              uVar3 = (undefined4)uVar29;\n              uVar12 = *(undefined4 *)(puVar17 + -1);\n              uVar22 = *(undefined4 *)((int)puVar17 + -4);\n              uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n              uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n              uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n              *puVar17 = uVar27;\n              puVar17 = puVar17 + -1;\n              *puVar17 = uVar29;\n            } while (&local_160 != puVar17);\n            uVar29 = 0;\n            puVar18 = puVar19 + 2;\n            puVar17 = puVar21 + 1;\n            do {\n              puVar21 = puVar17 + -1;\n              uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),\n                                    *(undefined4 *)puVar21,*(undefined4 *)((int)puVar17 + -4));\n              puVar17 = puVar21;\n            } while (puVar18 != puVar21);\n            goto LAB_0800abe4;\n          }\n        }\n        uVar29 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\n      puVar17 = puVar19 + iVar5 + 1;\n      do {\n        puVar21 = puVar17 + -1;\n        uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                              *(undefined4 *)((int)puVar17 + -4));\n        puVar17 = puVar21;\n      } while (puVar19 != puVar21);\n      goto LAB_0800aafc;\n    }\n    uVar29 = 0;\n    puVar17 = puVar19 + iVar5 + 1;\n    do {\n      puVar21 = puVar17 + -1;\n      uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                            *(undefined4 *)((int)puVar17 + -4));\n      puVar17 = puVar21;\n    } while (puVar19 != puVar21);\n  }\n  iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n  uVar3 = (undefined4)uVar29;\n  if (iVar23 == 0) {\n    *(undefined8 *)local_260[1] = uVar29;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (iVar5 < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    iVar9 = 1;\n    puVar19 = (undefined8 *)&local_168;\n    do {\n      uVar30 = __aeabi_dadd((int)uVar30,(int)(uVar30 >> 0x20),*(undefined4 *)(puVar19 + 1),\n                            *(undefined4 *)((int)puVar19 + 0xc));\n      iVar9 = iVar9 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar9 <= iVar5);\n    if (iVar23 == 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_260[1] = uVar3;\n    *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (0 < iVar5) goto LAB_0800ad04;\n  }\n  uVar30 = uVar30 & 0xffffffff | (ulonglong)((int)(uVar30 >> 0x20) + 0x80000000) << 0x20;\nLAB_0800ad26:\n  *(ulonglong *)((int)local_260[1] + 8) = uVar30;\n  return uVar2 & 7;\n}\n\n",
            "called": [
                "floor",
                "scalbn",
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__aeabi_d2iz",
                "__aeabi_i2d",
                "__subdf3",
                "__aeabi_dcmpge"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800a5a0",
            "calling": [
                "__ieee754_rem_pio2"
            ],
            "imported": false,
            "current_name": "FUNC_0800a5a0"
        },
        "FUN_0800195c": {
            "renaming": {
                "FUN_0800195c": "check_reset_needed_0800195c",
                "PTR_sys_08001990": "sys_data"
            },
            "code": "void check_reset_needed_0800195c(void)\n{\n  if ((PTR_sys_08001990[1] != '\\x06') && ((PTR_sys_08001990[2] & 0x20) == 0)) {\n    mc_reset();\n    PTR_sys_08001990[2] |= 0x40;\n  }\n  return;\n}",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800195c",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "check_reset_needed_0800195c"
        },
        "FUN_08009214": {
            "renaming": {
                "FUN_08009214": "is_not_null_08009214",
                "in_ZR": "input_char"
            },
            "code": "bool is_not_null_08009214(char input_char)\n{\n  __aeabi_cfcmpeq();\n  return input_char != '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009214",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "mc_arc",
                "gc_execute_line",
                "read_float",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "is_not_null_08009214"
        },
        "FUN_08004dd2": {
            "renaming": {
                "FUN_08004dd2": "read_settings_from_eeprom_08004dd2",
                "bVar1": "eeprom_version",
                "iVar2": "result",
                "version": "success_flag",
                "PTR_settings_08004e2c": "settings_data",
                "memcpy_from_eeprom_with_checksum": "memcpy_from_eeprom_with_checksum",
                "settings_reset": "reset_settings"
            },
            "code": "uint8_t read_settings_from_eeprom_08004dd2(void)\n{\n  byte eeprom_version;\n  int result;\n  uint8_t success_flag;\n  eeprom_version = eeprom_get_char(0);\n  if (eeprom_version == 5) {\n    result = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c, 1, 0x40);\n    if (result == 0) {\n      return 0;\n    }\n  }\n  else {\n    if (eeprom_version > 4) {\n      return 0;\n    }\n    result = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c, 1, 0x28);\n    if (result == 0) {\n      return 0;\n    }\n    reset_settings(false);\n  }\n  return 1;\n}",
            "called": [
                "settings_reset",
                "memcpy_from_eeprom_with_checksum",
                "eeprom_get_char"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004dd2",
            "calling": [
                "settings_init"
            ],
            "imported": false,
            "current_name": "read_settings_from_eeprom_08004dd2"
        },
        "FUN_08008244": {
            "renaming": {
                "FUN_08008244": "do_nothing_08008244"
            },
            "code": "\nvoid do_nothing_08008244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008244",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008244"
        },
        "FUN_08005778": {
            "renaming": {
                "FUN_08005778": "step_write_from_saved_step_bits_08005778",
                "PTR_saved_step_bits_0800578c": "PTR_saved_step_bits_0800578c",
                "step_wr": "step_wr",
                "uint": "uint",
                "ushort": "uint16_t"
            },
            "code": "void step_write_from_saved_step_bits_08005778(void)\n{\n  uint16_t* saved_step_bits = (uint16_t*)PTR_saved_step_bits_0800578c;\n  uint16_t step_bits = *saved_step_bits;\n  step_wr(step_bits);\n  return;\n}",
            "called": [
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005778",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "step_write_from_saved_step_bits_08005778"
        },
        "FUN_080028bc": {
            "renaming": {
                "FUN_080028bc": "calculate_acceleration_080028bc",
                "in_r0": "initial_velocity",
                "in_r1": "final_velocity",
                "in_r2": "time",
                "uVar1": "velocity_difference_squared",
                "uVar2": "time_doubled",
                "fVar3": "acceleration"
            },
            "code": "float calculate_acceleration_080028bc(float initial_velocity, float final_velocity, float time) {\n  float velocity_difference_squared = pow((final_velocity - initial_velocity), 2);\n  float time_doubled = time * 2;\n  float acceleration = velocity_difference_squared / time_doubled;\n  return acceleration;\n}",
            "called": [
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fsub",
                "__aeabi_fdiv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028bc",
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "imported": false,
            "current_name": "calculate_acceleration_080028bc"
        },
        "FUN_08006628": {
            "renaming": {
                "FUN_08006628": "get_system_core_clock_frequency_08006628",
                "uVar1": "sys_clock_freq",
                "uVar2": "count_leading_zeroes_result",
                "result": "apb_ahb_prescaler",
                "result_1": "system_core_clock_frequency"
            },
            "code": "uint32_t get_system_core_clock_frequency_08006628(void)\n{\n  uint32_t sys_clock_freq = HAL_RCC_GetSysClockFreq();\n  uint32_t apb_ahb_prescaler = PTR_APBAHBPrescTable_08006678[(*(uint *)(DAT_08006674 + 8) & 0xf0) >> (count_leading_zeroes(0xf000000) & 0xff)];\n  *(uint32_t *)PTR_SystemCoreClock_0800667c = sys_clock_freq >> apb_ahb_prescaler;\n  return *(uint32_t *)PTR_SystemCoreClock_0800667c;\n}",
            "called": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006628",
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "imported": false,
            "current_name": "get_system_core_clock_frequency_08006628"
        },
        "FUN_080078e2": {
            "renaming": {
                "FUN_080078e2": "do_nothing_080078e2"
            },
            "code": "\nvoid do_nothing_080078e2(uint32_t bits)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078e2",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080078e2"
        },
        "FUN_08008b38": {
            "renaming": {
                "FUN_08008b38": "is_not_equal_to_zero_08008b38",
                "in_CY": "is_CY_zero",
                "in_ZR": "in_ZR"
            },
            "code": "bool is_not_equal_to_zero_08008b38(void)\n{\n  bool is_CY_zero = __aeabi_cdcmpeq();\n  return !is_CY_zero || in_ZR;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b38",
            "calling": [],
            "imported": false,
            "current_name": "is_not_equal_to_zero_08008b38"
        },
        "FUN_0800738e": {
            "renaming": {
                "FUN_0800738e": "check_GPIO_pin_0800738e",
                "GPIO_Pin": "pin",
                "DAT_080073bc": "data_ptr"
            },
            "code": "void check_GPIO_pin_0800738e(uint16_t pin) {\n  uint32_t* ptr = (uint32_t*)(DAT_080073bc + 0x14);\n  uint32_t mask = *ptr;\n  if ((pin & mask) != 0) {\n    *ptr = pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738e",
            "calling": [],
            "imported": false,
            "current_name": "check_GPIO_pin_0800738e"
        },
        "FUN_08002828": {
            "renaming": {
                "FUN_08002828": "do_nothing_08002828"
            },
            "code": "\nvoid do_nothing_08002828(uint32_t us)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002828",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "do_nothing_08002828"
        },
        "FUN_080053a0": {
            "renaming": {
                "FUN_080053a0": "FUNC_080053a0"
            },
            "code": "\nvoid FUNC_080053a0(void)\n\n{\n  block_t *pbVar1;\n  int iVar2;\n  \n  dirn_wr((uint)*(ushort *)PTR_dirn_bits_080055f0);\n  *(undefined2 *)PTR_saved_step_bits_080055f8 = *(undefined2 *)PTR_step_bits_080055f4;\n  if (*(int *)PTR_current_block_080055fc == 0) {\n    pbVar1 = plan_get_current_block();\n    *(block_t **)PTR_current_block_080055fc = pbVar1;\n    if (*(int *)PTR_current_block_080055fc == 0) {\n      st_go_idle();\n      PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n    }\n    else {\n      if (PTR_sys_08005600[1] == '\\x03') {\n        *(undefined4 *)(PTR_st_08005604 + 0x1c) =\n             *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x28);\n        set_step_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n        *(undefined4 *)(PTR_st_08005604 + 0x18) = DAT_08005608;\n      }\n      *(int *)(PTR_st_08005604 + 0x20) =\n           (*(int *)(*(int *)PTR_current_block_080055fc + 0x30) >> 1) +\n           *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n      *(int *)PTR_st_08005604 = -(*(int *)(*(int *)PTR_current_block_080055fc + 0x10) >> 1);\n      *(undefined4 *)(PTR_st_08005604 + 4) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 8) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 0xc) =\n           *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x10);\n      *(undefined4 *)(PTR_st_08005604 + 0x10) = 0;\n    }\n  }\n  if (*(int *)PTR_current_block_080055fc != 0) {\n    *(undefined2 *)PTR_dirn_bits_080055f0 = **(undefined2 **)PTR_current_block_080055fc;\n    *(undefined2 *)PTR_step_bits_080055f4 = 0;\n    *(int *)PTR_st_08005604 =\n         *(int *)(*(int *)PTR_current_block_080055fc + 4) + *(int *)PTR_st_08005604;\n    if (0 < *(int *)PTR_st_08005604) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x10;\n      *(int *)PTR_st_08005604 = *(int *)PTR_st_08005604 - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x20) == 0) {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 4) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 8) + *(int *)(PTR_st_08005604 + 4);\n    if (0 < *(int *)(PTR_st_08005604 + 4)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x440;\n      *(int *)(PTR_st_08005604 + 4) =\n           *(int *)(PTR_st_08005604 + 4) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x80) == 0) {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 8) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 0xc) + *(int *)(PTR_st_08005604 + 8);\n    if (0 < *(int *)(PTR_st_08005604 + 8)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x100;\n      *(int *)(PTR_st_08005604 + 8) =\n           *(int *)(PTR_st_08005604 + 8) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x200) == 0) {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 0x10) = *(int *)(PTR_st_08005604 + 0x10) + 1;\n    if (*(uint *)(PTR_st_08005604 + 0x10) < *(uint *)(*(int *)PTR_current_block_080055fc + 0x10)) {\n      if (PTR_sys_08005600[1] == '\\x04') {\n        iVar2 = iterate_trapezoid_cycle_counter();\n        if (iVar2 != 0) {\n          if (*(uint *)(*(int *)PTR_current_block_080055fc + 0x30) <\n              *(uint *)(PTR_st_08005604 + 0x1c)) {\n            *(int *)(PTR_st_08005604 + 0x1c) =\n                 *(int *)(PTR_st_08005604 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n            set_step_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n          }\n          else {\n            st_go_idle();\n            PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n          }\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x34)) {\n        iVar2 = iterate_trapezoid_cycle_counter();\n        if (iVar2 != 0) {\n          *(int *)(PTR_st_08005748 + 0x1c) =\n               *(int *)(PTR_st_08005748 + 0x1c) +\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          if (*(uint *)(*(int *)PTR_current_block_0800574c + 0x3c) <=\n              *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          }\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) != *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n               *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(int *)(PTR_st_08005748 + 0x10) ==\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) == *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x18) = DAT_08005750;\n        }\n        else {\n          *(int *)(PTR_st_08005748 + 0x18) = 420000 - *(int *)(PTR_st_08005748 + 0x18);\n        }\n      }\n      else {\n        iVar2 = iterate_trapezoid_cycle_counter();\n        if (iVar2 != 0) {\n          if (*(uint *)(PTR_st_08005748 + 0x20) < *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(int *)(PTR_st_08005748 + 0x1c) =\n                 *(int *)(PTR_st_08005748 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          }\n          else {\n            *(uint *)(PTR_st_08005748 + 0x1c) = *(uint *)(PTR_st_08005748 + 0x1c) >> 1;\n          }\n          if (*(uint *)(PTR_st_08005748 + 0x1c) <\n              *(uint *)(*(int *)PTR_current_block_0800574c + 0x2c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x2c);\n          }\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n    }\n    else {\n      *(undefined2 *)PTR_step_bits_08005754 = 0;\n      *(undefined4 *)PTR_current_block_0800574c = 0;\n      plan_discard_current_block();\n    }\n  }\n  *(ushort *)PTR_step_bits_08005754 =\n       *(ushort *)PTR_step_bits_08005754 ^ *(ushort *)(PTR_settings_08005758 + 0x18);\n  *(ushort *)PTR_dirn_bits_0800575c =\n       *(ushort *)PTR_dirn_bits_0800575c ^ *(ushort *)(PTR_settings_08005758 + 0x1a);\n  return;\n}\n\n",
            "called": [
                "iterate_trapezoid_cycle_counter",
                "plan_discard_current_block",
                "st_go_idle",
                "plan_get_current_block",
                "dirn_wr",
                "set_step_events_per_minute"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080053a0",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "FUNC_080053a0"
        },
        "FUN_080092c4": {
            "renaming": {
                "FUN_080092c4": "initialize_system_080092c4",
                "iVar1": "i",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "UNRECOVERED_JUMPTABLE",
                "PTR_completed_8911_0800930c": "PTR_completed_8911_0800930c",
                "PTR_SystemCoreClock_08009304": "PTR_SystemCoreClock_08009304",
                "PTR_completed_8911_08009308": "PTR_completed_8911_08009308",
                "PTR___fini_array_end_08009300": "PTR___fini_array_end_08009300",
                "PTR__ebss_08009310": "PTR__ebss_08009310"
            },
            "code": "void initialize_system_080092c4(void)\n{\n  int i = 0;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8911_0800930c;\n  undefined4 *clock_ptr = PTR_SystemCoreClock_08009304;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (i = 0; clock_ptr + i < PTR_completed_8911_08009308; i += 4) {\n    *(undefined4 *)(clock_ptr + i) = *(undefined4 *)(PTR___fini_array_end_08009300 + i);\n  }\n  \n  for (; completed_ptr < PTR__ebss_08009310; completed_ptr++) {\n    *completed_ptr = 0;\n  }\n  \n  SystemInit();\n  __libc_init_array();\n  \n  UNRECOVERED_JUMPTABLE = (code *)0x80092fa;\n  main();\n  \n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080092c4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_080092c4"
        },
        "FUN_0800770e": {
            "renaming": {
                "FUN_0800770e": "do_nothing_0800770e"
            },
            "code": "\nvoid do_nothing_0800770e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800770e",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800770e"
        },
        "FUN_08008250": {
            "renaming": {
                "FUN_08008250": "print_data_to_usart_08008250",
                "data": "data"
            },
            "code": "void print_data_to_usart_08008250(uint8_t data)\n{\n  usart_putc(data);\n  return;\n}",
            "called": [
                "usart_putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008250",
            "calling": [
                "printString",
                "printInteger",
                "print_uint32_base10",
                "print_base2",
                "printPgmString",
                "printFloat"
            ],
            "imported": false,
            "current_name": "print_data_to_usart_08008250"
        },
        "FUN_0800184c": {
            "renaming": {
                "FUN_0800184c": "validate_letter_and_read_float_0800184c",
                "*letter": "*current_letter",
                "*float_ptr": "*float_ptr",
                "*line": "*line",
                "*char_counter": "*char_counter",
                "*PTR_gc_080018c8": "*PTR_gc_080018c8",
                "iVar1": "result",
                "read_float": "read_float"
            },
            "code": "int validate_letter_and_read_float_0800184c(char *current_letter, float *float_ptr, char *line, uint8_t *char_counter) {\n  int result = 0;\n  if (line[*char_counter] == '\\0') {\n    result = 0;\n  }\n  else {\n    *current_letter = line[*char_counter];\n    if (((byte)*current_letter < 0x41) || (0x5a < (byte)*current_letter)) {\n      *PTR_gc_080018c8 = 2;\n      result = 0;\n    }\n    else {\n      *char_counter = *char_counter + '\\x01';\n      result = read_float(line, char_counter, float_ptr);\n      if (result == 0) {\n        *PTR_gc_080018c8 = 1;\n        result = 0;\n      }\n      else {\n        result = 1;\n      }\n    }\n  }\n  return result;\n}",
            "called": [
                "read_float"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800184c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "validate_letter_and_read_float_0800184c"
        },
        "FUN_08001f00": {
            "renaming": {
                "FUN_08001f00": "FUNC_08001f00"
            },
            "code": "\nvoid FUNC_08001f00(float *position,float *target,float *offset,uint8_t axis_0,uint8_t axis_1,\n           uint8_t axis_linear,float feed_rate,uint8_t invert_feed_rate,float radius,\n           uint8_t isclockwise)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int iVar6;\n  float fVar7;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  float extraout_s2;\n  float z;\n  float extraout_s2_00;\n  float extraout_s3;\n  float feed_rate_00;\n  float extraout_s3_00;\n  float feed_rate_01;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  undefined3 in_stack_00000009;\n  undefined4 in_stack_00000010;\n  char in_stack_00000014;\n  uint in_stack_ffffff78;\n  undefined4 in_stack_ffffff7c;\n  undefined3 in_stack_ffffff80;\n  uint uVar10;\n  byte bVar11;\n  float arc_target [3];\n  float r_axisi;\n  float sin_Ti;\n  float cos_Ti;\n  float sin_T;\n  float cos_T;\n  float linear_per_segment;\n  float theta_per_segment;\n  uint16_t segments;\n  float millimeters_of_travel;\n  float rt_axis1;\n  float rt_axis0;\n  float linear_travel;\n  float center_axis1;\n  float center_axis0;\n  int8_t count;\n  uint16_t i;\n  float angular_travel;\n  float r_axis1;\n  float r_axis0;\n  \n  uVar10 = CONCAT13(axis_0,in_stack_ffffff80);\n  center_axis0 = (float)__addsf3(feed_rate,position[axis_0],offset[axis_0]);\n  center_axis1 = (float)__addsf3(position[axis_1],offset[axis_1]);\n  uVar1 = __aeabi_fsub(target[axis_linear],position[axis_linear]);\n  bVar11 = (byte)(uVar10 >> 0x18);\n  r_axis0 = (float)((uint)offset[bVar11] ^ 0x80000000);\n  r_axis1 = (float)((uint)offset[axis_1] ^ 0x80000000);\n  uVar2 = __aeabi_fsub(target[bVar11],center_axis0);\n  uVar3 = __aeabi_fsub(target[axis_1],center_axis1);\n  uVar4 = __aeabi_fmul(r_axis0,uVar3);\n  uVar5 = __aeabi_fmul(r_axis1,uVar2);\n  uVar4 = __aeabi_fsub(uVar4,uVar5);\n  uVar8 = __aeabi_f2d(uVar4);\n  uVar2 = __aeabi_fmul(r_axis0,uVar2);\n  uVar3 = __aeabi_fmul(r_axis1,uVar3);\n  uVar2 = __addsf3(uVar2,uVar3);\n  uVar9 = __aeabi_f2d(uVar2);\n  uVar8 = atan2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar9,\n                (int)((ulonglong)uVar9 >> 0x20));\n  angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  if (in_stack_00000014 == '\\0') {\n    iVar6 = __aeabi_fcmple(angular_travel,0);\n    if (iVar6 != 0) {\n      uVar8 = __aeabi_f2d(angular_travel);\n      uVar8 = __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),DAT_08002240,DAT_08002244);\n      angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  else {\n    iVar6 = __aeabi_fcmpge(angular_travel,0);\n    if (iVar6 != 0) {\n      uVar8 = __aeabi_f2d(angular_travel);\n      uVar8 = __subdf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),DAT_08002240,DAT_08002244);\n      angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  uVar2 = __aeabi_fmul(angular_travel,in_stack_00000010);\n  uVar2 = __aeabi_f2d(uVar2);\n  __aeabi_f2d(uVar1 & 0x7fffffff);\n  hypot((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78),(double)CONCAT44(offset,uVar10));\n  uVar2 = __truncdfsf2(uVar2,extraout_r1);\n  iVar6 = __aeabi_fcmpeq(uVar2,0);\n  if (iVar6 == 0) {\n    uVar2 = __aeabi_fdiv(uVar2,*(undefined4 *)(PTR_settings_08002248 + 0x1c));\n    uVar2 = __aeabi_f2d(uVar2);\n    floor((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n    segments = __aeabi_d2uiz(uVar2,extraout_r1_00);\n    if (isclockwise != '\\0') {\n      uVar2 = __floatsisf(segments);\n      __aeabi_fmul(_invert_feed_rate,uVar2);\n    }\n    uVar2 = __floatsisf(segments);\n    sin_T = (float)__aeabi_fdiv(angular_travel,uVar2);\n    uVar2 = __floatsisf(segments);\n    linear_per_segment = (float)__aeabi_fdiv(uVar1,uVar2);\n    uVar8 = __aeabi_f2d(sin_T);\n    uVar8 = __muldf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),0,DAT_0800224c);\n    uVar9 = __aeabi_f2d(sin_T);\n    uVar8 = __muldf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar9,\n                     (int)((ulonglong)uVar9 >> 0x20));\n    uVar8 = __subdf3(0,DAT_08002250,(int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    cos_T = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    count = '\\0';\n    theta_per_segment = sin_T;\n    arc_target[axis_linear] = position[axis_linear];\n    uVar8 = extraout_d0;\n    fVar7 = extraout_s2;\n    feed_rate_01 = extraout_s3;\n    for (i = 1; i < segments; i = i + 1) {\n      if ((int)count < (int)(uint)(byte)PTR_settings_08002248[0x3e]) {\n        uVar2 = __aeabi_fmul(r_axis0,sin_T);\n        uVar3 = __aeabi_fmul(r_axis1,cos_T);\n        fVar7 = (float)__addsf3(uVar2,uVar3);\n        uVar2 = __aeabi_fmul(r_axis0,cos_T);\n        uVar3 = __aeabi_fmul(r_axis1,sin_T);\n        r_axis0 = (float)__aeabi_fsub(uVar2,uVar3);\n        count = count + '\\x01';\n        r_axis1 = fVar7;\n      }\n      else {\n        uVar2 = __floatsisf(i);\n        uVar2 = __aeabi_fmul(uVar2,theta_per_segment);\n        uVar2 = __aeabi_f2d(uVar2);\n        cos((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar2 = __truncdfsf2(uVar2,extraout_r1_01);\n        uVar3 = __floatsisf(i);\n        uVar3 = __aeabi_fmul(uVar3,theta_per_segment);\n        uVar3 = __aeabi_f2d(uVar3);\n        sin((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar3 = __truncdfsf2(uVar3,extraout_r1_02);\n        uVar4 = __aeabi_fmul((uint)offset[uVar10 >> 0x18] ^ 0x80000000,uVar2);\n        uVar5 = __aeabi_fmul(offset[axis_1],uVar3);\n        r_axis0 = (float)__addsf3(uVar4,uVar5);\n        uVar3 = __aeabi_fmul((uint)offset[uVar10 >> 0x18] ^ 0x80000000,uVar3);\n        uVar2 = __aeabi_fmul(offset[axis_1],uVar2);\n        r_axis1 = (float)__aeabi_fsub(uVar3,uVar2);\n        count = '\\0';\n      }\n      uVar1 = uVar10 >> 0x18;\n      fVar7 = (float)__addsf3(center_axis0,r_axis0);\n      arc_target[uVar1] = fVar7;\n      fVar7 = (float)__addsf3(center_axis1,r_axis1);\n      arc_target[axis_1] = fVar7;\n      fVar7 = (float)__addsf3(arc_target[axis_linear],linear_per_segment);\n      arc_target[axis_linear] = fVar7;\n      in_stack_ffffff78 = (uint)isclockwise;\n      mc_line((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 >> 0x20),z,feed_rate_00,\n              SUB41(arc_target[0],0));\n      if (*PTR_sys_08002404 != '\\0') {\n        return;\n      }\n      uVar8 = extraout_d0_01;\n      fVar7 = extraout_s2_00;\n      feed_rate_01 = extraout_s3_00;\n    }\n    mc_line((float)uVar8,(float)((ulonglong)uVar8 >> 0x20),fVar7,feed_rate_01,SUB41(*target,0));\n  }\n  return;\n}\n\n",
            "called": [
                "__aeabi_fcmple",
                "__aeabi_fcmpge",
                "atan2",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__aeabi_dadd",
                "__muldf3",
                "cos",
                "__aeabi_fdiv",
                "mc_line",
                "__subdf3",
                "floor",
                "__addsf3",
                "sin",
                "__aeabi_fmul",
                "__aeabi_fcmpeq",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "hypot",
                "__floatsisf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001f00",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "FUNC_08001f00"
        },
        "FUN_08005ad4": {
            "renaming": {
                "FUN_08005ad4": "extract_upper_bits_08005ad4",
                "*DAT_08005ae8": "data_pointer",
                "return": "upper_bits",
                ">> 0x10": ">> 16",
                "uint32_t": "",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "uint32_t extract_upper_bits_08005ad4(void)\n{\n    uint32_t* *DAT_08005ae8 = DAT_08005ae8;\n    uint32_t data_value = **DAT_08005ae8;\n    uint32_t upper_bits = data_value >> 16;\n    return upper_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ad4",
            "calling": [],
            "imported": false,
            "current_name": "extract_upper_bits_08005ad4"
        },
        "FUN_08005b3c": {
            "renaming": {
                "FUN_08005b3c": "set_data_flag_08005b3c",
                "DAT_08005b54": "data_start_ptr",
                "PTR_": "ptr_",
                "uint": "unsigned_int",
                "*": "ptr_to_"
            },
            "code": "void set_data_flag_08005b3c(void)\n{\n    uint* data_ptr = (uint*)(DAT_08005b54 + 4);\n    *data_ptr |= 2;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b3c",
            "calling": [],
            "imported": false,
            "current_name": "set_data_flag_08005b3c"
        },
        "FUN_08006ce0": {
            "renaming": {
                "FUN_08006ce0": "set_priority_group_08006ce0",
                "PriorityGroup": "priority_group"
            },
            "code": "void set_priority_group_08006ce0(uint32_t priority_group)\n{\n    NVIC_SetPriorityGrouping(priority_group);\n    return;\n}",
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ce0",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "set_priority_group_08006ce0"
        },
        "FUN_08006d4a": {
            "renaming": {
                "FUN_08006d4a": "disable_irq_08006d4a",
                "IRQn": "irq"
            },
            "code": "void disable_irq_08006d4a(IRQn_Type irq)\n{\n  NVIC_DisableIRQ(irq);\n  return;\n}",
            "called": [
                "NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d4a",
            "calling": [],
            "imported": false,
            "current_name": "disable_irq_08006d4a"
        },
        "FUN_08008894": {
            "renaming": {
                "FUN_08008894": "FUNC_08008894"
            },
            "code": "\nulonglong FUNC_08008894(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  ulonglong uVar17;\n  \n  uVar17 = CONCAT44(param_2,param_1);\n  uVar13 = 0x7ff;\n  uVar7 = param_2 >> 0x14 & 0x7ff;\n  bVar14 = uVar7 == 0;\n  if (!bVar14) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar14 = unaff_r5 == 0;\n  }\n  if (!bVar14) {\n    bVar14 = uVar7 == 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 = unaff_r5 == 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 = calculate_result_08008a02();\n  }\n  uVar9 = (uint)(uVar17 >> 0x20);\n  uVar11 = (uint)uVar17;\n  iVar8 = uVar7 - unaff_r5;\n  if ((param_3 | param_4 << 0xc) == 0) {\n    uVar7 = (uVar9 ^ param_4) & 0x80000000 | uVar9 & 0xfffff;\n    bVar16 = SCARRY4(iVar8,uVar13 >> 1);\n    uVar9 = iVar8 + (uVar13 >> 1);\n    bVar14 = (int)uVar9 < 0;\n    bVar15 = uVar9 == 0;\n    if (!bVar15 && bVar14 == bVar16) {\n      bVar16 = SBORROW4(uVar13,uVar9);\n      bVar14 = (int)(uVar13 - uVar9) < 0;\n      bVar15 = uVar13 == uVar9;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      uVar7 = uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      return uVar17 & 0xffffffff | (ulonglong)uVar7 << 0x20;\n    }\n    uVar7 = uVar7 | 0x100000;\n    uVar13 = 0;\n    bVar15 = SBORROW4(uVar9,1);\n    uVar9 = uVar9 - 1;\n    bVar14 = uVar9 == 0;\n    uVar3 = uVar9;\n  }\n  else {\n    uVar3 = (param_4 << 0xc) >> 4 | 0x10000000 | param_3 >> 0x18;\n    uVar13 = param_3 << 8;\n    uVar10 = (uVar9 << 0xc) >> 4 | 0x10000000 | uVar11 >> 0x18;\n    uVar11 = uVar11 * 0x100;\n    uVar7 = (uVar9 ^ param_4) & 0x80000000;\n    bVar14 = uVar3 <= uVar10;\n    if (uVar10 == uVar3) {\n      bVar14 = uVar13 <= uVar11;\n    }\n    iVar8 = iVar8 + (uint)bVar14;\n    uVar9 = iVar8 + 0x3fd;\n    if (bVar14 == false) {\n      uVar3 = uVar3 >> 1;\n      uVar13 = (uint)((param_3 >> 0x18 & 1) != 0) << 0x1f | uVar13 >> 1;\n    }\n    uVar12 = uVar11 - uVar13;\n    uVar10 = (uVar10 - uVar3) - (uint)(uVar11 < uVar13);\n    uVar4 = uVar3 >> 1;\n    uVar1 = (uint)((uVar3 & 1) != 0) << 0x1f | uVar13 >> 1;\n    uVar11 = 0x100000;\n    uVar3 = 0x80000;\n    while( true ) {\n      bVar14 = uVar1 <= uVar12;\n      if (uVar4 < uVar10 || uVar10 - uVar4 < (uint)bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar11 = uVar11 | uVar3;\n        uVar10 = (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 = uVar4 >> 1;\n      uVar1 = (uint)((uVar4 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar10 - uVar5 < (uint)bVar15;\n      uVar13 = uVar10;\n      if (uVar5 < uVar10 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar13 = (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 < uVar10 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 1;\n      }\n      uVar10 = uVar4 >> 2;\n      uVar2 = (uint)((uVar5 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar2 <= uVar12;\n      bVar14 = uVar13 - uVar10 < (uint)bVar15;\n      uVar5 = uVar13;\n      if (uVar10 < uVar13 || bVar14) {\n        uVar12 = uVar12 - uVar2;\n        uVar5 = (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 < uVar13 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 2;\n      }\n      uVar6 = uVar4 >> 3;\n      uVar1 = (uint)((uVar10 & 1) != 0) << 0x1f | uVar2 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar5 - uVar6 < (uint)bVar15;\n      uVar10 = uVar5;\n      if (uVar6 < uVar5 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar10 = (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 < uVar5 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 3;\n      }\n      uVar13 = uVar10 | uVar12;\n      if (uVar13 == 0) break;\n      uVar10 = uVar10 << 4 | uVar12 >> 0x1c;\n      uVar12 = uVar12 << 4;\n      uVar4 = uVar4 & 0xfffffff8 | uVar1 >> 0x1d;\n      uVar1 = (uVar2 >> 1) << 3;\n      uVar3 = uVar3 >> 4;\n      if (uVar3 == 0) {\n        uVar6 = uVar4;\n        if ((uVar7 & 0x100000) != 0) goto LAB_080089b2;\n        uVar7 = uVar7 | uVar11;\n        uVar11 = 0;\n        uVar3 = 0x80000000;\n      }\n    }\n    if ((uVar7 & 0x100000) == 0) {\n      uVar7 = uVar7 | uVar11;\n      uVar11 = 0;\n    }\nLAB_080089b2:\n    bVar16 = 0xfc < uVar9;\n    bVar15 = SBORROW4(uVar9,0xfd);\n    uVar4 = iVar8 + 0x300;\n    bVar14 = uVar4 == 0;\n    uVar3 = uVar4;\n    if (bVar16 && !bVar14) {\n      bVar16 = 0x6ff < uVar4;\n      bVar15 = SBORROW4(uVar4,0x700);\n      uVar3 = iVar8 - 0x400;\n      bVar14 = uVar4 == 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 = uVar6 <= uVar10;\n      if (uVar10 == uVar6) {\n        bVar14 = uVar1 <= uVar12;\n      }\n      if (uVar10 == uVar6 && uVar12 == uVar1) {\n        bVar14 = (uVar11 & 1) != 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 && (int)uVar3 < 0 == bVar15) {\n    return (ulonglong)(uVar7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar16 = SCARRY4(uVar9,0x36);\n  bVar14 = (int)(uVar9 + 0x36) < 0;\n  bVar15 = uVar9 == 0xffffffca;\n  if (bVar15 || bVar14 != bVar16) {\n    uVar11 = 0;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    uVar7 = uVar7 & 0x80000000;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 = -uVar9;\n  uVar10 = uVar3 - 0x20;\n  if (0x1f < (int)uVar3) {\n    uVar3 = uVar11 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff);\n    uVar9 = (uVar7 >> (uVar10 & 0xff) & ~((uVar7 & 0x80000000) >> (uVar10 & 0xff))) -\n            ((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar11 << (0x20 - uVar10 & 0xff) | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) & 0x80000000ffffffff;\n  }\n  iVar8 = uVar3 - 0x14;\n  if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar10,0xc)) {\n    uVar9 = 0xc - iVar8;\n    uVar3 = uVar11 << (uVar9 & 0xff);\n    uVar11 = uVar11 >> (0x20 - uVar9 & 0xff) | uVar7 << (uVar9 & 0xff);\n    uVar9 = uVar11 + -((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44((uVar7 & 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 >> 0x1f)),uVar9);\n  }\n  uVar10 = uVar11 << (uVar9 + 0x20 & 0xff);\n  uVar11 = uVar11 >> (uVar3 & 0xff) | uVar7 << (uVar9 + 0x20 & 0xff);\n  uVar9 = uVar11 + -((int)uVar10 >> 0x1f);\n  if ((uVar13 | uVar10 << 1) == 0) {\n    uVar9 = uVar9 & ~(uVar10 >> 0x1f);\n  }\n  return CONCAT44((uVar7 & 0x80000000) +\n                  ((uVar7 & 0x7fffffff) >> (uVar3 & 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 >> 0x1f)),uVar9);\n}\n\n",
            "called": [
                "FUN_08008a02"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008894",
            "calling": [
                "__ieee754_sqrt",
                "__ieee754_atan2",
                "sqrt",
                "homing_cycle",
                "plan_buffer_line",
                "gc_execute_line",
                "atan"
            ],
            "imported": false,
            "current_name": "FUNC_08008894"
        },
        "FUN_08000374": {
            "renaming": {
                "FUN_08000374": "write_to_eeprom_08000374",
                "destination": "memory_address",
                "source": "data",
                "size": "data_size",
                "local_1c": "remaining_size",
                "local_18": "current_byte",
                "local_14": "current_destination",
                "checksum": "checksum"
            },
            "code": "void write_to_eeprom_08000374(uint destination, char* source, uint size)\n{\n  uint remaining_size;\n  uchar* current_byte;\n  uint current_destination;\n  uchar checksum = 0;\n  remaining_size = size;\n  current_byte = (uchar*)source;\n  current_destination = destination;\n  if (*(int*)PTR_eeprom_ready_080003e8 == 0) {\n    eeprom_init();\n    current_byte = (uchar*)source;\n    current_destination = destination;\n  }\n  for (; remaining_size != 0; remaining_size--) {\n    checksum = (checksum != 0) + *current_byte;\n    eeprom_put_char(current_destination, *current_byte);\n    current_byte++;\n    current_destination++;\n  }\n  eeprom_put_char(current_destination, checksum);\n  return;\n}",
            "called": [
                "eeprom_put_char",
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000374",
            "calling": [
                "settings_write_coord_data",
                "settings_store_startup_line",
                "write_global_settings"
            ],
            "imported": false,
            "current_name": "write_to_eeprom_08000374"
        },
        "FUN_080037fc": {
            "renaming": {
                "FUN_080037fc": "print_unsigned_long_080037fc",
                "n": "number",
                "local_c": "absolute_number",
                "ulong": "unsigned long"
            },
            "code": "void print_unsigned_long_080037fc(long number) {\n  unsigned long absolute_number;\n  absolute_number = number;\n  if (number < 0) {\n    serial_write('-');\n    absolute_number = -number;\n  }\n  print_uint32_base10(absolute_number);\n  return;\n}",
            "called": [
                "print_uint32_base10",
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037fc",
            "calling": [
                "report_grbl_settings",
                "report_startup_line",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "print_unsigned_long_080037fc"
        },
        "FUN_08007dd8": {
            "renaming": {
                "FUN_08007dd8": "set_timer_mode_08007dd8",
                "puVar1": "timer_reg",
                "TIMx": "N/A",
                "DAT_08007e04": "N/A"
            },
            "code": "void set_timer_mode_08007dd8(void)\n{\n  uint32_t *timer_reg = DAT_08007e04;\n  *timer_reg &= 0xfffffffe;\n  timer_reg[8] &= 0xffffffef;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007dd8",
            "calling": [],
            "imported": false,
            "current_name": "set_timer_mode_08007dd8"
        },
        "FUN_0800a1bc": {
            "renaming": {
                "FUN_0800a1bc": "calculate_0800a1bc",
                "param_1": "num1",
                "param_2": "num2",
                "uVar1": "quotient",
                "uVar2": "bit_position",
                "iVar3": "temp",
                "uVar4": "bit_mask",
                "uVar5": "divisor",
                "uVar6": "shift_amount",
                "uVar7": "remainder",
                "uVar8": "dividend",
                "uVar9": "difference",
                "uVar10": "temp",
                "uVar11": "bit_position",
                "uVar12": "dividend",
                "uVar13": "quotient",
                "uVar14": "temp"
            },
            "code": "uint calculate_0800a1bc(uint num1, uint num2) {\n  uint quotient;\n  uint remainder;\n  uint divisor;\n  uint shift_amount;\n  uint bit_position;\n  uint bit_mask;\n  uint temp;\n  if ((0x0800a340 & ~num2) == 0) {\n    temp = num1 * num2;\n    quotient = temp + (temp >> 32);\n    return quotient;\n  }\n  if ((int)num2 < 1) {\n    if ((num2 & 0x7fffffff | num1) == 0) {\n      return num1;\n    }\n    if (num2 != 0) {\n      temp = num1 - num2;\n      divisor = (uint)((ulonglong)temp >> 32);\n      quotient = __divdf3((int)temp, divisor, (int)temp, divisor);\n      return quotient;\n    }\n    do {\n      shift_amount = num1 >> 11;\n      bit_position = 0x15 - num2;\n      num1 <<= 21;\n    } while (shift_amount == 0);\n    remainder = num2;\n    if ((int)num1 < 0) {\n      bit_mask = 0xffffffff;\n      divisor = num1;\n    }\n    else {\n      bit_mask = 0;\n      divisor = 0;\n    }\n  }\n  else {\n    bit_position = num2 >> 20;\n    remainder = num2;\n    divisor = num1;\n    if (bit_position != 0) {\n      bit_mask = 0x80000000;\n      bit_position = 32 - bit_position;\n      remainder = num2 << bit_position;\n      divisor = num1 >> bit_position | num1 << (32 - bit_position);\n    }\n    else {\n      bit_mask = 0;\n    }\n  }\n  divisor |= 0x100000;\n  if ((int)(remainder << 31) < 0) {\n    divisor = divisor * 2 - ((int)divisor >> 31);\n    remainder <<= 1;\n  }\n  quotient = 0;\n  divisor = divisor * 2 - ((int)remainder >> 31);\n  remainder <<= 1;\n  bit_position = 22;\n  bit_mask >>= 1;\n  do {\n    temp = divisor + bit_mask;\n    if ((int)temp <= (int)remainder) {\n      remainder -= temp;\n      divisor = temp + bit_mask;\n      quotient |= bit_mask;\n    }\n    bit_position--;\n    bit_mask >>= 1;\n  } while (bit_position != 0);\n  if ((divisor | remainder) == 0) {\n    quotient <<= 1;\n  }\n  else if (remainder == 0xffffffff) {\n    quotient += 1;\n  }\n  return quotient;\n}",
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a1bc",
            "calling": [
                "__ieee754_hypot",
                "sqrt"
            ],
            "imported": false,
            "current_name": "calculate_0800a1bc"
        },
        "FUN_0800525c": {
            "renaming": {
                "FUN_0800525c": "spindle_direction_control_0800525c",
                "direction": "new_direction",
                "*PTR_current_direction_080052a8": "current_direction",
                "spindle_rev": "spindle_reverse",
                "spindle_fwd": "spindle_forward",
                "spindle_on": "spindle_turn_on"
            },
            "code": "void spindle_direction_control_0800525c(int8_t new_direction)\n{\n  int8_t *PTR_current_direction_080052a8 = *PTR_*PTR_current_direction_080052a8_080052a8;\n  if (new_direction != *PTR_current_direction_080052a8) {\n    plan_synchronize();\n    if (new_direction == 0) {\n      spindle_stop();\n    }\n    else {\n      if (new_direction < 1) {\n        spindle_reverse();\n      }\n      else {\n        spindle_forward();\n      }\n      spindle_turn_on();\n    }\n    *PTR_*PTR_current_direction_080052a8_080052a8 = new_direction;\n  }\n  return;\n}",
            "called": [
                "plan_synchronize",
                "spindle_stop",
                "spindle_fwd",
                "spindle_on",
                "spindle_rev"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800525c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "spindle_direction_control_0800525c"
        },
        "FUN_080073d4": {
            "renaming": {
                "FUN_080073d4": "set_bit_in_short_array_080073d4",
                "n": "bit_index"
            },
            "code": "void set_bit_in_short_array_080073d4(int bit_index)\n{\n    int array_index = bit_index >> 4;\n    short* array_start = (short*)(array_index * 0x400 + 0x4002001a);\n    int bit_offset = bit_index & 0xfU;\n    short bit_mask = 1 << bit_offset;\n    *array_start = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d4",
            "calling": [
                "debounce_off_handler"
            ],
            "imported": false,
            "current_name": "set_bit_in_short_array_080073d4"
        },
        "FUN_080085e4": {
            "renaming": {
                "FUN_080085e4": "FUNC_080085e4"
            },
            "code": "\nulonglong FUNC_080085e4(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  bool bVar11;\n  bool bVar12;\n  \n  if ((param_1 | param_2) == 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  uVar8 = param_2 & 0x80000000;\n  uVar3 = param_2;\n  if ((int)uVar8 < 0) {\n    bVar11 = param_1 != 0;\n    param_1 = -param_1;\n    uVar3 = -param_2 - (uint)bVar11;\n  }\n  iVar7 = 0x432;\n  uVar9 = uVar3 >> 0x16;\n  if (uVar9 != 0) {\n    iVar7 = 3;\n    if (uVar3 >> 0x19 != 0) {\n      iVar7 = 6;\n    }\n    if (uVar3 >> 0x1c != 0) {\n      iVar7 = iVar7 + 3;\n    }\n    uVar4 = iVar7 - ((int)uVar3 >> 0x1f);\n    uVar9 = param_1 << (0x20 - uVar4 & 0xff);\n    param_1 = param_1 >> (uVar4 & 0xff) | uVar3 << (0x20 - uVar4 & 0xff);\n    uVar3 = uVar3 >> (uVar4 & 0xff);\n    iVar7 = uVar4 + 0x432;\n  }\n  if (0xfffff < uVar3) {\n    if (0x1fffff < uVar3) {\n      uVar4 = uVar3 & 1;\n      uVar3 = uVar3 >> 1;\n      bVar1 = (byte)param_1;\n      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;\n      uVar9 = (uint)(bVar1 & 1) << 0x1f | uVar9 >> 1;\n      iVar7 = iVar7 + 1;\n      if (0xffbfffff < (uint)(iVar7 * 0x200000)) {\n        return (ulonglong)(uVar8 | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080083e0:\n    bVar11 = 0x7fffffff < uVar9;\n    if (uVar9 == 0x80000000) {\n      bVar11 = (param_1 & 1) != 0;\n    }\n    return CONCAT44(uVar3 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar11) | uVar8,\n                    param_1 + bVar11);\n  }\n  bVar10 = (uVar9 & 0x80000000) != 0;\n  uVar9 = uVar9 << 1;\n  uVar4 = param_1 * 2;\n  bVar11 = CARRY4(param_1,param_1);\n  param_1 = param_1 * 2 + (uint)bVar10;\n  uVar3 = uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4,(uint)bVar10));\n  bVar11 = iVar7 != 0;\n  iVar7 = iVar7 + -1;\n  if (bVar11 && 0xfffff < uVar3) goto LAB_080083e0;\n  uVar2 = param_1;\n  uVar4 = uVar3;\n  if (uVar3 == 0) {\n    uVar2 = 0;\n    uVar4 = param_1;\n  }\n  iVar5 = count_leading_zeroes(uVar4);\n  if (uVar3 == 0) {\n    iVar5 = iVar5 + 0x20;\n  }\n  uVar6 = iVar5 - 0xb;\n  bVar12 = SBORROW4(uVar6,0x20);\n  uVar3 = iVar5 - 0x2b;\n  bVar11 = (int)uVar3 < 0;\n  bVar10 = uVar3 == 0;\n  if ((int)uVar6 < 0x20) {\n    bVar12 = SCARRY4(uVar3,0xc);\n    iVar5 = iVar5 + -0x1f;\n    bVar11 = iVar5 < 0;\n    bVar10 = iVar5 == 0;\n    uVar3 = uVar6;\n    if (!bVar10 && bVar11 == bVar12) {\n      uVar2 = uVar4 << (uVar6 & 0xff);\n      uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar10 || bVar11 != bVar12) {\n    uVar9 = 0x20 - uVar3;\n  }\n  uVar4 = uVar4 << (uVar3 & 0xff);\n  if (bVar10 || bVar11 != bVar12) {\n    uVar4 = uVar4 | uVar2 >> (uVar9 & 0xff);\n  }\n  if (bVar10 || bVar11 != bVar12) {\n    uVar2 = uVar2 << (uVar3 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar6 <= iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8,uVar2);\n  }\n  uVar3 = ~(iVar7 - uVar6);\n  if ((int)uVar3 < 0x1f) {\n    iVar7 = uVar3 - 0x13;\n    if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar3 - 0x1f,0xc)) {\n      return CONCAT44(param_2,uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |\n                              uVar4 << (0xcU - iVar7 & 0xff)) & 0x80000000ffffffff;\n    }\n    uVar3 = uVar3 + 1;\n    return CONCAT44(uVar8 | uVar4 >> (uVar3 & 0xff),\n                    uVar2 >> (uVar3 & 0xff) | uVar4 << (0x20 - uVar3 & 0xff));\n  }\n  return CONCAT44(param_2,uVar4 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080085e4",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_080085e4"
        },
        "FUN_08006dfe": {
            "renaming": {
                "FUN_08006dfe": "clear_pending_interrupt_08006dfe",
                "IRQn": "interrupt_type"
            },
            "code": "void clear_pending_interrupt_08006dfe(IRQn_Type interrupt_type)\n{\n  NVIC_ClearPendingIRQ(interrupt_type);\n  return;\n}",
            "called": [
                "NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dfe",
            "calling": [],
            "imported": false,
            "current_name": "clear_pending_interrupt_08006dfe"
        },
        "FUN_08006d66": {
            "renaming": {
                "FUN_08006d66": "reset_system_08006d66"
            },
            "code": "void reset_system_08006d66(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d66",
            "calling": [],
            "imported": false,
            "current_name": "reset_system_08006d66"
        },
        "FUN_08006e88": {
            "renaming": {
                "FUN_08006e88": "configure_GPIO_pins_08006e88",
                "GPIO_TypeDef": "GPIOx",
                "GPIO_InitTypeDef": "GPIO_Init",
                "uVar1": "alternate_function",
                "uVar2": "pin_mask",
                "uVar3": "pin_state",
                "iVar4": "exti_value",
                "temp": "temp",
                "iocurrent": "iocurrent",
                "ioposition": "ioposition",
                "position": "position"
            },
            "code": "void configure_GPIO_pins_08006e88(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)\n{\n    for (uint32_t position = 0; position < 16; position++) {\n        uint32_t pin_mask = 1 << (position & 0xff);\n        uint32_t pin_state = GPIO_Init->Pin & pin_mask;\n        if (pin_state == pin_mask) {\n            if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) {\n                uint32_t alternate_function = GPIO_Init->Alternate;\n                uint32_t afr_index = position >> 3;\n                uint32_t afr_shift = (position & 7) << 2;\n                GPIOx->AFR[afr_index] &= ~(0xf << afr_shift);\n                GPIOx->AFR[afr_index] |= alternate_function << afr_shift;\n            }\n            uint32_t moder_shift = (position & 0x7f) << 1;\n            GPIOx->MODER &= ~(3 << moder_shift);\n            GPIOx->MODER |= (GPIO_Init->Mode & 3) << moder_shift;\n            if ((((GPIO_Init->Mode == GPIO_MODE_INPUT) || (GPIO_Init->Mode == GPIO_MODE_AF_PP)) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) || (GPIO_Init->Mode == GPIO_MODE_ANALOG)) {\n                uint32_t ospeedr_shift = (position & 0x7f) << 1;\n                GPIOx->OSPEEDR &= ~(3 << ospeedr_shift);\n                GPIOx->OSPEEDR |= GPIO_Init->Speed << ospeedr_shift;\n                uint32_t otyper_shift = position & 0xff;\n                GPIOx->OTYPER &= ~(1 << otyper_shift);\n                GPIOx->OTYPER |= (GPIO_Init->Mode >> 4 & 1) << otyper_shift;\n            }\n            uint32_t pupdr_shift = (position & 0x7f) << 1;\n            GPIOx->PUPDR &= ~(3 << pupdr_shift);\n            GPIOx->PUPDR |= GPIO_Init->Pull << pupdr_shift;\n            if ((GPIO_Init->Mode & GPIO_MODE_IT_RISING_FALLING) != 0) {\n                uint32_t exti_shift = (position & 3) << 2;\n                uint32_t exti_index = (position >> 2) + 2;\n                uint32_t exti_mask = ~(0xf << exti_shift);\n                uint32_t exti_value = (GPIOx == GPIOA) ? 0 : ((GPIOx == GPIOB) ? 1 : ((GPIOx == GPIOC) ? 2 : ((GPIOx == GPIOD) ? 3 : ((GPIOx == GPIOE) ? 4 : ((GPIOx == GPIOF) ? 5 : ((GPIOx == GPIOG) ? 6 : ((GPIOx == GPIOH) ? 7 : 10)))))));\n                uint32_t exti_register = (exti_index * 4) + (uint32_t)0x40013C00;\n                *(uint32_t*)exti_register &= exti_mask;\n                *(uint32_t*)exti_register |= exti_value << exti_shift;\n                *(uint32_t*)0x40013C40 &= ~pin_mask;\n                *(uint32_t*)0x40013C44 &= ~pin_mask;\n                if ((GPIO_Init->Mode & GPIO_MODE_IT_RISING) != 0) {\n                    *(uint32_t*)0x40013C40 |= pin_mask;\n                }\n                if ((GPIO_Init->Mode & GPIO_MODE_IT_FALLING) != 0) {\n                    *(uint32_t*)0x40013C44 |= pin_mask;\n                }\n            }\n        }\n    }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e88",
            "calling": [
                "gpio_init",
                "HAL_RCC_MCOConfig"
            ],
            "imported": false,
            "current_name": "configure_GPIO_pins_08006e88"
        },
        "FUN_0800b4f0": {
            "renaming": {
                "FUN_0800b4f0": "do_global_dtors_aux_fini_array_0800b4f0",
                "iVar1": "num_dtors",
                "ppcVar2": "dtor"
            },
            "code": "void do_global_dtors_aux_fini_array_0800b4f0() {\n  int num_dtors = (int)PTR___fini_array_end_0800b514 - (int)PTR___do_global_dtors_aux_fini_array_0800b4f0_entry_0800b518 >> 2;\n  if (num_dtors != 0) {\n    code **dtor = (code **)(PTR___do_global_dtors_aux_fini_array_0800b4f0_entry_0800b518 + ((int)PTR___fini_array_end_0800b514 - (int)PTR___do_global_dtors_aux_fini_array_0800b4f0_entry_0800b518) - 4);\n    do {\n      num_dtors--;\n      (**dtor)();\n      dtor--;\n    } while (num_dtors != 0);\n  }\n  _fini();\n  return;\n}",
            "called": [
                "frame_dummy",
                "_fini",
                "__do_global_dtors_aux"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4f0",
            "calling": [],
            "imported": false,
            "current_name": "do_global_dtors_aux_fini_array_0800b4f0"
        },
        "FUN_080001e0": {
            "renaming": {
                "FUN_080001e0": "do_nothing_080001e0"
            },
            "code": "\nvoid do_nothing_080001e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001e0",
            "calling": [
                "coolant_run"
            ],
            "imported": false,
            "current_name": "do_nothing_080001e0"
        },
        "FUN_080036f0": {
            "renaming": {
                "FUN_080036f0": "print_bits_080036f0",
                "n": "number",
                "bits": "num_bits",
                "data": "bit",
                "i": "index",
                "mask": "bit_mask"
            },
            "code": "void print_bits_080036f0(uint number, int num_bits) {\n  uint32_t mask;\n  char bit;\n  mask = 1 << (num_bits - 1);\n  for (int i = 0; i < num_bits; i++) {\n    bit = (mask & number) ? '1' : '0';\n    serial_write(bit);\n    mask >>= 1;\n  }\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f0",
            "calling": [
                "print_uint16_base2",
                "print_uint8_base2"
            ],
            "imported": false,
            "current_name": "print_bits_080036f0"
        },
        "FUN_08005c74": {
            "renaming": {
                "FUN_08005c74": "set_flags_08005c74",
                "DAT_08005ce4": "data_pointer"
            },
            "code": "void set_flags_08005c74(void)\n{\n  unsigned int* DAT_08005ce4 = DAT_08005ce4;\n  *DAT_08005ce4 |= 0x81;\n  DAT_08005ce4[2] = 0;\n  *DAT_08005ce4 &= 0xfaf6ffff;\n  DAT_08005ce4[1] = 0;\n  DAT_08005ce4[1] |= DAT_08005ce4[5];\n  DAT_08005ce4[33] = 0;\n  DAT_08005ce4[33] |= 0x20003000;\n  *DAT_08005ce4 &= 0xfffbffff;\n  DAT_08005ce4[3] = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c74",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_08005c74"
        },
        "FUN_08002edc": {
            "renaming": {
                "FUN_08002edc": "calculate_trapezoids_08002edc",
                "planner_reverse_pass": "reverse_pass",
                "planner_forward_pass": "forward_pass",
                "FUN_08002edc_trapezoids": "calculate_trapezoids_internal"
            },
            "code": "void calculate_trapezoids_08002edc(void)\n{\n  reverse_pass();\n  forward_pass();\n  calculate_trapezoids_08002edc_internal();\n  return;\n}",
            "called": [
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "planner_reverse_pass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002edc",
            "calling": [
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_trapezoids_08002edc"
        },
        "FUN_0800375c": {
            "renaming": {
                "FUN_0800375c": "print_binary_0800375c",
                "n": "number"
            },
            "code": "void print_binary_0800375c(uint16_t number) {\n    print_base2((uint)number, 0x10);\n    return;\n}",
            "called": [
                "print_base2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800375c",
            "calling": [
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "print_binary_0800375c"
        },
        "FUN_08009990": {
            "renaming": {
                "FUN_08009990": "calculate_result_08009990",
                "param_1": "dividend_1",
                "param_2": "dividend_2",
                "param_3": "divisor_1",
                "param_4": "divisor_2",
                "param_5": "angle",
                "uVar2": "sign_bit",
                "uVar3": "abs_divisor_2",
                "uVar4": "abs_dividend_2",
                "uVar5": "difference_result",
                "iVar1": "difference"
            },
            "code": "void calculate_result_08009990(uint dividend_1, uint dividend_2, uint divisor_1, uint divisor_2, double angle) {\n  int difference;\n  uint abs_divisor_2 = divisor_2 & 0x7fffffff;\n  uint abs_dividend_2 = dividend_2 & 0x7fffffff;\n  if ((DAT_08009b18 < (abs_divisor_2 | (-divisor_1 | divisor_1) >> 0x1f)) || (DAT_08009b18 < (abs_dividend_2 | (-dividend_1 | dividend_1) >> 0x1f))) {\n    __aeabi_dadd(divisor_1, divisor_2, dividend_1, dividend_2);\n  }\n  else {\n    if ((divisor_2 + 0xc0100000 | divisor_1) == 0) {\n      atan(angle);\n      return;\n    }\n    uint sign_bit = (int)divisor_2 >> 0x1e & 2U | dividend_2 >> 0x1f;\n    if (((((dividend_2 | dividend_1) != 0) && ((abs_divisor_2 | divisor_1) != 0)) && (abs_divisor_2 != DAT_08009b18)) && (abs_dividend_2 != DAT_08009b18)) {\n      difference = (int)(abs_dividend_2 - abs_divisor_2) >> 0x14;\n      if (((int)(abs_dividend_2 - abs_divisor_2) < 0x3d00000) && ((-1 < (int)divisor_2 || (difference + 0x3c < 0 == SCARRY4(difference, 0x3c))))) {\n        __divdf3(dividend_1, dividend_2, divisor_1, divisor_2);\n        fabs((double)CONCAT44(unaff_r4, divisor_2));\n        atan((double)CONCAT44(unaff_r4, divisor_2));\n      }\n      if (sign_bit != 1) {\n        if (sign_bit == 2) {\n          double difference_result = __subdf3();\n          __subdf3(DAT_08009af0, DAT_08009af4, (int)difference_result, (int)((ulonglong)difference_result >> 0x20));\n        }\n        else if (sign_bit != 0) {\n          double difference_result = __subdf3();\n          __subdf3((int)difference_result, (int)((ulonglong)difference_result >> 0x20), DAT_08009af0, DAT_08009af4);\n        }\n      }\n    }\n  }\n  return;\n}\n",
            "called": [
                "__aeabi_dadd",
                "fabs",
                "atan",
                "__subdf3",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009990",
            "calling": [
                "atan2"
            ],
            "imported": false,
            "current_name": "calculate_result_08009990"
        },
        "FUN_08005b58": {
            "renaming": {
                "FUN_08005b58": "set_flag_to_false_08005b58",
                "DAT_08005b70": "flag_data"
            },
            "code": "void set_flag_to_false_08005b58(void)\n{\n  uint32_t* flag_ptr = (uint32_t*)(DAT_08005b70 + 4);\n  *flag_ptr &= ~0x2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b58",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_to_false_08005b58"
        },
        "FUN_08007e58": {
            "renaming": {
                "FUN_08007e58": "check_usart_transmission_complete_08007e58",
                "*DAT_08007e80": "*DAT_USART_STATUS_REGISTER",
                "usart": "usart_instance",
                "(uint)": "(int)",
                "&": "of",
                "!= 0": "",
                "PTR_USART_INSTANCE": "PTR_USART_INSTANCE",
                "DAT_USART_STATUS_REGISTER": "DAT_USART_STATUS_REGISTER"
            },
            "code": "int check_usart_transmission_complete_08007e58(void)\n{\n    USART_TypeDef *usart_instance = PTR_USART_INSTANCE;\n    uint8_t usart_status_register = *DAT_08007e80;\n    bool transmission_complete = (usart_status_register & 0x20) != 0;\n    return (int)transmission_complete;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e58",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "check_usart_transmission_complete_08007e58"
        },
        "FUN_080059f8": {
            "renaming": {
                "FUN_080059f8": "reset_device_080059f8",
                "HAL_StatusTypeDef": "HAL status type definition",
                "DAT_08005a4c": "dat_08005a4c",
                "ptr_dat_08005a4c": "pointer_dat_08005a4c"
            },
            "code": "HAL_StatusTypeDef reset_device_080059f8(void)\n{\n    uint32_t *ptr_DAT_08005a4c = (uint32_t *)DAT_08005a4c;\n    ptr_DAT_08005a4c[5] = 0xFFFFFFFF;\n    ptr_DAT_08005a4c[5] = 0;\n    ptr_DAT_08005a4c[6] = 0xFFFFFFFF;\n    ptr_DAT_08005a4c[6] = 0;\n    ptr_DAT_08005a4c[4] = 0xFFFFFFFF;\n    ptr_DAT_08005a4c[4] = 0;\n    ptr_DAT_08005a4c[3] = 0xFFFFFFFF;\n    ptr_DAT_08005a4c[3] = 0;\n    ptr_DAT_08005a4c[2] = 0xFFFFFFFF;\n    ptr_DAT_08005a4c[2] = 0;\n    HAL_MspDeInit();\n    return HAL_OK;\n}",
            "called": [
                "HAL_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f8",
            "calling": [],
            "imported": false,
            "current_name": "reset_device_080059f8"
        },
        "FUN_08009194": {
            "renaming": {
                "FUN_08009194": "check_params_08009194",
                "param_1": "param1",
                "param_2": "param2",
                "uVar2": "double_param1",
                "uVar3": "double_param2",
                "uVar4": "result",
                "bVar1": "is_negative_result",
                "bVar5": "is_zero"
            },
            "code": "// Improved and more readable version of the original code\n\nuint check_params_08009194(uint param1, uint param2)\n{\n  bool is_negative1, is_negative2, is_zero;\n  uint double_param1, double_param2, result;\n  \n  double_param1 = param1 * 2;\n  double_param2 = param2 * 2;\n  is_negative1 = ((int)double_param1 >> 0x18 == -1);\n  is_negative2 = ((int)double_param2 >> 0x18 == -1);\n  is_zero = ((double_param1 | param2 & 0x7fffffff) == 0);\n  \n  if (is_negative1 || is_negative2) {\n    if ((is_negative1 && ((param1 & 0x7fffff) != 0)) || ((is_negative2 && ((param2 & 0x7fffff) != 0)))) {\n      return 1;\n    }\n  }\n  \n  if (!is_zero) {\n    result = param1 ^ param2;\n    if (result == 0) {\n      is_zero = true;\n    }\n  }\n  \n  if (result < 0) {\n    result = double_param1 + (param2 * -2);\n    is_zero = (result == 0);\n  }\n  \n  if ((result >= 0) && (double_param2 <= double_param1) && !is_zero) {\n    result = (int)param2 >> 0x1f;\n  }\n  \n  if ((result < 0) || (double_param2 > double_param1)) {\n    result = ~((int)param2 >> 0x1f);\n  }\n  \n  if (!is_zero) {\n    result |= 1;\n  }\n  \n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009194",
            "calling": [],
            "imported": false,
            "current_name": "check_params_08009194"
        },
        "FUN_08003f34": {
            "renaming": {
                "FUN_08003f34": "process_input_line_08003f34",
                "bVar1": "current_byte",
                "status_code": "status_code",
                "bVar2": "current_byte",
                "c": "current_byte",
                "*PTR_iscomment_08004028": "is_comment",
                "0xff": "0xFF",
                "10": "10",
                "0xd": "0xD",
                "0x20": "0x20",
                "0x2f": "0x2F",
                "0x28": "0x28",
                "*PTR_char_counter_08004020": "char_counter",
                "report_status_message": "report_status_message",
                "protocol_reset_line_buffer": "protocol_reset_line_buffer",
                "PTR_line_08004024": "PTR_line_08004024",
                "0x61": "0x61",
                "0x7a": "0x7A",
                "0x29": "0x29",
                "*PTR_sys_0800401c": "PTR_sys_0800401c"
            },
            "code": "void process_input_line_08003f34(void)\\n{\\n  byte current_byte;\\n  uint8_t status_code;\\n  byte *PTR_iscomment_08004028 = 0;\\n  uint8_t *PTR_char_counter_08004020 = 0;\\n\\n  while(true)\\n  {\\n    current_byte = serial_read();\\n    if(current_byte == 0xFF)\\n    {\\n      return;\\n    }\\n    if((current_byte == 10) || (current_byte == 0xD))\\n    {\\n      protocol_execute_runtime();\\n      if(**PTR_sys_0800401c != \"\\0\")\\n      {\\n        break;\\n      }\\n      if(*PTR_char_counter_08004020 == 0)\\n      {\\n        report_status_message(\"\\0\");\\n      }\\n      else\\n      {\\n        PTR_line_08004024[*PTR_char_counter_08004020] = 0;\\n        status_code = protocol_execute_line(PTR_line_08004024);\\n        report_status_message(status_code);\\n      }\\n      protocol_reset_line_buffer();\\n      *PTR_char_counter_08004020 = 0;\\n      *PTR_iscomment_08004028 = 0;\\n    }\\n    else if(*PTR_iscomment_08004028 == 0)\\n    {\\n      if((0x20 < current_byte) && (current_byte != 0x2F))\\n      {\\n        if(current_byte == 0x28)\\n        {\\n          *PTR_iscomment_08004028 = 1;\\n        }\\n        else if(*PTR_char_counter_08004020 == -1)\\n        {\\n          report_status_message(\"\\r\");\\n          protocol_reset_line_buffer();\\n        }\\n        else if((current_byte < 0x61) || (0x7A < current_byte))\\n        {\\n          PTR_line_08004024[*PTR_char_counter_08004020++] = current_byte;\\n        }\\n        else\\n        {\\n          PTR_line_08004024[*PTR_char_counter_08004020++] = current_byte - 0x20;\\n        }\\n      }\\n    }\\n    else if(current_byte == 0x29)\\n    {\\n      *PTR_iscomment_08004028 = 0;\\n    }\\n  }\\n}",
            "called": [
                "protocol_reset_line_buffer",
                "protocol_execute_line",
                "report_status_message",
                "serial_read",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f34",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "process_input_line_08003f34"
        },
        "FUN_080095b8": {
            "renaming": {
                "FUN_080095b8": "calculate_double_to_long_080095b8",
                "__x": "input",
                "in_r0": "mantissa_bits",
                "in_r1": "exponent_bits",
                "uVar1": "rounding_bit",
                "uVar2": "shift_amount",
                "uVar3": "shifted_mantissa",
                "uVar5": "exponent_difference",
                "lVar4": "result",
                "PTR_0800a3b4": "__aeabi_d2iz",
                "DAT_0800a3b8": "0x413",
                "DAT_0800a3bc": "0x434",
                "DAT_0800a3c0": "0x3ff",
                "DAT_0800a3c4": "0x14",
                "DAT_0800a3c8": "0x1e",
                "DAT_0800a3cc": "0x34",
                "DAT_0800a3d0": "0x80000",
                "DAT_0800a3d4": "0x100000",
                "DAT_0800a3d8": "0x80000000"
            },
            "code": "long calculate_double_to_long_080095b8(double input){\n  uint exponent_bits;\n  uint mantissa_bits;\n  uint sign_bit;\n  long result;\n  uint hidden_bit;\n  uint shifted_mantissa;\n  uint rounding_bit;\n  uint sticky_bits;\n  \n  exponent_bits = (uint)(input >> 52) & 0x7ff;\n  mantissa_bits = (uint)(input) & 0xfffffffffffff;\n  sign_bit = (uint)(input >> 63) & 1;\n  hidden_bit = DAT_0800a3d4;\n  if ((int)exponent_bits < DAT_0800a3c0) {\n    if ((int)exponent_bits < 0) {\n      if (exponent_bits != 0xffffffff) {\n        result = 0;\n      }\n      else{\n        result = -1;\n      }\n      return result;\n    }\n    shifted_mantissa = mantissa_bits + hidden_bit;\n    shifted_mantissa = shifted_mantissa >> (DAT_0800a3c0 - exponent_bits);\n    rounding_bit = shifted_mantissa & 1;\n    sticky_bits = (shifted_mantissa >> 1) | (mantissa_bits & ((1 << (DAT_0800a3c0 - exponent_bits)) - 1));\n    if (rounding_bit != 0 || sticky_bits != 0) {\n      shifted_mantissa += 1;\n    }\n    result = shifted_mantissa;\n  }\n  else {\n    if ((int)exponent_bits < 0x43e) {\n      shifted_mantissa = mantissa_bits + hidden_bit;\n      shifted_mantissa = shifted_mantissa << (exponent_bits - DAT_0800a3c0);\n      result = shifted_mantissa;\n    }\n    else {\n      result = PTR_0800a3b4(input);\n    }\n  }\n  if (sign_bit != 0) {\n    result = -result;\n  }\n  return result;\n}",
            "called": [
                "__aeabi_d2iz"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095b8",
            "calling": [
                "homing_cycle",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_double_to_long_080095b8"
        },
        "FUN_08007e4c": {
            "renaming": {
                "FUN_08007e4c": "do_nothing_08007e4c"
            },
            "code": "\nvoid do_nothing_08007e4c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e4c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007e4c"
        },
        "FUN_08006cf6": {
            "renaming": {
                "FUN_08006cf6": "set_irq_priority_08006cf6",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "priority_encoded",
                "prioritygroup": "priority_group",
                "NVIC_GetPriorityGrouping": "get_priority_grouping",
                "NVIC_EncodePriority": "encode_priority",
                "NVIC_SetPriority": "set_irq_priority"
            },
            "code": "void set_irq_priority_08006cf6(IRQn_Type irq, uint32_t preempt_priority, uint32_t sub_priority)\n{\n  uint32_t priority_group;\n  uint32_t priority_encoded = NVIC_EncodePriority(NVIC_GetPriorityGrouping(), preempt_priority, sub_priority);\n  NVIC_SetPriority(irq, priority_encoded);\n  return;\n}",
            "called": [
                "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority",
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006cf6",
            "calling": [
                "enable_tim_interrupt"
            ],
            "imported": false,
            "current_name": "set_irq_priority_08006cf6"
        },
        "FUN_08002ef0": {
            "renaming": {
                "FUN_08002ef0": "copy_block_from_head_to_tail_08002ef0",
                "*PTR_block_buffer_tail_08002f1c": "*block_buffer_tail",
                "*PTR_block_buffer_head_08002f18": "*block_buffer_head",
                "*PTR_next_buffer_head_08002f20": "*next_buffer_head",
                "uVar1": "block_head_value",
                "next_block_index": "next_block_index",
                "uVar2": "next_block_index_value"
            },
            "code": "void copy_block_from_head_to_tail_08002ef0(void)\n{\n  uint8_t block_head_value = *PTR_block_buffer_head_08002f18;\n  *PTR_block_buffer_tail_08002f1c = block_head_value;\n  uint8_t next_block_index_value = next_block_index(block_head_value);\n  *PTR_next_buffer_head_08002f20 = next_block_index_value;\n  return;\n}",
            "called": [
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef0",
            "calling": [
                "plan_init"
            ],
            "imported": false,
            "current_name": "copy_block_from_head_to_tail_08002ef0"
        },
        "FUN_08006e7c": {
            "renaming": {
                "FUN_08006e7c": "do_nothing_08006e7c"
            },
            "code": "\nvoid do_nothing_08006e7c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e7c",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08006e7c"
        },
        "FUN_08001d4c": {
            "renaming": {
                "FUN_08001d4c": "homing_sequence_08001d4c",
                "homing_rate": "homing_rate_1",
                "homing_rate_00": "homing_rate_2",
                "homing_rate_01": "homing_rate_3",
                "extraout_s0": "previous_homing_rate",
                "extraout_s0_00": "delay_time",
                "n_cycle": "cycle_count"
            },
            "code": "void homing_sequence_08001d4c(void)\\n{\\n  char cycle_count;\\n  float homing_rate_1;\\n  float homing_rate_2;\\n  float homing_rate_3;\\n  float previous_homing_rate;\\n  float delay_time;\\n\\n  wake_up_controller();\\n  homing_cycle(\"\\x04\", \"\\x01\", false, homing_rate_1);\\n  homing_cycle(\"\\x03\", \"\\x01\", false, homing_rate_2);\\n  delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\\n  cycle_count = 2;\\n  previous_homing_rate = homing_rate_3;\\n  while (cycle_count > 0) {\\n    homing_cycle(\"\\x07\", \"\\0\", true, previous_homing_rate);\\n    delay_time = *(uint16_t *)(PTR_settings_08001dd8 + 0x34);\\n    delay_ms(delay_time);\\n    previous_homing_rate = homing_rate_2;\\n    cycle_count--;\\n    if (cycle_count > 0) {\\n      homing_cycle(\"\\x07\", \"\\x01\", false, homing_rate_2);\\n      delay_time = *(uint16_t *)(PTR_settings_08001dd8 + 0x34);\\n      delay_ms(delay_time);\\n      previous_homing_rate = homing_rate_3;\\n    }\\n  }\\n  go_idle_controller();\\n  return;\\n}",
            "called": [
                "st_wake_up",
                "homing_cycle",
                "st_go_idle",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001d4c",
            "calling": [
                "mc_go_home"
            ],
            "imported": false,
            "current_name": "homing_sequence_08001d4c"
        },
        "FUN_08000268": {
            "renaming": {
                "FUN_08000268": "calculate_time_elapsed_since_last_tick_08000268",
                "uVar1": "current_tick",
                "DAT_0800029c": "some_data",
                "DAT_08000298": "some_other_data"
            },
            "code": "uint64_t calculate_time_elapsed_since_last_tick_08000268(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  uint64_t elapsed_time = (current_tick + 1) * 1000 - ((uint64_t)DAT_0800029c * (uint64_t)(*(uint *)(DAT_08000298 + 8) >> 3) >> 0x21);\n  return elapsed_time;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000268",
            "calling": [
                "_delay_us"
            ],
            "imported": false,
            "current_name": "calculate_time_elapsed_since_last_tick_08000268"
        },
        "FUN_0800918c": {
            "renaming": {
                "FUN_0800918c": "calculate_result_0800918c",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_greater_than_negative_one",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "or_result",
                "bVar5": "is_zero"
            },
            "code": "uint calculate_result_0800918c(uint input_1, uint input_2)\n{\n  bool is_negative_1 = ((int)input_1 >> 0x18 == -1);\n  bool is_negative_2 = ((int)input_2 >> 0x18 == -1);\n  uint doubled_input_1 = input_1 * 2;\n  uint doubled_input_2 = input_2 * 2;\n  if (is_negative_1 || is_negative_2)\n  {\n    if ((is_negative_1 && ((input_1 & 0x7fffff) != 0)) || ((is_negative_2 && ((input_2 & 0x7fffff) != 0))))\n    {\n      return 0xffffffff;\n    }\n  }\n  uint or_result = doubled_input_1 | input_2 & 0x7fffffff;\n  bool is_zero = or_result == 0;\n  if (!is_zero)\n  {\n    uint xor_result = input_1 ^ input_2;\n    is_zero = xor_result == 0;\n  }\n  bool is_greater_than_negative_one = -1 < (int)(input_1 ^ input_2);\n  if (is_greater_than_negative_one)\n  {\n    uint addition_result = doubled_input_1 + input_2 * -2;\n    is_zero = addition_result == 0;\n  }\n  if (is_greater_than_negative_one && doubled_input_2 <= doubled_input_1 && !is_zero)\n  {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_greater_than_negative_one || doubled_input_2 > doubled_input_1)\n  {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero)\n  {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800918c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_0800918c"
        },
        "FUN_08003778": {
            "renaming": {
                "FUN_08003778": "print_ulong_as_string_08003778",
                "n": "num",
                "uVar1": "digit_index",
                "local_1c": "remaining_num",
                "uStack_15": "last_digit",
                "buf": "digits",
                "i": "digit_index"
            },
            "code": "void print_ulong_as_string_08003778(ulong num) {\n  uint digit_index = 0;\n  ulong remaining_num = num;\n  uint8_t last_digit;\n  uchar digits[10];\n\n  if (num == 0) {\n    serial_write('0');\n    return;\n  }\n\n  while (remaining_num != 0) {\n    last_digit = remaining_num % 10;\n    remaining_num /= 10;\n    digits[digit_index] = last_digit + '0';\n    digit_index++;\n  }\n\n  while (digit_index != 0) {\n    serial_write(digits[digit_index - 1]);\n    digit_index--;\n  }\n}\n",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003778",
            "calling": [
                "printInteger"
            ],
            "imported": false,
            "current_name": "print_ulong_as_string_08003778"
        },
        "FUN_0800b3dc": {
            "renaming": {
                "FUN_0800b3dc": "get_impure_ptr_value_0800b3dc",
                "PTR__impure_ptr_0800b3e4": "PTR__impure_ptr_0800b3e4",
                "undefined4": "int",
                "*": "*",
                "return": "return",
                ";": ";"
            },
            "code": "int get_impure_ptr_value_0800b3dc(void)\n{\n    int* impure_ptr = (int*)PTR__impure_ptr_0800b3e4;\n    return *impure_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3dc",
            "calling": [
                "sqrt",
                "hypot"
            ],
            "imported": false,
            "current_name": "get_impure_ptr_value_0800b3dc"
        },
        "FUN_080046d0": {
            "renaming": {
                "FUN_080046d0": "print_sensor_data_080046d0",
                "bVar1": "sensor_value",
                "cVar2": "sensor_type",
                "n": "float_n",
                "n_00": "float_n_00",
                "uVar3": "undefined8_uVar3"
            },
            "code": "void print_sensor_data_080046d0(void)\n{\n    byte sensor_value;\n    char sensor_type;\n    float n;\n    float n_00;\n    undefined8 uVar3;\n\n    if (4 < (byte)PTR_gc_08004890[1]) {\n        printPgmString(PTR_DAT_080048a8);\n        printInteger((byte)PTR_gc_08004890[0x1c] + 0x36);\n        if (PTR_gc_08004890[0x19] == '\\0') {\n            if (PTR_gc_08004890[0x1a] == '\\x01') {\n                printPgmString(PTR_DAT_080048ac);\n            }\n            else {\n                printPgmString(PTR_DAT_080048b0);\n            }\n        }\n        else {\n            printPgmString(PTR_DAT_080048b4);\n        }\n        if (PTR_gc_08004890[3] == '\\0') {\n            printPgmString(PTR_DAT_080048bc);\n        }\n        else {\n            printPgmString(PTR_DAT_080048b8);\n        }\n        if (PTR_gc_08004890[4] == '\\0') {\n            printPgmString(PTR_DAT_080048c4);\n        }\n        else {\n            printPgmString(PTR_DAT_080048c0);\n        }\n        if (PTR_gc_08004890[2] == '\\0') {\n            printPgmString(PTR_DAT_080048cc);\n        }\n        else {\n            printPgmString(PTR_DAT_080048c8);\n        }\n        sensor_value = PTR_gc_08004890[5];\n        if (sensor_value == 2) {\n            printPgmString(PTR_DAT_080048d8);\n        }\n        else if (sensor_value < 3) {\n            if (sensor_value == 0) {\n                printPgmString(PTR_DAT_080048d0);\n            }\n            else if (sensor_value == 1) {\n                printPgmString(PTR_DAT_080048d4);\n            }\n        }\n        sensor_type = PTR_gc_08004890[6];\n        if (sensor_type == '\\x01') {\n            printPgmString(PTR_DAT_080048dc);\n        }\n        else if (sensor_type < '\\x02') {\n            if (sensor_type == -1) {\n                printPgmString(PTR_DAT_080048e0);\n            }\n            else if (sensor_type == '\\0') {\n                printPgmString(PTR_DAT_080048e4);\n            }\n        }\n        sensor_value = PTR_gc_08004890[7];\n        if (sensor_value == 2) {\n            printPgmString(PTR_DAT_080048f0);\n        }\n        else if (sensor_value < 3) {\n            if (sensor_value == 0) {\n                printPgmString(PTR_DAT_080048e8);\n            }\n            else if (sensor_value == 1) {\n                printPgmString(PTR_DAT_080048ec);\n            }\n        }\n        printPgmString(PTR_DAT_080048f4);\n        printInteger((uint)(byte)PTR_gc_08004890[0x18]);\n        printPgmString(PTR_DAT_080048f8);\n        if (PTR_gc_08004890[3] == '\\0') {\n            printFloat(n);\n        }\n        else {\n            uVar3 = __aeabi_f2d(*(undefined4 *)(PTR_gc_08004890 + 8));\n            uVar3 = __muldf3((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),DAT_08004888,DAT_0800488c);\n            n_00 = (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 >> 0x20));\n            printFloat(n_00);\n        }\n        printPgmString(PTR_DAT_080048fc);\n        return;\n    }\n                    /* WARNING: Could not recover jumptable at 0x080046de. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*(code *)(&switchD_080046de::switchdataD_080046e4)[(byte)PTR_gc_08004890[1]])();\n    return;\n}",
            "called": [
                "printInteger",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3",
                "printPgmString",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046d0",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_sensor_data_080046d0"
        },
        "FUN_08006d72": {
            "renaming": {
                "FUN_08006d72": "configure_systick_08006d72",
                "TicksNumb": "ticks_number",
                "uVar1": "config_result"
            },
            "code": "uint32_t configure_systick_08006d72(uint32_t ticks_number)\n{\n  uint32_t config_result;\n  config_result = SysTick_Config(ticks_number);\n  return config_result;\n}",
            "called": [
                "SysTick_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d72",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configure_systick_08006d72"
        },
        "FUN_0800756c": {
            "renaming": {
                "FUN_0800756c": "set_bit_and_clear_mask_0800756c",
                "DAT_080075bc": "ptr_dat_080075bc",
                "DAT_080075c0": "value_to_set",
                "DAT_080075c4": "ptr_dat_080075c4"
            },
            "code": "void set_bit_and_clear_mask_0800756c(void)\n{\n  unsigned int* DAT_080075bc = DAT_080075bc;\n  unsigned int mask1 = 0x1;\n  unsigned int mask2 = 0xfef6ffff;\n  unsigned int mask3 = 0xfffbffff;\n  unsigned int value1 = *DAT_080075bc | mask1;\n  DAT_080075bc[2] = 0;\n  *DAT_080075bc = value1 & mask2;\n  DAT_080075bc[1] = DAT_080075c0;\n  *DAT_080075bc = *DAT_080075bc & mask3;\n  DAT_080075bc[3] = 0;\n  unsigned int* DAT_080075c4 = DAT_080075c4;\n  *(unsigned int *)(DAT_080075c4 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800756c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_mask_0800756c"
        },
        "FUN_0800691c": {
            "renaming": {
                "FUN_0800691c": "check_and_set_clock_security_bit_0800691c",
                "DAT_0800693c": "ptr_dat_0800693c",
                "DAT_08006940": "ptr_dat_08006940",
                "uint": "uint32_t",
                "*": "*ptr_",
                "bit_mask": "bit_mask"
            },
            "code": "void check_and_set_clock_security_bit_0800691c(void)\n{\n    uint32_t* DAT_0800693c = (uint32_t*)DAT_0800693c;\n    uint32_t* DAT_08006940 = (uint32_t*)DAT_08006940;\n    uint32_t bit_mask = 0x80;\n    if ((*DAT_0800693c + 0xc) & bit_mask)\n    {\n        HAL_RCC_CCSCallback();\n        *DAT_08006940 = bit_mask;\n    }\n    return;\n}",
            "called": [
                "HAL_RCC_CCSCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800691c",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_clock_security_bit_0800691c"
        },
        "FUN_080001f8": {
            "renaming": {
                "FUN_080001f8": "stop_coolant_flow_080001f8",
                "PTR_current_coolant_mode_0800020c": "current_coolant_mode",
                "coolant_stop": "coolant_stop"
            },
            "code": "void stop_coolant_flow_080001f8(void)\n{\n  *PTR_current_coolant_mode_0800020c = 0;\n  coolant_stop();\n  return;\n}",
            "called": [
                "coolant_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001f8",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "stop_coolant_flow_080001f8"
        },
        "FUN_08002f74": {
            "renaming": {
                "FUN_08002f74": "get_current_block_08002f74",
                "*pbVar1": "*current_block",
                "pbVar1": "current_block",
                "*PTR_block_buffer_head_08002fa0": "*buffer_head",
                "PTR_block_buffer_head_08002fa0": "buffer_head",
                "*PTR_block_buffer_tail_08002fa4": "*buffer_tail",
                "PTR_block_buffer_tail_08002fa4": "buffer_tail",
                "PTR_block_buffer_08002fa8": "buffer",
                "byte": "uint8_t",
                "0x40": "BLOCK_SIZE"
            },
            "code": "block_t * get_current_block_08002f74(void)\n{\n  block_t *current_block = NULL;\n  if (*PTR_block_PTR_block_PTR_block_buffer_08002fa8_head_08002fa0_08002fa0 == *PTR_block_PTR_block_PTR_block_buffer_08002fa8_tail_08002fa4_08002fa4) {\n    current_block = NULL;\n  }\n  else {\n    uint8_t current_block_index = (uint8_t)*PTR_block_PTR_block_PTR_block_buffer_08002fa8_tail_08002fa4_08002fa4;\n    current_block = (block_t *)(PTR_block_PTR_block_buffer_08002fa8_08002fa8 + current_block_index * 0x40);\n  }\n  return current_block;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f74",
            "calling": [
                "plan_synchronize",
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "get_current_block_08002f74"
        },
        "FUN_0800b3e8": {
            "renaming": {
                "FUN_0800b3e8": "run_global_destructors_0800b3e8",
                "param_1": "ctx",
                "iVar1": "i",
                "ppcVar2": "destructor_array",
                "iVar3": "num_destructors"
            },
            "code": "void run_global_destructors_0800b3e8(EVP_PKEY_CTX *ctx) {\n  int num_destructors = (int)PTR___preinit_array_end_0800b420 - (int)PTR___preinit_array_end_0800b424 >> 2;\n  if (num_destructors != 0) {\n    int i = 0;\n    code **destructor_array = (code **)PTR___preinit_array_end_0800b424;\n    do {\n      i++;\n      ctx = (EVP_PKEY_CTX *)(*destructor_array)();\n      destructor_array++;\n    } while (num_destructors != i);\n  }\n  destructor_array = (code **)PTR___preinit_array_end_0800b42c;\n  num_destructors = (int)PTR___do_global_dtors_aux_fini_array_entry_0800b428 - (int)PTR___preinit_array_end_0800b42c;\n  _init(ctx);\n  num_destructors = num_destructors >> 2;\n  if (num_destructors != 0) {\n    int i = 0;\n    do {\n      i++;\n      (*destructor_array)();\n      destructor_array++;\n    } while (num_destructors != i);\n  }\n  return;\n}",
            "called": [
                "_init",
                "register_fini",
                "frame_dummy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3e8",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "run_global_destructors_0800b3e8"
        },
        "FUN_080096e8": {
            "renaming": {
                "FUN_080096e8": "calculate_cosine_080096e8",
                "__x": "x",
                "in_r0": "integer_part",
                "in_r1": "fractional_part",
                "dVar2": "result",
                "local_28": "remainder",
                "uStack_24": "DAT_08009798",
                "local_20": "DAT_0800979c",
                "uStack_1c": "DAT_080097a0"
            },
            "code": "double calculate_cosine_080096e8(double x) {\n  uint fractional_part;\n  uint integer_part;\n  double result;\n  uint remainder;\n  uint quadrant;\n  if (DAT_08009790 < (int)(x & 0x7fffffff)) {\n    if (DAT_08009794 < (int)(x & 0x7fffffff)) {\n      result = (double)__subdf3();\n    }\n    else {\n      remainder = __ieee754_rem_pio2(x, integer_part, &fractional_part);\n      quadrant = remainder & 3;\n      if (quadrant == 1) {\n        result = (double)__kernel_cos(fractional_part, DAT_08009798, DAT_0800979c, DAT_080097a0);\n      }\n      else if (quadrant == 2 || quadrant == 0) {\n        result = (double)__kernel_calculate_cosine_080096e8(fractional_part, DAT_08009798, DAT_0800979c, DAT_080097a0, 1);\n      }\n      else {\n        result = (double)__kernel_cos(fractional_part, DAT_08009798, DAT_0800979c, DAT_080097a0);\n      }\n    }\n    return result;\n  }\n  result = (double)__kernel_calculate_cosine_080096e8(integer_part, x, 0, 0, 0);\n  return result;\n}",
            "called": [
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "__subdf3",
                "__kernel_sin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e8",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_cosine_080096e8"
        },
        "FUN_08006a18": {
            "renaming": {
                "FUN_08006a18": "is_irq_enabled_08006a18",
                "IRQn": "irq",
                "DAT_08006a54": "irq_bitmask_base_address",
                "uint": "uint32_t",
                "*": "*",
                "irq_bitmask_ptr": "irq_bitmask_ptr",
                "irq_bitmask": "irq_bitmask",
                "irq_bit": "irq_bit"
            },
            "code": "uint32_t is_irq_enabled_08006a18(IRQn_Type irq) {\n    uint32_t* irq_bitmask_ptr = (uint32_t*)(DAT_08006a54 + (((uint32_t)irq >> 5) + 0x40) * 4);\n    uint32_t irq_bitmask = *irq_bitmask_ptr;\n    uint32_t irq_bit = 1 << (irq & 0x1f);\n    return (uint32_t)((irq_bitmask & irq_bit) != 0);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a18",
            "calling": [
                "HAL_NVIC_GetPendingIRQ"
            ],
            "imported": false,
            "current_name": "is_irq_enabled_08006a18"
        },
        "FUN_08002c18": {
            "renaming": {
                "FUN_08002c18": "calculate_rate_steps_08002c18",
                "block_t": "block",
                "entry_factor": "entry_rate",
                "exit_factor": "exit_rate",
                "acceleration": "acceleration",
                "decelerate_steps": "deceleration_steps",
                "acceleration_per_minute": "acceleration_distance",
                "plateau_steps": "plateau_steps",
                "accelerate_steps": "acceleration_steps",
                "rate_delta": "rate_delta",
                "distance": "distance",
                "FUN_08002e04": "FUN_08002e04",
                "estimate_acceleration_distance": "estimate_acceleration_distance",
                "initial_rate": "initial_rate",
                "nominal_rate": "nominal_rate",
                "final_rate": "final_rate",
                "step_event_count": "step_event_count",
                "ceil": "ceil",
                "floor": "floor",
                "intersection_distance": "intersection_distance",
                "uVar1": "uVar1",
                "uVar2": "uVar2",
                "uVar5": "uVar5",
                "iVar3": "iVar3",
                "iVar4": "iVar4",
                "uVar6": "uVar6",
                "in_r1": "in_r1",
                "extraout_r1": "extraout_r1",
                "extraout_r1_00": "extraout_r1_00",
                "extraout_r1_01": "extraout_r1_01",
                "extraout_r1_02": "extraout_r1_02",
                "extraout_r1_03": "extraout_r1_03",
                "in_r2": "in_r2",
                "in_stack_ffffffc8": "in_stack_ffffffc8"
            },
            "code": "void calculate_rate_steps_08002c18(block_t *block, float entry_rate, float exit_rate) {\n    float acceleration, deceleration, distance;\n    int acceleration_steps, plateau_steps, deceleration_steps;\n    float rate_delta = exit_rate - entry_rate;\n    float acceleration_distance = estimate_acceleration_distance(rate_delta);\n    float deceleration_distance = estimate_acceleration_distance(-rate_delta);\n    int total_steps = block->step_event_count;\n    if (acceleration_distance + deceleration_distance >= total_steps) {\n        acceleration_distance = total_steps / 2.0;\n        deceleration_distance = total_steps / 2.0;\n        plateau_steps = 0;\n    } else {\n        plateau_steps = total_steps - (int)ceil(acceleration_distance) - (int)floor(deceleration_distance);\n    }\n    acceleration_steps = (int)ceil(acceleration_distance);\n    deceleration_steps = (int)floor(deceleration_distance);\n    block->initial_rate = (uint32_t)round(entry_rate);\n    block->final_rate = (uint32_t)round(exit_rate);\n    block->accelerate_until = acceleration_steps;\n    block->decelerate_after = acceleration_steps + plateau_steps;\n}\n",
            "called": [
                "intersection_distance",
                "floor",
                "__floatunsisf",
                "ceil",
                "__aeabi_fmul",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__muldf3",
                "__aeabi_d2iz",
                "__floatsisf",
                "__aeabi_i2d",
                "estimate_acceleration_distance"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c18",
            "calling": [
                "planner_recalculate_trapezoids"
            ],
            "imported": false,
            "current_name": "calculate_rate_steps_08002c18"
        },
        "FUN_08006ac0": {
            "renaming": {
                "FUN_08006ac0": "convert_IRQn_to_bitmask_08006ac0",
                "IRQn": "irq",
                "DAT_08006afc": "irq_address_base"
            },
            "code": "uint32_t convert_IRQn_to_bitmask_08006ac0(IRQn_Type irq) {\n    uint32_t *irq_address = (uint32_t *)(DAT_08006afc + (((uint32_t)irq >> 5) + 0x80) * 4);\n    uint32_t irq_bitmask = 1U << (irq & 0x1fU);\n    return (*irq_address & irq_bitmask) != 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ac0",
            "calling": [
                "HAL_NVIC_GetActive"
            ],
            "imported": false,
            "current_name": "convert_IRQn_to_bitmask_08006ac0"
        },
        "FUN_080001ec": {
            "renaming": {
                "FUN_080001ec": "do_nothing_080001ec"
            },
            "code": "\nvoid do_nothing_080001ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ec",
            "calling": [
                "coolant_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_080001ec"
        },
        "FUN_08005a50": {
            "renaming": {
                "FUN_08005a50": "do_nothing_08005a50"
            },
            "code": "\nvoid do_nothing_08005a50(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a50",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a50"
        },
        "FUN_08002ba8": {
            "renaming": {
                "FUN_08002ba8": "process_blocks_08002ba8",
                "previous": "previous_block",
                "next": "current_block",
                "block": "next_block",
                "block_index": "block_index",
                "PTR_block_buffer_tail_08002c0c": "PTR_block_buffer_tail_08002c0c",
                "PTR_block_buffer_head_08002c14": "PTR_block_buffer_head_08002c14",
                "PTR_block_buffer_08002c10": "PTR_block_buffer_08002c10",
                "process_blocks_kernel": "process_blocks_kernel",
                "next_block_index": "next_block_index"
            },
            "code": "void process_blocks_08002ba8(void)\n{\n  block_t* previous_block;\n  block_t* current_block;\n  block_t* next_block [3];\n  uint8_t block_index;\n  block_index = *PTR_block_buffer_tail_08002c0c;\n  next_block[1] = (block_t *)0x0;\n  next_block[2] = (block_t *)0x0;\n  while (previous_block = next_block[1], block_index != *PTR_block_buffer_head_08002c14) {\n    next_block[1] = next_block[2];\n    current_block = (block_t *)(PTR_block_buffer_08002c10 + (uint)block_index * 0x40);\n    process_blocks_08002ba8_kernel(previous_block, next_block[2], current_block);\n    block_index = next_block_index(block_index);\n    next_block[2] = current_block;\n  }\n  process_blocks_08002ba8_kernel(next_block[1], next_block[2], (block_t *)0x0);\n  return;\n}",
            "called": [
                "planner_forward_pass_kernel",
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ba8",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "process_blocks_08002ba8"
        },
        "FUN_0800919c": {
            "renaming": {
                "FUN_0800919c": "check_inputs_and_calculate_result_0800919c",
                "param_1": "result",
                "param_2": "input_2",
                "bVar1": "is_input_2_greater_than_input_1",
                "uVar2": "abs_input_1",
                "uVar3": "abs_input_2",
                "uVar4": "sum_of_inputs",
                "bVar5": "is_xor_of_inputs_negative"
            },
            "code": "uint check_inputs_and_calculate_result_0800919c(uint input_1, uint input_2)\n{\n    bool is_negative_1 = false;\n    bool is_negative_2 = false;\n    uint abs_input_1 = 0;\n    uint abs_input_2 = 0;\n    uint sum_of_inputs = 0;\n    bool is_sum_of_inputs_zero = false;\n    uint xor_of_inputs = 0;\n    bool is_xor_of_inputs_zero = false;\n    bool is_xor_of_inputs_negative = false;\n    bool is_input_2_greater_than_input_1 = false;\n    uint result = 0;\n    \n    // check if inputs are negative\n    is_negative_1 = ((int)input_1 >> 0x1f) != 0;\n    is_negative_2 = ((int)input_2 >> 0x1f) != 0;\n    \n    // get absolute values of inputs\n    abs_input_1 = is_negative_1 ? ~(input_1 - 1) : input_1;\n    abs_input_2 = is_negative_2 ? ~(input_2 - 1) : input_2;\n    \n    // check if either input is all ones and the upper bit is set\n    if (((int)input_1 >> 0x18 == -1 && ((abs_input_1 & 0x7fffff) != 0)) || ((int)input_2 >> 0x18 == -1 && ((abs_input_2 & 0x7fffff) != 0))) {\n        return 1;\n    }\n    \n    // calculate sum of inputs and check if it is zero\n    sum_of_inputs = input_1 + input_2;\n    is_sum_of_inputs_zero = (sum_of_inputs == 0);\n    \n    // calculate xor of inputs and check if it is zero or negative\n    xor_of_inputs = input_1 ^ input_2;\n    is_xor_of_inputs_zero = (xor_of_inputs == 0);\n    is_xor_of_inputs_negative = ((int)xor_of_inputs < 0);\n    \n    // check if input_2 is greater than input_1\n    is_input_2_greater_than_input_1 = (input_2 > input_1);\n    \n    // calculate result\n    if (is_xor_of_inputs_negative && is_input_2_greater_than_input_1 && !is_sum_of_inputs_zero) {\n        result = (int)input_2 >> 0x1f;\n    } else if (!is_xor_of_inputs_negative && is_input_2_greater_than_input_1) {\n        result = ~(int)(input_2 >> 0x1f);\n    } else if (!is_sum_of_inputs_zero) {\n        result = 1;\n    } else {\n        result = (int)(sum_of_inputs >> 0x1f) | 1;\n    }\n    \n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800919c",
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "imported": false,
            "current_name": "check_inputs_and_calculate_result_0800919c"
        },
        "FUN_0800b2cc": {
            "renaming": {
                "FUN_0800b2cc": "calculate_result_0800b2cc",
                "__x": "input",
                "in_d0": "result"
            },
            "code": "double calculate_result_0800b2cc(double input){\n  double result;\n  // calculation goes here\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2cc",
            "calling": [
                "__ieee754_atan2",
                "__ieee754_rem_pio2",
                "atan"
            ],
            "imported": false,
            "current_name": "calculate_result_0800b2cc"
        },
        "FUN_0800854c": {
            "renaming": {
                "FUN_0800854c": "reverse_bits_0800854c",
                "param_1": "input",
                "uVar1": "output",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeroes",
                "uVar4": "temp",
                "in_r12": "trailing_zeroes",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "is_overflow"
            },
            "code": "ulonglong reverse_bits_0800854c(uint input){\n  if (input == 0) {\n    return 0;\n  }\n  uint leading_zeroes = count_leading_zeroes(input);\n  uint shift_amount = leading_zeroes + 0x15;\n  uint output = 0;\n  if (shift_amount < 0x20) {\n    shift_amount = shift_amount + 1;\n    output = input << (shift_amount & 0xff);\n    input = input >> ((0xcU - leading_zeroes + 1) & 0xff);\n  }\n  else {\n    uint trailing_zeroes = 0x20 - leading_zeroes;\n    output = input << (leading_zeroes & 0xff);\n    output = output | 0U >> (trailing_zeroes & 0xff);\n    output = 0 << (leading_zeroes & 0xff);\n  }\n  if (shift_amount < 0x433) {\n    return CONCAT44(output + (0x432 - shift_amount) * 0x100000, input);\n  }\n  else {\n    uint inverted_shift_amount = ~(0x432 - shift_amount);\n    if (0x1e < inverted_shift_amount) {\n      return (ulonglong)(input >> (inverted_shift_amount - 0x1f & 0xff));\n    }\n    else {\n      int difference = inverted_shift_amount - 0x13;\n      if (difference == 0 || (inverted_shift_amount - 0x1f < 0) != (difference < 0)) {\n        inverted_shift_amount = inverted_shift_amount + 1;\n        return CONCAT44(input >> (inverted_shift_amount & 0xff), output >> (inverted_shift_amount & 0xff) | input << (0x20 - inverted_shift_amount & 0xff));\n      }\n      else {\n        return (ulonglong)(output >> (0x20 - (0xcU - difference) & 0xff) | input << (0xcU - difference & 0xff));\n      }\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800854c",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "reverse_bits_0800854c"
        },
        "FUN_08008e44": {
            "renaming": {
                "FUN_08008e44": "leading_zero_bits_08008e44",
                "param_1": "num",
                "iVar1": "num_leading_zeroes",
                "uVar2": "shift_amount",
                "iVar4": "magic_number_sum",
                "uVar3": "result",
                "uVar5": "sign_bit_shifted",
                "count_leading_zeroes": "count_leading_zeroes"
            },
            "code": "uint leading_zero_bits_08008e44(uint num) {\n  int num_leading_zeroes = count_leading_zeroes(num);\n  uint shifted_num = num << (24 - num_leading_zeroes);\n  uint sign_bit = num & 0x80000000;\n  uint sign_bit_shifted = sign_bit >> 31;\n  uint shifted_sign_bit = sign_bit >> (31 - num_leading_zeroes);\n  uint magic_number = (0x4b - 0x80) << 24;\n  uint scaled_magic_number = magic_number >> (num_leading_zeroes - 1);\n  uint scaled_num = shifted_num >> 8;\n  uint scaled_sum = scaled_magic_number + scaled_num + shifted_sign_bit + sign_bit_shifted;\n  uint result = scaled_sum << (num_leading_zeroes - 1);\n  if (shifted_num == 0) {\n    result = result & ~(sign_bit >> 31);\n  }\n  if (sign_bit == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e44",
            "calling": [
                "calculate_trapezoid_for_block",
                "gc_set_current_position",
                "report_realtime_status",
                "mc_go_home",
                "plan_cycle_reinitialize",
                "mc_arc",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "leading_zero_bits_08008e44"
        },
        "FUN_0800733e": {
            "renaming": {
                "FUN_0800733e": "set_gpio_pin_state_0800733e",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "BSRRH": "reset_bit_mask",
                "BSRRL": "set_bit_mask"
            },
            "code": "void set_gpio_pin_state_0800733e(GPIO_TypeDef *gpio, uint16_t pin, GPIO_PinState state)\n{\n    if (state == GPIO_PIN_RESET) {\n        gpio->BSRRH = pin;\n    }\n    else {\n        gpio->BSRRL = pin;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800733e",
            "calling": [
                "gpio_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_0800733e"
        },
        "FUN_08005aec": {
            "renaming": {
                "FUN_08005aec": "get_first_twelve_bits_08005aec",
                "*DAT_08005b00": "data_ptr",
                "& 0xfff": "data_value"
            },
            "code": "uint32_t get_first_twelve_bits_08005aec(void)\n{\n  uint32_t* *DAT_08005b00 = DAT_08005b00;\n  uint32_t data_value = **DAT_08005b00 & 0xfff;\n  return data_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aec",
            "calling": [],
            "imported": false,
            "current_name": "get_first_twelve_bits_08005aec"
        },
        "FUN_08005b74": {
            "renaming": {
                "FUN_08005b74": "set_flag_on_data_08005b74",
                "DAT_08005b8c": "data_start_address"
            },
            "code": "void set_flag_on_data_08005b74(){\n    uint* data_ptr = (uint *)(DAT_08005b8c + 4);\n    *data_ptr |= 4;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b74",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_on_data_08005b74"
        },
        "FUN_0800583c": {
            "renaming": {
                "FUN_0800583c": "step_with_settings_0800583c",
                "PTR_settings_08005858": "PTR_settings",
                "step_wr": "step_with_settings_write",
                "st_wake_up": "step_with_settings_wake_up",
                "st_go_idle": "step_with_settings_go_idle"
            },
            "code": "void step_with_settings_0800583c(void)\n{\n  uint16_t current_settings = *(uint16_t *)(PTR_settings_08005858_08005858 + 0x18);\n  step_wr(current_settings);\n  st_wake_up();\n  st_go_idle();\n  return;\n}",
            "called": [
                "st_wake_up",
                "st_go_idle",
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583c",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "step_with_settings_0800583c"
        },
        "FUN_08001e98": {
            "renaming": {
                "FUN_08001e98": "process_buffer_and_plan_08001e98",
                "x": "x_pos",
                "y": "y_pos",
                "z": "z_pos",
                "feed_rate": "feed_rate",
                "invert_feed_rate": "invert_feed_rate",
                "uVar1": "buffer_full",
                "x_00": "new_x_pos",
                "y_00": "new_y_pos",
                "z_00": "new_z_pos",
                "feed_rate_00": "new_feed_rate"
            },
            "code": "void process_buffer_and_plan_08001e98(float x_pos, float y_pos, float z_pos, float feed_rate, uint8_t invert_feed_rate) {\n  uint8_t buffer_full;\n  float new_x_pos;\n  float new_y_pos;\n  float new_z_pos;\n  float new_feed_rate;\n\n  if (PTR_sys_08001efc[1] != '\\a') {\n    do {\n      protocol_execute_runtime();\n      if (*PTR_sys_08001efc != '\\0') {\n        return;\n      }\n      buffer_full = plan_check_full_buffer();\n    } while (buffer_full != '\\0');\n    plan_buffer_line(new_x_pos, new_y_pos, new_z_pos, new_feed_rate, invert_feed_rate);\n    if (PTR_sys_08001efc[1] == '\\0') {\n      PTR_sys_08001efc[1] = 2;\n    }\n    if (PTR_sys_08001efc[0x10] != '\\0') {\n      st_cycle_start();\n    }\n  }\n  return;\n}",
            "called": [
                "plan_check_full_buffer",
                "plan_buffer_line",
                "st_cycle_start",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e98",
            "calling": [
                "mc_go_home",
                "mc_arc",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "process_buffer_and_plan_08001e98"
        },
        "FUN_080069e4": {
            "renaming": {
                "FUN_080069e4": "set_interrupt_enable_bit_080069e4",
                "IRQn": "irq_number",
                "DAT_08006a14": "interrupt_enable_reg_base_address"
            },
            "code": "void set_interrupt_enable_bit_080069e4(IRQn_Type irq_number)\n{\n    int* interrupt_enable_reg_address = (int*)(DAT_08006a14 + (((uint)(int)irq_number >> 5) + 0x20) * 4);\n    int interrupt_enable_bit_position = irq_number & 0x1fU;\n    int interrupt_enable_bit_mask = 1 << interrupt_enable_bit_position;\n    *interrupt_enable_reg_address = interrupt_enable_bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069e4",
            "calling": [
                "HAL_NVIC_DisableIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_080069e4"
        },
        "FUN_0800b2d4": {
            "renaming": {
                "FUN_0800b2d4": "set_sign_bit_0800b2d4",
                "__value": "value",
                "in_r1": "sign_bit_mask"
            },
            "code": "int set_sign_bit_0800b2d4(double value){\n    uint32_t sign_bit_mask = 0x80000000;\n    uint32_t abs_value = *((uint32_t*)&value) & 0x7FFFFFFF;\n    uint32_t result = abs_value | sign_bit_mask;\n    return (int)(result >> 31);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2d4",
            "calling": [
                "hypot"
            ],
            "imported": false,
            "current_name": "set_sign_bit_0800b2d4"
        },
        "FUN_08008e3c": {
            "renaming": {
                "FUN_08008e3c": "calculate_hash_08008e3c",
                "param_1": "input",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "iVar3": "constant",
                "uVar4": "carry",
                "shifted_input": "shifted_input",
                "shifted_zero": "shifted_zero",
                "result": "result",
                "shifted_constant": "shifted_constant"
            },
            "code": "uint calculate_hash_08008e3c(uint input)\n{\n  if (input == 0) {\n    return 0;\n  }\n  int leading_zeroes = count_leading_zeroes(input);\n  int shift_amount = leading_zeroes - 8;\n  int constant = shift_amount * -0x800000 + 0x4a800000;\n  if (leading_zeroes > 7) {\n    uint shifted_input = input << (shift_amount & 0xff);\n    uint shifted_zero = 0U >> (0x20 - shift_amount & 0xff);\n    uint carry = (uint)(0x7fffffff < 0);\n    uint result = constant + shifted_input + shifted_zero + carry;\n    if ((0 << (shift_amount & 0xff)) == 0x80000000) {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  uint shifted_input = input << (leading_zeroes + 0x18U & 0xff);\n  uint shifted_constant = (uint)(constant + ((input >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shifted_input >> 0x1f)));\n  if ((shifted_input & 0x7fffffff) == 0) {\n    shifted_constant = shifted_constant & ~(shifted_input >> 0x1f);\n  }\n  return shifted_constant;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e3c",
            "calling": [
                "calculate_trapezoid_for_block",
                "read_float"
            ],
            "imported": false,
            "current_name": "calculate_hash_08008e3c"
        },
        "FUN_08009654": {
            "renaming": {
                "FUN_08009654": "calculate_shifted_double_08009654",
                "__x": "input_value",
                "in_r1": "exponent_shifted",
                "iVar1": "exponent_raw",
                "in_d0": "output_value"
            },
            "code": "double calculate_shifted_double_08009654(double input_value)\n{\n  int exponent_shifted;\n  int exponent_raw;\n  double output_value;\n  \n  exponent_raw = ((uint)(input_value << 1) >> 0x15) - 0x3ff;\n  if (((0x13 < exponent_raw) && (0x33 < exponent_raw)) && (exponent_raw == 0x400)) {\n    output_value = (double)__aeabi_dadd();\n  }\n  return output_value;\n}",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009654",
            "calling": [
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "calculate_shifted_double_08009654"
        },
        "FUN_08007bc2": {
            "renaming": {
                "FUN_08007bc2": "set_timer_08007bc2",
                "TIMx": "timer",
                "_DAT_40000000": "timer_CR1",
                "_DAT_4000000c": "timer_CR2"
            },
            "code": "void set_timer_08007bc2(TIM_TypeDef *timer)\n{\n    timer->CR1 &= ~1;\n    timer->CR2 &= ~7;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bc2",
            "calling": [
                "st_go_idle"
            ],
            "imported": false,
            "current_name": "set_timer_08007bc2"
        },
        "FUN_08009410": {
            "renaming": {
                "FUN_08009410": "calculate_sine_08009410",
                "__x": "angle",
                "in_r0": "integer_part",
                "in_r1": "fractional_part",
                "dVar2": "result",
                "local_28": "remainder",
                "uStack_24": "quadrant",
                "local_20": "unused_variable",
                "uStack_1c": "unused_variable",
                "DAT_080094b4": "MAXIMUM_INTEGER_VALUE",
                "DAT_080094b8": "MAXIMUM_FRACTIONAL_VALUE",
                "__subdf3": "undefined_function",
                "__ieee754_rem_pio2": "undefined_function",
                "__kernel_sin": "undefined_function",
                "__kernel_cos": "undefined_function"
            },
            "code": "double calculate_sine_08009410(double angle)\n{\n  uint32_t integer_part;\n  uint32_t fractional_part;\n  double result;\n  uint32_t remainder;\n  uint32_t quadrant;\n  if (DAT_080094b4 < (int)(angle & 0x7fffffff)) {\n    if (DAT_080094b8 < (int)(angle & 0x7fffffff)) {\n      result = (double)__subdf3();\n    }\n    else {\n      remainder = __ieee754_rem_pio2(integer_part, fractional_part, &quadrant);\n      remainder = remainder & 3;\n      if (remainder == 1) {\n        result = (double)__kernel_sin(integer_part, fractional_part, quadrant, 1);\n      }\n      else if (remainder == 2) {\n        result = (double)__kernel_cos(integer_part, fractional_part, quadrant);\n      }\n      else if (remainder == 0) {\n        result = (double)__kernel_cos(integer_part, fractional_part, quadrant);\n      }\n      else {\n        result = (double)__kernel_sin(integer_part, fractional_part, quadrant, 1);\n      }\n    }\n    return result;\n  }\n  result = (double)__kernel_cos(integer_part, fractional_part, 0);\n  return result;\n}",
            "called": [
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "__subdf3",
                "__kernel_sin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009410",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_sine_08009410"
        },
        "FUN_080035ec": {
            "renaming": {
                "FUN_080035ec": "set_xyz_080035ec",
                "x": "x_coord",
                "y": "y_coord",
                "z": "z_coord"
            },
            "code": "void set_xyz_080035ec(int32_t x_coord, int32_t y_coord, int32_t z_coord)\n{\n  *(int32_t *)PTR_pl_08003614 = x_coord;\n  *(int32_t *)(PTR_pl_08003614 + 4) = y_coord;\n  *(int32_t *)(PTR_pl_08003614 + 8) = z_coord;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035ec",
            "calling": [
                "sys_sync_current_position"
            ],
            "imported": false,
            "current_name": "set_xyz_080035ec"
        },
        "FUN_08006c70": {
            "renaming": {
                "FUN_08006c70": "synchronize_data_08006c70",
                "DAT_08006c94": "PTR_data_offset",
                "DAT_08006c98": "data_mask",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void synchronize_data_08006c70(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* ptr = (uint *)(DAT_08006c94 + 0xc);\n  uint dat = DAT_08006c98 | (*ptr & 0x700);\n  *ptr = dat;\n  DataSynchronizationBarrier(0xf);\n  while(true)\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c70",
            "calling": [
                "HAL_NVIC_SystemReset"
            ],
            "imported": false,
            "current_name": "synchronize_data_08006c70"
        },
        "FUN_080068bc": {
            "renaming": {
                "FUN_080068bc": "set_rcc_clock_init_080068bc",
                "RCC_ClkInitStruct": "rcc_clk_init_struct",
                "pFLatency": "flash_latency",
                "ClockType": "RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2",
                "SYSCLKSource": "RCC_SYSCLKSOURCE_PLLCLK",
                "AHBCLKDivider": "RCC_SYSCLK_DIV1",
                "APB1CLKDivider": "RCC_HCLK_DIV2",
                "APB2CLKDivider": "RCC_HCLK_DIV1",
                "*DAT_08006918": "FLASH_LATENCY_4"
            },
            "code": "void set_rcc_clock_init_080068bc(RCC_ClkInitTypeDef *rcc_clk_init_struct, uint32_t *flash_latency) {\n  rcc_clk_init_struct->ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  rcc_clk_init_struct->SYSCLKSource = *(uint *)(DAT_08006914 + 8) & RCC_SYSCLKSOURCE_PLLCLK;\n  rcc_clk_init_struct->AHBCLKDivider = *(uint *)(DAT_08006914 + 8) & RCC_SYSCLK_DIV1;\n  rcc_clk_init_struct->APB1CLKDivider = *(uint *)(DAT_08006914 + 8) & RCC_HCLK_DIV2;\n  rcc_clk_init_struct->APB2CLKDivider = *(uint *)(DAT_08006914 + 8) >> 3 & RCC_HCLK_DIV1;\n  *flash_latency = *DAT_08006918 & *DAT_08006918;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068bc",
            "calling": [],
            "imported": false,
            "current_name": "set_rcc_clock_init_080068bc"
        },
        "FUN_08006944": {
            "renaming": {
                "FUN_08006944": "do_nothing_08006944"
            },
            "code": "\nvoid do_nothing_08006944(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006944",
            "calling": [
                "HAL_RCC_NMI_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08006944"
        },
        "FUN_08006d98": {
            "renaming": {
                "FUN_08006d98": "decode_priority_08006d98",
                "IRQn": "irq",
                "PriorityGroup": "priority_group",
                "pPreemptPriority": "preempt_priority",
                "pSubPriority": "sub_priority",
                "Priority": "priority"
            },
            "code": "void decode_priority_08006d98(IRQn_Type irq, uint32_t priority_group, uint32_t *preempt_priority, uint32_t *sub_priority)\n{\n  uint32_t priority = NVIC_GetPriority(irq);\n  NVIC_DecodePriority(priority, priority_group, preempt_priority, sub_priority);\n  return;\n}",
            "called": [
                "NVIC_DecodePriority",
                "NVIC_GetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d98",
            "calling": [],
            "imported": false,
            "current_name": "decode_priority_08006d98"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "increment_uwTick_08005a68",
                "PTR_uwTick_08005a80": "tick_ptr"
            },
            "code": "void increment_uwTick_08005a68(void)\n{\n  int* PTR_uwTick_08005a80 = (int*)PTR_uwTick_08005a80;\n  *PTR_uwTick_08005a80 += 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "increment_uwTick_08005a68"
        },
        "FUN_080079c0": {
            "renaming": {
                "FUN_080079c0": "clear_debounce_ready_flag_080079c0",
                "PTR_debounce_080079d8": "debounce_array",
                "PTR_debounce_ready_080079dc": "debounce_ready_flag_ptr",
                "undefined4": "bool"
            },
            "code": "void clear_debounce_ready_flag_080079c0(void)\n{\n  memset(PTR_debounce_080079d8, 0, DEBOUNCE_ARRAY_SIZE);\n  *PTR_debounce_ready_080079dc = true;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079c0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "clear_debounce_ready_flag_080079c0"
        },
        "FUN_0800b2e0": {
            "renaming": {
                "FUN_0800b2e0": "return_zero_on_exception_0800b2e0",
                "__exc": "__exception_ptr"
            },
            "code": "int return_zero_on_exception_0800b2e0(exception *__exc)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e0",
            "calling": [
                "sqrt",
                "hypot"
            ],
            "imported": false,
            "current_name": "return_zero_on_exception_0800b2e0"
        },
        "FUN_08002908": {
            "renaming": {
                "FUN_08002908": "calculate_velocity_08002908",
                "in_r0": "initial_velocity",
                "in_r1": "final_velocity",
                "in_r2": "acceleration",
                "in_r3": "distance",
                "uVar1": "velocity_squared_difference",
                "uVar2": "distance_times_double_acceleration",
                "fVar3": "velocity",
                "__addsf3": "add_floats",
                "__aeabi_fmul": "multiply_floats",
                "__aeabi_fsub": "subtract_floats",
                "__aeabi_fdiv": "divide_floats",
                "0x40800000": "double_constant",
                "PTR_": "pointer_",
                "DAT_": "data_"
            },
            "code": "float calculate_velocity_08002908(float initial_velocity, float final_velocity, float acceleration, float distance) \n{\n    float double_acceleration = acceleration * 2;\n    float distance_squared = distance * distance;\n    float initial_velocity_squared = initial_velocity * initial_velocity;\n    float final_velocity_squared = final_velocity * final_velocity;\n    float velocity_squared_difference = final_velocity_squared - initial_velocity_squared;\n    float distance_times_double_acceleration = distance * double_acceleration;\n    float numerator = velocity_squared_difference + distance_squared;\n    float denominator = distance_times_double_acceleration;\n    float velocity_squared = numerator / denominator;\n    float velocity = sqrt(velocity_squared);\n    return velocity;\n}",
            "called": [
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fsub",
                "__aeabi_fdiv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002908",
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "imported": false,
            "current_name": "calculate_velocity_08002908"
        },
        "FUN_08007c40": {
            "renaming": {
                "FUN_08007c40": "set_timer_ticks_08007c40",
                "ticks": "ticks",
                "TIMx": "timer",
                "_DAT_40000034": "timer->ARR"
            },
            "code": "void set_timer_ticks_08007c40(TIM_TypeDef *timer, uint32_t ticks)\n{\n    _DAT_40000034 = ticks;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c40",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "set_timer_ticks_08007c40"
        },
        "FUN_080094c0": {
            "renaming": {
                "FUN_080094c0": "calculate_function_080094c0",
                "__x": "input_value",
                "in_r0": "left_bits",
                "in_r1": "right_bits",
                "uVar1": "exponent_value",
                "uVar2": "exponent_bits",
                "extraout_d0": "output_value",
                "extraout_d0_00": "output_value",
                "extraout_d0_01": "output_value",
                "uVar3": "sum",
                "DAT_080095a8": "constant1",
                "DAT_080095ac": "constant2",
                "DAT_080095b0": "constant3",
                "0x3ff": "constant4",
                "0x413": "constant5",
                "0xfffffff": "constant6",
                "0xffffffff": "constant7"
            },
            "code": "double calculate_function_080094c0(double input_value)\n{\n  uint left_bits;\n  uint right_bits;\n  uint exponent_bits;\n  uint exponent_value;\n  double output_value;\n  double sum;\n  double DAT_080095a8 = 2.0;\n  double DAT_080095ac = 1.0;\n  double DAT_080095b0 = 0.0;\n  uint constant4 = 1072693248;\n  uint constant5 = 1073741824;\n  uint constant6 = 4290772992;\n  uint constant7 = 4294967295;\n  exponent_bits = (right_bits << DAT_080095a8) >> 0x15;\n  exponent_value = exponent_bits - constant4;\n  if ((int)exponent_value < 0x14) {\n    if ((int)exponent_value < 0) {\n      sum = input_value + DAT_080095ac;\n      if (sum > DAT_080095b0) {\n        output_value = sum;\n      }\n    }\n    else if ((right_bits & constant6 >> (exponent_value & constant7) | left_bits) != 0) {\n      sum = input_value + DAT_080095ac;\n      if (sum > DAT_080095b0) {\n        output_value = sum;\n      }\n    }\n  }\n  else if ((int)exponent_value < 0x34) {\n    if ((constant7 >> (exponent_bits - constant5 & constant7) & left_bits) != 0) {\n      sum = input_value + DAT_080095ac;\n      if (sum > DAT_080095b0) {\n        output_value = sum;\n      }\n    }\n  }\n  else if (exponent_value == constant5) {\n    output_value = (double)(input_value + DAT_080095ac);\n  }\n  return output_value;\n}",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094c0",
            "calling": [
                "calculate_trapezoid_for_block",
                "mc_arc",
                "mc_dwell",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculate_function_080094c0"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "FUNC_08008eec"
            },
            "code": "\nuint FUNC_08008eec(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar3 = param_1 >> 0x17 & 0xff;\n  bVar9 = uVar3 == 0;\n  if (!bVar9) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    bVar9 = param_4 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar3 == 0xff;\n  }\n  if (!bVar9) {\n    bVar9 = param_4 == 0xff;\n  }\n  if (bVar9) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    if (uVar3 == 0xff || param_4 == 0xff) {\n      bVar9 = param_1 == 0 || param_1 == 0x80000000;\n      uVar2 = param_2;\n      if (param_1 != 0 && param_1 != 0x80000000) {\n        bVar9 = param_2 == 0;\n        uVar2 = param_1;\n      }\n      if (!bVar9) {\n        bVar9 = param_2 == 0x80000000;\n      }\n      uVar8 = uVar2;\n      if (((bVar9) || ((uVar3 == 0xff && ((uVar2 & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (uVar8 = param_2, (param_2 & 0x7fffff) != 0)))) {\n        return uVar8 | 0x7fc00000;\n      }\n      uVar2 = uVar2 ^ param_2;\n      goto LAB_0800903c;\n    }\n    bVar9 = (param_1 & 0x7fffffff) == 0;\n    if (!bVar9) {\n      bVar9 = (param_2 & 0x7fffffff) == 0;\n    }\n    if (bVar9) {\n      return (param_1 ^ param_2) & 0x80000000;\n    }\n    bVar9 = uVar3 == 0;\n    uVar2 = param_1 & 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_1 = param_1 << 1;\n        bVar9 = (param_1 & 0x800000) == 0;\n      }\n      if (!bVar9) break;\n      uVar3 = uVar3 - 1;\n    }\n    param_1 = param_1 | uVar2;\n    bVar9 = param_4 == 0;\n    uVar2 = param_2 & 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_2 = param_2 << 1;\n        bVar9 = (param_2 & 0x800000) == 0;\n      }\n      if (!bVar9) break;\n      param_4 = param_4 - 1;\n    }\n    param_2 = param_2 | uVar2;\n  }\n  iVar4 = uVar3 + param_4;\n  uVar8 = param_1 ^ param_2;\n  uVar3 = param_1 << 9;\n  bVar9 = uVar3 == 0;\n  if (!bVar9) {\n    param_2 = param_2 << 9;\n    bVar9 = param_2 == 0;\n  }\n  if (bVar9) {\n    if (uVar3 == 0) {\n      param_2 = param_2 << 9;\n    }\n    uVar2 = uVar8 & 0x80000000 | param_1 & 0x7fffff | param_2 >> 9;\n    bVar10 = SBORROW4(iVar4,0x7f);\n    iVar5 = iVar4 + -0x7f;\n    bVar9 = iVar5 == 0;\n    iVar7 = iVar5;\n    if (!bVar9 && 0x7e < iVar4) {\n      bVar10 = SBORROW4(0xff,iVar5);\n      iVar7 = 0xff - iVar5;\n      bVar9 = iVar5 == 0xff;\n    }\n    if (!bVar9 && iVar7 < 0 == bVar10) {\n      uVar2 = uVar2 | iVar5 * 0x800000;\n    }\n    if (!bVar9 && iVar7 < 0 == bVar10) {\n      return uVar2;\n    }\n    uVar2 = uVar2 | 0x800000;\n    uVar6 = 0;\n    bVar10 = SBORROW4(iVar5,1);\n    uVar8 = iVar4 - 0x80;\n    bVar9 = uVar8 == 0;\n    uVar3 = uVar8;\n  }\n  else {\n    lVar1 = (ulonglong)(uVar3 >> 5 | 0x8000000) * (ulonglong)(param_2 >> 5 | 0x8000000);\n    uVar6 = (uint)lVar1;\n    uVar2 = (uint)((ulonglong)lVar1 >> 0x20);\n    bVar9 = uVar2 < 0x800000;\n    if (bVar9) {\n      uVar2 = uVar2 << 1;\n    }\n    if (bVar9) {\n      uVar2 = uVar2 | uVar6 >> 0x1f;\n      uVar6 = uVar6 << 1;\n    }\n    uVar2 = uVar8 & 0x80000000 | uVar2;\n    uVar8 = (iVar4 + -0x7f) - (uint)bVar9;\n    bVar10 = SBORROW4(uVar8,0xfd);\n    bVar9 = uVar8 == 0xfd;\n    uVar3 = uVar8 - 0xfd;\n    if (uVar8 < 0xfe) {\n      uVar2 = uVar2 + uVar8 * 0x800000 + (uint)(0x7fffffff < uVar6);\n      if (uVar6 == 0x80000000) {\n        uVar2 = uVar2 & 0xfffffffe;\n      }\n      return uVar2;\n    }\n  }\n  if (bVar9 || (int)uVar3 < 0 != bVar10) {\n    bVar9 = (int)(uVar8 + 0x19) < 0;\n    if (uVar8 == 0xffffffe7 || bVar9 != SCARRY4(uVar8,0x19)) {\n      uVar2 = uVar2 & 0x80000000;\n    }\n    if (uVar8 != 0xffffffe7 && bVar9 == SCARRY4(uVar8,0x19)) {\n      uVar3 = (uVar2 << 1) >> (-uVar8 & 0xff);\n      uVar8 = uVar2 << (uVar8 + 0x20 & 0xff);\n      uVar3 = ((uint)((uVar2 & 0x80000000) != 0) << 0x1f | uVar3 >> 1) + (uint)((byte)uVar3 & 1);\n      if ((uVar6 | uVar8 << 1) == 0) {\n        uVar3 = uVar3 & ~(uVar8 >> 0x1f);\n      }\n      return uVar3;\n    }\n    return uVar2;\n  }\nLAB_0800903c:\n  return uVar2 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008eec",
            "calling": [
                "homing_cycle",
                "mc_arc",
                "mc_dwell",
                "max_allowable_speed",
                "read_float",
                "printFloat",
                "estimate_acceleration_distance",
                "settings_store_global_setting",
                "intersection_distance",
                "calculate_trapezoid_for_block",
                "mc_go_home",
                "plan_cycle_reinitialize",
                "plan_buffer_line",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "FUNC_08008eec"
        },
        "FUN_08006b54": {
            "renaming": {
                "FUN_08006b54": "get_priority_level_08006b54",
                "IRQn": "irq_number",
                "bVar1": "priority_level",
                "DAT_08006b98": "PTR_DAT_08006b98",
                "DAT_08006b9c": "DAT_08006b9c"
            },
            "code": "uint32_t get_priority_level_08006b54(IRQn_Type irq_number)\n{\n  byte priority_level;\n  if (irq_number < WWDG_IRQn) {\n    priority_level = *(byte *)(((byte)irq_number & 0xf) + DAT_08006b98 + 0x14);\n  }\n  else {\n    priority_level = *(byte *)(irq_number + DAT_08006b9c + 0x300);\n  }\n  return (uint)(priority_level >> 4);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b54",
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "imported": false,
            "current_name": "get_priority_level_08006b54"
        },
        "FUN_08007e84": {
            "renaming": {
                "FUN_08007e84": "get_usart_data_08007e84",
                "DAT_08007ea0": "DATA_ADDRESS",
                "usart": "usart_ptr"
            },
            "code": "char get_usart_data_08007e84(void)\n{\n  USART_TypeDef *usart = NULL;\n  return (char)*(undefined4 *)(DAT_08007ea0 + 4);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e84",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "get_usart_data_08007e84"
        },
        "FUN_080057e4": {
            "renaming": {
                "FUN_080057e4": "disable_stepper_if_not_idle_080057e4",
                "PTR_settings_0800580c": "settings_array",
                "PTR_sys_08005810": "sys_array"
            },
            "code": "void disable_stepper_if_not_idle_080057e4(void)\n{\n  step_isr_disable();\n  if ((PTR_settings_0800580c[0x3c] != -1) || ((PTR_sys_08005810[2] & 0x20) != 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}",
            "called": [
                "stepper_motor_disable",
                "step_isr_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e4",
            "calling": [
                "limits_go_home",
                "step_period_isr",
                "st_init",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "disable_stepper_if_not_idle_080057e4"
        },
        "FUN_08006d8a": {
            "renaming": {
                "FUN_08006d8a": "get_nviv_priority_grouping_08006d8a",
                "uVar1": "priority_grouping"
            },
            "code": "uint32_t get_nviv_priority_grouping_08006d8a(void)\n{\n  uint32_t priority_grouping;\n  priority_grouping = NVIC_GetPriorityGrouping();\n  return priority_grouping;\n}",
            "called": [
                "NVIC_GetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d8a",
            "calling": [],
            "imported": false,
            "current_name": "get_nviv_priority_grouping_08006d8a"
        },
        "FUN_0800b2e8": {
            "renaming": {
                "FUN_0800b2e8": "calculate_power_0800b2e8",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "base_int",
                "in_r2": "exponent_int",
                "uVar1": "temp_var1",
                "iVar2": "temp_var2",
                "uVar3": "temp_var3",
                "in_d0": "result",
                "extraout_d0": "extraout_result",
                "dVar4": "temp_double1",
                "uVar5": "temp_ulonglong"
            },
            "code": "double calculate_power_0800b2e8(double base, int exponent){\n    uint base_int = (uint)base;\n    int exponent_int = exponent;\n    uint temp_var1;\n    int temp_var2;\n    uint temp_var3;\n    double result;\n    double extraout_result;\n    double temp_double1;\n    ulonglong temp_ulonglong;\n    \n    temp_ulonglong = CONCAT44(base_int,exponent_int);\n    temp_var1 = (base_int << 1) >> 0x15;\n    if (temp_var1 == 0) {\n        if ((exponent_int | base_int & 0x7fffffff) == 0) {\n            return result;\n        }\n        temp_ulonglong = __muldf3(exponent_int,base_int,0,DAT_0800b3c8);\n        if (temp_var2 < DAT_0800b3cc) goto LAB_0800b34a;\n        temp_var1 = ((uint)((int)(temp_ulonglong >> 0x20) << 1) >> 0x15) - 0x36;\n        result = extraout_result;\n    }\n    else if (temp_var1 == 0x7ff) {\n        temp_double1 = (double)__aeabi_dadd(exponent_int,base_int,exponent_int);\n        return temp_double1;\n    }\n    temp_var3 = (uint)(temp_ulonglong >> 0x20);\n    temp_var2 = temp_var1 + exponent_int;\n    if (temp_var2 < 0x7ff) {\n        if (0 < temp_var2) {\n            return result;\n        }\n        if (temp_var2 + 0x35 < 0 == SCARRY4(temp_var2,0x35)) {\n            temp_double1 = (double)__muldf3((int)temp_ulonglong,temp_var3 & 0x800fffff | (temp_var2 + 0x36) * 0x100000,0,\n                            DAT_0800b3d8);\n            return temp_double1;\n        }\n        if (exponent_int < 0xc351) {\n            temp_ulonglong = temp_ulonglong & 0x8000000000000000 | (ulonglong)DAT_0800b3d0 | 0x1a56e1f00000000;\n    LAB_0800b34a:\n            temp_double1 = (double)__muldf3((int)temp_ulonglong,(int)(temp_ulonglong >> 0x20),DAT_0800b3b8,DAT_0800b3bc);\n            return temp_double1;\n        }\n    }\n    temp_double1 = (double)__muldf3(DAT_0800b3d4,temp_var3 & 0x80000000 | 0x7e37e43c,DAT_0800b3c0,DAT_0800b3c4);\n    return temp_double1;\n}",
            "called": [
                "__muldf3",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e8",
            "calling": [
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculate_power_0800b2e8"
        },
        "FUN_08005220": {
            "renaming": {
                "FUN_08005220": "do_nothing_08005220"
            },
            "code": "\nvoid do_nothing_08005220(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005220",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_08005220"
        },
        "FUN_08007520": {
            "renaming": {
                "FUN_08007520": "set_gpio_state_if_bit_is_set_08007520",
                "bits": "bits",
                "gpio_clr": "gpio_clear",
                "is_bit_set": "is_bit_set"
            },
            "code": "void set_gpio_state_if_bit_is_set_08007520(uint32_t bits) {\n  bool is_bit_set = (bits & 1) != 0;\n  if (is_bit_set) {\n    gpio_clear(0x3e);\n  }\n  return;\n}",
            "called": [
                "gpio_clr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007520",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "set_gpio_state_if_bit_is_set_08007520"
        },
        "FUN_08007884": {
            "renaming": {
                "FUN_08007884": "get_gpio_values_08007884",
                "iVar1": "gpio_value_1",
                "iVar2": "gpio_value_2",
                "iVar3": "gpio_value_3",
                "iVar4": "gpio_value_4",
                "iVar5": "gpio_value_5",
                "uVar6": "all_gpio_values"
            },
            "code": "uint32_t get_gpio_values_08007884(void)\n{\n  int gpio_value_1;\n  int gpio_value_2;\n  int gpio_value_3;\n  int gpio_value_4;\n  int gpio_value_5;\n  uint32_t all_gpio_values;\n  \n  gpio_value_1 = gpio_rd(0x36);\n  gpio_value_2 = gpio_rd(0x37);\n  gpio_value_3 = gpio_rd(0x38);\n  gpio_value_4 = gpio_rd(0x39);\n  gpio_value_5 = gpio_rd(0xf);\n  all_gpio_values = gpio_rd(0);\n  \n  return all_gpio_values | (gpio_value_1 << 4) | (gpio_value_2 << 3) | (gpio_value_3 << 2) | (gpio_value_4 << 1) | (gpio_value_5 << 7);\n}",
            "called": [
                "gpio_rd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007884",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "get_gpio_values_08007884"
        },
        "FUN_08004250": {
            "renaming": {
                "FUN_08004250": "print_settings_08004250",
                "n": "step_x",
                "n_00": "step_y",
                "n_01": "step_z",
                "n_02": "step_pulse_usec",
                "n_03": "default_feed",
                "n_04": "step_idle_delay",
                "n_05": "acceleration",
                "n_06": "junction_deviation",
                "n_07": "arc_segment",
                "n_08": "homing_feed",
                "n_09": "homing_seek"
            },
            "code": "void print_settings_08004250(void) {\n    float step_x;\n    float step_y;\n    float step_z;\n    float step_pulse_usec;\n    float default_feed;\n    float default_seek;\n    float acceleration;\n    float junction_deviation;\n    float arc_segment;\n    float homing_feed;\n    float homing_seek;\n    float homing_pull_off;\n    float homing_debounce;\n    uint8_t n_arc_correction;\n    uint8_t n_decimals;\n\n    printPgmString(PTR_DAT_08004470);\n    printFloat(n);\n    printPgmString(PTR_s___x__step_mm___1__08004478);\n    printFloat(step_x);\n    printPgmString(PTR_s___y__step_mm___2__0800447c);\n    printFloat(step_y);\n    printPgmString(PTR_s___z__step_mm___3__08004480);\n    printFloat(step_z);\n    printInteger((uint)(byte)PTR_settings_08004474[0xd]);\n    printPgmString(PTR_s___step_pulse__usec___4__08004484);\n    printFloat(step_pulse_usec);\n    printPgmString(PTR_s___default_feed__mm_min___5__08004488);\n    printFloat(default_feed);\n    printPgmString(PTR_s___default_seek__mm_min___6__0800448c);\n    printFloat(default_seek);\n    printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x18));\n    printPgmString(PTR_s___step_port_invert_mask__int__08004490);\n    print_uint16_base2(*(uint16_t *)(PTR_settings_08004474 + 0x18));\n    printPgmString(PTR_s____7__08004494);\n    printInteger((uint)(byte)PTR_settings_08004474[0x3c]);\n    printPgmString(PTR_s___step_idle_delay__msec___8__08004498);\n    float step_idle_delay = (float)__aeabi_fdiv(*(undefined4 *)(PTR_settings_08004474 + 0x20),DAT_0800449c);\n    printFloat(step_idle_delay);\n    printPgmString(PTR_s___acceleration__mm_sec_2___9__080044a0);\n    printFloat(acceleration);\n    printPgmString(PTR_s___junction_deviation__mm___10__080044a4);\n    printFloat(junction_deviation);\n    printPgmString(PTR_s___arc__mm_segment___11__080044a8);\n    printInteger((uint)(byte)PTR_settings_08004474[0x3e]);\n    printPgmString(PTR_s___n_arc_correction__int___12__080044ac);\n    printInteger(n_arc_correction);\n    printPgmString(PTR_s___n_decimals__int___13__080044b0);\n    printInteger((uint)((PTR_settings_08004474[0x28] & 1) != 0));\n    printPgmString(PTR_s___report_inches__bool___14__080044b4);\n    printInteger((uint)((PTR_settings_08004474[0x28] & 2) != 0));\n    printPgmString(PTR_s___auto_start__bool___15__080044b8);\n    printInteger((uint)((PTR_settings_08004474[0x28] & 4) != 0));\n    printPgmString(PTR_s___invert_step_enable__bool___16__080044bc);\n    printInteger((uint)((PTR_settings_08004474[0x28] & 8) != 0));\n    printPgmString(PTR_s___hard_limits__bool___17__080044c0);\n    printInteger((uint)((PTR_settings_08004474[0x28] & 0x10) != 0));\n    printPgmString(PTR_s___homing_cycle__bool___18__080044c4);\n    printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x2a));\n    printPgmString(PTR_s___homing_dir_invert_mask__int__080044c8);\n    print_uint16_base2(*(uint16_t *)(PTR_settings_08004474 + 0x2a));\n    printPgmString(PTR_s____19__080044cc);\n    printFloat(homing_feed);\n    printPgmString(PTR_s___homing_feed__mm_min___20__080044d0);\n    printFloat(homing_seek);\n    printPgmString(PTR_s___homing_seek__mm_min___21__080044d4);\n    printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x34));\n    printPgmString(PTR_s___homing_debounce__msec___22__080044d8);\n    printFloat(homing_debounce);\n    printPgmString(PTR_s___homing_pull_off__mm___23__080044dc);\n    printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x1a));\n    printPgmString(PTR_s___dir_port_invert_mask__int__080044e0);\n    print_uint16_base2(*(uint16_t *)(PTR_settings_08004474 + 0x1a));\n    printPgmString(PTR_DAT_080044e4);\n}\n",
            "called": [
                "printInteger",
                "printPgmString",
                "__aeabi_fdiv",
                "print_uint16_base2",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004250",
            "calling": [
                "protocol_execute_line",
                "settings_init"
            ],
            "imported": false,
            "current_name": "print_settings_08004250"
        },
        "FUN_08006dc4": {
            "renaming": {
                "FUN_08006dc4": "set_pending_irq_08006dc4",
                "IRQn": "irq"
            },
            "code": "void set_pending_irq_08006dc4(IRQn_Type irq) {\n\tNVIC_SetPendingIRQ(irq);\n}",
            "called": [
                "NVIC_SetPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dc4",
            "calling": [],
            "imported": false,
            "current_name": "set_pending_irq_08006dc4"
        },
        "FUN_08007402": {
            "renaming": {
                "FUN_08007402": "set_short_value_at_address_offset_by_n_08007402",
                "n": "n",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void set_short_value_at_address_offset_by_n_08007402(int n)\n{\n    int address_offset = (n >> 4) * 0x400 + 0x40020018;\n    short value_to_set = (short)(1 << (n & 0xfU));\n    *(short *)(address_offset) = value_to_set;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007402",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "set_short_value_at_address_offset_by_n_08007402"
        },
        "FUN_08002870": {
            "renaming": {
                "FUN_08002870": "increment_block_index_08002870",
                "block_index": "block_index",
                "local_9": "incremented_index"
            },
            "code": "uint8_t increment_block_index_08002870(uint8_t block_index)\n{\n  uint8_t incremented_index;\n  incremented_index = block_index + 1;\n  if (incremented_index == 18) {\n    incremented_index = 0;\n  }\n  return incremented_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002870",
            "calling": [
                "plan_discard_current_block",
                "plan_reset_buffer",
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "increment_block_index_08002870"
        },
        "FUN_08000210": {
            "renaming": {
                "FUN_08000210": "turn_off_coolant_system_08000210"
            },
            "code": "void turn_off_coolant_system_08000210(void)\n{\n  coolant_mist_off();\n  coolant_flood_off();\n  return;\n}",
            "called": [
                "coolant_mist_off",
                "coolant_flood_off"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000210",
            "calling": [
                "coolant_init",
                "coolant_run",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "turn_off_coolant_system_08000210"
        },
        "FUN_08008a64": {
            "renaming": {
                "FUN_08008a64": "check_overlap_08008a64",
                "param_1": "first_start",
                "param_2": "first_end",
                "param_3": "first_is_before_second",
                "param_4": "overlap_exists",
                "uVar1": "xor_result",
                "bVar2": "first_is_empty",
                "bVar3": "xor_is_negative"
            },
            "code": "uint check_overlap_08008a64(uint first_start, uint first_end, uint second_start, uint second_end) {\n  bool first_is_empty = (first_start | (first_end << 1)) == 0;\n  bool second_is_empty = (second_start | (second_end << 1)) == 0;\n  if (!first_is_empty && !second_is_empty && first_end == second_start && first_start == second_end) {\n    return 0;\n  }\n  uint xor_result = first_end ^ second_start;\n  bool xor_is_negative = (int)xor_result < 0;\n  bool second_is_before_first = xor_is_negative && second_end <= first_start;\n  bool first_is_before_second = xor_result == 0 && second_end <= first_start;\n  uint overlap_exists = (int)second_end >> 0x1f;\n  if (!second_is_before_first && !first_is_before_second) {\n    overlap_exists = ~overlap_exists;\n  }\n  return overlap_exists | 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a64",
            "calling": [],
            "imported": false,
            "current_name": "check_overlap_08008a64"
        },
        "FUN_08005900": {
            "renaming": {
                "FUN_08005900": "check_for_special_characters_08005900",
                "data": "character",
                "rc": "return_code",
                "PTR_sys_08005978": "sys_ptr_08005978",
                "mc_reset": "reset_mc"
            },
            "code": "int check_for_special_characters_08005900(uint8_t character) {\n    int return_code = 0;\n    if (character == '~') {\n        PTR_sys_08005978[2] |= 2;\n        return_code = 1;\n    }\n    else if (character < 0x7f) {\n        if (character == '?') {\n            PTR_sys_08005978[2] |= 1;\n            return_code = 1;\n        }\n        else if (character < 0x40) {\n            if (character == '\\x18') {\n                mc_reset();\n                return_code = 1;\n            }\n            else if (character == '!') {\n                PTR_sys_08005978[2] |= 8;\n                return_code = 1;\n            }\n        }\n    }\n    return return_code;\n}",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005900",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "check_for_special_characters_08005900"
        },
        "FUN_08002638": {
            "renaming": {
                "FUN_08002638": "parse_float_08002638",
                "line": "input",
                "char_counter": "char_count",
                "float_ptr": "result",
                "puVar5": "byte_ptr",
                "puVar4": "current_ptr",
                "bVar1": "digit",
                "bVar2": "is_negative",
                "bVar3": "is_decimal",
                "ndigit": "digit_count",
                "exp": "exponent",
                "intval": "integer_part",
                "isdecimal": "not used",
                "isnegative": "not used",
                "c": "current_char",
                "ptr": "not used",
                "iVar6": "return value",
                "uVar7": "not used",
                "fval": "float_part"
            },
            "code": "int parse_float_08002638(char *input, uint8_t *char_count, float *result) {\n    uint8_t digit_count = 0;\n    _Bool is_negative = false;\n    _Bool is_decimal = false;\n    int8_t exponent = 0;\n    uint32_t integer_part = 0;\n    uchar current_char = *(input + *char_count);\n    char *current_ptr;\n    uchar *byte_ptr;\n\n    byte_ptr = (uchar *)(input + *char_count);\n    current_ptr = (char *)(byte_ptr + 1);\n\n    if (current_char == '-') {\n        is_negative = true;\n        current_char = *current_ptr;\n        current_ptr = (char *)(byte_ptr + 2);\n    }\n    else if (current_char == '+') {\n        current_char = *current_ptr;\n        current_ptr = (char *)(byte_ptr + 2);\n    }\n\n    while (true) {\n        uint8_t digit = current_char - '0';\n        if (digit < 10) {\n            digit_count++;\n            if (digit_count < 9) {\n                if (is_decimal) {\n                    exponent--;\n                }\n                integer_part = digit + integer_part * 10;\n            }\n            else if (!is_decimal) {\n                exponent++;\n            }\n        }\n        else {\n            if (digit == 0xfe) {\n                if (!is_decimal) {\n                    is_decimal = true;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        current_char = *current_ptr;\n        current_ptr++;\n    }\n\n    if (digit_count == 0) {\n        return 0;\n    }\n\n    float float_part = (float)__floatunsisf(integer_part);\n\n    if (exponent < 0) {\n        for (; exponent < -1; exponent += 2) {\n            float_part *= 0.01f;\n        }\n        float_part *= 0.1f;\n    }\n    else if (exponent > 0) {\n        for (; exponent > 1; exponent -= 2) {\n            float_part *= 100.0f;\n        }\n        float_part *= 10.0f;\n    }\n\n    if (is_negative) {\n        *result = -float_part;\n    }\n    else {\n        *result = float_part;\n    }\n\n    *char_count = ((char *)current_ptr - input) + 0xff;\n    return 1;\n}",
            "called": [
                "__floatunsisf",
                "__aeabi_fcmpeq",
                "__aeabi_fmul",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002638",
            "calling": [
                "protocol_execute_line",
                "next_statement"
            ],
            "imported": false,
            "current_name": "parse_float_08002638"
        },
        "FUN_08005bac": {
            "renaming": {
                "FUN_08005bac": "set_dat_08005bc0_to_one_08005bac",
                "DAT_08005bc0": "dat_08005bc0_pointer"
            },
            "code": "void set_dat_08005bc0_to_one_08005bac(void)\n{\n  *DAT_08005bc0 = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bac",
            "calling": [],
            "imported": false,
            "current_name": "set_dat_08005bc0_to_one_08005bac"
        },
        "FUN_080051b4": {
            "renaming": {
                "FUN_080051b4": "read_and_report_coord_data_080051b4",
                "uVar1": "global_settings",
                "coord_data": "coord_data",
                "i": "i",
                "read_global_settings": "read_global_settings",
                "report_status_message": "report_status_message",
                "settings_reset": "reset_settings",
                "report_grbl_settings": "report_grbl_settings",
                "settings_read_coord_data": "read_coord_data",
                "read_coord_data_result": "read_coord_data_result"
            },
            "code": "void read_and_report_coord_data_080051b4(void)\n{\n  uint8_t global_settings = read_global_settings();\n  if (global_settings == 0) {\n    report_status_message('\\n');\n    reset_settings(true);\n    report_grbl_settings();\n  }\n  for (uint8_t i = 0; i < 8; i++) {\n    uint8_t read_coord_data_result = read_coord_data(i, coord_data);\n    if (read_coord_data_result == 0) {\n      report_status_message('\\n');\n    }\n  }\n  return;\n}",
            "called": [
                "settings_read_coord_data",
                "settings_reset",
                "read_global_settings",
                "report_status_message",
                "report_grbl_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051b4",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "read_and_report_coord_data_080051b4"
        },
        "FUN_080098d0": {
            "renaming": {
                "FUN_080098d0": "calculate_function_080098d0",
                "__x": "input",
                "cVar1": "version",
                "iVar2": "comparison_result",
                "puVar3": "error_ptr",
                "piVar4": "error_ptr",
                "dVar5": "result",
                "extraout_d0": "result",
                "extraout_d0_00": "result",
                "extraout_d0_01": "result",
                "extraout_d0_02": "result",
                "extraout_d0_03": "result",
                "local_50": "local_array",
                "local_38": "local_double",
                "local_30": "local_int"
            },
            "code": "double calculate_function_080098d0(double input)\\n{\\n    double result;\\n    char version = *PTR___fdlib_version_08009988;\\n    undefined local_array[24];\\n    undefined8 local_double;\\n    int local_int;\\n\\n    result = (double)__ieee754_calculate_function_080098d0();\\n\\n    if (((version == -1) || (local_int = __unorddf2(), result = result, local_int != 0)) || (iVar2 = __aeabi_dcmplt(), result = extraout_d0_00, iVar2 == 0)) {\\n        return result;\\n    }\\n\\n    local_array._0_4_ = 1;\\n    local_array._4_4_ = PTR_DAT_0800998c;\\n\\n    if (version == \"\\0\") {\\n        local_double = 0.0;\\n\\n    LAB_0800996c:\\n        int error = matherr((exception *)local_array);\\n        result = extraout_d0_02;\\n        if (error != 0) goto joined_r0x0800997a;\\n    }\\n    else {\\n        local_double = (double)__divdf3(0,0,0,0);\\n        if (version != \"\\x02\") goto LAB_0800996c;\\n    }\\n\\n    undefined4 *error_ptr = (undefined4 *)__errno();\\n    *error_ptr = 0x21;\\n    result = extraout_d0_01;\\n\\njoined_r0x0800997a:\\n    if (local_int != 0) {\\n        int *error_ptr = (int *)__errno();\\n        *error_ptr = local_int;\\n        result = extraout_d0_03;\\n    }\\n\\n    return result;\\n}",
            "called": [
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__unorddf2",
                "__divdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d0",
            "calling": [
                "homing_cycle",
                "plan_buffer_line",
                "max_allowable_speed",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_function_080098d0"
        },
        "FUN_08005c30": {
            "renaming": {
                "FUN_08005c30": "check_ticks_08005c30",
                "ticks": "ticks",
                "bVar1": "is_valid_ticks",
                "DAT_08005c70": "dat_array"
            },
            "code": "uint32_t check_ticks_08005c30(uint32_t ticks) {\n  bool is_valid_ticks = ticks - 1 < 0x1000000;\n  if (is_valid_ticks) {\n    DAT_08005c70[1] = ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn, 0xf);\n    DAT_08005c70[2] = 0;\n    *DAT_08005c70 = 7;\n  }\n  return (uint)!is_valid_ticks;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c30",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "check_ticks_08005c30"
        },
        "FUN_0800b51c": {
            "renaming": {
                "FUN_0800b51c": "do_nothing_0800b51c"
            },
            "code": "\nvoid do_nothing_0800b51c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b51c",
            "calling": [
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b51c"
        },
        "FUN_0800056c": {
            "renaming": {
                "FUN_0800056c": "calculate_value_0800056c",
                "value": "input_value",
                "in_r0": "register_0",
                "uVar1": "converted_value",
                "DAT_080005a8": "data_value_1",
                "DAT_080005ac": "data_value_2"
            },
            "code": "float calculate_value_0800056c(float input_value)\\n{\\n  if (PTR_gc_080005b0[3] != \"\\0\") {\\n    double converted_value = (double)input_value;\\n    double multiplied_value = converted_value * DAT_080005a8 * DAT_080005ac;\\n    float final_value = (float)multiplied_value;\\n    return final_value;\\n  }\\n  return input_value;\\n}",
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__muldf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800056c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_value_0800056c"
        },
        "FUN_08002f24": {
            "renaming": {
                "FUN_08002f24": "reset_buffer_and_set_to_zero_08002f24",
                "PTR_pl_08002f3c": "planner_data"
            },
            "code": "void reset_buffer_and_set_to_zero_08002f24(void)\n{\n  plan_reset_buffer();\n  memset(PTR_pl_08002f3c, 0, sizeof(PTR_pl_08002f3c));\n  return;\n}",
            "called": [
                "memset",
                "plan_reset_buffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f24",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "reset_buffer_and_set_to_zero_08002f24"
        },
        "FUN_0800981c": {
            "renaming": {
                "FUN_0800981c": "calculate_result_0800981c",
                "__x": "x",
                "__y": "y",
                "cVar1": "version",
                "puVar2": "fdlib_version_ptr",
                "iVar3": "is_finite_x_y",
                "puVar4": "errno_ptr",
                "dVar5": "result",
                "extraout_d0": "extraout_d0",
                "extraout_d0_00": "extraout_d0_00",
                "extraout_d0_01": "extraout_d0_01",
                "extraout_d0_02": "extraout_d0_02",
                "extraout_d0_03": "extraout_d0_03",
                "in_stack_ffffffb0": "stack_int",
                "in_stack_ffffffb4": "stack_char_ptr"
            },
            "code": "double calculate_result_0800981c(double x, double y)\n{\n  char version;\n  undefined *fdlib_version_ptr;\n  int is_finite_x_y;\n  undefined4 *errno_ptr;\n  double result;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  double extraout_d0_02;\n  double extraout_d0_03;\n  int stack_int;\n  char *stack_char_ptr;\n  \n  fdlib_version_ptr = PTR___fdlib_version_080098cc;\n  result = (double)__ieee754_calculate_result_0800981c();\n  is_finite_x_y = finite((double)CONCAT44(stack_char_ptr,stack_int));\n  if (((*fdlib_version_ptr != -1) && (is_finite_x_y == 0) && (is_finite_x_y = finite((double)CONCAT44(stack_char_ptr,stack_int)), result = extraout_d0, is_finite_x_y != 0) && (is_finite_x_y = finite((double)CONCAT44(stack_char_ptr,stack_int)), result = extraout_d0_00, is_finite_x_y != 0 && (((version = *fdlib_version_ptr, version != '\\0' && (version == '\\x02')) || (is_finite_x_y = matherr((exception *)&stack_int), result = extraout_d0_03, is_finite_x_y == 0)))))) {\n    errno_ptr = (undefined4 *)__errno();\n    *errno_ptr = 0x22;\n    result = extraout_d0_02;\n  }\n  return result;\n}",
            "called": [
                "finite",
                "__ieee754_hypot",
                "__errno",
                "matherr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800981c",
            "calling": [
                "mc_arc",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_result_0800981c"
        },
        "FUN_080059b4": {
            "renaming": {
                "FUN_080059b4": "initialize_system_080059b4",
                "DAT_080059f4": "ptr_dat_080059f4"
            },
            "code": "HAL_StatusTypeDef initialize_system_080059b4(void)\n{\n  uint32_t *DAT_080059f4 = DAT_080059f4;\n  *DAT_080059f4 |= (1 << 9);\n  *DAT_080059f4 |= (1 << 10);\n  *DAT_080059f4 |= (1 << 8);\n  HAL_SYSTICK_Config(16000);\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_SYSTICK_Config",
                "HAL_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059b4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_system_080059b4"
        },
        "FUN_08006c04": {
            "renaming": {
                "FUN_08006c04": "calculate_priority_bits_08006c04",
                "Priority": "priority",
                "PriorityGroup": "priority_group",
                "pPreemptPriority": "preempt_priority_bits",
                "pSubPriority": "sub_priority_bits",
                "SubPriorityBits": "sub_priority_mask",
                "PreemptPriorityBits": "preempt_priority_mask",
                "PriorityGroupTmp": "priority_group_bits",
                "uVar1": "priority_group_bits",
                "uVar2": "priority_group_remaining_bits"
            },
            "code": "void calculate_priority_bits_08006c04(uint32_t priority, uint32_t priority_group, uint32_t *preempt_priority_bits, uint32_t *sub_priority_bits)\n{\n  uint32_t sub_priority_mask;\n  uint32_t preempt_priority_mask;\n  uint32_t priority_group_bits;\n  uint32_t priority_group_remaining_bits;\n  uint32_t priority_group_shift;\n  priority_group_bits = priority_group & 7;\n  priority_group_remaining_bits = 7 - priority_group_bits;\n  if (priority_group_remaining_bits > 3) {\n    priority_group_remaining_bits = 4;\n  }\n  if (priority_group_bits + 4 < 7) {\n    priority_group_shift = 0;\n  }\n  else {\n    priority_group_shift = priority_group_bits - 3;\n  }\n  preempt_priority_mask = (1 << (priority_group_remaining_bits & 0xff)) - 1U & priority >> (priority_group_shift & 0xff);\n  sub_priority_mask = (1 << (priority_group_shift & 0xff)) - 1U & priority;\n  *preempt_priority_bits = preempt_priority_mask;\n  *sub_priority_bits = sub_priority_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c04",
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priority_bits_08006c04"
        },
        "FUN_08002e08": {
            "renaming": {
                "FUN_08002e08": "calculate_trapezoid_for_all_blocks_08002e08",
                "pbVar1": "current_block",
                "uVar2": "current_entry_speed",
                "next": "next_block",
                "block_index": "block_index"
            },
            "code": "void calculate_trapezoid_for_all_blocks_08002e08(void)\n{\n  block_t *current_block;\n  block_t *next_block;\n  uint8_t block_index;\n  \n  block_index = *PTR_block_buffer_tail_08002ed0;\n  next_block = NULL;\n  while (block_index != *PTR_block_buffer_head_08002ed8) {\n    current_block = (block_t *)(PTR_block_buffer_08002ed4 + (uint)block_index * 0x40);\n    if ((next_block != NULL) && ((next_block->recalculate_flag != 0 || (current_block->recalculate_flag != 0)))) {\n      __aeabi_fdiv(next_block->entry_speed, next_block->nominal_speed);\n      float current_entry_speed = __aeabi_fdiv(current_block->entry_speed, current_block->nominal_speed);\n      calculate_trapezoid_for_block(next_block, current_entry_speed, 0);\n      next_block->recalculate_flag = 0;\n    }\n    block_index = next_block_index(block_index);\n    next_block = current_block;\n  }\n  __aeabi_fdiv(next_block->entry_speed, next_block->nominal_speed);\n  calculate_trapezoid_for_block(next_block, 0, 0);\n  next_block->recalculate_flag = 0;\n  return;\n}",
            "called": [
                "calculate_trapezoid_for_block",
                "next_block_index",
                "__aeabi_fdiv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e08",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "calculate_trapezoid_for_all_blocks_08002e08"
        },
        "FUN_08005bc4": {
            "renaming": {
                "FUN_08005bc4": "set_dat_to_zero_08005bc4",
                "DAT_08005bd8": "dat_pointer"
            },
            "code": "void set_dat_to_zero_08005bc4(void)\n{\n  *DAT_08005bd8 = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bc4",
            "calling": [],
            "imported": false,
            "current_name": "set_dat_to_zero_08005bc4"
        },
        "FUN_08006680": {
            "renaming": {
                "FUN_08006680": "get_HCLK_freq_divided_by_APB_AHB_prescalar_08006680",
                "uVar1": "HCLK_freq",
                "uVar2": "leading_zeroes_count",
                "result": "APB_AHB_prescalar_index",
                "result_1": "unused"
            },
            "code": "uint32_t get_HCLK_freq_divided_by_APB_AHB_prescalar_08006680(void)\n{\n  uint32_t HCLK_freq = HAL_RCC_GetHCLKFreq();\n  uint8_t leading_zeroes_count = count_leading_zeroes(0x380000);\n  uint32_t APB_AHB_prescalar_index = (*(uint *)(APBAHBPrescTable_080066c8 + 8) & 0x1c00) >> (leading_zeroes_count & 0xff);\n  return HCLK_freq >> APB_AHB_prescalar_index;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006680",
            "calling": [
                "set_baud_rate"
            ],
            "imported": false,
            "current_name": "get_HCLK_freq_divided_by_APB_AHB_prescalar_08006680"
        },
        "FUN_08000340": {
            "renaming": {
                "FUN_08000340": "update_eeprom_data_08000340",
                "addr": "address",
                "new_value": "new_value",
                "PTR_eeprom_ready_0800036c": "eeprom_ready",
                "eeprom_init": "initialize_eeprom",
                "PTR_eeprom_data_08000370": "eeprom_data"
            },
            "code": "void update_eeprom_data_08000340(uint address, uchar new_value)\n{\n    if (*(int *)PTR_eeprom_ready_0800036c == 0)\n    {\n        initialize_eeprom();\n    }\n    PTR_eeprom_data_08000370[address & 0x3ff] = new_value;\n    return;\n}",
            "called": [
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000340",
            "calling": [
                "memcpy_to_eeprom_with_checksum",
                "write_global_settings"
            ],
            "imported": false,
            "current_name": "update_eeprom_data_08000340"
        },
        "FUN_08004bf4": {
            "renaming": {
                "FUN_08004bf4": "write_coord_data_to_eeprom_08004bf4",
                "coord_select": "coord_select",
                "coord_data": "coord_data",
                "addr": "addr"
            },
            "code": "void write_coord_data_to_eeprom_08004bf4(uint8_t coord_select, float *coord_data) {\n  uint16_t addr = (coord_select * 13) + 512;\n  memcpy_to_eeprom_with_checksum(addr, (char *)coord_data, 12);\n  return;\n}",
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bf4",
            "calling": [
                "settings_read_coord_data",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "write_coord_data_to_eeprom_08004bf4"
        },
        "FUN_08004d7c": {
            "renaming": {
                "FUN_08004d7c": "read_coordinate_data_08004d7c",
                "coord_select": "coordinate_index",
                "coord_data": "coordinate_data",
                "iVar1": "read_result",
                "addr": "N/A"
            },
            "code": "bool read_coordinate_data_08004d7c(uint8_t coordinate_index, float *coordinate_data) {\n    int read_result = memcpy_from_eeprom_with_checksum((char *)coordinate_data, (uint)(ushort)((ushort)coordinate_index * 0xd + 0x200), 0xc);\n    if (read_result == 0) {\n        memset(coordinate_data, 0, 0xc);\n        settings_write_coord_data(coordinate_index, coordinate_data);\n    }\n    return read_result != 0;\n}",
            "called": [
                "settings_write_coord_data",
                "memset",
                "memcpy_from_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d7c",
            "calling": [
                "gc_init",
                "report_gcode_parameters",
                "gc_execute_line",
                "settings_init"
            ],
            "imported": false,
            "current_name": "read_coordinate_data_08004d7c"
        },
        "FUN_08009278": {
            "renaming": {
                "FUN_08009278": "calculate_value_08009278",
                "param_1": "input_value",
                "uVar1": "shifted_value",
                "uVar2": "shift_amount",
                "uVar3": "result"
            },
            "code": "uint calculate_value_08009278(uint input_value)\n{\n  uint shifted_value;\n  uint shift_amount;\n  uint result;\n  \n  if (input_value << 1 < 0x7f000000) {\n    return 0;\n  }\n  \n  shifted_value = (input_value << 1) >> 0x18;\n  shift_amount = 0x9e - shifted_value;\n  \n  if (shifted_value < 0x9f && shift_amount != 0) {\n    result = (input_value << 8 | 0x80000000) >> (shift_amount & 0xff);\n    if ((input_value & 0x80000000) != 0) {\n      result = -result;\n    }\n    return result;\n  }\n  \n  if ((shift_amount == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  \n  input_value = input_value & 0x80000000;\n  if (input_value == 0) {\n    input_value = 0x7fffffff;\n  }\n  return input_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009278",
            "calling": [
                "protocol_execute_line",
                "printFloat"
            ],
            "imported": false,
            "current_name": "calculate_value_08009278"
        },
        "FUN_080004fc": {
            "renaming": {
                "FUN_080004fc": "divide_by_settings_080004fc",
                "x": "x_coord",
                "y": "y_coord",
                "z": "z_coord",
                "uVar1": "x_dividend",
                "PTR_settings_08000564": "x_divisor",
                "PTR_gc_08000568": "gc_pointer"
            },
            "code": "void divide_by_settings_080004fc(int32_t x_coord, int32_t y_coord, int32_t z_coord)\n{\n  float x_dividend = __floatsisf(x_coord);\n  float PTR_settings_08000564 = *(float *)PTR_settings_08000564;\n  float x_quotient = __aeabi_fdiv(x_dividend, PTR_settings_08000564);\n  *(float *)(PTR_gc_08000568 + 0xc) = x_quotient;\n  \n  float y_dividend = __floatsisf(y_coord);\n  float y_divisor = *(float *)(PTR_settings_08000564 + 4);\n  float y_quotient = __aeabi_fdiv(y_dividend, y_divisor);\n  *(float *)(PTR_gc_08000568 + 0x10) = y_quotient;\n  \n  float z_dividend = __floatsisf(z_coord);\n  float z_divisor = *(float *)(PTR_settings_08000564 + 8);\n  float z_quotient = __aeabi_fdiv(z_dividend, z_divisor);\n  *(float *)(PTR_gc_08000568 + 0x14) = z_quotient;\n  return;\n}",
            "called": [
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004fc",
            "calling": [
                "sys_sync_current_position"
            ],
            "imported": false,
            "current_name": "divide_by_settings_080004fc"
        },
        "FUN_08000220": {
            "renaming": {
                "FUN_08000220": "coolant_control_08000220",
                "mode": "new_mode",
                "*PTR_current_coolant_mode_08000264": "*current_coolant_mode",
                "coolant_flood_on()": "turn_on_coolant_flood",
                "coolant_mist_on()": "turn_on_coolant_mist",
                "coolant_stop()": "turn_off_coolant",
                "'\\x01'": "COOLANT_FLOOD_MODE",
                "'\\x02'": "COOLANT_MIST_MODE"
            },
            "code": "void coolant_control_08000220(uint8_t new_mode)\n{\n  if (new_mode != *PTR_current_coolant_mode_08000264) {\n    plan_synchronize();\n    if (new_mode == COOLANT_FLOOD_MODE) {\n      coolant_flood_on();\n    }\n    else if (new_mode == COOLANT_MIST_MODE) {\n      coolant_mist_on();\n    }\n    else {\n      coolant_stop();\n    }\n    *PTR_current_coolant_mode_08000264 = new_mode;\n  }\n  return;\n}",
            "called": [
                "plan_synchronize",
                "coolant_stop",
                "coolant_mist_on",
                "coolant_flood_on"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000220",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "coolant_control_08000220"
        },
        "FUN_08005238": {
            "renaming": {
                "FUN_08005238": "reset_spindle_direction_08005238",
                "PTR_current_direction_0800524c": "current_direction",
                "spindle_stop": "stop_spindle"
            },
            "code": "void reset_spindle_direction_08005238(void)\n{\n  *PTR_current_direction_0800524c = 0;\n  stop_spindle();\n  return;\n}",
            "called": [
                "spindle_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005238",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "reset_spindle_direction_08005238"
        },
        "FUN_08007da8": {
            "renaming": {
                "FUN_08007da8": "set_timer_interrupt_08007da8",
                "puVar1": "timer_register",
                "TIMx": "timer_instance",
                "DAT_08007dd4": "timer_data"
            },
            "code": "void set_timer_interrupt_08007da8(void)\n{\n  uint32_t *timer_register;\n  TIM_TypeDef *timer_instance;\n  timer_register = DAT_08007dd4;\n  DAT_08007dd4[8] |= 0x10;\n  *timer_register |= 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007da8",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "set_timer_interrupt_08007da8"
        },
        "FUN_08004148": {
            "renaming": {
                "FUN_08004148": "print_alarm_message_08004148",
                "alarm_code": "alarm_code",
                "PTR_s_ALARM__08004190": "alarm_header",
                "PTR_s_Abort_during_cycle_08004198": "abort_message",
                "PTR_s_Hard_limit_08004194": "hard_limit_message",
                "PTR_s___MPos__0800419c": "current_position",
                "delay_ms": "delay_ms"
            },
            "code": "void print_alarm_message_08004148(int8_t alarm_code) {\n  printPgmString(PTR_s_ALARM__08004190);\n  if (alarm_code == ABORT_CYCLE) {\n    printPgmString(PTR_s_Abort_during_cycle_08004198);\n  }\n  else if (alarm_code == HARD_LIMIT) {\n    printPgmString(PTR_s_Hard_limit_08004194);\n  }\n  printPgmString(PTR_s___MPos__0800419c);\n  delay_ms(500);\n  return;\n}",
            "called": [
                "printPgmString",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004148",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "print_alarm_message_08004148"
        },
        "FUN_08004940": {
            "renaming": {
                "FUN_08004940": "print_machine_position_08004940",
                "print_position": "work_position",
                "current_position": "machine_position",
                "i": "index",
                "uVar1": "unsigned_var_1",
                "fVar2": "float_var_2",
                "extraout_s0": "extra_out_float_0",
                "extraout_s0_00": "extra_out_float_00",
                "extraout_s0_01": "extra_out_float_01",
                "extraout_s0_02": "extra_out_float_02"
            },
            "code": "void print_machine_position_08004940()\n{\n    // Get current position\n    int32_t current_position[3];\n    current_position[X_AXIS] = *(int32_t *)(PTR_sys_08004b88 + 4);\n    current_position[Y_AXIS] = *(int32_t *)(PTR_sys_08004b88 + 8);\n    current_position[Z_AXIS] = *(int32_t *)(PTR_sys_08004b88 + 0xc);\n\n    // Print machine position\n    printPgmString(PTR_s__MPos__08004ba8);\n    for (uint8_t i = 0; i < 3; i++) {\n        float position = (float)current_position[i] / *(float *)(PTR_settings_08004bac + i * 4);\n        if (PTR_settings_08004bac[0x28] & 1) {\n            position = (float)((double)position * (double)DAT_08004b80) - (float)((double)position * (double)DAT_08004b84);\n        }\n        printFloat(position);\n        printPgmString(PTR_DAT_08004bb0);\n    }\n\n    // Print work position\n    printPgmString(PTR_s_WPos__08004bb4);\n    for (uint8_t i = 0; i < 3; i++) {\n        float position = print_position[i];\n        if (PTR_settings_08004bac[0x28] & 1) {\n            float offset = (float)(*(int32_t *)(PTR_gc_08004bb8 + (i + 8) * 4) + *(int32_t *)(PTR_gc_08004bb8 + (i + 10) * 4 + 4));\n            position = (float)((double)position * (double)DAT_08004b80) - (float)((double)offset * (double)DAT_08004b84);\n        } else {\n            float offset = (float)(*(int32_t *)(PTR_gc_08004bb8 + (i + 8) * 4) + *(int32_t *)(PTR_gc_08004bb8 + (i + 10) * 4 + 4));\n            position -= offset;\n        }\n        printFloat(position);\n        if (i < 2) {\n            printPgmString(PTR_DAT_08004bb0);\n        }\n    }\n    printPgmString(PTR_DAT_08004bbc);\n}\n",
            "called": [
                "__addsf3",
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__muldf3",
                "printPgmString",
                "__floatsisf",
                "__aeabi_fdiv",
                "__subdf3",
                "printFloat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004940",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "print_machine_position_08004940"
        },
        "FUN_08008a74": {
            "renaming": {
                "FUN_08008a74": "check_params_08008a74",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "result",
                "uVar1": "xor_result",
                "bVar2": "is_input_2_zero",
                "bVar3": "is_input_4_smaller"
            },
            "code": "uint check_params_08008a74(uint input_1, uint input_2, uint input_3, uint input_4)\n{\n  uint result;\n  bool is_input_2_negative;\n  bool is_input_4_negative;\n\n  is_input_2_negative = ((int)(input_2 << 1) >> 0x15 == -1);\n  is_input_4_negative = ((int)(input_4 << 1) >> 0x15 == -1);\n\n  if (is_input_2_negative || is_input_4_negative)\n  {\n    if ((is_input_2_negative && ((input_1 | input_2 << 0xc) != 0)) || (is_input_4_negative && ((input_3 | input_4 << 0xc) != 0)))\n    {\n      result = 1;\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else if ((input_1 | input_2 << 1) == 0 || (input_3 | input_4 << 1) == 0 || input_2 == input_4 || input_1 == input_3)\n  {\n    result = 0;\n  }\n  else\n  {\n    uint xor_result = input_2 ^ input_4;\n    bool is_xor_result_negative = (int)xor_result < 0;\n    bool is_input_4_smaller = is_xor_result_negative && input_4 <= input_2;\n    bool is_input_3_smaller = !is_xor_result_negative && input_3 <= input_1;\n    result = is_input_4_smaller || is_input_3_smaller ? 1 : 0;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a74",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "check_params_08008a74"
        },
        "FUN_08002fd4": {
            "renaming": {
                "FUN_08002fd4": "execute_protocol_runtime_until_block_complete_08002fd4",
                "pbVar1": "current_block"
            },
            "code": "void execute_protocol_runtime_until_block_complete_08002fd4(void)\\n{\\n  block_t *current_block;\\n  while ((current_block = plan_get_current_block(), current_block != (block_t *)0x0 || (PTR_sys_08003000[1] == \"\\x03\")))\\n  {\\n    protocol_execute_runtime();\\n    if (*PTR_sys_08003000 != \"\\0\")\\n    {\\n      return;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "plan_get_current_block",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fd4",
            "calling": [
                "coolant_run",
                "mc_go_home",
                "spindle_run",
                "mc_dwell",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "execute_protocol_runtime_until_block_complete_08002fd4"
        },
        "FUN_08002408": {
            "renaming": {
                "FUN_08002408": "calculate_delay_in_ms_08002408",
                "seconds": "input_seconds",
                "ms": "milliseconds",
                "uVar1": "multiplier_1",
                "uVar2": "multiplier_2",
                "i": "iterations",
                "in_r0": "unused_variable_1",
                "extraout_r1": "unused_variable_2",
                "extraout_r1_00": "unused_variable_3",
                "in_stack_ffffffe0": "unused_variable_4",
                "delay_in_seconds": "delay_in_seconds",
                "delay_in_ms_float": "delay_in_ms_float"
            },
            "code": "void calculate_delay_in_ms_08002408(float seconds)\\n{\\n  uint16_t milliseconds;\\n  float multiplier_1 = 1000.0f;\\n  float multiplier_2 = 50.0f;\\n  uint16_t iterations;\\n  float delay_in_seconds;\\n  float delay_in_ms_float;\\n  delay_in_seconds = seconds * multiplier_1;\\n  iterations = (uint16_t) delay_in_seconds / multiplier_2;\\n  plan_synchronize();\\n  delay_in_ms_float = (delay_in_seconds - (iterations * multiplier_2)) * multiplier_1;\\n  milliseconds = (uint16_t) delay_in_ms_float;\\n  delay_ms(milliseconds);\\n  while ((iterations != 0 && (protocol_execute_runtime(), *PTR_sys_080024c0 == \"\\0\"))) {\\n    _delay_ms(50);\\n    iterations--;\\n  }\\n  return;\\n}",
            "called": [
                "floor",
                "plan_synchronize",
                "__aeabi_fmul",
                "_delay_ms",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__floatsisf",
                "protocol_execute_runtime",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002408",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_delay_in_ms_08002408"
        },
        "FUN_08002a94": {
            "renaming": {
                "FUN_08002a94": "process_blocks_08002a94",
                "next": "current_block",
                "previous": "previous_block",
                "block": "blocks",
                "block_index": "block_index",
                "PTR_block_buffer_head_08002af0": "PTR_block_buffer_head_08002af0",
                "PTR_block_buffer_tail_08002af8": "PTR_block_buffer_tail_08002af8",
                "prev_block_index": "prev_block_index",
                "PTR_block_buffer_08002af4": "PTR_block_buffer_08002af4",
                "FUN_08002a94_kernel": "process_block_kernel"
            },
            "code": "void process_blocks_08002a94(void)\n{\n  block_t *current_block;\n  block_t *previous_block;\n  block_t *blocks[2];\n  uint8_t block_index;\n  \n  block_index = *PTR_block_buffer_head_08002af0;\n  blocks[0] = NULL;\n  blocks[1] = NULL;\n  \n  while (block_index != *PTR_block_buffer_tail_08002af8) {\n    block_index = prev_block_index(block_index);\n    blocks[1] = blocks[0];\n    previous_block = (block_t *)(PTR_block_buffer_08002af4 + (uint)block_index * 0x40);\n    process_block_kernel(previous_block, blocks[0], current_block);\n    blocks[0] = previous_block;\n  }\n  return;\n}",
            "called": [
                "planner_reverse_pass_kernel",
                "prev_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a94",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "process_blocks_08002a94"
        },
        "FUN_08003618": {
            "renaming": {
                "FUN_08003618": "update_block_parameters_08003618",
                "step_events_remaining": "remaining_step_events",
                "PTR_block_buffer_08003698": "PTR_block_buffer",
                "PTR_block_buffer_tail_08003694": "block_buffer_tail",
                "puVar2": "block",
                "bVar1": "block_tail",
                "uVar3": "time_delta",
                "uVar4": "velocity",
                "block": "block",
                "block_buffer_tail": "block_buffer_tail",
                "PTR_block_buffer": "PTR_block_buffer"
            },
            "code": "void update_block_parameters_08003618(int32_t remaining_step_events)\n{\n  byte block_tail = *PTR_block_buffer_08003698_tail_08003694;\n  block_t *block = PTR_block_buffer_08003698 + (uint)block_tail * 0x40;\n  undefined4 velocity = *(undefined4 *)(block + 0x20);\n  undefined4 time_delta = __floatsisf(remaining_step_events);\n  undefined4 new_velocity = __aeabi_fmul(velocity, time_delta);\n  undefined4 distance = *(undefined4 *)(block + 0x10);\n  undefined4 new_distance = __aeabi_fdiv(new_velocity, distance);\n  *(undefined4 *)(block + 0x20) = new_velocity;\n  *(undefined4 *)(block + 0x10) = remaining_step_events;\n  *(undefined4 *)(block + 0x18) = 0;\n  *(undefined4 *)(block + 0x1c) = 0;\n  block[0x25] = 0;\n  block[0x24] = 1;\n  planner_recalculate();\n}",
            "called": [
                "planner_recalculate",
                "__aeabi_fmul",
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003618",
            "calling": [
                "st_cycle_reinitialize"
            ],
            "imported": false,
            "current_name": "update_block_parameters_08003618"
        },
        "FUN_0800522c": {
            "renaming": {
                "FUN_0800522c": "do_nothing_0800522c"
            },
            "code": "\nvoid do_nothing_0800522c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800522c",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_0800522c"
        },
        "FUN_0800af78": {
            "renaming": {
                "FUN_0800af78": "FUNC_0800af78"
            },
            "code": "\ndouble FUNC_0800af78(double __x)\n\n{\n  undefined *puVar1;\n  int in_r0;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint in_r1;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 extraout_r1;\n  uint uVar6;\n  int iVar7;\n  double in_d0;\n  double dVar8;\n  double extraout_d0;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  undefined4 in_stack_ffffffd0;\n  uint uVar11;\n  \n  uVar6 = in_r1 & 0x7fffffff;\n  if (DAT_0800b298 < (int)uVar6) {\n    if ((uVar6 != DAT_0800b29c && (int)DAT_0800b29c <= (int)uVar6) ||\n       ((uVar6 == DAT_0800b29c && (in_r0 != 0)))) {\n      dVar8 = (double)__aeabi_dadd();\n      return dVar8;\n    }\n  }\n  else {\n    if (DAT_0800b2ac < (int)uVar6) {\n      fabs((double)CONCAT44(in_r1,in_stack_ffffffd0));\n      if (DAT_0800b2bc < (int)uVar6) {\n        if ((int)uVar6 < DAT_0800b2c0) {\n          uVar9 = __subdf3();\n          uVar10 = __muldf3(in_r0,extraout_r1,0,DAT_0800b2c4);\n          uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_0800b2b8);\n          uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),(int)uVar10,\n                           (int)((ulonglong)uVar10 >> 0x20));\n          uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n          in_r0 = (int)uVar9;\n          iVar7 = 2;\n        }\n        else {\n          uVar9 = __divdf3(0,DAT_0800b2c8,in_r0,extraout_r1);\n          uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n          in_r0 = (int)uVar9;\n          iVar7 = 3;\n        }\n      }\n      else if (DAT_0800b2bc + -0xd0000 < (int)uVar6) {\n        uVar9 = __subdf3();\n        uVar10 = __aeabi_dadd(in_r0,extraout_r1,0,DAT_0800b2b8);\n        uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),(int)uVar10,\n                         (int)((ulonglong)uVar10 >> 0x20));\n        uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n        in_r0 = (int)uVar9;\n        iVar7 = 1;\n      }\n      else {\n        uVar9 = __aeabi_dadd();\n        uVar9 = __subdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),0,DAT_0800b2b8);\n        uVar10 = __aeabi_dadd(in_r0,extraout_r1,0,0x40000000);\n        uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),(int)uVar10,\n                         (int)((ulonglong)uVar10 >> 0x20));\n        uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n        in_r0 = (int)uVar9;\n        iVar7 = 0;\n      }\n    }\n    else {\n      uVar11 = in_r1;\n      if ((int)uVar6 <= DAT_0800b2ac + -0x1bc0000) {\n        uVar9 = __aeabi_dadd(in_r0,in_r1,DAT_0800b290,DAT_0800b294);\n        iVar7 = __aeabi_dcmpgt((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),0,DAT_0800b2b8);\n        if (iVar7 != 0) {\n          return extraout_d0;\n        }\n      }\n      iVar7 = -1;\n    }\n    uVar9 = __muldf3(in_r0,uVar11,in_r0);\n    uVar4 = (undefined4)((ulonglong)uVar9 >> 0x20);\n    uVar2 = (undefined4)uVar9;\n    uVar9 = __muldf3(uVar2,uVar4,uVar2,uVar4);\n    uVar5 = (undefined4)((ulonglong)uVar9 >> 0x20);\n    uVar3 = (undefined4)uVar9;\n    uVar9 = __muldf3(uVar3,uVar5,DAT_0800b238,DAT_0800b23c);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b240,DAT_0800b244);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b248,DAT_0800b24c);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b250,DAT_0800b254);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b258,DAT_0800b25c);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b260,DAT_0800b264);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar2,uVar4);\n    uVar2 = (undefined4)((ulonglong)uVar9 >> 0x20);\n    uVar10 = __muldf3(uVar3,uVar5,DAT_0800b268,DAT_0800b26c);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b270,DAT_0800b274);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b278,DAT_0800b27c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b280,DAT_0800b284);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b288,DAT_0800b28c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar3 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    if (iVar7 == -1) {\n      uVar9 = __aeabi_dadd((int)uVar9,uVar2,(int)uVar10,uVar3);\n      uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),in_r0,uVar11);\n      dVar8 = (double)__subdf3(in_r0,uVar11,(int)uVar9,(int)((ulonglong)uVar9 >> 0x20));\n      return dVar8;\n    }\n    uVar9 = __aeabi_dadd((int)uVar9,uVar2,(int)uVar10,uVar3);\n    puVar1 = PTR_FUNC_0800af78hi_0800b2b0;\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),in_r0,uVar11);\n    uVar9 = __subdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),\n                     *(undefined4 *)(PTR_FUNC_0800af78lo_0800b2b4 + iVar7 * 8),\n                     *(undefined4 *)((int)(PTR_FUNC_0800af78lo_0800b2b4 + iVar7 * 8) + 4));\n    uVar9 = __subdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),in_r0,uVar11);\n    in_d0 = (double)__subdf3(*(undefined4 *)(puVar1 + iVar7 * 8),\n                             *(undefined4 *)((int)(puVar1 + iVar7 * 8) + 4),(int)uVar9,\n                             (int)((ulonglong)uVar9 >> 0x20));\n    if ((int)in_r1 < 0) {\n      return in_d0;\n    }\n  }\n  return in_d0;\n}\n\n",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "__muldf3",
                "fabs",
                "__subdf3",
                "__divdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800af78",
            "calling": [
                "__ieee754_atan2"
            ],
            "imported": false,
            "current_name": "FUNC_0800af78"
        },
        "FUN_08005b20": {
            "renaming": {
                "FUN_08005b20": "clear_least_significant_bit_of_second_uint_in_dat_08005b38_08005b20",
                "DAT_08005b38": "dat_08005b38",
                "PTR_080482e0": "ptr_080482e0"
            },
            "code": "void clear_least_significant_bit_of_second_uint_in_dat_08005b38_08005b20(void)\n{\n  uint* second_uint_ptr = (uint*)(DAT_08005b38 + 4);\n  *second_uint_ptr &= 0xFFFFFFFE;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b20",
            "calling": [],
            "imported": false,
            "current_name": "clear_least_significant_bit_of_second_uint_in_dat_08005b38_08005b20"
        },
        "FUN_08007d08": {
            "renaming": {
                "FUN_08007d08": "initialize_timer_08007d08",
                "pTVar1": "timer",
                "TIMx": "timer_instance",
                "DAT_08007d9c": "timer_instance",
                "DAT_08007da4": "timer_prescaler_value",
                "PTR_SystemCoreClock_08007da0": "system_core_clock_pointer"
            },
            "code": "void initialize_timer_08007d08(void)\n{\n  TIM_TypeDef *timer;\n  timer = DAT_08007d9c;\n  enable_timer_clock(DAT_08007d9c);\n  timer->control_register_1 = 0x80;\n  timer->control_register_2 = 0;\n  timer->slave_mode_control_register = 0;\n  timer->DMA_interrupt_enable_register = 0;\n  timer->status_register = 0;\n  timer->capture_compare_mode_register_1 = 0x6800;\n  timer->capture_compare_mode_register_2 = 0;\n  timer->capture_compare_enable_register = 0;\n  timer->counter = 0;\n  timer->prescaler = (uint)((ulonglong)DAT_08007da4 * (ulonglong)*(uint *)PTR_SystemCoreClock_08007da0 >> 0x35) - 1;\n  timer->auto_reload_register = 199;\n  timer->capture_compare_register_1 = 0;\n  timer->capture_compare_register_2 = 100;\n  timer->capture_compare_register_3 = 0;\n  timer->capture_compare_register_4 = 0;\n  timer->DMA_control_register = 0;\n  timer->DMA_address_for_full_transfer = 0;\n  timer->event_generation_register = 1;\n  return;\n}",
            "called": [
                "enable_tim_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007d08",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007d08"
        },
        "FUN_080091fc": {
            "renaming": {
                "FUN_080091fc": "compare_floats_080091fc",
                "param_1": "first_float",
                "param_2": "second_float"
            },
            "code": "void compare_floats_080091fc(float first_float, float second_float) {\n  __aeabi_cfcmpeq(second_float, first_float);\n  return;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091fc",
            "calling": [
                "__aeabi_fcmpge",
                "__aeabi_fcmpgt"
            ],
            "imported": false,
            "current_name": "compare_floats_080091fc"
        },
        "FUN_080058a0": {
            "renaming": {
                "FUN_080058a0": "plan_cycle_reinitialize_080058a0",
                "PTR_current_block_080058f0": "current_block",
                "PTR_sys_080058fc": "sys",
                "PTR_st_080058f4": "st",
                "DAT_080058f8": "sys[0]"
            },
            "code": "void plan_cycle_reinitialize_080058a0(int cycle_time_difference) {\n  if (*(int *)PTR_current_block_080058f0 == 0) {\n    PTR_sys_080058fc[1] = 0;\n  }\n  else {\n    plan_cycle_reinitialize_080058a0(cycle_time_difference);\n    *(undefined4 *)(PTR_st_080058f4 + 0x1c) = 0;\n    set_PTR_st_080058f4ep_events_per_minute(*(uint32_t *)(PTR_st_080058f4 + 0x1c));\n    *(undefined4 *)(PTR_st_080058f4 + 0x18) = DAT_080058f8;\n    *(undefined4 *)(PTR_st_080058f4 + 0x10) = 0;\n    PTR_sys_080058fc[1] = 2;\n  }\n  return;\n}",
            "called": [
                "plan_cycle_reinitialize",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058a0",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "plan_cycle_reinitialize_080058a0"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "check_parameters_08008a6c",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "xor_result",
                "bVar2": "is_zero_first",
                "bVar3": "is_fourth_smaller"
            },
            "code": "uint check_parameters_08008a6c(uint first_param, uint second_param, uint third_param, uint fourth_param)\n{\n  uint result;\n  bool is_negative_first = ((int)(second_param << 1) >> 0x15 == -1);\n  bool is_negative_second = ((int)(fourth_param << 1) >> 0x15 == -1);\n  if ((is_negative_first || is_negative_second) && ((is_negative_first && ((first_param | second_param << 0xc) != 0)) || ((is_negative_second && ((third_param | fourth_param << 0xc) != 0)))) {\n    return 1;\n  }\n  bool is_zero_first = (first_param | second_param << 1) == 0;\n  bool is_zero_second = (third_param | fourth_param << 1) == 0;\n  if (!is_zero_first && !is_zero_second) {\n    bool is_equal_second = second_param == fourth_param;\n    bool is_equal_first = first_param == third_param;\n    if (!is_equal_second && !is_equal_first) {\n      uint xor_result = second_param ^ fourth_param;\n      bool is_xor_zero = (xor_result == 0);\n      if (-1 < (int)xor_result) {\n        is_xor_zero = (second_param == fourth_param);\n      }\n      bool is_fourth_smaller = (-1 < (int)xor_result && fourth_param <= second_param);\n      if (is_xor_zero) {\n        is_fourth_smaller = (third_param <= first_param);\n      }\n      int shift_right = (int)fourth_param >> 0x1f;\n      if (!is_fourth_smaller) {\n        shift_right = ~shift_right;\n      }\n      result = shift_right | 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = is_zero_first && is_zero_second;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [],
            "imported": false,
            "current_name": "check_parameters_08008a6c"
        },
        "FUN_080036c6": {
            "renaming": {
                "FUN_080036c6": "print_string_080036c6",
                "s": "string_to_print",
                "local_c": "byte_ptr"
            },
            "code": "void print_string_080036c6(char *string_to_print)\n{\n  uint8_t *byte_ptr;\n  byte_ptr = (uint8_t *)string_to_print;\n  while (*byte_ptr != '\\0') {\n    serial_write(*byte_ptr);\n    byte_ptr++;\n  }\n  return;\n}",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036c6",
            "calling": [
                "report_feedback_message",
                "report_init_message",
                "report_alarm_message",
                "report_grbl_help",
                "report_realtime_status",
                "report_gcode_parameters",
                "report_status_message",
                "report_grbl_settings",
                "report_startup_line",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "print_string_080036c6"
        },
        "FUN_08008190": {
            "renaming": {
                "FUN_08008190": "initialize_usart_08008190",
                "usart_00": "usart_ptr",
                "usart": "usart",
                "val": "val"
            },
            "code": "void initialize_usart_08008190(void)\n{\n  USART_TypeDef *usart_ptr;\n  uint32_t val;\n  USART_TypeDef *usart;\n  \n  usart_ptr = DAT_08008240;\n  enable_usart_clock(usart_ptr);\n  usart_ptr->CR1 &= ~USART_CR1_OVER8;\n  usart_ptr->CR1 &= ~USART_CR1_M;\n  usart_ptr->CR1 |= USART_CR1_TE | USART_CR1_RE;\n  usart_ptr->CR2 &= ~USART_CR2_STOP;\n  usart_ptr->CR3 &= ~USART_CR3_CTSE & ~USART_CR3_RTSE;\n  usart_ptr->SR &= ~USART_SR_CTS & ~USART_SR_LBD & ~USART_SR_TC & ~USART_SR_RXNE & ~USART_SR_TXE;\n  set_baud_rate(usart_ptr, 0x1c200);\n  usart_ptr->GTPR = 0x0;\n  usart_ptr->CR1 |= USART_CR1_UE;\n  return;\n}",
            "called": [
                "enable_usart_clock",
                "set_baud_rate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008190",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_usart_08008190"
        },
        "FUN_080074c8": {
            "renaming": {
                "FUN_080074c8": "handle_bits_080074c8",
                "bits": "bits",
                "PTR_limits_enabled_08007518": "PTR_limits_enabled_08007518",
                "PTR_buttons_enabled_0800751c": "PTR_buttons_enabled_0800751c",
                "gpio_set": "gpio_set",
                "limits_isr": "handle_limits_isr",
                "buttons_isr": "handle_buttons_isr"
            },
            "code": "void handle_bits_080074c8(uint32_t bits)\n{\n    bool is_bit_set = (bits & 1) != 0;\n    bool are_limits_enabled = *(int *)PTR_limits_enabled_08007518 != 0;\n    bool are_buttons_enabled = *(int *)PTR_buttons_enabled_0800751c != 0;\n\n    if (is_bit_set) {\n        gpio_set(0x3e);\n    }\n\n    if (are_limits_enabled && ((bits & 0x1e) != 0)) {\n        handle_limits_isr();\n    }\n\n    if (are_buttons_enabled && ((bits & 0x80) != 0)) {\n        handle_buttons_isr(bits);\n    }\n}",
            "called": [
                "buttons_isr",
                "limits_isr",
                "gpio_set"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074c8",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "handle_bits_080074c8"
        },
        "FUN_0800b430": {
            "renaming": {
                "FUN_0800b430": "replace_chars_with_c_0800b430",
                "__s": "string",
                "__c": "c",
                "__n": "length",
                "uVar1": "uint1",
                "puVar2": "ptr1",
                "puVar3": "ptr2",
                "puVar4": "ptr3",
                "uVar5": "uint5",
                "bVar6": "is_length_zero"
            },
            "code": "void * replace_chars_with_c_0800b430(void *string, int c, size_t length) {\n  uint uVar1;\n  uint *ptr1;\n  uint *ptr2;\n  uint *ptr3;\n  uint uVar5;\n  bool is_length_zero;\n  ptr1 = (uint *)string;\n  if (((uint)string & 3) != 0) {\n    uVar5 = length - 1;\n    ptr2 = (uint *)string;\n    if (length == 0) {\n      return string;\n    }\n    while (true) {\n      ptr1 = (uint *)((int)ptr2 + 1);\n      *(char *)ptr2 = (char)c;\n      length = uVar5;\n      if (((uint)ptr1 & 3) == 0) {\n        break;\n      }\n      is_length_zero = uVar5 == 0;\n      uVar5 = uVar5 - 1;\n      ptr2 = ptr1;\n      if (is_length_zero) {\n        return string;\n      }\n    }\n  }\n  if (3 < length) {\n    uVar5 = c & 0xffU | (c & 0xffU) << 8;\n    uVar5 = uVar5 | uVar5 << 0x10;\n    if (0xf < length) {\n      ptr2 = ptr1 + 4;\n      do {\n        ptr2[-4] = uVar5;\n        ptr2[-3] = uVar5;\n        ptr2[-2] = uVar5;\n        ptr2[-1] = uVar5;\n        ptr2 = ptr2 + 4;\n      } while (ptr2 != (uint *)((int)ptr1 + (length - 0x10 & 0xfffffff0) + 0x20));\n      uVar1 = length & 0xc;\n      ptr1 = ptr1 + ((length - 0x10 >> 4) + 1) * 4;\n      length = length & 0xf;\n      if (uVar1 == 0) {\n        goto end_of_function;\n      }\n    }\n    ptr2 = (uint *)((length - 4 & 0xfffffffc) + 4 + (int)ptr1);\n    do {\n      ptr3 = ptr1 + 1;\n      *ptr1 = uVar5;\n      ptr1 = ptr3;\n    } while (ptr2 != ptr3);\n    length = length & 3;\n    ptr1 = ptr2;\n  }\nend_of_function:\n  if (length != 0) {\n    ptr2 = ptr1;\n    do {\n      ptr3 = (uint *)((int)ptr2 + 1);\n      *(char *)ptr2 = (char)c;\n      ptr2 = ptr3;\n    } while ((uint *)(length + (int)ptr1) != ptr3);\n  }\n  return string;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b430",
            "calling": [
                "settings_read_coord_data",
                "homing_cycle",
                "mc_go_home",
                "gc_init",
                "grbl_main",
                "eeprom_init",
                "debounce_init",
                "plan_init",
                "gc_execute_line",
                "st_reset"
            ],
            "imported": false,
            "current_name": "replace_chars_with_c_0800b430"
        },
        "FUN_08004030": {
            "renaming": {
                "FUN_08004030": "print_error_message_08004030",
                "status_code": "error_code",
                "PTR__etext_08004108": "error_message_table[0]",
                "PTR_s_error__0800410c": "error_message_header",
                "PTR_s_Bad_number_format_08004110": "error_message_table[1]",
                "PTR_s_Expected_command_letter_08004114": "error_message_table[2]",
                "PTR_s_Unsupported_statement_08004118": "error_message_table[3]",
                "PTR_s_Invalid_radius_0800411c": "error_message_table[4]",
                "PTR_s_Modal_group_violation_08004120": "error_message_table[5]",
                "PTR_s_Invalid_statement_08004124": "error_message_table[6]",
                "PTR_s_Setting_disabled_08004128": "error_message_table[7]",
                "PTR_s_Value___0_0_0800412c": "error_message_table[8]",
                "PTR_s_Value___3_usec_08004130": "error_message_table[9]",
                "PTR_s_EEPROM_read_fail__Using_defaults_08004134": "error_message_table[10]",
                "PTR_s_Busy_or_queued_08004138": "error_message_table[11]",
                "PTR_s_Alarm_lock_0800413c": "error_message_table[12]",
                "PTR_s_Line_overflow_08004140": "error_message_table[13]",
                "PTR_DAT_08004144": "error_message_footer"
            },
            "code": "void print_error_message_08004030(uint8_t error_code)\n{\n    if (error_code == '\\0') {\n        printPgmString(PTR__etext_08004108);\n    }\n    else {\n        printPgmString(PTR_s_error__0800410c);\n        switch(error_code) {\n        case ERROR_BAD_NUMBER_FORMAT:\n            printPgmString(PTR_s_Bad_number_format_08004110);\n            break;\n        case ERROR_EXPECTED_COMMAND_LETTER:\n            printPgmString(PTR_s_Expected_command_letter_08004114);\n            break;\n        case ERROR_UNSUPPORTED_STATEMENT:\n            printPgmString(PTR_s_Unsupported_statement_08004118);\n            break;\n        case ERROR_INVALID_RADIUS:\n            printPgmString(PTR_s_Invalid_radius_0800411c);\n            break;\n        case ERROR_MODAL_GROUP_VIOLATION:\n            printPgmString(PTR_s_Modal_group_violation_08004120);\n            break;\n        case ERROR_INVALID_STATEMENT:\n            printPgmString(PTR_s_Invalid_statement_08004124);\n            break;\n        case ERROR_SETTING_DISABLED:\n            printPgmString(PTR_s_Setting_disabled_08004128);\n            break;\n        case ERROR_VALUE_0_0:\n            printPgmString(PTR_s_Value___0_0_0800412c);\n            break;\n        case ERROR_VALUE_3_USEC:\n            printPgmString(PTR_s_Value___3_usec_08004130);\n            break;\n        case ERROR_EEPROM_READ_FAIL:\n            printPgmString(PTR_s_EEPROM_read_fail__Using_defaults_08004134);\n            break;\n        case ERROR_BUSY_OR_QUEUED:\n            printPgmString(PTR_s_Busy_or_queued_08004138);\n            break;\n        case ERROR_ALARM_LOCK:\n            printPgmString(PTR_s_Alarm_lock_0800413c);\n            break;\n        case ERROR_LINE_OVERFLOW:\n            printPgmString(PTR_s_Line_overflow_08004140);\n        }\n        printPgmString(PTR_DAT_08004144);\n    }\n    return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004030",
            "calling": [
                "protocol_execute_line",
                "gc_init",
                "report_gcode_parameters",
                "protocol_execute_startup",
                "protocol_process",
                "settings_init"
            ],
            "imported": false,
            "current_name": "print_error_message_08004030"
        },
        "FUN_08005360": {
            "renaming": {
                "FUN_08005360": "calculate_result_08005360",
                "PTR_st_08005398": "pointer_st",
                "DAT_0800539c": "max_value",
                "uVar1": "max_value",
                "uVar2": "current_value"
            },
            "code": "int calculate_result_08005360(void)\n{\n  int sum = *(int *)(PTR_st_08005398 + 0x14) + *(int *)(PTR_st_08005398 + 0x18);\n  uint DAT_0800539c = DAT_0800539c;\n  uint current_value = *(uint *)(PTR_st_08005398 + 0x18);\n  if (DAT_0800539c < current_value) {\n    sum -= 420000;\n  }\n  return (uint)(DAT_0800539c < current_value);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005360",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "calculate_result_08005360"
        },
        "FUN_08003980": {
            "renaming": {
                "FUN_08003980": "reset_char_counter_and_comment_flag_08003980",
                "*PTR_char_counter_08003998": "char_counter",
                "*PTR_iscomment_0800399c": "is_comment"
            },
            "code": "void reset_char_counter_and_comment_flag_08003980(void)\n{\n  **PTR_char_counter_08003998 = 0;\n  **PTR_iscomment_0800399c = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003980",
            "calling": [
                "protocol_init",
                "protocol_process"
            ],
            "imported": false,
            "current_name": "reset_char_counter_and_comment_flag_08003980"
        },
        "FUN_08006de0": {
            "renaming": {
                "FUN_08006de0": "get_pending_interrupt_08006de0",
                "IRQn": "irq",
                "uVar1": "pending_irq"
            },
            "code": "uint32_t get_pending_interrupt_08006de0(IRQn_Type irq)\n{\n  uint32_t pending_irq = NVIC_GetPendingIRQ(irq);\n  return pending_irq;\n}",
            "called": [
                "NVIC_GetPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006de0",
            "calling": [],
            "imported": false,
            "current_name": "get_pending_interrupt_08006de0"
        },
        "FUN_08007540": {
            "renaming": {
                "FUN_08007540": "initialize_grbl_08007540",
                "gpio_init": "initialize_gpio",
                "timers_init": "initialize_timers",
                "debounce_init": "initialize_debounce",
                "usart_init": "initialize_usart",
                "grbl_FUN_08007540": "execute_grbl"
            },
            "code": "int initialize_grbl_08007540(void)\n{\n  HAL_Init();\n  SystemClock_Config();\n  initialize_gpio();\n  initialize_timers();\n  initialize_debounce();\n  initialize_usart();\n  start_forkserver(0);\n  execute_grbl();\n  return 0;\n}",
            "called": [
                "grbl_main",
                "timers_init",
                "gpio_init",
                "HAL_Init",
                "debounce_init",
                "SystemClock_Config",
                "startForkserver",
                "usart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007540",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_grbl_08007540"
        },
        "FUN_080052dc": {
            "renaming": {
                "FUN_080052dc": "update_value_at_address_080052dc",
                "x": "new_value",
                "*(uint32_t *)(DAT_08005308 + 0x14)": "address_to_update",
                "*(uint *)(DAT_08005308 + 0x14)": "current_value_at_address",
                "0xfffff55f": "mask",
                "x | *(uint *)(DAT_08005308 + 0x14) & 0xfffff55f": "new_value_with_mask",
                "val": "updated_value"
            },
            "code": "void update_value_at_address_080052dc(uint32_t new_value)\n{\n  uint32_t* *(uint32_t *)(DAT_08005308 + 0x14) = (uint32_t*)(DAT_08005308 + 0x14);\n  uint32_t *(uint *)(DAT_08005308 + 0x14) = *(uint32_t *)(*(uint32_t *)(DAT_08005308 + 0x14));\n  uint32_t mask = 0xfffff55f;\n  uint32_t updated_value = new_value | (*(uint *)(DAT_08005308 + 0x14) & mask);\n  **(uint32_t *)(DAT_08005308 + 0x14) = updated_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052dc",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_value_at_address_080052dc"
        },
        "FUN_080064ec": {
            "renaming": {
                "FUN_080064ec": "calculate_sys_clock_frequency_080064ec",
                "pllp": "pll_p_divisor",
                "pllm": "pll_m_divisor",
                "sysclockfreq": "sys_clock_frequency",
                "pllvco": "pll_vco_freq",
                "result_6": "reg_6",
                "result_7": "reg_7",
                "result_4": "reg_4",
                "result_5": "reg_5",
                "result_2": "reg_2",
                "result_3": "reg_3",
                "result": "reg_1",
                "result_1": "reg_0",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "pll_divisor": "pll_divisor",
                "pll_mul_factor": "pll_mul_factor",
                "pll_input_freq_divisor": "pll_input_freq_divisor",
                "pll_div_factor": "pll_div_factor",
                "leading_zeroes": "leading_zeroes",
                "pll_config": "pll_config"
            },
            "code": "uint32_t calculate_sys_clock_frequency_080064ec(void)\n{\n  uint32_t pllp;\n  uint32_t pllm;\n  uint32_t sys_clock_frequency;\n  uint32_t pllvco;\n  uint32_t reg_6;\n  uint32_t reg_7;\n  uint32_t reg_4;\n  uint32_t reg_5;\n  uint32_t reg_2;\n  uint32_t reg_3;\n  uint32_t reg_1;\n  uint32_t reg_0;\n  uint32_t pll_divisor;\n  uint32_t pll_mul_factor;\n  uint32_t pll_input_freq_divisor;\n  uint32_t pll_vco_freq;\n\n  uint32_t pll_config = *(uint *)(DAT_0800661c + 8);\n\n  if (pll_config == 8) {\n    uint32_t pll_div_factor = *(uint *)(DAT_0800661c + 4) & 0x3f;\n    uint32_t leading_zeroes = count_leading_zeroes(0x200);\n    if ((*(uint *)(DAT_0800661c + 4) & 0x400000) >> (leading_zeroes & 0xff) == 0) {\n      leading_zeroes = count_leading_zeroes(0x3fe0000);\n      pll_mul_factor = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (leading_zeroes & 0xff)) * (DAT_08006620 / pll_div_factor);\n    }\n    else {\n      leading_zeroes = count_leading_zeroes(0x3fe0000);\n      pll_mul_factor = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (leading_zeroes & 0xff)) * (DAT_08006624 / pll_div_factor);\n    }\n    leading_zeroes = count_leading_zeroes(0xc000);\n    pll_divisor = (((*(uint *)(DAT_0800661c + 4) & 0x30000) >> (leading_zeroes & 0xff)) + 1) * 2;\n    pll_vco_freq = pll_mul_factor / pll_divisor;\n  }\n  else if (pll_config < 9) {\n    if (pll_config == 0) {\n      pll_vco_freq = DAT_08006620;\n    }\n    else if (pll_config == 4) {\n      pll_vco_freq = DAT_08006624;\n    }\n  }\n  else {\n    pll_vco_freq = DAT_08006620;\n  }\n  pll_input_freq_divisor = *(uint *)(DAT_0800661c + 8) & 0x3;\n  pllm = *(uint *)(DAT_0800661c + 0xc) & 0x7f;\n  pllp = ((*(uint *)(DAT_0800661c + 0xc) & 0x3f80) >> 7) + 1;\n  sys_clock_frequency = (pll_vco_freq / pllm) * pllp / (pll_input_freq_divisor + 1);\n\n  return sys_clock_frequency;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ec",
            "calling": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "imported": false,
            "current_name": "calculate_sys_clock_frequency_080064ec"
        },
        "FUN_08006ba0": {
            "renaming": {
                "FUN_08006ba0": "calculate_priority_bits_08006ba0",
                "PriorityGroup": "priority_group",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "SubPriorityBits": "sub_priority_bits",
                "PreemptPriorityBits": "preempt_priority_bits",
                "PriorityGroupTmp": "priority_group_tmp",
                "uVar1": "priority_group_bits",
                "uVar2": "bits_to_shift"
            },
            "code": "uint32_t calculate_priority_bits_08006ba0(uint32_t priority_group, uint32_t preempt_priority, uint32_t sub_priority)\n{\n  uint32_t sub_priority_bits;\n  uint32_t preempt_priority_bits;\n  uint32_t priority_group_tmp;\n  \n  uint32_t priority_group_bits = priority_group & 0b111;\n  uint32_t bits_to_shift = 7 - priority_group_bits;\n  if (bits_to_shift > 3) {\n    bits_to_shift = 4;\n  }\n  if (priority_group_bits + 4 < 7) {\n    priority_group_bits = 0;\n  }\n  else {\n    priority_group_bits -= 3;\n  }\n  return sub_priority & ((1 << bits_to_shift) - 1) | ((1 << bits_to_shift) - 1 & preempt_priority) << priority_group_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ba0",
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priority_bits_08006ba0"
        },
        "FUN_080003ec": {
            "renaming": {
                "FUN_080003ec": "read_from_eeprom_080003ec",
                "destination": "destination",
                "source": "start_address",
                "size": "size",
                "local_1c": "remaining_size",
                "local_18": "current_address",
                "local_14": "current_destination",
                "data": "data",
                "checksum": "checksum"
            },
            "code": "int read_from_eeprom_080003ec(char *destination, uint start_address, uint size) {\n  char current_char;\n  uint remaining_size = size;\n  uint current_address = start_address;\n  char *current_destination = destination;\n  uchar checksum = 0;\n  uchar data;\n  if (*(int *)PTR_eeprom_ready_08000470 == 0) {\n    eeprom_init();\n    current_address = start_address;\n    current_destination = destination;\n  }\n  for (; remaining_size != 0; remaining_size--) {\n    current_char = eeprom_get_char(current_address);\n    checksum = current_char + (checksum != 0);\n    *current_destination = current_char;\n    current_address++;\n    current_destination++;\n  }\n  current_char = eeprom_get_char(current_address);\n  return (uint)((uint)checksum == (int)current_char);\n}",
            "called": [
                "eeprom_get_char",
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003ec",
            "calling": [
                "settings_read_coord_data",
                "read_global_settings",
                "settings_read_startup_line"
            ],
            "imported": false,
            "current_name": "read_from_eeprom_080003ec"
        },
        "FUN_08002896": {
            "renaming": {
                "FUN_08002896": "calculate_block_offset_08002896",
                "block_index": "block_index",
                "local_9": "offset"
            },
            "code": "uint8_t calculate_block_offset_08002896(uint8_t block_index) {\n  uint8_t offset;\n  if (block_index == 0x00) {\n    offset = 0x12;\n  }\n  else {\n    offset = block_index;\n  }\n  return offset + 0xff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002896",
            "calling": [
                "planner_reverse_pass"
            ],
            "imported": false,
            "current_name": "calculate_block_offset_08002896"
        },
        "FUN_0800a348": {
            "renaming": {
                "FUN_0800a348": "FUNC_0800a348"
            },
            "code": "\nundefined4 FUNC_0800a348(undefined4 param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  longlong lVar8;\n  undefined4 local_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  \n  uVar4 = param_2 & 0x7fffffff;\n  if (uVar4 < 0x3e400000) {\n    iVar1 = __aeabi_d2iz();\n    if (iVar1 == 0) {\n      return 0;\n    }\n    uVar5 = __muldf3(param_1,param_2,param_1,param_2);\n    uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);\n    uVar2 = (undefined4)uVar5;\n    uVar6 = __muldf3(uVar2,uVar3,DAT_0800a558,DAT_0800a55c);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a560,DAT_0800a564);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a570,DAT_0800a574);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a580,DAT_0800a584);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n  }\n  else {\n    uVar5 = __muldf3(param_1,param_2,param_1,param_2);\n    uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);\n    uVar2 = (undefined4)uVar5;\n    uVar6 = __muldf3(uVar2,uVar3,DAT_0800a558,DAT_0800a55c);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a560,DAT_0800a564);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a570,DAT_0800a574);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a580,DAT_0800a584);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    if (DAT_0800a590 < (int)uVar4) {\n      if (DAT_0800a594 < (int)uVar4) {\n        lVar8 = (ulonglong)DAT_0800a598 << 0x20;\n        iVar1 = DAT_0800a59c;\n      }\n      else {\n        lVar8 = __subdf3(0,DAT_0800a58c,0,uVar4 - 0x200000);\n        iVar1 = uVar4 - 0x200000;\n      }\n      uStack_24 = (undefined4)((ulonglong)lVar8 >> 0x20);\n      local_28 = (undefined4)lVar8;\n      uVar5 = __muldf3(uVar2,uVar3,0,DAT_0800a588);\n      uVar5 = __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0,iVar1);\n      uVar6 = __muldf3(uVar2,uVar3,(int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n      uVar7 = __muldf3(param_1,param_2,param_3,param_4);\n      uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                       (int)((ulonglong)uVar7 >> 0x20));\n      uVar5 = __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),(int)uVar6,\n                       (int)((ulonglong)uVar6 >> 0x20));\n      uVar2 = __subdf3(local_28,uStack_24,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n      return uVar2;\n    }\n  }\n  uStack_2c = (undefined4)((ulonglong)uVar6 >> 0x20);\n  local_30 = (undefined4)uVar6;\n  uVar2 = (undefined4)((ulonglong)uVar5 >> 0x20);\n  uVar6 = __muldf3((int)uVar5,uVar2,0,DAT_0800a588);\n  uVar5 = __muldf3((int)uVar5,uVar2,local_30,uStack_2c);\n  uVar7 = __muldf3(param_1,param_2,param_3,param_4);\n  uVar5 = __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),(int)uVar7,\n                   (int)((ulonglong)uVar7 >> 0x20));\n  uVar5 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar5,\n                   (int)((ulonglong)uVar5 >> 0x20));\n  uVar2 = __subdf3(0,DAT_0800a58c,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n  return uVar2;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800a348",
            "calling": [
                "sin",
                "cos"
            ],
            "imported": false,
            "current_name": "FUNC_0800a348"
        },
        "FUN_080001ac": {
            "renaming": {
                "FUN_080001ac": "concatenate_080001ac",
                "param_1": "first_half",
                "param_2": "second_half",
                "DAT_080001bc": "constant",
                "PTR__init_080001c4": "init_pointer",
                "PTR_object_8916_080001c0": "object_pointer"
            },
            "code": "typedef unsigned long long uint64_t;\n\nuint64_t concatenate_080001ac(uint64_t param_1, uint64_t param_2)\n{\n  if (DAT_080001bc != 0) {\n    param_1 = PTR__init_080001c4;\n    param_2 = PTR_object_8916_080001c0;\n  }\n  return ((uint64_t)param_2 << 32) | param_1;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ac",
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "concatenate_080001ac"
        },
        "FUN_08003740": {
            "renaming": {
                "FUN_08003740": "print_binary_08003740",
                "n": "number"
            },
            "code": "void print_binary_08003740(uint8_t number)\n{\n    print_base2((uint)number, 8);\n    return;\n}",
            "called": [
                "print_base2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003740",
            "calling": [],
            "imported": false,
            "current_name": "print_binary_08003740"
        },
        "FUN_08000478": {
            "renaming": {
                "FUN_08000478": "set_axis_values_08000478",
                "axis_0": "x_axis",
                "axis_1": "y_axis",
                "axis_2": "z_axis"
            },
            "code": "void set_axis_values_08000478(uint8_t x_axis, uint8_t y_axis, uint8_t z_axis) {\n\tPTR_gc_080004a8[25] = x_axis;\n\tPTR_gc_080004a8[26] = y_axis;\n\tPTR_gc_080004a8[27] = z_axis;\n\treturn;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000478",
            "calling": [
                "gc_init",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "set_axis_values_08000478"
        },
        "FUN_08006d2e": {
            "renaming": {
                "FUN_08006d2e": "enable_interrupt_08006d2e",
                "IRQn": "irq",
                "NVIC_EnableIRQ": "NVIC_EnableIRQ"
            },
            "code": "void enable_interrupt_08006d2e(IRQn_Type irq)\n{\n  NVIC_EnableIRQ(irq);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d2e",
            "calling": [],
            "imported": false,
            "current_name": "enable_interrupt_08006d2e"
        },
        "FUN_08007e1c": {
            "renaming": {
                "FUN_08007e1c": "wait_until_usart_ready_08007e1c",
                "c": "data"
            },
            "code": "void wait_until_usart_ready_08007e1c(USART_TypeDef *usart, uint8_t data) {\n  while((*DAT_08007e48 & 0x80) == 0);\n  DAT_08007e48[1] = (uint)(byte)data;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e1c",
            "calling": [
                "__io_putchar",
                "serial_write"
            ],
            "imported": false,
            "current_name": "wait_until_usart_ready_08007e1c"
        },
        "FUN_0800adf0": {
            "renaming": {
                "FUN_0800adf0": "calculate_new_value_0800adf0",
                "param_1": "base_value",
                "param_2": "multiplier",
                "param_3": "param_3",
                "param_4": "param_4",
                "param_5": "param_5",
                "iVar1": "temp_value",
                "uVar2": "lower_32_bits",
                "uVar3": "upper_32_bits",
                "uVar4": "temp_32_bits_2",
                "uVar5": "temp_32_bits_1",
                "uVar6": "temp_32_bits_6",
                "uVar7": "temp_64_bits_1",
                "uVar8": "temp_64_bits_2"
            },
            "code": "undefined4 calculate_new_value_0800adf0(undefined4 base_value, uint multiplier, undefined4 param_3, undefined4 param_4, int param_5)\n{\n    int temp_value;\n    undefined4 upper_32_bits, lower_32_bits, temp_32_bits_1, temp_32_bits_2, temp_32_bits_3, temp_32_bits_4, temp_32_bits_5, temp_32_bits_6;\n    undefined8 temp_64_bits_1, temp_64_bits_2;\n    \n    if (((multiplier & 0x7fffffff) < 0x3e400000) && (temp_value = __aeabi_d2iz(), temp_value == 0)) {\n        return base_value;\n    }\n    \n    temp_64_bits_1 = __muldf3(base_value, multiplier, base_value);\n    upper_32_bits = (undefined4)((ulonglong)temp_64_bits_1 >> 0x20);\n    lower_32_bits = (undefined4)temp_64_bits_1;\n    temp_64_bits_1 = __muldf3(base_value, multiplier, lower_32_bits, upper_32_bits);\n    temp_32_bits_2 = (undefined4)((ulonglong)temp_64_bits_1 >> 0x20);\n    temp_32_bits_1 = (undefined4)temp_64_bits_1;\n    temp_64_bits_1 = __muldf3(lower_32_bits, upper_32_bits, DAT_0800af40, DAT_0800af44);\n    temp_64_bits_1 = __subdf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), DAT_0800af48, DAT_0800af4c);\n    temp_64_bits_1 = __muldf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), lower_32_bits, upper_32_bits);\n    temp_64_bits_1 = __aeabi_dadd((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), DAT_0800af50, DAT_0800af54);\n    temp_64_bits_1 = __muldf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), lower_32_bits, upper_32_bits);\n    temp_64_bits_1 = __subdf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), DAT_0800af58, DAT_0800af5c);\n    temp_64_bits_1 = __muldf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), lower_32_bits, upper_32_bits);\n    temp_64_bits_1 = __aeabi_dadd((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), DAT_0800af60, DAT_0800af64);\n    temp_32_bits_6 = (undefined4)((ulonglong)temp_64_bits_1 >> 0x20);\n    \n    if (param_5 != 0) {\n        temp_64_bits_2 = __muldf3(param_3, param_4, 0, DAT_0800af70);\n        temp_64_bits_1 = __muldf3(temp_32_bits_1, temp_32_bits_2, (int)temp_64_bits_1, temp_32_bits_6);\n        temp_64_bits_1 = __subdf3((int)temp_64_bits_2, (int)((ulonglong)temp_64_bits_2 >> 0x20), (int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20));\n        temp_64_bits_1 = __muldf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), lower_32_bits, upper_32_bits);\n        temp_64_bits_1 = __subdf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), param_3, param_4);\n        temp_64_bits_2 = __muldf3(temp_32_bits_1, temp_32_bits_2, DAT_0800af68, DAT_0800af6c);\n        temp_64_bits_1 = __aeabi_dadd((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), (int)temp_64_bits_2, (int)((ulonglong)temp_64_bits_2 >> 0x20));\n        lower_32_bits = __subdf3(base_value, multiplier, (int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20));\n        return lower_32_bits;\n    }\n    \n    temp_64_bits_1 = __muldf3(lower_32_bits, upper_32_bits, (int)temp_64_bits_1, temp_32_bits_6);\n    temp_64_bits_1 = __subdf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), DAT_0800af68, DAT_0800af6c);\n    temp_64_bits_1 = __muldf3((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), temp_32_bits_1, temp_32_bits_2);\n    lower_32_bits = __aeabi_dadd((int)temp_64_bits_1, (int)((ulonglong)temp_64_bits_1 >> 0x20), base_value, multiplier);\n    return lower_32_bits;\n}",
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800adf0",
            "calling": [
                "sin",
                "cos"
            ],
            "imported": false,
            "current_name": "calculate_new_value_0800adf0"
        },
        "FUN_08003a74": {
            "renaming": {
                "FUN_08003a74": "execute_runtime_task_08003a74",
                "bVar1": "task_status",
                "rt_exec": "runtime_task"
            },
            "code": "void execute_runtime_task_08003a74(void)\\n{\\n  byte task_status;\\n  uint8_t runtime_task;\\n  \\n  if (PTR_sys_08003b90[2] != \"\\0\") {\\n    task_status = PTR_sys_08003b90[2];\\n    if ((task_status & 0x60) != 0) {\\n      PTR_sys_08003b90[1] = 6;\\n      if ((task_status & 0x40) == 0) {\\n        report_alarm_message(-2);\\n      }\\n      else {\\n        report_alarm_message(-1);\\n        report_feedback_message(\"\\x01\");\\n        PTR_sys_08003b90[2] = task_status & 0xef;\\n        do {\\n        } while ((PTR_sys_08003b90[2] & 0x10) == 0);\\n      }\\n      PTR_sys_08003b90[2] = task_status & 0x9f;\\n    }\\n    if ((task_status & 0x10) == 0) {\\n      if ((task_status & 1) != 0) {\\n        report_realtime_status();\\n        PTR_sys_08003b90[2] = task_status & 0xfe;\\n      }\\n      if ((task_status & 8) != 0) {\\n        st_feed_hold();\\n        PTR_sys_08003b90[2] = task_status & 0xf7;\\n      }\\n      if ((task_status & 4) != 0) {\\n        st_cycle_reinitialize();\\n        PTR_sys_08003b90[2] = task_status & 0xfb;\\n      }\\n      if ((task_status & 2) != 0) {\\n        st_cycle_start();\\n        if ((PTR_settings_08003b94[0x28] & 2) != 0) {\\n          PTR_sys_08003b90[0x10] = 1;\\n        }\\n        PTR_sys_08003b90[2] = task_status & 0xfd;\\n      }\\n    }\\n    else {\\n      *PTR_sys_08003b90 = 1;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "report_feedback_message",
                "st_feed_hold",
                "report_alarm_message",
                "report_realtime_status",
                "st_cycle_reinitialize",
                "st_cycle_start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a74",
            "calling": [
                "plan_synchronize",
                "mc_go_home",
                "grbl_main",
                "mc_dwell",
                "mc_line",
                "protocol_process"
            ],
            "imported": false,
            "current_name": "execute_runtime_task_08003a74"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "FUNC_08005cec"
            },
            "code": "\nHAL_StatusTypeDef FUNC_08005cec(RCC_OscInitTypeDef *RCC_OscInitStruct)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  uint32_t timeout;\n  \n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 4) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0x400000)))) {\n      if (((*DAT_08005fac & 0x20000) != 0) && (RCC_OscInitStruct->HSEState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      *DAT_08005fb0 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08005fac & 0x20000) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 5000 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005fb0 = (char)RCC_OscInitStruct->HSEState;\n      if (RCC_OscInitStruct->HSEState == 1) {\n        uVar1 = HAL_GetTick();\n        while ((*DAT_08005fac & 0x20000) == 0) {\n          uVar2 = HAL_GetTick();\n          if (uVar1 + 5000 <= uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar1 = HAL_GetTick();\n        while ((*DAT_08005fac & 0x20000) != 0) {\n          uVar2 = HAL_GetTick();\n          if (uVar1 + 5000 <= uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 0) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0)))) {\n      if (((*DAT_08005fac & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005fb4 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08005fac & 2) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb4 = 1;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08005fac & 2) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      uVar3 = count_leading_zeroes(0x1f000000);\n      *DAT_08005fac =\n           RCC_OscInitStruct->HSICalibrationValue << (uVar3 & 0xff) | *DAT_08005fac & 0xffffff07;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005fb8 = 0;\n      uVar1 = HAL_GetTick();\n      while ((DAT_08005fac[0x1d] & 2) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb8 = 1;\n      uVar1 = HAL_GetTick();\n      while ((DAT_08005fac[0x1d] & 2) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    DAT_08005fac[0x10] = DAT_08005fac[0x10] | 0x10000000;\n    *DAT_08005fbc = *DAT_08005fbc | 0x100;\n    uVar1 = HAL_GetTick();\n    while ((*DAT_08005fbc & 0x100) == 0) {\n      uVar2 = HAL_GetTick();\n      if (uVar1 + 100 <= uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08005fc0 = 0;\n    uVar1 = HAL_GetTick();\n    while ((DAT_08006180[0x1c] & 2) != 0) {\n      uVar2 = HAL_GetTick();\n      if (uVar1 + 5000 <= uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08006184 = (char)RCC_OscInitStruct->LSEState;\n    if (RCC_OscInitStruct->LSEState == 1) {\n      uVar1 = HAL_GetTick();\n      while ((DAT_08006180[0x1c] & 2) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 5000 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar1 = HAL_GetTick();\n      while ((DAT_08006180[0x1c] & 2) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 5000 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->PLL).PLLState != 0) {\n    if ((DAT_08006180[2] & 0xc) == 8) {\n      return HAL_ERROR;\n    }\n    if ((RCC_OscInitStruct->PLL).PLLState == 2) {\n      *DAT_08006188 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      uVar3 = count_leading_zeroes(0x3fe0000);\n      uVar4 = count_leading_zeroes(0xc000);\n      uVar5 = count_leading_zeroes(0xf0);\n      DAT_08006180[1] =\n           (RCC_OscInitStruct->PLL).PLLQ << (uVar5 & 0xff) |\n           (RCC_OscInitStruct->PLL).PLLM | (RCC_OscInitStruct->PLL).PLLN << (uVar3 & 0xff) |\n           ((RCC_OscInitStruct->PLL).PLLP >> 1) - 1 << (uVar4 & 0xff) |\n           (RCC_OscInitStruct->PLL).PLLSource | 0x20000000;\n      *DAT_08006188 = 1;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08006188 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005cec",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_08005cec"
        },
        "FUN_08006b00": {
            "renaming": {
                "FUN_08006b00": "set_interrupt_priority_08006b00",
                "IRQn": "interrupt_number",
                "priority": "priority",
                "WWDG_IRQn": "WWDG_interrupt_number",
                "DAT_08006b4c": "interrupt_priority_base_address",
                "DAT_08006b50": "interrupt_priority_offset"
            },
            "code": "void set_interrupt_priority_08006b00(IRQn_Type interrupt_number, uint32_t priority) {\n  if (interrupt_number < WWDG_IRQn) {\n    *(char *)(((byte)interrupt_number & 0xf) + DAT_08006b4c + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interrupt_number + DAT_08006b50 + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b00",
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08006b00"
        },
        "FUN_0800b4d0": {
            "renaming": {
                "FUN_0800b4d0": "initialize_exit_handler_0800b4d0",
                "DAT_0800b4dc": "exit_handler_initialized",
                "DAT_0800b4e0": "exit_handler"
            },
            "code": "void initialize_exit_handler_0800b4d0(void)\n{\n    if (DAT_0800b4dc != 0) {\n        atexit(DAT_0800b4e0);\n        return;\n    }\n    return;\n}",
            "called": [
                "atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4d0",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_exit_handler_0800b4d0"
        },
        "FUN_08007f54": {
            "renaming": {
                "FUN_08007f54": "calculate_baud_rate_08007f54",
                "usart": "usart_register",
                "baud": "baud_rate",
                "uVar1": "numerator",
                "uVar2": "pclk_frequency",
                "uVar3": "pclk_frequency",
                "uVar4": "pclk_frequency",
                "DAT_08008184": "USART1",
                "DAT_08008188": "USART2",
                "DAT_0800818c": "USART_BRR_SAMPLING16",
                "USART_CR1_UE": "0x8000",
                "USART_BRR_SAMPLING8": "0x10",
                "USART_BRR_SAMPLING16": "0x08"
            },
            "code": "void calculate_baud_rate_08007f54(USART_TypeDef *usart,int baud_rate){\n  ulonglong numerator;\n  uint32_t pclk_frequency;\n  uint32_t mantissa;\n  uint32_t fraction;\n  \n  if ((usart->CR1 & USART_CR1_UE) == 0) {\n    if ((usart == DAT_08008184) || (usart == DAT_08008188)) {\n      pclk_frequency = HAL_RCC_GetPCLK2Freq();\n    }\n    else {\n      pclk_frequency = HAL_RCC_GetPCLK1Freq();\n    }\n    numerator = (ulonglong)DAT_0800818c * ((ulonglong)pclk_frequency << 4) / (ulonglong)(baud_rate << 1);\n    mantissa = numerator >> 28;\n    fraction = (numerator >> 1) & 0x07;\n    fraction |= (numerator & 1) << 3;\n    usart->BRR = (mantissa << 4) | fraction;\n  }\n  else {\n    if ((usart == DAT_08008184) || (usart == DAT_08008188)) {\n      pclk_frequency = HAL_RCC_GetPCLK2Freq();\n    }\n    else {\n      pclk_frequency = HAL_RCC_GetPCLK1Freq();\n    }\n    numerator = (ulonglong)USART_BRR_SAMPLING8 * ((ulonglong)pclk_frequency << 4) / (ulonglong)baud_rate;\n    mantissa = numerator >> 28;\n    fraction = (numerator >> 1) & 0x07;\n    fraction |= (numerator & 1) << 3;\n    usart->BRR = (mantissa << 4) | fraction;\n  }\n  return;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f54",
            "calling": [
                "usart_init"
            ],
            "imported": false,
            "current_name": "calculate_baud_rate_08007f54"
        },
        "FUN_08003b98": {
            "renaming": {
                "FUN_08003b98": "execute_line_08003b98",
                "*line": "line",
                "bVar1": "first_char",
                "uVar2": "result",
                "iVar3": "read_float_result",
                "uVar4": "global_setting_value",
                "extraout_r1": "extraout_r1",
                "uVar5": "uint_var",
                "value_00": "global_setting_value",
                "in_stack_ffffffe0": "in_stack_ffffffe0",
                "value": "value",
                "parameter": "parameter",
                "char_counter": "char_counter",
                "helper_var": "helper_var",
                "PTR_sys_08003f2c": "sys_08003f2c",
                "PTR_settings_08003f30": "settings_08003f30",
                "mc_reset": "reset_motion_control",
                "report_feedback_message": "report_feedback_message",
                "mc_go_home": "go_home_motion_control",
                "protocol_execute_startup": "execute_startup_protocol",
                "settings_read_startup_line": "read_startup_line_settings",
                "report_status_message": "report_status_message",
                "report_startup_line": "report_startup_line",
                "settings_store_global_setting": "store_global_setting_settings",
                "settings_store_startup_line": "store_startup_line_settings",
                "execute_gcode": "execute_gcode"
            },
            "code": "uint8_t execute_line_08003b98(char *line) {\n  byte first_char = line[0];\n  uint8_t result;\n  uint8_t char_counter;\n  uint8_t helper_var;\n  float value;\n  float parameter;\n  float global_setting_value;\n  uint32_t global_setting_index;\n  int read_float_result;\n\n  if (first_char != '$') {\n    result = execute_gcode(line);\n    return result;\n  }\n\n  char_counter = 1;\n  helper_var = 0;\n  byte second_char = line[1];\n\n  if (second_char == 0) {\n    report_grbl_help();\n    return 0;\n  }\n\n  if ((second_char < 0x23) || (second_char > 0x58)) {\n    goto switchD_08003bdc_caseD_25;\n  }\n\n  switch (second_char) {\n    case 0x23:\n      char_counter = 2;\n      if (line[2] != 0) {\n        return 3;\n      }\n      report_gcode_parameters();\n      break;\n    case 0x24:\n      char_counter = 2;\n      if (line[2] != 0) {\n        return 3;\n      }\n      report_grbl_settings();\n      break;\n    case 0x43:\n      char_counter = 2;\n      if (line[2] != 0) {\n        return 3;\n      }\n      if (PTR_sys_08003f2c[1] == 7) {\n        mc_reset();\n        report_feedback_message(5);\n      } else {\n        if (PTR_sys_08003f2c[1] != 0) {\n          return 11;\n        }\n        PTR_sys_08003f2c[1] = 7;\n        report_feedback_message(4);\n      }\n      break;\n    case 0x47:\n      char_counter = 2;\n      if (line[2] != 0) {\n        return 3;\n      }\n      report_gcode_modes();\n      break;\n    case 0x48:\n      if ((PTR_settings_08003f30[0x28] & 0x10) == 0) {\n        return 7;\n      }\n      if ((PTR_sys_08003f2c[1] != 0) && (PTR_sys_08003f2c[1] != 6)) {\n        return 11;\n      }\n      mc_go_home();\n      if (PTR_sys_08003f2c[0] == 0) {\n        protocol_execute_startup();\n      }\n      break;\n    case 0x4e:\n      char_counter = 2;\n      if (line[2] == 0) {\n        for (helper_var = 0; helper_var < 2; helper_var++) {\n          result = settings_read_startup_line(helper_var, line);\n          if (result == 0) {\n            report_status_message('\\n');\n          } else {\n            report_startup_line(helper_var, line);\n          }\n        }\n        return 0;\n      }\n      helper_var = 1;\n      /* fallthrough */\n    default:\nswitchD_08003bdc_caseD_25:\n      read_float_result = read_float(line, &char_counter, &parameter);\n      if (read_float_result == 0) {\n        return 1;\n      }\n      char_counter++;\n      if (line[char_counter - 1] != '=') {\n        return 3;\n      }\n      if (helper_var == 0) {\n        read_float_result = read_float(line, &char_counter, &value);\n        if (read_float_result == 0) {\n          return 1;\n        }\n        if (line[char_counter] == 0) {\n          global_setting_index = (uint32_t)__aeabi_f2iz(parameter);\n          global_setting_value = value;\n          result = settings_store_global_setting(global_setting_index, global_setting_value);\n          return result;\n        }\n        return 3;\n      }\n      while (line[char_counter] != 0) {\n        line[char_counter - char_counter + helper_var - 1] = line[char_counter];\n        char_counter++;\n      }\n      helper_var = char_counter - char_counter + helper_var - 1;\n      result = execute_gcode(line);\n      if (result != 0) {\n        return result;\n      }\n      uVar4 = __aeabi_f2d(parameter);\n      trunc((double)CONCAT44(line,in_stack_ffffffe0));\n      helper_var = __aeabi_d2uiz(uVar4,extraout_r1);\n      settings_store_startup_line(helper_var,line);\n      break;\n    case 0x58:\n      char_counter = 2;\n      if (line[2] != 0) {\n        return 3;\n      }\n      if (PTR_sys_08003f2c[1] == 6) {\n        report_feedback_message(3);\n        PTR_sys_08003f2c[1] = 0;\n      }\n  }\n  return 0;\n}",
            "called": [
                "report_feedback_message",
                "settings_store_startup_line",
                "report_status_message",
                "__aeabi_f2iz",
                "protocol_execute_startup",
                "settings_read_startup_line",
                "report_gcode_modes",
                "settings_store_global_setting",
                "read_float",
                "report_grbl_help",
                "mc_go_home",
                "report_gcode_parameters",
                "__aeabi_d2uiz",
                "trunc",
                "__aeabi_f2d",
                "report_grbl_settings",
                "mc_reset",
                "gc_execute_line",
                "report_startup_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b98",
            "calling": [
                "protocol_process"
            ],
            "imported": false,
            "current_name": "execute_line_08003b98"
        },
        "FUN_080024c4": {
            "renaming": {
                "FUN_080024c4": "execute_line_and_sync_080024c4",
                "invert_feed_rate": "inverted_feed_rate",
                "uVar1": "direction_float",
                "uVar2": "z_direction_float",
                "z": "z_coord",
                "feed_rate": "feed_rate",
                "z_dir": "z_direction",
                "y_dir": "y_direction",
                "x_dir": "x_direction"
            },
            "code": "void execute_line_and_sync_080024c4(void)\n{\n  uint8_t inverted_feed_rate;\n  undefined4 x_dir_float;\n  undefined4 y_dir_float;\n  undefined4 z_dir_float;\n  float z_coord;\n  float feed_rate;\n  int8_t x_direction;\n  int8_t y_direction;\n  int8_t z_direction;\n  PTR_sys_080025d8[1] = 5;\n  *(undefined4 *)PTR_limits_enabled_080025dc = 0;\n  limits_go_home();\n  protocol_execute_runtime();\n  if (*PTR_sys_080025d8 == '\\0') {\n    memset(DAT_080025e0,0,0xc);\n    sys_sync_current_position();\n    PTR_sys_080025d8[1] = 0;\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x20) == 0) {\n      x_direction = -1;\n    }\n    else {\n      x_direction = 1;\n    }\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x80) == 0) {\n      y_direction = -1;\n    }\n    else {\n      y_direction = 1;\n    }\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x200) == 0) {\n      z_direction = -1;\n    }\n    else {\n      z_direction = 1;\n    }\n    x_dir_float = __floatsisf((int)x_direction);\n    inverted_feed_rate = __aeabi_fmul(x_dir_float,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    y_dir_float = __floatsisf((int)y_direction);\n    __aeabi_fmul(y_dir_float,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    z_dir_float = __floatsisf((int)z_direction);\n    feed_rate = *(undefined4 *)(PTR_settings_080025e4 + 0x38);\n    z_coord = 0.0f;\n    mc_line(z_dir_float, z_dir_float, z_coord, feed_rate, inverted_feed_rate);\n    st_cycle_start();\n    plan_synchronize();\n    sys_sync_current_position();\n    if ((PTR_settings_080025e4[0x28] & 8) != 0) {\n      *(undefined4 *)PTR_limits_enabled_080025dc = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "sys_sync_current_position",
                "plan_synchronize",
                "limits_go_home",
                "memset",
                "__aeabi_fmul",
                "st_cycle_start",
                "__floatsisf",
                "mc_line",
                "protocol_execute_runtime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080024c4",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "execute_line_and_sync_080024c4"
        },
        "FUN_08002f40": {
            "renaming": {
                "FUN_08002f40": "update_block_buffer_tail_if_not_empty_08002f40",
                "uVar1": "next_block_index",
                "*PTR_block_buffer_head_08002f6c": "block_buffer_head",
                "*PTR_block_buffer_tail_08002f70": "block_buffer_tail",
                "next_block_index": "next_block_index"
            },
            "code": "void update_block_buffer_tail_if_not_empty_08002f40(void)\n{\n  uint8_t next_block_index;\n  if (*PTR_*PTR_block_buffer_head_08002f6c_08002f6c != *PTR_*PTR_block_buffer_tail_08002f70_08002f70) {\n    next_block_index = get_next_block_index(*PTR_*PTR_block_buffer_tail_08002f70_08002f70);\n    *PTR_*PTR_block_buffer_tail_08002f70_08002f70 = next_block_index;\n  }\n  return;\n}",
            "called": [
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f40",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_block_buffer_tail_if_not_empty_08002f40"
        },
        "FUN_08009054": {
            "renaming": {
                "FUN_08009054": "FUNC_08009054"
            },
            "code": "\nuint FUNC_08009054(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  uVar2 = param_1 >> 0x17 & 0xff;\n  bVar7 = uVar2 == 0;\n  if (!bVar7) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    bVar7 = param_4 == 0;\n  }\n  if (!bVar7) {\n    bVar7 = uVar2 == 0xff;\n  }\n  if (!bVar7) {\n    bVar7 = param_4 == 0xff;\n  }\n  if (bVar7) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    uVar6 = param_1;\n    if (uVar2 == 0xff) {\n      if (((param_1 & 0x7fffff) != 0) || (uVar6 = param_2, param_4 == 0xff)) {\nLAB_0800904a:\n        return uVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (param_4 == 0xff) {\n        uVar6 = param_2;\n        if ((param_2 & 0x7fffff) == 0) {\nLAB_08009000:\n          return (param_1 ^ param_2) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      bVar7 = (param_1 & 0x7fffffff) == 0;\n      if (!bVar7) {\n        bVar7 = (param_2 & 0x7fffffff) == 0;\n      }\n      if (!bVar7) {\n        bVar7 = uVar2 == 0;\n        uVar6 = param_1 & 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_1 = param_1 << 1;\n            bVar7 = (param_1 & 0x800000) == 0;\n          }\n          if (!bVar7) break;\n          uVar2 = uVar2 - 1;\n        }\n        param_1 = param_1 | uVar6;\n        bVar7 = param_4 == 0;\n        uVar6 = param_2 & 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_2 = param_2 << 1;\n            bVar7 = (param_2 & 0x800000) == 0;\n          }\n          if (!bVar7) break;\n          param_4 = param_4 - 1;\n        }\n        param_2 = param_2 | uVar6;\n        goto LAB_0800906c;\n      }\n      if ((param_1 & 0x7fffffff) == 0) {\n        if ((param_2 & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    param_1 = param_1 ^ param_2;\n  }\n  else {\nLAB_0800906c:\n    iVar3 = uVar2 - param_4;\n    if (param_2 << 9 == 0) {\n      param_1 = (param_1 ^ param_2) & 0x80000000 | param_1 & 0x7fffff;\n      bVar9 = SCARRY4(iVar3,0x7f);\n      iVar5 = iVar3 + 0x7f;\n      bVar7 = iVar5 < 0;\n      bVar8 = iVar5 == 0;\n      if (!bVar8 && bVar7 == bVar9) {\n        bVar9 = SBORROW4(0xff,iVar5);\n        bVar7 = 0xff - iVar5 < 0;\n        bVar8 = iVar5 == 0xff;\n      }\n      if (!bVar8 && bVar7 == bVar9) {\n        param_1 = param_1 | iVar5 * 0x800000;\n      }\n      if (!bVar8 && bVar7 == bVar9) {\n        return param_1;\n      }\n      param_1 = param_1 | 0x800000;\n      uVar2 = 0;\n      bVar8 = SBORROW4(iVar5,1);\n      uVar4 = iVar3 + 0x7e;\n      bVar7 = uVar4 == 0;\n      uVar6 = uVar4;\n    }\n    else {\n      uVar1 = (param_2 << 9) >> 4 | 0x10000000;\n      uVar2 = (param_1 << 9) >> 4 | 0x10000000;\n      param_1 = (param_1 ^ param_2) & 0x80000000;\n      bVar7 = uVar1 <= uVar2;\n      if (!bVar7) {\n        uVar2 = uVar2 << 1;\n      }\n      uVar4 = iVar3 + 0x7d + (uint)bVar7;\n      uVar6 = 0x800000;\n      do {\n        if (uVar1 <= uVar2) {\n          uVar2 = uVar2 - uVar1;\n          param_1 = param_1 | uVar6;\n        }\n        bVar7 = uVar1 >> 1 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 1);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 1;\n        }\n        bVar7 = uVar1 >> 2 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 2);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 2;\n        }\n        bVar7 = uVar1 >> 3 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 3);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 3;\n        }\n        uVar2 = uVar2 * 0x10;\n        bVar7 = uVar2 == 0;\n        if (!bVar7) {\n          uVar6 = uVar6 >> 4;\n          bVar7 = uVar6 == 0;\n        }\n      } while (!bVar7);\n      bVar8 = SBORROW4(uVar4,0xfd);\n      bVar7 = uVar4 == 0xfd;\n      uVar6 = uVar4 - 0xfd;\n      if (uVar4 < 0xfe) {\n        param_1 = param_1 + uVar4 * 0x800000 + (uint)(uVar1 <= uVar2);\n        if (uVar2 - uVar1 == 0) {\n          param_1 = param_1 & 0xfffffffe;\n        }\n        return param_1;\n      }\n    }\n    if (bVar7 || (int)uVar6 < 0 != bVar8) {\n      bVar7 = (int)(uVar4 + 0x19) < 0;\n      if (uVar4 == 0xffffffe7 || bVar7 != SCARRY4(uVar4,0x19)) {\n        param_1 = param_1 & 0x80000000;\n      }\n      if (uVar4 == 0xffffffe7 || bVar7 != SCARRY4(uVar4,0x19)) {\n        return param_1;\n      }\n      uVar6 = (param_1 << 1) >> (-uVar4 & 0xff);\n      uVar4 = param_1 << (uVar4 + 0x20 & 0xff);\n      uVar6 = ((uint)((param_1 & 0x80000000) != 0) << 0x1f | uVar6 >> 1) + (uint)((byte)uVar6 & 1);\n      if ((uVar2 | uVar4 << 1) == 0) {\n        uVar6 = uVar6 & ~(uVar4 >> 0x1f);\n      }\n      return uVar6;\n    }\n  }\n  return param_1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009054",
            "calling": [
                "intersection_distance",
                "gc_set_current_position",
                "homing_cycle",
                "report_realtime_status",
                "plan_cycle_reinitialize",
                "planner_recalculate_trapezoids",
                "mc_arc",
                "plan_buffer_line",
                "report_grbl_settings",
                "estimate_acceleration_distance"
            ],
            "imported": false,
            "current_name": "FUNC_08009054"
        },
        "FUN_080025e8": {
            "renaming": {
                "FUN_080025e8": "spindle_controller_080025e8",
                "PTR_sys_08002634": "sys_ptr",
                "spindle_is_on": "is_spindle_on",
                "coolant_stop": "stop_coolant",
                "is_idle": "is_machine_idle",
                "st_go_idle": "go_to_idle_state"
            },
            "code": "void spindle_controller_080025e8() {\n  bool spindle_is_on = ((PTR_sys_08002634[2] & 0x10) == 0);\n  if (spindle_is_on) {\n    PTR_sys_08002634[2] |= 0x10;\n    spindle_stop();\n    coolant_stop();\n    bool is_idle = ((byte)PTR_sys_08002634[1] - 3 < 3);\n    if (is_idle) {\n      PTR_sys_08002634[2] |= 0x20;\n      st_go_idle();\n    }\n  }\n}\n",
            "called": [
                "spindle_stop",
                "st_go_idle",
                "coolant_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e8",
            "calling": [
                "protocol_execute_line",
                "buttons_isr",
                "serial_rx_hook",
                "limits_isr",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "spindle_controller_080025e8"
        },
        "FUN_080001c8": {
            "renaming": {
                "FUN_080001c8": "do_nothing_080001c8"
            },
            "code": "\nvoid do_nothing_080001c8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001c8",
            "calling": [
                "coolant_run"
            ],
            "imported": false,
            "current_name": "do_nothing_080001c8"
        },
        "FUN_08005ac4": {
            "renaming": {
                "FUN_08005ac4": "get_default_value_08005ac4"
            },
            "code": "uint32_t get_default_value_08005ac4(void)\n{\n  uint32_t default_value = 0x1000000;\n  return default_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ac4",
            "calling": [],
            "imported": false,
            "current_name": "get_default_value_08005ac4"
        },
        "FUN_08005250": {
            "renaming": {
                "FUN_08005250": "spindle_turn_off_08005250",
                "spindle_off": "spindle_turn_off"
            },
            "code": "void spindle_turn_off_08005250(void)\n{\n  spindle_off();\n  return;\n}",
            "called": [
                "spindle_off"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005250",
            "calling": [
                "spindle_init",
                "spindle_run",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "spindle_turn_off_08005250"
        },
        "FUN_08007430": {
            "renaming": {
                "FUN_08007430": "infinite_loop_08007430"
            },
            "code": "void infinite_loop_08007430(void)\n{\n  while(true){\n    // do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007430",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "infinite_loop_08007430"
        },
        "FUN_08008640": {
            "renaming": {
                "FUN_08008640": "FUNC_08008640"
            },
            "code": "\nulonglong FUNC_08008640(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 = CONCAT44(param_2,param_1);\n  uVar7 = 0x7ff;\n  uVar4 = param_2 >> 0x14 & 0x7ff;\n  bVar9 = uVar4 == 0;\n  if (!bVar9) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar9 = unaff_r5 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar4 == 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 = unaff_r5 == 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 = calculate_value_0800881c();\n  }\n  uVar3 = (uint)(uVar12 >> 0x20);\n  iVar5 = uVar4 + unaff_r5;\n  uVar4 = uVar3 ^ param_4;\n  uVar3 = uVar3 & ~(uVar7 << 0x15);\n  param_4 = param_4 & ~(uVar7 << 0x15);\n  bVar9 = ((uint)uVar12 | uVar3 << 0xc) == 0;\n  if (!bVar9) {\n    bVar9 = (param_3 | param_4 << 0xc) == 0;\n  }\n  uVar3 = uVar3 | 0x100000;\n  param_4 = param_4 | 0x100000;\n  if (bVar9) {\n    param_3 = (uint)uVar12 | param_3;\n    param_4 = (uVar4 & 0x80000000 | uVar3) ^ param_4;\n    uVar4 = uVar7 >> 1;\n    bVar11 = SBORROW4(iVar5,uVar4);\n    uVar6 = iVar5 - uVar4;\n    bVar9 = uVar6 == 0;\n    uVar3 = uVar6;\n    if (!bVar9 && (int)uVar4 <= iVar5) {\n      bVar11 = SBORROW4(uVar7,uVar6);\n      uVar3 = uVar7 - uVar6;\n      bVar9 = uVar7 == uVar6;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      param_4 = param_4 | uVar6 * 0x100000;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      return CONCAT44(param_4,param_3);\n    }\n    param_4 = param_4 | 0x100000;\n    uVar7 = 0;\n    bVar11 = SBORROW4(uVar6,1);\n    uVar6 = uVar6 - 1;\n    bVar9 = uVar6 == 0;\n    uVar4 = uVar6;\n  }\n  else {\n    uVar1 = (uVar12 & 0xffffffff) * (ulonglong)param_3;\n    uVar12 = (uVar12 & 0xffffffff) * (ulonglong)param_4 +\n             (ulonglong)uVar3 * (ulonglong)param_3 + (uVar1 >> 0x20);\n    uVar8 = (uint)uVar12;\n    lVar2 = (ulonglong)uVar3 * (ulonglong)param_4 + (uVar12 >> 0x20);\n    uVar7 = (uint)lVar2;\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    if ((int)uVar1 != 0) {\n      uVar8 = uVar8 | 1;\n    }\n    uVar6 = (iVar5 + -0x3ff) - (uint)(uVar3 < 0x200);\n    if (uVar3 < 0x200) {\n      bVar9 = (uVar8 & 0x80000000) != 0;\n      uVar8 = uVar8 << 1;\n      lVar2 = CONCAT44(uVar3 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    param_4 = uVar4 & 0x80000000 | (int)((ulonglong)lVar2 >> 0x20) << 0xb | (uint)lVar2 >> 0x15;\n    param_3 = (uint)lVar2 << 0xb | uVar8 >> 0x15;\n    uVar7 = uVar8 * 0x800;\n    bVar10 = 0xfc < uVar6;\n    bVar11 = SBORROW4(uVar6,0xfd);\n    uVar3 = uVar6 - 0xfd;\n    bVar9 = uVar3 == 0;\n    uVar4 = uVar3;\n    if (bVar10 && !bVar9) {\n      bVar10 = 0x6ff < uVar3;\n      bVar11 = SBORROW4(uVar3,0x700);\n      uVar4 = uVar6 - 0x7fd;\n      bVar9 = uVar3 == 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 = 0x7fffffff < uVar7;\n      if (uVar7 == 0x80000000) {\n        bVar9 = (uVar8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(param_4 + uVar6 * 0x100000 + (uint)CARRY4(param_3,(uint)bVar9),param_3 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 && (int)uVar4 < 0 == bVar11) {\n    return (ulonglong)(param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar10 = SCARRY4(uVar6,0x36);\n  bVar9 = (int)(uVar6 + 0x36) < 0;\n  bVar11 = uVar6 == 0xffffffca;\n  if (bVar11 || bVar9 != bVar10) {\n    param_3 = 0;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    param_4 = param_4 & 0x80000000;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    return CONCAT44(param_4,param_3);\n  }\n  uVar4 = -uVar6;\n  uVar3 = uVar4 - 0x20;\n  if (0x1f < (int)uVar4) {\n    uVar6 = param_3 >> (uVar3 & 0xff) | param_4 << (0x20 - uVar3 & 0xff);\n    uVar4 = (param_4 >> (uVar3 & 0xff) & ~((param_4 & 0x80000000) >> (uVar3 & 0xff))) -\n            ((int)uVar6 >> 0x1f);\n    if ((uVar7 | param_3 << (0x20 - uVar3 & 0xff) | uVar6 << 1) == 0) {\n      uVar4 = uVar4 & ~(uVar6 >> 0x1f);\n    }\n    return CONCAT44(param_4,uVar4) & 0x80000000ffffffff;\n  }\n  iVar5 = uVar4 - 0x14;\n  if (iVar5 == 0 || iVar5 < 0 != SCARRY4(uVar3,0xc)) {\n    uVar8 = param_3 << (uVar6 + 0x20 & 0xff);\n    uVar3 = param_3 >> (uVar4 & 0xff) | param_4 << (uVar6 + 0x20 & 0xff);\n    uVar6 = uVar3 + -((int)uVar8 >> 0x1f);\n    if ((uVar7 | uVar8 << 1) == 0) {\n      uVar6 = uVar6 & ~(uVar8 >> 0x1f);\n    }\n    return CONCAT44((param_4 & 0x80000000) +\n                    ((param_4 & 0x7fffffff) >> (uVar4 & 0xff)) +\n                    (uint)CARRY4(uVar3,-((int)uVar8 >> 0x1f)),uVar6);\n  }\n  uVar4 = 0xc - iVar5;\n  uVar6 = param_3 << (uVar4 & 0xff);\n  uVar4 = param_3 >> (0x20 - uVar4 & 0xff) | param_4 << (uVar4 & 0xff);\n  uVar3 = uVar4 + -((int)uVar6 >> 0x1f);\n  if ((uVar7 | uVar6 << 1) == 0) {\n    uVar3 = uVar3 & ~(uVar6 >> 0x1f);\n  }\n  return CONCAT44((param_4 & 0x80000000) + (uint)CARRY4(uVar4,-((int)uVar6 >> 0x1f)),uVar3);\n}\n\n",
            "called": [
                "FUN_0800881c"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008640",
            "calling": [
                "scalbn",
                "homing_cycle",
                "mc_arc",
                "read_float",
                "report_gcode_modes",
                "__ieee754_sqrt",
                "calculate_trapezoid_for_block",
                "__ieee754_hypot",
                "report_realtime_status",
                "report_gcode_parameters",
                "__kernel_cos",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "to_millimeters",
                "atan",
                "__kernel_rem_pio2",
                "__kernel_sin"
            ],
            "imported": false,
            "current_name": "FUNC_08008640"
        },
        "FUN_08007310": {
            "renaming": {
                "FUN_08007310": "get_pin_state_08007310",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "bitstatus": "bit_status",
                "uint": "GPIO_PinState"
            },
            "code": "GPIO_PinState get_pin_state_08007310(GPIO_TypeDef *gpio, uint16_t pin){\n  GPIO_PinState bit_status = (GPIO_PinState)(gpio->IDR & pin);\n  return bit_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007310",
            "calling": [],
            "imported": false,
            "current_name": "get_pin_state_08007310"
        },
        "FUN_08007436": {
            "renaming": {
                "FUN_08007436": "initialize_clocks_08007436",
                "RCC_OscInitStruct": "osc_init",
                "RCC_ClkInitStruct": "clk_init",
                "HVar1": "status",
                "RCC_OscInitStruct.OscillatorType": "osc_init.OscillatorType",
                "RCC_OscInitStruct.HSEState": "osc_init.HSEState",
                "RCC_OscInitStruct.PLL.PLLState": "osc_init.PLL.PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "osc_init.PLL.PLLSource",
                "RCC_OscInitStruct.PLL.PLLM": "osc_init.PLL.PLLM",
                "RCC_OscInitStruct.PLL.PLLN": "osc_init.PLL.PLLN",
                "RCC_OscInitStruct.PLL.PLLP": "osc_init.PLL.PLLP",
                "RCC_OscInitStruct.PLL.PLLQ": "osc_init.PLL.PLLQ",
                "HAL_RCC_OscConfig": "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig": "HAL_RCC_ClockConfig",
                "RCC_ClkInitStruct.ClockType": "clk_init.ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "clk_init.SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "clk_init.AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "clk_init.APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "clk_init.APB2CLKDivider",
                "FLASH_LATENCY_5": "FLASH_LATENCY_5",
                "DAT_080074c0": "DAT_080074c0",
                "DAT_080074c4": "DAT_080074c4"
            },
            "code": "void initialize_clocks_08007436(void)\n{\n    HAL_StatusTypeDef status;\n    RCC_OscInitTypeDef osc_init;\n    RCC_ClkInitTypeDef clk_init;\n\n    // Enable HSE oscillator and activate PLL with HSE as source\n    *(uint *)(DAT_080074c0 + 0x40) |= 0x10000000;\n\n    // Set APB1 and APB2 clock dividers\n    *DAT_080074c4 |= 0xC000;\n\n    // Configure oscillator\n    osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n    osc_init.HSEState = RCC_HSE_ON;\n    osc_init.PLL.PLLState = RCC_PLL_ON;\n    osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n    osc_init.PLL.PLLM = 8;\n    osc_init.PLL.PLLN = 336;\n    osc_init.PLL.PLLP = RCC_PLLP_DIV2;\n    osc_init.PLL.PLLQ = 7;\n\n    status = HAL_RCC_OscConfig(&osc_init);\n    if (status != HAL_OK) {\n        Error_Handler();\n    }\n\n    // Configure system clock\n    clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n    clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n    clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;\n    clk_init.APB1CLKDivider = RCC_HCLK_DIV4;\n    clk_init.APB2CLKDivider = RCC_HCLK_DIV2;\n\n    status = HAL_RCC_ClockConfig(&clk_init, FLASH_LATENCY_5);\n    if (status != HAL_OK) {\n        Error_Handler();\n    }\n\n    return;\n}",
            "called": [
                "HAL_RCC_OscConfig",
                "Error_Handler",
                "HAL_RCC_ClockConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007436",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_clocks_08007436"
        },
        "FUN_08005814": {
            "renaming": {
                "FUN_08005814": "initialize_data_08005814",
                "PTR_st_08005834": "data_array",
                "PTR_current_block_08005838": "current_block",
                "set_step_events_per_minute": "set_events_per_minute",
                "undefined4": "uint32_t"
            },
            "code": "void initialize_data_08005814(void)\n{\n  memset(PTR_st_08005834, 0, sizeof(PTR_st_08005834));\n  set_events_per_minute(800);\n  *(uint32_t *)PTR_current_block_08005838 = 0;\n  return;\n}",
            "called": [
                "memset",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005814",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_data_08005814"
        },
        "FUN_08005bdc": {
            "renaming": {
                "FUN_08005bdc": "set_irq_priority_08005bdc",
                "IRQn_Type": "IRQn",
                "IRQn": "irq",
                "priority": "priority",
                "WWDG_IRQn": "WWDG_IRQn",
                "irq_priority_base_address": "DAT_08005c28",
                "irq_priority_offset": "DAT_08005c2c"
            },
            "code": "void set_irq_priority_08005bdc(IRQn_Type irq, uint32_t priority) {\n  if (irq < WWDG_IRQn) {\n    *(char *)(((byte)irq & 0xf) + irq_priority_base_address + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(irq + irq_priority_offset + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bdc",
            "calling": [
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "set_irq_priority_08005bdc"
        },
        "FUN_080085d4": {
            "renaming": {
                "FUN_080085d4": "convert_to_double_080085d4",
                "param_1": "a",
                "param_2": "b",
                "bVar1": "low_byte_a",
                "uVar2": "low",
                "uVar3": "shift_amount",
                "uVar4": "high",
                "iVar5": "leading_zeros",
                "uVar6": "shift_amount2",
                "iVar7": "shift",
                "uVar8": "high_b",
                "bVar9": "carry",
                "bVar10": "shift_needed",
                "bVar11": "shift_amount_overflow"
            },
            "code": "ulonglong convert_to_double_080085d4(uint a, uint b)\n{\n    if ((a | b) == 0)\n    {\n        return CONCAT44(b, a);\n    }\n    int shift = 0x432;\n    uint high_b = b >> 0x16;\n    if (high_b != 0)\n    {\n        shift = 3;\n        if (b >> 0x19 != 0)\n        {\n            shift = 6;\n        }\n        if (b >> 0x1c != 0)\n        {\n            shift += 3;\n        }\n        int shift_amount = shift - ((int)b >> 0x1f);\n        uint low_a = a << (0x20 - shift_amount & 0xff);\n        a = a >> (shift_amount & 0xff) | b << (0x20 - shift_amount & 0xff);\n        b = b >> (shift_amount & 0xff);\n        shift = shift_amount + 0x432;\n    }\n    if (0xfffff < b)\n    {\n        if (0x1fffff < b)\n        {\n            uint low_bit_b = b & 1;\n            b = b >> 1;\n            byte low_byte_a = (byte)a;\n            a = (uint)(low_bit_b != 0) << 0x1f | a >> 1;\n            high_b = (uint)(low_byte_a & 1) << 0x1f | high_b >> 1;\n            shift++;\n            if (0xffbfffff < (uint)(shift * 0x200000))\n            {\n                return 0x7ff0000000000000;\n            }\n        }\n        goto end_conversion;\n    }\n    bool carry = (high_b & 0x80000000) != 0;\n    high_b = high_b << 1;\n    uint low_a_double = a * 2;\n    bool carry_a = CARRY4(a, a);\n    a = a * 2 + (uint)carry;\n    b = b * 2 + (uint)(carry_a || CARRY4(low_a_double, (uint)carry));\n    bool shift_needed = shift != 0;\n    shift--;\n    while (shift_needed && 0xfffff < b)\n    {\n        goto end_conversion;\n    }\nend_conversion:\n    uint low = a;\n    uint high = b;\n    if (b == 0)\n    {\n        low = 0;\n        high = a;\n    }\n    int leading_zeros = count_leading_zeroes(high);\n    if (b == 0)\n    {\n        leading_zeros += 0x20;\n    }\n    int shift_amount = leading_zeros - 0xb;\n    bool shift_amount_overflow = SBORROW4(shift_amount, 0x20);\n    int shift_amount2 = leading_zeros - 0x2b;\n    bool shift_amount2_negative = (int)shift_amount2 < 0;\n    bool shift_amount2_zero = shift_amount2 == 0;\n    if ((int)shift_amount < 0x20)\n    {\n        shift_amount_overflow = SCARRY4(shift_amount2, 0xc);\n        leading_zeros--;\n        shift_needed = leading_zeros < 0;\n        shift_amount2_zero = leading_zeros == 0;\n        shift_amount2_negative = shift_needed == shift_amount_overflow;\n        shift_amount = shift_amount2;\n        if (!shift_amount2_zero && shift_amount2_negative == shift_amount_overflow)\n        {\n            low = high << (shift_amount & 0xff);\n            high = high >> (0xcU - leading_zeros & 0xff);\n            goto end_shift;\n        }\n    }\n    if (shift_amount2_zero || shift_amount2_negative != shift_amount_overflow)\n    {\n        int shift_amount3 = 0x20 - shift_amount;\n        high = high << (shift_amount & 0xff);\n        if (shift_amount2_zero || shift_amount2_negative != shift_amount_overflow)\n        {\n            high = high | low >> (shift_amount3 & 0xff);\n        }\n        if (shift_amount2_zero || shift_amount2_negative != shift_amount_overflow)\n        {\n            low = low << (shift_amount & 0xff);\n        }\n    }\nend_shift:\n    if ((int)shift_amount <= shift)\n    {\n        return CONCAT44(high + (shift - shift_amount) * 0x100000, low);\n    }\n    uint shift_amount4 = ~(shift - shift_amount);\n    if ((int)shift_amount4 < 0x1f)\n    {\n        int shift_amount5 = shift_amount4 - 0x13;\n        if (shift_amount5 != 0 && shift_amount5 < 0 == SCARRY4(shift_amount4 - 0x1f, 0xc))\n        {\n            return (ulonglong)(low >> (0x20 - (0xcU - shift_amount5) & 0xff) | high << (0xcU - shift_amount5 & 0xff));\n        }\n        shift_amount4++;\n        return CONCAT44(high >> (shift_amount4 & 0xff), low >> (shift_amount4 & 0xff) | high << (0x20 - shift_amount4 & 0xff));\n    }\n    return (ulonglong)(high >> (shift_amount4 - 0x1f & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085d4",
            "calling": [],
            "imported": false,
            "current_name": "convert_to_double_080085d4"
        },
        "FUN_08006e70": {
            "renaming": {
                "FUN_08006e70": "update_system_tick_08006e70"
            },
            "code": "void update_system_tick_08006e70(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e70",
            "calling": [],
            "imported": false,
            "current_name": "update_system_tick_08006e70"
        },
        "FUN_080002f0": {
            "renaming": {
                "FUN_080002f0": "clear_eeprom_data_080002f0",
                "PTR_eeprom_data_08000308": "eeprom_data",
                "PTR_eeprom_ready_0800030c": "eeprom_ready"
            },
            "code": "void clear_eeprom_data_080002f0(void)\n{\n  memset(PTR_eeprom_data_08000308, 0xff, 4);\n  *PTR_eeprom_ready_0800030c = 1;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002f0",
            "calling": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum",
                "memcpy_from_eeprom_with_checksum",
                "eeprom_get_char"
            ],
            "imported": false,
            "current_name": "clear_eeprom_data_080002f0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "do_nothing_080073c0"
            },
            "code": "\nvoid do_nothing_080073c0(uint16_t GPIO_Pin)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080073c0"
        },
        "FUN_0800778c": {
            "renaming": {
                "FUN_0800778c": "initialize_gpio_pins_0800778c",
                "puVar1": "gpio_info_ptr",
                "GPIO_InitStruct": "GPIO_InitStruct",
                "gpio": "GPIO_INFO",
                "i": "i",
                "DAT_08007850": "DAT_08007850",
                "PTR_gpio_info_0800784c": "PTR_gpio_info_0800784c"
            },
            "code": "void initialize_gpio_pins_0800778c(void)\n{\n  uint *gpio_info_ptr;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_INFO *gpio;\n  int i;\n  uint gpio_pin;\n  uint gpio_port;\n  uint gpio_pin_state;\n  for (i = 0; i < 0x11; i++) {\n    gpio_info_ptr = (uint *)(PTR_gpio_info_0800784c + i * 0x18);\n    gpio_pin = *gpio_info_ptr & 0xf;\n    gpio_port = (*gpio_info_ptr >> 4 & 0xff) + 0x100080;\n    gpio_pin_state = (uint)gpio_info_ptr[5];\n    *(uint *)(DAT_08007850 + 0x30) |= 1 << gpio_port;\n    GPIO_InitStruct.Pin = 1 << gpio_pin;\n    GPIO_InitStruct.Mode = gpio_info_ptr[1];\n    GPIO_InitStruct.Pull = gpio_info_ptr[2];\n    GPIO_InitStruct.Speed = gpio_info_ptr[3];\n    GPIO_InitStruct.Alternate = gpio_info_ptr[4];\n    HAL_GPIO_Init((GPIO_TypeDef *)(gpio_port * 0x400),&GPIO_InitStruct);\n    if (gpio_pin_state >= 0) {\n      HAL_GPIO_WritePin((GPIO_TypeDef *)(gpio_port * 0x400), gpio_pin, (GPIO_PinState)gpio_pin_state);\n    }\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800778c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_gpio_pins_0800778c"
        },
        "FUN_080001d4": {
            "renaming": {
                "FUN_080001d4": "do_nothing_080001d4"
            },
            "code": "\nvoid do_nothing_080001d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001d4",
            "calling": [
                "coolant_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_080001d4"
        },
        "FUN_08001ddc": {
            "renaming": {
                "FUN_08001ddc": "initialize_system_08001ddc",
                "serial_init": "initialize_serial",
                "settings_init": "initialize_settings",
                "st_init": "initialize_stepper_motor",
                "serial_reset_read_buffer": "reset_serial_read_buffer",
                "plan_init": "initialize_planner",
                "gc_init": "initialize_garbage_collector",
                "protocol_init": "initialize_protocol",
                "spindle_init": "initialize_spindle",
                "coolant_init": "initialize_coolant",
                "limits_init": "initialize_limits",
                "st_reset": "reset_stepper_motor",
                "sys_sync_current_position": "synchronize_current_position",
                "protocol_execute_startup": "execute_startup_protocol",
                "protocol_execute_runtime": "execute_runtime_protocol",
                "protocol_process": "process_protocol",
                "PTR_sys_08001e90": "system_pointer_08001e90",
                "PTR_settings_08001e94": "settings_pointer_08001e94"
            },
            "code": "int initialize_system_08001ddc(void)\n{\n    initialize_serial();\n    initialize_settings();\n    initialize_stepper_motor();\n    memset(PTR_sys_08001e90, 0, 0x14);\n    *PTR_sys_08001e90 = 1;\n    PTR_sys_08001e90[1] = 1;\n    do {\n        if (*PTR_sys_08001e90 != '\\0') {\n            reset_serial_read_buffer();\n            initialize_planner();\n            initialize_garbage_collector();\n            initialize_protocol();\n            initialize_spindle();\n            initialize_coolant();\n            initialize_limits();\n            reset_stepper_motor();\n            synchronize_current_position();\n            *PTR_sys_08001e90 = 0;\n            PTR_sys_08001e90[2] = 0;\n            if ((PTR_settings_08001e94[0x28] & 2) != 0) {\n                PTR_sys_08001e90[0x10] = 1;\n            }\n            if ((PTR_sys_08001e90[1] == '\\x01') && ((PTR_settings_08001e94[0x28] & 0x10) != 0)) {\n                PTR_sys_08001e90[1] = 6;\n            }\n            if (PTR_sys_08001e90[1] == '\\x06') {\n                report_feedback_message('\\x02');\n            }\n            else {\n                PTR_sys_08001e90[1] = 0;\n                execute_startup_protocol();\n            }\n        }\n        execute_runtime_protocol();\n        process_protocol();\n    } while (true);\n}",
            "called": [
                "sys_sync_current_position",
                "report_feedback_message",
                "coolant_init",
                "spindle_init",
                "memset",
                "gc_init",
                "st_init",
                "protocol_execute_startup",
                "serial_init",
                "protocol_execute_runtime",
                "protocol_init",
                "limits_init",
                "serial_reset_read_buffer",
                "plan_init",
                "protocol_process",
                "st_reset",
                "settings_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ddc",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_system_08001ddc"
        },
        "FUN_080069b4": {
            "renaming": {
                "FUN_080069b4": "set_interrupt_priority_bit_080069b4",
                "IRQn": "irq_num",
                "DAT_080069e0": "irq_priority_reg_base"
            },
            "code": "void set_interrupt_priority_bit_080069b4(IRQn_Type irq_num)\n{\n    int* irq_reg = (int*)(DAT_080069e0 + ((uint)(int)irq_num >> 5) * 4);\n    int bit_pos = irq_num & 0x1fU;\n    int bit_val = 1 << bit_pos;\n    *irq_reg = bit_val;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069b4",
            "calling": [
                "HAL_NVIC_EnableIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_bit_080069b4"
        },
        "FUN_0800b4e4": {
            "renaming": {
                "FUN_0800b4e4": "register_exit_proc_0800b4e4",
                "__func": "__func_ptr",
                "iVar1": "exit_proc_id"
            },
            "code": "int register_exit_proc_0800b4e4(__func *__func_ptr)\n{\n  int exit_proc_id = __register_exitproc(0, __func_ptr, 0);\n  return exit_proc_id;\n}",
            "called": [
                "__register_exitproc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4e4",
            "calling": [
                "register_fini"
            ],
            "imported": false,
            "current_name": "register_exit_proc_0800b4e4"
        },
        "FUN_08007720": {
            "renaming": {
                "FUN_08007720": "infinite_loop_08007720"
            },
            "code": "void infinite_loop_08007720(void)\n{\n  while(true);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007720",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_08007720"
        },
        "FUN_08009228": {
            "renaming": {
                "FUN_08009228": "is_end_of_string_08009228",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_08009228(void)\n{\n  char current_char;\n  __aeabi_cfcmpeq();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009228",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line",
                "gc_execute_line",
                "printFloat",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08009228"
        },
        "FUN_08007c7c": {
            "renaming": {
                "FUN_08007c7c": "step_isr_08007c7c",
                "TIMx": "timer",
                "_DAT_40000010": "GPIOA->IDR",
                "_DAT_4000000c": "GPIOC->IDR",
                "step_delay_isr": "step_delay_isr",
                "step_pulse_isr": "step_pulse_isr",
                "step_period_isr": "step_period_isr"
            },
            "code": "void step_isr_08007c7c(void)\n{\n    TIM_TypeDef *timer;\n\n    if (((_DAT_40000010 & 2) != 0) && ((_DAT_4000000c & 2) != 0)) {\n        _DAT_40000010 &= ~(1 << 1);\n        step_delay_isr();\n    }\n    if (((_DAT_40000010 & 4) != 0) && ((_DAT_4000000c & 4) != 0)) {\n        _DAT_40000010 &= ~(1 << 2);\n        step_pulse_isr();\n    }\n    if (((_DAT_40000010 & 1) != 0) && ((_DAT_4000000c & 1) != 0)) {\n        _DAT_40000010 &= ~(1 << 0);\n        step_period_isr();\n    }\n    return;\n}",
            "called": [
                "step_period_isr",
                "step_pulse_isr",
                "step_delay_isr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c7c",
            "calling": [],
            "imported": false,
            "current_name": "step_isr_08007c7c"
        },
        "FUN_08007726": {
            "renaming": {
                "FUN_08007726": "wait_forever_08007726"
            },
            "code": "void wait_forever_08007726(void)\n{\n  while(true) {\n    // do nothing, just wait forever\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007726",
            "calling": [],
            "imported": false,
            "current_name": "wait_forever_08007726"
        },
        "FUN_08007b70": {
            "renaming": {
                "FUN_08007b70": "enable_timers_08007b70",
                "TIMx": "timer_instance",
                "enable": "enable_flags",
                "_DAT_40000034": "PTR_TIM2_CR",
                "_DAT_40000038": "PTR_TIM3_CR",
                "_DAT_4000000c": "PTR_TIM1_DIER",
                "_DAT_40000000": "PTR_TIM1_CR1"
            },
            "code": "void enable_timers_08007b70(void)\n{\n  TIM_TypeDef *timer_instance;\n  uint32_t enable_flags = 1;\n  \n  if (_DAT_40000034 != 0) {\n    enable_flags = 3;\n  }\n  if (_DAT_40000038 != 0) {\n    enable_flags |= 4;\n  }\n  _DAT_4000000c |= enable_flags;\n  _DAT_40000000 |= 1;\n  return;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007b70",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "enable_timers_08007b70"
        },
        "FUN_08004d2c": {
            "renaming": {
                "FUN_08004d2c": "read_line_from_eeprom_and_store_if_invalid_08004d2c",
                "n": "line_index",
                "line": "line_buffer",
                "iVar1": "bytes_read",
                "addr": "address"
            },
            "code": "bool read_line_from_eeprom_and_store_if_invalid_08004d2c(uint8_t line_index, char *line_buffer) {\n    int bytes_read = 0;\n    uint16_t address = (uint16_t)((uint16_t)line_index * 0x101 + 0x300);\n    bytes_read = memcpy_from_eeprom_with_checksum(line_buffer, address, 0x100);\n    if (bytes_read == 0) {\n        *line_buffer = '\\0';\n        settings_store_startup_line(line_index, line_buffer);\n    }\n    return bytes_read != 0;\n}",
            "called": [
                "settings_store_startup_line",
                "memcpy_from_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d2c",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "read_line_from_eeprom_and_store_if_invalid_08004d2c"
        },
        "FUN_08003004": {
            "renaming": {
                "FUN_08003004": "FUNC_08003004"
            },
            "code": "\nvoid FUNC_08003004(float x,float y,float z,float feed_rate,uint8_t invert_feed_rate)\n\n{\n  undefined *puVar1;\n  uint8_t uVar2;\n  undefined4 uVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  float fVar11;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 in_r2;\n  uint uVar12;\n  undefined4 in_r3;\n  ushort *puVar13;\n  int iVar14;\n  uint uVar15;\n  float fVar16;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 extraout_d0_04;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  char in_stack_00000000;\n  float unit_vec [3];\n  float delta_mm [3];\n  int32_t target [3];\n  float v_allowable;\n  float sin_theta_d2;\n  float cos_theta;\n  float inverse_millimeters;\n  block_t *block;\n  float vmax_junction;\n  float inverse_minute;\n  \n  puVar13 = (ushort *)\n            (PTR_block_buffer_08003234 + (uint)(byte)*PTR_block_buffer_head_08003230 * 0x40);\n  uVar3 = __aeabi_fmul(x,*(undefined4 *)PTR_settings_08003238,invert_feed_rate);\n  __aeabi_f2d(uVar3);\n  lVar4 = lround((double)CONCAT44(in_r2,in_r3));\n  uVar3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 4),in_r1);\n  __aeabi_f2d(uVar3);\n  lVar5 = lround((double)CONCAT44(in_r2,in_r3));\n  uVar3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 8),in_r2);\n  __aeabi_f2d(uVar3);\n  lVar6 = lround((double)CONCAT44(in_r2,in_r3));\n  *puVar13 = 0;\n  if (lVar4 < *(int *)PTR_pl_0800323c) {\n    *puVar13 = *puVar13 | 0x20;\n  }\n  if (lVar5 < *(int *)(PTR_pl_0800323c + 4)) {\n    *puVar13 = *puVar13 | 0x880;\n  }\n  if (lVar6 < *(int *)(PTR_pl_0800323c + 8)) {\n    *puVar13 = *puVar13 | 0x200;\n  }\n  iVar14 = lVar4 - *(int *)PTR_pl_0800323c;\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(puVar13 + 2) = iVar14;\n  iVar14 = lVar5 - *(int *)(PTR_pl_0800323c + 4);\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(puVar13 + 4) = iVar14;\n  iVar14 = lVar6 - *(int *)(PTR_pl_0800323c + 8);\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(puVar13 + 6) = iVar14;\n  uVar12 = *(uint *)(puVar13 + 6);\n  if (*(uint *)(puVar13 + 6) < *(uint *)(puVar13 + 4)) {\n    uVar12 = *(uint *)(puVar13 + 4);\n  }\n  uVar15 = *(uint *)(puVar13 + 2);\n  if (*(uint *)(puVar13 + 2) < uVar12) {\n    uVar15 = uVar12;\n  }\n  *(uint *)(puVar13 + 8) = uVar15;\n  if (*(int *)(puVar13 + 8) != 0) {\n    uVar3 = __floatsisf(lVar4 - *(int *)PTR_pl_0800323c);\n    uVar3 = __aeabi_fdiv(uVar3,*(undefined4 *)PTR_settings_08003238);\n    uVar7 = __floatsisf(lVar5 - *(int *)(PTR_pl_0800323c + 4));\n    uVar7 = __aeabi_fdiv(uVar7,*(undefined4 *)(PTR_settings_08003238 + 4));\n    uVar8 = __floatsisf(lVar6 - *(int *)(PTR_pl_0800323c + 8));\n    uVar8 = __aeabi_fdiv(uVar8,*(undefined4 *)(PTR_settings_08003238 + 8));\n    uVar9 = __aeabi_fmul(uVar3,uVar3);\n    uVar10 = __aeabi_fmul(uVar7,uVar7);\n    uVar9 = __addsf3(uVar9,uVar10);\n    uVar10 = __aeabi_fmul(uVar8,uVar8);\n    uVar9 = __addsf3(uVar9,uVar10);\n    uVar9 = __aeabi_f2d(uVar9);\n    sqrt((double)CONCAT44(in_r2,in_r3));\n    uVar9 = __truncdfsf2(uVar9,extraout_r1);\n    *(undefined4 *)(puVar13 + 0x10) = uVar9;\n    uVar9 = __aeabi_fdiv(0x3f800000,*(undefined4 *)(puVar13 + 0x10));\n    if (in_stack_00000000 == '\\0') {\n      inverse_minute = (float)__aeabi_fmul(in_r3,uVar9);\n    }\n    else {\n      inverse_minute = (float)__aeabi_fdiv(0x3f800000,in_r3);\n    }\n    uVar10 = __aeabi_fmul(*(undefined4 *)(puVar13 + 0x10),inverse_minute);\n    *(undefined4 *)(puVar13 + 10) = uVar10;\n    uVar10 = __floatsisf(*(undefined4 *)(puVar13 + 8));\n    uVar10 = __aeabi_fmul(uVar10,inverse_minute);\n    uVar10 = __aeabi_f2d(uVar10);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    uVar10 = __aeabi_d2uiz(uVar10,extraout_r1_00);\n    *(undefined4 *)(puVar13 + 0x1e) = uVar10;\n    uVar10 = __floatsisf(*(undefined4 *)(puVar13 + 8));\n    uVar10 = __aeabi_fmul(uVar10,uVar9);\n    uVar10 = __aeabi_fmul(uVar10,*(undefined4 *)(PTR_settings_08003560 + 0x20));\n    uVar10 = __aeabi_fdiv(uVar10,DAT_08003564);\n    uVar10 = __aeabi_f2d(uVar10);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    uVar10 = __aeabi_d2iz(uVar10,extraout_r1_01);\n    *(undefined4 *)(puVar13 + 0x18) = uVar10;\n    uVar3 = __aeabi_fmul(uVar3,uVar9);\n    uVar7 = __aeabi_fmul(uVar7,uVar9);\n    uVar8 = __aeabi_fmul(uVar8,uVar9);\n    vmax_junction = 0.0;\n    uVar17 = extraout_d0;\n    fVar16 = extraout_s2;\n    if ((*PTR_block_buffer_head_08003568 != *PTR_block_buffer_tail_0800356c) &&\n       (iVar14 = __aeabi_fcmpgt(*(undefined4 *)(PTR_pl_08003570 + 0x18),0), uVar17 = extraout_d0_00,\n       fVar16 = extraout_s2_00, iVar14 != 0)) {\n      uVar9 = __aeabi_fmul(*(uint *)(PTR_pl_08003570 + 0xc) ^ 0x80000000,uVar3);\n      uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x10),uVar7);\n      uVar9 = __aeabi_fsub(uVar9,uVar10);\n      uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x14),uVar8);\n      uVar9 = __aeabi_fsub(uVar9,uVar10);\n      uVar17 = __aeabi_f2d(uVar9);\n      iVar14 = __aeabi_dcmplt((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),DAT_08003550,DAT_08003554\n                             );\n      uVar17 = extraout_d0_01;\n      fVar16 = extraout_s2_01;\n      if (iVar14 != 0) {\n        iVar14 = __aeabi_fcmplt(*(undefined4 *)(PTR_pl_08003570 + 0x18),\n                                *(undefined4 *)(puVar13 + 10));\n        if (iVar14 == 0) {\n          vmax_junction = *(float *)(puVar13 + 10);\n        }\n        else {\n          vmax_junction = *(float *)(PTR_pl_08003570 + 0x18);\n        }\n        uVar17 = __aeabi_f2d(uVar9);\n        iVar14 = __aeabi_dcmpgt((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),DAT_08003558,\n                                DAT_0800355c);\n        uVar17 = extraout_d0_02;\n        fVar16 = extraout_s2_02;\n        if (iVar14 != 0) {\n          uVar17 = __aeabi_f2d(uVar9);\n          uVar17 = __subdf3(0,DAT_08003574,(int)uVar17,(int)((ulonglong)uVar17 >> 0x20));\n          uVar9 = __muldf3((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),0,DAT_08003578);\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          uVar9 = __truncdfsf2(uVar9,extraout_r1_02);\n          uVar17 = __aeabi_f2d(vmax_junction);\n          uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x20),\n                                *(undefined4 *)(PTR_settings_08003560 + 0x24));\n          uVar10 = __aeabi_fmul(uVar10,uVar9);\n          uVar18 = __aeabi_f2d(uVar10);\n          uVar19 = __aeabi_f2d(uVar9);\n          uVar19 = __subdf3(0,DAT_08003574,(int)uVar19,(int)((ulonglong)uVar19 >> 0x20));\n          uVar10 = __divdf3((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),(int)uVar19,\n                            (int)((ulonglong)uVar19 >> 0x20));\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          iVar14 = __aeabi_dcmplt((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),uVar10,extraout_r1_03\n                                 );\n          uVar17 = extraout_d0_03;\n          fVar16 = extraout_s2_03;\n          if (iVar14 == 0) {\n            uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x20),\n                                  *(undefined4 *)(PTR_settings_08003560 + 0x24));\n            uVar10 = __aeabi_fmul(uVar10,uVar9);\n            uVar17 = __aeabi_f2d(uVar10);\n            uVar18 = __aeabi_f2d(uVar9);\n            uVar18 = __subdf3(0,DAT_08003574,(int)uVar18,(int)((ulonglong)uVar18 >> 0x20));\n            uVar9 = __divdf3((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),(int)uVar18,\n                             (int)((ulonglong)uVar18 >> 0x20));\n            sqrt((double)CONCAT44(in_r2,in_r3));\n            vmax_junction = (float)__truncdfsf2(uVar9,extraout_r1_04);\n            uVar17 = extraout_d0_04;\n            fVar16 = extraout_s2_04;\n          }\n        }\n      }\n    }\n    *(float *)(puVar13 + 0xe) = vmax_junction;\n    fVar11 = (float)(*(uint *)(PTR_settings_08003560 + 0x20) ^ 0x80000000);\n    max_allowable_speed((float)uVar17,(float)((ulonglong)uVar17 >> 0x20),fVar16);\n    iVar14 = __aeabi_fcmplt(vmax_junction,fVar11);\n    fVar16 = fVar11;\n    if (iVar14 != 0) {\n      fVar16 = vmax_junction;\n    }\n    *(float *)(puVar13 + 0xc) = fVar16;\n    iVar14 = __aeabi_fcmpge(fVar11,*(undefined4 *)(puVar13 + 10));\n    if (iVar14 == 0) {\n      *(undefined *)((int)puVar13 + 0x25) = 0;\n    }\n    else {\n      *(undefined *)((int)puVar13 + 0x25) = 1;\n    }\n    *(undefined *)(puVar13 + 0x12) = 1;\n    puVar1 = PTR_pl_080035e0;\n    *(undefined4 *)(PTR_pl_080035e0 + 0xc) = uVar3;\n    *(undefined4 *)(puVar1 + 0x10) = uVar7;\n    *(undefined4 *)(puVar1 + 0x14) = uVar8;\n    *(undefined4 *)(PTR_pl_080035e0 + 0x18) = *(undefined4 *)(puVar13 + 10);\n    *PTR_block_buffer_head_080035e8 = *PTR_next_buffer_head_080035e4;\n    uVar2 = next_block_index(*PTR_block_buffer_head_080035e8);\n    *PTR_next_buffer_head_080035e4 = uVar2;\n    puVar1 = PTR_pl_080035e0;\n    *(long *)PTR_pl_080035e0 = lVar4;\n    *(long *)(puVar1 + 4) = lVar5;\n    *(long *)(puVar1 + 8) = lVar6;\n    planner_recalculate();\n  }\n  return;\n}\n\n",
            "called": [
                "planner_recalculate",
                "__aeabi_fcmpge",
                "ceil",
                "lround",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_d2iz",
                "__aeabi_fdiv",
                "max_allowable_speed",
                "__subdf3",
                "__aeabi_fcmpgt",
                "__addsf3",
                "sqrt",
                "__aeabi_dcmplt",
                "__aeabi_dcmpgt",
                "__aeabi_fmul",
                "next_block_index",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fcmplt",
                "__floatsisf",
                "__divdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003004",
            "calling": [
                "mc_line"
            ],
            "imported": false,
            "current_name": "FUNC_08003004"
        },
        "FUN_080066cc": {
            "renaming": {
                "FUN_080066cc": "calculate_APB_clock_080066cc",
                "uVar1": "HCLK_freq",
                "uVar2": "leading_zeroes",
                "result": "APB_clock",
                "result_1": "unused_variable",
                "PTR_APBAHBPrescTable_08006714": "APBAHB_prescaler_table",
                "DAT_08006710": "data_address",
                "mask": "mask",
                "shifted_value": "shifted_value"
            },
            "code": "uint32_t calculate_APB_clock_080066cc(void)\n{\n  uint32_t HCLK_freq = HAL_RCC_GetHCLKFreq();\n  uint leading_zeroes = count_leading_zeroes(0x70000);\n  uint32_t* PTR_APBAHBPrescTable_08006714 = PTR_APBAHBPrescTable_08006714;\n  uint32_t* DAT_08006710 = DAT_08006710;\n  uint32_t data_value = *(uint *)(DAT_08006710 + 8);\n  uint32_t mask = 0xe000;\n  uint32_t shifted_value = (data_value & mask) >> (leading_zeroes & 0xff);\n  uint32_t APB_clock = HCLK_freq >> PTR_APBAHBPrescTable_08006714[shifted_value];\n  return APB_clock;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066cc",
            "calling": [
                "set_baud_rate"
            ],
            "imported": false,
            "current_name": "calculate_APB_clock_080066cc"
        },
        "FUN_080018fc": {
            "renaming": {
                "FUN_080018fc": "set_bit_in_register_080018fc",
                "x": "value",
                "DAT_08001928": "register_data",
                "PTR_": "",
                "val": ""
            },
            "code": "void set_bit_in_register_080018fc(uint32_t value)\n{\n  uint32_t *register_ptr = (uint32_t *)(DAT_08001928 + 0x14);\n  uint32_t current_register_value = *(uint *)(DAT_08001928 + 0x14);\n  uint32_t mask = 0xfffff55f;\n  uint32_t masked_value = current_register_value & mask;\n  uint32_t new_value = value | masked_value;\n  *register_ptr = new_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018fc",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "set_bit_in_register_080018fc"
        },
        "FUN_080039bc": {
            "renaming": {
                "FUN_080039bc": "read_startup_lines_080039bc",
                "n": "line_number",
                "uVar1": "read_result"
            },
            "code": "void read_startup_lines_080039bc(void)\n{\n  uint8_t line_number;\n  for (line_number = 0; line_number < 2; line_number++) {\n    uint8_t read_result = settings_read_startup_line(line_number, PTR_line_08003a14);\n    if (read_result == 0) {\n      report_status_message('\\n');\n    }\n    else if (*PTR_line_08003a14 != 0) {\n      printString(PTR_line_08003a14);\n      uint8_t execution_result = gc_execute_line(PTR_line_08003a14);\n      report_status_message(execution_result);\n    }\n  }\n  return;\n}",
            "called": [
                "printString",
                "report_status_message",
                "settings_read_startup_line",
                "gc_execute_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039bc",
            "calling": [
                "protocol_execute_line",
                "grbl_main"
            ],
            "imported": false,
            "current_name": "read_startup_lines_080039bc"
        },
        "FUN_0800618c": {
            "renaming": {
                "FUN_0800618c": "configure_clocks_0800618c",
                "RCC_ClkInitStruct": "clk_init_struct",
                "FLatency": "flash_latency",
                "uVar1": "timeout",
                "uVar2": "current_tick",
                "timeout": "timeout",
                "DAT_08006400": "FLASH_ACR",
                "DAT_08006404": "RCC_CFGR",
                "HAL_GetTick": "HAL_GetTick",
                "RCC_ClkInitTypeDef": "RCC_ClkInitTypeDef",
                "uint32_t": "uint32_t",
                "uint": "uint",
                "HAL_StatusTypeDef": "HAL_StatusTypeDef",
                "return HAL_ERROR;": "return HAL_ERROR;",
                "return HAL_TIMEOUT;": "return HAL_TIMEOUT;",
                "return HAL_OK;": "return HAL_OK;",
                "RCC_CLOCKTYPE_SYSCLK": "RCC_CLOCKTYPE_SYSCLK",
                "RCC_CLOCKTYPE_HCLK": "RCC_CLOCKTYPE_HCLK",
                "RCC_CLOCKTYPE_PCLK1": "RCC_CLOCKTYPE_PCLK1",
                "RCC_CLOCKTYPE_PCLK2": "RCC_CLOCKTYPE_PCLK2",
                "RCC_SYSCLKSOURCE_PLLCLK": "RCC_SYSCLKSOURCE_PLLCLK",
                "RCC_SYSCLKSOURCE_HSE": "RCC_SYSCLKSOURCE_HSE",
                "RCC_SYSCLKSOURCE_HSI": "RCC_SYSCLKSOURCE_HSI",
                "RCC_CFGR_SW": "RCC_CFGR_SW",
                "RCC_CFGR_SWS": "RCC_CFGR_SWS",
                "RCC_CFGR_HPRE": "RCC_CFGR_HPRE",
                "RCC_CFGR_PPRE1": "RCC_CFGR_PPRE1",
                "RCC_CFGR_PPRE2": "RCC_CFGR_PPRE2",
                "RCC_CR_PLLRDY": "RCC_CR_PLLRDY",
                "RCC_CR_HSERDY": "RCC_CR_HSERDY",
                "RCC_CFGR_PPRE1_Pos": "RCC_CFGR_PPRE1_Pos",
                "RCC_CFGR_PPRE2_Pos": "RCC_CFGR_PPRE2_Pos",
                "RCC_CFGR_SWS_PLL": "RCC_CFGR_SWS_PLL",
                "RCC_CFGR_SWS_HSE": "RCC_CFGR_SWS_HSE",
                "SysTick_CLKSource_HCLK": "SysTick_CLKSource_HCLK",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "SysTick_Config": "SysTick_Config"
            },
            "code": "HAL_StatusTypeDef configure_clocks_0800618c(RCC_ClkInitTypeDef *clk_init_struct, uint32_t flash_latency) {\\n\\\n  uint32_t timeout;\\n\\\n  uint32_t current_flash_latency = *DAT_08006400 & 0xf;\\n\\\n  if (current_flash_latency < flash_latency) {\\n\\\n    *DAT_08006400 = (*DAT_08006400 & 0xfffffff0) | flash_latency;\\n\\\n    if (current_flash_latency != (*DAT_08006400 & 0xf)) {\\n\\\n      return HAL_ERROR;\\n\\\n    }\\n\\\n    if ((clk_init_struct->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\\n\\\n      if (clk_init_struct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) {\\n\\\n        if ((*RCC_CR & RCC_CR_PLLRDY) == 0) {\\n\\\n          return HAL_ERROR;\\n\\\n        }\\n\\\n      }\\n\\\n      else if (clk_init_struct->SYSCLKSource != RCC_SYSCLKSOURCE_HSI) {\\n\\\n        return HAL_ERROR;\\n\\\n      }\\n\\\n      *DAT_08006404 = (*DAT_08006404 & (~DAT_08006404_SW)) | clk_init_struct->SYSCLKSource;\\n\\\n      timeout = HAL_GetTick() + 5000;\\n\\\n      if (clk_init_struct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) {\\n\\\n        while ((*DAT_08006404 & DAT_08006404_SWS) != DAT_08006404_SWS_PLL) {\\n\\\n          if (HAL_GetTick() >= timeout) {\\n\\\n            return HAL_TIMEOUT;\\n\\\n          }\\n\\\n        }\\n\\\n      }\\n\\\n      else {\\n\\\n        while ((*DAT_08006404 & DAT_08006404_SWS) != (uint32_t)(clk_init_struct->SYSCLKSource << DAT_08006404_SWS_Pos)) {\\n\\\n          if (HAL_GetTick() >= timeout) {\\n\\\n            return HAL_TIMEOUT;\\n\\\n          }\\n\\\n        }\\n\\\n      }\\n\\\n    }\\n\\\n  }\\n\\\n  else {\\n\\\n    if ((clk_init_struct->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\\n\\\n      if (clk_init_struct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) {\\n\\\n        if ((*RCC_CR & RCC_CR_PLLRDY) == 0) {\\n\\\n          return HAL_ERROR;\\n\\\n        }\\n\\\n      }\\n\\\n      else if (clk_init_struct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE) {\\n\\\n        if ((*RCC_CR & RCC_CR_HSERDY) == 0) {\\n\\\n          return HAL_ERROR;\\n\\\n        }\\n\\\n      }\\n\\\n      else if (clk_init_struct->SYSCLKSource != RCC_SYSCLKSOURCE_HSI) {\\n\\\n        return HAL_ERROR;\\n\\\n      }\\n\\\n      *DAT_08006404 = (*DAT_08006404 & (~DAT_08006404_SW)) | clk_init_struct->SYSCLKSource;\\n\\\n      timeout = HAL_GetTick() + 5000;\\n\\\n      if (clk_init_struct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK) {\\n\\\n        while ((*DAT_08006404 & DAT_08006404_SWS) != DAT_08006404_SWS_PLL) {\\n\\\n          if (HAL_GetTick() >= timeout) {\\n\\\n            return HAL_TIMEOUT;\\n\\\n          }\\n\\\n        }\\n\\\n      }\\n\\\n      else if (clk_init_struct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE) {\\n\\\n        while ((*DAT_08006404 & DAT_08006404_SWS) != DAT_08006404_SWS_HSE) {\\n\\\n          if (HAL_GetTick() >= timeout) {\\n\\\n            return HAL_TIMEOUT;\\n\\\n          }\\n\\\n        }\\n\\\n      }\\n\\\n      else {\\n\\\n        while ((*DAT_08006404 & DAT_08006404_SWS) != (uint32_t)(clk_init_struct->SYSCLKSource << DAT_08006404_SWS_Pos)) {\\n\\\n          if (HAL_GetTick() >= timeout) {\\n\\\n            return HAL_TIMEOUT;\\n\\\n          }\\n\\\n        }\\n\\\n      }\\n\\\n    }\\n\\\n    *DAT_08006400 = (*DAT_08006400 & 0xfffffff0) | flash_latency;\\n\\\n    if (current_flash_latency != (*DAT_08006400 & 0xf)) {\\n\\\n      return HAL_ERROR;\\n\\\n    }\\n\\\n  }\\n\\\n  if ((clk_init_struct->ClockType & RCC_CLOCKTYPE_HCLK) != 0) {\\n\\\n    *DAT_08006404 = (*DAT_08006404 & (~DAT_08006404_HPRE)) | clk_init_struct->AHBCLKDivider;\\n\\\n  }\\n\\\n  if ((clk_init_struct->ClockType & RCC_CLOCKTYPE_PCLK1) != 0) {\\n\\\n    *DAT_08006404 = (*DAT_08006404 & (~DAT_08006404_PPRE1)) | (clk_init_struct->APB1CLKDivider << DAT_08006404_PPRE1_Pos);\\n\\\n  }\\n\\\n  if ((clk_init_struct->ClockType & RCC_CLOCKTYPE_PCLK2) != 0) {\\n\\\n    *DAT_08006404 = (*DAT_08006404 & (~DAT_08006404_PPRE2)) | (clk_init_struct->APB2CLKDivider << DAT_08006404_PPRE2_Pos);\\n\\\n  }\\n\\\n  uint32_t hclk_frequency = HAL_RCC_GetHCLKFreq();\\n\\\n  SysTick_Config((uint32_t)((uint64_t)SysTick_CLKSource_HCLK * (uint64_t)hclk_frequency / (uint64_t)1000000));\\n\\\n  return HAL_OK;\\n\\\n}",
            "called": [
                "HAL_GetTick",
                "SysTick_Config",
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800618c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_clocks_0800618c"
        },
        "FUN_08006998": {
            "renaming": {
                "FUN_08006998": "get_dat_value_shifted_right_and_masked_08006998",
                "DAT_080069b0": "dat_pointer"
            },
            "code": "uint32_t get_dat_value_shifted_right_and_masked_08006998(void)\n{\n    uint32_t* DAT_080069b0 = (uint32_t*)DAT_080069b0;\n    uint32_t dat_value = *(DAT_080069b0 + 0x3);\n    uint32_t shifted_value = dat_value >> 8;\n    uint32_t masked_value = shifted_value & 0x7;\n    return masked_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006998",
            "calling": [
                "HAL_NVIC_GetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "get_dat_value_shifted_right_and_masked_08006998"
        },
        "FUN_080004ac": {
            "renaming": {
                "FUN_080004ac": "clear_and_initialize_settings_080004ac",
                "PTR_gc_080004f0": "gc_buffer",
                "PTR_settings_080004f4": "settings",
                "DAT_080004f8": "data",
                "uVar1": "is_coord_data_valid"
            },
            "code": "void clear_and_initialize_settings_080004ac(void)\n{\n  uint8_t is_coord_DAT_080004f8_valid;\n  memset(PTR_gc_080004f0, 0, 0x38);\n  *(undefined4 *)(PTR_gc_080004f0 + 8) = *(undefined4 *)(PTR_settings_080004f4 + 0x10);\n  select_plane(PLANE_XY, PLANE_YZ, PLANE_XZ);\n  PTR_gc_080004f0[4] = 1;\n  is_coord_DAT_080004f8_valid = read_coord_DAT_080004f8(PTR_gc_080004f0[0x1c], DAT_080004f8);\n  if (is_coord_DAT_080004f8_valid == FALSE) {\n    report_status_message('\n');\n  }\n  return;\n}",
            "called": [
                "settings_read_coord_data",
                "memset",
                "report_status_message",
                "select_plane"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004ac",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "clear_and_initialize_settings_080004ac"
        },
        "FUN_080078f4": {
            "renaming": {
                "FUN_080078f4": "debounce_state_080078f4",
                "state": "state",
                "i": "i",
                "PTR_debounce_0800792c": "PTR_debounce_0800792c"
            },
            "code": "uint32_t debounce_state_080078f4(void)\n{\n  int i;\n  uint32_t state = 0;\n  for (i = 0; i < 4; i++) {\n    state |= *(uint *)(PTR_debounce_0800792c + i * 4);\n  }\n  return state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078f4",
            "calling": [
                "homing_cycle",
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "debounce_state_080078f4"
        },
        "FUN_080041a0": {
            "renaming": {
                "FUN_080041a0": "print_message_080041a0",
                "message_code": "message_code",
                "PTR_DAT_0800420c": "start_message",
                "PTR_s_Reset_to_continue_08004210": "reset_message",
                "PTR_s___H____X__to_unlock_08004214": "unlock_message",
                "PTR_s_Caution__Unlocked_08004218": "caution_message",
                "PTR_s_Enabled_0800421c": "enabled_message",
                "PTR_s_Disabled_08004220": "disabled_message",
                "PTR_DAT_08004224": "end_message"
            },
            "code": "void print_message_080041a0(uint8_t message_code)\n{\n  printPgmString(PTR_DAT_0800420c);\n  switch(message_code) {\n    case RESET:\n      printPgmString(PTR_s_Reset_to_continue_08004210);\n      break;\n    case UNLOCK:\n      printPgmString(PTR_s___H____X__to_unlock_08004214);\n      break;\n    case CAUTION:\n      printPgmString(PTR_s_Caution__Unlocked_08004218);\n      break;\n    case ENABLED:\n      printPgmString(PTR_s_Enabled_0800421c);\n      break;\n    case DISABLED:\n      printPgmString(PTR_s_Disabled_08004220);\n      break;\n  }\n  printPgmString(PTR_DAT_08004224);\n  return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a0",
            "calling": [
                "protocol_execute_line",
                "grbl_main",
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "print_message_080041a0"
        },
        "FUN_08008bf0": {
            "renaming": {
                "FUN_08008bf0": "convert_fixed_point_to_integer_08008bf0",
                "param_1": "fixed_point_num",
                "param_2": "fractional_bits",
                "iVar1": "scaled_num",
                "uVar2": "shift_amount"
            },
            "code": "uint convert_fixed_point_to_integer_08008bf0(uint fixed_point_num, uint fractional_bits) {\n  int scaled_num;\n  uint shift_amount;\n  \n  if ((fractional_bits & 0x80000000) != 0) {\n    return 0;\n  }\n  scaled_num = fixed_point_num * 2 + 0x200000;\n  if (fixed_point_num * 2 < 0xffe00000) {\n    if (-1 < scaled_num) {\n      return 0;\n    }\n    shift_amount = -(scaled_num >> 0x15) - 0x3e1;\n    if (-1 < (int)shift_amount) {\n      return (fixed_point_num << 0xb | 0x80000000 | fractional_bits >> 0x15) >> (shift_amount & 0xff);\n    }\n  }\n  else if ((fixed_point_num | fractional_bits << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf0",
            "calling": [
                "calculate_trapezoid_for_block",
                "protocol_execute_line",
                "homing_cycle",
                "mc_arc",
                "plan_buffer_line",
                "mc_dwell",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "convert_fixed_point_to_integer_08008bf0"
        },
        "FUN_0800771a": {
            "renaming": {
                "FUN_0800771a": "wait_forever_0800771a"
            },
            "code": "void wait_forever_0800771a(void)\n{\n    while(true)\n    {\n        // Do nothing\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771a",
            "calling": [],
            "imported": false,
            "current_name": "wait_forever_0800771a"
        },
        "FUN_08003a18": {
            "renaming": {
                "FUN_08003a18": "update_button_state_08003a18",
                "buttons": "button_state",
                "PTR_sys_08003a70": "PTR_sys"
            },
            "code": "void update_button_state_08003a18(uint32_t buttons) {\n    bool is_button_pressed = (buttons & 0x80) != 0;\n    bool is_button_a_pressed = (buttons & 0x40) != 0;\n    bool is_button_b_pressed = (buttons & 0x20) != 0;\n\n    if (!is_button_pressed) {\n        if (!is_button_a_pressed) {\n            if (is_button_b_pressed) {\n                PTR_sys_08003a70_08003a70[2] |= 2;\n            }\n        }\n        else {\n            PTR_sys_08003a70_08003a70[2] |= 8;\n        }\n    }\n    else {\n        mc_reset();\n    }\n    return;\n}",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a18",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "update_button_state_08003a18"
        },
        "FUN_08005790": {
            "renaming": {
                "FUN_08005790": "enable_stepper_motor_if_mode_is_three_08005790",
                "PTR_sys_080057d4": "mode_setting_ptr",
                "PTR_step_bits_080057dc": "step_bits_ptr",
                "PTR_settings_080057d8": "settings_ptr",
                "PTR_dirn_bits_080057e0": "dirn_bits_ptr",
                "set_step_pulse_delay": "set_step_pulse_delay",
                "set_step_pulse_time": "set_step_pulse_time",
                "step_isr_enable": "enable_step_isr"
            },
            "code": "void enable_stepper_motor_if_mode_is_three_08005790() {\n  stepper_motor_enable();\n  if (PTR_sys_080057d4[1] == '\\x03') {\n    *(undefined2*)PTR_step_bits_080057dc = *(undefined2*)(PTR_settings_080057d8 + 0x18);\n    *(undefined2*)PTR_dirn_bits_080057e0 = *(undefined2*)(PTR_settings_080057d8 + 0x1a);\n    set_step_pulse_delay(0x69);\n    set_step_pulse_time(((byte)PTR_settings_080057d8[0xd] + 5) * 0x15);\n    enable_step_isr();\n  }\n  return;\n}",
            "called": [
                "set_step_pulse_time",
                "stepper_motor_enable",
                "step_isr_enable",
                "set_step_pulse_delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005790",
            "calling": [
                "limits_go_home",
                "st_init",
                "st_cycle_start"
            ],
            "imported": false,
            "current_name": "enable_stepper_motor_if_mode_is_three_08005790"
        },
        "FUN_08007732": {
            "renaming": {
                "FUN_08007732": "do_nothing_08007732"
            },
            "code": "\nvoid do_nothing_08007732(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007732",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007732"
        },
        "FUN_08001994": {
            "renaming": {
                "FUN_08001994": "FUNC_08001994"
            },
            "code": "\nvoid FUNC_08001994(uint8_t cycle_mask,int8_t pos_dir,_Bool invert_pin,float homing_rate)\n\n{\n  ushort uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  uint32_t uVar6;\n  undefined4 in_r3;\n  uint32_t uVar7;\n  undefined8 uVar8;\n  undefined in_stack_ffffff9c;\n  char cVar9;\n  uint32_t steps [3];\n  uint16_t step_bits0;\n  uint32_t dt_min;\n  uint32_t delta_rate;\n  float ds;\n  uint32_t step_event_count;\n  uint32_t limit_state;\n  uint16_t step_bits;\n  uint32_t trap_counter;\n  uint32_t step_rate;\n  uint32_t step_delay;\n  int32_t counter_z;\n  int32_t counter_y;\n  int32_t counter_x;\n  uint16_t dirn_bits;\n  uint32_t dt;\n  uint8_t dist;\n  \n  cVar9 = !invert_pin;\n  memset(steps,0,0xc);\n  dist = (cycle_mask & 1) != 0;\n  if ((bool)dist) {\n    __aeabi_f2d(*(undefined4 *)PTR_settings_08001c90);\n    steps[0] = lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,\n                                                                                in_r3)))));\n  }\n  if ((cycle_mask & 2) != 0) {\n    dist = dist + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 4));\n    steps[1] = lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,\n                                                                                in_r3)))));\n  }\n  if ((cycle_mask & 4) != 0) {\n    dist = dist + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 8));\n    steps[2] = lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,\n                                                                                in_r3)))));\n  }\n  uVar6 = steps[2];\n  if (steps[2] < steps[1]) {\n    uVar6 = steps[1];\n  }\n  uVar7 = steps[0];\n  if (steps[0] < uVar6) {\n    uVar7 = uVar6;\n  }\n  uVar8 = __floatunsidf(uVar7);\n  uVar2 = __floatunsidf(dist);\n  sqrt((double)CONCAT17(cycle_mask,\n                        CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,in_r3)))));\n  uVar8 = __divdf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),uVar2,extraout_r1);\n  uVar2 = __truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  uVar3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08001c90 + 0x20),uVar2);\n  uVar3 = __aeabi_fdiv(uVar3,DAT_08001c94);\n  uVar3 = __aeabi_f2d(uVar3);\n  ceil((double)CONCAT17(cycle_mask,\n                        CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,in_r3)))));\n  iVar4 = __aeabi_d2uiz(uVar3,extraout_r1_00);\n  uVar3 = __floatunsidf(dist);\n  sqrt((double)CONCAT17(cycle_mask,\n                        CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,in_r3)))));\n  uVar8 = __aeabi_f2d(in_r3);\n  uVar8 = __muldf3(uVar3,extraout_r1_01,(int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  uVar3 = __truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  uVar2 = __aeabi_fmul(uVar2,uVar3);\n  uVar2 = __aeabi_fdiv(DAT_08001c98,uVar2);\n  __aeabi_f2d(uVar2);\n  uVar5 = lround((double)CONCAT17(cycle_mask,\n                                  CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,uVar3))\n                                          )));\n  dt = DAT_08001c9c;\n  if (uVar5 < DAT_08001c9c) {\n    dt = uVar5;\n  }\n  uVar1 = *(ushort *)(PTR_settings_08001c90 + 0x18);\n  dirn_bits = *(ushort *)(PTR_settings_08001c90 + 0x1a) ^\n              *(ushort *)(PTR_settings_08001c90 + 0x2a) & 0xaa0;\n  if (pos_dir == '\\0') {\n    dirn_bits = dirn_bits ^ 0xaa0;\n  }\n  dirn_wr((uint)dirn_bits);\n  step_wr((uint)uVar1);\n  counter_z = -(uVar7 >> 1);\n  step_delay = dt - (byte)PTR_settings_08001c90[0xd];\n  step_rate = 0;\n  trap_counter = 10000;\n  counter_y = counter_z;\n  counter_x = counter_z;\n  while( true ) {\n    limit_state = debounce_rd();\n    if (cVar9 != '\\0') {\n      limit_state = limit_state ^ 0x1e;\n    }\n    step_bits = uVar1;\n    if (((cycle_mask & 1) != 0) && (counter_x = counter_x + steps[0], 0 < counter_x)) {\n      if ((limit_state & 0x10) == 0) {\n        cycle_mask = cycle_mask & 0xfe;\n      }\n      else {\n        step_bits = uVar1 ^ 0x10;\n      }\n      counter_x = counter_x - uVar7;\n    }\n    if (((cycle_mask & 2) != 0) && (counter_y = counter_y + steps[1], 0 < counter_y)) {\n      if ((limit_state & 8) == 0) {\n        cycle_mask = cycle_mask & 0xfd;\n      }\n      else {\n        step_bits = step_bits ^ 0x440;\n      }\n      counter_y = counter_y - uVar7;\n    }\n    if (((cycle_mask & 4) != 0) && (counter_z = counter_z + steps[2], 0 < counter_z)) {\n      if ((limit_state & 4) == 0) {\n        cycle_mask = cycle_mask & 0xfb;\n      }\n      else {\n        step_bits = step_bits ^ 0x100;\n      }\n      counter_z = counter_z - uVar7;\n    }\n    if ((cycle_mask == 0) || ((PTR_sys_08001d40[2] & 0x10) != 0)) break;\n    step_wr((uint)step_bits);\n    delay_us((uint)(byte)PTR_settings_08001d44[0xd]);\n    step_wr((uint)uVar1);\n    delay_us(step_delay);\n    if ((uVar5 < dt) && (trap_counter = dt + trap_counter, 20000 < trap_counter)) {\n      trap_counter = trap_counter - 20000;\n      step_rate = iVar4 + step_rate;\n      dt = DAT_08001d48 / step_rate;\n      if (DAT_08001d48 / step_rate < uVar5) {\n        dt = uVar5;\n      }\n      step_delay = dt - (byte)PTR_settings_08001d44[0xd];\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__floatunsidf",
                "memset",
                "dirn_wr",
                "ceil",
                "lround",
                "__truncdfsf2",
                "step_wr",
                "__muldf3",
                "__aeabi_fdiv",
                "delay_us",
                "debounce_rd",
                "sqrt",
                "__aeabi_fmul",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__divdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001994",
            "calling": [
                "limits_go_home"
            ],
            "imported": false,
            "current_name": "FUNC_08001994"
        },
        "FUN_08007854": {
            "renaming": {
                "FUN_08007854": "get_bit_at_index_08007854",
                "n": "num",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "int get_bit_at_index_08007854(uint32_t num, uint32_t index) {\n    uint32_t ptr = (num >> 4) * 0x400 + 0x40020010;\n    uint32_t data = *(uint32_t *)ptr;\n    uint32_t bit_mask = 1 << (index & 0xfU);\n    uint32_t result = data & bit_mask;\n    return result >> (index & 0xfU);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007854",
            "calling": [
                "debounce_input"
            ],
            "imported": false,
            "current_name": "get_bit_at_index_08007854"
        },
        "FUN_08004900": {
            "renaming": {
                "FUN_08004900": "print_line_info_08004900",
                "n": "line_number",
                "line": "line_text"
            },
            "code": "void print_line_info_08004900(uint8_t line_number,char *line_text)\n{\n  printPgmString(PTR_DAT_08004934);\n  printInteger((uint)line_number);\n  printPgmString(PTR_DAT_08004938);\n  printString(line_text);\n  printPgmString(PTR_DAT_0800493c);\n  return;\n}",
            "called": [
                "printInteger",
                "printString",
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004900",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_line_info_08004900"
        },
        "FUN_08005318": {
            "renaming": {
                "FUN_08005318": "do_nothing_08005318"
            },
            "code": "\nvoid do_nothing_08005318(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005318",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "do_nothing_08005318"
        },
        "FUN_08004228": {
            "renaming": {
                "FUN_08004228": "print_help_message_08004228",
                "PTR_s__Grbl_0_8c______for_help__08004238": "help_message"
            },
            "code": "void print_help_message_08004228(void)\n{\n  printPgmString(PTR_s__Grbl_0_8c______for_help__08004238);\n  return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004228",
            "calling": [
                "protocol_init"
            ],
            "imported": false,
            "current_name": "print_help_message_08004228"
        },
        "FUN_08009b24": {
            "renaming": {
                "FUN_08009b24": "FUNC_08009b24"
            },
            "code": "\nuint FUNC_08009b24(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  undefined4 uVar5;\n  int iVar6;\n  uint uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined8 uVar13;\n  int local_3c;\n  \n  uVar1 = DAT_08009d70;\n  param_2 = param_2 & 0x7fffffff;\n  param_4 = param_4 & 0x7fffffff;\n  uVar3 = param_1;\n  uVar7 = param_2;\n  if (param_2 < param_4) {\n    uVar3 = param_3;\n    param_3 = param_1;\n    uVar7 = param_4;\n    param_4 = param_2;\n  }\n  if (0x3c00000 < (int)(uVar7 - param_4)) {\n    uVar3 = __aeabi_dadd(uVar3,uVar7,param_3,param_4);\n    return uVar3;\n  }\n  if (DAT_08009d68 < (int)uVar7) {\n    if (DAT_08009d74 < (int)uVar7) {\n      if ((uVar7 & 0xfffff | uVar3) != 0) {\n        uVar3 = __aeabi_dadd(uVar3,uVar7,param_3,param_4);\n      }\n      if ((param_4 ^ 0x7ff00000 | param_3) != 0) {\n        return uVar3;\n      }\n      return param_3;\n    }\n    uVar7 = uVar7 + 0xda800000;\n    param_4 = param_4 + 0xda800000;\n    local_3c = 600;\n  }\n  else {\n    local_3c = 0;\n  }\n  uVar11 = CONCAT44(uVar7,uVar3);\n  uVar10 = CONCAT44(param_4,param_3);\n  if ((int)param_4 <= DAT_08009d6c) {\n    if ((int)param_4 < 0x100000) {\n      if ((param_4 | param_3) == 0) {\n        return uVar3;\n      }\n      uVar10 = __muldf3(param_3,param_4,0,DAT_08009d70);\n      uVar11 = __muldf3(uVar3,uVar7,0,uVar1);\n      local_3c = local_3c + -0x3fe;\n    }\n    else {\n      uVar7 = uVar7 + 0x25800000;\n      uVar11 = CONCAT44(uVar7,uVar3);\n      param_4 = param_4 + 0x25800000;\n      uVar10 = CONCAT44(param_4,param_3);\n      local_3c = local_3c + -600;\n    }\n  }\n  uVar9 = (undefined4)((ulonglong)uVar11 >> 0x20);\n  uVar8 = (undefined4)uVar11;\n  iVar6 = (int)((ulonglong)uVar10 >> 0x20);\n  uVar5 = (undefined4)uVar10;\n  uVar10 = __subdf3(uVar8,uVar9,uVar5,iVar6);\n  iVar4 = (int)((ulonglong)uVar10 >> 0x20);\n  uVar1 = (undefined4)uVar10;\n  iVar2 = __aeabi_dcmplt(uVar5,iVar6,uVar1,iVar4);\n  if (iVar2 == 0) {\n    uVar10 = __muldf3(0,param_4,0);\n    uVar11 = __muldf3(uVar1,iVar4 + -0x80000000,uVar1,iVar4);\n    uVar12 = __aeabi_dadd(uVar8,uVar9,uVar8,uVar9);\n    uVar12 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),0,uVar7 + 0x100000);\n    uVar12 = __muldf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),uVar5,iVar6);\n    uVar13 = __subdf3(uVar5,iVar6,0,param_4);\n    uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),0,uVar7 + 0x100000);\n    uVar12 = __aeabi_dadd((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,\n                          (int)((ulonglong)uVar13 >> 0x20));\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar12,\n                      (int)((ulonglong)uVar12 >> 0x20));\n    __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n             (int)((ulonglong)uVar11 >> 0x20));\n    uVar10 = __ieee754_sqrt();\n  }\n  else {\n    uVar10 = __muldf3(0,uVar7,0,uVar7);\n    uVar11 = __muldf3(uVar5,iVar6 + -0x80000000,uVar5,iVar6);\n    uVar12 = __aeabi_dadd(uVar8,uVar9,0,uVar7);\n    uVar13 = __subdf3(uVar8,uVar9,0,uVar7);\n    uVar12 = __muldf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,\n                      (int)((ulonglong)uVar13 >> 0x20));\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar12,\n                      (int)((ulonglong)uVar12 >> 0x20));\n    __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n             (int)((ulonglong)uVar11 >> 0x20));\n    uVar10 = __ieee754_sqrt();\n  }\n  uVar3 = (uint)uVar10;\n  if (local_3c != 0) {\n    uVar3 = __muldf3(uVar3,(int)((ulonglong)uVar10 >> 0x20),0,local_3c * 0x100000 + 0x3ff00000);\n  }\n  return uVar3;\n}\n\n",
            "called": [
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__muldf3",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009b24",
            "calling": [
                "hypot"
            ],
            "imported": false,
            "current_name": "FUNC_08009b24"
        },
        "FUN_080076c8": {
            "renaming": {
                "FUN_080076c8": "set_bit_in_uint_array_080076c8",
                "n": "index",
                "PTR_40020014": "array",
                "uint": "unsigned int",
                "DAT_0000000f": "0xF",
                "DAT_00000400": "0x100",
                "DAT_00000800": "0x400"
            },
            "code": "void set_bit_in_uint_array_080076c8(uint* PTR_40020014, int index)\n{\n    int PTR_40020014_index = index >> 4;\n    uint* PTR_40020014_pointer = PTR_40020014 + PTR_40020014_index * DAT_00000400;\n    uint bit_mask = 1 << (index & DAT_0000000f);\n    *PTR_40020014_pointer ^= bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076c8",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_in_uint_array_080076c8"
        },
        "FUN_0800530c": {
            "renaming": {
                "FUN_0800530c": "do_nothing_0800530c"
            },
            "code": "\nvoid do_nothing_0800530c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800530c",
            "calling": [
                "st_go_idle"
            ],
            "imported": false,
            "current_name": "do_nothing_0800530c"
        },
        "FUN_08006a8c": {
            "renaming": {
                "FUN_08006a8c": "set_interrupt_enable_bit_08006a8c",
                "IRQn": "irq",
                "DAT_08006abc": "interrupt_enable_register_base_address"
            },
            "code": "void set_interrupt_enable_bit_08006a8c(IRQn_Type irq)\n{\n    int* interrupt_enable_register = (int*)(DAT_08006abc + (((uint)(int)irq >> 5) + 0x60) * 4);\n    int interrupt_enable_bit = 1 << (irq & 0x1fU);\n    *interrupt_enable_register = interrupt_enable_bit;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a8c",
            "calling": [
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_08006a8c"
        },
        "FUN_0800772c": {
            "renaming": {
                "FUN_0800772c": "do_nothing_loop_0800772c"
            },
            "code": "void do_nothing_loop_0800772c(void)\n{\n    while(true)\n    {\n        // Do nothing\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800772c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_loop_0800772c"
        },
        "FUN_0800283a": {
            "renaming": {
                "FUN_0800283a": "set_current_position_0800283a",
                "PTR_sys_08002868": "PTR_sys_08002868",
                "plan_set_current_position": "plan_set_current_position",
                "gc_set_current_position": "gc_set_current_position"
            },
            "code": "void set_current_position_0800283a(int32_t x, int32_t y, int32_t z)\n{\n  plan_set_current_position_0800283a(x, y, z);\n  gc_set_current_position_0800283a(x, y, z);\n  return;\n}",
            "called": [
                "gc_set_current_position",
                "plan_set_current_position"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800283a",
            "calling": [
                "mc_go_home",
                "grbl_main"
            ],
            "imported": false,
            "current_name": "set_current_position_0800283a"
        },
        "FUN_0800881c": {
            "renaming": {
                "FUN_0800881c": "calculate_value_0800881c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_check_1",
                "unaff_r4": "temp_1",
                "uVar2": "bit_check_2",
                "uVar3": "temp_3",
                "in_r12": "mask",
                "bVar4": "is_zero",
                "CONCAT44": "concatenate_44",
                "DAT_080482f8": "concat_mask_1",
                "DAT_080482fc": "concat_mask_2",
                "DAT_08048300": "nan_mask",
                "DAT_08048304": "input_4_mask",
                "result_1": "input_1",
                "result_2": "input_2"
            },
            "code": "unsigned long long calculate_value_0800881c(uint input_1, uint input_2, uint input_3, uint input_4) {\n  uint bit_check_1;\n  uint bit_check_2;\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  bool is_zero;\n  uint mask = 0x80000000;\n  uint shift = 0x14;\n  uint DAT_080482f8 = 0x100000;\n  uint DAT_080482fc = 0x7ff00000;\n  uint DAT_08048300 = 0x7ff8000000000000;\n  uint DAT_08048304 = 0x80000000;\n  uint result_1;\n  uint result_2;\n  bit_check_1 = input_4 >> shift;\n  if ((input_2 != DAT_08048304) && (bit_check_1 != DAT_08048304)) {\n    is_zero = ((input_1 | (input_2 << 1)) == 0);\n    if (!is_zero) {\n      is_zero = ((input_3 | (input_4 << 1)) == 0);\n    }\n    if (is_zero) {\n      return ((unsigned long long)((input_2 ^ input_4) & mask)) << 0x20;\n    }\n    if (input_2 == 0) {\n      temp_3 = input_2 & mask;\n      do {\n        bit_check_2 = input_1 & mask;\n        input_1 = input_1 << 1;\n        input_2 = (input_2 * 2) + (uint)(bit_check_2 != 0);\n      } while ((input_2 & DAT_080482f8) == 0);\n      input_2 |= temp_3;\n      if (bit_check_1 != 0) {\n        return CONCAT44(input_2, input_1);\n      }\n    }\n    do {\n      bit_check_1 = input_3 & mask;\n      input_3 = input_3 << 1;\n      input_4 = (input_4 * 2) + (uint)(bit_check_1 != 0);\n    } while ((input_4 & DAT_080482f8) == 0);\n    return CONCAT44(input_2, input_1);\n  }\n  is_zero = ((input_1 | (input_2 << 1)) == 0);\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = ((input_3 | (input_4 << 1)) == 0);\n  }\n  temp_3 = input_2;\n  if (((!is_zero) && ((input_2 != DAT_08048304 || ((input_1 | (input_2 << 0xc)) == 0)))) && ((bit_check_1 != DAT_08048304 || (input_1 = input_3, temp_3 = input_4, ((input_3 | (input_4 << 0xc)) == 0))))) {\n    return ((unsigned long long)((input_2 ^ input_4) & mask | DAT_080482fc)) << 0x20;\n  }\n  return (CONCAT44(temp_3, input_1) | DAT_08048300);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800881c",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "calculate_value_0800881c"
        },
        "FUN_08004bc0": {
            "renaming": {
                "FUN_08004bc0": "write_line_to_eeprom_08004bc0",
                "n": "line_number",
                "line": "line",
                "addr": "address",
                "memcpy_to_eeprom_with_checksum": "memcpy_to_eeprom_with_checksum"
            },
            "code": "void write_line_to_eeprom_08004bc0(uint8_t line_number, char *line)\n{\n  uint16_t address = (uint16_t)(line_number * 0x101 + 0x300);\n  memcpy_to_eeprom_with_checksum(address, line, 0x100);\n  return;\n}",
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bc0",
            "calling": [
                "protocol_execute_line",
                "settings_read_startup_line"
            ],
            "imported": false,
            "current_name": "write_line_to_eeprom_08004bc0"
        },
        "FUN_08008b4c": {
            "renaming": {
                "FUN_08008b4c": "is_not_CY_or_ZR_08008b4c",
                "in_CY": "in_CY",
                "in_ZR": "in_ZR",
                "__aeabi_cdrcmple": "__aeabi_cdrcmple",
                "! (bool)in_CY || (bool)in_ZR": "!is_CY || is_ZR"
            },
            "code": "bool is_not_CY_or_ZR_08008b4c(bool in_CY, bool in_ZR)\n{\n  bool is_CY = (bool)in_CY;\n  bool is_ZR = (bool)in_ZR;\n  return !is_CY || is_ZR;\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b4c",
            "calling": [
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "is_not_CY_or_ZR_08008b4c"
        },
        "FUN_08004c2a": {
            "renaming": {
                "FUN_08004c2a": "save_settings_to_eeprom_08004c2a",
                "PTR_settings_08004c44": "settings_data"
            },
            "code": "void save_settings_to_eeprom_08004c2a(void)\n{\n  eeprom_put_char(0, 0x05);\n  memcpy_to_eeprom_with_checksum(1, PTR_settings_08004c44, 0x40);\n  return;\n}",
            "called": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c2a",
            "calling": [
                "settings_reset",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "save_settings_to_eeprom_08004c2a"
        },
        "FUN_0800826a": {
            "renaming": {
                "FUN_0800826a": "print_char_0800826a",
                "ch": "character"
            },
            "code": "int print_char_0800826a(int character)\n{\n    usart_putc((char)character);\n    return 0;\n}",
            "called": [
                "usart_putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800826a",
            "calling": [],
            "imported": false,
            "current_name": "print_char_0800826a"
        },
        "FUN_08008b60": {
            "renaming": {
                "FUN_08008b60": "is_end_of_string_08008b60",
                "in_CY": "current_char"
            },
            "code": "bool is_end_of_string_08008b60(void)\n{\n  char current_char;\n  __aeabi_cdrcmple();\n  return current_char == '\\0';\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b60",
            "calling": [
                "floor",
                "ceil",
                "plan_buffer_line",
                "atan"
            ],
            "imported": false,
            "current_name": "is_end_of_string_08008b60"
        },
        "FUN_08005324": {
            "renaming": {
                "FUN_08005324": "set_step_period_based_on_steps_per_minute_08005324",
                "steps_per_minute": "steps_per_minute",
                "ticks_00": "ticks_per_step",
                "local_14": "min_steps_per_minute",
                "ticks": "total_ticks"
            },
            "code": "void set_step_period_based_on_steps_per_minute_08005324(uint32_t steps_per_minute)\n{\n  uint ticks_per_step;\n  uint32_t min_steps_per_minute = 800;\n  uint32_t total_ticks = DAT_08005358;\n  if (steps_per_minute < min_steps_per_minute) {\n    steps_per_minute = min_steps_per_minute;\n  }\n  ticks_per_step = total_ticks / steps_per_minute;\n  *(uint *)(PTR_st_0800535c + 0x14) = ticks_per_step;\n  set_step_period(ticks_per_step);\n  return;\n}",
            "called": [
                "set_step_period"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005324",
            "calling": [
                "step_period_isr",
                "st_cycle_reinitialize",
                "st_reset"
            ],
            "imported": false,
            "current_name": "set_step_period_based_on_steps_per_minute_08005324"
        },
        "FUN_08000310": {
            "renaming": {
                "FUN_08000310": "get_eeprom_data_08000310",
                "addr": "address",
                "PTR_eeprom_ready_08000338": "eeprom_ready",
                "eeprom_init": "initialize_eeprom",
                "PTR_eeprom_data_0800033c": "eeprom_data"
            },
            "code": "char get_eeprom_data_08000310(uint address) {\n  if (*PTR_eeprom_ready_08000338 == 0) {\n    initialize_eeprom();\n  }\n  return PTR_eeprom_data_0800033c[address & 0x3ff];\n}",
            "called": [
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000310",
            "calling": [
                "read_global_settings",
                "memcpy_from_eeprom_with_checksum"
            ],
            "imported": false,
            "current_name": "get_eeprom_data_08000310"
        },
        "FUN_08005208": {
            "renaming": {
                "FUN_08005208": "do_nothing_08005208"
            },
            "code": "\nvoid do_nothing_08005208(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005208",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_08005208"
        },
        "FUN_08007a70": {
            "renaming": {
                "FUN_08007a70": "set_timer_irq_priority_and_enable_08007a70",
                "tim": "timer",
                "pre": "preemption_priority",
                "sub": "sub_priority",
                "irq": "timer_irq",
                "DAT_40000000": "PTR_40000000",
                "TIM2_IRQn": "TIM2_IRQn",
                "DAT_08007ac8": "PTR_08007ac8",
                "TIM3_IRQn": "TIM3_IRQn",
                "DAT_08007acc": "PTR_08007acc",
                "TIM4_IRQn": "TIM4_IRQn",
                "(IRQn_Type)irq": "(IRQn_Type)timer_irq"
            },
            "code": "void set_timer_irq_priority_and_enable_08007a70(TIM_TypeDef *timer, uint32_t preemption_priority, uint32_t sub_priority)\n{\n    uint32_t timer_irq;\n    if (timer == (TIM_TypeDef *)&DAT_40000000) {\n        timer_irq = TIM2_IRQn;\n    }\n    else if (timer == DAT_08007ac8) {\n        timer_irq = TIM3_IRQn;\n    }\n    else {\n        if (timer != DAT_08007acc) {\n            return;\n        }\n        timer_irq = TIM4_IRQn;\n    }\n    HAL_NVIC_SetPriority((IRQn_Type)timer_irq, preemption_priority, sub_priority);\n    NVIC_EnableIRQ((IRQn_Type)timer_irq);\n}",
            "called": [
                "NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a70",
            "calling": [
                "step_timer_init"
            ],
            "imported": false,
            "current_name": "set_timer_irq_priority_and_enable_08007a70"
        },
        "FUN_0800b5b0": {
            "renaming": {
                "FUN_0800b5b0": "get_evp_pkey_ctx_pointer_0800b5b0",
                "ctx": "evp_pkey_ctx_pointer"
            },
            "code": "int get_evp_pkey_ctx_pointer_0800b5b0(EVP_PKEY_CTX *evp_pkey_ctx_pointer) {\n  return (int)evp_pkey_ctx_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5b0",
            "calling": [
                "__libc_init_array",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "get_evp_pkey_ctx_pointer_0800b5b0"
        },
        "FUN_08002978": {
            "renaming": {
                "FUN_08002978": "calculate_final_velocity_08002978",
                "acceleration": "acceleration",
                "target_velocity": "target_velocity",
                "distance": "distance",
                "in_r0": "in_r0",
                "uVar1": "acceleration_squared",
                "uVar2": "distance_doubled",
                "in_r1": "acceleration",
                "extraout_r1": "distance",
                "in_r2": "target_velocity",
                "fVar3": "final_velocity",
                "in_stack_ffffffe0": "in_stack_ffffffe0"
            },
            "code": "float calculate_final_velocity_08002978(float acceleration, float target_velocity, float distance) {\n    float acceleration_squared = __aeabi_fmul(acceleration, acceleration);\n    float distance_doubled = __addsf3(distance, distance);\n    float distance_multiplied = __aeabi_fmul(distance_doubled, target_velocity);\n    float subtraction_result = __aeabi_fsub(acceleration_squared, distance_multiplied);\n    float subtraction_result_double = __aeabi_f2d(subtraction_result);\n    sqrt((double)CONCAT44(target_velocity, distance));\n    float final_velocity = (float)__truncdfsf2(subtraction_result_double, distance);\n    return final_velocity;\n}",
            "called": [
                "__addsf3",
                "sqrt",
                "__aeabi_fmul",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__truncdfsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002978",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_final_velocity_08002978"
        },
        "FUN_08009d78": {
            "renaming": {
                "FUN_08009d78": "FUNC_08009d78"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint FUNC_08009d78(undefined4 param_1,uint param_2,undefined8 *param_3)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 extraout_r1;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  int iVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined4 in_stack_ffffffa8;\n  undefined4 in_stack_ffffffac;\n  undefined4 local_50;\n  undefined4 uStack_4c;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  \n  uVar8 = param_2 & 0x7fffffff;\n  if ((int)uVar8 <= DAT_08009fb0) {\n    *(undefined4 *)param_3 = param_1;\n    *(uint *)((int)param_3 + 4) = param_2;\n    *(undefined4 *)(param_3 + 1) = 0;\n    *(undefined4 *)((int)param_3 + 0xc) = 0;\n    return 0;\n  }\n  if ((int)uVar8 <= DAT_08009fb4) {\n    if ((int)param_2 < 1) {\n      uVar10 = __aeabi_dadd(param_1,param_2,DAT_08009f88,DAT_08009f8c);\n      uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar1 = (undefined4)uVar10;\n      if (uVar8 != DAT_0800a1b8) {\n        uVar10 = __aeabi_dadd(uVar1,uVar2,DAT_0800a1b0,DAT_0800a1b4);\n        *param_3 = uVar10;\n        uVar10 = __subdf3(uVar1,uVar2);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800a1b0,DAT_0800a1b4\n                             );\n        param_3[1] = uVar10;\n        return -1;\n      }\n      uVar10 = __aeabi_dadd(uVar1,uVar2,DAT_0800a190,DAT_0800a194);\n      uVar1 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar11 = __aeabi_dadd((int)uVar10,uVar1,DAT_0800a198,DAT_0800a19c);\n      *param_3 = uVar11;\n      uVar10 = __subdf3((int)uVar10,uVar1);\n      uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800a198,DAT_0800a19c);\n      param_3[1] = uVar10;\n      return -1;\n    }\n    uVar10 = __subdf3();\n    uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar1 = (undefined4)uVar10;\n    if (uVar8 != DAT_08009fb8) {\n      uVar10 = __subdf3(uVar1,uVar2,DAT_08009f90,DAT_08009f94);\n      *param_3 = uVar10;\n      uVar10 = __subdf3(uVar1,uVar2);\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08009f90,DAT_08009f94);\n      param_3[1] = uVar10;\n      return 1;\n    }\n    uVar10 = __subdf3(uVar1,uVar2,DAT_08009f98,DAT_08009f9c);\n    uVar1 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar11 = __subdf3((int)uVar10,uVar1,DAT_08009fa0,DAT_08009fa4);\n    *param_3 = uVar11;\n    uVar10 = __subdf3((int)uVar10,uVar1);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08009fa0,DAT_08009fa4);\n    param_3[1] = uVar10;\n    return 1;\n  }\n  if (DAT_08009fbc < (int)uVar8) {\n    if (DAT_08009fc0 < (int)uVar8) {\n      uVar10 = __subdf3(param_1,param_2,param_1,param_2);\n      param_3[1] = uVar10;\n      *param_3 = uVar10;\n      return 0;\n    }\n    iVar9 = ((int)uVar8 >> 0x14) + -0x416;\n    __aeabi_d2iz();\n    local_40 = __aeabi_i2d();\n    uVar10 = __subdf3(param_1,uVar8 + iVar9 * -0x100000,(int)local_40,\n                      (int)((ulonglong)local_40 >> 0x20));\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08009fc4);\n    __aeabi_d2iz();\n    local_38 = __aeabi_i2d();\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20));\n    local_30 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08009fc4);\n    __aeabi_dcmpeq((int)local_30,(int)((ulonglong)local_30 >> 0x20),0,0);\n    iVar9 = __kernel_rem_pio2(&local_40,param_3,iVar9);\n    if (-1 < (int)param_2) {\n      return iVar9;\n    }\n    *(int *)((int)param_3 + 4) = *(int *)((int)param_3 + 4) + -0x80000000;\n    *(int *)((int)param_3 + 0xc) = *(int *)((int)param_3 + 0xc) + -0x80000000;\n    return -iVar9;\n  }\n  fabs((double)CONCAT44(in_stack_ffffffac,in_stack_ffffffa8));\n  uVar10 = __muldf3();\n  __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08009fcc);\n  iVar9 = __aeabi_d2iz();\n  uVar10 = __aeabi_i2d();\n  uVar4 = (undefined4)((ulonglong)uVar10 >> 0x20);\n  uVar1 = (undefined4)uVar10;\n  uVar10 = __muldf3(uVar1,uVar4,DAT_08009f88,DAT_08009f8c);\n  uVar10 = __subdf3(param_1,extraout_r1,(int)uVar10,(int)((ulonglong)uVar10 >> 0x20));\n  uVar5 = (undefined4)((ulonglong)uVar10 >> 0x20);\n  uVar2 = (undefined4)uVar10;\n  uVar11 = __muldf3(uVar1,uVar4,DAT_08009f90,DAT_08009f94);\n  if ((0x1f < iVar9) || (*(uint *)(PTR_npio2_hw_08009fd0 + (iVar9 + -1) * 4) == uVar8)) {\n    uVar12 = __subdf3(uVar2,uVar5,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n    if ((int)((uVar8 >> 0x14) - ((uint)((int)((ulonglong)uVar12 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    uVar11 = __muldf3(uVar1,uVar4,DAT_0800a190,DAT_0800a194);\n    uVar6 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar10 = __subdf3(uVar2,uVar5,(int)uVar11,uVar6);\n    uVar7 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar3 = (undefined4)uVar10;\n    uVar12 = __subdf3(uVar2,uVar5,uVar3,uVar7);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,uVar6);\n    uVar12 = __muldf3(uVar1,uVar4,DAT_0800a198,DAT_0800a19c);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,\n                      (int)((ulonglong)uVar11 >> 0x20));\n    uVar12 = __subdf3(uVar3,uVar7,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n    if ((int)(((int)uVar8 >> 0x14) - ((uint)((int)((ulonglong)uVar12 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    uVar11 = __muldf3(uVar1,uVar4,DAT_0800a1a0,DAT_0800a1a4);\n    uVar2 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar10 = __subdf3(uVar3,uVar7,(int)uVar11,uVar2);\n    uVar12 = __subdf3(uVar3,uVar7);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,uVar2);\n    uVar12 = __muldf3(uVar1,uVar4,DAT_0800a1a8,DAT_0800a1ac);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,\n                      (int)((ulonglong)uVar11 >> 0x20));\n  }\n  uVar12 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                    (int)((ulonglong)uVar11 >> 0x20));\nLAB_0800a0ce:\n  uStack_4c = (undefined4)((ulonglong)uVar10 >> 0x20);\n  local_50 = (undefined4)uVar10;\n  *param_3 = uVar12;\n  uVar10 = __subdf3(local_50,uStack_4c);\n  uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                    (int)((ulonglong)uVar11 >> 0x20));\n  param_3[1] = uVar10;\n  if ((int)param_2 < 0) {\n    *(int *)param_3 = (int)uVar12;\n    *(int *)((int)param_3 + 4) = (int)((ulonglong)uVar12 >> 0x20) + -0x80000000;\n    *(int *)(param_3 + 1) = (int)uVar10;\n    *(int *)((int)param_3 + 0xc) = (int)((ulonglong)uVar10 >> 0x20) + -0x80000000;\n    iVar9 = -iVar9;\n  }\n  return iVar9;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__aeabi_d2iz",
                "fabs",
                "__subdf3",
                "__aeabi_i2d",
                "__kernel_rem_pio2"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009d78",
            "calling": [
                "sin",
                "cos"
            ],
            "imported": false,
            "current_name": "FUNC_08009d78"
        },
        "FUN_08003826": {
            "renaming": {
                "FUN_08003826": "print_float_as_string_08003826",
                "n": "number",
                "in_r0": "integer_part",
                "iVar1": "is_negative",
                "uVar2": "unused_variable",
                "bVar3": "unused_variable",
                "uVar4": "unused_variable",
                "local_24": "number",
                "uStack_1d": "unused_variable",
                "buf": "buffer",
                "a": "unused_variable",
                "i": "index",
                "decimals": "decimals"
            },
            "code": "void print_float_as_string_08003826(float number) {\n  uint integer_part;\n  int is_negative = __aeabi_fcmplt(number, 0);\n  if (is_negative) {\n    serial_write('-');\n    number = -number;\n  }\n  uint decimals = PTR_settings_08003970[0x3d];\n  while (decimals > 1) {\n    number *= DAT_08003974;\n    decimals -= 0xfe;\n  }\n  if (decimals != 0) {\n    number *= DAT_08003978;\n  }\n  integer_part = __aeabi_f2iz(__addsf3(number, 0x3f000000));\n  uint8_t buffer[PTR_settings_08003970[0x3d] + 1];\n  uint8_t i = 0;\n  buffer[PTR_settings_08003970[0x3d]] = '.';\n  while (integer_part != 0) {\n    if (i == PTR_settings_08003970[0x3d]) {\n      i++;\n    }\n    uint8_t index = i++;\n    buffer[index] = (char)(integer_part % 10) + '0';\n    integer_part /= 10;\n  }\n  while (i < PTR_settings_08003970[0x3d]) {\n    buffer[i++] = '0';\n  }\n  if (i == PTR_settings_08003970[0x3d]) {\n    buffer[i++] = '0';\n  }\n  while (i-- > 0) {\n    serial_write(buffer[i]);\n  }\n}\n",
            "called": [
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_f2iz",
                "serial_write",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003826",
            "calling": [
                "report_realtime_status",
                "report_gcode_parameters",
                "report_grbl_settings",
                "report_gcode_modes"
            ],
            "imported": false,
            "current_name": "print_float_as_string_08003826"
        },
        "FUN_0800923c": {
            "renaming": {
                "FUN_0800923c": "check_if_not_equal_0800923c",
                "in_CY": "is_CY_zero",
                "in_ZR": "is_ZR_nonzero"
            },
            "code": "bool check_if_not_equal_0800923c(void)\n{\n    bool is_CY_zero = __aeabi_cfcmpeq() == 0;\n    bool is_ZR_nonzero = in_ZR != 0;\n    return is_CY_zero || is_ZR_nonzero;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800923c",
            "calling": [
                "mc_arc",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "check_if_not_equal_0800923c"
        },
        "FUN_08002afc": {
            "renaming": {
                "FUN_08002afc": "calculate_entry_speed_08002afc",
                "previous": "previous_block",
                "current": "current_block",
                "next": "next_block",
                "iVar1": "is_entry_speed_less",
                "uVar2": "max_speed_bits",
                "fVar3": "current_entry_speed",
                "acceleration": "max_acceleration",
                "target_velocity": "max_target_velocity",
                "distance": "max_distance",
                "acceleration_00": "max_acceleration_00",
                "target_velocity_00": "max_target_velocity_00",
                "distance_00": "max_distance_00",
                "entry_speed": "current_distance"
            },
            "code": "void calculate_entry_speed_08002afc(block_t *previous_block, block_t *current_block, block_t *next_block) {\n    int is_entry_speed_less;\n    uint max_speed_bits;\n    float current_entry_speed;\n    float max_acceleration;\n    float max_target_velocity;\n    float max_distance;\n    float max_acceleration_00;\n    float max_target_velocity_00;\n    float max_distance_00;\n    float current_distance;\n    \n    if (previous_block != NULL && !previous_block->nominal_length_flag && (is_entry_speed_less = __aeabi_fcmplt(previous_block->entry_speed, current_block->entry_speed))) {\n        current_entry_speed = current_block->entry_speed;\n        max_speed_bits = *(uint *)(PTR_settings_08002ba4 + 0x20) ^ 0x80000000;\n        max_allowable_speed(max_acceleration, max_target_velocity, max_distance);\n        if (!__aeabi_fcmplt(current_entry_speed, max_speed_bits)) {\n            current_entry_speed = current_block->entry_speed;\n        }\n        else {\n            max_allowable_speed(max_acceleration_00, max_target_velocity_00, max_distance_00);\n            current_entry_speed = max_speed_bits;\n        }\n        if (current_entry_speed != current_block->entry_speed) {\n            current_block->entry_speed = current_entry_speed;\n            current_block->recalculate_flag = 1;\n        }\n    }\n}\n",
            "called": [
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "max_allowable_speed"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002afc",
            "calling": [
                "planner_forward_pass"
            ],
            "imported": false,
            "current_name": "calculate_entry_speed_08002afc"
        },
        "FUN_08004c48": {
            "renaming": {
                "FUN_08004c48": "reset_settings_08004c48",
                "reset_all": "reset_all",
                "PTR_settings_08004d0c": "settings",
                "DAT_08004d10": "DEFAULT_VALUE",
                "settings.value1": "value1",
                "settings.value2": "value2",
                "settings.value3": "value3",
                "settings.value13": "value13",
                "settings.value16": "value16",
                "settings.value20": "value20",
                "settings.value28": "value28",
                "settings.value42": "value42",
                "settings.value44": "value44",
                "settings.value52": "value52",
                "settings.value56": "value56",
                "settings.value60": "value60",
                "settings.value61": "value61",
                "settings.value62": "value62"
            },
            "code": "void reset_settings_08004c48(_Bool reset_all)\n{\n    if (reset_all) {\n        PTR_settings_08004d0c.value1 = DAT_08004d10;\n        PTR_settings_08004d0c.value2 = DAT_08004d10;\n        PTR_settings_08004d0c.value3 = DAT_08004d10;\n        PTR_settings_08004d0c.value13 = 10;\n        PTR_settings_08004d0c.value16 = DAT_08004d10;\n        PTR_settings_08004d0c.value20 = DAT_08004d10;\n        PTR_settings_08004d0c.value28 = 0;\n        PTR_settings_08004d0c.value28 |= 2;\n        PTR_settings_08004d0c.value28 |= 0x10;\n        PTR_settings_08004d0c.value42 = DAT_08004d10;\n        PTR_settings_08004d0c.value44 = DAT_08004d10;\n        PTR_settings_08004d0c.value52 = 100;\n        PTR_settings_08004d0c.value56 = 0x3f800000;\n        PTR_settings_08004d0c.value60 = 0x19;\n        PTR_settings_08004d0c.value61 = 3;\n        PTR_settings_08004d0c.value62 = 0x19;\n        write_global_PTR_settings_08004d0c();\n    }\n}",
            "called": [
                "write_global_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c48",
            "calling": [
                "read_global_settings",
                "settings_init"
            ],
            "imported": false,
            "current_name": "reset_settings_08004c48"
        },
        "FUN_080002a0": {
            "renaming": {
                "FUN_080002a0": "delay_in_milliseconds_080002a0",
                "_ms": "milliseconds_to_delay"
            },
            "code": "void delay_in_milliseconds_080002a0(uint milliseconds_to_delay)\n{\n  HAL_Delay(milliseconds_to_delay);\n  return;\n}",
            "called": [
                "HAL_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002a0",
            "calling": [
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "delay_in_milliseconds_080002a0"
        },
        "FUN_08009250": {
            "renaming": {
                "FUN_08009250": "is_not_CY_or_ZR_08009250",
                "in_CY": "is_CY",
                "in_ZR": "in_ZR"
            },
            "code": "bool is_not_CY_or_ZR_08009250(void)\n{\n  bool is_CY = __aeabi_cfrcmple();\n  return !is_CY || (bool)in_ZR;\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009250",
            "calling": [
                "mc_arc",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "is_not_CY_or_ZR_08009250"
        },
        "FUN_0800640c": {
            "renaming": {
                "FUN_0800640c": "set_RCC_MCO_0800640c",
                "RCC_MCOx": "mco_index",
                "RCC_MCOSource": "mco_source",
                "RCC_MCODiv": "mco_div",
                "GPIO_InitStruct": "gpio_init_struct",
                "DAT_080064b0": "dat_1",
                "DAT_080064b4": "dat_2",
                "DAT_080064b8": "dat_3"
            },
            "code": "void set_RCC_MCO_0800640c(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)\n{\n  GPIO_InitTypeDef GPIO_InitStruct;\n  if (RCC_MCOx == 0) {\n    *(uint *)(DAT_080064b0 + 0x30) |= 1;\n    GPIO_InitStruct.Pin = GPIO_PIN_8;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\n    HAL_GPIO_Init(GPIOA,&GPIO_InitStruct);\n    *(uint32_t *)(DAT_080064b0 + 8) = RCC_MCODiv | RCC_MCOSource | (*(uint *)(DAT_080064b0 + 8) & 0xf89fffff);\n  }\n  else {\n    *(uint *)(DAT_080064b0 + 0x30) |= 4;\n    GPIO_InitStruct.Pin = GPIO_PIN_9;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\n    HAL_GPIO_Init(GPIOA,&GPIO_InitStruct);\n    *(uint32_t *)(DAT_080064b0 + 8) = RCC_MCOSource | (RCC_MCODiv << 3) | (*(uint *)(DAT_080064b0 + 8) & 0x7ffffff);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800640c",
            "calling": [],
            "imported": false,
            "current_name": "set_RCC_MCO_0800640c"
        },
        "FUN_0800773e": {
            "renaming": {
                "FUN_0800773e": "do_nothing_0800773e"
            },
            "code": "\nvoid do_nothing_0800773e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800773e",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800773e"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "compare_doubles_08008af0",
                "param_1": "a",
                "param_2": "b",
                "param_3": "unused",
                "param_4": "unused"
            },
            "code": "void compare_doubles_08008af0(double a, double b) {\n    __aeabi_cdcmpeq(a, b);\n    return;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af0",
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "imported": false,
            "current_name": "compare_doubles_08008af0"
        },
        "FUN_08006e1a": {
            "renaming": {
                "FUN_08006e1a": "get_active_irq_08006e1a",
                "IRQn": "irq",
                "uVar1": "active_irq"
            },
            "code": "uint32_t get_active_irq_08006e1a(IRQn_Type irq)\n{\n  uint32_t active_irq;\n  active_irq = NVIC_GetActive(irq);\n  return active_irq;\n}",
            "called": [
                "NVIC_GetActive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e1a",
            "calling": [],
            "imported": false,
            "current_name": "get_active_irq_08006e1a"
        },
        "FUN_080052ac": {
            "renaming": {
                "FUN_080052ac": "update_value_at_address_080052ac",
                "x": "new_value",
                "val": "current_value",
                "*(uint32_t *)(DAT_080052d8 + 0x14)": "target_address",
                "*(uint *)(DAT_080052d8 + 0x14)": "current_value",
                "0xfffffaaf": "mask"
            },
            "code": "void update_value_at_address_080052ac(uint32_t new_value){\n  uint32_t* *(uint32_t *)(DAT_080052d8 + 0x14) = (uint32_t *)(DAT_080052d8 + 0x14);\n  uint32_t *(uint *)(DAT_080052d8 + 0x14) = *(uint32_t *)(DAT_080052d8 + 0x14);\n  uint32_t mask = 0xfffffaaf;\n  \n  **(uint32_t *)(DAT_080052d8 + 0x14) = new_value | (*(uint *)(DAT_080052d8 + 0x14) & mask);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052ac",
            "calling": [
                "st_init",
                "step_pulse_isr",
                "step_delay_isr"
            ],
            "imported": false,
            "current_name": "update_value_at_address_080052ac"
        },
        "FUN_080064bc": {
            "renaming": {
                "FUN_080064bc": "set_dat_080064d0_to_1_080064bc",
                "*DAT_080064d0": "dat_080064d0_pointer"
            },
            "code": "void set_dat_080064d0_to_1_080064bc(void)\n{\n  **DAT_080064d0 = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064bc",
            "calling": [],
            "imported": false,
            "current_name": "set_dat_080064d0_to_1_080064bc"
        },
        "FUN_08008286": {
            "renaming": {
                "FUN_08008286": "receive_data_08008286",
                "data": "received_byte",
                "iVar1": "data_available",
                "c": "N/A",
                "hook_return": "N/A"
            },
            "code": "uint8_t receive_data_08008286(void)\n{\n  uint8_t received_byte;\n  int data_available = usart_tstc();\n  if (data_available)\n  {\n    received_byte = usart_getc();\n    int hook_return = serial_rx_hook(received_byte);\n    if (hook_return == 0)\n    {\n      return received_byte;\n    }\n  }\n  return 0xff;\n}",
            "called": [
                "serial_rx_hook",
                "usart_tstc",
                "usart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008286",
            "calling": [
                "protocol_process"
            ],
            "imported": false,
            "current_name": "receive_data_08008286"
        },
        "FUN_0800b5bc": {
            "renaming": {
                "FUN_0800b5bc": "do_nothing_0800b5bc"
            },
            "code": "\nvoid do_nothing_0800b5bc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5bc",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b5bc"
        },
        "FUN_08008b74": {
            "renaming": {
                "FUN_08008b74": "is_valid_input_08008b74",
                "param_1": "input_one",
                "param_2": "input_two",
                "param_3": "input_three",
                "param_4": "input_four",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int is_valid_input_08008b74(uint32_t input_one, int input_two, uint32_t input_three, int input_four) {\n    int is_first_valid = ((input_two << 1) >> 0x15 != -1) || ((input_one | input_two << 0xc) == 0);\n    int is_second_valid = ((input_four << 1) >> 0x15 != -1) || ((input_three | input_four << 0xc) == 0);\n    if (is_first_valid && is_second_valid) {\n        return 0;\n    }\n    return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b74",
            "calling": [
                "sqrt"
            ],
            "imported": false,
            "current_name": "is_valid_input_08008b74"
        },
        "FUN_0800b524": {
            "renaming": {
                "FUN_0800b524": "add_to_global_list_0800b524",
                "param_1": "action",
                "param_2": "value",
                "param_3": "mutex_ptr",
                "param_4": "global_ptr",
                "puVar1": "mutex_ptr",
                "uVar2": "return_value",
                "uVar3": "mask",
                "iVar4": "global_impure_ptr",
                "iVar5": "list_ptr",
                "uVar6": "list_length"
            },
            "code": "int add_to_global_list_0800b524(int action, int value, int mutex_ptr, int global_ptr) {\n    int global_impure_ptr = *(int*)global_ptr;\n    int list_ptr = *(int*)(global_impure_ptr + 0x148);\n    if (list_ptr == 0) {\n        list_ptr = global_impure_ptr + 0x14c;\n        *(int*)(global_impure_ptr + 0x148) = list_ptr;\n    }\n    uint list_length = *(uint*)(list_ptr + 4);\n    if ((int)list_length < 0x20) {\n        if (action != 0) {\n            int item_ptr = list_ptr + list_length * 4;\n            *(int*)(item_ptr + 0x88) = mutex_ptr;\n            uint mask = 1 << (list_length & 0xff);\n            *(uint*)(list_ptr + 0x188) |= mask;\n            *(int*)(item_ptr + 0x108) = value;\n            if (action == 2) {\n                *(uint*)(list_ptr + 0x18c) |= mask;\n            }\n        }\n        uint* mutex_ptr = (uint*)PTR___atexit_recursive_mutex_0800b5ac;\n        __retarget_lock_release_recursive(*mutex_ptr);\n        return 0;\n    }\n    else {\n        uint* mutex_ptr = (uint*)PTR___atexit_recursive_mutex_0800b5ac;\n        __retarget_lock_release_recursive(*mutex_ptr);\n        return -1;\n    }\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b524",
            "calling": [
                "atexit"
            ],
            "imported": false,
            "current_name": "add_to_global_list_0800b524"
        },
        "FUN_08005214": {
            "renaming": {
                "FUN_08005214": "do_nothing_08005214"
            },
            "code": "\nvoid do_nothing_08005214(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005214",
            "calling": [
                "spindle_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_08005214"
        },
        "FUN_08009818": {
            "renaming": {
                "FUN_08009818": "calculate_result_08009818",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "iVar1": "difference",
                "unaff_r4": "unused_variable",
                "uVar2": "sign_bits",
                "uVar3": "abs_input_4",
                "uVar4": "abs_input_2",
                "uVar5": "unused_variable"
            },
            "code": "void calculate_result_08009818(uint32_t input_1, uint32_t input_2, uint32_t input_3, uint32_t input_4, double input_5) {\n  int difference;\n  uint32_t abs_input_4 = input_4 & 0x7fffffff;\n  uint32_t abs_input_2 = input_2 & 0x7fffffff;\n  if ((MAXIMUM_VALUE < (abs_input_4 | (-input_3 | input_3) >> 0x1f)) || (MAXIMUM_VALUE < (abs_input_2 | (-input_1 | input_1) >> 0x1f))) {\n    add_double(input_3, input_4, input_1, input_2);\n  }\n  else {\n    if ((input_4 + 0xc0100000 | input_3) == 0) {\n      atan(input_5);\n      return;\n    }\n    uint32_t sign_bits = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n    if (((abs_input_2 | input_1) != 0) && ((abs_input_4 | input_3) != 0) && (abs_input_4 != MAXIMUM_VALUE) && (abs_input_2 != MAXIMUM_VALUE)) {\n      difference = (int)(abs_input_2 - abs_input_4) >> 0x14;\n      if (((int)(abs_input_2 - abs_input_4) < 0x3d00000) && ((-1 < (int)input_4 || (difference + 0x3c < 0 == SCARRY4(difference, 0x3c))))) {\n        calculate_division(input_1, input_2, input_3, input_4);\n        double abs_input_4_double = (double)CONCAT44(input_4, input_4);\n        double atan_result = atan(abs_input_4_double);\n      }\n      if (sign_bits != 1) {\n        if (sign_bits == 2) {\n          double sub_result = subtract_double(DAT_08009af0, DAT_08009af4, input_4);\n          subtract_double(DAT_08009af0, DAT_08009af4, (int)sub_result, (int)((unsigned long long)sub_result >> 0x20));\n        }\n        else if (sign_bits != 0) {\n          double sub_result = subtract_double(input_4, DAT_08009af4, DAT_08009af0);\n          subtract_double((int)sub_result, (int)((unsigned long long)sub_result >> 0x20), DAT_08009af0, DAT_08009af4);\n        }\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "__ieee754_atan2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009818",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_result_08009818"
        },
        "FUN_08007ea4": {
            "renaming": {
                "FUN_08007ea4": "set_usart_flag_08007ea4",
                "usart": "usart_ptr",
                "DAT_08007f38": "PTR_DAT_08007f38",
                "DAT_08007f40": "PTR_DAT_08007f40",
                "DAT_08007f44": "PTR_DAT_08007f44",
                "DAT_08007f48": "PTR_DAT_08007f48",
                "DAT_08007f4c": "PTR_DAT_08007f4c",
                "DAT_08007f50": "PTR_DAT_08007f50"
            },
            "code": "void set_usart_flag_08007ea4(USART_TypeDef *usart) {\n    uint32_t *usart_flags = (uint32_t *)DAT_08007f3c;\n    if (usart == DAT_08007f38) {\n        usart_flags[1] |= 0x10;\n    }\n    else if (usart == DAT_08007f40) {\n        usart_flags[1] |= 0x20000;\n    }\n    else if (usart == DAT_08007f44) {\n        usart_flags[1] |= 0x40000;\n    }\n    else if (usart == DAT_08007f48) {\n        usart_flags[1] |= 0x80000;\n    }\n    else if (usart == DAT_08007f4c) {\n        usart_flags[1] |= 0x100000;\n    }\n    else if (usart == DAT_08007f50) {\n        usart_flags[1] |= 0x20;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ea4",
            "calling": [
                "usart_init"
            ],
            "imported": false,
            "current_name": "set_usart_flag_08007ea4"
        },
        "FUN_08007756": {
            "renaming": {
                "FUN_08007756": "toggle_gpio_and_debounce_isr_if_needed_08007756",
                "uVar1": "current_tick_count"
            },
            "code": "void toggle_gpio_and_debounce_isr_if_needed_08007756(void)\n{\n  uint32_t current_tick_count;\n  uint32_t ticks;\n  current_tick_count = HAL_GetTick();\n  if ((current_tick_count & 0x1ff) == 0) {\n    gpio_toggle(0x3c);\n  }\n  if ((current_tick_count & 0xf) == 0) {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_IncTick",
                "gpio_toggle",
                "debounce_isr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007756",
            "calling": [],
            "imported": false,
            "current_name": "toggle_gpio_and_debounce_isr_if_needed_08007756"
        },
        "FUN_0800b520": {
            "renaming": {
                "FUN_0800b520": "do_nothing_0800b520"
            },
            "code": "\nvoid do_nothing_0800b520(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b520",
            "calling": [
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b520"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "do_nothing_0800774a"
            },
            "code": "\nvoid do_nothing_0800774a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800774a"
        },
        "FUN_0800423c": {
            "renaming": {
                "FUN_0800423c": "print_grbl_settings_view_0800423c",
                "PTR_s_____view_Grbl_settings______view_0800424c": "grbl_settings_view_string"
            },
            "code": "void print_grbl_settings_view_0800423c(void)\n{\n  printPgmString(PTR_s_____view_Grbl_settings______view_0800424c);\n  return;\n}",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800423c",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_grbl_settings_view_0800423c"
        },
        "FUN_080064d4": {
            "renaming": {
                "FUN_080064d4": "initialize_data_080064d4",
                "*DAT_080064e8": "data_pointer"
            },
            "code": "void initialize_data_080064d4(void)\n{\n    **DAT_080064e8 = 0;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064d4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_080064d4"
        },
        "FUN_08006e38": {
            "renaming": {
                "FUN_08006e38": "update_clk_source_08006e38",
                "CLKSource": "clk_source",
                "*DAT_08006e6c": "data_pointer"
            },
            "code": "void update_clk_source_08006e38(uint32_t clk_source) {\n    if (clk_source == 4) {\n        *DAT_08006e6c |= 4;\n    }\n    else {\n        *DAT_08006e6c &= 0xfffffffb;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e38",
            "calling": [],
            "imported": false,
            "current_name": "update_clk_source_08006e38"
        },
        "FUN_08009264": {
            "renaming": {
                "FUN_08009264": "is_input_null_terminated_08009264",
                "in_CY": "input_string"
            },
            "code": "bool is_input_null_terminated_08009264(char input_string[]) {\n  return input_string[strlen(input_string)-1] == '\\0';\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009264",
            "calling": [
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "is_input_null_terminated_08009264"
        },
        "FUN_08007e08": {
            "renaming": {
                "FUN_08007e08": "initialize_timers_08007e08",
                "step_timer_init": "initialize_step_timer",
                "g540_timer_init": "initialize_g540_timer",
                "g540_timer_start": "start_g540_timer"
            },
            "code": "void initialize_timers_08007e08(void)\n{\n  initialize_step_timer();\n  initialize_g540_timer();\n  start_g540_timer();\n  return;\n}",
            "called": [
                "g540_timer_start",
                "g540_timer_init",
                "step_timer_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e08",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_timers_08007e08"
        },
        "FUN_08002fac": {
            "renaming": {
                "FUN_08002fac": "is_block_buffer_tail_equal_to_next_buffer_head_08002fac",
                "*PTR_block_buffer_tail_08002fcc": "*block_buffer_tail_ptr",
                "*PTR_next_buffer_head_08002fd0": "*next_buffer_head_ptr"
            },
            "code": "bool is_block_buffer_tail_equal_to_next_buffer_head_08002fac(void)\n{\n    uint8_t block_buffer_tail = *PTR_block_buffer_tail_08002fcc;\n    uint8_t next_buffer_head = *PTR_next_buffer_head_08002fd0;\n    return block_buffer_tail == next_buffer_head;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fac",
            "calling": [
                "mc_line"
            ],
            "imported": false,
            "current_name": "is_block_buffer_tail_equal_to_next_buffer_head_08002fac"
        },
        "FUN_08005b04": {
            "renaming": {
                "FUN_08005b04": "set_bit_in_dat_08005b1c_08005b04",
                "DAT_08005b1c": "dat_ptr",
                "uint": "unsigned_int",
                "*": "pointer",
                "+": "plus",
                "|": "bitwise_or",
                "=": "assign",
                "return": "return_statement"
            },
            "code": "void set_bit_in_dat_08005b1c_08005b04(void)\n{\n    uint* data_ptr = (uint*)(DAT_08005b1c + 4);\n    *data_ptr = *data_ptr | 1;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b04",
            "calling": [],
            "imported": false,
            "current_name": "set_bit_in_dat_08005b1c_08005b04"
        },
        "FUN_080002b6": {
            "renaming": {
                "FUN_080002b6": "wait_microseconds_080002b6",
                "_us": "microseconds_to_wait",
                "uVar1": "current_microseconds",
                "bVar2": "timeout_reached",
                "uVar3": "start_microseconds",
                "uVar4": "current_microseconds",
                "timeout": "timeout_microseconds"
            },
            "code": "void wait_microseconds_080002b6(uint microseconds_to_wait) {\n  uint current_microseconds;\n  bool timeout_reached;\n  uint64_t start_microseconds = get_current_usecs();\n  do {\n    current_microseconds = (uint)(get_current_usecs() >> 0x20);\n    uint64_t timeout_microseconds = start_microseconds + microseconds_to_wait;\n    timeout_reached = timeout_microseconds._4_4_ <= current_microseconds;\n    if (current_microseconds == timeout_microseconds._4_4_) {\n      timeout_reached = (uint)timeout_microseconds <= (uint)get_current_usecs();\n    }\n  } while (!timeout_reached);\n}",
            "called": [
                "get_current_usecs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002b6",
            "calling": [],
            "imported": false,
            "current_name": "wait_microseconds_080002b6"
        },
        "FUN_080075c8": {
            "renaming": {
                "FUN_080075c8": "calculate_system_core_clock_080075c8",
                "pllm": "pllm",
                "pllsource": "pllsource",
                "pllp": "pllp",
                "tmp": "tmp",
                "pllvco": "pllvco",
                "uVar1": "system_clock_source",
                "DAT_080076b4": "DAT_080076b4",
                "DAT_080076b8": "PTR_SystemCoreClock_080076b8",
                "DAT_080076bc": "DAT_080076bc",
                "DAT_080076c0": "DAT_080076c0",
                "PTR_SystemCoreClock_080076b8": "PTR_SystemCoreClock_080076b8",
                "PTR_AHBPrescTable_080076c4": "PTR_AHBPrescTable_080076c4"
            },
            "code": "void calculate_system_core_clock_080075c8(void)\n{\n    uint system_clock_source = *(uint *)(DAT_080076b4 + 8) & 0xc;\n    uint32_t pllm = DAT_080076bc;\n    uint32_t pllsource = DAT_080076c0;\n    uint32_t pllp;\n    uint32_t tmp;\n    uint32_t pllvco;\n    if (system_clock_source == 8) {\n        uint pllm_value = *(uint *)(DAT_080076b4 + 4) & 0x3f;\n        if ((*(uint *)(DAT_080076b4 + 4) >> 0x16 & 1) == 0) {\n            pllvco = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (pllm / pllm_value);\n        }\n        else {\n            pllvco = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (pllsource / pllm_value);\n        }\n        uint ahb_prescaler = *(uint *)(DAT_080076b4 + 8) >> 4 & 0xf;\n        uint ahb_prescaler_value = PTR_AHBPrescTable_080076c4[ahb_prescaler];\n        uint system_core_clock_value = pllvco / (((*(uint *)(DAT_080076b4 + 4) >> 0x10 & 3) + 1) * 2);\n        *(uint *)DAT_080076b8 = system_core_clock_value >> ahb_prescaler_value;\n    }\n    else if (system_clock_source == 0) {\n        *(uint *)DAT_080076b8 = pllm;\n    }\n    else if (system_clock_source == 4) {\n        *(uint *)DAT_080076b8 = pllsource;\n    }\n    else {\n        *(uint *)DAT_080076b8 = pllm;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075c8",
            "calling": [],
            "imported": false,
            "current_name": "calculate_system_core_clock_080075c8"
        }
    },
    "used_tokens": 218667,
    "layers": [
        [
            "FUN_0800192c",
            "FUN_08006950",
            "FUN_08008ba0",
            "FUN_08005b90",
            "FUN_080071d0",
            "FUN_08008e60",
            "FUN_08005984",
            "FUN_08006718",
            "FUN_08007a10",
            "FUN_0800856c",
            "FUN_08008b00",
            "FUN_0800585c",
            "FUN_0800597c",
            "FUN_08009314",
            "FUN_08009798",
            "FUN_08007930",
            "FUN_08000188",
            "FUN_08008e70",
            "FUN_08009318",
            "FUN_080018cc",
            "FUN_080079e0",
            "FUN_08006a58",
            "FUN_08005a84",
            "FUN_08008b10",
            "FUN_0800736c",
            "FUN_08008c30",
            "FUN_08007bf0",
            "FUN_08008590",
            "FUN_08007ad0",
            "FUN_080039a0",
            "FUN_08009204",
            "FUN_080029d8",
            "FUN_08007c5e",
            "FUN_08005760",
            "FUN_08008b24",
            "FUN_0800587c",
            "FUN_08008a02",
            "FUN_0800369c",
            "FUN_08005a98",
            "FUN_080044e8",
            "FUN_08006c9c",
            "FUN_0800195c",
            "FUN_08009214",
            "FUN_08004dd2",
            "FUN_08005778",
            "FUN_080028bc",
            "FUN_08006628",
            "FUN_08008b38",
            "FUN_0800738e",
            "FUN_080092c4",
            "FUN_08008250",
            "FUN_0800184c",
            "FUN_08005ad4",
            "FUN_08005b3c",
            "FUN_08006ce0",
            "FUN_08006d4a",
            "FUN_08000374",
            "FUN_080037fc",
            "FUN_08007dd8",
            "FUN_0800a1bc",
            "FUN_0800525c",
            "FUN_080073d4",
            "FUN_08006dfe",
            "FUN_08006d66",
            "FUN_08006e88",
            "FUN_0800b4f0",
            "FUN_080036f0",
            "FUN_08005c74",
            "FUN_0800375c",
            "FUN_08009990",
            "FUN_08005b58",
            "FUN_08007e58",
            "FUN_080059f8",
            "FUN_08009194",
            "FUN_08003f34",
            "FUN_080095b8",
            "FUN_08006cf6",
            "FUN_08002ef0",
            "FUN_08001d4c",
            "FUN_08000268",
            "FUN_0800918c",
            "FUN_08003778",
            "FUN_0800b3dc",
            "FUN_080046d0",
            "FUN_08006d72",
            "FUN_0800756c",
            "FUN_0800691c",
            "FUN_080001f8",
            "FUN_08002f74",
            "FUN_0800b3e8",
            "FUN_08006a18",
            "FUN_08002c18",
            "FUN_08006ac0",
            "FUN_0800919c",
            "FUN_0800b2cc",
            "FUN_0800854c",
            "FUN_08008e44",
            "FUN_0800733e",
            "FUN_08005aec",
            "FUN_08005b74",
            "FUN_0800583c",
            "FUN_08001e98",
            "FUN_080069e4",
            "FUN_0800b2d4",
            "FUN_08008e3c",
            "FUN_08009654",
            "FUN_08007bc2",
            "FUN_080035ec",
            "FUN_08006c70",
            "FUN_080068bc",
            "FUN_08006d98",
            "FUN_08005a68",
            "FUN_080079c0",
            "FUN_0800b2e0",
            "FUN_08002908",
            "FUN_08007c40",
            "FUN_080094c0",
            "FUN_08006b54",
            "FUN_08007e84",
            "FUN_080057e4",
            "FUN_08006d8a",
            "FUN_0800b2e8",
            "FUN_08007520",
            "FUN_08007884",
            "FUN_08004250",
            "FUN_08006dc4",
            "FUN_08007402",
            "FUN_08002870",
            "FUN_08000210",
            "FUN_08008a64",
            "FUN_08005900",
            "FUN_08002638",
            "FUN_08005bac",
            "FUN_080051b4",
            "FUN_08005c30",
            "FUN_0800056c",
            "FUN_08002f24",
            "FUN_080059b4",
            "FUN_08006c04",
            "FUN_08002e08",
            "FUN_08005bc4",
            "FUN_08006680",
            "FUN_08000340",
            "FUN_08004bf4",
            "FUN_08004d7c",
            "FUN_08009278",
            "FUN_080004fc",
            "FUN_08000220",
            "FUN_08005238",
            "FUN_08007da8",
            "FUN_08004148",
            "FUN_08004940",
            "FUN_08008a74",
            "FUN_08002fd4",
            "FUN_08002408",
            "FUN_08003618",
            "FUN_08005b20",
            "FUN_08007d08",
            "FUN_080091fc",
            "FUN_080058a0",
            "FUN_08008a6c",
            "FUN_080036c6",
            "FUN_08008190",
            "FUN_080074c8",
            "FUN_0800b430",
            "FUN_08004030",
            "FUN_08005360",
            "FUN_08003980",
            "FUN_08006de0",
            "FUN_080052dc",
            "FUN_080064ec",
            "FUN_08006ba0",
            "FUN_080003ec",
            "FUN_08002896",
            "FUN_080001ac",
            "FUN_08003740",
            "FUN_08000478",
            "FUN_08006d2e",
            "FUN_08007e1c",
            "FUN_0800adf0",
            "FUN_08003a74",
            "FUN_08006b00",
            "FUN_0800b4d0",
            "FUN_08007f54",
            "FUN_08003b98",
            "FUN_080024c4",
            "FUN_08002f40",
            "FUN_080025e8",
            "FUN_08005ac4",
            "FUN_08005250",
            "FUN_08007430",
            "FUN_08007310",
            "FUN_08007436",
            "FUN_08005814",
            "FUN_08005bdc",
            "FUN_080085d4",
            "FUN_08006e70",
            "FUN_080002f0",
            "FUN_0800778c",
            "FUN_08001ddc",
            "FUN_080069b4",
            "FUN_0800b4e4",
            "FUN_08007720",
            "FUN_08009228",
            "FUN_08007c7c",
            "FUN_08007726",
            "FUN_08007b70",
            "FUN_08004d2c",
            "FUN_080066cc",
            "FUN_080018fc",
            "FUN_080039bc",
            "FUN_0800618c",
            "FUN_08006998",
            "FUN_080004ac",
            "FUN_080078f4",
            "FUN_080041a0",
            "FUN_08008bf0",
            "FUN_0800771a",
            "FUN_08003a18",
            "FUN_08005790",
            "FUN_08007854",
            "FUN_08004900",
            "FUN_08004228",
            "FUN_080076c8",
            "FUN_08006a8c",
            "FUN_0800772c",
            "FUN_0800283a",
            "FUN_0800881c",
            "FUN_08004bc0",
            "FUN_08008b4c",
            "FUN_08004c2a",
            "FUN_0800826a",
            "FUN_08008b60",
            "FUN_08005324",
            "FUN_08000310",
            "FUN_08007a70",
            "FUN_0800b5b0",
            "FUN_08002978",
            "FUN_08003826",
            "FUN_0800923c",
            "FUN_08002afc",
            "FUN_08004c48",
            "FUN_080002a0",
            "FUN_08009250",
            "FUN_0800640c",
            "FUN_08008af0",
            "FUN_08006e1a",
            "FUN_080052ac",
            "FUN_080064bc",
            "FUN_08008286",
            "FUN_08008b74",
            "FUN_0800b524",
            "FUN_08009818",
            "FUN_08007ea4",
            "FUN_08007756",
            "FUN_0800423c",
            "FUN_080064d4",
            "FUN_08006e38",
            "FUN_08009264",
            "FUN_08007e08",
            "FUN_08002fac",
            "FUN_08005b04",
            "FUN_080002b6",
            "FUN_080075c8"
        ],
        [
            "FUN_08002edc",
            "FUN_080096e8",
            "FUN_08002ba8",
            "FUN_08009410",
            "FUN_080098d0",
            "FUN_0800981c",
            "FUN_08002a94",
            "FUN_08007540"
        ]
    ],
    "locked_functions": []
}