{
    "functions": {
        "FUN_080050fc": {
            "renaming": {
                "FUN_080050fc": "parse_and_print_format_string_080050fc",
                "param_1": "mem_ptr",
                "param_2": "stream",
                "param_3": "format_str",
                "param_4": "arg_ptr",
                "bVar1": "found_number",
                "puVar2": "char_set",
                "iVar3": "num_len",
                "iVar4": "ssputs_result",
                "pvVar5": "char_ptr",
                "puVar6": "printf_result",
                "piVar7": "arg_index",
                "pbVar8": "format_ptr",
                "pbVar9": "prev_format_ptr",
                "unaff_r9": "malloc_result_ptr",
                "local_8c": "arg_index_ptr",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "arg_width",
                "local_74": "total_chars_printed",
                "local_70": "specifier",
                "local_6f": "space_char",
                "local_6e": "plus_char",
                "local_45": "prefix_char",
                "local_30": "zero_char"
            },
            "code": "\nint parse_and_print_format_string_080050fc(undefined4 *mem_ptr,int *stream,byte *format_str,int *arg_ptr)\n\n{\n  bool found_number;\n  undefined *char_set;\n  int num_len;\n  int ssputs_result;\n  void *char_ptr;\n  undefined4 *printf_result;\n  int *arg_index;\n  byte *format_ptr;\n  byte *prev_format_ptr;\n  undefined4 *malloc_result_ptr;\n  int *arg_index_ptr;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int arg_width;\n  int total_chars_printed;\n  byte specifier;\n  undefined space_char;\n  undefined plus_char;\n  undefined prefix_char;\n  undefined4 zero_char;\n  \n  arg_index_ptr = arg_ptr;\n  if (((int)((uint)*(ushort *)(stream + 3) << 0x18) < 0) && (stream[4] == 0)) {\n    num_len = _malloc_r(mem_ptr,0x40);\n    *stream = num_len;\n    stream[4] = num_len;\n    if (num_len == 0) {\n      *mem_ptr = 0xc;\n      return -1;\n    }\n    stream[5] = 0x40;\n  }\n  total_chars_printed = 0;\n  space_char = 0x20;\n  plus_char = 0x30;\n  format_ptr = format_str;\nLAB_08005146:\n  prev_format_ptr = format_ptr;\n  if (*prev_format_ptr != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  format_ptr = prev_format_ptr + 1;\n  if (*prev_format_ptr != 0x25) goto LAB_08005146;\nLAB_08005150:\n  num_len = (int)prev_format_ptr - (int)format_str;\n  if (num_len != 0) {\n    ssputs_result = __ssputs_r(mem_ptr,stream,format_str,num_len);\n    if (ssputs_result == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(stream + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return total_chars_printed;\n    }\n    total_chars_printed = total_chars_printed + num_len;\n  }\n  if (*prev_format_ptr == 0) goto LAB_080052ac;\n  flags = 0;\n  arg_width = 0;\n  precision = -1;\n  width = 0;\n  prefix_char = 0;\n  zero_char = 0;\n  format_ptr = prev_format_ptr + 1;\n  while( true ) {\n    char_ptr = memchr(PTR_DAT_080052d0,(uint)*format_ptr,5);\n    char_set = PTR_DAT_080052d4;\n    format_str = format_ptr + 1;\n    if (char_ptr == (void *)0x0) break;\n    flags = 1 << ((int)char_ptr - (int)PTR_DAT_080052d0 & 0xffU) | flags;\n    format_ptr = format_str;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    prefix_char = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    prefix_char = 0x2b;\n  }\n  if (*format_ptr == 0x2a) {\n    arg_index = arg_index_ptr + 1;\n    num_len = *arg_index_ptr;\n    arg_index_ptr = arg_index;\n    if (-1 < num_len) goto LAB_080051ee;\n    arg_width = -num_len;\n    flags = flags | 2;\n  }\n  else {\n    found_number = false;\n    num_len = arg_width;\n    format_str = format_ptr;\n    while( true ) {\n      if (9 < *format_str - 0x30) break;\n      num_len = num_len * 10 + (*format_str - 0x30);\n      found_number = true;\n      format_str = format_str + 1;\n    }\n    if (found_number) {\nLAB_080051ee:\n      arg_width = num_len;\n    }\n  }\n  if (*format_str == 0x2e) {\n    if (format_str[1] == 0x2a) {\n      format_str = format_str + 2;\n      arg_index = arg_index_ptr + 1;\n      precision = *arg_index_ptr;\n      arg_index_ptr = arg_index;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      found_number = false;\n      num_len = 0;\n      precision = 0;\n      while( true ) {\n        format_str = format_str + 1;\n        if (9 < *format_str - 0x30) break;\n        num_len = num_len * 10 + (*format_str - 0x30);\n        found_number = true;\n      }\n      if (found_number) {\n        precision = num_len;\n      }\n    }\n  }\n  char_ptr = memchr(PTR_DAT_080052d4,(uint)*format_str,3);\n  if (char_ptr != (void *)0x0) {\n    format_str = format_str + 1;\n    flags = flags | 0x40 << ((int)char_ptr - (int)char_set & 0xffU);\n  }\n  specifier = *format_str;\n  format_str = format_str + 1;\n  char_ptr = memchr(PTR_s_efgEFG_080052d8,(uint)specifier,6);\n  if (char_ptr == (void *)0x0) {\n    printf_result = (undefined4 *)_printf_i(mem_ptr,&flags,stream,DAT_080052e0,&arg_index_ptr);\n  }\n  else {\n    printf_result = mem_ptr;\n    if (DAT_080052dc == 0) {\n      arg_index_ptr = (int *)(((int)arg_index_ptr + 7U & 0xfffffff8) + 8);\n      printf_result = malloc_result_ptr;\n      goto LAB_08005260;\n    }\n  }\n  if (printf_result == (undefined4 *)0xffffffff) goto LAB_080052ac;\nLAB_08005260:\n  total_chars_printed = total_chars_printed + (int)printf_result;\n  format_ptr = format_str;\n  malloc_result_ptr = printf_result;\n  goto LAB_08005146;\n}\n\n",
            "called": [
                "__ssputs_r",
                "memchr",
                "_printf_i",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080050fc",
            "calling": [
                "siprintf"
            ],
            "imported": false,
            "current_name": "parse_and_print_format_string_080050fc"
        },
        "FUN_08003320": {
            "renaming": {
                "FUN_08003320": "updateDeltaT_08003320",
                "_deltat": "deltaTime",
                "in_r0": "zero",
                "PTR_deltat_08003328": "deltaTimePointer"
            },
            "code": "void updateDeltaT_08003320(float deltaTime) {\n  *(float *)deltaTime = 0.0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003320",
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "updateDeltaT_08003320"
        },
        "FUN_08004410": {
            "renaming": {
                "FUN_08004410": "send_attitude_data_08004410",
                "local_10": "attitude_data",
                "local_c": "frame_data",
                "in_r1": "input_register_1"
            },
            "code": "void send_attitude_data_08004410(void)\n{\n  uint16_t attitude_data = *(uint16_t *)PTR_msp_txf_attitude_08004430;\n  uint32_t frame_data = (in_r1 & 0xffff0000) | (uint32_t)attitude_data;\n  MSP_SendFrame('l', (uint8_t *)&attitude_data, 6);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004410",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_attitude_data_08004410"
        },
        "FUN_08003ef2": {
            "renaming": {
                "FUN_08003ef2": "initializeCircularBuffer_08003ef2",
                "cb": "circularBuffer",
                "iVar1": "i"
            },
            "code": "void initializeCircularBuffer_08003ef2(CircularBuffer *cb)\n{\n  int i = 0;\n  cb->head = 0;\n  cb->tail = 0;\n  cb->size = 0;\n  do {\n    cb->buffer[i] = '\\0';\n    i++;\n  } while (i != 2048);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ef2",
            "calling": [
                "serialFlush"
            ],
            "imported": false,
            "current_name": "initializeCircularBuffer_08003ef2"
        },
        "FUN_08001264": {
            "renaming": {
                "FUN_08001264": "configure_gpio_pin_08001264",
                "GPIOx": "GPIO_Port",
                "GPIO_Init": "GPIO_Init",
                "puVar1": "config_reg",
                "uVar2": "alternate_function_1",
                "uVar3": "alternate_function_2",
                "uVar4": "config_bits",
                "uVar5": "pin_mask",
                "uVar6": "mode",
                "iVar7": "alternate_function_index",
                "uVar8": "i",
                "uVar9": "temp",
                "uVar10": "alternate_function_3",
                "tmpreg": "temp_reg"
            },
            "code": "void configure_gpio_pin_08001264(GPIO_TypeDef *GPIO_Port, GPIO_InitTypeDef *GPIO_Init)\n{\n  uint32_t pin_mask;\n  uint32_t speed_bits;\n  uint32_t pull_bits;\n  uint32_t mode_bits;\n  uint32_t config_bits;\n  uint32_t reg_offset;\n  uint32_t cr_reg;\n  uint32_t cr_shift;\n  uint32_t cr_reg_mask;\n  uint32_t mode;\n  uint32_t i;\n  for (i = 0; i < 16; i++) {\n    pin_mask = 1 << i;\n    if (pin_mask & GPIO_Init->Pin) {\n      mode = GPIO_Init->Mode;\n      if (mode == GPIO_MODE_AF_OD || mode == GPIO_MODE_AF_PP) {\n        config_bits = GPIO_Init->Alternate;\n        if (i < 8) {\n          reg_offset = 0;\n          cr_shift = i * 4;\n          cr_reg = (uint32_t)&GPIO_Port->CRL;\n        } else {\n          reg_offset = 8;\n          cr_shift = (i - 8) * 4;\n          cr_reg = (uint32_t)&GPIO_Port->CRH;\n        }\n        cr_reg_mask = ~(0xFU << cr_shift);\n        config_bits <<= cr_shift;\n        config_bits &= 0xFU << cr_shift;\n        cr_reg &= cr_reg_mask;\n        cr_reg |= config_bits;\n        if (mode == GPIO_MODE_AF_PP) {\n          GPIO_Port->BSRR = pin_mask;\n        }\n      } else {\n        speed_bits = GPIO_Init->Speed;\n        if (mode == GPIO_MODE_INPUT || mode == GPIO_MODE_ANALOG) {\n          pull_bits = GPIO_Init->Pull;\n          if (pull_bits == GPIO_NOPULL) {\n            pull_bits = GPIO_PULLUP;\n          }\n          config_bits = pull_bits;\n        } else {\n          if (speed_bits == GPIO_SPEED_FREQ_HIGH) {\n            config_bits = GPIO_CNF_OUTPUT_PUSHPULL | GPIO_MODE_OUTPUT_50_MHZ;\n          } else {\n            config_bits = GPIO_CNF_OUTPUT_PUSHPULL | GPIO_MODE_OUTPUT_2_MHZ;\n          }\n          if (mode == GPIO_MODE_OUTPUT_OD) {\n            config_bits |= GPIO_MODE_OUTPUT_OD;\n          }\n        }\n        if (i < 8) {\n          reg_offset = 0;\n          cr_shift = i * 4;\n          cr_reg = (uint32_t)&GPIO_Port->CRL;\n        } else {\n          reg_offset = 8;\n          cr_shift = (i - 8) * 4;\n          cr_reg = (uint32_t)&GPIO_Port->CRH;\n        }\n        cr_reg_mask = ~(0xFU << cr_shift);\n        config_bits <<= cr_shift;\n        config_bits &= 0xFU << cr_shift;\n        cr_reg &= cr_reg_mask;\n        cr_reg |= config_bits;\n      }\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001264",
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_TIM_MspPostInit",
                "HAL_I2C_MspInit"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_08001264"
        },
        "FUN_080058fc": {
            "renaming": {
                "FUN_080058fc": "calculate_result_080058fc",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "uVar1": "result1",
                "extraout_r1": "result2",
                "extraout_r1_00": "result3",
                "unaff_r4": "temp_var1",
                "iVar2": "temp_int1",
                "uVar3": "temp_uint1",
                "uVar4": "positive_input2",
                "uVar6": "positive_input4",
                "uVar7": "result",
                "uVar8": "sub_result",
                "DAT_08006204": "constant1",
                "DAT_08006200": "constant2",
                "DAT_08006220": "constant3",
                "DAT_080061fc": "constant4",
                "DAT_080061f8": "constant5",
                "DAT_080061ec": "constant6",
                "DAT_080061e8": "constant7",
                "DAT_080061f4": "constant8",
                "DAT_080061f0": "constant9",
                "DAT_0800621c": "constant10",
                "DAT_08006218": "constant11",
                "DAT_080061e4": "constant12",
                "DAT_080061e0": "constant13",
                "DAT_08006210": "constant14",
                "DAT_08006214": "constant15",
                "DAT_08006208": "constant16",
                "DAT_0800620c": "constant17",
                "fabs": "absolute_value",
                "atan": "arc_tangent",
                "__divdf3": "double_division",
                "__subdf3": "double_subtraction",
                "__aeabi_dadd": "double_addition",
                "SCARRY4": "signed_overflow_check"
            },
            "code": "undefined8 calculate_result_080058fc(uint input1, uint input2, uint input3, uint input4, double input5) {\n  uint positive_input4 = input4 & 0x7fffffff;\n  uint positive_input2 = input2 & 0x7fffffff;\n  double result;\n  int temp_int;\n  uint temp_uint;\n  if ((DAT_08006220 < (positive_input4 | (-input3 | input3) >> 0x1f)) || (DAT_08006220 < (positive_input2 | (-input1 | input1) >> 0x1f))) {\n    result = __aeabi_dadd(input1, input2);\n    return result;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    atan(input5);\n    result = CONCAT44(extraout_r1, input1);\n    return result;\n  }\n  uint temp_uint_2 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((input1 | positive_input2) == 0) {\n    if (temp_uint_2 == 2) {\n      result = CONCAT44(DAT_080061fc, DAT_080061f8);\n      return result;\n    }\n    if (temp_uint_2 != 3) {\n      result = CONCAT44(input2, input1);\n      return result;\n    }\n  }\n  else {\n    if ((input3 | positive_input4) != 0) {\n      if (positive_input4 == DAT_08006220) {\n        if (positive_input2 == positive_input4) {\n          if (temp_uint_2 == 2) {\n            result = CONCAT44(DAT_080061ec, DAT_080061e8);\n            return result;\n          }\n          if (temp_uint_2 == 3) {\n            result = CONCAT44(DAT_080061f4, DAT_080061f0);\n            return result;\n          }\n          if (temp_uint_2 != 1) {\n            result = CONCAT44(DAT_0800621c, DAT_08006218);\n            return result;\n          }\n          result = CONCAT44(DAT_080061e4, DAT_080061e0);\n          return result;\n        }\n        if (temp_uint_2 == 2) {\n          result = CONCAT44(DAT_080061fc, DAT_080061f8);\n          return result;\n        }\n        if (temp_uint_2 == 3) {\n          result = (double)CONCAT44(DAT_08006204, DAT_08006200);\n          return result;\n        }\n        if (temp_uint_2 == 1) {\n          result = -9223372036854775808;\n          return result;\n        }\n        result = 0;\n        return result;\n      }\n      if (positive_input2 != DAT_08006220) {\n        int difference = (int)(positive_input2 - positive_input4) >> 0x14;\n        uint div_result;\n        if (difference < 0x3d) {\n          if (((int)input4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference, 0x3c))) {\n            div_result = 0;\n            temp_int = 0;\n          }\n          else {\n            div_result = __divdf3(input1, input2);\n            fabs((double)CONCAT44(unaff_r4, input4));\n            atan((double)CONCAT44(unaff_r4, input4));\n            temp_int = extraout_r1_00;\n          }\n        }\n        if (temp_uint_2 != 1) {\n          if (temp_uint_2 == 2) {\n            double sub_result = __subdf3(div_result, temp_int, DAT_08006208, DAT_0800620c);\n            result = CONCAT44(DAT_080061fc, DAT_080061f8);\n            result = __subdf3((int)result, (int)((ulonglong)result >> 0x20), (int)sub_result, (int)((ulonglong)sub_result >> 0x20));\n            return result;\n          }\n          if (temp_uint_2 == 0) {\n            result = CONCAT44(temp_int, div_result);\n            return result;\n          }\n          double sub_result = __subdf3(div_result, temp_int, DAT_08006208, DAT_0800620c);\n          result = __subdf3((int)result, (int)((ulonglong)result >> 0x20), (int)sub_result, (int)((ulonglong)sub_result >> 0x20));\n          result = CONCAT44(DAT_080061fc, DAT_080061f8);\n          return result;\n        }\n        result = CONCAT44(temp_int + -0x80000000, div_result);\n        return result;\n      }\n    }\n    result = CONCAT44(DAT_08006214, DAT_08006210);\n    if ((int)input2 < 0) {\n      result = CONCAT44(DAT_080061dc, DAT_080061d8);\n    }\n  }\n  return result;\n}",
            "called": [
                "__ieee754_atan2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058fc",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_result_080058fc"
        },
        "FUN_080070b0": {
            "renaming": {
                "FUN_080070b0": "calculate_080070b0",
                "__x": "input",
                "in_r0": "lower_bits",
                "in_r1": "upper_bits",
                "iVar1": "sign_bit",
                "uVar2": "lower_bits_of_sum",
                "uVar3": "upper_bits_of_sum",
                "uVar4": "shift_amount",
                "uVar5": "biased_exponent",
                "dVar6": "result",
                "in_d0": "input_copy",
                "uVar7": "sum",
                "PTR_TWO52_080071b8": "constant_pointer",
                "DAT_080071bc": "constant"
            },
            "code": "double calculate_080070b0(double input)\n{\n    int exponent = ((int)(*(unsigned int *)&input >> 20u) & 0x7FF) - 1023;\n    if (exponent < 20 && exponent >= -1)\n    {\n        if (exponent < 0)\n        {\n            if ((*(unsigned int *)&input & 0x7FFFFFFF | *(unsigned int *)&input >> 32) == 0)\n                return input;\n            unsigned int mantissa = (*(unsigned int *)&input & 0xFFFFF | 0x100000);\n            mantissa >>= (1 - exponent);\n            return (double)(*(unsigned int *)&input & 0x80000000 ? -mantissa : mantissa);\n        }\n        else\n        {\n            *(unsigned int *)&input &= 0xFFFFFFFF << 20;\n            *(unsigned int *)&input |= 0x3FF00000;\n            *(unsigned int *)&input += (unsigned int)(exponent << 20);\n            return input;\n        }\n    }\n    else if (exponent == 1024)\n    {\n        return input + input;\n    }\n    else\n    {\n        return 0.0;\n    }\n}",
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080070b0",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "calculate_080070b0"
        },
        "FUN_08001028": {
            "renaming": {
                "FUN_08001028": "string_is_empty_08001028",
                "in_CY": "input_char"
            },
            "code": "bool string_is_empty_08001028(void)\n{\n  char input_char;\n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001028",
            "calling": [
                "PID_Update",
                "AHRS_GetYaw",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "string_is_empty_08001028"
        },
        "FUN_080006ac": {
            "renaming": {
                "FUN_080006ac": "convert_bits_to_double_080006ac",
                "param_1": "bits1",
                "param_2": "bits2",
                "param_3": "bits3",
                "param_4": "bits4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp3",
                "uVar3": "temp4",
                "in_r12": "mask",
                "bVar4": "is_zero",
                "mask": "mask",
                "shift_count": "shift_count",
                "is_zero": "is_zero",
                "is_denormal": "is_denormal",
                "is_nan_or_inf": "is_nan_or_inf",
                "is_negative": "is_negative",
                "is_special": "is_special"
            },
            "code": "ulonglong convert_bits_to_double_080006ac(uint bits1, uint bits2, uint bits3, uint bits4) {\n  uint temp1 = 0;\n  uint temp2 = 0;\n  uint temp3 = 0;\n  uint temp4 = 0;\n  uint mask = 0x80000000;\n  uint shift_count = 0;\n  bool is_zero = false;\n  bool is_denormal = false;\n  bool is_nan_or_inf = false;\n  bool is_negative = false;\n  bool is_special = false;\n  if ((bits1 & mask) == mask) {\n    is_negative = true;\n    bits1 = ~bits1 + 1;\n    bits2 = ~bits2 + ((bits1 == 0) ? 1 : 0);\n    bits3 = ~bits3 + ((bits1 == 0 && bits2 == 0) ? 1 : 0);\n    bits4 = ~bits4 + ((bits1 == 0 && bits2 == 0 && bits3 == 0) ? 1 : 0);\n  }\n  is_zero = (bits1 | bits2) == 0;\n  if (!is_zero) {\n    is_denormal = (bits1 & mask) == 0;\n    if (is_denormal) {\n      while ((bits2 & mask) == 0 && shift_count < 32) {\n        bits1 <<= 1;\n        bits1 |= (bits2 & mask) >> 31;\n        bits2 <<= 1;\n        shift_count++;\n      }\n      bits2 |= mask;\n      bits1 &= ~mask;\n    }\n    else {\n      bits1 |= mask;\n    }\n    is_nan_or_inf = (bits1 & ~mask) == 0xff000000;\n    is_special = is_nan_or_inf || (bits1 & ~mask) == 0;\n    if (is_special) {\n      return ((ulonglong)(bits1 & mask) << 32) | ((ulonglong)(bits1 & ~mask) << 20) | ((ulonglong)bits2 << 0);\n    }\n    else {\n      temp1 = bits1 & ~mask;\n      temp2 = bits2;\n    }\n  }\n  else {\n    return ((ulonglong)is_negative << 63);\n  }\n  shift_count = 0;\n  while ((bits3 & mask) == 0 && shift_count < 32) {\n    temp2 <<= 1;\n    temp2 |= (temp3 & mask) >> 31;\n    temp3 <<= 1;\n    temp3 |= (temp4 & mask) >> 31;\n    temp4 <<= 1;\n    temp4 |= (bits3 & mask) >> 31;\n    shift_count++;\n  }\n  return ((ulonglong)(is_negative ? 1 : 0) << 63) | ((ulonglong)temp1 << 52) | ((ulonglong)(temp2 >> 11) & 0x000fffffffffffff) | ((ulonglong)(temp2 & 0x7ff) << 52);\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080006ac",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "convert_bits_to_double_080006ac"
        },
        "FUN_0800125a": {
            "renaming": {
                "FUN_0800125a": "handle_SysTick_0800125a"
            },
            "code": "void handle_SysTick_0800125a(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800125a",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "handle_SysTick_0800125a"
        },
        "FUN_08001828": {
            "renaming": {
                "FUN_08001828": "write_i2c_mem_08001828",
                "*hi2c": "*i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "*pData": "*data",
                "Size": "data_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "*pIVar4": "*i2c_instance",
                "uVar5": "cr1",
                "I2C_RequestMemoryWrite": "I2C_RequestMemoryWrite",
                "HAL_StatusTypeDef": "HAL_StatusTypeDef",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "I2C_WaitOnTXEFlagUntilTimeout": "I2C_WaitOnTXEFlagUntilTimeout",
                "uint8_t": "uint8_t",
                "uint16_t": "uint16_t",
                "uint32_t": "uint32_t"
            },
            "code": "HAL_StatusTypeDef write_i2c_mem_08001828(I2C_HandleTypeDef *i2c_handle, uint16_t device_address, uint16_t memory_address, uint16_t memory_address_size, uint8_t *data, uint16_t data_size, uint32_t timeout)\n{\n    HAL_StatusTypeDef status;\n    uint32_t start_time;\n    uint32_t current_time;\n    I2C_TypeDef *i2c_instance;\n    uint8_t *current_data;\n    uint16_t remaining_data_size;\n\n    if (i2c_handle->State != HAL_I2C_STATE_READY) {\n        return HAL_BUSY;\n    }\n\n    if (data == NULL || data_size == 0) {\n        return HAL_ERROR;\n    }\n\n    start_time = HAL_GetTick();\n\n    do {\n        i2c_instance = i2c_handle->Instance;\n\n        if ((~i2c_instance->SR2 & 2) != 0) {\n            if (i2c_handle->Lock == HAL_LOCKED) {\n                return HAL_BUSY;\n            }\n\n            uint32_t cr1 = i2c_instance->CR1;\n            i2c_handle->Lock = HAL_LOCKED;\n            i2c_instance->CR1 = cr1 & 0xfffff7ff;\n            i2c_handle->State = HAL_I2C_STATE_BUSY_TX;\n            i2c_handle->Mode = HAL_I2C_MODE_MEM;\n            i2c_handle->ErrorCode = 0;\n            status = I2C_RequestMemoryWrite(i2c_handle, device_address, memory_address, memory_address_size, timeout);\n\n            if (status != HAL_OK) {\n                i2c_handle->Lock = HAL_UNLOCKED;\n\n                if (i2c_handle->ErrorCode == 4) {\n                    return HAL_ERROR;\n                }\n\n                return HAL_TIMEOUT;\n            }\n\n            break;\n        }\n\n        current_time = HAL_GetTick();\n    } while (current_time - start_time < 10000);\n\n    if (i2c_handle->Lock == HAL_LOCKED) {\n        i2c_handle->Lock = HAL_UNLOCKED;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n    }\n\n    if (current_time - start_time >= 10000) {\n        return HAL_BUSY;\n    }\n\n    current_data = data;\n    remaining_data_size = data_size;\n\n    while (remaining_data_size != 0) {\n        status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\n\n        if (status != HAL_OK) {\n            goto error_cleanup;\n        }\n\n        i2c_instance = i2c_handle->Instance;\n        i2c_instance->DR = (uint32_t)*current_data;\n\n        if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\n            if ((uint16_t)(remaining_data_size - 1) == 0) {\n                break;\n            }\n\n            remaining_data_size = remaining_data_size - 2;\n            i2c_instance->DR = (uint32_t)current_data[1];\n            current_data = current_data + 2;\n        }\n        else {\n            current_data = current_data + 1;\n            remaining_data_size = remaining_data_size - 1;\n        }\n    }\n\n    status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\n\n    if (status != HAL_OK) {\n        goto error_cleanup;\n    }\n\n    i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n    i2c_handle->Lock = HAL_UNLOCKED;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n\nerror_cleanup:\n    if (i2c_handle->ErrorCode == 4) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n        return HAL_ERROR;\n    }\n\n    return HAL_TIMEOUT;\n}",
            "called": [
                "I2C_RequestMemoryWrite",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001828",
            "calling": [
                "I2C_WriteByte"
            ],
            "imported": false,
            "current_name": "write_i2c_mem_08001828"
        },
        "FUN_0800016c": {
            "renaming": {
                "FUN_0800016c": "FUNC_0800016c"
            },
            "code": "\nulonglong FUNC_0800016c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = param_2;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar5 = param_2;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar5 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar5 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar5 = -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar4 = uVar5 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar4;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar5;\n    uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if ((uVar10 & 0x100000) != 0) goto LAB_08000278;\n  uVar5 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar5 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar5 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar5 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar5 = uVar5 << (uVar10 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 >> (uVar10 & 0xff),\n                    uVar5 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800016c",
            "calling": [
                "__ieee754_atan2",
                "scalbn",
                "__ieee754_sqrt",
                "__aeabi_drsub",
                "atan",
                "rint",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "FUNC_0800016c"
        },
        "FUN_08001b58": {
            "renaming": {
                "FUN_08001b58": "configure_RCC_Oscillators_08001b58",
                "RCC_OscInitStruct": "oscillator_config",
                "puVar1": "ptr_to_RCC_CR",
                "puVar2": "ptr_to_RCC_APB2ENR",
                "uVar3": "current_time",
                "uVar4": "elapsed_time",
                "iVar5": "leading_zeroes",
                "uVar6": "temp_value",
                "tmpreg": "temporary_register"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) */\n/* WARNING: Removing unreachable block (ram,0x08001ee8) */\n\nHAL_StatusTypeDef configure_RCC_Oscillators_08001b58(RCC_OscInitTypeDef *oscillator_config)\n\n{\n  uint *ptr_to_RCC_CR;\n  uint *ptr_to_RCC_APB2ENR;\n  uint32_t current_time;\n  uint32_t elapsed_time;\n  int leading_zeroes;\n  uint temp_value;\n  uint32_t temporary_register;\n  \n  ptr_to_RCC_CR = DAT_08001e70;\n  if ((int)(oscillator_config->OscillatorType << 0x1f) < 0) {\n    if (((DAT_08001e70[1] & 0xc) == 4) ||\n       (((DAT_08001e70[1] & 0xc) == 8 && ((int)(DAT_08001e70[1] << 0xf) < 0)))) {\n      temp_value = count_leading_zeroes(0x4000);\n      if (((int)((*DAT_08001e70 >> (temp_value & 0x1f)) << 0x1f) < 0) &&\n         (oscillator_config->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      current_time = oscillator_config->HSEState;\n      if (current_time == 0x10000) {\nLAB_08001c1e:\n        temp_value = *ptr_to_RCC_CR | 0x10000;\n      }\n      else {\n        if (current_time == 0) {\n          *DAT_08001e70 = *DAT_08001e70 & 0xfffeffff;\n          *ptr_to_RCC_CR = *ptr_to_RCC_CR & 0xfffbffff;\n          current_time = HAL_GetTick();\n          while (temp_value = count_leading_zeroes(0x4000),\n                (int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f) < 0) {\n            elapsed_time = HAL_GetTick();\n            if (100 < elapsed_time - current_time) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (current_time == 0x50000) {\n          *DAT_08001e70 = *DAT_08001e70 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        *DAT_08001e70 = *DAT_08001e70 & 0xfffeffff;\n        temp_value = *ptr_to_RCC_CR & 0xfffbffff;\n      }\n      *ptr_to_RCC_CR = temp_value;\n      current_time = HAL_GetTick();\n      while (temp_value = count_leading_zeroes(0x4000), -1 < (int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f))\n      {\n        elapsed_time = HAL_GetTick();\n        if (100 < elapsed_time - current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  ptr_to_RCC_CR = DAT_08001e70;\n  if ((int)(oscillator_config->OscillatorType << 0x1e) < 0) {\n    if (((DAT_08001e70[1] & 0xc) == 0) ||\n       (((DAT_08001e70[1] & 0xc) == 8 && (-1 < (int)(DAT_08001e70[1] << 0xf))))) {\n      temp_value = count_leading_zeroes(0x40000000);\n      if (((int)((*DAT_08001e70 >> (temp_value & 0x1f)) << 0x1f) < 0) &&\n         (oscillator_config->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscillator_config->HSIState == 0) {\n        leading_zeroes = count_leading_zeroes(0x80000000);\n        *(undefined4 *)(leading_zeroes * 4 + 0x42420000) = 0;\n        current_time = HAL_GetTick();\n        while (temp_value = count_leading_zeroes(0x40000000),\n              (int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f) < 0) {\n          elapsed_time = HAL_GetTick();\n          if (2 < elapsed_time - current_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      leading_zeroes = count_leading_zeroes(0x80000000);\n      *(undefined4 *)(leading_zeroes * 4 + 0x42420000) = 1;\n      current_time = HAL_GetTick();\n      while (temp_value = count_leading_zeroes(0x40000000),\n            -1 < (int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f)) {\n        elapsed_time = HAL_GetTick();\n        if (2 < elapsed_time - current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    temp_value = count_leading_zeroes(0x1f000000);\n    *ptr_to_RCC_CR = oscillator_config->HSICalibrationValue << (temp_value & 0xff) | *ptr_to_RCC_CR & 0xffffff07;\n  }\nLAB_08001b6c:\n  ptr_to_RCC_CR = DAT_08001e70;\n  if ((int)(oscillator_config->OscillatorType << 0x1c) < 0) {\n    if (oscillator_config->LSIState == 0) {\n      leading_zeroes = count_leading_zeroes(0x80000000);\n      *(undefined4 *)(DAT_08001e74 + leading_zeroes * 4) = 0;\n      current_time = HAL_GetTick();\n      while (temp_value = count_leading_zeroes(0x40000000),\n            (int)((ptr_to_RCC_CR[9] >> (temp_value & 0x1f)) << 0x1f) < 0) {\n        elapsed_time = HAL_GetTick();\n        if (2 < elapsed_time - current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      leading_zeroes = count_leading_zeroes(0x80000000);\n      *(undefined4 *)(DAT_08001e74 + leading_zeroes * 4) = 1;\n      current_time = HAL_GetTick();\n      while (temp_value = count_leading_zeroes(0x40000000),\n            -1 < (int)((ptr_to_RCC_CR[9] >> (temp_value & 0x1f)) << 0x1f)) {\n        elapsed_time = HAL_GetTick();\n        if (2 < elapsed_time - current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      HAL_Delay(1);\n    }\n  }\n  ptr_to_RCC_APB2ENR = DAT_08001e78;\n  ptr_to_RCC_CR = DAT_08001e70;\n  if (-1 < (int)(oscillator_config->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  DAT_08001e70[7] = DAT_08001e70[7] | 0x10000000;\n  *ptr_to_RCC_APB2ENR = *ptr_to_RCC_APB2ENR | 0x100;\n  current_time = HAL_GetTick();\n  while (-1 < (int)(*ptr_to_RCC_APB2ENR << 0x17)) {\n    elapsed_time = HAL_GetTick();\n    if (100 < elapsed_time - current_time) {\n      return HAL_TIMEOUT;\n    }\n  }\n  current_time = oscillator_config->LSEState;\n  if (current_time == 1) {\nLAB_08001e1a:\n    temp_value = ptr_to_RCC_CR[8] | 1;\n  }\n  else {\n    if (current_time == 0) {\n      ptr_to_RCC_CR[8] = ptr_to_RCC_CR[8] & 0xfffffffe;\n      ptr_to_RCC_CR[8] = ptr_to_RCC_CR[8] & 0xfffffffb;\n      current_time = HAL_GetTick();\n      while (temp_value = count_leading_zeroes(0x40000000),\n            (int)((ptr_to_RCC_CR[8] >> (temp_value & 0x1f)) << 0x1f) < 0) {\n        elapsed_time = HAL_GetTick();\n        if (5000 < elapsed_time - current_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (current_time == 5) {\n      ptr_to_RCC_CR[8] = ptr_to_RCC_CR[8] | 4;\n      goto LAB_08001e1a;\n    }\n    ptr_to_RCC_CR[8] = ptr_to_RCC_CR[8] & 0xfffffffe;\n    temp_value = ptr_to_RCC_CR[8] & 0xfffffffb;\n  }\n  ptr_to_RCC_CR[8] = temp_value;\n  current_time = HAL_GetTick();\n  while (temp_value = count_leading_zeroes(0x40000000), -1 < (int)((ptr_to_RCC_CR[8] >> (temp_value & 0x1f)) << 0x1f)\n        ) {\n    elapsed_time = HAL_GetTick();\n    if (5000 < elapsed_time - current_time) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  ptr_to_RCC_CR = DAT_08002004;\n  current_time = (oscillator_config->PLL).PLLState;\n  if (current_time == 0) {\n    return HAL_OK;\n  }\n  if ((DAT_08002004[1] & 0xc) != 8) {\n    if (current_time != 2) {\n      leading_zeroes = count_leading_zeroes(0x80);\n      *(undefined4 *)(leading_zeroes * 4 + 0x42420000) = 0;\n      current_time = HAL_GetTick();\n      do {\n        temp_value = count_leading_zeroes(0x40);\n        if (-1 < (int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f)) {\n          return HAL_OK;\n        }\n        elapsed_time = HAL_GetTick();\n      } while (elapsed_time - current_time < 3);\n      return HAL_TIMEOUT;\n    }\n    leading_zeroes = count_leading_zeroes(0x80);\n    *(undefined4 *)(leading_zeroes * 4 + 0x42420000) = 0;\n    current_time = HAL_GetTick();\n    do {\n      temp_value = count_leading_zeroes(0x40);\n      if (-1 < (int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f)) {\n        temp_value = (oscillator_config->PLL).PLLSource;\n        if (temp_value == 0x10000) {\n          ptr_to_RCC_CR[1] = ptr_to_RCC_CR[1] & 0xfffdffff | oscillator_config->HSEPredivValue;\n        }\n        ptr_to_RCC_CR[1] = temp_value | (oscillator_config->PLL).PLLMUL | ptr_to_RCC_CR[1] & 0xffc2ffff;\n        leading_zeroes = count_leading_zeroes(0x80);\n        *(undefined4 *)(leading_zeroes * 4 + 0x42420000) = 1;\n        current_time = HAL_GetTick();\n        do {\n          temp_value = count_leading_zeroes(0x40);\n          if ((int)((*ptr_to_RCC_CR >> (temp_value & 0x1f)) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          elapsed_time = HAL_GetTick();\n        } while (elapsed_time - current_time < 3);\n        return HAL_TIMEOUT;\n      }\n      elapsed_time = HAL_GetTick();\n    } while (elapsed_time - current_time < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "called": [
                "HAL_Delay",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b58",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_RCC_Oscillators_08001b58"
        },
        "FUN_0800290c": {
            "renaming": {
                "FUN_0800290c": "receiveData_0800290c",
                "*huart": "*uart",
                "HAL_StatusTypeDef": "HAL_Status",
                "uVar1": "parity",
                "bVar2": "data",
                "pUVar3": "instance",
                "uVar4": "wordLength",
                "puVar5": "rxBufferPtr",
                "puVar6": "rxBufferNext",
                "bVar7": "isBusy",
                "State": "State",
                "Init": "Init",
                "Parity": "Parity",
                "Instance": "Instance",
                "WordLength": "WordLength",
                "pRxBuffPtr": "pRxBuffPtr",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9B",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "DR": "DR",
                "CR1": "CR1",
                "CR3": "CR3",
                "RxXferCount": "RxXferCount",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_UART_STATE_BUSY_RX_COMPLETE": "HAL_UART_STATE_BUSY_RX_COMPLETE",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_RxCpltCallback": "HAL_UART_RxCpltCallback"
            },
            "code": "HAL_StatusTypeDef receiveData_0800290c(UART_HandleTypeDef *uart)\n{\n  uint32_t parity;\n  byte data;\n  USART_TypeDef *instance;\n  uint16_t wordLength;\n  ushort *rxBufferPtr;\n  ushort *rxBufferNext;\n  bool isBusy;\n  \n  if ((uart->State & HAL_UART_STATE_BUSY_RX) != HAL_UART_STATE_BUSY_RX)\n  {\n    return HAL_BUSY;\n  }\n  parity = (uart->Init).Parity;\n  instance = uart->Instance;\n  rxBufferPtr = (ushort *)uart->pRxBuffPtr;\n  wordLength = (uart->Init).WordLength;\n  if (wordLength == UART_WORDLENGTH_9B)\n  {\n    if (parity == UART_PARITY_NONE)\n    {\n      rxBufferNext = rxBufferPtr + 1;\n      *rxBufferPtr = (ushort)((instance->DR << 0x17) >> 0x17);\n    }\n    else\n    {\n      rxBufferNext = (ushort *)((int)rxBufferPtr + 1);\n      *rxBufferPtr = (ushort)instance->DR & 0xff;\n    }\n    uart->pRxBuffPtr = (uint8_t *)rxBufferNext;\n  }\n  else\n  {\n    if (parity == UART_PARITY_NONE)\n    {\n      data = (byte)instance->DR;\n      uart->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n    }\n    else\n    {\n      parity = instance->DR;\n      uart->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n      data = (byte)parity & 0x7f;\n    }\n    *(byte *)rxBufferPtr = data;\n  }\n  rxBufferNext = uart->RxXferCount - 1;\n  uart->RxXferCount = rxBufferNext;\n  if (rxBufferNext == 0)\n  {\n    instance->CR1 = instance->CR1 & 0xffffffdf;\n    isBusy = uart->State != HAL_UART_STATE_BUSY_RX_COMPLETE;\n    if (isBusy)\n    {\n      instance->CR1 = instance->CR1 & 0xfffffeff;\n      parity = (uint32_t)instance->CR3 & 0xfffffffe;\n      instance->CR3 = parity;\n      uart->State = HAL_UART_STATE_READY;\n      HAL_UART_RxCpltCallback(uart);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800290c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receiveData_0800290c"
        },
        "FUN_080028a6": {
            "renaming": {
                "FUN_080028a6": "receive_data_080028a6",
                "*huart": "*uart_handle",
                "*pData": "*data",
                "Size": "size",
                "HVar1": "uart_state",
                "uVar2": "cr1_reg",
                "*pUVar3": "*uart_instance"
            },
            "code": "HAL_StatusTypeDef receive_data_080028a6(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size)\n{\n  HAL_UART_StateTypeDef uart_state;\n  uint cr1_reg;\n  USART_TypeDef *uart_instance;\n  \n  if ((uart_handle->State == HAL_UART_STATE_READY) || (uart_handle->State == HAL_UART_STATE_BUSY_TX)) {\n    if ((data == NULL) || (size == 0)) {\n      return HAL_ERROR;\n    }\n    if (uart_handle->Lock != HAL_LOCKED) {\n      uart_handle->Lock = HAL_LOCKED;\n      uart_handle->ErrorCode = 0;\n      uart_handle->RxXferSize = size;\n      uart_handle->RxXferCount = size;\n      uart_handle->Lock = HAL_UNLOCKED;\n      if (uart_handle->State == HAL_UART_STATE_BUSY_TX) {\n        uart_state = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uart_state = HAL_UART_STATE_BUSY_RX;\n      }\n      uart_instance = uart_handle->Instance;\n      uart_handle->State = uart_state;\n      cr1_reg = uart_instance->CR1;\n      uart_handle->pRxBuffPtr = data;\n      uart_instance->CR1 = cr1_reg | 0x100;\n      uart_instance->CR3 = uart_instance->CR3 | 1;\n      uart_instance->CR1 = uart_instance->CR1 | 0x20;\n      return HAL_OK;\n    }\n  }\n  return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028a6",
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "imported": false,
            "current_name": "receive_data_080028a6"
        },
        "FUN_0800290a": {
            "renaming": {
                "FUN_0800290a": "do_nothing_0800290a"
            },
            "code": "\nvoid do_nothing_0800290a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800290a",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_0800290a"
        },
        "FUN_08004300": {
            "renaming": {
                "FUN_08004300": "printDataWithChecksum_08004300",
                "code": "checksumKey",
                "data": "data",
                "data_length": "dataLength",
                "ch": "checksum",
                "pbVar1": "dataPtr"
            },
            "code": "void printDataWithChecksum_08004300(uint8_t checksumKey, uint8_t *data, uint16_t dataLength) {\n  uint8_t checksum = 0;\n  uint8_t *dataPtr;\n\n  serialPrint(PTR_DAT_08004344);\n  serialWrite((byte)dataLength);\n  checksum = (byte)dataLength ^ checksumKey;\n  serialWrite(checksumKey);\n  for (dataPtr = data; (int)dataPtr - (int)data < (int)(uint)dataLength; dataPtr++) {\n    serialWrite(*dataPtr);\n    checksum ^= *dataPtr;\n  }\n  serialWrite(checksum);\n  return;\n}",
            "called": [
                "serialPrint",
                "serialWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004300",
            "calling": [
                "MSP_SendStatus",
                "MSP_SendPID",
                "MSP_SendAltitude",
                "MSP_SendAttitude",
                "MSP_SendRawIMU",
                "MSP_SendMotor",
                "MSP_SendIdent"
            ],
            "imported": false,
            "current_name": "printDataWithChecksum_08004300"
        },
        "FUN_08005630": {
            "renaming": {
                "FUN_08005630": "copy_memory_08005630",
                "__dest": "dest",
                "__src": "src",
                "__n": "n",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "code": "void* copy_memory_08005630(void* dest, const void* src, size_t n) {\n    unsigned char* dest_ptr = (unsigned char*)dest;\n    const unsigned char* src_ptr = (const unsigned char*)src;\n    for (size_t i = 0; i < n; i++) {\n        dest_ptr[i] = src_ptr[i];\n    }\n    return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005630",
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "copy_memory_08005630"
        },
        "FUN_08003330": {
            "renaming": {
                "FUN_08003330": "FUNC_08003330"
            },
            "code": "\nvoid FUNC_08003330\n               (float ax,float ay,float az,float gx,float gy,float gz,float mx,float my,float mz,\n               float *angle)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  int iVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  int iVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  undefined4 uVar23;\n  undefined4 uVar24;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  int iVar27;\n  undefined4 in_r2;\n  undefined4 uVar28;\n  int iVar29;\n  undefined4 uVar30;\n  undefined4 uVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_00000000;\n  undefined4 in_stack_00000004;\n  undefined4 in_stack_00000008;\n  undefined4 in_stack_0000000c;\n  undefined4 in_stack_00000010;\n  undefined4 *in_stack_00000014;\n  undefined4 in_stack_ffffff78;\n  float hy;\n  float hx;\n  \n  uVar28 = *(undefined4 *)PTR_q_080035d8;\n  iVar29 = *(int *)(PTR_q_080035d8 + 4);\n  uVar31 = *(undefined4 *)(PTR_q_080035d8 + 8);\n  uVar30 = *(undefined4 *)(PTR_q_080035d8 + 0xc);\n  uVar2 = __aeabi_fmul(ax,mz,mz);\n  uVar3 = __aeabi_fmul(angle);\n  uVar2 = __addsf3(uVar2,uVar3);\n  uVar3 = __aeabi_fmul(in_r2);\n  __addsf3(uVar2,uVar3);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n  uVar2 = __truncdfsf2();\n  iVar4 = __aeabi_fcmpeq(uVar2,0);\n  if (iVar4 == 0) {\n    uVar3 = __aeabi_fmul(in_stack_00000008);\n    uVar5 = __aeabi_fmul(in_stack_0000000c);\n    uVar3 = __addsf3(uVar3,uVar5);\n    uVar5 = __aeabi_fmul(in_stack_00000010);\n    __addsf3(uVar3,uVar5);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n    uVar3 = __truncdfsf2();\n    iVar4 = __aeabi_fcmpeq(uVar3,0);\n    if (iVar4 == 0) {\n      uVar32 = __aeabi_f2d();\n      __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_080035d0,DAT_080035d4);\n      uVar5 = __truncdfsf2();\n      uVar32 = __aeabi_f2d(in_stack_00000000);\n      __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_080035d0,DAT_080035d4);\n      uVar6 = __truncdfsf2();\n      uVar32 = __aeabi_f2d(in_stack_00000004);\n      __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_080035d0,DAT_080035d4);\n      uVar7 = __truncdfsf2();\n      iVar4 = __addsf3(uVar28);\n      uVar8 = __addsf3(iVar29);\n      iVar9 = __addsf3(uVar31,uVar31);\n      uVar10 = __addsf3(uVar30,uVar30);\n      uVar11 = __aeabi_fmul(uVar28);\n      uVar12 = __aeabi_fmul(uVar28,iVar29);\n      uVar13 = __aeabi_fmul(uVar28,uVar31);\n      uVar14 = __aeabi_fmul(iVar29);\n      uVar15 = __aeabi_fmul(iVar29,uVar30);\n      uVar16 = __aeabi_fmul(uVar31,uVar31);\n      uVar17 = __aeabi_fmul(uVar30,uVar30);\n      uVar2 = __aeabi_fdiv(0x3f800000,uVar2);\n      uVar3 = __aeabi_fdiv(0x3f800000,uVar3);\n      uVar18 = __aeabi_fmul(in_stack_00000008,uVar3);\n      uVar19 = __aeabi_fmul(in_stack_0000000c,uVar3);\n      uVar3 = __aeabi_fmul(in_stack_00000010,uVar3);\n      iVar20 = __aeabi_fmul(iVar4,uVar18);\n      uVar21 = __aeabi_fmul(iVar4,uVar19);\n      uVar22 = __aeabi_fmul(iVar4,uVar3);\n      uVar23 = __aeabi_fmul(uVar8,uVar18);\n      uVar24 = __aeabi_fmul(uVar11,uVar18);\n      uVar25 = __aeabi_fmul(uVar30,uVar21);\n      uVar24 = __aeabi_fsub(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar31,uVar22);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar14,uVar18);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar8,uVar19);\n      uVar25 = __aeabi_fmul(uVar25,uVar31);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar8,uVar3);\n      uVar25 = __aeabi_fmul(uVar25,uVar30);\n      uVar24 = __addsf3(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar16,uVar18);\n      uVar24 = __aeabi_fsub(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar17,uVar18);\n      uVar24 = __aeabi_fsub(uVar24,uVar25);\n      uVar25 = __aeabi_fmul(uVar30,iVar20);\n      uVar26 = __aeabi_fmul(uVar11,uVar19);\n      uVar25 = __addsf3(uVar25,uVar26);\n      uVar22 = __aeabi_fmul(iVar29,uVar22);\n      uVar22 = __aeabi_fsub(uVar25,uVar22);\n      uVar25 = __aeabi_fmul(uVar31,uVar23);\n      uVar22 = __addsf3(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(uVar14,uVar19);\n      uVar22 = __aeabi_fsub(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(uVar16,uVar19);\n      uVar22 = __addsf3(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(iVar9,uVar3);\n      uVar25 = __aeabi_fmul(uVar25,uVar30);\n      uVar22 = __addsf3(uVar22,uVar25);\n      uVar25 = __aeabi_fmul(uVar17,uVar19);\n      uVar22 = __aeabi_fsub(uVar22,uVar25);\n      uVar24 = __aeabi_fmul(uVar24,uVar24);\n      uVar22 = __aeabi_fmul(uVar22,uVar22);\n      __addsf3(uVar24,uVar22);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n      iVar27 = __truncdfsf2();\n      uVar22 = __aeabi_fmul(iVar20 + -0x80000000,uVar31);\n      uVar21 = __aeabi_fmul(iVar29,uVar21);\n      uVar21 = __addsf3(uVar22,uVar21);\n      uVar11 = __aeabi_fmul(uVar11,uVar3);\n      uVar11 = __addsf3(uVar21,uVar11);\n      uVar21 = __aeabi_fmul(uVar30,uVar23);\n      uVar11 = __addsf3(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(uVar14,uVar3);\n      uVar11 = __aeabi_fsub(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(iVar9,uVar19);\n      uVar21 = __aeabi_fmul(uVar21,uVar30);\n      uVar11 = __addsf3(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(uVar16,uVar3);\n      uVar11 = __aeabi_fsub(uVar11,uVar21);\n      uVar21 = __aeabi_fmul(uVar17,uVar3);\n      uVar11 = __addsf3(uVar11,uVar21);\n      uVar21 = __addsf3(uVar11,uVar11);\n      uVar22 = __addsf3(uVar15);\n      uVar23 = __aeabi_fmul(uVar31,iVar4);\n      uVar22 = __aeabi_fsub(uVar22,uVar23);\n      uVar23 = __aeabi_fmul(mz,uVar2);\n      uVar22 = __aeabi_fsub(uVar22,uVar23);\n      uVar23 = __aeabi_fmul(uVar30,iVar9);\n      uVar24 = __addsf3(uVar12);\n      uVar23 = __addsf3(uVar23,uVar24);\n      uVar24 = __aeabi_fmul(angle,uVar2);\n      uVar23 = __aeabi_fsub(uVar23,uVar24);\n      uVar24 = __aeabi_fmul(uVar31,uVar11);\n      uVar25 = __aeabi_fsub(0x3f000000,uVar16);\n      uVar17 = __aeabi_fsub(uVar25,uVar17);\n      uVar17 = __aeabi_fmul(uVar17,iVar27);\n      uVar25 = __aeabi_fsub(uVar15,uVar13);\n      uVar25 = __aeabi_fmul(uVar25,uVar11);\n      uVar17 = __addsf3(uVar17,uVar25);\n      uVar17 = __aeabi_fsub(uVar17,uVar18);\n      uVar18 = __aeabi_fmul(iVar29,uVar11);\n      uVar25 = __aeabi_fmul(iVar29,uVar31);\n      uVar26 = __aeabi_fmul(uVar28,uVar30);\n      uVar25 = __aeabi_fsub(uVar25,uVar26);\n      uVar25 = __aeabi_fmul(uVar25,iVar27);\n      uVar26 = __aeabi_fmul(uVar31,uVar30);\n      uVar12 = __addsf3(uVar26,uVar12);\n      uVar12 = __aeabi_fmul(uVar12,uVar11);\n      uVar12 = __addsf3(uVar25,uVar12);\n      uVar12 = __aeabi_fsub(uVar12,uVar19);\n      uVar19 = __aeabi_fmul(uVar31,iVar27);\n      uVar25 = __aeabi_fsub(0x3f000000,uVar14);\n      uVar25 = __aeabi_fsub(uVar25,uVar16);\n      uVar25 = __aeabi_fmul(uVar25,uVar11);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar13 = __aeabi_fmul(uVar13,iVar27);\n      uVar13 = __addsf3(uVar25,uVar13);\n      uVar3 = __aeabi_fsub(uVar13,uVar3);\n      uVar13 = __aeabi_fmul(iVar9 + -0x80000000,uVar22);\n      uVar15 = __aeabi_fmul(uVar8,uVar23);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar15 = __aeabi_fmul(uVar24,uVar17);\n      uVar13 = __aeabi_fsub(uVar13,uVar15);\n      uVar15 = __aeabi_fmul(uVar30,iVar27 + -0x80000000);\n      uVar15 = __addsf3(uVar15,uVar18);\n      uVar15 = __aeabi_fmul(uVar15,uVar12);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar15 = __aeabi_fmul(uVar19,uVar3);\n      uVar13 = __addsf3(uVar13,uVar15);\n      uVar14 = __addsf3(uVar14);\n      uVar14 = __aeabi_fsub(0x3f800000,uVar14);\n      uVar15 = __addsf3(uVar16);\n      uVar14 = __aeabi_fsub(uVar14,uVar15);\n      uVar2 = __aeabi_fmul(in_r2,uVar2);\n      uVar2 = __aeabi_fsub(uVar14,uVar2);\n      uVar14 = __aeabi_fmul(uVar30,uVar11);\n      uVar11 = __aeabi_fmul(uVar28,uVar11);\n      uVar15 = __aeabi_fmul(uVar10,uVar22);\n      uVar16 = __aeabi_fmul(iVar4,uVar23);\n      uVar15 = __addsf3(uVar15,uVar16);\n      uVar16 = __aeabi_fmul(iVar29,0x40800000);\n      uVar16 = __aeabi_fmul(uVar16,uVar2);\n      uVar15 = __aeabi_fsub(uVar15,uVar16);\n      uVar16 = __aeabi_fmul(uVar17,uVar14);\n      uVar15 = __addsf3(uVar15,uVar16);\n      uVar16 = __addsf3(uVar19,uVar11);\n      uVar16 = __aeabi_fmul(uVar16,uVar12);\n      uVar15 = __addsf3(uVar15,uVar16);\n      uVar16 = __aeabi_fmul(uVar30,iVar27);\n      uVar19 = __aeabi_fmul(iVar29,uVar21);\n      uVar16 = __aeabi_fsub(uVar16,uVar19);\n      uVar16 = __aeabi_fmul(uVar16,uVar3);\n      uVar15 = __addsf3(uVar15,uVar16);\n      iVar20 = __addsf3(iVar27,iVar27);\n      uVar16 = __aeabi_fmul(iVar29,iVar27);\n      uVar19 = __aeabi_fmul(iVar4 + -0x80000000,uVar22);\n      uVar10 = __aeabi_fmul(uVar10,uVar23);\n      uVar10 = __addsf3(uVar19,uVar10);\n      uVar19 = __aeabi_fmul(uVar31,0x40800000);\n      uVar2 = __aeabi_fmul(uVar19,uVar2);\n      uVar2 = __aeabi_fsub(uVar10,uVar2);\n      uVar10 = __aeabi_fmul(uVar31,iVar20 + -0x80000000);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,uVar17);\n      uVar2 = __addsf3(uVar2,uVar10);\n      uVar10 = __addsf3(uVar14,uVar16);\n      uVar10 = __aeabi_fmul(uVar10,uVar12);\n      uVar2 = __addsf3(uVar2,uVar10);\n      uVar10 = __aeabi_fmul(uVar28,iVar27);\n      uVar11 = __aeabi_fmul(uVar31,uVar21);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,uVar3);\n      uVar2 = __addsf3(uVar2,uVar10);\n      uVar8 = __aeabi_fmul(uVar8,uVar22);\n      uVar10 = __aeabi_fmul(iVar9,uVar23);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar30,iVar20 + -0x80000000);\n      uVar10 = __addsf3(uVar10,uVar18);\n      uVar10 = __aeabi_fmul(uVar10,uVar17);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar28,iVar27 + -0x80000000);\n      uVar10 = __addsf3(uVar10,uVar24);\n      uVar10 = __aeabi_fmul(uVar10,uVar12);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar3 = __aeabi_fmul(uVar3,uVar16);\n      uVar3 = __addsf3(uVar8,uVar3);\n      uVar8 = __aeabi_fmul(uVar13);\n      uVar10 = __aeabi_fmul(uVar15);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar2,uVar2);\n      uVar8 = __addsf3(uVar8,uVar10);\n      uVar10 = __aeabi_fmul(uVar3,uVar3);\n      __addsf3(uVar8,uVar10);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(iVar29,in_stack_ffffff78));\n      uVar8 = __truncdfsf2();\n      uVar8 = __aeabi_fdiv(0x3f800000,uVar8);\n      puVar1 = PTR_deltat_08003d84;\n      uVar12 = *(undefined4 *)PTR_beta_08003d80;\n      uVar14 = *(undefined4 *)PTR_beta_08003d80;\n      uVar16 = *(undefined4 *)PTR_beta_08003d80;\n      uVar17 = *(undefined4 *)PTR_beta_08003d80;\n      uVar10 = __aeabi_fmul(iVar29 + -0x80000000,uVar5);\n      uVar11 = __aeabi_fmul(uVar31,uVar6);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar11 = __aeabi_fmul(uVar30,uVar7);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,0x3f000000);\n      uVar11 = __aeabi_fmul(uVar13,uVar8);\n      uVar13 = *(undefined4 *)puVar1;\n      uVar11 = __aeabi_fmul(uVar11,uVar12);\n      uVar10 = __aeabi_fsub(uVar10,uVar11);\n      uVar10 = __aeabi_fmul(uVar10,uVar13);\n      uVar10 = __addsf3(uVar10,uVar28);\n      uVar11 = __aeabi_fmul(uVar28,uVar5);\n      uVar12 = __aeabi_fmul(uVar31,uVar7);\n      uVar13 = *(undefined4 *)puVar1;\n      uVar11 = __addsf3(uVar11,uVar12);\n      uVar12 = __aeabi_fmul(uVar30,uVar6);\n      uVar11 = __aeabi_fsub(uVar11,uVar12);\n      uVar11 = __aeabi_fmul(uVar11,0x3f000000);\n      uVar12 = __aeabi_fmul(uVar15,uVar8);\n      uVar12 = __aeabi_fmul(uVar12,uVar14);\n      uVar11 = __aeabi_fsub(uVar11,uVar12);\n      uVar11 = __aeabi_fmul(uVar11,uVar13);\n      uVar11 = __addsf3(uVar11,iVar29);\n      uVar14 = *(undefined4 *)puVar1;\n      uVar12 = __aeabi_fmul(uVar28,uVar6);\n      uVar13 = __aeabi_fmul(iVar29,uVar7);\n      uVar12 = __aeabi_fsub(uVar12,uVar13);\n      uVar13 = __aeabi_fmul(uVar30,uVar5);\n      uVar12 = __addsf3(uVar12,uVar13);\n      uVar12 = __aeabi_fmul(uVar12,0x3f000000);\n      uVar2 = __aeabi_fmul(uVar2,uVar8);\n      uVar2 = __aeabi_fmul(uVar2,uVar16);\n      uVar2 = __aeabi_fsub(uVar12,uVar2);\n      uVar2 = __aeabi_fmul(uVar2,uVar14);\n      uVar2 = __addsf3(uVar2,uVar31);\n      uVar28 = __aeabi_fmul(uVar28,uVar7);\n      uVar6 = __aeabi_fmul(iVar29,uVar6);\n      uVar28 = __addsf3(uVar28,uVar6);\n      uVar31 = __aeabi_fmul(uVar31,uVar5);\n      uVar31 = __aeabi_fsub(uVar28,uVar31);\n      uVar31 = __aeabi_fmul(uVar31,0x3f000000);\n      uVar3 = __aeabi_fmul(uVar3,uVar8);\n      uVar3 = __aeabi_fmul(uVar3,uVar17);\n      uVar5 = *(undefined4 *)puVar1;\n      uVar3 = __aeabi_fsub(uVar31,uVar3);\n      uVar3 = __aeabi_fmul(uVar3,uVar5);\n      uVar3 = __addsf3(uVar3,uVar30);\n      uVar30 = __aeabi_fmul(uVar10,uVar10);\n      uVar31 = __aeabi_fmul(uVar11,uVar11);\n      uVar30 = __addsf3(uVar30,uVar31);\n      uVar31 = __aeabi_fmul(uVar2,uVar2);\n      uVar30 = __addsf3(uVar30,uVar31);\n      uVar31 = __aeabi_fmul(uVar3,uVar3);\n      __addsf3(uVar30,uVar31);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(uVar28,in_stack_ffffff78));\n      uVar30 = __truncdfsf2();\n      uVar30 = __aeabi_fdiv(0x3f800000,uVar30);\n      uVar31 = __aeabi_fmul(uVar10,uVar30);\n      puVar1 = PTR_q_08003d88;\n      *(undefined4 *)PTR_q_08003d88 = uVar31;\n      uVar5 = __aeabi_fmul(uVar11,uVar30);\n      *(undefined4 *)(puVar1 + 4) = uVar5;\n      uVar2 = __aeabi_fmul(uVar2,uVar30);\n      *(undefined4 *)(puVar1 + 8) = uVar2;\n      uVar3 = __aeabi_fmul(uVar3,uVar30);\n      *(undefined4 *)(puVar1 + 0xc) = uVar3;\n      uVar3 = __aeabi_fmul(uVar5,uVar3);\n      uVar2 = __aeabi_fmul(uVar31,uVar2);\n      uVar2 = __aeabi_fsub(uVar3,uVar2);\n      __addsf3(uVar2,uVar2);\n      __aeabi_f2d();\n      asin((double)CONCAT44(uVar28,in_stack_ffffff78));\n      uVar32 = __muldf3();\n      __divdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_08003d78,DAT_08003d7c);\n      uVar2 = __truncdfsf2();\n      *in_stack_00000014 = uVar2;\n      uVar31 = *(undefined4 *)puVar1;\n      uVar5 = *(undefined4 *)(puVar1 + 4);\n      uVar2 = __aeabi_fmul(uVar31,uVar31);\n      uVar3 = __aeabi_fmul(uVar5,uVar5);\n      uVar2 = __aeabi_fsub(uVar2,uVar3);\n      uVar28 = *(undefined4 *)(puVar1 + 8);\n      uVar3 = __aeabi_fmul(uVar28,uVar28);\n      uVar2 = __aeabi_fsub(uVar2,uVar3);\n      uVar30 = *(undefined4 *)(puVar1 + 0xc);\n      uVar3 = __aeabi_fmul(uVar30,uVar30);\n      __addsf3(uVar2,uVar3);\n      uVar32 = __aeabi_f2d();\n      uVar2 = __aeabi_fmul(uVar31,uVar5);\n      uVar3 = __aeabi_fmul(uVar28,uVar30);\n      uVar2 = __addsf3(uVar2,uVar3);\n      __addsf3(uVar2,uVar2);\n      uVar33 = __aeabi_f2d();\n      uVar32 = atan2((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar32,\n                     (int)((ulonglong)uVar32 >> 0x20));\n      uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,DAT_08003ea8);\n      __divdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_08003ea0,DAT_08003ea4);\n      uVar2 = __truncdfsf2();\n      in_stack_00000014[1] = uVar2;\n      uVar30 = *(undefined4 *)puVar1;\n      uVar31 = *(undefined4 *)(puVar1 + 4);\n      uVar2 = __aeabi_fmul(uVar30,uVar30);\n      uVar3 = __aeabi_fmul(uVar31,uVar31);\n      uVar2 = __addsf3(uVar2,uVar3);\n      uVar5 = *(undefined4 *)(puVar1 + 8);\n      uVar3 = __aeabi_fmul(uVar5,uVar5);\n      uVar2 = __aeabi_fsub(uVar2,uVar3);\n      uVar28 = *(undefined4 *)(puVar1 + 0xc);\n      uVar3 = __aeabi_fmul(uVar28,uVar28);\n      __aeabi_fsub(uVar2,uVar3);\n      uVar32 = __aeabi_f2d();\n      uVar2 = __aeabi_fmul(uVar31,uVar5);\n      uVar3 = __aeabi_fmul(uVar30,uVar28);\n      uVar2 = __addsf3(uVar2,uVar3);\n      __addsf3(uVar2,uVar2);\n      uVar33 = __aeabi_f2d();\n      uVar32 = atan2((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar32,\n                     (int)((ulonglong)uVar32 >> 0x20));\n      uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,DAT_08003ea8);\n      __divdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),DAT_08003ea0,DAT_08003ea4);\n      uVar2 = __truncdfsf2();\n      in_stack_00000014[2] = uVar2;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "asin",
                "__aeabi_fmul",
                "__divdf3",
                "__addsf3",
                "__muldf3",
                "sqrt",
                "__aeabi_fsub",
                "__aeabi_f2d",
                "__aeabi_fdiv",
                "__truncdfsf2",
                "atan2",
                "__aeabi_fcmpeq"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08003330",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "FUNC_08003330"
        },
        "FUN_08000980": {
            "renaming": {
                "FUN_08000980": "compare_double_values_08000980",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value1",
                "param_4": "value2"
            },
            "code": "void compare_double_values_08000980(double value1, double value2){\n  int areEqual = __aeabi_cdcmpeq(value1, value2);\n  return;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000980",
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "imported": false,
            "current_name": "compare_double_values_08000980"
        },
        "FUN_08002368": {
            "renaming": {
                "FUN_08002368": "configure_timer_08002368",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "cr1",
                "pTVar2": "repetition_timer",
                "DAT_080023cc": "timer1"
            },
            "code": "void configure_timer_08002368(TIM_TypeDef *timer, TIM_Base_InitTypeDef *config)\n{\n  uint32_t cr1 = timer->CR1;\n  if ((((timer == DAT_080023cc) || (timer == timer2)) ||\n      (timer == &DAT_080023cc->DMAR)) ||\n     (timer == &DAT_080023cc->SMCR)) {\n    cr1 = cr1 & 0xffffff8f | config->CounterMode;\n    if (((timer == DAT_080023cc) || (timer == timer2)) ||\n       ((timer == &DAT_080023cc->DMAR ||\n        (timer == &DAT_080023cc->SMCR)))) {\n      cr1 = cr1 & 0xfffffcff | config->ClockDivision;\n    }\n  }\n  timer->CR1 = cr1;\n  timer->ARR = config->Period;\n  timer->PSC = config->Prescaler;\n  TIM_TypeDef *repetition_timer = DAT_080023cc;\n  if (timer == DAT_080023cc) {\n    repetition_timer = (TIM_TypeDef *)config->RepetitionCounter;\n  }\n  if (timer == DAT_080023cc) {\n    timer->RCR = (uint32_t)repetition_timer;\n  }\n  timer->EGR = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002368",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_08002368"
        },
        "FUN_08002008": {
            "renaming": {
                "FUN_08002008": "calculate_pll_multiplier_08002008",
                "uVar1": "temp1",
                "uVar2": "output_freq",
                "uVar3": "temp2",
                "uVar4": "reg_value",
                "uVar5": "leading_zeroes",
                "uVar6": "prediv_index",
                "puVar7": "pll_mul_factor_table_ptr",
                "puVar8": "temp_ptr",
                "aPredivFactorTable": "prediv_factor_table",
                "aPLLMULFactorTable": "pll_mul_factor_table",
                "DAT_08002090": "PLL_CONFIG_REG",
                "DAT_08002094": "PLL_INPUT_FREQ",
                "DAT_08002098": "PLL_OUTPUT_FREQ"
            },
            "code": "uint32_t calculate_pll_multiplier_08002008(void)\n{\n  uint32_t pll_mul_factor;\n  uint8_t prediv_factor_table[2] = {1, 2};\n  uint8_t pll_mul_factor_table[16];\n  uint32_t reg_value = *(uint32_t *)(0x08002090 + 4);\n  uint32_t output_freq = 0;\n  if ((reg_value & 0xc) == 8)\n  {\n    uint32_t leading_zeroes = count_leading_zeroes(0x3c00);\n    uint32_t prediv_factor = DAT_08002094;\n    if ((int)(reg_value << 0xf) < 0)\n    {\n      uint32_t prediv_index = count_leading_zeroes(0x4000);\n      prediv_factor = DAT_08002094 / prediv_factor_table[(reg_value & 0x20000) >> (prediv_index & 0xff)];\n    }\n    pll_mul_factor = prediv_factor * pll_mul_factor_table[(reg_value & 0x3c0000) >> (leading_zeroes & 0xff)];\n    output_freq = pll_mul_factor;\n  }\n  return output_freq;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002008",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_pll_multiplier_08002008"
        },
        "FUN_080008fc": {
            "renaming": {
                "FUN_080008fc": "check_values_080008fc",
                "param_1": "val1",
                "param_2": "val2",
                "param_3": "val3",
                "param_4": "val4",
                "uVar1": "xor_val2_val4",
                "bVar2": "is_val1_val2_zero",
                "bVar3": "is_val4_less_than_or_equal_val2"
            },
            "code": "uint check_values_080008fc(uint val1, uint val2, uint val3, uint val4)\n{\n  uint result;\n  bool is_negative_val2 = ((int)(val2 << 1) >> 0x15 == -1);\n  bool is_negative_val4 = ((int)(val4 << 1) >> 0x15 == -1);\n  \n  if ((is_negative_val2 || is_negative_val4) && ((is_negative_val2 && ((val1 | (val2 << 0xc)) != 0)) || ((is_negative_val4 && ((val3 | (val4 << 0xc)) != 0)))) {\n    return 1;\n  }\n  \n  bool is_val1_val2_zero = ((val1 | (val2 << 1)) == 0);\n  bool is_val3_val4_zero = ((val3 | (val4 << 1)) == 0);\n  bool is_val2_val4_equal = (val2 == val4);\n  bool is_val1_val3_equal = (val1 == val3);\n  \n  if (!is_val1_val2_zero && !is_val3_val4_zero && !is_val2_val4_equal && !is_val1_val3_equal) {\n    uint xor_val2_val4 = val2 ^ val4;\n    bool is_xor_val2_val4_zero = (xor_val2_val4 == 0);\n    bool is_xor_val2_val4_positive = (-1 < (int)xor_val2_val4);\n    bool is_val4_less_than_or_equal_val2 = (val4 <= val2);\n    \n    if (is_xor_val2_val4_zero || (is_xor_val2_val4_positive && is_val4_less_than_or_equal_val2)) {\n      result = (int)val4 >> 0x1f;\n      if (!(is_xor_val2_val4_zero || (is_xor_val2_val4_positive && is_val4_less_than_or_equal_val2))) {\n        result = ~result;\n      }\n      return result | 1;\n    }\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008fc",
            "calling": [],
            "imported": false,
            "current_name": "check_values_080008fc"
        },
        "FUN_0800114c": {
            "renaming": {
                "FUN_0800114c": "increment_uwTick_0800114c",
                "PTR_uwTick_08001158": "uwTick_address",
                "*(int *)PTR_uwTick_08001158": "uwTick_value",
                "DAT_08001158": "uwTick"
            },
            "code": "void increment_uwTick_0800114c(void)\n{\n  int* PTR_DAT_08001158_08001158 = (int*) PTR_DAT_08001158_08001158;\n  int *(int *)PTR_DAT_08001158_08001158 = *PTR_DAT_08001158_08001158;\n  *(int *)PTR_DAT_08001158_08001158++;\n  *PTR_DAT_08001158_08001158 = *(int *)PTR_DAT_08001158_08001158;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800114c",
            "calling": [
                "main",
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "increment_uwTick_0800114c"
        },
        "FUN_08002250": {
            "renaming": {
                "FUN_08002250": "calculateSystemCoreClockFrequency_08002250",
                "uVar1": "leadingZeroesCount",
                "PTR_SystemCoreClock_0800227c": "systemCoreClockFrequencyPointer",
                "PTR_APBPrescTable_08002278": "apbPrescalerTablePointer",
                "DAT_08002274": "apbPrescalerTableOffset",
                "apbPrescalerIndex": "apbPrescalerIndex"
            },
            "code": "uint32_t calculateSystemCoreClockFrequency_08002250(void)\n{\n    uint32_t leadingZeroesCount = count_leading_zeroes(0x1c0000);\n    uint32_t apbPrescalerIndex = (*(uint32_t *)PTR_SystemCoreClock_0800227c >> ((*(uint32_t *)(DAT_08002274 + 4) & 0x3800) >> (leadingZeroesCount & 0xff)));\n    return apbPrescalerTable[apbPrescalerIndex];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002250",
            "calling": [
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "calculateSystemCoreClockFrequency_08002250"
        },
        "FUN_080011fc": {
            "renaming": {
                "FUN_080011fc": "set_interrupt_priority_080011fc",
                "IRQn": "interrupt",
                "DAT_08001210": "interrupt_register_base_address"
            },
            "code": "void set_interrupt_priority_080011fc(IRQn_Type interrupt)\n{\n    int* interrupt_register_address = (int*)(DAT_08001210 + ((uint)(int)interrupt >> 5) * 4);\n    int interrupt_bit_position = (int)interrupt & 0x1fU;\n    int interrupt_bit_mask = 1 << interrupt_bit_position;\n    *interrupt_register_address = interrupt_bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080011fc",
            "calling": [
                "HAL_UART_MspInit"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_080011fc"
        },
        "FUN_08003f7c": {
            "renaming": {
                "FUN_08003f7c": "blinkLEDs_08003f7c",
                "iVar1": "count"
            },
            "code": "void blinkLEDs_08003f7c(void)\n{\n  int count = 3;\n  do {\n    toggleLED(1,0,0);\n    delay_ms(100);\n    toggleLED(0,1,0);\n    delay_ms(100);\n    toggleLED(0,0,1);\n    delay_ms(100);\n    count--;\n  } while (count > 0);\n  toggleLED(1,1,1);\n  return;\n}",
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f7c",
            "calling": [
                "Devices_Init"
            ],
            "imported": false,
            "current_name": "blinkLEDs_08003f7c"
        },
        "FUN_08005646": {
            "renaming": {
                "FUN_08005646": "reverse_copy_08005646",
                "__dest": "dest",
                "__src": "src",
                "__n": "n",
                "puVar1": "dst",
                "iVar2": "count",
                "puVar3": "source"
            },
            "code": "void * reverse_copy_08005646(void *dest, const void *src, size_t n) {\n    unsigned char *dst = (unsigned char *)dest;\n    const unsigned char *source = (const unsigned char *)src;\n    if (dst > source && dst < source + n) {\n        source += n;\n        dst += n;\n        while (n--) {\n            *--dst = *--source;\n        }\n    } else {\n        while (n--) {\n            *dst++ = *source++;\n        }\n    }\n    return dest;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005646",
            "calling": [
                "__ssputs_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_08005646"
        },
        "FUN_08000990": {
            "renaming": {
                "FUN_08000990": "convert_double_to_float_08000990",
                "param_1": "input_float"
            },
            "code": "undefined4 convert_double_to_float_08000990(undefined4 input_float)\n{\n  __nedf2();\n  return input_float;\n}",
            "called": [
                "__nedf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000990",
            "calling": [
                "__aeabi_dcmple",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmpeq"
            ],
            "imported": false,
            "current_name": "convert_double_to_float_08000990"
        },
        "FUN_08004ee6": {
            "renaming": {
                "FUN_08004ee6": "infinite_loop_08004ee6"
            },
            "code": "void infinite_loop_08004ee6(void)\n{\n    while(true)\n    {\n        // Do nothing\n    }\n}",
            "called": [
                "HardFault_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee6",
            "calling": [
                "HardFault_Handler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08004ee6"
        },
        "FUN_08004434": {
            "renaming": {
                "FUN_08004434": "send_altitude_frame_08004434",
                "in_r1": "altitude_data",
                "local_10": "altitude_frame_data",
                "local_c": "altitude",
                "PTR_msp_txf_altitude_08004454": "msp_txf_altitude_ptr"
            },
            "code": "void send_altitude_frame_08004434(void)\n{\n  uint16_t altitude;\n  uint32_t altitude_frame_data;\n  altitude = *(uint16_t*)PTR_msp_txf_altitude_08004454;\n  altitude_frame_data = (uint32_t)(altitude);\n  MSP_SendFrame('m', (uint8_t*)&altitude_frame_data, 6);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004434",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_altitude_frame_08004434"
        },
        "FUN_08001168": {
            "renaming": {
                "FUN_08001168": "do_nothing_08001168"
            },
            "code": "\nvoid do_nothing_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001168",
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "imported": false,
            "current_name": "do_nothing_08001168"
        },
        "FUN_08004ee4": {
            "renaming": {
                "FUN_08004ee4": "do_nothing_08004ee4"
            },
            "code": "\nvoid do_nothing_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee4",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004ee4"
        },
        "FUN_08004ee8": {
            "renaming": {
                "FUN_08004ee8": "infiniteLoop_08004ee8"
            },
            "code": "void infiniteLoop_08004ee8(void)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "MemManage_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ee8",
            "calling": [
                "MemManage_Handler"
            ],
            "imported": false,
            "current_name": "infiniteLoop_08004ee8"
        },
        "FUN_08004ffc": {
            "renaming": {
                "FUN_08004ffc": "print_formatted_string_08004ffc",
                "__s": "destination",
                "__format": "format",
                "local_78": "destination_array",
                "local_70": "destination_array_size",
                "local_6c": "format_array_size",
                "local_6a": "destination_array_max_chars",
                "local_68": "destination_array_copy",
                "local_64": "format_array_max_chars",
                "pcStack_c": "format_copy",
                "uStack_8": "in_r2_copy",
                "uStack_4": "in_r3_copy"
            },
            "code": "int print_formatted_string_08004ffc(char* destination, const char* format, ...) {\n  va_list args;\n  va_start(args, format);\n  int result = vsnprintf(destination, INT_MAX, format, args);\n  va_end(args);\n  return result;\n}",
            "called": [
                "_svfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ffc",
            "calling": [
                "serialInt"
            ],
            "imported": false,
            "current_name": "print_formatted_string_08004ffc"
        },
        "FUN_0800103c": {
            "renaming": {
                "FUN_0800103c": "is_not_equal_to_zero_or_both_are_zero_0800103c",
                "in_CY": "is_CY_not_equal_to_zero",
                "in_ZR": "is_ZR_not_equal_to_zero"
            },
            "code": "bool is_not_equal_to_zero_or_both_are_zero_0800103c(bool is_CY_not_equal_to_zero, bool is_ZR_not_equal_to_zero) {\n  __aeabi_cfcmpeq();\n  return !is_CY_not_equal_to_zero || is_ZR_not_equal_to_zero;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800103c",
            "calling": [],
            "imported": false,
            "current_name": "is_not_equal_to_zero_or_both_are_zero_0800103c"
        },
        "FUN_0800115c": {
            "renaming": {
                "FUN_0800115c": "get_uwTick_value_0800115c",
                "PTR_uwTick_08001164": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_0800115c(void)\n{\n  uint32_t* PTR_uwTick_08001164 = (uint32_t*)PTR_uwTick_08001164;\n  uint32_t uwTick_value = *PTR_uwTick_08001164;\n  return uwTick_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800115c",
            "calling": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "HAL_RCC_OscConfig",
                "HAL_I2C_Mem_Read",
                "millis",
                "I2C_RequestMemoryWrite",
                "HAL_RCC_ClockConfig",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_0800115c"
        },
        "FUN_08004f60": {
            "renaming": {
                "FUN_08004f60": "get_uwTick_08004f60",
                "PTR_uwTick_08001164": "PTR_uwTick_08001164"
            },
            "code": "uint32_t get_uwTick_08004f60(void)\n{\n  uint32_t* uwTick_ptr = (uint32_t*) PTR_uwTick_08001164;\n  return *uwTick_ptr;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f60",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "get_uwTick_08004f60"
        },
        "FUN_08002d88": {
            "renaming": {
                "FUN_08002d88": "read_mpu9250_magnetometer_data_08002d88",
                "puVar3": "i2c_data_ptr",
                "puVar4": "mag_data_ptr",
                "puVar5": "mag_calibration_ptr",
                "puVar6": "mag_bias_ptr",
                "bVar7": "i2c_byte",
                "uVar8": "temp_float",
                "uVar9": "m_res",
                "sVar1": "byte1",
                "sVar2": "byte2",
                "raw_data": "raw_data",
                "magRaw_08002e84": "mag_raw",
                "magCalib_08002e98": "mag_calibration",
                "magBias_08002e9c": "mag_bias",
                "magScale_08002e8c": "mag_scale",
                "magData_08002e90": "mag_data",
                "PTR_s____Src_MPU9250_c_08002e80": "i2c_data_ptr",
                "PTR_mRes_08002e88": "m_res_ptr",
                "PTR_msp_txf_status_08002e94": "msp_txf_status_ptr"
            },
            "code": "void read_mpu9250_magnetometer_data_08002d88(void)\n{\n  short byte1;\n  short byte2;\n  uint8_t raw_data [7];\n  uint8_t i2c_byte;\n  float m_res = 0.0f;\n  float mag_scale[3] = {0.0f, 0.0f, 0.0f};\n  float mag_bias[3] = {0.0f, 0.0f, 0.0f};\n  float mag_calibration[3] = {0.0f, 0.0f, 0.0f};\n  float mag_data[3] = {0.0f, 0.0f, 0.0f};\n  i2c_byte = I2C_ReadByte(0x18, 2, PTR_s____Src_MPU9250_c_08002e80, 0xd7);\n  if (i2c_byte >= 0) {\n    I2C_ReadByteArray(0x18, 3, raw_data, 7, PTR_s____Src_MPU9250_c_08002e80, 0xda);\n    if ((int)((uint)raw_data[6] << 0x1c) < 0) {\n      *(short *)(PTR_msp_txf_status_08002e94 + 2) = *(short *)(PTR_msp_txf_status_08002e94 + 2) + 1;\n    }\n    else {\n      byte1 = (short) ((raw_data[2] << 8) | raw_data[3]);\n      byte2 = (short) ((raw_data[4] << 8) | raw_data[5]);\n      raw_data[0] = raw_data[0];\n      raw_data[1] = raw_data[1];\n      mag_raw[0] = (float) raw_data[0];\n      mag_raw[1] = (float) byte1;\n      mag_raw[2] = (float) byte2;\n      m_res = (float) (*(int *) PTR_mRes_08002e88);\n      mag_scale[0] = *(float *) PTR_magScale_08002e8c;\n      mag_scale[1] = *(float *) (PTR_magScale_08002e8c + 4);\n      mag_scale[2] = *(float *) (PTR_magScale_08002e8c + 8);\n      mag_calibration[0] = *(float *) PTR_magCalib_08002e98;\n      mag_calibration[1] = *(float *) (PTR_magCalib_08002e98 + 4);\n      mag_calibration[2] = *(float *) (PTR_magCalib_08002e98 + 8);\n      mag_bias[0] = *(float *) PTR_magBias_08002e9c;\n      mag_bias[1] = *(float *) (PTR_magBias_08002e9c + 4);\n      mag_bias[2] = *(float *) (PTR_magBias_08002e9c + 8);\n      mag_data[0] = ((mag_raw[0] * m_res * mag_calibration[0]) - mag_bias[0]) * mag_scale[0];\n      mag_data[1] = ((mag_raw[1] * m_res * mag_calibration[1]) - mag_bias[1]) * mag_scale[1];\n      mag_data[2] = ((mag_raw[2] * m_res * mag_calibration[2]) - mag_bias[2]) * mag_scale[2];\n      *(float *) PTR_magData_08002e90 = mag_data[0];\n      *(float *) (PTR_magData_08002e90 + 4) = mag_data[1];\n      *(float *) (PTR_magData_08002e90 + 8) = mag_data[2];\n    }\n  }\n}",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "I2C_ReadByteArray",
                "__aeabi_fsub",
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002d88",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "read_mpu9250_magnetometer_data_08002d88"
        },
        "FUN_08004f64": {
            "renaming": {
                "FUN_08004f64": "do_nothing_08004f64"
            },
            "code": "\nvoid do_nothing_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "called": [
                "HAL_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f64",
            "calling": [
                "LED_StartupSequence",
                "I2C_WriteByte",
                "_Error_Handler",
                "MS5611_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f64"
        },
        "FUN_08002b48": {
            "renaming": {
                "FUN_08002b48": "read_accelerometer_data_08002b48",
                "in_r3": "input_value",
                "raw_data": "raw_accel_data",
                "puVar1": "accel_raw_ptr",
                "PTR_s____Src_MPU9250_c_08002be4": "mpu9250_ptr",
                "PTR_accelRaw_08002be8": "accel_raw_data_ptr",
                "PTR_accelData_08002bec": "accel_data_ptr",
                "uVar2": "conversion_result"
            },
            "code": "void read_accelerometer_data_08002b48(){\n  uint16_t raw_data[3];\n  uint32_t accel_data[3];\n  uint32_t temp_data;\n  uint32_t i2c_status;\n  i2c_status = I2C_ReadByteArray(0xd0, 0x3b, (uint8_t*)raw_data, 6, PTR_s____Src_MPU9250_c_08002be4, 0x58);\n  accel_data[0] = (uint32_t)raw_data[0] << 8 | raw_data[1];\n  accel_data[1] = (uint32_t)raw_data[2] << 8 | raw_data[3];\n  accel_data[2] = (uint32_t)raw_data[4] << 8 | raw_data[5];\n  accel_data[0] = (accel_data[0] * 0.00390625f);\n  accel_data[1] = (accel_data[1] * 0.00390625f);\n  accel_data[2] = (accel_data[2] * 0.00390625f);\n  temp_data = accel_data[1];\n  accel_data[1] = accel_data[2];\n  accel_data[2] = temp_data;\n}\n",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "I2C_ReadByteArray"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b48",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "read_accelerometer_data_08002b48"
        },
        "FUN_08004f68": {
            "renaming": {
                "FUN_08004f68": "initializeSystem_08004f68",
                "iVar1": "index",
                "puVar2": "completedPtr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "code": "void initializeSystem_08004f68(void)\n{\n  int index;\n  undefined4 *completedPtr = (undefined4 *)PTR_completed_8672_08004fa8;\n  code *jumpTable;\n  \n  for (index = 0; PTR_gyroBias_08004fa0 + index < PTR_completed_8672_08004fa4; index += 4) {\n    *(undefined4 *)(PTR_gyroBias_08004fa0 + index) = *(undefined4 *)(PTR__sidata_08004f9c + index);\n  }\n  for (; completedPtr < PTR__ebss_08004fac; completedPtr++) {\n    *completedPtr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8004f9a;\n  main();\n  /* WARNING: Could not recover jumptable at 0x08004f9a. Too many branches */\n  /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n",
            "called": [
                "SystemInit",
                "main",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f68",
            "calling": [],
            "imported": false,
            "current_name": "initializeSystem_08004f68"
        },
        "FUN_08001170": {
            "renaming": {
                "FUN_08001170": "set_priority_group_08001170",
                "PriorityGroup": "priority_group",
                "DAT_08001190": "register_address",
                "PTR_0800119c": "register_value",
                "PTR_080011a0": "priority_bits",
                "PTR_080011a4": "new_register_value"
            },
            "code": "void set_priority_group_08001170(uint32_t priority_group) {\n    uint32_t *DAT_08001190 = (uint32_t *)(DAT_08001190 + 0xc);\n    uint32_t PTR_0800119c = *DAT_08001190;\n    uint32_t PTR_080011a0 = priority_group & 7;\n    uint32_t PTR_080011a4 = (PTR_0800119c & 0xf8ff) | 0x5fa0000 | (PTR_080011a0 << 8);\n    *DAT_08001190 = PTR_080011a4;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001170",
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "imported": false,
            "current_name": "set_priority_group_08001170"
        },
        "FUN_08002bf0": {
            "renaming": {
                "FUN_08002bf0": "read_gyro_data_08002bf0",
                "raw_data": "raw_data",
                "I2C_ReadByteArray": "I2C_ReadByteArray",
                "gyro_src": "gyro_src",
                "gyroRaw_08002ca0": "x_gyro",
                "gyroBias_08002ca4": "gyro_bias",
                "gyroData_08002cac": "gyro_data",
                "gyro_scale_factor": "gyro_scale_factor"
            },
            "code": "void read_gyro_data_08002bf0(void)\n{\n  uint8_t raw_data[6];\n  raw_data[0] = 0;\n  raw_data[1] = 0;\n  I2C_ReadByteArray(0xd0, 0x43, raw_data, 6, gyro_src, 0x7b);\n  float x_gyro = (float)((int16_t)((raw_data[0] << 8) | raw_data[1])) * gyro_scale_factor - gyro_bias[0];\n  float y_gyro = (float)((int16_t)((raw_data[2] << 8) | raw_data[3])) * gyro_scale_factor - gyro_bias[1];\n  float z_gyro = (float)((int16_t)((raw_data[4] << 8) | raw_data[5])) * gyro_scale_factor - gyro_bias[2];\n  gyro_data[0] = x_gyro;\n  gyro_data[1] = y_gyro;\n  gyro_data[2] = z_gyro;\n}\n",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "I2C_ReadByteArray",
                "__aeabi_fsub"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002bf0",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "read_gyro_data_08002bf0"
        },
        "FUN_08004ef0": {
            "renaming": {
                "FUN_08004ef0": "do_nothing_08004ef0"
            },
            "code": "\nvoid do_nothing_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004ef0"
        },
        "FUN_08002ad0": {
            "renaming": {
                "FUN_08002ad0": "read_and_configure_MPU9250_08002ad0",
                "0xd0": "MPU9250_DEVICE_ADDRESS",
                "0x75": "MPU9250_WHO_AM_I_REGISTER",
                "PTR_s____Src_MPU9250_c_08002b44": "MPU9250_who_am_i",
                "0x3b": "MPU9250_READ_SIZE",
                "0x6b": "MPU9250_PWR_MGMT_1_REGISTER",
                "0x80": "MPU9250_RESET_VALUE",
                "'\\x01'": "MPU9250_PWR_MGMT_2_VALUE",
                "0x19": "MPU9250_CONFIG_REGISTER",
                "0x1d": "MPU9250_SMPLRT_DIV_REGISTER",
                "0x01": "MPU9250_SMPLRT_DIV_VALUE",
                "0x1a": "MPU9250_ACCEL_CONFIG_REGISTER",
                "0x03": "MPU9250_ACCEL_CONFIG_VALUE",
                "0x1b": "MPU9250_ACCEL_CONFIG_2_REGISTER",
                "0x10": "MPU9250_ACCEL_CONFIG_2_VALUE",
                "0x1c": "MPU9250_GYRO_CONFIG_REGISTER",
                "0x0b": "MPU9250_GYRO_CONFIG_VALUE",
                "0x6c": "MPU9250_PWR_MGMT_2_REGISTER"
            },
            "code": "void read_and_configure_MPU9250_08002ad0(void) {\n  I2C_ReadByte(MPU9250_DEVICE_ADDRESS, MPU9250_WHO_AM_I_REGISTER, PTR_s____Src_MPU9250_c_08002b44, MPU9250_READ_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_PWR_MGMT_1_REGISTER, MPU9250_RESET_VALUE, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_PWR_MGMT_1_REGISTER, MPU9250_CLKSEL_INTERNAL_OSCILLATOR, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_CONFIG_REGISTER, MPU9250_DLPF_CFG_0, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_SMPLRT_DIV_REGISTER, MPU9250_SMPLRT_DIV_VALUE, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_ACCEL_CONFIG_REGISTER, MPU9250_ACCEL_CONFIG_VALUE, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_ACCEL_CONFIG_2_REGISTER, MPU9250_ACCEL_CONFIG_2_VALUE, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_GYRO_CONFIG_REGISTER, MPU9250_GYRO_CONFIG_VALUE, MPU9250_WRITE_SIZE);\n  I2C_WriteByte(MPU9250_DEVICE_ADDRESS, MPU9250_PWR_MGMT_2_REGISTER, MPU9250_PWR_MGMT_2_VALUE, MPU9250_WRITE_SIZE);\n  return;\n}",
            "called": [
                "I2C_WriteByte",
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ad0",
            "calling": [
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "read_and_configure_MPU9250_08002ad0"
        },
        "FUN_08001050": {
            "renaming": {
                "FUN_08001050": "is_not_carry_or_zero_08001050",
                "in_CY": "carry_flag",
                "in_ZR": "zero_flag",
                "! (bool)in_CY": "not_carry",
                "(bool)in_ZR": "zero"
            },
            "code": "bool is_not_carry_or_zero_08001050(void)\n{\n  bool not_carry = !(bool)in_CY;\n  bool zero = (bool)in_ZR;\n  return not_carry || zero;\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001050",
            "calling": [
                "AHRS_GetYaw"
            ],
            "imported": false,
            "current_name": "is_not_carry_or_zero_08001050"
        },
        "FUN_08004ef4": {
            "renaming": {
                "FUN_08004ef4": "increment_system_tick_and_handle_systick_interrupt_08004ef4",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void increment_system_tick_and_handle_systick_interrupt_08004ef4(void)\n{\n    HAL_IncTick();\n    HAL_SYSTICK_IRQHandler();\n    return;\n}",
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef4",
            "calling": [],
            "imported": false,
            "current_name": "increment_system_tick_and_handle_systick_interrupt_08004ef4"
        },
        "FUN_08004ef2": {
            "renaming": {
                "FUN_08004ef2": "do_nothing_08004ef2"
            },
            "code": "\nvoid do_nothing_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ef2",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004ef2"
        },
        "FUN_080043bc": {
            "renaming": {
                "FUN_080043bc": "copy_imu_data_to_local_buffer_and_send_frame_080043bc",
                "uVar1": "imu_data_word_1",
                "uVar2": "imu_data_word_2",
                "puVar3": "local_buffer_ptr_1",
                "puVar4": "imu_data_ptr_1",
                "local_24": "local_buffer",
                "local_1c": "unused",
                "*(undefined2 *)puVar3": "imu_data_last_word",
                "PTR_msp_txf_raw_imu_080043ec": "imu_data_ptr_start"
            },
            "code": "void copy_imu_data_to_local_buffer_and_send_frame_080043bc(void)\n{\n  undefined4 imu_data_word_1;\n  undefined4 imu_data_word_2;\n  undefined4 *local_buffer_ptr_1;\n  undefined4 *imu_data_ptr_1;\n  undefined2 *local_buffer_ptr_2;\n  undefined2 *imu_data_ptr_2;\n  undefined2 imu_data_last_word;\n  local_buffer_ptr_1 = &local_buffer[0];\n  imu_data_ptr_1 = (undefined4 *)PTR_msp_txf_raw_imu_080043ec;\n  do {\n    imu_data_word_1 = *imu_data_ptr_1;\n    imu_data_word_2 = imu_data_ptr_1[1];\n    imu_data_ptr_1 += 2;\n    *local_buffer_ptr_1 = imu_data_word_1;\n    local_buffer_ptr_1[1] = imu_data_word_2;\n    local_buffer_ptr_1 += 2;\n  } while (imu_data_ptr_1 != (undefined4 *)(PTR_msp_txf_raw_imu_080043ec + 0x10));\n  imu_data_ptr_2 = (undefined2 *)imu_data_ptr_1;\n  local_buffer_ptr_2 = (undefined2 *)local_buffer_ptr_1;\n  imu_data_last_word = *imu_data_ptr_2;\n  *local_buffer_ptr_2 = imu_data_last_word;\n  MSP_SendFrame('f', (uint8_t *)local_buffer, 0x12);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043bc",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "copy_imu_data_to_local_buffer_and_send_frame_080043bc"
        },
        "FUN_08004f5c": {
            "renaming": {
                "FUN_08004f5c": "get_uwTick_value_08004f5c",
                "PTR_uwTick_08001164": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_08004f5c(void)\n{\n  uint32_t* PTR_uwTick_08001164 = (uint32_t*)PTR_uwTick_08001164;\n  return *PTR_uwTick_08001164;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f5c",
            "calling": [
                "MS5611_Update",
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08004f5c"
        },
        "FUN_08000404": {
            "renaming": {
                "FUN_08000404": "reverseBits_08000404",
                "param_1": "num",
                "uVar1": "mask",
                "uVar2": "num",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "trailing_zeros",
                "uVar6": "is_negative",
                "bVar7": "is_negative_overflow",
                "bVar8": "is_negative_zero",
                "bVar9": "is_shift_amount_overflow",
                "in_r12": "temp"
            },
            "code": "ulonglong reverseBits_08000404(uint num)\n{\n  uint mask = 0x80000000;\n  uint leading_zeros = 0;\n  uint trailing_zeros = 0;\n  uint result = 0;\n  bool is_negative = (int)num < 0;\n  if (num == 0) {\n    return 0;\n  }\n  if (is_negative) {\n    num = -num;\n  }\n  leading_zeros = count_leading_zeroes(num);\n  trailing_zeros = leading_zeros - 11;\n  if (leading_zeros < 0x20) {\n    result = num << (leading_zeros + 0x15);\n    result |= num >> (0x20 - (leading_zeros + 0xc));\n  }\n  else {\n    uint in_r12 = 0x20 - leading_zeros;\n    result = num << trailing_zeros;\n    result |= 0U >> in_r12;\n    result |= 0 << trailing_zeros;\n  }\n  if (leading_zeros < 0x433) {\n    return result | (ulonglong)is_negative << 0x20;\n  }\n  uint shift_amount = ~(0x432 - leading_zeros);\n  if (shift_amount > 0x1e) {\n    return ((ulonglong)num << (shift_amount - 0x1f)) & 0x80000000ffffffff;\n  }\n  int diff = shift_amount - 0x13;\n  if (diff == 0 || (diff < 0) != (shift_amount - 0x1f < 0xc)) {\n    shift_amount++;\n    return (result >> shift_amount) | ((result << (0x20 - shift_amount)) & 0xffffffff00000000) | (ulonglong)is_negative << 0x20;\n  }\n  return ((ulonglong)num << (0xc - diff)) | ((result >> (0x20 - (0xc - diff))) & 0xffffffff00000000) | (ulonglong)is_negative << 0x20;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000404",
            "calling": [
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "reverseBits_08000404"
        },
        "FUN_08004eec": {
            "renaming": {
                "FUN_08004eec": "wait_forever_08004eec"
            },
            "code": "void wait_forever_08004eec(void)\n{\n  while(true) {\n    // do nothing\n  }\n}",
            "called": [
                "UsageFault_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004eec",
            "calling": [
                "UsageFault_Handler"
            ],
            "imported": false,
            "current_name": "wait_forever_08004eec"
        },
        "FUN_08004eea": {
            "renaming": {
                "FUN_08004eea": "wait_forever_08004eea"
            },
            "code": "void wait_forever_08004eea(void)\n{\n  while( true )\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "BusFault_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004eea",
            "calling": [
                "BusFault_Handler"
            ],
            "imported": false,
            "current_name": "wait_forever_08004eea"
        },
        "FUN_08006070": {
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "first_input",
                "param_2": "second_input",
                "param_3": "third_input",
                "param_4": "fourth_input",
                "param_5": "fifth_input",
                "uVar1": "temp1",
                "extraout_r1": "temp2",
                "extraout_r1_00": "temp3",
                "unaff_r4": "temp4",
                "iVar2": "temp5",
                "uVar3": "temp6",
                "uVar4": "temp7",
                "uVar6": "temp8",
                "uVar7": "result",
                "uVar8": "temp9"
            },
            "code": "undefined8 calculate_result_08006070(uint32_t first_input, uint32_t second_input, uint32_t third_input, uint32_t fourth_input, double fifth_input) {\n    undefined4 temp1;\n    undefined4 temp2;\n    int temp3;\n    undefined4 temp4;\n    int temp5;\n    uint32_t temp6;\n    uint32_t temp7;\n    undefined8 result;\n    undefined8 temp8;\n    result = CONCAT44(DAT_08006204, DAT_08006200);\n    temp6 = fourth_input & 0x7fffffff;\n    if (DAT_08006220 < (temp6 | (-third_input | third_input) >> 0x1f) || DAT_08006220 < ((second_input & 0x7fffffff) | (-first_input | first_input) >> 0x1f)) {\n        temp8 = __aeabi_dadd(first_input, second_input);\n        return temp8;\n    }\n    if ((fourth_input + 0xc0100000 | third_input) == 0) {\n        atan(fifth_input);\n        return CONCAT44(extraout_r1, first_input);\n    }\n    temp7 = (int)fourth_input >> 0x1e & 2U | second_input >> 0x1f;\n    if ((first_input | (second_input & 0x7fffffff)) == 0) {\n        if (temp7 == 2) {\n            return CONCAT44(DAT_080061fc, DAT_080061f8);\n        }\n        if (temp7 != 3) {\n            return CONCAT44(second_input, first_input);\n        }\n    }\n    else {\n        if ((third_input | temp6) != 0) {\n            if (temp6 == DAT_08006220) {\n                if ((second_input & 0x7fffffff) == DAT_08006220) {\n                    if (temp7 == 2) {\n                        return CONCAT44(DAT_080061ec, DAT_080061e8);\n                    }\n                    if (temp7 == 3) {\n                        return CONCAT44(DAT_080061f4, DAT_080061f0);\n                    }\n                    if (temp7 != 1) {\n                        return CONCAT44(DAT_0800621c, DAT_08006218);\n                    }\n                    return CONCAT44(DAT_080061e4, DAT_080061e0);\n                }\n                if (temp7 == 2) {\n                    return CONCAT44(DAT_080061fc, DAT_080061f8);\n                }\n                if (temp7 == 3) {\n                    return result;\n                }\n                if (temp7 == 1) {\n                    return 0x8000000000000000;\n                }\n                return 0;\n            }\n            if ((second_input & 0x7fffffff) != DAT_08006220) {\n                temp5 = (int)((second_input & 0x7fffffff) - temp6) >> 0x14;\n                temp1 = DAT_08006210;\n                temp2 = DAT_08006214;\n                if (temp5 < 0x3d) {\n                    if ((int)fourth_input < 0 && temp5 + 0x3c < 0 != SCARRY4(temp5, 0x3c)) {\n                        temp1 = 0;\n                        temp2 = 0;\n                    }\n                    else {\n                        temp1 = __divdf3(first_input, second_input);\n                        fabs((double)CONCAT44(temp4, fourth_input));\n                        atan((double)CONCAT44(temp4, fourth_input));\n                        temp2 = temp3;\n                    }\n                }\n                if (temp7 != 1) {\n                    if (temp7 == 2) {\n                        temp8 = __subdf3(temp1, temp2, DAT_08006208, DAT_0800620c);\n                        result = CONCAT44(DAT_080061fc, DAT_080061f8);\n                    }\n                    else {\n                        if (temp7 == 0) {\n                            return CONCAT44(temp2, temp1);\n                        }\n                        result = __subdf3(temp1, temp2, DAT_08006208, DAT_0800620c);\n                        temp8 = CONCAT44(DAT_080061fc, DAT_080061f8);\n                    }\n                    result = __subdf3((int)result, (int)((ulonglong)result >> 0x20), (int)temp8, (int)((ulonglong)temp8 >> 0x20));\n                    return result;\n                }\n                return CONCAT44(temp2 + -0x80000000, temp1);\n            }\n        }\n        result = CONCAT44(DAT_08006214, DAT_08006210);\n        if ((int)second_input < 0) {\n            result = CONCAT44(DAT_080061dc, DAT_080061d8);\n        }\n    }\n    return result;\n}",
            "called": [
                "__divdf3",
                "__aeabi_dadd",
                "atan",
                "fabs",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006070",
            "calling": [
                "atan2"
            ],
            "imported": false,
            "current_name": "calculate_result_08006070"
        },
        "FUN_08004cac": {
            "renaming": {
                "FUN_08004cac": "print_and_send_serial_data_08004cac",
                "val": "value",
                "data": "tx_buffer",
                "PTR_tx_buffer_08004cc4": "tx_buffer",
                "PTR_DAT_08004cc8": "data",
                "serialPrint": "serialPrint"
            },
            "code": "void print_and_send_serial_data_08004cac(int value) {\n  undefined *serial_PTR_DAT_08004cc8;\n  serial_PTR_DAT_08004cc8 = PTR_tx_buffer_08004cc4;\n  siprintf(PTR_tx_buffer_08004cc4, PTR_DAT_08004cc8, value);\n  serialPrint(serial_PTR_DAT_08004cc8);\n  return;\n}",
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004cac",
            "calling": [
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "print_and_send_serial_data_08004cac"
        },
        "FUN_08004eee": {
            "renaming": {
                "FUN_08004eee": "do_nothing_08004eee"
            },
            "code": "\nvoid do_nothing_08004eee(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004eee",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08004eee"
        },
        "FUN_08004c18": {
            "renaming": {
                "FUN_08004c18": "transmit_data_08004c18",
                "ch": "data",
                "pData": "buffer",
                "PTR_tx_buffer_08004c28": "tx_buffer",
                "HAL_UART_Transmit": "HAL_UART_Transmit",
                "UART_HandleTypeDef": "huart1"
            },
            "code": "void transmit_data_08004c18(uchar data){\n                      undefined *buffer;\n                      buffer = PTR_tx_buffer_08004c28;\n                      *PTR_tx_buffer_08004c28 = data;\n                      HAL_UART_Transmit((UART_HandleTypeDef *)huart1,buffer,1,5);\n                    }",
            "called": [
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c18",
            "calling": [
                "MSP_SendFrame",
                "_Error_Handler",
                "serialPrint"
            ],
            "imported": false,
            "current_name": "transmit_data_08004c18"
        },
        "FUN_08004c8c": {
            "renaming": {
                "FUN_08004c8c": "printSerialData_08004c8c",
                "*data": "data",
                "sVar1": "dataLength",
                "*puVar2": "currentCharPtr"
            },
            "code": "void printSerialData_08004c8c(char* data)\n{\n    size_t dataLength = strlen(data);\n    uchar* currentCharPtr;\n    for (currentCharPtr = (uchar*)data; (uint)((int)currentCharPtr - (int)data) < dataLength; currentCharPtr++)\n    {\n        serialWrite(*currentCharPtr);\n    }\n}",
            "called": [
                "strlen",
                "serialWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c8c",
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "printSerialData_08004c8c"
        },
        "FUN_08001460": {
            "renaming": {
                "FUN_08001460": "checkFlag_08001460",
                "*hi2c": "*handle",
                "Flag": "flag",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "uVar3": "statusRegister",
                "pIVar4": "instance"
            },
            "code": "HAL_StatusTypeDef checkFlag_08001460(I2C_HandleTypeDef *handle, uint32_t flag, uint32_t timeout) {\n    uint32_t startTime = HAL_GetTick();\n    do {\n        I2C_TypeDef *instance = handle->Instance;\n        uint32_t statusRegister;\n        if ((flag << 8) >> 0x18 == 1) {\n            statusRegister = instance->SR1;\n        }\n        else {\n            statusRegister = instance->SR2;\n        }\n        if ((flag & 0xffff & ~statusRegister) == 0) {\n            return HAL_OK;\n        }\n        if ((int)(instance->SR1 << 0x15) < 0) {\n            instance->CR1 = instance->CR1 | 0x200;\n            instance->SR1 = instance->SR1 & 0xfffffbff;\n            handle->ErrorCode = 4;\n            handle->State = HAL_I2C_STATE_READY;\n            handle->Lock = HAL_UNLOCKED;\n            return HAL_ERROR;\n        }\n    } while ((timeout == 0xffffffff) || ((timeout != 0 && (HAL_GetTick() - startTime <= timeout))));\n    handle->State = HAL_I2C_STATE_READY;\n    handle->Lock = HAL_UNLOCKED;\n    return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001460",
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "imported": false,
            "current_name": "checkFlag_08001460"
        },
        "FUN_08003fd0": {
            "renaming": {
                "FUN_08003fd0": "set_pwm_value_08003fd0",
                "pwm": "pwm_value",
                "PTR_htim4_08003fd8": "htim4"
            },
            "code": "void set_pwm_value_08003fd0(int pwm_value)\n{\n    int* PTR_htim4_08003fd8 = *(int*)PTR_PTR_htim4_08003fd8_08003fd8;\n    int* pwm_register_address = PTR_htim4_08003fd8 + 0x3c;\n    *pwm_register_address = pwm_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd0",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_value_08003fd0"
        },
        "FUN_08000134": {
            "renaming": {
                "FUN_08000134": "concatenate_pointers_if_initialized_08000134",
                "param_1": "init_ptr",
                "param_2": "obj_ptr",
                "DAT_08000144": "DAT_initialized",
                "PTR__init_0800014c": "PTR_init",
                "PTR_object_8677_08000148": "PTR_object"
            },
            "code": "typedef unsigned long long undefined8;\n\nundefined8 concatenate_pointers_if_initialized_08000134(undefined *init_ptr, undefined *obj_ptr)\n{\n  if (DAT_08000144 != 0) {\n    init_ptr = PTR__init_0800014c;\n    obj_ptr = PTR_object_8677_08000148;\n  }\n  return CONCAT44(obj_ptr, init_ptr);\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000134",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "concatenate_pointers_if_initialized_08000134"
        },
        "FUN_08003eb0": {
            "renaming": {
                "FUN_08003eb0": "calculate_afl_call_result_08003eb0",
                "ticks": "ticks",
                "uVar1": "result",
                "PTR_noHyperCall_08003ec4": "PTR_noHyperCall_08003ec4"
            },
            "code": "uint32_t calculate_afl_call_result_08003eb0(int ticks) {\n  uint32_t result;\n  if (*(int *)PTR_noHyperCall_08003ec4 == 0) {\n    result = aflCall(1, ticks, 0);\n    return result;\n  }\n  return 0;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003eb0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "calculate_afl_call_result_08003eb0"
        },
        "FUN_08005c70": {
            "renaming": {
                "FUN_08005c70": "FUNC_08005c70"
            },
            "code": "\nulonglong FUNC_08005c70(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 extraout_r1;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  ulonglong uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined4 in_stack_ffffffc8;\n  \n  uVar9 = CONCAT44(param_2,param_1);\n  uVar8 = param_2 & 0x7fffffff;\n  if (DAT_08005f90 < (int)uVar8) {\n    if ((uVar8 + 0xc0100000 | param_1) != 0) {\n      uVar10 = __subdf3(param_1,param_2,param_1,param_2);\n      uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar9 = __divdf3((int)uVar10,uVar2,(int)uVar10,uVar2);\n      return uVar9;\n    }\n    uVar9 = __muldf3(param_1,param_2,DAT_08005f28,DAT_08005f2c);\n    uVar10 = __muldf3(param_1,param_2,DAT_08005f30,DAT_08005f34);\nLAB_08005cba:\n    uVar9 = __aeabi_dadd((int)uVar9,(int)(uVar9 >> 0x20),(int)uVar10,\n                         (int)((ulonglong)uVar10 >> 0x20));\n  }\n  else {\n    if ((int)uVar8 <= DAT_08005f94) {\n      if (0x3e3fffff < uVar8) {\n        uVar10 = __muldf3(param_1,param_2,param_1,param_2);\n        uVar7 = (undefined4)((ulonglong)uVar10 >> 0x20);\n        uVar2 = (undefined4)uVar10;\n        uVar10 = __muldf3(uVar2,uVar7,DAT_08005f40,DAT_08005f44);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f48,DAT_08005f4c\n                             );\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f50,DAT_08005f54);\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f58,DAT_08005f5c\n                             );\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f60,DAT_08005f64);\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f68,DAT_08005f6c\n                             );\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar7);\n        uVar11 = __muldf3(uVar2,uVar7,DAT_08005f70,DAT_08005f74);\n        uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f78,DAT_08005f7c);\n        uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar7);\n        uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f80,DAT_08005f84\n                             );\n        uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar7);\n        uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f88,DAT_08005f8c);\n        uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar7);\n        uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),0,DAT_08005f98);\n        uVar10 = __divdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                          (int)((ulonglong)uVar11 >> 0x20));\n        uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),param_1,param_2);\n        goto LAB_08005cba;\n      }\n      uVar10 = __aeabi_dadd(param_1,param_2,DAT_08005f38,DAT_08005f3c);\n      iVar1 = __aeabi_dcmpgt((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08005f98);\n      if (iVar1 != 0) {\n        return uVar9;\n      }\n    }\n    fabs((double)CONCAT44(param_2,in_stack_ffffffc8));\n    uVar10 = __subdf3(0,DAT_08005f98,param_1,extraout_r1);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08005f9c);\n    uVar3 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar2 = (undefined4)uVar10;\n    uVar10 = __muldf3(uVar2,uVar3,DAT_08005f40,DAT_08005f44);\n    uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f48,DAT_08005f4c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f50,DAT_08005f54);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f58,DAT_08005f5c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f60,DAT_08005f64);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f68,DAT_08005f6c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar2,uVar3);\n    uVar4 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar11 = __muldf3(uVar2,uVar3,DAT_08005f70,DAT_08005f74);\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f78,DAT_08005f7c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar3);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f80,DAT_08005f84);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar3);\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),DAT_08005f88,DAT_08005f8c);\n    uVar11 = __muldf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),uVar2,uVar3);\n    uVar11 = __aeabi_dadd((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),0,DAT_08005f98);\n    uVar5 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar12 = __ieee754_sqrt(uVar2,uVar3);\n    uVar6 = (undefined4)((ulonglong)uVar12 >> 0x20);\n    uVar7 = (undefined4)uVar12;\n    if (DAT_08005fa0 < (int)uVar8) {\n      uVar10 = __divdf3((int)uVar10,uVar4,(int)uVar11,uVar5);\n      uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar7,uVar6);\n      uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar7,uVar6);\n      uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar10 = __aeabi_dadd((int)uVar10,uVar2,(int)uVar10,uVar2);\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08005f30,DAT_08005f34);\n      uVar2 = DAT_08005f28;\n      uVar7 = DAT_08005f2c;\n    }\n    else {\n      uVar10 = __divdf3((int)uVar10,uVar4,(int)uVar11,uVar5);\n      uVar11 = __aeabi_dadd(uVar7,uVar6,uVar7,uVar6);\n      uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                        (int)((ulonglong)uVar11 >> 0x20));\n      uVar11 = __muldf3(0,uVar6,0,uVar6);\n      uVar11 = __subdf3(uVar2,uVar3,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n      uVar12 = __aeabi_dadd(uVar7,uVar6,0,uVar6);\n      uVar11 = __divdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar12,\n                        (int)((ulonglong)uVar12 >> 0x20));\n      uVar2 = (undefined4)((ulonglong)uVar11 >> 0x20);\n      uVar11 = __aeabi_dadd((int)uVar11,uVar2,(int)uVar11,uVar2);\n      uVar11 = __subdf3(DAT_08006060,DAT_08006064,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                        (int)((ulonglong)uVar11 >> 0x20));\n      uVar11 = __aeabi_dadd(0,uVar6,0,uVar6);\n      uVar11 = __subdf3(DAT_08006068,DAT_0800606c,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                        (int)((ulonglong)uVar11 >> 0x20));\n      uVar2 = DAT_08006068;\n      uVar7 = DAT_0800606c;\n    }\n    uVar9 = __subdf3(uVar2,uVar7,(int)uVar10,(int)((ulonglong)uVar10 >> 0x20));\n    if ((int)param_2 < 1) {\n      uVar9 = uVar9 & 0xffffffff | (ulonglong)((int)(uVar9 >> 0x20) + 0x80000000) << 0x20;\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "__divdf3",
                "__muldf3",
                "__ieee754_sqrt",
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "fabs",
                "__subdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005c70",
            "calling": [
                "asin"
            ],
            "imported": false,
            "current_name": "FUNC_08005c70"
        },
        "FUN_08002ee8": {
            "renaming": {
                "FUN_08002ee8": "calculate_ahrs_angle_08002ee8",
                "iVar1": "is_greater_than_or_equal_to_threshold",
                "uVar2": "angle_value",
                "DAT_08002f1c": "AHRS_ANGLE_THRESHOLD",
                "DAT_08002f20": "AHRS_ANGLE_UPPER_LIMIT",
                "DAT_08002f24": "AHRS_ANGLE_LOWER_LIMIT"
            },
            "code": "float calculate_ahrs_angle_08002ee8(void)\n{\n  int is_greater_than_or_equal_to_threshold;\n  undefined4 angle_value = *(undefined4 *)(PTR_AHRS_Angle_08002f18 + 8);\n  is_greater_than_or_equal_to_threshold = __aeabi_fcmpge(angle_value, DAT_08002f1c);\n  if ((is_greater_than_or_equal_to_threshold != 0) && (__aeabi_fcmplt(angle_value, DAT_08002f20))) {\n    float result = (float)__addsf3(angle_value, DAT_08002f20);\n    return result;\n  }\n  float result = (float)__aeabi_fsub(angle_value, DAT_08002f24);\n  return result;\n}",
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmpge",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ee8",
            "calling": [
                "AHRS_ComputeAngles",
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_ahrs_angle_08002ee8"
        },
        "FUN_08001104": {
            "renaming": {
                "FUN_08001104": "configureSysTickTimer_08001104",
                "TickPriority": "tickPriority",
                "uVar1": "hclkFreq",
                "SysTick_IRQn": "SysTick_IRQn",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef configureSysTickTimer_08001104(uint32_t tickPriority)\n{\n  uint32_t hclkFreq = HAL_RCC_GetHCLKFreq();\n  uint32_t systickInterval = hclkFreq / 1000;\n  HAL_SYSTICK_Config(systickInterval);\n  HAL_NVIC_SetPriority(SysTick_IRQn, tickPriority, 0);\n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001104",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configureSysTickTimer_08001104"
        },
        "FUN_08004978": {
            "renaming": {
                "FUN_08004978": "initialize_pid_values_08004978",
                "PTR_pid_roll_080049e8": "roll_pid",
                "PTR_pid_pitch_080049ec": "pitch_pid",
                "PTR_pid_yaw_080049f0": "yaw_pid",
                "PTR_pid_altitude_080049f4": "altitude_pid",
                "DAT_080049f8": "pitch_kp",
                "DAT_08004a10": "pitch_kd",
                "DAT_08004a00": "pitch_ki",
                "DAT_08004a08": "pitch_integrator_max",
                "DAT_08004a14": "pitch_integrator_min",
                "DAT_08004a18": "roll_kp",
                "DAT_08004a20": "roll_integrator_min",
                "DAT_08004a24": "yaw_kp",
                "DAT_08004a28": "yaw_ki",
                "DAT_08004a2c": "altitude_kp"
            },
            "code": "void initialize_pid_values_08004978(void)\n{\n    float* PTR_pid_roll_080049e8 = PTR_pid_roll_080049e8;\n    float* PTR_pid_pitch_080049ec = PTR_pid_pitch_080049ec;\n    float* PTR_pid_yaw_080049f0 = PTR_pid_yaw_080049f0;\n    float* PTR_pid_altitude_080049f4 = PTR_pid_altitude_080049f4;\n    \n    *(PTR_pid_yaw_080049f0 + 0x4c) = -1.0f;\n    *(PTR_pid_roll_080049e8 + 0x4c) = 1.0f;\n    *(PTR_pid_pitch_080049ec + 0x4c) = 1.0f;\n    *(PTR_pid_altitude_080049f4 + 0x4c) = 1.0f;\n    \n    *(PTR_pid_pitch_080049ec + 0x20) = 0.0f;\n    *(PTR_pid_roll_080049e8 + 0x20) = 0.0f;\n    *(PTR_pid_yaw_080049f0 + 0x20) = 0.0f;\n    *(PTR_pid_altitude_080049f4 + 0x20) = 0.0f;\n    \n    *(PTR_pid_pitch_080049ec + 0x4) = DAT_080049f8;\n    *(PTR_pid_pitch_080049ec + 0x8) = DAT_08004a10;\n    *(PTR_pid_pitch_080049ec + 0xc) = DAT_08004a00;\n    *(PTR_pid_pitch_080049ec + 0x10) = DAT_08004a08;\n    *(PTR_pid_pitch_080049ec + 0x14) = DAT_08004a10;\n    *(PTR_pid_pitch_080049ec + 0x18) = DAT_08004a14;\n    \n    *(PTR_pid_roll_080049e8 + 0x4) = DAT_08004a18;\n    *(PTR_pid_roll_080049e8 + 0x8) = DAT_08004a10;\n    *(PTR_pid_roll_080049e8 + 0xc) = DAT_080049f8;\n    *(PTR_pid_roll_080049e8 + 0x10) = DAT_08004a18;\n    *(PTR_pid_roll_080049e8 + 0x14) = DAT_08004a10;\n    *(PTR_pid_roll_080049e8 + 0x18) = DAT_08004a20;\n    \n    *(PTR_pid_yaw_080049f0 + 0x4) = DAT_08004a24;\n    *(PTR_pid_yaw_080049f0 + 0x8) = DAT_08004a28;\n    *(PTR_pid_yaw_080049f0 + 0xc) = DAT_08004a00;\n    *(PTR_pid_yaw_080049f0 + 0x10) = 0.0f;\n    \n    *(PTR_pid_altitude_080049f4 + 0x4) = DAT_08004a2c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004978",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_pid_values_08004978"
        },
        "FUN_08000c60": {
            "renaming": {
                "FUN_08000c60": "calculate_hash_08000c60",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "var_1",
                "uVar2": "var_2",
                "iVar3": "var_4",
                "uVar4": "var_5",
                "iVar5": "var_3",
                "uVar6": "var_6"
            },
            "code": "uint calculate_hash_08000c60(uint input_1, uint input_2)\n{\n  uint output;\n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  uint var_1 = input_1;\n  uint var_2 = input_2;\n  if (input_2 == 0) {\n    var_1 = 0;\n    var_2 = input_1;\n  }\n  int var_3 = 0x5b000000;\n  if (input_2 == 0) {\n    var_3 = 0x4b000000;\n  }\n  int var_4 = count_leading_zeroes(var_2);\n  uint var_5 = var_4 - 8;\n  var_3 = var_3 + -0x800000 + var_5 * -0x800000;\n  if (var_4 < 8) {\n    var_5 = var_2 << (var_4 + 0x18U & 0xff);\n    var_2 = var_3 + ((var_2 >> (0x20 - (var_4 + 0x18U) & 0xff)) - ((int)var_5 >> 0x1f));\n    if ((var_1 | var_5 << 1) == 0) {\n      var_2 = var_2 & ~(var_5 >> 0x1f);\n    }\n    output = var_2;\n  }\n  else {\n    uint var_6 = var_1 << (var_5 & 0xff);\n    output = var_3 + (var_2 << (var_5 & 0xff)) + (var_1 >> (0x20 - var_5 & 0xff)) + (uint)(0x7fffffff < var_6);\n    if (var_6 == 0x80000000) {\n      output = output & 0xfffffffe;\n    }\n  }\n  return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c60",
            "calling": [],
            "imported": false,
            "current_name": "calculate_hash_08000c60"
        },
        "FUN_08006d68": {
            "renaming": {
                "FUN_08006d68": "calculate_polynomial_08006d68",
                "__x": "input_value",
                "in_r0": "int_part",
                "iVar1": "index",
                "uVar2": "temp_var_1",
                "uVar3": "temp_var_2",
                "in_r1": "uint_part",
                "extraout_r1": "extra_output",
                "uVar4": "temp_var_3",
                "uVar5": "temp_var_4",
                "in_r3": "dividend_part_1",
                "unaff_r4": "dividend_part_2",
                "uVar6": "dividend_part_1_new",
                "uVar7": "dividend_part_2_new",
                "uVar8": "uint_part_abs",
                "puVar9": "polynomial_coefficients",
                "in_d0": "result",
                "extraout_d0": "result_temp",
                "uVar10": "temp_var_5",
                "uVar11": "temp_var_6"
            },
            "code": "\ndouble calculate_polynomial_08006d68(double input_value)\n\n{\n  int int_part;\n  int index;\n  undefined4 temp_var_1;\n  undefined4 temp_var_2;\n  uint uint_part;\n  undefined4 extra_output;\n  undefined4 temp_var_3;\n  undefined4 temp_var_4;\n  undefined4 dividend_part_1;\n  undefined4 dividend_part_2;\n  undefined4 dividend_part_1_new;\n  undefined4 dividend_part_2_new;\n  uint uint_part_abs;\n  undefined4 *polynomial_coefficients;\n  double result;\n  double result_temp;\n  undefined8 temp_var_5;\n  undefined8 temp_var_6;\n  \n  temp_var_6 = CONCAT44(uint_part,int_part);\n  uint_part_abs = uint_part & 0x7fffffff;\n  if (DAT_08007058 < (int)uint_part_abs) {\n    if (((int)DAT_0800705c < (int)uint_part_abs) || ((uint_part_abs == DAT_0800705c && (int_part != 0)))) {\n      result = (double)__aeabi_dadd();\n    }\n  }\n  else {\n    if (DAT_08007068 < (int)uint_part_abs) {\n      fabs((double)CONCAT44(dividend_part_2,dividend_part_1));\n      if (DAT_08007070 < (int)uint_part_abs) {\n        if (DAT_08007074 < (int)uint_part_abs) {\n          temp_var_6 = __divdf3(0,DAT_0800707c,int_part,extra_output);\n          index = 3;\n        }\n        else {\n          temp_var_6 = __subdf3();\n          temp_var_5 = __muldf3(int_part,extra_output,0,DAT_08007078);\n          temp_var_5 = __aeabi_dadd((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),0,DAT_0800706c);\n          temp_var_6 = __divdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),(int)temp_var_5,\n                            (int)((ulonglong)temp_var_5 >> 0x20));\n          index = 2;\n        }\n      }\n      else if (DAT_08007070 + -0xd0000 < (int)uint_part_abs) {\n        temp_var_6 = __subdf3();\n        temp_var_5 = __aeabi_dadd(int_part,extra_output,0,DAT_0800706c);\n        temp_var_6 = __divdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),(int)temp_var_5,\n                          (int)((ulonglong)temp_var_5 >> 0x20));\n        index = 1;\n      }\n      else {\n        temp_var_6 = __aeabi_dadd();\n        temp_var_6 = __subdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),0,DAT_0800706c);\n        temp_var_5 = __aeabi_dadd(int_part,extra_output,0,0x40000000);\n        temp_var_6 = __divdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),(int)temp_var_5,\n                          (int)((ulonglong)temp_var_5 >> 0x20));\n        index = 0;\n      }\n    }\n    else {\n      if ((int)uint_part_abs <= DAT_08007068 + -0x1bc0000) {\n        temp_var_5 = __aeabi_dadd(int_part,uint_part,DAT_08006ff8,DAT_08006ffc);\n        index = __aeabi_dcmpgt((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),0,DAT_0800706c);\n        if (index != 0) {\n          return result_temp;\n        }\n      }\n      index = -1;\n    }\n    dividend_part_2_new = (undefined4)((ulonglong)temp_var_6 >> 0x20);\n    dividend_part_1_new = (undefined4)temp_var_6;\n    temp_var_6 = __muldf3(dividend_part_1_new,dividend_part_2_new,dividend_part_1_new,dividend_part_2_new);\n    temp_var_3 = (undefined4)((ulonglong)temp_var_6 >> 0x20);\n    temp_var_1 = (undefined4)temp_var_6;\n    temp_var_6 = __muldf3(temp_var_1,temp_var_3,temp_var_1,temp_var_3);\n    temp_var_4 = (undefined4)((ulonglong)temp_var_6 >> 0x20);\n    temp_var_2 = (undefined4)temp_var_6;\n    temp_var_6 = __muldf3(temp_var_2,temp_var_4,DAT_08007000,DAT_08007004);\n    temp_var_6 = __aeabi_dadd((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),DAT_08007008,DAT_0800700c);\n    temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_6 = __aeabi_dadd((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),DAT_08007010,DAT_08007014);\n    temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_6 = __aeabi_dadd((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),DAT_08007018,DAT_0800701c);\n    temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_6 = __aeabi_dadd((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),DAT_08007020,DAT_08007024);\n    temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_6 = __aeabi_dadd((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),DAT_08007028,DAT_0800702c);\n    temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),temp_var_1,temp_var_3);\n    temp_var_1 = (undefined4)((ulonglong)temp_var_6 >> 0x20);\n    temp_var_5 = __muldf3(temp_var_2,temp_var_4,DAT_08007030,DAT_08007034);\n    temp_var_5 = __subdf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),DAT_08007038,DAT_0800703c);\n    temp_var_5 = __muldf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_5 = __subdf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),DAT_08007040,DAT_08007044);\n    temp_var_5 = __muldf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_5 = __subdf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),DAT_08007048,DAT_0800704c);\n    temp_var_5 = __muldf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_5 = __subdf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),DAT_08007050,DAT_08007054);\n    temp_var_5 = __muldf3((int)temp_var_5,(int)((ulonglong)temp_var_5 >> 0x20),temp_var_2,temp_var_4);\n    temp_var_2 = (undefined4)((ulonglong)temp_var_5 >> 0x20);\n    if (index == -1) {\n      temp_var_6 = __aeabi_dadd((int)temp_var_6,temp_var_1,(int)temp_var_5,temp_var_2);\n      temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),dividend_part_1_new,dividend_part_2_new);\n      result = (double)__subdf3(dividend_part_1_new,dividend_part_2_new,(int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20));\n    }\n    else {\n      temp_var_6 = __aeabi_dadd((int)temp_var_6,temp_var_1,(int)temp_var_5,temp_var_2);\n      temp_var_6 = __muldf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),dividend_part_1_new,dividend_part_2_new);\n      polynomial_coefficients = (undefined4 *)(PTR_calculate_polynomial_08006d68hi_08007080 + index * 8);\n      temp_var_6 = __subdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),\n                        *(undefined4 *)(PTR_calculate_polynomial_08006d68lo_08007084 + index * 8),\n                        *(undefined4 *)((int)(PTR_calculate_polynomial_08006d68lo_08007084 + index * 8) + 4));\n      temp_var_6 = __subdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),dividend_part_1_new,dividend_part_2_new);\n      result = (double)__subdf3(*polynomial_coefficients,polynomial_coefficients[1],(int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20));\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "__divdf3",
                "__muldf3",
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "fabs",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d68",
            "calling": [
                "__ieee754_atan2"
            ],
            "imported": false,
            "current_name": "calculate_polynomial_08006d68"
        },
        "FUN_08004f04": {
            "renaming": {
                "FUN_08004f04": "handle_UART_interrupt_08004f04",
                "PTR_huart1_08004f0c": "huart1_ptr",
                "HAL_UART_IRQHandler": "HAL_UART_IRQHandler",
                "UART_HandleTypeDef": "UART_HandleTypeDef"
            },
            "code": "void handle_UART_interrupt_08004f04(void)\n{\n  UART_HandleTypeDef *PTR_huart1_08004f0c = (UART_HandleTypeDef *)PTR_huart1_08004f0c;\n  HAL_UART_IRQHandler(PTR_huart1_08004f0c);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f04",
            "calling": [],
            "imported": false,
            "current_name": "handle_UART_interrupt_08004f04"
        },
        "FUN_080072b8": {
            "renaming": {
                "FUN_080072b8": "allocate_memory_080072b8",
                "__delta": "delta",
                "puVar1": "heap_end_ptr",
                "pvVar2": "allocated_memory"
            },
            "code": "void * allocate_memory_080072b8(intptr_t delta)\n{\n  undefined *heap_end_ptr;\n  void *allocated_memory;\n  \n  heap_end_ptr = PTR_heap_end_4116_080072cc;\n  if (*(int *)PTR_heap_end_4116_080072cc == 0) \n  {\n    *(undefined **)PTR_heap_end_4116_080072cc = PTR__ebss_080072d0;\n  }\n  allocated_memory = *(void **)heap_end_ptr;\n  *(intptr_t *)heap_end_ptr = delta + (int)allocated_memory;\n  return allocated_memory;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072b8",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_080072b8"
        },
        "FUN_0800581c": {
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "error_ptr",
                "pvVar2": "memory_ptr"
            },
            "code": "void allocate_memory_0800581c(int *error_code,intptr_t size)\n{\n  undefined *error_ptr;\n  void *memory_ptr;\n  \n  error_ptr = PTR_errno_08005838;\n  *(undefined4 *)PTR_errno_08005838 = 0;\n  memory_ptr = _sbrk(size);\n  if ((memory_ptr == (void *)0xffffffff) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800581c",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_0800581c"
        },
        "FUN_08003eac": {
            "renaming": {
                "FUN_08003eac": "execute_system_call_08003eac",
                "a0": "syscall_number",
                "a1": "syscall_arg",
                "a2": "error_check"
            },
            "code": "uint32_t execute_system_call_08003eac(uint32_t syscall_number, uint32_t syscall_arg, int32_t error_check)\n{\n  software_interrupt(syscall_number);\n  return syscall_arg;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003eac",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "execute_system_call_08003eac"
        },
        "FUN_080072ac": {
            "renaming": {
                "FUN_080072ac": "getImpurePtrValue_080072ac",
                "PTR__impure_ptr_080072b4": "PTR__impure_ptr"
            },
            "code": "uint32_t getImpurePtrValue_080072ac(void)\n{\n    uint32_t* impurePtr = (uint32_t*) PTR__impure_ptr_080072b4_080072b4;\n    return *impurePtr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072ac",
            "calling": [
                "asin",
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "getImpurePtrValue_080072ac"
        },
        "FUN_08000ad0": {
            "renaming": {
                "FUN_08000ad0": "calculate_float_08000ad0",
                "param_1": "float_bits",
                "param_2": "float_bits_2",
                "param_3": "unused",
                "param_4": "shift",
                "iVar1": "exponent",
                "uVar2": "significand",
                "uVar3": "significand_2",
                "uVar4": "temp",
                "uVar5": "shifted_significand",
                "uVar6": "shift_distance",
                "iVar7": "leading_zeros",
                "bVar8": "condition"
            },
            "code": "\nuint calculate_float_08000ad0(uint float_bits,uint float_bits_2,undefined4 unused,uint shift)\n\n{\n  int exponent;\n  uint significand;\n  uint significand_2;\n  uint temp;\n  uint shifted_significand;\n  uint shift_distance;\n  int leading_zeros;\n  bool condition;\n  \n  significand = float_bits ^ 0x80000000;\n  temp = float_bits << 1;\n  condition = temp == 0;\n  if (!condition) {\n    shift = float_bits_2 << 1;\n    condition = shift == 0;\n  }\n  if (!condition) {\n    condition = temp == shift;\n  }\n  leading_zeros = (int)temp >> 0x18;\n  if (!condition) {\n    condition = leading_zeros == -1;\n  }\n  if (!condition) {\n    condition = (int)shift >> 0x18 == -1;\n  }\n  if (condition) {\n    exponent = (int)(float_bits_2 << 1) >> 0x18;\n    if (leading_zeros == -1 || exponent == -1) {\n      temp = float_bits_2;\n      if (leading_zeros == -1) {\n        temp = significand;\n      }\n      if (leading_zeros != -1 || exponent != -1) {\n        float_bits_2 = temp;\n      }\n      condition = (temp & 0x7fffff) == 0;\n      if (condition) {\n        condition = (float_bits_2 & 0x7fffff) == 0;\n      }\n      if (condition) {\n        condition = temp == float_bits_2;\n      }\n      if (!condition) {\n        temp = temp | 0x400000;\n      }\n      return temp;\n    }\n    if (((float_bits ^ float_bits_2) & 0x7fffffff) != 0) {\n      if (temp == 0) {\n        significand = float_bits_2;\n      }\n      return significand;\n    }\n    if (significand != float_bits_2) {\n      return 0;\n    }\n    if ((temp & 0xff000000) == 0) {\n      float_bits = float_bits << 1;\n      if ((significand & 0x80000000) != 0) {\n        float_bits = float_bits | 0x80000000;\n      }\n      return float_bits;\n    }\n    if (temp < 0xfe000000) {\n      return significand + 0x800000;\n    }\n    significand = significand & 0x80000000;\nLAB_08000c12:\n    return significand | 0x7f800000;\n  }\n  temp = temp >> 0x18;\n  shift = shift >> 0x18;\n  shift_distance = shift - temp;\n  condition = shift_distance != 0;\n  shifted_significand = temp;\n  if (condition && temp <= shift) {\n    shifted_significand = temp + shift_distance;\n  }\n  if (condition && temp <= shift) {\n    float_bits_2 = float_bits_2 ^ significand;\n  }\n  if (condition && temp <= shift) {\n    significand = significand ^ float_bits_2;\n  }\n  if (condition && temp <= shift) {\n    float_bits_2 = float_bits_2 ^ significand;\n  }\n  if (shift < temp) {\n    shift_distance = -shift_distance;\n  }\n  if (0x19 < shift_distance) {\n    return significand;\n  }\n  temp = significand & 0xffffff | 0x800000;\n  if ((significand & 0x80000000) != 0) {\n    temp = -temp;\n  }\n  significand_2 = float_bits_2 & 0xffffff | 0x800000;\n  if ((float_bits_2 & 0x80000000) != 0) {\n    significand_2 = -significand_2;\n  }\n  if (shifted_significand == shift_distance) {\n    significand_2 = significand_2 ^ 0x800000;\n    if (shifted_significand == 0) {\n      temp = temp ^ 0x800000;\n      shifted_significand = 1;\n    }\n    else {\n      shift_distance = shift_distance - 1;\n    }\n  }\n  temp = temp + ((int)significand_2 >> (shift_distance & 0xff));\n  significand_2 = significand_2 << (0x20 - shift_distance & 0xff);\n  significand = temp & 0x80000000;\n  if ((int)temp < 0) {\n    condition = significand_2 != 0;\n    significand_2 = -significand_2;\n    temp = -temp - (uint)condition;\n  }\n  if (temp < 0x800000) {\n    shift_distance = significand_2 & 0x80000000;\n    significand_2 = significand_2 << 1;\n    temp = temp * 2 + (uint)(shift_distance != 0);\n    shift_distance = shifted_significand - 2;\n    if ((temp & 0x800000) == 0) {\n      leading_zeros = count_leading_zeroes(temp);\n      shifted_significand = leading_zeros - 8;\n      temp = temp << (shifted_significand & 0xff);\n      if ((int)shift_distance < (int)shifted_significand) {\n        temp = temp >> (-(shift_distance - shifted_significand) & 0xff);\n      }\n      else {\n        temp = temp + (shift_distance - shifted_significand) * 0x800000;\n      }\n      return temp | significand;\n    }\n  }\n  else {\n    shift_distance = shifted_significand - 1;\n    if (0xffffff < temp) {\n      shift_distance = temp & 1;\n      temp = temp >> 1;\n      significand_2 = (uint)(shift_distance != 0) << 0x1f | significand_2 >> 1;\n      shift_distance = shifted_significand;\n      if (0xfd < shifted_significand) goto LAB_08000c12;\n    }\n  }\n  temp = temp + shift_distance * 0x800000 + (uint)(0x7fffffff < significand_2);\n  if (significand_2 == 0x80000000) {\n    temp = temp & 0xfffffffe;\n  }\n  return temp | significand;\n}\n\n",
            "called": [
                "__addsf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ad0",
            "calling": [],
            "imported": false,
            "current_name": "calculate_float_08000ad0"
        },
        "FUN_08002cb0": {
            "renaming": {
                "FUN_08002cb0": "read_and_calculate_mpu9250_data_08002cb0",
                "in_r3": "i2c_data",
                "_rawData": "raw_data",
                "PTR_s____Src_MPU9250_c_08002d80": "mpu9250_data",
                "PTR_magCalib_08002d84": "magCalib",
                "I2C_WriteByte": "i2c_write_byte",
                "I2C_ReadByte": "i2c_read_byte",
                "I2C_ReadByteArray": "i2c_read_byte_array"
            },
            "code": "void read_and_calculate_mpu9250_data_08002cb0(void)\\n{\\n  uint8_t rawData [3];\\n  uint16_t raw_data = i2c_data;\\n  i2c_write_byte(0xd0,0x37,\"\\\"\",\"\\x01\");\\n  i2c_write_byte(0xd0,0x6a,\"\\x01\",\"\\x01\");\\n  i2c_read_byte(0x18,0,PTR_s____Src_MPU9250_c_08002d80,0xad);\\n  i2c_write_byte(0x18,0xb,\"\\x01\",\"\\x01\");\\n  i2c_write_byte(0x18,10,\"\\0\",\"\\x01\");\\n  i2c_write_byte(0x18,10,\"\\x0f\",\"\\x01\");\\n  i2c_read_byte_array(0x18,0x10,rawData,3,PTR_s____Src_MPU9250_c_08002d80,0xb6);\\n  float x_mag = (float)(raw_data & 0xff) - 0x80;\\n  x_mag = x_mag * 0.00390625f;\\n  x_mag += 1.0f;\\n  float y_mag = (float)(raw_data >> 8 & 0xff) - 0x80;\\n  y_mag = y_mag * 0.00390625f;\\n  y_mag += 1.0f;\\n  float z_mag = (float)rawData[2] - 0x80;\\n  z_mag = z_mag * 0.00390625f;\\n  z_mag += 1.0f;\\n  PTR_magCalib_08002d84[0] = x_mag;\\n  PTR_magCalib_08002d84[1] = y_mag;\\n  PTR_magCalib_08002d84[2] = z_mag;\\n  i2c_write_byte(0x18,10,\"\\0\",\"\\x01\");\\n  i2c_write_byte(0x18,10,\"\\x16\",\"\\x01\");\\n}",
            "called": [
                "__aeabi_fmul",
                "__floatsisf",
                "__addsf3",
                "I2C_ReadByteArray",
                "I2C_WriteByte",
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb0",
            "calling": [
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "read_and_calculate_mpu9250_data_08002cb0"
        },
        "FUN_08002324": {
            "renaming": {
                "FUN_08002324": "configure_timer_08002324",
                "TIMx": "timer",
                "OC_Config": "output_config",
                "uVar1": "cr2_reg_value",
                "uVar2": "output_mode_value",
                "uVar3": "output_polarity_value",
                "pTVar4": "timer_idle_state",
                "DAT_08002364": "timer_idle_state"
            },
            "code": "void configure_timer_08002324(TIM_TypeDef *timer,TIM_OC_InitTypeDef *output_config)\n{\n  uint32_t cr2_reg_value;\n  uint32_t output_mode_value;\n  uint32_t output_polarity_value;\n  TIM_TypeDef *DAT_08002364 = timer;\n  \n  timer->CCER &= ~(1 << 12);\n  cr2_reg_value = timer->CR2;\n  output_mode_value = output_config->OCMode;\n  output_polarity_value = output_config->OCPolarity;\n  \n  if (timer == DAT_08002364) {\n    DAT_08002364 = (TIM_TypeDef *)output_config->OCIdleState;\n    cr2_reg_value &= ~(1 << 14);\n  }\n  \n  if (timer == DAT_08002364) {\n    cr2_reg_value |= (int)DAT_08002364 << 6;\n  }\n  \n  timer->CR2 = cr2_reg_value;\n  timer->CCMR2 = (timer->CCMR2 & ~(3 << 8)) | (output_mode_value << 8);\n  timer->CCR4 = output_config->Pulse;\n  timer->CCER = (timer->CCER & ~(1 << 14)) | (output_polarity_value << 12);\n  \n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002324",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08002324"
        },
        "FUN_08002564": {
            "renaming": {
                "FUN_08002564": "configureTIMBreakDeadTime_08002564",
                "htim": "timerHandle",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status"
            },
            "code": "HAL_StatusTypeDef configureTIMBreakDeadTime_08002564(TIM_HandleTypeDef *timerHandle, TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n{\n  HAL_StatusTypeDef status = HAL_BUSY;\n  if (timerHandle->Lock != HAL_LOCKED) {\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->BDTR =\n         breakDeadTimeConfig->OffStateRunMode | breakDeadTimeConfig->OffStateIDLEMode |\n         breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime |\n         breakDeadTimeConfig->BreakState | breakDeadTimeConfig->BreakPolarity |\n         breakDeadTimeConfig->AutomaticOutput;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timerHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002564",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configureTIMBreakDeadTime_08002564"
        },
        "FUN_08004fb0": {
            "renaming": {
                "FUN_08004fb0": "wait_forever_08004fb0"
            },
            "code": "void wait_forever_08004fb0(void)\n{\n    while(true){}\n}",
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004fb0",
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "imported": false,
            "current_name": "wait_forever_08004fb0"
        },
        "FUN_08000ad8": {
            "renaming": {
                "FUN_08000ad8": "calculate_float_08000ad8",
                "param_1": "float_bits_a",
                "param_2": "float_bits_b",
                "param_3": "float_bits_c",
                "param_4": "float_bits_d",
                "uVar2": "flipped_b",
                "uVar3": "flipped_a",
                "uVar4": "shifted_a",
                "uVar5": "shift_distance",
                "uVar6": "shifted_distance",
                "iVar1": "sign_a",
                "iVar7": "sign_distance",
                "bVar8": "comparison_result"
            },
            "code": "\nuint calculate_float_08000ad8(uint float_bits_a,uint float_bits_b,undefined4 float_bits_c,uint float_bits_d)\n\n{\n  int sign_a;\n  uint flipped_b;\n  uint flipped_a;\n  uint shifted_a;\n  uint shift_distance;\n  uint shifted_distance;\n  int sign_distance;\n  bool comparison_result;\n  \n  flipped_b = float_bits_b ^ 0x80000000;\n  shifted_a = float_bits_a << 1;\n  comparison_result = shifted_a == 0;\n  if (!comparison_result) {\n    float_bits_d = float_bits_b << 1;\n    comparison_result = float_bits_d == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = shifted_a == float_bits_d;\n  }\n  sign_distance = (int)shifted_a >> 0x18;\n  if (!comparison_result) {\n    comparison_result = sign_distance == -1;\n  }\n  if (!comparison_result) {\n    comparison_result = (int)float_bits_d >> 0x18 == -1;\n  }\n  if (comparison_result) {\n    sign_a = (int)(float_bits_b << 1) >> 0x18;\n    if (sign_distance == -1 || sign_a == -1) {\n      shifted_a = flipped_b;\n      if (sign_distance == -1) {\n        shifted_a = float_bits_a;\n      }\n      if (sign_distance != -1 || sign_a != -1) {\n        flipped_b = shifted_a;\n      }\n      comparison_result = (shifted_a & 0x7fffff) == 0;\n      if (comparison_result) {\n        comparison_result = (flipped_b & 0x7fffff) == 0;\n      }\n      if (comparison_result) {\n        comparison_result = shifted_a == flipped_b;\n      }\n      if (!comparison_result) {\n        shifted_a = shifted_a | 0x400000;\n      }\n      return shifted_a;\n    }\n    if (((float_bits_a ^ flipped_b) & 0x7fffffff) != 0) {\n      if (shifted_a == 0) {\n        float_bits_a = flipped_b;\n      }\n      return float_bits_a;\n    }\n    if (float_bits_a != flipped_b) {\n      return 0;\n    }\n    if ((shifted_a & 0xff000000) == 0) {\n      flipped_b = float_bits_a << 1;\n      if ((float_bits_a & 0x80000000) != 0) {\n        flipped_b = flipped_b | 0x80000000;\n      }\n      return flipped_b;\n    }\n    if (shifted_a < 0xfe000000) {\n      return float_bits_a + 0x800000;\n    }\n    float_bits_a = float_bits_a & 0x80000000;\nLAB_08000c12:\n    return float_bits_a | 0x7f800000;\n  }\n  shifted_a = shifted_a >> 0x18;\n  float_bits_d = float_bits_d >> 0x18;\n  shifted_distance = float_bits_d - shifted_a;\n  comparison_result = shifted_distance != 0;\n  shift_distance = shifted_a;\n  if (comparison_result && shifted_a <= float_bits_d) {\n    shift_distance = shifted_a + shifted_distance;\n  }\n  if (comparison_result && shifted_a <= float_bits_d) {\n    flipped_b = flipped_b ^ float_bits_a;\n  }\n  if (comparison_result && shifted_a <= float_bits_d) {\n    float_bits_a = float_bits_a ^ flipped_b;\n  }\n  if (comparison_result && shifted_a <= float_bits_d) {\n    flipped_b = flipped_b ^ float_bits_a;\n  }\n  if (float_bits_d < shifted_a) {\n    shifted_distance = -shifted_distance;\n  }\n  if (0x19 < shifted_distance) {\n    return float_bits_a;\n  }\n  shifted_a = float_bits_a & 0xffffff | 0x800000;\n  if ((float_bits_a & 0x80000000) != 0) {\n    shifted_a = -shifted_a;\n  }\n  flipped_a = flipped_b & 0xffffff | 0x800000;\n  if ((flipped_b & 0x80000000) != 0) {\n    flipped_a = -flipped_a;\n  }\n  if (shift_distance == shifted_distance) {\n    flipped_a = flipped_a ^ 0x800000;\n    if (shift_distance == 0) {\n      shifted_a = shifted_a ^ 0x800000;\n      shift_distance = 1;\n    }\n    else {\n      shifted_distance = shifted_distance - 1;\n    }\n  }\n  shifted_a = shifted_a + ((int)flipped_a >> (shifted_distance & 0xff));\n  flipped_a = flipped_a << (0x20 - shifted_distance & 0xff);\n  float_bits_a = shifted_a & 0x80000000;\n  if ((int)shifted_a < 0) {\n    comparison_result = flipped_a != 0;\n    flipped_a = -flipped_a;\n    shifted_a = -shifted_a - (uint)comparison_result;\n  }\n  if (shifted_a < 0x800000) {\n    flipped_b = flipped_a & 0x80000000;\n    flipped_a = flipped_a << 1;\n    shifted_a = shifted_a * 2 + (uint)(flipped_b != 0);\n    flipped_b = shift_distance - 2;\n    if ((shifted_a & 0x800000) == 0) {\n      sign_distance = count_leading_zeroes(shifted_a);\n      shifted_distance = sign_distance - 8;\n      shifted_a = shifted_a << (shifted_distance & 0xff);\n      if ((int)flipped_b < (int)shifted_distance) {\n        shifted_a = shifted_a >> (-(flipped_b - shifted_distance) & 0xff);\n      }\n      else {\n        shifted_a = shifted_a + (flipped_b - shifted_distance) * 0x800000;\n      }\n      return shifted_a | float_bits_a;\n    }\n  }\n  else {\n    flipped_b = shift_distance - 1;\n    if (0xffffff < shifted_a) {\n      flipped_b = shifted_a & 1;\n      shifted_a = shifted_a >> 1;\n      flipped_a = (uint)(flipped_b != 0) << 0x1f | flipped_a >> 1;\n      flipped_b = shift_distance;\n      if (0xfd < shift_distance) goto LAB_08000c12;\n    }\n  }\n  shifted_a = shifted_a + flipped_b * 0x800000 + (uint)(0x7fffffff < flipped_a);\n  if (flipped_a == 0x80000000) {\n    shifted_a = shifted_a & 0xfffffffe;\n  }\n  return shifted_a | float_bits_a;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ad8",
            "calling": [
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "Motor_DistributeSpeed",
                "AHRS_GetYaw",
                "MPU9250_ReadGyroData",
                "lowPassFilter",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "calculate_float_08000ad8"
        },
        "FUN_08003ec8": {
            "renaming": {
                "FUN_08003ec8": "addDataToCircularBuffer_08003ec8",
                "cb": "buffer",
                "data": "data",
                "size": "size",
                "buffer": "data",
                "tail": "tail"
            },
            "code": "int addDataToCircularBuffer_08003ec8(CircularBuffer *buffer, uint8_t data) {\n  buffer->size++;\n  buffer->data[buffer->tail] = data;\n  buffer->tail = (buffer->tail + 1) & 0x7ff;\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ec8",
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "addDataToCircularBuffer_08003ec8"
        },
        "FUN_08003fe8": {
            "renaming": {
                "FUN_08003fe8": "set_pwm_value_08003fe8",
                "pwm": "pwm_value",
                "PTR_htim3_08003ff0": "htim3_ptr"
            },
            "code": "void set_pwm_value_08003fe8(int pwm_value)\n{\n    int* PTR_htim3_08003ff0 = *(int*)PTR_htim3_08003ff0;\n    int* pwm_reg = PTR_htim3_08003ff0 + 0x3c;\n    *pwm_reg = pwm_value;\n    return;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fe8",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_value_08003fe8"
        },
        "FUN_08005714": {
            "renaming": {
                "FUN_08005714": "allocate_memory_08005714",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "start",
                "uVar2": "new_block",
                "puVar3": "free_list",
                "iVar4": "remaining_space",
                "puVar5": "free_block",
                "uVar6": "remaining_size",
                "puVar7": "prev_free_list",
                "uVar8": "aligned_size"
            },
            "code": "uint allocate_memory_08005714(uint *error_code, uint size)\n{\n    uint aligned_size = (size + 3 & 0xfffffffc) + 8;\n    if (aligned_size < 0xc) {\n        aligned_size = 0xc;\n    }\n    if (((int)aligned_size < 0) || (aligned_size < size)) {\n        *error_code = 0xc;\n    }\n    else {\n        __malloc_lock();\n        void *start = PTR___malloc_sbrk_start_080057cc;\n        uint *free_list = *(uint **)PTR___malloc_free_list_080057c8;\n        uint *prev_free_list = *(uint **)PTR___malloc_free_list_080057c8;\n        while (free_list != (uint *)0x0) {\n            uint remaining_size = *free_list - aligned_size;\n            if (-1 < (int)remaining_size) {\n                if (remaining_size < 0xc) {\n                    if (prev_free_list == free_list) {\n                        uint next_free_block = prev_free_list[1];\n                        *(uint *)PTR___malloc_free_list_080057c8 = next_free_block;\n                    }\n                    else {\n                        uint next_free_block = free_list[1];\n                    }\n                    if (prev_free_list != free_list) {\n                        prev_free_list[1] = next_free_block;\n                        prev_free_list = free_list;\n                    }\n                }\n                else {\n                    *free_list = remaining_size;\n                    *(uint *)((int)free_list + remaining_size) = aligned_size;\n                    prev_free_list = (uint *)((int)free_list + remaining_size);\n                }\n                goto LAB_08005778;\n            }\n            prev_free_list = free_list;\n            free_list = (uint *)free_list[1];\n        }\n        if (*(int *)PTR___malloc_sbrk_start_080057cc == 0) {\n            void *new_block = _sbrk_r(error_code);\n            *(void **)start = new_block;\n        }\n        free_list = (uint *)_sbrk_r(error_code, aligned_size);\n        if ((free_list != (uint *)0xffffffff) &&\n            ((prev_free_list = (uint *)((int)free_list + 3U & 0xfffffffc), free_list == prev_free_list ||\n             (_sbrk_r(error_code,(int)prev_free_list - (int)free_list) != -1)))) {\n            *prev_free_list = aligned_size;\n        LAB_08005778:\n            __malloc_unlock(error_code);\n            uint block_end = (int)prev_free_list + 0xbU & 0xfffffff8;\n            int remaining_space = block_end - (int)(prev_free_list + 1);\n            if (remaining_space != 0) {\n                *(int *)((int)prev_free_list + remaining_space) = -remaining_space;\n                return block_end;\n            }\n            return block_end;\n        }\n        *error_code = 0xc;\n        __malloc_unlock(error_code);\n    }\n    return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005714",
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08005714"
        },
        "FUN_08004fb4": {
            "renaming": {
                "FUN_08004fb4": "init_and_finalize_crypto_08004fb4",
                "param_1": "context",
                "puVar1": "frame_dummy_init_array_entry",
                "iVar2": "frame_dummy_size",
                "iVar3": "i",
                "_init": "initialize",
                "PTR___frame_dummy_init_array_entry_08004ff4": "do_global_dtors_aux_fini_array_entry",
                "PTR___do_global_dtors_aux_fini_array_entry_08004ff8": "do_global_dtors_aux_fini_array_size"
            },
            "code": "void init_and_finalize_crypto_08004fb4(EVP_PKEY_CTX *context){\n    undefined *frame_dummy_init_array_entry = PTR___frame_dummy_init_array_entry_08004fec;\n    int frame_dummy_size = (int)PTR___frame_dummy_init_array_entry_08004ff0 - (int)PTR___frame_dummy_init_array_entry_08004fec;\n    for (int i = 0; i < frame_dummy_size >> 2; i++) {\n        context = (EVP_PKEY_CTX *)(**(code **)(frame_dummy_init_array_entry + i * 4))();\n    }\n    _init(context);\n    undefined *PTR___frame_dummy_init_array_entry_08004ff4 = PTR___PTR___frame_dummy_init_array_entry_08004ff4_08004ff4;\n    int PTR___do_global_dtors_aux_fini_array_entry_08004ff8 = (int)PTR___PTR___frame_dummy_init_array_entry_08004ff4_08004ff8 - (int)PTR___frame_dummy_init_array_entry_08004ff4;\n    for (int i = 0; i < PTR___do_global_dtors_aux_fini_array_entry_08004ff8 >> 2; i++) {\n        (**(code **)(PTR___frame_dummy_init_array_entry_08004ff4 + i * 4))();\n    }\n    return;\n}",
            "called": [
                "frame_dummy",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004fb4",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "init_and_finalize_crypto_08004fb4"
        },
        "FUN_080009dc": {
            "renaming": {
                "FUN_080009dc": "check_if_not_greater_than_or_equal_to_zero_080009dc",
                "in_CY": "is_CY_greater_than_zero",
                "in_ZR": "in_ZR"
            },
            "code": "bool check_if_not_greater_than_or_equal_to_zero_080009dc(void)\n{\n  bool is_CY_greater_than_zero = __aeabi_cdrcmple();\n  return !is_CY_greater_than_zero || in_ZR == 0;\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009dc",
            "calling": [],
            "imported": false,
            "current_name": "check_if_not_greater_than_or_equal_to_zero_080009dc"
        },
        "FUN_08000c70": {
            "renaming": {
                "FUN_08000c70": "calculate_absolute_difference_08000c70",
                "param_1": "number1",
                "param_2": "number2",
                "uVar1": "absolute_difference",
                "uVar2": "shifted_number1",
                "iVar3": "leading_zero_count",
                "uVar4": "shift_amount",
                "iVar6": "adjusted_shift_amount",
                "uVar5": "sign_extension_mask",
                "uVar7": "sum",
                "bVar8": "is_number1_nonzero"
            },
            "code": "uint calculate_absolute_difference_08000c70(uint number1, uint number2)\n{\n  uint absolute_difference;\n  uint sign_bit;\n  bool is_number1_nonzero;\n  int leading_zero_count;\n  uint shift_amount;\n  uint sign_extension_mask;\n  int adjusted_shift_amount;\n  uint shifted_number1;\n  uint shifted_number2;\n  uint sum;\n  \n  if ((number1 | number2) == 0) {\n    return number1;\n  }\n  sign_bit = number2 & 0x80000000;\n  if ((int)sign_bit < 0) {\n    is_number1_nonzero = number1 != 0;\n    number1 = -number1;\n    number2 = -number2 - (uint)is_number1_nonzero;\n  }\n  shifted_number1 = number1;\n  shifted_number2 = number2;\n  if (number2 == 0) {\n    shifted_number1 = 0;\n    shifted_number2 = number1;\n  }\n  sign_extension_mask = sign_bit | 0x5b000000;\n  if (number2 == 0) {\n    sign_extension_mask = sign_extension_mask + 0xf0000000;\n  }\n  leading_zero_count = count_leading_zeroes(shifted_number2);\n  shift_amount = leading_zero_count - 8;\n  adjusted_shift_amount = (sign_extension_mask - 0x800000) + shift_amount * -0x800000;\n  if (leading_zero_count < 8) {\n    sum = shifted_number2 << (leading_zero_count + 0x18U & 0xff);\n    absolute_difference = adjusted_shift_amount + ((shifted_number2 >> (0x20 - (leading_zero_count + 0x18U) & 0xff)) - ((int)sum >> 0x1f));\n    if ((shifted_number1 | sum << 1) == 0) {\n      absolute_difference = absolute_difference & ~(sum >> 0x1f);\n    }\n    return absolute_difference;\n  }\n  sum = shifted_number1 << (shift_amount & 0xff);\n  absolute_difference = adjusted_shift_amount + (shifted_number2 << (shift_amount & 0xff)) + (shifted_number1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < (shifted_number1 << shift_amount));\n  if (sum == 0x80000000) {\n    absolute_difference = absolute_difference & 0xfffffffe;\n  }\n  return absolute_difference;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c70",
            "calling": [],
            "imported": false,
            "current_name": "calculate_absolute_difference_08000c70"
        },
        "FUN_080023d0": {
            "renaming": {
                "FUN_080023d0": "set_timer_config_080023d0",
                "htim": "timer_handle",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspInit": "HAL_TIM_PWM_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef set_timer_config_080023d0(TIM_HandleTypeDef *timer_handle)\n{\n    if (timer_handle != NULL)\n    {\n        if (timer_handle->State == HAL_TIM_STATE_RESET)\n        {\n            timer_handle->Lock = HAL_UNLOCKED;\n            HAL_TIM_PWM_MspInit(timer_handle);\n        }\n        timer_handle->State = HAL_TIM_STATE_BUSY;\n        TIM_Base_SetConfig(timer_handle->Instance, &timer_handle->Init);\n        timer_handle->State = HAL_TIM_STATE_READY;\n        return HAL_OK;\n    }\n    return HAL_ERROR;\n}",
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080023d0",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "set_timer_config_080023d0"
        },
        "FUN_08000a30": {
            "renaming": {
                "FUN_08000a30": "calculate_float_bits_08000a30",
                "param_1": "float_bits",
                "param_2": "float_bits_shifted",
                "uVar1": "result",
                "uVar2": "shifted_bits",
                "uVar3": "normalized_bits",
                "in_r12": "threshold_bits",
                "bVar4": "is_result_bits_zero",
                "bVar5": "is_shifted_bits_below_threshold",
                "uVar4": "mantissa",
                "uVar5": "exponent",
                "uVar6": "exponent_bits",
                "uVar7": "sign_bit",
                "uVar8": "shift_amount"
            },
            "code": "uint calculate_float_bits_08000a30(uint float_bits, uint float_bits_shifted) {\n  uint shifted_bits = float_bits_shifted * 2;\n  bool is_shifted_bits_below_threshold = shifted_bits < 0x70000000;\n  uint normalized_bits = shifted_bits + 0x90000000;\n  uint result_bits = normalized_bits;\n  uint threshold_bits = shifted_bits + 0x8fe00000;\n  if (!is_shifted_bits_below_threshold) {\n    result_bits = threshold_bits;\n  }\n  bool is_result_bits_zero = result_bits == 0;\n  if (!is_shifted_bits_below_threshold && normalized_bits >= 0x200000) {\n    is_result_bits_zero = threshold_bits == 0x1fc00000;\n  }\n  if (is_shifted_bits_below_threshold || normalized_bits < 0x200000 || 0x1fc00000 < threshold_bits || is_result_bits_zero) {\n    if ((float_bits_shifted & 0x40000000) != 0) {\n      if (((int)shifted_bits >> 0x15 == -1) && ((float_bits | float_bits_shifted << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return float_bits_shifted & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(shifted_bits + 0x92e00000) < 0 != SCARRY4(normalized_bits, 0x2e00000)) {\n      return float_bits_shifted & 0x80000000;\n    }\n    uint shift_amount = 0x18 - (shifted_bits + 0x92e00000 >> 0x15);\n    uint mantissa_bits = float_bits >> (shift_amount & 0xff);\n    if (float_bits << (0x20 - shift_amount & 0xff) != 0) {\n      mantissa_bits = mantissa_bits | 1;\n    }\n    uint exponent_bits = float_bits_shifted & 0x1fffff | 0x100000;\n    float_bits = mantissa_bits | exponent_bits << (0x20 - shift_amount & 0xff);\n    exponent_bits = (exponent_bits >> (shift_amount & 0xff)) << 1;\n  }\n  uint sign_bit = float_bits & 0x80000000;\n  uint exponent = float_bits >> 0x1d;\n  uint mantissa = float_bits & 0x7fffff;\n  uint result = sign_bit | exponent + exponent_bits * 4 + (uint)(0x7fffffff < mantissa * 8);\n  if (mantissa * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a30",
            "calling": [
                "MS5611_Update",
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_float_bits_08000a30"
        },
        "FUN_08003fdc": {
            "renaming": {
                "FUN_08003fdc": "set_pwm_08003fdc",
                "pwm": "pwm_value",
                "PTR_htim2_08003fe4": "htim2_ptr"
            },
            "code": "void set_pwm_08003fdc(int pwm_value)\n{\n  int* PTR_htim2_08003fe4 = (int*)PTR_htim2_08003fe4;\n  int* pwm_register_ptr = (int*)(*PTR_htim2_08003fe4 + 0x38);\n  *pwm_register_ptr = pwm_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fdc",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_pwm_08003fdc"
        },
        "FUN_080009f0": {
            "renaming": {
                "FUN_080009f0": "isEndOfString_080009f0",
                "in_CY": "currentChar"
            },
            "code": "bool isEndOfString_080009f0(void)\n{\n    char currentChar;\n    __aeabi_cdrcmple();\n    return currentChar == '\\0';\n}",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009f0",
            "calling": [
                "asin",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "isEndOfString_080009f0"
        },
        "FUN_08004f10": {
            "renaming": {
                "FUN_08004f10": "set_bit_and_clear_flags_08004f10",
                "puVar1": "ptr_data"
            },
            "code": "void set_bit_and_clear_flags_08004f10(void)\n{\n  uint *ptr_data = DAT_08004f50;\n  *ptr_data |= 1;\n  ptr_data[1] &= DAT_08004f54;\n  *ptr_data &= 0xfef6ffff;\n  *ptr_data &= 0xfffbffff;\n  ptr_data[1] &= 0xff80ffff;\n  ptr_data[2] = 0x9f0000;\n  *(undefined4 *)(DAT_08004f58 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f10",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_flags_08004f10"
        },
        "FUN_08005044": {
            "renaming": {
                "FUN_08005044": "resize_buffer_08005044",
                "param_1": "errorCode",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "bufferEnd",
                "pvVar1": "newBufferPtr",
                "pvVar2": "newEndPtr",
                "__n": "capacity",
                "flags": "flags",
                "realloc_r": "realloc",
                "_malloc_r": "malloc",
                "_free_r": "free"
            },
            "code": "int resize_buffer_08005044(unsigned int *errorCode, void **buffer, void *bufferEnd, void *data, unsigned int dataSize) {\n  void *newBufferPtr;\n  void *newEndPtr;\n  unsigned int capacity;\n  unsigned int flags;\n  \n  flags = *(unsigned short *)(buffer + 3);\n  if ((buffer[2] <= bufferEnd) && ((flags & 0x480) != 0)) {\n    capacity = (int)*buffer - (int)buffer[4];\n    newEndPtr = (void *)((unsigned int)buffer[5] * 3 / 2);\n    newBufferPtr = (void *)((int)bufferEnd + capacity + 1);\n    if (newEndPtr < newBufferPtr) {\n      newEndPtr = newBufferPtr;\n    }\n    if ((int)((unsigned int)flags << 0x15) < 0) {\n      newBufferPtr = (void *)malloc(capacity);\n      if (newBufferPtr == (void *)0x0) {\n        *errorCode = 0xc;\n        *(unsigned short *)(buffer + 3) = *(unsigned short *)(buffer + 3) | 0x40;\n        return -1;\n      }\n      memcpy(newBufferPtr, buffer[4], dataSize);\n      *(unsigned short *)(buffer + 3) = *(unsigned short *)(buffer + 3) & 0xfb7f | 0x80;\n    }\n    else {\n      newBufferPtr = (void *)realloc(buffer[4], capacity);\n      if (newBufferPtr == (void *)0x0) {\n        free(buffer[4]);\n        *errorCode = 0xc;\n        *(unsigned short *)(buffer + 3) = *(unsigned short *)(buffer + 3) | 0x40;\n        return -1;\n      }\n    }\n    buffer[4] = newBufferPtr;\n    *buffer = (void *)((int)newBufferPtr + dataSize);\n    buffer[5] = newEndPtr;\n    buffer[2] = (void *)((int)newEndPtr - dataSize);\n    bufferEnd = buffer[2];\n  }\n  if (bufferEnd <= data) {\n    data = bufferEnd;\n  }\n  memmove(*buffer, data, (size_t)dataSize);\n  buffer[2] = (void *)((int)buffer[2] - (int)dataSize);\n  *buffer = (void *)((int)dataSize + (int)*buffer);\n  return 0;\n}",
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "_realloc_r",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005044",
            "calling": [
                "_svfiprintf_r"
            ],
            "imported": false,
            "current_name": "resize_buffer_08005044"
        },
        "FUN_08004194": {
            "renaming": {
                "FUN_08004194": "initializeDevicesAndSensors_08004194",
                "Devices_Init": "initializeDevices",
                "serialBegin": "initializeSerialCommunication",
                "IMU_Init": "initializeIMU",
                "MS5611_Init": "initializeMS5611",
                "PID_Init": "initializePID"
            },
            "code": "void initializeDevicesAndSensors_08004194(void)\n{\n  initializeDevices();\n  initializeSerialCommunication();\n  initializeIMU();\n  initializeMS5611();\n  initializePID();\n  return;\n}",
            "called": [
                "Devices_Init",
                "PID_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004194",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeDevicesAndSensors_08004194"
        },
        "FUN_08001240": {
            "renaming": {
                "FUN_08001240": "toggle_clock_source_08001240",
                "CLKSource": "clk_source",
                "uVar1": "current_settings",
                "*DAT_08001254": "*current_settings_ptr"
            },
            "code": "void toggle_clock_source_08001240(uint32_t clk_source)\n{\n  uint32_t current_settings;\n  if (clk_source == 4) {\n    current_settings = *DAT_08001254 | 0b100;\n  }\n  else {\n    current_settings = *DAT_08001254 & 0b11111111111111111111111111111011;\n  }\n  *DAT_08001254 = current_settings;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001240",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "toggle_clock_source_08001240"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_new_index_08005840",
                "param_1": "current_index",
                "param_2": "array",
                "iVar1": "new_index",
                "*(int *)(param_2 + -4)": "current_value",
                "*(int *)(param_2 + iVar1)": "new_value"
            },
            "code": "int calculate_new_index_08005840(int current_index, int* array) {\n  int new_index = current_index - 4;\n  if (current_index < 0) {\n    new_index += array[new_index];\n  }\n  return new_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_new_index_08005840"
        },
        "FUN_08000150": {
            "renaming": {
                "FUN_08000150": "get_string_length_08000150",
                "__s": "input_string",
                "pcVar3": "current_position",
                "pcVar2": "next_position",
                "cVar1": "current_char"
            },
            "code": "size_t get_string_length_08000150(char* input_string) {\n  char current_char;\n  char* current_position = input_string;\n  while (current_char = *current_position) {\n    current_position++;\n  }\n  return (size_t)(current_position - input_string);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000150",
            "calling": [
                "serialPrint"
            ],
            "imported": false,
            "current_name": "get_string_length_08000150"
        },
        "FUN_08003f3c": {
            "renaming": {
                "FUN_08003f3c": "set_led_state_08003f3c",
                "led_white": "white_led",
                "led_red": "red_led",
                "led_blue": "blue_led",
                "GPIOx": "led_port",
                "uVar1": "led_mask",
                "DAT_08003f78": "led_port"
            },
            "code": "void set_led_state_08003f3c(int white_led, int red_led, int blue_led)\n{\n  GPIO_TypeDef *GPIOx;\n  uint32_t led_mask;\n\n  GPIOx = DAT_08003f78;\n  led_mask = 0x8000 >> (count_leading_zeroes(white_led) >> 5);\n  HAL_GPIO_WritePin(GPIOx, led_mask, GPIO_PIN_SET);\n  led_mask = 0x4000 >> (count_leading_zeroes(red_led) >> 5);\n  HAL_GPIO_WritePin(GPIOx, led_mask, GPIO_PIN_SET);\n  led_mask = 0x2000 >> (count_leading_zeroes(blue_led) >> 5);\n  HAL_GPIO_WritePin(GPIOx, led_mask, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f3c",
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "imported": false,
            "current_name": "set_led_state_08003f3c"
        },
        "FUN_08002214": {
            "renaming": {
                "FUN_08002214": "getSystemCoreClock_08002214",
                "PTR_SystemCoreClock_0800221c": "systemCoreClockPtr"
            },
            "code": "uint32_t getSystemCoreClock_08002214(void)\n{\n  uint32_t* PTR_SystemCoreClock_0800221c = (uint32_t*)PTR_SystemCoreClock_0800221c;\n  return *PTR_SystemCoreClock_0800221c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002214",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "getSystemCoreClock_08002214"
        },
        "FUN_08003ff4": {
            "renaming": {
                "FUN_08003ff4": "start_PWM_timers_08003ff4",
                "htim": "timer_handle",
                "PTR_htim2_08004020": "timer2_handle",
                "PTR_htim3_08004024": "timer3_handle",
                "PTR_htim4_0800401c": "timer4_handle"
            },
            "code": "void start_PWM_timers_08003ff4(void)\n{\n  TIM_HandleTypeDef *PTR_htim2_08004020 = PTR_htim2_08004020;\n  TIM_HandleTypeDef *PTR_htim3_08004024 = PTR_htim3_08004024;\n  TIM_HandleTypeDef *PTR_htim4_0800401c = PTR_htim4_0800401c;\n  HAL_TIM_PWM_Start(PTR_htim2_08004020, 4);\n  HAL_TIM_PWM_Start(PTR_htim3_08004024, 8);\n  HAL_TIM_PWM_Start(PTR_htim4_0800401c, 8);\n  HAL_TIM_PWM_Start(PTR_htim4_0800401c, 0xc);\n  return;\n}",
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ff4",
            "calling": [
                "Devices_Init"
            ],
            "imported": false,
            "current_name": "start_PWM_timers_08003ff4"
        },
        "FUN_08001004": {
            "renaming": {
                "FUN_08001004": "compare_and_concatenate_08001004",
                "param_1": "value1",
                "param_2": "value2"
            },
            "code": "float32_t compare_and_concatenate_08001004(float32_t value1, float32_t value2) {\n    __cmpsf2();\n    return CONCAT44(value2, value1);\n}",
            "called": [
                "__cmpsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001004",
            "calling": [
                "__aeabi_fcmple",
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt"
            ],
            "imported": false,
            "current_name": "compare_and_concatenate_08001004"
        },
        "FUN_08001128": {
            "renaming": {
                "FUN_08001128": "initializeHardware_08001128",
                "FUN_08001128Tick": "initializeHardwareTick"
            },
            "code": "HAL_StatusTypeDef initializeHardware_08001128(void)\n{\n  *DAT_08001148 |= 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  initializeHardware_08001128Tick(0);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001128",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "initializeHardware_08001128"
        },
        "FUN_08004514": {
            "renaming": {
                "FUN_08004514": "initialize_clocks_08004514",
                "HVar1": "status",
                "uVar3": "hclk_freq",
                "line": "line_number",
                "FLatency": "flash_latency",
                "RCC_ClkInitStruct": "clock_init_struct",
                "RCC_OscInitStruct": "oscillator_init_struct",
                "puVar2": "pointer"
            },
            "code": "void initialize_clocks_08004514(void)\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclk_freq;\n  int line_number;\n  uint32_t flash_latency;\n  RCC_ClkInitTypeDef clock_init_struct;\n  RCC_OscInitTypeDef oscillator_init_struct;\n  undefined *pointer;\n  oscillator_init_struct.HSIState = RCC_HSI_ON;\n  oscillator_init_struct.HSICalibrationValue = 0x10;\n  flash_latency = 2;\n  oscillator_init_struct.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  oscillator_init_struct.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  oscillator_init_struct.PLL.PLLState = RCC_PLL_ON;\n  oscillator_init_struct.PLL.PLLMUL = RCC_PLL_MUL16;\n  status = HAL_RCC_OscConfig(&oscillator_init_struct);\n  pointer = (undefined *)(uint)status;\n  if (pointer == (undefined *)0x0) {\n    line_number = 60;\n    _Error_Handler(__FILE__, line_number);\n  }\n  else {\n    line_number = 61;\n    _Error_Handler(__FILE__, line_number);\n  }\n  clock_init_struct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clock_init_struct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clock_init_struct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clock_init_struct.APB1CLKDivider = RCC_HCLK_DIV4;\n  clock_init_struct.APB2CLKDivider = RCC_HCLK_DIV2;\n  status = HAL_RCC_ClockConfig(&clock_init_struct, flash_latency);\n  flash_latency = (uint)status;\n  if (flash_latency != 0) {\n    line_number = 77;\n    _Error_Handler(__FILE__, line_number);\n  }\n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclk_freq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n",
            "called": [
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_RCC_ClockConfig",
                "_Error_Handler",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004514",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "initialize_clocks_08004514"
        },
        "FUN_08004a84": {
            "renaming": {
                "FUN_08004a84": "calculateFlightParams_08004a84",
                "puVar1": "pitch_pid",
                "puVar2": "roll_pid",
                "puVar3": "yaw_pid",
                "puVar4": "joystick",
                "puVar5": "altitude_pid",
                "extraout_s0": "throttle",
                "extraout_s0_00": "throttle",
                "extraout_s1": "pitch_correction",
                "extraout_s1_00": "pitch_correction",
                "extraout_s2": "roll_correction",
                "extraout_s2_00": "roll_correction",
                "extraout_s3": "yaw_correction",
                "extraout_s3_00": "yaw_correction",
                "in_r0": "current_pitch",
                "iVar7": "is_within_limits",
                "uVar6": "msp_value",
                "uVar8": "msp_scale"
            },
            "code": "void calculateFlightParams_08004a84(void)\n{\n    float throttle, pitch, roll, yaw;\n    float pitch_pid, roll_pid, yaw_pid, altitude_pid;\n    float pitch_error, roll_error;\n    float pitch_correction, roll_correction, yaw_correction, altitude_correction;\n    float joystick[4];\n    \n    // Get current pitch, roll, and yaw\n    float current_pitch = AHRS_GetPitch();\n    float current_roll = AHRS_GetRoll();\n    float current_yaw = AHRS_GetYaw();\n    \n    // Update PID values\n    PID_TypeDef* pitch_pid_ptr = (PID_TypeDef*)PID_pitch;\n    PID_TypeDef* roll_pid_ptr = (PID_TypeDef*)PID_roll;\n    PID_TypeDef* yaw_pid_ptr = (PID_TypeDef*)PID_yaw;\n    PID_TypeDef* altitude_pid_ptr = (PID_TypeDef*)PID_altitude;\n    \n    pitch_pid_ptr->input = current_pitch;\n    roll_pid_ptr->input = current_roll;\n    yaw_pid_ptr->input = current_yaw;\n    \n    pitch_pid = PID_Compute(pitch_pid_ptr);\n    roll_pid = PID_Compute(roll_pid_ptr);\n    yaw_pid = PID_Compute(yaw_pid_ptr);\n    altitude_pid = PID_Compute(altitude_pid_ptr);\n    \n    // Check if pitch and roll are within acceptable limits\n    if (current_pitch > PITCH_MAX || current_pitch < PITCH_MIN || current_roll > ROLL_MAX || current_roll < ROLL_MIN) {\n        Motor_StopAll();\n        toggleLED(0,1,0);\n        return;\n    }\n    \n    // Check if joystick is not at center\n    joystick[0] = joystick[1] = joystick[2] = joystick[3] = 0;\n    getJoystick(joystick);\n    if (joystick[1] != 0) {\n        joystick[1] = joystick[1] * JOYSTICK_SCALE;\n        joystick[2] = joystick[2] * JOYSTICK_SCALE;\n        joystick[3] = joystick[3] * JOYSTICK_SCALE;\n        \n        // Update altitude PID\n        altitude_correction = PID_Compute(altitude_pid_ptr);\n        altitude_correction += JOYSTICK_DEADZONE;\n        altitude_correction += joystick[0];\n        altitude_correction = altitude_correction > 1 ? 1 : altitude_correction;\n        altitude_correction = altitude_correction < 0 ? 0 : altitude_correction;\n        altitude_correction *= ALTITUDE_MAX;\n        \n        // Update pitch and roll PID\n        pitch_error = joystick[2] - pitch_pid;\n        pitch_correction = PID_Compute(pitch_pid_ptr);\n        pitch_correction += pitch_error * PITCH_KP;\n        pitch_correction = pitch_correction > 1 ? 1 : pitch_correction;\n        pitch_correction = pitch_correction < -1 ? -1 : pitch_correction;\n        pitch_correction *= PITCH_MAX;\n        \n        roll_error = joystick[1] - roll_pid;\n        roll_correction = PID_Compute(roll_pid_ptr);\n        roll_correction += roll_error * ROLL_KP;\n        roll_correction = roll_correction > 1 ? 1 : roll_correction;\n        roll_correction = roll_correction < -1 ? -1 : roll_correction;\n        roll_correction *= ROLL_MAX;\n        \n        // Update yaw PID\n        yaw_correction = joystick[3] * YAW_SCALE;\n        yaw_correction += yaw_pid;\n        yaw_correction = yaw_correction > 1 ? 1 : yaw_correction;\n        yaw_correction = yaw_correction < -1 ? -1 : yaw_correction;\n        yaw_correction *= YAW_MAX;\n        \n        // Update motor speeds\n        Motor_DistributeSpeed(altitude_correction, pitch_correction, roll_correction, yaw_correction);\n    }\n    else {\n        Motor_StopAll();\n    }\n    \n    // Update MSP telemetry\n    uint32_t pitch_msp = (uint32_t)(pitch_pid * MSP_SCALE);\n    uint32_t roll_msp = (uint32_t)(roll_pid * MSP_SCALE);\n    uint32_t yaw_msp = (uint32_t)(yaw_pid * MSP_SCALE);\n    uint32_t altitude_msp = (uint32_t)(altitude_pid * MSP_SCALE);\n    MSP_UpdateTelemetry(pitch_msp, roll_msp, yaw_msp, altitude_msp);\n    \n    // Toggle LED\n    toggleLED(1,1,1);\n}\n",
            "called": [
                "__aeabi_fcmpgt",
                "AHRS_GetPitch",
                "Motor_DistributeSpeed",
                "AHRS_GetRoll",
                "AHRS_GetYaw",
                "PID_Compute",
                "Motor_StopAll",
                "__aeabi_fcmplt",
                "PID_UpdateAltitude",
                "__aeabi_fmul",
                "toggleLED",
                "__addsf3",
                "__fixunssfsi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a84",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "calculateFlightParams_08004a84"
        },
        "FUN_080057d0": {
            "renaming": {
                "FUN_080057d0": "copy_memory_080057d0",
                "param_1": "size",
                "param_2": "src",
                "param_3": "dst",
                "param_4": "alignment",
                "pvVar1": "result",
                "pvVar2": "usable_size"
            },
            "code": "void * copy_memory_080057d0(size_t size, void *src, void *dst, size_t alignment) {\n    void *result;\n    if (src != NULL) {\n        if (dst == NULL) {\n            free(dst);\n            result = src;\n        }\n        else {\n            void *usable_size = malloc_usable_size(dst);\n            result = src;\n            if ((usable_size < dst) && (result = malloc(size), result != NULL)) {\n                memcpy(result, src, size);\n                free(src);\n            }\n        }\n        return result;\n    }\n    result = malloc(size);\n    return result;\n}",
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057d0",
            "calling": [
                "__ssputs_r"
            ],
            "imported": false,
            "current_name": "copy_memory_080057d0"
        },
        "FUN_080072d4": {
            "renaming": {
                "FUN_080072d4": "get_EVP_PKEY_CTX_address_080072d4",
                "ctx": "context"
            },
            "code": "int get_EVP_PKEY_CTX_address_080072d4(EVP_PKEY_CTX *context) {\n  return (int)context;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d4",
            "calling": [
                "__do_global_dtors_aux",
                "frame_dummy",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "get_EVP_PKEY_CTX_address_080072d4"
        },
        "FUN_0800583c": {
            "renaming": {
                "FUN_0800583c": "do_nothing_0800583c"
            },
            "code": "\nvoid do_nothing_0800583c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800583c"
        },
        "FUN_08000adc": {
            "renaming": {
                "FUN_08000adc": "calculate_float_08000adc",
                "param_1": "float_1",
                "param_2": "float_2",
                "param_3": "undefined",
                "param_4": "float_3",
                "iVar1": "int_1",
                "uVar2": "uint_1",
                "uVar3": "uint_2",
                "uVar4": "uint_3",
                "uVar5": "uint_4",
                "iVar6": "int_2",
                "bVar7": "bool_1"
            },
            "code": "\nuint calculate_float_08000adc(uint float_1,uint float_2,undefined4 undefined,uint float_3)\n\n{\n  int int_1;\n  uint uint_1;\n  uint uint_2;\n  uint uint_3;\n  uint uint_4;\n  int int_2;\n  bool bool_1;\n  \n  uint_2 = float_1 << 1;\n  bool_1 = uint_2 == 0;\n  if (!bool_1) {\n    float_3 = float_2 << 1;\n    bool_1 = float_3 == 0;\n  }\n  if (!bool_1) {\n    bool_1 = uint_2 == float_3;\n  }\n  int_2 = (int)uint_2 >> 0x18;\n  if (!bool_1) {\n    bool_1 = int_2 == -1;\n  }\n  if (!bool_1) {\n    bool_1 = (int)float_3 >> 0x18 == -1;\n  }\n  if (bool_1) {\n    int_1 = (int)(float_2 << 1) >> 0x18;\n    if (int_2 == -1 || int_1 == -1) {\n      uint_2 = float_2;\n      if (int_2 == -1) {\n        uint_2 = float_1;\n      }\n      if (int_2 != -1 || int_1 != -1) {\n        float_2 = uint_2;\n      }\n      bool_1 = (uint_2 & 0x7fffff) == 0;\n      if (bool_1) {\n        bool_1 = (float_2 & 0x7fffff) == 0;\n      }\n      if (bool_1) {\n        bool_1 = uint_2 == float_2;\n      }\n      if (!bool_1) {\n        uint_2 = uint_2 | 0x400000;\n      }\n      return uint_2;\n    }\n    if (((float_1 ^ float_2) & 0x7fffffff) != 0) {\n      if (uint_2 == 0) {\n        float_1 = float_2;\n      }\n      return float_1;\n    }\n    if (float_1 != float_2) {\n      return 0;\n    }\n    if ((uint_2 & 0xff000000) == 0) {\n      uint_2 = float_1 << 1;\n      if ((float_1 & 0x80000000) != 0) {\n        uint_2 = uint_2 | 0x80000000;\n      }\n      return uint_2;\n    }\n    if (uint_2 < 0xfe000000) {\n      return float_1 + 0x800000;\n    }\n    float_1 = float_1 & 0x80000000;\nLAB_08000c12:\n    return float_1 | 0x7f800000;\n  }\n  uint_2 = uint_2 >> 0x18;\n  float_3 = float_3 >> 0x18;\n  uint_4 = float_3 - uint_2;\n  bool_1 = uint_4 != 0;\n  uint_3 = uint_2;\n  if (bool_1 && uint_2 <= float_3) {\n    uint_3 = uint_2 + uint_4;\n  }\n  if (bool_1 && uint_2 <= float_3) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (bool_1 && uint_2 <= float_3) {\n    float_1 = float_1 ^ float_2;\n  }\n  if (bool_1 && uint_2 <= float_3) {\n    float_2 = float_2 ^ float_1;\n  }\n  if (float_3 < uint_2) {\n    uint_4 = -uint_4;\n  }\n  if (0x19 < uint_4) {\n    return float_1;\n  }\n  uint_2 = float_1 & 0xffffff | 0x800000;\n  if ((float_1 & 0x80000000) != 0) {\n    uint_2 = -uint_2;\n  }\n  uint_1 = float_2 & 0xffffff | 0x800000;\n  if ((float_2 & 0x80000000) != 0) {\n    uint_1 = -uint_1;\n  }\n  if (uint_3 == uint_4) {\n    uint_1 = uint_1 ^ 0x800000;\n    if (uint_3 == 0) {\n      uint_2 = uint_2 ^ 0x800000;\n      uint_3 = 1;\n    }\n    else {\n      uint_4 = uint_4 - 1;\n    }\n  }\n  uint_2 = uint_2 + ((int)uint_1 >> (uint_4 & 0xff));\n  uint_1 = uint_1 << (0x20 - uint_4 & 0xff);\n  float_1 = uint_2 & 0x80000000;\n  if ((int)uint_2 < 0) {\n    bool_1 = uint_1 != 0;\n    uint_1 = -uint_1;\n    uint_2 = -uint_2 - (uint)bool_1;\n  }\n  if (uint_2 < 0x800000) {\n    uint_4 = uint_1 & 0x80000000;\n    uint_1 = uint_1 << 1;\n    uint_2 = uint_2 * 2 + (uint)(uint_4 != 0);\n    uint_4 = uint_3 - 2;\n    if ((uint_2 & 0x800000) == 0) {\n      int_2 = count_leading_zeroes(uint_2);\n      uint_3 = int_2 - 8;\n      uint_2 = uint_2 << (uint_3 & 0xff);\n      if ((int)uint_4 < (int)uint_3) {\n        uint_2 = uint_2 >> (-(uint_4 - uint_3) & 0xff);\n      }\n      else {\n        uint_2 = uint_2 + (uint_4 - uint_3) * 0x800000;\n      }\n      return uint_2 | float_1;\n    }\n  }\n  else {\n    uint_4 = uint_3 - 1;\n    if (0xffffff < uint_2) {\n      uint_4 = uint_2 & 1;\n      uint_2 = uint_2 >> 1;\n      uint_1 = (uint)(uint_4 != 0) << 0x1f | uint_1 >> 1;\n      uint_4 = uint_3;\n      if (0xfd < uint_3) goto LAB_08000c12;\n    }\n  }\n  uint_2 = uint_2 + uint_4 * 0x800000 + (uint)(0x7fffffff < uint_1);\n  if (uint_1 == 0x80000000) {\n    uint_2 = uint_2 & 0xfffffffe;\n  }\n  return uint_2 | float_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000adc",
            "calling": [
                "__aeabi_frsub",
                "MS5611_Update",
                "MadgwickQuaternionUpdate",
                "Motor_DistributeSpeed",
                "PID_Update",
                "AHRS_GetYaw",
                "lowPassFilter",
                "AK8963_Init",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "calculate_float_08000adc"
        },
        "FUN_0800583e": {
            "renaming": {
                "FUN_0800583e": "do_nothing_0800583e"
            },
            "code": "\nvoid do_nothing_0800583e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583e",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_0800583e"
        },
        "FUN_08000160": {
            "renaming": {
                "FUN_08000160": "calculate_double_precision_08000160",
                "iVar1": "right_shifted_b",
                "bVar2": "lsb_of_sum",
                "uVar3": "sum_of_a_and_right_shifted_b",
                "uVar4": "a_sign_bit_cleared",
                "uVar5": "left_shifted_cleared_d",
                "iVar6": "right_shifted_b_sign_extended",
                "uVar7": "b_sign_bit_cleared",
                "uVar10": "difference_of_b_and_right_shifted_b",
                "uVar11": "left_shifted_a",
                "uVar12": "left_shifted_b",
                "bVar13": "a_equals_c",
                "bVar14": "condition",
                "bVar15": "overflow"
            },
            "code": "\nulonglong calculate_double_precision_08000160(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int right_shifted_b;\n  byte lsb_of_sum;\n  uint sum_of_a_and_right_shifted_b;\n  uint a_sign_bit_cleared;\n  uint left_shifted_cleared_d;\n  int right_shifted_b_sign_extended;\n  uint b_sign_bit_cleared;\n  uint uVar8;\n  uint uVar9;\n  uint difference_of_b_and_right_shifted_b;\n  uint left_shifted_a;\n  uint left_shifted_b;\n  bool a_equals_c;\n  bool condition;\n  bool overflow;\n  \n  a_sign_bit_cleared = param_2 ^ 0x80000000;\n  b_sign_bit_cleared = param_2 << 1;\n  uVar9 = param_4 << 1;\n  a_equals_c = ((a_sign_bit_cleared ^ param_4) & 0x7fffffff) == 0;\n  condition = a_equals_c && param_1 == param_3;\n  if (!a_equals_c || param_1 != param_3) {\n    condition = (b_sign_bit_cleared | param_1) == 0;\n  }\n  if (!condition) {\n    condition = (uVar9 | param_3) == 0;\n  }\n  right_shifted_b_sign_extended = (int)b_sign_bit_cleared >> 0x15;\n  if (!condition) {\n    condition = right_shifted_b_sign_extended == -1;\n  }\n  right_shifted_b = (int)uVar9 >> 0x15;\n  if (!condition) {\n    condition = right_shifted_b == -1;\n  }\n  if (condition) {\n    if (right_shifted_b_sign_extended == -1 || right_shifted_b == -1) {\n      uVar9 = param_4;\n      b_sign_bit_cleared = param_3;\n      if (right_shifted_b_sign_extended == -1) {\n        uVar9 = a_sign_bit_cleared;\n        b_sign_bit_cleared = param_1;\n      }\n      if (right_shifted_b_sign_extended != -1 || right_shifted_b != -1) {\n        param_3 = b_sign_bit_cleared;\n        param_4 = uVar9;\n      }\n      condition = (b_sign_bit_cleared | uVar9 << 0xc) == 0;\n      if (condition) {\n        condition = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (condition) {\n        condition = uVar9 == param_4;\n      }\n      if (!condition) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,b_sign_bit_cleared);\n    }\n    if (((a_sign_bit_cleared ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((b_sign_bit_cleared | param_1) == 0) {\n        param_1 = param_3;\n        a_sign_bit_cleared = param_4;\n      }\n      return CONCAT44(a_sign_bit_cleared,param_1);\n    }\n    if (a_sign_bit_cleared != param_4) {\n      return 0;\n    }\n    if (b_sign_bit_cleared >> 0x15 == 0) {\n      condition = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)condition;\n      if (CARRY4(a_sign_bit_cleared,a_sign_bit_cleared) || CARRY4(param_2 * 2,(uint)condition)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (b_sign_bit_cleared < 0xffc00000) {\n      return CONCAT44(a_sign_bit_cleared + 0x100000,param_1);\n    }\n    a_sign_bit_cleared = a_sign_bit_cleared & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(a_sign_bit_cleared | 0x7ff00000) << 0x20;\n  }\n  b_sign_bit_cleared = b_sign_bit_cleared >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  difference_of_b_and_right_shifted_b = uVar9 - b_sign_bit_cleared;\n  condition = difference_of_b_and_right_shifted_b != 0;\n  if (uVar9 < b_sign_bit_cleared) {\n    difference_of_b_and_right_shifted_b = -difference_of_b_and_right_shifted_b;\n  }\n  uVar8 = param_1;\n  left_shifted_b = a_sign_bit_cleared;\n  if (condition && b_sign_bit_cleared <= uVar9) {\n    b_sign_bit_cleared = b_sign_bit_cleared + difference_of_b_and_right_shifted_b;\n    uVar8 = param_3;\n    left_shifted_b = param_4;\n    param_3 = param_1;\n    param_4 = a_sign_bit_cleared;\n  }\n  if (0x36 < difference_of_b_and_right_shifted_b) {\n    return CONCAT44(left_shifted_b,uVar8);\n  }\n  uVar9 = left_shifted_b & 0xfffff | 0x100000;\n  if ((left_shifted_b & 0x80000000) != 0) {\n    condition = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)condition;\n  }\n  a_sign_bit_cleared = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    condition = param_3 != 0;\n    param_3 = -param_3;\n    a_sign_bit_cleared = -a_sign_bit_cleared - (uint)condition;\n  }\n  if (b_sign_bit_cleared == difference_of_b_and_right_shifted_b) {\n    a_sign_bit_cleared = a_sign_bit_cleared ^ 0x100000;\n    if (b_sign_bit_cleared == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      b_sign_bit_cleared = 1;\n    }\n    else {\n      difference_of_b_and_right_shifted_b = difference_of_b_and_right_shifted_b - 1;\n    }\n  }\n  left_shifted_b = -difference_of_b_and_right_shifted_b + 0x20;\n  if ((int)difference_of_b_and_right_shifted_b < 0x21) {\n    left_shifted_a = param_3 << (left_shifted_b & 0xff);\n    param_3 = param_3 >> (difference_of_b_and_right_shifted_b & 0xff);\n    sum_of_a_and_right_shifted_b = uVar8 + param_3;\n    left_shifted_cleared_d = a_sign_bit_cleared << (left_shifted_b & 0xff);\n    left_shifted_b = sum_of_a_and_right_shifted_b + left_shifted_cleared_d;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)a_sign_bit_cleared >> (difference_of_b_and_right_shifted_b & 0xff)) +\n            (uint)CARRY4(sum_of_a_and_right_shifted_b,left_shifted_cleared_d);\n  }\n  else {\n    left_shifted_a = a_sign_bit_cleared << (-difference_of_b_and_right_shifted_b + 0x40 & 0xff);\n    if (param_3 != 0) {\n      left_shifted_a = left_shifted_a | 2;\n    }\n    a_sign_bit_cleared = (int)a_sign_bit_cleared >> (difference_of_b_and_right_shifted_b - 0x20 & 0xff);\n    left_shifted_b = uVar8 + a_sign_bit_cleared;\n    uVar9 = uVar9 + ((int)a_sign_bit_cleared >> 0x1f) + (uint)CARRY4(uVar8,a_sign_bit_cleared);\n  }\n  a_sign_bit_cleared = uVar9 & 0x80000000;\n  difference_of_b_and_right_shifted_b = uVar9;\n  if ((int)uVar9 < 0) {\n    condition = left_shifted_a == 0;\n    left_shifted_a = -left_shifted_a;\n    difference_of_b_and_right_shifted_b = -left_shifted_b;\n    left_shifted_b = -(uint)!condition - left_shifted_b;\n    difference_of_b_and_right_shifted_b = -(uint)(condition <= difference_of_b_and_right_shifted_b) - uVar9;\n  }\n  if (0xfffff < difference_of_b_and_right_shifted_b) {\n    uVar8 = b_sign_bit_cleared - 1;\n    if (0x1fffff < difference_of_b_and_right_shifted_b) {\n      uVar9 = difference_of_b_and_right_shifted_b & 1;\n      difference_of_b_and_right_shifted_b = difference_of_b_and_right_shifted_b >> 1;\n      lsb_of_sum = (byte)left_shifted_b;\n      left_shifted_b = (uint)(uVar9 != 0) << 0x1f | left_shifted_b >> 1;\n      left_shifted_a = (uint)(lsb_of_sum & 1) << 0x1f | left_shifted_a >> 1;\n      uVar8 = b_sign_bit_cleared;\n      if (0xffbfffff < b_sign_bit_cleared * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    condition = 0x7fffffff < left_shifted_a;\n    if (left_shifted_a == 0x80000000) {\n      condition = (left_shifted_b & 1) != 0;\n    }\n    return CONCAT44(difference_of_b_and_right_shifted_b + uVar8 * 0x100000 + (uint)CARRY4(left_shifted_b,(uint)condition) | a_sign_bit_cleared,\n                    left_shifted_b + condition);\n  }\n  a_equals_c = (left_shifted_a & 0x80000000) != 0;\n  left_shifted_a = left_shifted_a << 1;\n  uVar8 = left_shifted_b * 2;\n  condition = CARRY4(left_shifted_b,left_shifted_b);\n  left_shifted_b = left_shifted_b * 2 + (uint)a_equals_c;\n  difference_of_b_and_right_shifted_b = difference_of_b_and_right_shifted_b * 2 + (uint)(condition || CARRY4(uVar8,(uint)a_equals_c));\n  uVar8 = b_sign_bit_cleared - 2;\n  if ((difference_of_b_and_right_shifted_b & 0x100000) != 0) goto LAB_08000278;\n  sum_of_a_and_right_shifted_b = left_shifted_b;\n  b_sign_bit_cleared = difference_of_b_and_right_shifted_b;\n  if (difference_of_b_and_right_shifted_b == 0) {\n    sum_of_a_and_right_shifted_b = 0;\n    b_sign_bit_cleared = left_shifted_b;\n  }\n  right_shifted_b_sign_extended = count_leading_zeroes(b_sign_bit_cleared);\n  if (difference_of_b_and_right_shifted_b == 0) {\n    right_shifted_b_sign_extended = right_shifted_b_sign_extended + 0x20;\n  }\n  left_shifted_b = right_shifted_b_sign_extended - 0xb;\n  overflow = SBORROW4(left_shifted_b,0x20);\n  difference_of_b_and_right_shifted_b = right_shifted_b_sign_extended - 0x2b;\n  condition = (int)difference_of_b_and_right_shifted_b < 0;\n  a_equals_c = difference_of_b_and_right_shifted_b == 0;\n  if ((int)left_shifted_b < 0x20) {\n    overflow = SCARRY4(difference_of_b_and_right_shifted_b,0xc);\n    right_shifted_b_sign_extended = right_shifted_b_sign_extended + -0x1f;\n    condition = right_shifted_b_sign_extended < 0;\n    a_equals_c = right_shifted_b_sign_extended == 0;\n    difference_of_b_and_right_shifted_b = left_shifted_b;\n    if (!a_equals_c && condition == overflow) {\n      sum_of_a_and_right_shifted_b = b_sign_bit_cleared << (left_shifted_b & 0xff);\n      b_sign_bit_cleared = b_sign_bit_cleared >> (0xcU - right_shifted_b_sign_extended & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (a_equals_c || condition != overflow) {\n    left_shifted_a = 0x20 - difference_of_b_and_right_shifted_b;\n  }\n  b_sign_bit_cleared = b_sign_bit_cleared << (difference_of_b_and_right_shifted_b & 0xff);\n  if (a_equals_c || condition != overflow) {\n    b_sign_bit_cleared = b_sign_bit_cleared | sum_of_a_and_right_shifted_b >> (left_shifted_a & 0xff);\n  }\n  if (a_equals_c || condition != overflow) {\n    sum_of_a_and_right_shifted_b = sum_of_a_and_right_shifted_b << (difference_of_b_and_right_shifted_b & 0xff);\n  }\nLAB_080002f0:\n  if ((int)left_shifted_b <= (int)uVar8) {\n    return CONCAT44(b_sign_bit_cleared + (uVar8 - left_shifted_b) * 0x100000 | a_sign_bit_cleared,sum_of_a_and_right_shifted_b);\n  }\n  difference_of_b_and_right_shifted_b = ~(uVar8 - left_shifted_b);\n  if ((int)difference_of_b_and_right_shifted_b < 0x1f) {\n    right_shifted_b_sign_extended = difference_of_b_and_right_shifted_b - 0x13;\n    if (right_shifted_b_sign_extended != 0 && right_shifted_b_sign_extended < 0 == SCARRY4(difference_of_b_and_right_shifted_b - 0x1f,0xc)) {\n      return CONCAT44(uVar9,sum_of_a_and_right_shifted_b >> (0x20 - (0xcU - right_shifted_b_sign_extended) & 0xff) | b_sign_bit_cleared << (0xcU - right_shifted_b_sign_extended & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference_of_b_and_right_shifted_b = difference_of_b_and_right_shifted_b + 1;\n    return CONCAT44(a_sign_bit_cleared | b_sign_bit_cleared >> (difference_of_b_and_right_shifted_b & 0xff),\n                    sum_of_a_and_right_shifted_b >> (difference_of_b_and_right_shifted_b & 0xff) | b_sign_bit_cleared << (0x20 - difference_of_b_and_right_shifted_b & 0xff));\n  }\n  return CONCAT44(uVar9,b_sign_bit_cleared >> (difference_of_b_and_right_shifted_b - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000160",
            "calling": [],
            "imported": false,
            "current_name": "calculate_double_precision_08000160"
        },
        "FUN_08002220": {
            "renaming": {
                "FUN_08002220": "calculateSystemCoreClock_08002220",
                "uVar1": "count_leading_zeroes_result",
                "PTR_SystemCoreClock_0800224c": "system_core_clock_ptr",
                "PTR_APBPrescTable_08002248": "apb_prescale_table_ptr",
                "DAT_08002244": "dat_08002244",
                "apb_prescale_index": "apb_prescale_index"
            },
            "code": "uint32_t calculateSystemCoreClock_08002220(void)\n{\n  uint32_t count_leading_zeroes_result = count_leading_zeroes(0xe00000);\n  uint32_t apb_prescale_index = (*(uint32_t *)(PTR_SystemCoreClock_0800224c)) >> (PTR_APBPrescTable_08002248[(*(uint32_t *)(DAT_08002244 + 4) & 0x700) >> (count_leading_zeroes_result & 0xff)]);\n  return apb_prescale_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002220",
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "calculateSystemCoreClock_08002220"
        },
        "FUN_08003314": {
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "new_beta",
                "in_r0": "beta_value",
                "PTR_beta_0800331c": "beta_pointer"
            },
            "code": "void set_beta_08003314(float new_beta)\n{\n    *(float*)PTR_beta_0800331c = new_beta;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003314",
            "calling": [
                "IMU_Init"
            ],
            "imported": false,
            "current_name": "set_beta_08003314"
        },
        "FUN_08005854": {
            "renaming": {
                "FUN_08005854": "calculate_08005854",
                "__x": "input",
                "puVar1": "fdlib_version",
                "iVar2": "compare_result",
                "puVar3": "errno_value",
                "dVar4": "result",
                "extraout_d0": "result",
                "extraout_d0_00": "result",
                "extraout_d0_01": "result",
                "extraout_d0_02": "result",
                "in_stack_ffffffb8": "in_stack_value_1",
                "in_stack_ffffffbc": "in_stack_value_2"
            },
            "code": "double calculate_08005854(double input)\n{\n  double result;\n  char *fdlib_version;\n  int compare_result;\n  int errno_value;\n  \n  result = (double)__ieee754_calculate_08005854();\n  fdlib_version = PTR___fdlib_version_080058f8;\n  if ((*PTR___fdlib_version_080058f8 != -1) &&\n     (compare_result = __unorddf2(), result = extraout_d0, compare_result == 0)) {\n    fabs((double)CONCAT44(in_stack_ffffffbc,in_stack_ffffffb8));\n    compare_result = __aeabi_dcmpgt();\n    result = extraout_d0_00;\n    if ((compare_result != 0) &&\n       ((nan(PTR_DAT_080058f4), *fdlib_version == '\\x02' ||\n        (compare_result = matherr((exception *)&stack0xffffffb8), result = extraout_d0_02, compare_result == 0)))) {\n      errno_value = *__errno();\n      *puVar3 = 0x21;\n      result = extraout_d0_01;\n    }\n  }\n  return result;\n}",
            "called": [
                "__unorddf2",
                "__aeabi_dcmpgt",
                "fabs",
                "matherr",
                "__errno",
                "nan",
                "__ieee754_asin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005854",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_08005854"
        },
        "FUN_08000168": {
            "renaming": {
                "FUN_08000168": "calculate_double_precision_08000168",
                "iVar1": "shift_amount1",
                "bVar2": "bit_flag",
                "uVar3": "temp_var1",
                "uVar4": "temp_var2",
                "uVar5": "temp_var3",
                "uVar6": "temp_var4",
                "uVar7": "temp_var5",
                "iVar8": "shift_amount2",
                "uVar9": "temp_var6",
                "uVar10": "temp_var7",
                "uVar11": "temp_var8",
                "uVar12": "temp_var9",
                "bVar13": "bool_flag1",
                "bVar14": "bool_flag2",
                "bVar15": "bool_flag3"
            },
            "code": "\nulonglong calculate_double_precision_08000168(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int shift_amount1;\n  byte bit_flag;\n  uint temp_var1;\n  uint temp_var2;\n  uint temp_var3;\n  uint temp_var4;\n  uint temp_var5;\n  int shift_amount2;\n  uint temp_var6;\n  uint temp_var7;\n  uint temp_var8;\n  uint temp_var9;\n  bool bool_flag1;\n  bool bool_flag2;\n  bool bool_flag3;\n  \n  temp_var4 = param_4 ^ 0x80000000;\n  temp_var6 = param_2 << 1;\n  param_4 = param_4 << 1;\n  bool_flag1 = ((param_2 ^ temp_var4) & 0x7fffffff) == 0;\n  bool_flag2 = bool_flag1 && param_1 == param_3;\n  if (!bool_flag1 || param_1 != param_3) {\n    bool_flag2 = (temp_var6 | param_1) == 0;\n  }\n  if (!bool_flag2) {\n    bool_flag2 = (param_4 | param_3) == 0;\n  }\n  shift_amount2 = (int)temp_var6 >> 0x15;\n  if (!bool_flag2) {\n    bool_flag2 = shift_amount2 == -1;\n  }\n  shift_amount1 = (int)param_4 >> 0x15;\n  if (!bool_flag2) {\n    bool_flag2 = shift_amount1 == -1;\n  }\n  if (bool_flag2) {\n    if (shift_amount2 == -1 || shift_amount1 == -1) {\n      temp_var6 = temp_var4;\n      temp_var8 = param_3;\n      if (shift_amount2 == -1) {\n        temp_var6 = param_2;\n        temp_var8 = param_1;\n      }\n      if (shift_amount2 != -1 || shift_amount1 != -1) {\n        param_3 = temp_var8;\n        temp_var4 = temp_var6;\n      }\n      bool_flag2 = (temp_var8 | temp_var6 << 0xc) == 0;\n      if (bool_flag2) {\n        bool_flag2 = (param_3 | temp_var4 << 0xc) == 0;\n      }\n      if (bool_flag2) {\n        bool_flag2 = temp_var6 == temp_var4;\n      }\n      if (!bool_flag2) {\n        temp_var6 = temp_var6 | 0x80000;\n      }\n      return CONCAT44(temp_var6,temp_var8);\n    }\n    if (((param_2 ^ temp_var4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((temp_var6 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = temp_var4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != temp_var4) {\n      return 0;\n    }\n    if (temp_var6 >> 0x15 == 0) {\n      bool_flag2 = (param_1 & 0x80000000) != 0;\n      temp_var4 = param_2 * 2 + (uint)bool_flag2;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bool_flag2)) {\n        temp_var4 = temp_var4 | 0x80000000;\n      }\n      return CONCAT44(temp_var4,param_1 << 1);\n    }\n    if (temp_var6 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  temp_var6 = temp_var6 >> 0x15;\n  param_4 = param_4 >> 0x15;\n  temp_var8 = param_4 - temp_var6;\n  bool_flag2 = temp_var8 != 0;\n  if (param_4 < temp_var6) {\n    temp_var8 = -temp_var8;\n  }\n  temp_var7 = param_1;\n  temp_var5 = param_2;\n  if (bool_flag2 && temp_var6 <= param_4) {\n    temp_var6 = temp_var6 + temp_var8;\n    temp_var7 = param_3;\n    temp_var5 = temp_var4;\n    param_3 = param_1;\n    temp_var4 = param_2;\n  }\n  if (0x36 < temp_var8) {\n    return CONCAT44(temp_var5,temp_var7);\n  }\n  temp_var2 = temp_var5 & 0xfffff | 0x100000;\n  if ((temp_var5 & 0x80000000) != 0) {\n    bool_flag2 = temp_var7 != 0;\n    temp_var7 = -temp_var7;\n    temp_var2 = -temp_var2 - (uint)bool_flag2;\n  }\n  temp_var5 = temp_var4 & 0xfffff | 0x100000;\n  if ((temp_var4 & 0x80000000) != 0) {\n    bool_flag2 = param_3 != 0;\n    param_3 = -param_3;\n    temp_var5 = -temp_var5 - (uint)bool_flag2;\n  }\n  if (temp_var6 == temp_var8) {\n    temp_var5 = temp_var5 ^ 0x100000;\n    if (temp_var6 == 0) {\n      temp_var2 = temp_var2 ^ 0x100000;\n      temp_var6 = 1;\n    }\n    else {\n      temp_var8 = temp_var8 - 1;\n    }\n  }\n  temp_var4 = -temp_var8 + 0x20;\n  if ((int)temp_var8 < 0x21) {\n    temp_var9 = param_3 << (temp_var4 & 0xff);\n    param_3 = param_3 >> (temp_var8 & 0xff);\n    temp_var1 = temp_var7 + param_3;\n    temp_var3 = temp_var5 << (temp_var4 & 0xff);\n    temp_var4 = temp_var1 + temp_var3;\n    temp_var2 = temp_var2 + CARRY4(temp_var7,param_3) + ((int)temp_var5 >> (temp_var8 & 0xff)) +\n            (uint)CARRY4(temp_var1,temp_var3);\n  }\n  else {\n    temp_var9 = temp_var5 << (-temp_var8 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      temp_var9 = temp_var9 | 2;\n    }\n    temp_var5 = (int)temp_var5 >> (temp_var8 - 0x20 & 0xff);\n    temp_var4 = temp_var7 + temp_var5;\n    temp_var2 = temp_var2 + ((int)temp_var5 >> 0x1f) + (uint)CARRY4(temp_var7,temp_var5);\n  }\n  param_2 = temp_var2 & 0x80000000;\n  temp_var8 = temp_var2;\n  if ((int)temp_var2 < 0) {\n    bool_flag2 = temp_var9 == 0;\n    temp_var9 = -temp_var9;\n    temp_var8 = -temp_var4;\n    temp_var4 = -(uint)!bool_flag2 - temp_var4;\n    temp_var8 = -(uint)(bool_flag2 <= temp_var8) - temp_var2;\n  }\n  if (0xfffff < temp_var8) {\n    temp_var7 = temp_var6 - 1;\n    if (0x1fffff < temp_var8) {\n      temp_var7 = temp_var8 & 1;\n      temp_var8 = temp_var8 >> 1;\n      bit_flag = (byte)temp_var4;\n      temp_var4 = (uint)(temp_var7 != 0) << 0x1f | temp_var4 >> 1;\n      temp_var9 = (uint)(bit_flag & 1) << 0x1f | temp_var9 >> 1;\n      temp_var7 = temp_var6;\n      if (0xffbfffff < temp_var6 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    bool_flag2 = 0x7fffffff < temp_var9;\n    if (temp_var9 == 0x80000000) {\n      bool_flag2 = (temp_var4 & 1) != 0;\n    }\n    return CONCAT44(temp_var8 + temp_var7 * 0x100000 + (uint)CARRY4(temp_var4,(uint)bool_flag2) | param_2,\n                    temp_var4 + bool_flag2);\n  }\n  bool_flag1 = (temp_var9 & 0x80000000) != 0;\n  temp_var9 = temp_var9 << 1;\n  temp_var7 = temp_var4 * 2;\n  bool_flag2 = CARRY4(temp_var4,temp_var4);\n  temp_var4 = temp_var4 * 2 + (uint)bool_flag1;\n  temp_var8 = temp_var8 * 2 + (uint)(bool_flag2 || CARRY4(temp_var7,(uint)bool_flag1));\n  temp_var7 = temp_var6 - 2;\n  if ((temp_var8 & 0x100000) != 0) goto LAB_08000278;\n  temp_var5 = temp_var4;\n  temp_var6 = temp_var8;\n  if (temp_var8 == 0) {\n    temp_var5 = 0;\n    temp_var6 = temp_var4;\n  }\n  shift_amount2 = count_leading_zeroes(temp_var6);\n  if (temp_var8 == 0) {\n    shift_amount2 = shift_amount2 + 0x20;\n  }\n  temp_var8 = shift_amount2 - 0xb;\n  bool_flag3 = SBORROW4(temp_var8,0x20);\n  temp_var4 = shift_amount2 - 0x2b;\n  bool_flag2 = (int)temp_var4 < 0;\n  bool_flag1 = temp_var4 == 0;\n  if ((int)temp_var8 < 0x20) {\n    bool_flag3 = SCARRY4(temp_var4,0xc);\n    shift_amount2 = shift_amount2 + -0x1f;\n    bool_flag2 = shift_amount2 < 0;\n    bool_flag1 = shift_amount2 == 0;\n    temp_var4 = temp_var8;\n    if (!bool_flag1 && bool_flag2 == bool_flag3) {\n      temp_var5 = temp_var6 << (temp_var8 & 0xff);\n      temp_var6 = temp_var6 >> (0xcU - shift_amount2 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bool_flag1 || bool_flag2 != bool_flag3) {\n    temp_var9 = 0x20 - temp_var4;\n  }\n  temp_var6 = temp_var6 << (temp_var4 & 0xff);\n  if (bool_flag1 || bool_flag2 != bool_flag3) {\n    temp_var6 = temp_var6 | temp_var5 >> (temp_var9 & 0xff);\n  }\n  if (bool_flag1 || bool_flag2 != bool_flag3) {\n    temp_var5 = temp_var5 << (temp_var4 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp_var8 <= (int)temp_var7) {\n    return CONCAT44(temp_var6 + (temp_var7 - temp_var8) * 0x100000 | param_2,temp_var5);\n  }\n  temp_var4 = ~(temp_var7 - temp_var8);\n  if ((int)temp_var4 < 0x1f) {\n    shift_amount2 = temp_var4 - 0x13;\n    if (shift_amount2 != 0 && shift_amount2 < 0 == SCARRY4(temp_var4 - 0x1f,0xc)) {\n      return CONCAT44(temp_var2,temp_var5 >> (0x20 - (0xcU - shift_amount2) & 0xff) | temp_var6 << (0xcU - shift_amount2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp_var4 = temp_var4 + 1;\n    return CONCAT44(param_2 | temp_var6 >> (temp_var4 & 0xff),\n                    temp_var5 >> (temp_var4 & 0xff) | temp_var6 << (0x20 - temp_var4 & 0xff));\n  }\n  return CONCAT44(temp_var2,temp_var6 >> (temp_var4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000168",
            "calling": [
                "MS5611_Update",
                "__ieee754_atan2",
                "__ieee754_sqrt",
                "atan",
                "rint",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_double_precision_08000168"
        },
        "FUN_080072e0": {
            "renaming": {
                "FUN_080072e0": "do_nothing_080072e0"
            },
            "code": "\nvoid do_nothing_080072e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072e0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080072e0"
        },
        "FUN_08001014": {
            "renaming": {
                "FUN_08001014": "check_if_not_null_08001014",
                "in_ZR": "input_char"
            },
            "code": "bool check_if_not_null_08001014(char input_char) {\n\t__aeabi_cfcmpeq();\n\treturn input_char != '\\0';\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001014",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "check_if_not_null_08001014"
        },
        "FUN_080071c0": {
            "renaming": {
                "FUN_080071c0": "calculate_080071c0",
                "__x": "x",
                "__n": "n",
                "in_r1": "temp_var",
                "extraout_r1": "temp_var2",
                "in_r2": "temp_var2",
                "uVar1": "shift_count",
                "iVar2": "result_shifted",
                "in_d0": "result",
                "dVar3": "result"
            },
            "code": "double calculate_080071c0(double x, int n)\n{\n  uint shift_count;\n  int temp_var;\n  int temp_var2;\n  uint result_shifted;\n  double result;\n\n  shift_count = (temp_var << 1) >> 0x15;\n\n  if (shift_count == 0) {\n    if ((temp_var & 0x7fffffff | n) == 0) {\n      return result;\n    }\n    result = (double)__muldf3(n, temp_var, 0, DAT_08007290);\n    if (temp_var2 < DAT_08007294) {\n      goto LAB_0800722e;\n    }\n    result_shifted = ((uint)(temp_var2 << 1) >> 0x15) - 0x36;\n  }\n  else if (shift_count == 0x7ff) {\n    result = (double)__aeabi_dadd(n, temp_var, n);\n    return result;\n  }\n  else {\n    result_shifted = shift_count + temp_var2;\n    if (result_shifted < 0x7ff) {\n      if (result_shifted > 0) {\n        return result;\n      }\n      if (result_shifted + 0x35 < 0 == SCARRY4(result_shifted, 0x35)) {\n        goto LAB_0800722e;\n      }\n      if (temp_var2 < 0xc351) {\n        copysign((double)CONCAT44(unaff_r4, temp_var), (double)CONCAT44(unaff_r6, unaff_r5));\n        goto LAB_0800722e;\n      }\n    }\n  }\n\n  copysign((double)CONCAT44(unaff_r4, temp_var), (double)CONCAT44(unaff_r6, unaff_r5));\n\nLAB_0800722e:\n  result = (double)__muldf3();\n  return result;\n}",
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "copysign"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071c0",
            "calling": [
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_080071c0"
        },
        "FUN_08001258": {
            "renaming": {
                "FUN_08001258": "do_nothing_08001258"
            },
            "code": "\nvoid do_nothing_08001258(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001258",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08001258"
        },
        "FUN_08005614": {
            "renaming": {
                "FUN_08005614": "find_byte_08005614",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "size",
                "pbVar1": "current_byte",
                "pbVar2": "found_byte"
            },
            "code": "void * find_byte_08005614(void *data, int byte_to_find, size_t size) {\n  unsigned char *current_byte = (unsigned char *)data;\n  while (current_byte != (unsigned char *)(size + (int)data)) {\n    if (*current_byte == (byte_to_find & 0xff)) {\n      return current_byte;\n    }\n    current_byte++;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005614",
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_08005614"
        },
        "FUN_08000724": {
            "renaming": {
                "FUN_08000724": "calculate_result_08000724",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "uVar5": "temp_5",
                "uVar6": "temp_6",
                "uVar7": "temp_7",
                "iVar8": "temp_8",
                "uVar9": "temp_9",
                "unaff_r5": "temp_10",
                "uVar10": "temp_11",
                "uVar11": "temp_12",
                "uVar12": "temp_13",
                "uVar13": "temp_14",
                "bVar14": "flag_1",
                "bVar15": "flag_2",
                "bVar16": "flag_3",
                "uVar17": "result"
            },
            "code": "\nulonglong calculate_result_08000724(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint temp_7;\n  int temp_8;\n  uint temp_9;\n  uint temp_10;\n  uint temp_11;\n  uint temp_12;\n  uint temp_13;\n  uint temp_14;\n  bool flag_1;\n  bool flag_2;\n  bool flag_3;\n  ulonglong result;\n  \n  result = CONCAT44(input_2,input_1);\n  temp_14 = 0x7ff;\n  temp_7 = input_2 >> 0x14 & 0x7ff;\n  flag_1 = temp_7 == 0;\n  if (!flag_1) {\n    temp_10 = input_4 >> 0x14 & 0x7ff;\n    flag_1 = temp_10 == 0;\n  }\n  if (!flag_1) {\n    flag_1 = temp_7 == 0x7ff;\n  }\n  if (!flag_1) {\n    flag_1 = temp_10 == 0x7ff;\n  }\n  if (flag_1) {\n    result = calculate_result_08000724_08000892();\n  }\n  temp_9 = (uint)(result >> 0x20);\n  temp_12 = (uint)result;\n  temp_8 = temp_7 - temp_10;\n  if ((input_3 | input_4 << 0xc) == 0) {\n    temp_7 = (temp_9 ^ input_4) & 0x80000000 | temp_9 & 0xfffff;\n    flag_3 = SCARRY4(temp_8,temp_14 >> 1);\n    temp_9 = temp_8 + (temp_14 >> 1);\n    flag_1 = (int)temp_9 < 0;\n    flag_2 = temp_9 == 0;\n    if (!flag_2 && flag_1 == flag_3) {\n      flag_3 = SBORROW4(temp_14,temp_9);\n      flag_1 = (int)(temp_14 - temp_9) < 0;\n      flag_2 = temp_14 == temp_9;\n    }\n    if (!flag_2 && flag_1 == flag_3) {\n      temp_7 = temp_7 | temp_9 * 0x100000;\n    }\n    if (!flag_2 && flag_1 == flag_3) {\n      return result & 0xffffffff | (ulonglong)temp_7 << 0x20;\n    }\n    temp_7 = temp_7 | 0x100000;\n    temp_14 = 0;\n    flag_2 = SBORROW4(temp_9,1);\n    temp_9 = temp_9 - 1;\n    flag_1 = temp_9 == 0;\n    temp_3 = temp_9;\n  }\n  else {\n    temp_3 = (input_4 << 0xc) >> 4 | 0x10000000 | input_3 >> 0x18;\n    temp_14 = input_3 << 8;\n    temp_11 = (temp_9 << 0xc) >> 4 | 0x10000000 | temp_12 >> 0x18;\n    temp_12 = temp_12 * 0x100;\n    temp_7 = (temp_9 ^ input_4) & 0x80000000;\n    flag_1 = temp_3 <= temp_11;\n    if (temp_11 == temp_3) {\n      flag_1 = temp_14 <= temp_12;\n    }\n    temp_8 = temp_8 + (uint)flag_1;\n    temp_9 = temp_8 + 0x3fd;\n    if (flag_1 == false) {\n      temp_3 = temp_3 >> 1;\n      temp_14 = (uint)((input_3 >> 0x18 & 1) != 0) << 0x1f | temp_14 >> 1;\n    }\n    temp_13 = temp_12 - temp_14;\n    temp_11 = (temp_11 - temp_3) - (uint)(temp_12 < temp_14);\n    temp_4 = temp_3 >> 1;\n    temp_1 = (uint)((temp_3 & 1) != 0) << 0x1f | temp_14 >> 1;\n    temp_12 = 0x100000;\n    temp_3 = 0x80000;\n    while( true ) {\n      flag_1 = temp_1 <= temp_13;\n      if (temp_4 < temp_11 || temp_11 - temp_4 < (uint)flag_1) {\n        temp_13 = temp_13 - temp_1;\n        temp_12 = temp_12 | temp_3;\n        temp_11 = (temp_11 - temp_4) - (uint)!flag_1;\n      }\n      temp_5 = temp_4 >> 1;\n      temp_1 = (uint)((temp_4 & 1) != 0) << 0x1f | temp_1 >> 1;\n      flag_2 = temp_1 <= temp_13;\n      flag_1 = temp_11 - temp_5 < (uint)flag_2;\n      temp_14 = temp_11;\n      if (temp_5 < temp_11 || flag_1) {\n        temp_13 = temp_13 - temp_1;\n        temp_14 = (temp_11 - temp_5) - (uint)!flag_2;\n      }\n      if (temp_5 < temp_11 || flag_1) {\n        temp_12 = temp_12 | temp_3 >> 1;\n      }\n      temp_11 = temp_4 >> 2;\n      temp_2 = (uint)((temp_5 & 1) != 0) << 0x1f | temp_1 >> 1;\n      flag_2 = temp_2 <= temp_13;\n      flag_1 = temp_14 - temp_11 < (uint)flag_2;\n      temp_5 = temp_14;\n      if (temp_11 < temp_14 || flag_1) {\n        temp_13 = temp_13 - temp_2;\n        temp_5 = (temp_14 - temp_11) - (uint)!flag_2;\n      }\n      if (temp_11 < temp_14 || flag_1) {\n        temp_12 = temp_12 | temp_3 >> 2;\n      }\n      temp_6 = temp_4 >> 3;\n      temp_1 = (uint)((temp_11 & 1) != 0) << 0x1f | temp_2 >> 1;\n      flag_2 = temp_1 <= temp_13;\n      flag_1 = temp_5 - temp_6 < (uint)flag_2;\n      temp_11 = temp_5;\n      if (temp_6 < temp_5 || flag_1) {\n        temp_13 = temp_13 - temp_1;\n        temp_11 = (temp_5 - temp_6) - (uint)!flag_2;\n      }\n      if (temp_6 < temp_5 || flag_1) {\n        temp_12 = temp_12 | temp_3 >> 3;\n      }\n      temp_14 = temp_11 | temp_13;\n      if (temp_14 == 0) break;\n      temp_11 = temp_11 << 4 | temp_13 >> 0x1c;\n      temp_13 = temp_13 << 4;\n      temp_4 = temp_4 & 0xfffffff8 | temp_1 >> 0x1d;\n      temp_1 = (temp_2 >> 1) << 3;\n      temp_3 = temp_3 >> 4;\n      if (temp_3 == 0) {\n        temp_6 = temp_4;\n        if ((temp_7 & 0x100000) != 0) goto LAB_08000842;\n        temp_7 = temp_7 | temp_12;\n        temp_12 = 0;\n        temp_3 = 0x80000000;\n      }\n    }\n    if ((temp_7 & 0x100000) == 0) {\n      temp_7 = temp_7 | temp_12;\n      temp_12 = 0;\n    }\nLAB_08000842:\n    flag_3 = 0xfc < temp_9;\n    flag_2 = SBORROW4(temp_9,0xfd);\n    temp_4 = temp_8 + 0x300;\n    flag_1 = temp_4 == 0;\n    temp_3 = temp_4;\n    if (flag_3 && !flag_1) {\n      flag_3 = 0x6ff < temp_4;\n      flag_2 = SBORROW4(temp_4,0x700);\n      temp_3 = temp_8 - 0x400;\n      flag_1 = temp_4 == 0x700;\n    }\n    if (!flag_3 || flag_1) {\n      flag_1 = temp_6 <= temp_11;\n      if (temp_11 == temp_6) {\n        flag_1 = temp_1 <= temp_13;\n      }\n      if (temp_11 == temp_6 && temp_13 == temp_1) {\n        flag_1 = (temp_12 & 1) != 0;\n      }\n      return CONCAT44(temp_7 + temp_9 * 0x100000 + (uint)CARRY4(temp_12,(uint)flag_1),temp_12 + flag_1);\n    }\n  }\n  if (!flag_1 && (int)temp_3 < 0 == flag_2) {\n    return (ulonglong)(temp_7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag_3 = SCARRY4(temp_9,0x36);\n  flag_1 = (int)(temp_9 + 0x36) < 0;\n  flag_2 = temp_9 == 0xffffffca;\n  if (flag_2 || flag_1 != flag_3) {\n    temp_12 = 0;\n  }\n  if (flag_2 || flag_1 != flag_3) {\n    temp_7 = temp_7 & 0x80000000;\n  }\n  if (flag_2 || flag_1 != flag_3) {\n    return CONCAT44(temp_7,temp_12);\n  }\n  temp_3 = -temp_9;\n  temp_11 = temp_3 - 0x20;\n  if (0x1f < (int)temp_3) {\n    temp_3 = temp_12 >> (temp_11 & 0xff) | temp_7 << (0x20 - temp_11 & 0xff);\n    temp_9 = (temp_7 >> (temp_11 & 0xff) & ~((temp_7 & 0x80000000) >> (temp_11 & 0xff))) -\n            ((int)temp_3 >> 0x1f);\n    if ((temp_14 | temp_12 << (0x20 - temp_11 & 0xff) | temp_3 << 1) == 0) {\n      temp_9 = temp_9 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44(temp_7,temp_9) & 0x80000000ffffffff;\n  }\n  temp_8 = temp_3 - 0x14;\n  if (temp_8 != 0 && temp_8 < 0 == SCARRY4(temp_11,0xc)) {\n    temp_9 = 0xc - temp_8;\n    temp_3 = temp_12 << (temp_9 & 0xff);\n    temp_12 = temp_12 >> (0x20 - temp_9 & 0xff) | temp_7 << (temp_9 & 0xff);\n    temp_9 = temp_12 + -((int)temp_3 >> 0x1f);\n    if ((temp_14 | temp_3 << 1) == 0) {\n      temp_9 = temp_9 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44((temp_7 & 0x80000000) + (uint)CARRY4(temp_12,-((int)temp_3 >> 0x1f)),temp_9);\n  }\n  temp_11 = temp_12 << (temp_9 + 0x20 & 0xff);\n  temp_12 = temp_12 >> (temp_3 & 0xff) | temp_7 << (temp_9 + 0x20 & 0xff);\n  temp_9 = temp_12 + -((int)temp_11 >> 0x1f);\n  if ((temp_14 | temp_11 << 1) == 0) {\n    temp_9 = temp_9 & ~(temp_11 >> 0x1f);\n  }\n  return CONCAT44((temp_7 & 0x80000000) +\n                  ((temp_7 & 0x7fffffff) >> (temp_3 & 0xff)) +\n                  (uint)CARRY4(temp_12,-((int)temp_11 >> 0x1f)),temp_9);\n}\n\n",
            "called": [
                "FUN_08000892"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000724",
            "calling": [
                "__ieee754_atan2",
                "MadgwickQuaternionUpdate",
                "sqrt",
                "__ieee754_sqrt",
                "atan",
                "pow",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_result_08000724"
        },
        "FUN_080070a4": {
            "renaming": {
                "FUN_080070a4": "calculate_tagb_080070a4",
                "__tagb": "tagb",
                "in_d0": "result"
            },
            "code": "double calculate_tagb_080070a4(char *__tagb)\n{\n  double result;\n  \n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080070a4",
            "calling": [
                "asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_tagb_080070a4"
        },
        "FUN_0800407c": {
            "renaming": {
                "FUN_0800407c": "read_i2c_byte_0800407c",
                "device_add": "device_address",
                "register_add": "register_address",
                "file": "file_name",
                "line": "line_number",
                "HVar1": "status",
                "byte": "data_buffer"
            },
            "code": "uint8_t read_i2c_byte_0800407c(uint16_t device_address, uint16_t register_address, char *file_name, int line_number)\n{\n  HAL_StatusTypeDef status;\n  uint8_t data_buffer[1];\n  data_buffer[0] = 0;\n  status = HAL_I2C_Mem_Read((I2C_HandleTypeDef *)PTR_hi2c1_080040b4, device_address, register_address, 1, data_buffer, 1, 200);\n  if (status != HAL_OK) {\n    _Error_Handler(file_name, line_number);\n  }\n  return data_buffer[0];\n}",
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800407c",
            "calling": [
                "MPU9250_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray",
                "AK8963_Init"
            ],
            "imported": false,
            "current_name": "read_i2c_byte_0800407c"
        },
        "FUN_08001938": {
            "renaming": {
                "FUN_08001938": "i2c_read_memory_08001938",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "pData": "data",
                "Size": "data_size",
                "Timeout": "timeout",
                "puVar1": "pointer_var1",
                "HVar2": "hal_status",
                "uVar3": "uint_var3",
                "uVar4": "uint_var4",
                "pIVar5": "i2c_instance",
                "uVar6": "uint_var6",
                "puVar7": "pointer_var7",
                "bVar8": "bool_var8",
                "tmpreg": "temp_reg",
                "tmpreg_1": "temp_reg_1",
                "tmpreg_2": "temp_reg_2"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nHAL_StatusTypeDef\ni2c_read_memory_08001938(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_address_size\n                ,uint8_t *data,uint16_t data_size,uint32_t timeout)\n\n{\n  uint8_t *pointer_var1;\n  HAL_StatusTypeDef hal_status;\n  uint32_t uint_var3;\n  uint32_t uint_var4;\n  I2C_TypeDef *i2c_instance;\n  uint uint_var6;\n  uint8_t *pointer_var7;\n  bool bool_var8;\n  uint32_t temp_reg;\n  uint32_t temp_reg_1;\n  uint32_t temp_reg_2;\n  \n  if (i2c_handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (data_size == 0) {\n    return HAL_ERROR;\n  }\n  uint_var3 = HAL_GetTick();\n  while (i2c_instance = i2c_handle->Instance, (~i2c_instance->SR2 & 2) == 0) {\n    uint_var4 = HAL_GetTick();\n    if (10000 < uint_var4 - uint_var3) {\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (i2c_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  uint_var6 = i2c_instance->CR1;\n  i2c_handle->Lock = HAL_LOCKED;\n  i2c_instance->CR1 = uint_var6 & 0xfffff7ff;\n  i2c_handle->State = HAL_I2C_STATE_BUSY_RX;\n  i2c_handle->Mode = HAL_I2C_MODE_MEM;\n  i2c_handle->ErrorCode = 0;\n  hal_status = I2C_RequestMemoryRead(i2c_handle,device_address,memory_address,memory_address_size,timeout);\n  if (hal_status != HAL_OK) {\n    i2c_handle->Lock = HAL_UNLOCKED;\n    if (i2c_handle->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  i2c_instance = i2c_handle->Instance;\n  uint_var6 = i2c_instance->CR1;\n  if (data_size == 1) {\n    i2c_instance->CR1 = uint_var6 & 0xfffffbff;\n    disableIRQinterrupts();\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    hal_status = I2C_WaitOnRXNEFlagUntiltimeout(i2c_handle,timeout);\n    if (hal_status == HAL_OK) {\n      *data = (uint8_t)i2c_handle->Instance->DR;\nLAB_08001ab8:\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (i2c_handle->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (data_size == 2) {\n    i2c_instance->CR1 = uint_var6 | 0x800;\n    disableIRQinterrupts();\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    i2c_instance->CR1 = uint_var6 | 0x400;\n    while (3 < data_size) {\n      hal_status = I2C_WaitOnRXNEFlagUntiltimeout(i2c_handle,timeout);\n      if (hal_status != HAL_OK) goto LAB_08001a18;\n      *data = (uint8_t)i2c_handle->Instance->DR;\n      i2c_instance = i2c_handle->Instance;\n      bool_var8 = (int)(i2c_instance->SR1 << 0x1d) < 0;\n      if (bool_var8) {\n        i2c_instance = (I2C_TypeDef *)i2c_instance->DR;\n        pointer_var7 = data + 2;\n        data_size = data_size - 2;\n      }\n      else {\n        pointer_var7 = data + 1;\n        data_size = data_size - 1;\n      }\n      pointer_var1 = data + 1;\n      data = pointer_var7;\n      if (bool_var8) {\n        *pointer_var1 = (uint8_t)i2c_instance;\n      }\n    }\n    if (data_size != 2) {\n      uint_var3 = HAL_GetTick();\n      do {\n        i2c_instance = i2c_handle->Instance;\n        do {\n          if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\n            i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *data = (uint8_t)i2c_handle->Instance->DR;\n            uint_var3 = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (uint_var4 = HAL_GetTick(), uint_var4 - uint_var3 <= timeout));\n      goto LAB_08001afa;\n    }\n  }\n  uint_var3 = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2c_handle->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        i2c_instance = i2c_handle->Instance;\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n        *data = (uint8_t)i2c_instance->DR;\n        enableIRQinterrupts();\n        data[1] = (uint8_t)i2c_handle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (uint_var4 = HAL_GetTick(), uint_var4 - uint_var3 <= timeout));\nLAB_08001afa:\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    i2c_instance = i2c_handle->Instance;\n    do {\n      if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n        data[1] = (uint8_t)i2c_instance->DR;\n        enableIRQinterrupts();\n        data[2] = (uint8_t)i2c_handle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (uint_var4 = HAL_GetTick(), uint_var4 - uint_var3 <= timeout));\n  goto LAB_08001afa;\n}\n\n",
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001938",
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "imported": false,
            "current_name": "i2c_read_memory_08001938"
        },
        "FUN_080022d0": {
            "renaming": {
                "FUN_080022d0": "configure_timer_080022d0",
                "TIMx": "timer",
                "OC_Config": "oc_config",
                "uVar1": "oc_polarity",
                "uVar2": "timer_cr2",
                "uVar3": "oc_mode",
                "DAT_08002320": "PTR_08002320"
            },
            "code": "void configure_timer_080022d0(TIM_TypeDef *timer, TIM_OC_InitTypeDef *oc_config) {\n  uint32_t timer_ccer = timer->CCER & 0xfffffeff;\n  uint32_t timer_cr2 = timer->CR2;\n  uint32_t oc_mode = oc_config->OCMode;\n  uint32_t oc_polarity = oc_config->OCPolarity << 8;\n\n  if (timer == DAT_08002320) {\n    oc_polarity = (oc_polarity & 0xfffff7ff) | (oc_config->OCNPolarity << 8) & 0xfffffbff;\n    timer_cr2 = (timer_cr2 & 0xffffcfff) | ((oc_config->OCIdleState | oc_config->OCNIdleState) << 4);\n  }\n\n  timer->CR2 = timer_cr2;\n  timer->CCMR2 = (timer->CCMR2 & 0xffffff8c) | oc_mode;\n  timer->CCR3 = oc_config->Pulse;\n  timer->CCER = (timer_ccer & 0xfffffdff) | oc_polarity;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022d0",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_080022d0"
        },
        "FUN_080010c4": {
            "renaming": {
                "FUN_080010c4": "calculate_shifted_value_080010c4",
                "param_1": "input_value",
                "uVar1": "shift_amount",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "uint calculate_shifted_value_080010c4(uint input_value)\n{\n  uint shifted_value;\n  uint shift_amount = 0x9e - ((input_value << 1) >> 0x18);\n  \n  if (((input_value & 0x80000000) != 0) || (input_value << 1 < 0x7f000000)) {\n    return 0;\n  }\n  \n  if (-1 < (int)shift_amount) {\n    shifted_value = (input_value << 8 | 0x80000000) >> (shift_amount & 0xff);\n    return shifted_value;\n  }\n  \n  if ((shift_amount == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  \n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080010c4",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_shifted_value_080010c4"
        },
        "FUN_0800245c": {
            "renaming": {
                "FUN_0800245c": "configureTimer_0800245c",
                "htim": "timer_handle",
                "sConfig": "output_channel_config",
                "Channel": "channel",
                "extraout_r1": "extra_output_register_1",
                "extraout_r1_00": "extra_output_register_2",
                "extraout_r1_01": "extra_output_register_3",
                "ccmr": "capture_compare_mode_register",
                "extraout_r1_02": "extra_output_register_4",
                "uVar1": "unsigned_variable_1",
                "iVar2": "signed_variable_1",
                "uVar3": "unsigned_variable_3",
                "pTVar4": "timer_instance",
                "HAL_LOCKED": "timer_locked",
                "HAL_BUSY": "busy_status",
                "HAL_TIM_STATE_BUSY": "busy_timer_state",
                "HAL_TIM_STATE_READY": "ready_timer_state",
                "HAL_UNLOCKED": "timer_unlocked",
                "TIM_OC1_SetConfig": "setOutputCompare1Config",
                "TIM_OC2_SetConfig": "setOutputCompare2Config",
                "TIM_OC3_SetConfig": "setOutputCompare3Config",
                "TIM_OC4_SetConfig": "setOutputCompare4Config",
                "Instance": "timer_instance"
            },
            "code": "HAL_StatusTypeDef configureTimer_0800245c(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *output_channel_config, uint32_t channel) {\n  int extraout_r1;\n  int extraout_r1_00;\n  int extraout_r1_01;\n  uint32_t ccmr;\n  int extraout_r1_02;\n  int value;\n  uint32_t uVar3;\n  TIM_TypeDef *timer_instance;\n  if (timer_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  timer_handle->State = HAL_TIM_STATE_BUSY;\n  timer_handle->Lock = HAL_LOCKED;\n  switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timer_handle->Instance, output_channel_config);\n      timer_instance = timer_handle->Instance;\n      ccmr = *(uint *)(extraout_r1 + 0x10);\n      timer_instance->CCMR1 |= 8;\n      timer_instance->CCMR1 &= 0xfffffffb;\n      uVar3 = timer_instance->CCMR1 | ccmr;\n      break;\n    default:\n      goto switchD_0800247a_caseD_1;\n    case 4:\n      TIM_OC2_SetConfig(timer_handle->Instance, output_channel_config);\n      timer_instance = timer_handle->Instance;\n      value = *(int *)(extraout_r1_00 + 0x10);\n      timer_instance->CCMR1 |= 0x800;\n      timer_instance->CCMR1 &= 0xfffffbff;\n      uVar3 = timer_instance->CCMR1 | value << 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timer_handle->Instance, output_channel_config);\n      timer_instance = timer_handle->Instance;\n      ccmr = *(uint *)(extraout_r1_01 + 0x10);\n      timer_instance->CCMR2 |= 8;\n      timer_instance->CCMR2 &= 0xfffffffb;\n      uVar3 = timer_instance->CCMR2 | ccmr;\n      goto LAB_080024fa;\n    case 0xc:\n      TIM_OC4_SetConfig(timer_handle->Instance, output_channel_config);\n      timer_instance = timer_handle->Instance;\n      value = *(int *)(extraout_r1_02 + 0x10);\n      timer_instance->CCMR2 |= 0x800;\n      timer_instance->CCMR2 &= 0xfffffbff;\n      uVar3 = timer_instance->CCMR2 | value << 8;\nLAB_080024fa:\n      timer_instance->CCMR2 = uVar3;\n      goto switchD_0800247a_caseD_1;\n  }\n  timer_instance->CCMR1 = uVar3;\nswitchD_0800247a_caseD_1:\n  timer_handle->State = HAL_TIM_STATE_READY;\n  timer_handle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800245c",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configureTimer_0800245c"
        },
        "FUN_080008f4": {
            "renaming": {
                "FUN_080008f4": "compare_and_set_080008f4",
                "param_1": "first_value",
                "param_2": "first_mask",
                "param_3": "second_value",
                "param_4": "result",
                "uVar1": "mask_diff",
                "bVar2": "first_value_zero",
                "bVar3": "masks_inverted"
            },
            "code": "uint compare_and_set_080008f4(uint first_value, uint first_mask, uint second_value, uint second_mask)\n{\n    uint result;\n    bool first_value_zero = (first_value | (first_mask << 1)) == 0;\n    bool second_value_zero = (second_value | (second_mask << 1)) == 0;\n    bool values_equal = first_value == second_value;\n    bool masks_equal = first_mask == second_mask;\n    bool masks_inverted = first_mask == ~second_mask;\n\n    if ((int)(first_mask << 1) >> 0x15 == -1 || (int)(second_mask << 1) >> 0x15 == -1)\n    {\n        if ((int)(first_mask << 1) >> 0x15 == -1 && !first_value_zero)\n        {\n            return 0xffffffff;\n        }\n        else if ((int)(second_mask << 1) >> 0x15 == -1 && !second_value_zero)\n        {\n            return 0xffffffff;\n        }\n    }\n\n    if (first_value_zero && second_value_zero)\n    {\n        result = 1;\n    }\n    else if (values_equal && masks_equal)\n    {\n        result = 1;\n    }\n    else if (masks_inverted && (second_value <= first_value))\n    {\n        result = 1;\n    }\n    else if (values_equal && (second_value <= first_value))\n    {\n        result = 1;\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080008f4",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_set_080008f4"
        },
        "FUN_08004e14": {
            "renaming": {
                "FUN_08004e14": "initialize_GPIO_pin_08004e14",
                "TIM_HandleTypeDef": "timer_handle",
                "htim": "timer_handle",
                "GPIO_TypeDef": "GPIO_port",
                "pGVar1": "GPIO_port",
                "TIM_TypeDef": "timer_instance",
                "pTVar2": "timer_instance",
                "GPIO_InitTypeDef": "GPIO_init_structure",
                "GPIO_InitStruct": "GPIO_init_structure",
                "DAT_08004e6c": "GPIO_PORTB",
                "DAT_08004e68": "TIMER_1",
                "DAT_08004e70": "TIMER_3",
                "DAT_08004e74": "GPIO_PORTC",
                "DAT_08004e78": "TIMER_4"
            },
            "code": "void initialize_GPIO_pin_08004e14(TIM_HandleTypeDef *timer_handle)\n{\n  GPIO_TypeDef *GPIO_port;\n  TIM_TypeDef *timer_instance;\n  GPIO_InitTypeDef GPIO_init_structure;\n  \n  timer_instance = timer_handle->Instance;\n  GPIO_port = DAT_08004e6c;\n  if (timer_instance == DAT_08004e68) {\n    GPIO_init_structure.Pin = GPIO_PIN_11;\n  }\n  else if (timer_instance == TIMER_2) {\n    GPIO_init_structure.Pin = GPIO_PIN_1;\n  }\n  else {\n    GPIO_port = DAT_08004e74;\n    if (timer_instance == DAT_08004e70) {\n      GPIO_init_structure.Pin = GPIO_PIN_2;\n    }\n    else {\n      if (timer_instance != DAT_08004e78) {\n        return;\n      }\n      GPIO_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9;\n    }\n  }\n  GPIO_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;\n  GPIO_init_structure.Mode = GPIO_MODE_AF_PP;\n  HAL_GPIO_Init(GPIO_port, &GPIO_init_structure);\n  return;\n}",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e14",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "initialize_GPIO_pin_08004e14"
        },
        "FUN_08002ea0": {
            "renaming": {
                "FUN_08002ea0": "initializeSensors_08002ea0",
                "_beta": "betaValue",
                "_deltat": "deltatValue",
                "MPU9250_Init": "initializeMPU9250",
                "AK8963_Init": "initializeAK8963",
                "MadgwickSetBeta": "setMadgwickBeta",
                "MadgwickSetDelta": "setMadgwickDelta"
            },
            "code": "void initializeSensors_08002ea0(void)\n{\n  float betaValue;\n  float deltatValue;\n  MPU9250_Init();\n  AK8963_Init();\n  MadgwickSetBeta(betaValue);\n  MadgwickSetDelta(deltatValue);\n  return;\n}",
            "called": [
                "MPU9250_Init",
                "MadgwickSetBeta",
                "MadgwickSetDelta",
                "AK8963_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ea0",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initializeSensors_08002ea0"
        },
        "FUN_08001424": {
            "renaming": {
                "FUN_08001424": "set_GPIO_PinState_08001424",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "uVar1": "pin_mask",
                "GPIO_PIN_RESET": "PIN_RESET"
            },
            "code": "void set_GPIO_PinState_08001424(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  uint32_t pin_mask;\n  pin_mask = (uint32_t)GPIO_Pin;\n  if (PinState == GPIO_PIN_RESET) {\n    pin_mask <<= 0x10;\n  }\n  GPIOx->BSRR = pin_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001424",
            "calling": [
                "toggleLED",
                "_Error_Handler",
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "set_GPIO_PinState_08001424"
        },
        "FUN_08002998": {
            "renaming": {
                "FUN_08002998": "do_nothing_08002998"
            },
            "code": "\nvoid do_nothing_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002998",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08002998"
        },
        "FUN_08005900": {
            "renaming": {
                "FUN_08005900": "calculate_result_08005900",
                "__x": "input_x",
                "__y": "input_y",
                "cVar1": "char_var",
                "puVar2": "pointer_var",
                "iVar3": "int_var_1",
                "iVar4": "int_var_2",
                "piVar5": "int_pointer_var",
                "puVar6": "undefined4_pointer_var",
                "extraout_r1": "undefined4_var_1",
                "extraout_r1_00": "undefined4_var_2",
                "uVar7": "undefined4_var_3",
                "extraout_d0": "result_1",
                "extraout_d0_00": "result_2",
                "extraout_d0_01": "result_3",
                "extraout_d0_02": "result_4",
                "extraout_d0_03": "result_5",
                "extraout_d0_04": "result_6",
                "extraout_d0_05": "result_7",
                "extraout_d0_06": "result_8",
                "extraout_d0_07": "result_9",
                "extraout_d0_08": "result_10",
                "extraout_d0_09": "result_11",
                "extraout_d0_10": "result_12",
                "extraout_d0_11": "result_13",
                "extraout_d0_12": "result_14",
                "dVar8": "result",
                "uVar9": "undefined8_var",
                "local_50": "exception_info",
                "local_38": "double_var",
                "local_30": "int_var_3"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\ndouble calculate_result_08005900(double input_x,double input_y)\n\n{\n  char char_var;\n  undefined *pointer_var;\n  int int_var_1;\n  int int_var_2;\n  int *int_pointer_var;\n  undefined4 *undefined4_pointer_var;\n  undefined4 undefined4_var_1;\n  undefined4 undefined4_var_2;\n  undefined4 undefined4_var_3;\n  double result_1;\n  double result_2;\n  double result_3;\n  double result_4;\n  double result_5;\n  double result_6;\n  double result_7;\n  double result_8;\n  double result_9;\n  double result_10;\n  double result_11;\n  double result_12;\n  double result_13;\n  double result_14;\n  double result;\n  undefined8 undefined8_var;\n  undefined exception_info [24];\n  undefined8 double_var;\n  int int_var_3;\n  \n  result = (double)__ieee754_calculate_result_08005900();\n  pointer_var = PTR___fdlib_version_08005ba8;\n  char_var = *PTR___fdlib_version_08005ba8;\n  if (char_var == -1) {\n    return result_1;\n  }\n  int_var_3 = __unorddf2();\n  if (int_var_3 != 0) {\n    return result_2;\n  }\n  int_var_1 = __unorddf2();\n  if (int_var_1 != 0) {\n    int_var_1 = __aeabi_dcmpeq();\n    if (int_var_1 == 0) {\n      return result_3;\n    }\n    exception_info._0_4_ = 1;\n    exception_info._4_4_ = PTR_DAT_08005bac;\n    double_var = (double)((ulonglong)DAT_08005bb0 << 0x20);\n    if (char_var == '\\x02') {\n      return result_3;\n    }\n    goto LAB_08005978;\n  }\n  int_var_2 = __aeabi_dcmpeq();\n  if (int_var_2 == 0) {\n    int_var_1 = finite(result);\n    if ((int_var_1 == 0) && (int_var_2 = finite(result), int_var_2 != 0)) {\n      int_var_2 = finite(result);\n      if (int_var_2 == 0) goto LAB_08005b4c;\n      int_var_3 = __unorddf2(SUB84(result,0),(int)((ulonglong)result >> 0x20));\n      char_var = *pointer_var;\n      if (int_var_3 != 0) {\n        exception_info._4_4_ = PTR_DAT_08005bac;\n        exception_info._0_4_ = 1;\n        int_var_3 = int_var_1;\n        if (char_var == '\\0') goto LAB_08005a22;\n        double_var = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      exception_info._4_4_ = PTR_DAT_08005bac;\n      exception_info._0_4_ = 3;\n      if (char_var != '\\0') {\n        double_var._0_4_ = 0;\n        double_var._4_4_ = DAT_08005bc4;\n        int_var_1 = __aeabi_dcmplt();\n        if (int_var_1 != 0) {\n          undefined8_var = __muldf3();\n          undefined4_var_3 = (int)undefined8_var;\n          rint(result);\n          int_var_1 = __aeabi_dcmpeq((int)undefined8_var,(int)((ulonglong)undefined8_var >> 0x20),undefined4_var_3,undefined4_var_2);\n          if (int_var_1 == 0) {\n            double_var._0_4_ = 0;\n            double_var._4_4_ = DAT_08005bb4;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      double_var._0_4_ = 0xe0000000;\n      double_var._4_4_ = DAT_08005bb8;\n      int_var_1 = __aeabi_dcmplt();\n      if (int_var_1 != 0) {\n        undefined8_var = __muldf3();\n        undefined4_var_3 = (int)undefined8_var;\n        rint(result);\n        int_var_1 = __aeabi_dcmpeq((int)undefined8_var,(int)((ulonglong)undefined8_var >> 0x20),undefined4_var_3,undefined4_var_1);\n        if (int_var_1 == 0) {\n          double_var._0_4_ = 0xe0000000;\n          double_var._4_4_ = DAT_08005bc0;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      int_var_1 = matherr((exception *)exception_info);\n      result = result_14;\n      if (int_var_1 != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      int_var_1 = __aeabi_dcmpeq(SUB84(result,0),(int)((ulonglong)result >> 0x20),0,0);\n      if (int_var_1 == 0) {\n        return result_11;\n      }\n      int_var_1 = finite(result);\n      if (int_var_1 == 0) {\n        return result_12;\n      }\n      int_var_1 = finite(result);\n      if (int_var_1 == 0) {\n        return result_13;\n      }\n      exception_info._0_4_ = 4;\n      exception_info._4_4_ = PTR_DAT_08005bac;\n      int_var_3 = 0;\n      double_var._0_4_ = 0;\n      double_var._4_4_ = 0;\nLAB_08005afa:\n      if (*pointer_var != '\\x02') goto LAB_08005b98;\n    }\n    undefined4_pointer_var = (undefined4 *)__errno();\n    undefined4_var_3 = 0x22;\n    result = result_10;\n  }\n  else {\n    int_var_3 = __aeabi_dcmpeq();\n    if (int_var_3 == 0) {\n      int_var_1 = finite(result);\n      if (int_var_1 == 0) {\n        return result_7;\n      }\n      int_var_1 = __aeabi_dcmplt();\n      if (int_var_1 == 0) {\n        return result_8;\n      }\n      exception_info._0_4_ = 1;\n      exception_info._4_4_ = PTR_DAT_08005bac;\n      char_var = *pointer_var;\n      if (char_var == '\\0') {\nLAB_08005a22:\n        exception_info._0_4_ = 1;\n        double_var = 0.0;\n        exception_info._4_4_ = PTR_DAT_08005bac;\n        goto LAB_08005978;\n      }\n      double_var = (double)((ulonglong)DAT_08005bb4 << 0x20);\nLAB_08005a32:\n      if (char_var != '\\x02') goto LAB_08005978;\n    }\n    else {\n      exception_info._0_4_ = 1;\n      exception_info._4_4_ = PTR_DAT_08005bac;\n      double_var = 0.0;\n      int_var_3 = int_var_1;\n      if (char_var != '\\0') {\n        double_var = (double)((ulonglong)DAT_08005bb0 << 0x20);\n        result = result_5;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      int_var_1 = matherr((exception *)exception_info);\n      result = result_4;\n      if (int_var_1 != 0) goto LAB_080059d0;\n    }\n    undefined4_pointer_var = (undefined4 *)__errno();\n    undefined4_var_3 = 0x21;\n    result = result_9;\n  }\n  *undefined4_pointer_var = undefined4_var_3;\nLAB_080059d0:\n  if (int_var_3 != 0) {\n    int_pointer_var = (int *)__errno();\n    *int_pointer_var = int_var_3;\n    result = result_6;\n  }\n  return result;\n}\n\n",
            "called": [
                "__divdf3",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__aeabi_dcmpeq",
                "__muldf3",
                "finite",
                "matherr",
                "rint",
                "__errno",
                "__ieee754_pow"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005900",
            "calling": [
                "MS5611_Update"
            ],
            "imported": false,
            "current_name": "calculate_result_08005900"
        },
        "FUN_08004c64": {
            "renaming": {
                "FUN_08004c64": "initialize_circular_buffer_08004c64",
                "PTR_rxc_08004c6c": "buffer"
            },
            "code": "void initialize_circular_buffer_08004c64(void)\n{\n  CircularBuffer* PTR_rxc_08004c6c = (CircularBuffer*)PTR_rxc_08004c6c;\n  CB_Init(PTR_rxc_08004c6c);\n  return;\n}",
            "called": [
                "CB_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c64",
            "calling": [
                "serialBegin"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_08004c64"
        },
        "FUN_080041e4": {
            "renaming": {
                "FUN_080041e4": "set_motor_pwm_080041e4",
                "m1": "motor1_pwm",
                "m2": "motor2_pwm",
                "m3": "motor3_pwm",
                "m4": "motor4_pwm",
                "puVar1": "motor_pwm_ptr",
                "puVar2": "msp_txf_motor_ptr",
                "pwm": "motor1_pwm_masked"
            },
            "code": "void set_motor_pwm_080041e4(int motor1_pwm, int motor2_pwm, int motor3_pwm, int motor4_pwm) {\n  int *motor_pwm_ptr = PTR_motor_pwm_08004264;\n  if (motor1_pwm > 999) {\n    motor1_pwm = 1000;\n  }\n  if (motor2_pwm > 999) {\n    motor2_pwm = 1000;\n  }\n  if (motor3_pwm > 999) {\n    motor3_pwm = 1000;\n  }\n  if (motor4_pwm > 999) {\n    motor4_pwm = 1000;\n  }\n  uint pwm = motor1_pwm & ~(motor1_pwm >> 0x1f);\n  *(int *)(motor_pwm_ptr + 8) = motor3_pwm & ~(motor3_pwm >> 0x1f);\n  *(int *)(motor_pwm_ptr + 0xc) = motor4_pwm & ~(motor4_pwm >> 0x1f);\n  *(int *)(motor_pwm_ptr + 4) = motor2_pwm & ~(motor2_pwm >> 0x1f);\n  *(uint *)motor_pwm_ptr = pwm;\n  Motor1_SetPWM(pwm);\n  Motor2_SetPWM(*(int *)(motor_pwm_ptr + 4));\n  Motor3_SetPWM(*(int *)(motor_pwm_ptr + 8));\n  Motor4_SetPWM(*(int *)(motor_pwm_ptr + 0xc));\n  int *msp_txf_motor_ptr = PTR_msp_txf_motor_08004268;\n  *(short *)msp_txf_motor_ptr = (short)*(int *)motor_pwm_ptr + 1000;\n  *(short *)(msp_txf_motor_ptr + 2) = (short)*(int *)(motor_pwm_ptr + 4) + 1000;\n  *(short *)(msp_txf_motor_ptr + 4) = (short)*(int *)(motor_pwm_ptr + 8) + 1000;\n  *(short *)(msp_txf_motor_ptr + 6) = (short)*(int *)(motor_pwm_ptr + 0xc) + 1000;\n  return;\n}",
            "called": [
                "Motor2_SetPWM",
                "Motor1_SetPWM",
                "Motor4_SetPWM",
                "Motor3_SetPWM"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041e4",
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "imported": false,
            "current_name": "set_motor_pwm_080041e4"
        },
        "FUN_080003e4": {
            "renaming": {
                "FUN_080003e4": "shift_and_concatenate_bits_080003e4",
                "param_1": "input",
                "uVar1": "low_bits",
                "uVar2": "trailing_zeroes",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount",
                "in_r12": "excess_shift",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "overflow"
            },
            "code": "uint64_t shift_and_concatenate_bits_080003e4(uint32_t input)\n{\n  uint32_t leading_zeroes = count_leading_zeroes(input);\n  uint32_t shift_amount = leading_zeroes + 21;\n  uint32_t trailing_zeroes = 32 - shift_amount;\n  uint64_t high_bits = 0;\n  uint32_t low_bits = input << (shift_amount & 0x1F);\n  if (shift_amount < 32)\n  {\n    high_bits = input >> (trailing_zeroes & 0x1F);\n  }\n  else if (shift_amount < 1075)\n  {\n    high_bits = (input + (1075 - shift_amount) * 0x100000) << 32;\n  }\n  else\n  {\n    uint32_t excess_shift = ~(1075 - shift_amount);\n    if (excess_shift > 30)\n    {\n      high_bits = 0;\n    }\n    else if (excess_shift < 19)\n    {\n      high_bits = input >> (19 - excess_shift);\n      low_bits |= input << (excess_shift + 13);\n    }\n    else\n    {\n      high_bits = input << (excess_shift - 19);\n    }\n  }\n  return high_bits | low_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003e4",
            "calling": [],
            "imported": false,
            "current_name": "shift_and_concatenate_bits_080003e4"
        },
        "FUN_08007092": {
            "renaming": {
                "FUN_08007092": "get_sign_bit_08007092",
                "__value": "value",
                "in_r1": "sign",
                "0x80000000": "SIGN_BIT",
                "0x100000": "MAGNITUDE_BITS",
                ">> 0x1f": ">> 31"
            },
            "code": "int get_sign_bit_08007092(double value) {\n    const uint SIGN_BIT = 0x80000000;\n    const uint MAGNITUDE_BITS = 0x7FFFFFFF;\n    uint sign = *(uint*)&value & SIGN_BIT;\n    return sign >> 31;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007092",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "get_sign_bit_08007092"
        },
        "FUN_08002f28": {
            "renaming": {
                "FUN_08002f28": "calculateAttitude_08002f28",
                "puVar2": "pointer1",
                "puVar3": "pointer2",
                "puVar4": "pointer3",
                "uVar5": "unsignedShortVar",
                "uVar6": "microsVar",
                "uVar7": "unsignedFloatVar",
                "iVar8": "lastUpdateTime",
                "_deltat": "delta_t",
                "ax": "accel_x_f",
                "ay": "accel_y_f",
                "az": "accel_z_f",
                "gx": "gyro_x_f",
                "gy": "gyro_y_f",
                "gz": "gyro_z_f",
                "mx": "mag_x_f",
                "my": "mag_y_f"
            },
            "code": "void calculateAttitude_08002f28(void)\n{\n  short accel_x;\n  uint32_t currentTime;\n  float delta_t, accel_x_f, accel_y_f, accel_z_f, gyro_x_f, gyro_y_f, gyro_z_f, mag_x_f, mag_y_f;\n\n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n\n  currentTime = micros();\n  uint32_t lastUpdateTime = *(uint32_t*)lastUpdate;\n  *(uint32_t*)lastUpdate = currentTime;\n  uint32_t timeSinceLastUpdate = currentTime - lastUpdateTime;\n  delta_t = (float)timeSinceLastUpdate / 1000000.0;\n\n  MadgwickSetDelta(delta_t);\n\n  accel_x_f = (float)*(int*)accelData / 100.0;\n  accel_y_f = (float)*((int*)accelData + 1) / 100.0;\n  accel_z_f = (float)*((int*)accelData + 2) / 100.0;\n  gyro_x_f = (float)*(int*)gyroData / 100.0;\n  gyro_y_f = (float)*((int*)gyroData + 1) / 100.0;\n  gyro_z_f = (float)*((int*)gyroData + 2) / 100.0;\n  mag_x_f = (float)*(int*)magRaw / 100.0;\n  mag_y_f = (float)*((int*)magRaw + 1) / 100.0;\n\n  MadgwickQuaternionUpdate(accel_x_f, accel_y_f, accel_z_f, gyro_x_f, gyro_y_f, gyro_z_f, mag_x_f, mag_y_f);\n\n  *(short*)rawIMU = (short)accel_x;\n  *(short*)((int*)rawIMU + 1) = (short)(*(int*)accelData / 100);\n  *(short*)((int*)rawIMU + 2) = (short)(*(int*)accelData + 2 / 100);\n  *(short*)((int*)rawIMU + 3) = (short)(*(int*)gyroData / 100);\n  *(short*)((int*)rawIMU + 4) = (short)(*(int*)gyroData + 2 / 100);\n  *(short*)((int*)rawIMU + 5) = (short)(*(int*)gyroData + 4 / 100);\n  *(short*)((int*)rawIMU + 6) = (short)(*(int*)magRaw / 100);\n  *(short*)((int*)rawIMU + 7) = (short)(*(int*)magRaw + 2 / 100);\n\n  *(short*)txfAttitude = (short)(GetRoll() * 100);\n  *(short*)((int*)txfAttitude + 1) = (short)(GetPitch() * 100);\n  *(short*)((int*)txfAttitude + 2) = (short)(GetYaw() * 100);\n}\n",
            "called": [
                "AK8963_ReadData",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AHRS_GetRoll",
                "__aeabi_fdiv",
                "AHRS_GetYaw",
                "micros",
                "__aeabi_f2iz",
                "MPU9250_ReadAccelData",
                "__aeabi_fmul",
                "__floatunsisf",
                "MadgwickSetDelta",
                "MPU9250_ReadGyroData"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f28",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "calculateAttitude_08002f28"
        },
        "FUN_08004384": {
            "renaming": {
                "FUN_08004384": "send_data_frame_08004384",
                "PTR_msp_txf_status_080043b8": "msp_txf_status_ptr",
                "local_14": "frame_data",
                "uStack_10": "frame_length",
                "local_c": "frame_header"
            },
            "code": "void send_data_frame_08004384(void)\n{\n  uint16_t data = 0;\n  uint8_t *PTR_msp_txf_status_080043b8 = PTR_msp_txf_status_080043b8;\n  PTR_msp_txf_status_080043b8[4] = 7;\n  PTR_msp_txf_status_080043b8[5] = 0;\n  PTR_msp_txf_status_080043b8[6] = 0x2a;\n  PTR_msp_txf_status_080043b8[7] = 0;\n  uint32_t local_14 = *(uint32_t *)PTR_msp_txf_status_080043b8;\n  uint32_t uStack_10 = *(uint32_t *)(PTR_msp_txf_status_080043b8 + 4);\n  PTR_msp_txf_status_080043b8[8] = 0;\n  PTR_msp_txf_status_080043b8[9] = 0;\n  PTR_msp_txf_status_080043b8[10] = 0;\n  uint32_t local_c = (in_r3 & 0xff000000) | (uint32_t)*(uint16_t *)(PTR_msp_txf_status_080043b8 + 8);\n  MSP_SendFrame('e', (uint8_t *)&local_14, 0xb);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004384",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_data_frame_08004384"
        },
        "FUN_080009a0": {
            "renaming": {
                "FUN_080009a0": "check_if_not_null_080009a0",
                "in_ZR": "input"
            },
            "code": "bool check_if_not_null_080009a0(char input) {\n    __aeabi_cdcmpeq();\n    return input != '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009a0",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "check_if_not_null_080009a0"
        },
        "FUN_08003298": {
            "renaming": {
                "FUN_08003298": "read_MS5611_coefficients_and_initialize_alt_filter_08003298",
                "rxbuf": "rx_buffer",
                "iVar3": "i",
                "PTR_MS5611_Coefficients_0800330c": "MS5611_coefficients",
                "PTR_s____Src_MS5611_c_08003308": "s____Src_MS5611_c",
                "PTR_MS5611_OSR_08003304": "MS5611_OSR",
                "puVar1": "coefficient_ptr",
                "puVar2": "alt_filter_ptr",
                "PTR_alt_filter_08003310": "alt_filter"
            },
            "code": "void read_MS5611_coefficients_and_initialize_alt_filter_08003298(void)\n{\n  uint8_t rx_buffer[2];\n  int i = 0;\n  I2C_WriteByte(0xee, 0x1e, '\\x01', '\\x01');\n  delay_ms(10);\n  uint16_t* coefficient_ptr = PTR_MS5611_Coefficients_0800330c;\n  uint8_t* file_ptr = PTR_s____Src_MS5611_c_08003308;\n  *PTR_MS5611_OSR_08003304 = 8;\n  while (i != 0x10)\n  {\n    rx_buffer[0] = '\\0';\n    rx_buffer[1] = '\\0';\n    I2C_ReadByteArray(0xee, (short)i + 0xa0, rx_buffer, 2, file_ptr, 0x7c);\n    *(coefficient_ptr + i) = CONCAT11(rx_buffer[0], rx_buffer[1]);\n    i += 2;\n  }\n  i = 0;\n  uint32_t* PTR_alt_filter_08003310_ptr = PTR_alt_filter_08003310;\n  while (i != 0x14)\n  {\n    *(PTR_alt_filter_08003310_ptr + i) = 0;\n    i++;\n  }\n}\n",
            "called": [
                "I2C_ReadByteArray",
                "delay_ms",
                "I2C_WriteByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003298",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "read_MS5611_coefficients_and_initialize_alt_filter_08003298"
        },
        "FUN_08004028": {
            "renaming": {
                "FUN_08004028": "initialize_peripherals_and_start_LED_sequence_08004028",
                "Peripherals_Init": "initialize_peripherals",
                "PWM_Init": "initialize_PWM",
                "LED_StartupSequence": "start_LED_sequence"
            },
            "code": "void initialize_peripherals_and_start_LED_sequence_08004028(void)\n{\n  initialize_peripherals();\n  initialize_PWM();\n  start_LED_sequence();\n  return;\n}",
            "called": [
                "LED_StartupSequence",
                "PWM_Init",
                "Peripherals_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004028",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initialize_peripherals_and_start_LED_sequence_08004028"
        },
        "FUN_0800708c": {
            "renaming": {
                "FUN_0800708c": "calculate_something_0800708c",
                "__x": "input_parameter",
                "in_d0": "result"
            },
            "code": "double calculate_something_0800708c(double input_parameter)\n{\n  double result = 0.0;\n  //perform some calculations using input_parameter and store the result in the variable 'result'\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800708c",
            "calling": [
                "asin",
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_something_0800708c"
        },
        "FUN_08002520": {
            "renaming": {
                "FUN_08002520": "updateChannelState_08002520",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState",
                "CCER": "channelControlRegister"
            },
            "code": "void updateChannelState_08002520(TIM_TypeDef *timer, uint32_t channel, uint32_t channelState) {\n  uint32_t channelMask = 1 << (channel & 0xff);\n  timer->CCER = (timer->CCER & ~channelMask) | (channelState << (channel & 0xff));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002520",
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "updateChannelState_08002520"
        },
        "FUN_08000464": {
            "renaming": {
                "FUN_08000464": "calculate_08000464",
                "param_1": "num1",
                "param_2": "num2",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar6": "temp5",
                "iVar5": "leadingZeroes",
                "iVar7": "count",
                "bVar1": "bit1",
                "bVar9": "carry1",
                "bVar10": "carry2",
                "bVar11": "carry3"
            },
            "code": "ulonglong calculate_08000464(uint num1, uint num2)\n{\n    byte bit1;\n    uint temp1;\n    uint temp2;\n    uint temp3;\n    int count = 0x432;\n    bool carry1;\n    bool carry2;\n    bool carry3;\n\n    if ((num1 | num2) == 0)\n    {\n        return CONCAT44(num2, num1);\n    }\n\n    uint temp4 = num2 >> 0x16;\n    if (temp4 != 0)\n    {\n        count = 3;\n        if (num2 >> 0x19 != 0)\n        {\n            count = 6;\n        }\n        if (num2 >> 0x1c != 0)\n        {\n            count += 3;\n        }\n        temp3 = count - ((int)num2 >> 0x1f);\n        temp4 = num1 << (0x20 - temp3 & 0xff);\n        num1 = num1 >> (temp3 & 0xff) | num2 << (0x20 - temp3 & 0xff);\n        num2 = num2 >> (temp3 & 0xff);\n        count = temp3 + 0x432;\n    }\n\n    if (0xfffff < num2)\n    {\n        if (0x1fffff < num2)\n        {\n            temp3 = num2 & 1;\n            num2 = num2 >> 1;\n            bit1 = (byte)num1;\n            num1 = (uint)(temp3 != 0) << 0x1f | num1 >> 1;\n            temp4 = (uint)(bit1 & 1) << 0x1f | temp4 >> 1;\n            count++;\n            if (0xffbfffff < (uint)(count * 0x200000))\n            {\n                return 0x7ff0000000000000;\n            }\n        }\n    LABEL_08000278:\n        carry2 = 0x7fffffff < temp4;\n        if (temp4 == 0x80000000)\n        {\n            carry2 = (num1 & 1) != 0;\n        }\n        return CONCAT44(num2 + count * 0x100000 + (uint)CARRY4(num1, (uint)carry2), num1 + carry2);\n    }\n\n    carry1 = (temp4 & 0x80000000) != 0;\n    temp4 = temp4 << 1;\n    temp3 = num1 * 2;\n    carry2 = CARRY4(num1, num1);\n    num1 = num1 * 2 + (uint)carry1;\n    num2 = num2 * 2 + (uint)(carry2 || CARRY4(temp3, (uint)carry1));\n    count--;\n    if ((num2 & 0x100000) != 0)\n    {\n        goto LABEL_08000278;\n    }\n\n    temp1 = num1;\n    temp3 = num2;\n    if (num2 == 0)\n    {\n        temp1 = 0;\n        temp3 = num1;\n    }\n\n    int leadingZeroes = count_leading_zeroes(temp3);\n    if (num2 == 0)\n    {\n        leadingZeroes += 0x20;\n    }\n    temp2 = leadingZeroes - 0xb;\n    carry3 = SBORROW4(temp2, 0x20);\n    uint temp5 = leadingZeroes - 0x2b;\n    carry2 = (int)temp5 < 0;\n    carry1 = temp5 == 0;\n    if ((int)temp2 < 0x20)\n    {\n        carry3 = SCARRY4(temp5, 0xc);\n        leadingZeroes -= 0x1f;\n        carry2 = leadingZeroes < 0;\n        carry1 = leadingZeroes == 0;\n        temp2 = temp2;\n        if (!carry1 && carry2 == carry3)\n        {\n            temp4 = temp3 << (temp2 & 0xff);\n            temp3 = temp3 >> (0xcU - leadingZeroes & 0xff);\n            goto LABEL_080002f0;\n        }\n    }\n    if (carry1 || carry2 != carry3)\n    {\n        temp5 = 0x20 - temp2;\n    }\n    temp3 = temp3 << (temp2 & 0xff);\n    if (carry1 || carry2 != carry3)\n    {\n        temp3 |= temp1 >> (temp5 & 0xff);\n    }\n    if (carry1 || carry2 != carry3)\n    {\n        temp1 = temp1 << (temp2 & 0xff);\n    }\nLABEL_080002f0:\n    if ((int)temp2 <= count)\n    {\n        return CONCAT44(temp3 + (count - temp2) * 0x100000, temp1);\n    }\n    temp4 = ~(count - temp2);\n    if (0x1e < (int)temp4)\n    {\n        return (ulonglong)(temp3 >> (temp4 - 0x1f & 0xff));\n    }\n    int temp6 = temp4 - 0x13;\n    if (temp6 == 0 || temp6 < 0 != SCARRY4(temp4 - 0x1f, 0xc))\n    {\n        temp4++;\n        return CONCAT44(temp3 >> (temp4 & 0xff), temp1 >> (temp4 & 0xff) | temp3 << (0x20 - temp4 & 0xff));\n    }\n    return (ulonglong)(temp1 >> (0x20 - (0xcU - temp6) & 0xff) | temp3 << (0xcU - temp6 & 0xff));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000464",
            "calling": [],
            "imported": false,
            "current_name": "calculate_08000464"
        },
        "FUN_08002404": {
            "renaming": {
                "FUN_08002404": "configure_timer_08002404",
                "TIMx": "timer",
                "OC_Config": "output_config",
                "uVar1": "cc_enable_value",
                "uVar2": "cr2_value",
                "uVar3": "output_mode",
                "DAT_08002458": "PTR_08002458",
                "CCER": "cc_enable_mask",
                "OCMode": "output_mode",
                "OCPolarity": "output_polarity",
                "OCNPolarity": "output_n_polarity",
                "CR2": "cr2_value",
                "CCMR1": "cc_match_register_1",
                "Pulse": "output_pulse",
                "OCIdleState": "output_idle_state",
                "OCNIdleState": "output_n_idle_state"
            },
            "code": "void configure_timer_08002404(TIM_TypeDef *timer, TIM_OC_InitTypeDef *output_config)\n{\n    uint32_t cc_enable_mask = 0xffffffef;\n    uint32_t cr2_value = timer->CR2;\n    uint32_t output_mode = output_config->OCMode;\n    uint32_t cc_enable_value = (timer->CCER & 0xffffffdf) | (output_config->OCPolarity << 4);\n\n    if (timer == DAT_08002458) {\n        cc_enable_value = (cc_enable_value & 0xffffff7f) | (output_config->OCNPolarity << 4);\n        cr2_value = (cr2_value & 0xfffff3ff) | ((output_config->OCIdleState | output_config->OCNIdleState) << 2);\n    }\n\n    timer->CR2 = cr2_value;\n    timer->CCMR1 = (timer->CCMR1 & 0xffff8cff) | (output_mode << 8);\n    timer->CCR2 = output_config->Pulse;\n    timer->CCER = cc_enable_value;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002404",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08002404"
        },
        "FUN_08005bc8": {
            "renaming": {
                "FUN_08005bc8": "calculate_result_08005bc8",
                "__x": "input",
                "cVar1": "version_info",
                "iVar2": "comparison_result",
                "piVar3": "errno_ptr",
                "puVar4": "error_flag_ptr",
                "dVar5": "result",
                "extraout_d0": "matherr_result",
                "extraout_d0_00": "zero_division_result",
                "extraout_d0_01": "matherr_result",
                "extraout_d0_02": "zero_division_result",
                "extraout_d0_03": "zero_division_result",
                "local_50": "error_info",
                "local_38": "error_info._8_8_",
                "local_30": "unord_result",
                "PTR___fdlib_version_08005c68": "PTR___fdlib_version_08005c68",
                "PTR_DAT_08005c6c": "PTR_DAT_08005c6c",
                "__unorddf2": "__unorddf2",
                "__aeabi_dcmplt": "__aeabi_dcmplt",
                "__divdf3": "__divdf3",
                "matherr": "matherr",
                "exception": "exception",
                "__errno": "__errno"
            },
            "code": "double calculate_result_08005bc8(double input)\n{\n    char version_info;\n    int comparison_result;\n    int *errno_ptr;\n    undefined4 *error_flag_ptr;\n    double result;\n    double matherr_result;\n    double zero_division_result;\n    double unord_result;\n    undefined error_info [24];\n\n    result = (double) __ieee754_calculate_result_08005bc8();\n    version_info = *PTR___fdlib_version_08005c68;\n\n    if (version_info == -1)\n    {\n        return result;\n    }\n\n    unord_result = __unorddf2();\n    if (unord_result != 0)\n    {\n        return zero_division_result;\n    }\n\n    comparison_result = __aeabi_dcmplt();\n    if (comparison_result == 0)\n    {\n        return matherr_result;\n    }\n\n    error_info._0_4_ = 1;\n    error_info._4_4_ = PTR_DAT_08005c6c;\n\n    if (version_info == '\\0')\n    {\n        error_info._8_8_ = 0.0;\n        goto LAB_08005c26;\n    }\n    else\n    {\n        error_info._8_8_ = (double) __divdf3(0, 0, 0, 0);\n        if (version_info != '\\x02')\n        {\n            goto LAB_08005c26;\n        }\n    }\n\n    error_flag_ptr = (undefined4 *)__errno();\n    *error_flag_ptr = 0x21;\n    result = zero_division_result;\n\nLAB_08005c26:\n    if (unord_result != 0)\n    {\n        errno_ptr = (int *)__errno();\n        *errno_ptr = unord_result;\n        result = zero_division_result;\n    }\n\n    return result;\n}",
            "called": [
                "__divdf3",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__ieee754_sqrt",
                "matherr",
                "__errno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bc8",
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_result_08005bc8"
        },
        "FUN_08001436": {
            "renaming": {
                "FUN_08001436": "check_I2C_error_08001436",
                "*hi2c": "*i2c_handle",
                "pIVar1": "i2c_instance",
                "SR1": "I2C_SR1_AF",
                "ErrorCode": "HAL_I2C_ERROR_AF",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef check_I2C_error_08001436(I2C_HandleTypeDef *i2c_handle)\n{\n  I2C_TypeDef *i2c_instance;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->SR1 & I2C_SR1_AF) != 0) {\n    i2c_instance->SR1 = i2c_instance->SR1 & ~I2C_SR1_AF;\n    i2c_handle->ErrorCode = HAL_I2C_ERROR_AF;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Lock = HAL_UNLOCKED;\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001436",
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "imported": false,
            "current_name": "check_I2C_error_08001436"
        },
        "FUN_08004a30": {
            "renaming": {
                "FUN_08004a30": "calculate_altitude_pid_08004a30",
                "PTR_joystick_08004a74": "joystick",
                "PTR_ALT_FLAG_08004a78": "alt_flag",
                "PTR_pid_altitude_08004a7c": "pid_altitude",
                "MS5611_GetFilteredAltitude": "get_filtered_altitude"
            },
            "code": "void calculate_altitude_pid_08004a30(void)\n{\n  float *PTR_joystick_08004a74 = PTR_PTR_joystick_08004a74_08004a74;\n  float *PTR_ALT_FLAG_08004a78 = PTR_ALT_FLAG_08004a78;\n  float *PTR_pid_altitude_08004a7c = PTR_PTR_pid_altitude_08004a7c_08004a7c;\n  if (PTR_joystick_08004a74[1] != 0)\n  {\n    if (*PTR_ALT_FLAG_08004a78 == 0)\n    {\n      float altitude = MS5611_GetFilteredAltitude();\n      float filtered_altitude = altitude * 0.01f;\n      PTR_pid_altitude_08004a7c[7] = filtered_altitude;\n      *PTR_ALT_FLAG_08004a78 = 1;\n    }\n    else\n    {\n      float altitude = MS5611_GetFilteredAltitude();\n      float filtered_altitude = altitude * 0.01f;\n      PTR_pid_altitude_08004a7c[12] = filtered_altitude;\n    }\n  }\n  if (PTR_joystick_08004a74[1] == 0)\n  {\n    if (*PTR_ALT_FLAG_08004a78 != 0)\n    {\n      *PTR_ALT_FLAG_08004a78 = 0;\n    }\n    PTR_pid_altitude_08004a7c[18] = PTR_joystick_08004a74[2];\n  }\n}",
            "called": [
                "__aeabi_fmul",
                "MS5611_GetFilteredAltitude"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a30",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_altitude_pid_08004a30"
        },
        "FUN_08004c70": {
            "renaming": {
                "FUN_08004c70": "receive_uart_interrupt_08004c70",
                "PTR_huart1_08004c88": "uart_handle",
                "PTR_rx_buffer_08004c84": "rx_buffer"
            },
            "code": "void receive_uart_interrupt_08004c70(UART_HandleTypeDef* PTR_huart1_08004c88, uint8_t* PTR_rx_buffer_08004c84, uint8_t buffer_size) {\n    serialFlush();\n    HAL_UART_Receive_IT(PTR_huart1_08004c88, PTR_rx_buffer_08004c84, buffer_size);\n    return;\n}",
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c70",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "receive_uart_interrupt_08004c70"
        },
        "FUN_08000904": {
            "renaming": {
                "FUN_08000904": "check_collision_08000904",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2",
                "uVar1": "xor_xy",
                "bVar2": "is_x1y1_zero",
                "bVar3": "is_y2_less_than_or_equal_to_y1"
            },
            "code": "uint check_collision_08000904(uint x1, uint y1, uint x2, uint y2)\n{\n  bool is_collision = false;\n  if (((int)(y1 << 1) >> 0x15 == -1 || (int)(y2 << 1) >> 0x15 == -1) && ((((int)(y1 << 1) >> 0x15 == -1 && ((x1 | y1 << 0xc) != 0)) || (((int)(y2 << 1) >> 0x15 == -1 && ((x2 | y2 << 0xc) != 0)))))) {\n    return 1;\n  }\n  bool is_x1y1_zero = (x1 | y1 << 1) == 0;\n  if (is_x1y1_zero) {\n    is_x1y1_zero = (x2 | y2 << 1) == 0;\n  }\n  if (!is_x1y1_zero) {\n    is_x1y1_zero = y1 == y2;\n  }\n  if (is_x1y1_zero) {\n    is_x1y1_zero = x1 == x2;\n  }\n  if (!is_x1y1_zero) {\n    uint xor_xy = y1 ^ y2;\n    is_x1y1_zero = xor_xy == 0;\n    if (-1 < (int)xor_xy) {\n      is_x1y1_zero = y1 == y2;\n    }\n    bool is_y2_less_than_or_equal_to_y1 = -1 < (int)xor_xy && y2 <= y1;\n    if (is_x1y1_zero) {\n      is_y2_less_than_or_equal_to_y1 = x2 <= x1;\n    }\n    y2 = (int)y2 >> 0x1f;\n    if (!is_y2_less_than_or_equal_to_y1) {\n      y2 = ~y2;\n    }\n    return y2 | 1;\n  }\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000904",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "check_collision_08000904"
        },
        "FUN_0800299a": {
            "renaming": {
                "FUN_0800299a": "receiveUARTData_0800299a",
                "huart": "UART_HandleTypeDef",
                "uVar1": "controlReg",
                "uVar2": "transferCompleteFlag",
                "uVar3": "statusReg",
                "puVar4": "pTxBuffPtr",
                "HVar5": "huartState",
                "pUVar6": "usartInstance",
                "uVar7": "errorFlags",
                "uVar8": "transferCompleteFlag",
                "bVar9": "hasError"
            },
            "code": "void receiveUARTData_0800299a(UART_HandleTypeDef *huart) {\n  uint32_t statusReg;\n  uint32_t controlReg;\n  uint32_t errorFlags;\n  uint32_t transferCompleteFlag;\n  USART_TypeDef *usartInstance;\n\n  usartInstance = huart->Instance;\n  statusReg = usartInstance->SR;\n  controlReg = usartInstance->CR1;\n\n  if ((statusReg & USART_SR_RXNE) == 0) {\n    if (((statusReg & USART_SR_TC) == 0) && ((controlReg & USART_CR1_TCIE) == 0)) {\n      HAL_UART_Receive_IT(huart, huart->pRxBuffPtr, 1);\n    }\n  }\n  else {\n    errorFlags = statusReg & (USART_SR_NE | USART_SR_FE | USART_SR_ORE | USART_SR_PE);\n    if (errorFlags != 0) {\n      huart->ErrorCode |= errorFlags;\n      __HAL_UART_CLEAR_FLAG(huart, errorFlags);\n      if (((statusReg & USART_SR_RXNE) != 0) && ((controlReg & USART_CR1_RXNEIE) != 0)) {\n        HAL_UART_RxCpltCallback(huart);\n      }\n      return;\n    }\n\n    if (((statusReg & USART_SR_TXE) != 0) && ((controlReg & USART_CR1_TXEIE) != 0)) {\n      transferCompleteFlag = 0;\n      if (huart->TxXferCount > 0) {\n        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE)) {\n          usartInstance->DR = (uint16_t)(*huart->pTxBuffPtr & (uint16_t)0x01FF);\n          huart->pTxBuffPtr++;\n        }\n        else {\n          usartInstance->DR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);\n          huart->pTxBuffPtr++;\n        }\n        huart->TxXferCount--;\n        if (huart->TxXferCount == 0) {\n          transferCompleteFlag = USART_CR1_TCIE;\n        }\n      }\n      if (transferCompleteFlag != 0) {\n        __HAL_UART_DISABLE_IT(huart, USART_CR1_TXEIE);\n        __HAL_UART_ENABLE_IT(huart, transferCompleteFlag);\n      }\n    }\n  }\n}\n",
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800299a",
            "calling": [
                "USART1_IRQHandler"
            ],
            "imported": false,
            "current_name": "receiveUARTData_0800299a"
        },
        "FUN_080052e4": {
            "renaming": {
                "FUN_080052e4": "decode_080052e4",
                "param_1": "data",
                "param_2": "out_size",
                "param_3": "out_data_size",
                "param_4": "unk",
                "param_5": "callback",
                "iVar1": "i",
                "uVar2": "max_size",
                "uVar3": "type",
                "bVar4": "is_data_size",
                "*param_3": "*out_data_size",
                "*param_2": "*out_size",
                "(int)param_2 + 0x43": "(int)out_size + 0x43",
                "(int)param_2 + 0x19": "(int)out_size + 0x19",
                "(int)param_2 + uVar2 + 0x43": "(int)out_size + is_data_size + 0x43",
                "(int)param_2 + uVar2 + 0x44": "(int)out_size + is_data_size + 0x44",
                "(int)param_2 + 0x45": "(int)out_size + 0x45",
                "(int)param_2 + 0x1a": "(int)out_size + 0x1a"
            },
            "code": "undefined4 decode_080052e4(uint32_t data, uint32_t* out_size, uint32_t* out_data_size, uint32_t unk, code* callback) {\n    int i;\n    uint32_t max_size = (data >> 0x1a) < 0 ? out_size[2] : out_size[4];\n    *out_data_size = max_size;\n    if (*(char*)((int)out_size + 0x43) != 0) {\n        *out_data_size = max_size + 1;\n    }\n    if ((int)(data << 0x1a) < 0) {\n        *out_data_size = *out_data_size + 2;\n    }\n    uint32_t type = data & 6;\n    if (type == 0) {\n        for (i = 0; i < (int)(out_size[3] - *out_data_size); i++) {\n            int ret = (*callback)(data, unk, (int)out_size + 0x19, 1);\n            if (ret == -1) {\n                return 0xffffffff;\n            }\n        }\n    }\n    uint32_t is_data_size = (uint32_t)*(byte*)((int)out_size + 0x43);\n    if (is_data_size != 0) {\n        is_data_size = 1;\n    }\n    uint32_t current_size = is_data_size;\n    if ((int)(data << 0x1a) < 0) {\n        *(undefined*)((int)out_size + is_data_size + 0x43) = 0x30;\n        current_size += 2;\n        *(undefined*)((int)out_size + is_data_size + 0x44) = *(undefined*)((int)out_size + 0x45);\n    }\n    int ret = (*callback)(data, unk, (int)out_size + 0x43, current_size);\n    if (ret != -1) {\n        uint32_t size = out_size[3];\n        bool is_type_4 = (data & 6) != 4;\n        if (is_type_4) {\n            size = 0;\n        }\n        uint32_t remaining_size = 0;\n        if (!is_type_4) {\n            size = size - *out_data_size;\n        }\n        if (!is_type_4) {\n            size = size & ~((int)size >> 0x1f);\n        }\n        if (out_size[4] < out_size[2]) {\n            size = size + (out_size[2] - out_size[4]);\n        }\n        while (true) {\n            if (size == remaining_size) {\n                return 0;\n            }\n            ret = (*callback)(data, unk, (int)out_size + 0x1a, 1);\n            if (ret == -1) {\n                break;\n            }\n            remaining_size++;\n        }\n    }\n    return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052e4",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "decode_080052e4"
        },
        "FUN_08000f94": {
            "renaming": {
                "FUN_08000f94": "calculate_result_08000f94",
                "param_1": "x",
                "param_2": "y",
                "uVar2": "double_x",
                "uVar3": "double_y",
                "uVar4": "x_and_y",
                "bVar1": "is_x_greater_than_y",
                "bVar5": "is_zero",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint calculate_result_08000f94(uint x, uint y)\n{\n  bool is_negative_x = ((int)x >> 0x18 == -1);\n  bool is_negative_y = ((int)y >> 0x18 == -1);\n  uint double_x = x * 2;\n  uint double_y = y * 2;\n  if ((is_negative_x || is_negative_y) && ((is_negative_x && ((x & 0x7fffff) != 0)) || (is_negative_y && ((y & 0x7fffff) != 0)))) {\n    return 1;\n  }\n  uint x_and_y = double_x | y & 0x7fffffff;\n  bool is_zero = (x_and_y == 0);\n  if (!is_zero) {\n    x_and_y = x ^ y;\n    is_zero = (x_and_y == 0);\n  }\n  bool is_x_greater_than_y = (-1 < (int)x_and_y);\n  if (is_x_greater_than_y) {\n    x = double_x + y * -2;\n    is_zero = (x == 0);\n  }\n  if (is_x_greater_than_y && double_y <= double_x && !is_zero) {\n    x = (int)y >> 0x1f;\n  }\n  if (!is_x_greater_than_y || double_y > double_x) {\n    x = ~((int)y >> 0x1f);\n  }\n  if (!is_zero) {\n    x = x | 1;\n  }\n  return x;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f94",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08000f94"
        },
        "FUN_080014e2": {
            "renaming": {
                "FUN_080014e2": "check_i2c_acknowledge_080014e2",
                "*hi2c": "*i2c_handle",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time"
            },
            "code": "HAL_StatusTypeDef check_i2c_acknowledge_080014e2(I2C_HandleTypeDef *i2c_handle, uint32_t timeout)\n{\n    HAL_StatusTypeDef status;\n    uint32_t start_time = HAL_GetTick();\n    while(1) {\n        if ((int)(i2c_handle->Instance->SR1 << 0x18) < 0) {\n            return HAL_OK;\n        }\n        status = I2C_IsAcknowledgeFailed(i2c_handle);\n        if (status != HAL_OK) {\n            break;\n        }\n        if ((timeout != 0xffffffff) && (timeout == 0 || (HAL_GetTick() - start_time > timeout))) {\n            i2c_handle->ErrorCode |= 0x20;\n            i2c_handle->State = HAL_I2C_STATE_READY;\n            i2c_handle->Lock = HAL_UNLOCKED;\n            return HAL_TIMEOUT;\n        }\n    }\n    return HAL_ERROR;\n}",
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080014e2",
            "calling": [
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "imported": false,
            "current_name": "check_i2c_acknowledge_080014e2"
        },
        "FUN_0800142e": {
            "renaming": {
                "FUN_0800142e": "toggle_gpio_output_state_0800142e",
                "GPIOx": "gpio_register",
                "GPIO_Pin": "gpio_pin",
                "ODR": "output_data_register"
            },
            "code": "void toggle_gpio_output_state_0800142e(GPIO_TypeDef *gpio_register, uint16_t gpio_pin) {\n    gpio_register->ODR = (uint)gpio_pin ^ gpio_register->ODR;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800142e",
            "calling": [
                "_Error_Handler"
            ],
            "imported": false,
            "current_name": "toggle_gpio_output_state_0800142e"
        },
        "FUN_08004d8c": {
            "renaming": {
                "FUN_08004d8c": "set_PWM_TIM_flags_08004d8c",
                "htim_pwm": "htim_pwm",
                "pTVar1": "tim_instance",
                "tmpreg": "tmpreg",
                "tmpreg_1": "tim_flag",
                "tmpreg_2": "tmpreg_2",
                "tmpreg_3": "tmpreg_3",
                "DAT_08004e04": "PTR_TIM6",
                "uint": "uint32_t",
                "DAT_08004e08": "DAT_TIM6_BASE",
                "_DAT_4002101c": "_DAT_4002101c",
                "DAT_08004e0c": "PTR_TIM3",
                "DAT_08004e10": "PTR_TIM4",
                "PTR_40000000": "PTR_TIM2"
            },
            "code": "void set_PWM_TIM_flags_08004d8c(TIM_HandleTypeDef *htim_pwm)\n{\n  TIM_TypeDef *tim_instance;\n  uint32_t tim_flag;\n  uint32_t *tim_reg;\n  tim_instance = htim_pwm->Instance;\n  if (tim_instance == DAT_08004e04)\n  {\n    tim_reg = (uint32_t *)(DAT_08004e08 + 0x18);\n    tim_flag = TIM_FLAG_UPDATE;\n  }\n  else if (tim_instance == DAT_08004e0c)\n  {\n    tim_reg = (uint32_t *)(DAT_TIM3_BASE + 0x1C);\n    tim_flag = TIM_FLAG_CC1;\n  }\n  else if (tim_instance == PTR_40000000)\n  {\n    tim_reg = (uint32_t *)(DAT_TIM2_BASE + 0x1C);\n    tim_flag = TIM_FLAG_CC2;\n  }\n  else if (tim_instance == DAT_08004e10)\n  {\n    tim_reg = (uint32_t *)(DAT_TIM4_BASE + 0x1C);\n    tim_flag = TIM_FLAG_CC3;\n  }\n  else\n  {\n    return;\n  }\n  *tim_reg |= tim_flag;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d8c",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "set_PWM_TIM_flags_08004d8c"
        },
        "FUN_080009b4": {
            "renaming": {
                "FUN_080009b4": "isEndOfString_080009b4",
                "in_CY": "currentChar"
            },
            "code": "bool isEndOfString_080009b4(void)\n{\n  char currentChar;\n  __aeabi_cdcmpeq();\n  return currentChar == '\\0';\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009b4",
            "calling": [
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "isEndOfString_080009b4"
        },
        "FUN_08003068": {
            "renaming": {
                "FUN_08003068": "get_input_value_08003068",
                "in_s0": "input_value"
            },
            "code": "float get_input_value_08003068(void)\n{\n  float input_value;\n  return input_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003068",
            "calling": [
                "PID_UpdateAltitude"
            ],
            "imported": false,
            "current_name": "get_input_value_08003068"
        },
        "FUN_08000f8c": {
            "renaming": {
                "FUN_08000f8c": "calculate_result_08000f8c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "result1",
                "uVar3": "result2",
                "uVar4": "combined_result",
                "bVar1": "is_negative1",
                "bVar5": "is_zero"
            },
            "code": "uint calculate_result_08000f8c(uint input1, uint input2)\n{\n  bool is_negative1;\n  uint result1;\n  uint result2;\n  uint combined_result;\n  bool is_zero;\n  \n  result1 = input1 * 2;\n  result2 = input2 * 2;\n  \n  if (((int)result1 >> 0x18 == -1 || (int)result2 >> 0x18 == -1) && ((((int)result1 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) || (((int)result2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_result = result1 | input2 & 0x7fffffff;\n  is_zero = combined_result == 0;\n  if (!is_zero) {\n    combined_result = input1 ^ input2;\n    is_zero = combined_result == 0;\n  }\n  is_negative1 = -1 < (int)combined_result;\n  if (is_negative1) {\n    input1 = result1 + input2 * -2;\n    is_zero = input1 == 0;\n  }\n  if ((is_negative1 && result2 <= result1) && !is_zero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!is_negative1 || result2 > result1) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f8c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08000f8c"
        },
        "FUN_08000474": {
            "renaming": {
                "FUN_08000474": "performUnsignedDivision_08000474",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "carry",
                "uVar2": "quotient",
                "uVar3": "remainder",
                "uVar4": "temp",
                "iVar5": "shift",
                "uVar6": "carry",
                "iVar7": "loop_counter",
                "uVar8": "is_divisor_negative",
                "uVar9": "abs_divisor",
                "bVar10": "is_quotient_negative",
                "bVar11": "is_overflow",
                "bVar12": "temp_bool"
            },
            "code": "ulonglong performUnsignedDivision_08000474(uint dividend, uint divisor)\n{\n  byte carry = 0;\n  uint quotient = 0;\n  uint remainder = 0;\n  int shift = 0;\n  bool is_divisor_negative = false;\n  bool is_quotient_negative = false;\n  bool is_overflow = false;\n\n  if ((dividend | divisor) == 0) {\n    return CONCAT44(divisor, dividend);\n  }\n\n  is_divisor_negative = (divisor & 0x80000000) != 0;\n  uint abs_divisor = is_divisor_negative ? -divisor : divisor;\n  uint abs_dividend = dividend;\n  if (is_divisor_negative) {\n    is_quotient_negative = (dividend != 0);\n    abs_dividend = is_quotient_negative ? -dividend : dividend;\n    remainder = -abs_divisor - is_quotient_negative;\n  }\n\n  if (abs_dividend >= abs_divisor << 16) {\n    shift = 16;\n    if (abs_dividend >= abs_divisor << 19) {\n      shift = 19;\n      if (abs_dividend >= abs_divisor << 22) {\n        shift = 22;\n        remainder = abs_dividend >> (shift - 32);\n        abs_dividend <<= shift;\n      }\n      else {\n        abs_dividend <<= shift;\n        remainder = abs_dividend >> 31;\n      }\n    }\n    else {\n      abs_dividend <<= shift;\n      remainder = abs_dividend >> 31;\n    }\n  }\n\n  for (int i = 0; i < 27; i++) {\n    remainder <<= 1;\n    quotient <<= 1;\n    carry = (byte)(abs_dividend >> 31);\n    abs_dividend <<= 1;\n    remainder |= carry;\n    quotient |= carry ^ 1;\n    if (abs_divisor <= remainder) {\n      remainder -= abs_divisor;\n      quotient |= 1;\n    }\n  }\n\n  is_overflow = (quotient & 0x80000000) != 0;\n  if (is_overflow || quotient > 0x7fffffff) {\n    return (ulonglong)(is_divisor_negative ? 0xfff0000000000000 : 0x7ff0000000000000);\n  }\n\n  is_quotient_negative = (quotient == 0x80000000);\n  return CONCAT44(remainder + quotient * 0x100000 + (uint)(abs_dividend >> 31) + (uint)is_quotient_negative * 0x80000000 + (uint)is_divisor_negative * 0x80000000, quotient + is_quotient_negative);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000474",
            "calling": [],
            "imported": false,
            "current_name": "performUnsignedDivision_08000474"
        },
        "FUN_08000110": {
            "renaming": {
                "FUN_08000110": "has_completed_init_08000110",
                "param_1": "init_ptr",
                "PTR_completed_8672_08000128": "has_completed_ptr",
                "DAT_0800012c": "NULL",
                "PTR__init_08000130": "init_ptr"
            },
            "code": "bool has_completed_init_08000110(bool* PTR_completed_8672_08000128, void* PTR__init_08000130) {\n  if (*PTR_completed_8672_08000128 == false) {\n    if (PTR__init_08000130 != DAT_0800012c) {\n      PTR__init_08000130 = PTR__init_08000130;\n    }\n    *PTR_completed_8672_08000128 = true;\n  }\n  return PTR__init_08000130;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000110",
            "calling": [],
            "imported": false,
            "current_name": "has_completed_init_08000110"
        },
        "FUN_0800709e": {
            "renaming": {
                "FUN_0800709e": "handle_exception_0800709e",
                "__exc": "__exception_ptr"
            },
            "code": "int handle_exception_0800709e(exception *__exception_ptr)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800709e",
            "calling": [
                "asin",
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "handle_exception_0800709e"
        },
        "FUN_08002ec0": {
            "renaming": {
                "FUN_08002ec0": "calculateFilteredPitch_08002ec0",
                "in_s0": "input_pitch",
                "fVar1": "filtered_pitch"
            },
            "code": "float calculateFilteredPitch_08002ec0(void)\n{\n  float input_pitch;\n  float filtered_pitch;\n  filtered_pitch = lowPassFilter((LPF *)PTR_lpf_pitch_08002ed0, input_pitch);\n  return filtered_pitch;\n}",
            "called": [
                "lowPassFilter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec0",
            "calling": [
                "AHRS_ComputeAngles",
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculateFilteredPitch_08002ec0"
        },
        "FUN_08006c0c": {
            "renaming": {
                "FUN_08006c0c": "calculate_multiplication_and_addition_08006c0c",
                "param_1": "multiplicand",
                "param_2": "multiplier",
                "uVar1": "quotient_high_bits",
                "uVar2": "shifted_mantissa",
                "iVar3": "exponent_difference",
                "iVar7": "quotient_high_bits",
                "uVar4": "quotient_mantissa",
                "uVar5": "quotient_low_bits",
                "uVar6": "shifted_multiplier",
                "uVar8": "quotient_exponent",
                "uVar9": "sum",
                "iVar10": "remainder",
                "uVar11": "quotient_mantissa",
                "uVar12": "quotient_exponent",
                "uVar13": "result"
            },
            "code": "undefined8 calculate_multiplication_and_addition_08006c0c(uint multiplicand, uint multiplier)\n{\n  undefined4 quotient_high_bits;\n  uint quotient_low_bits;\n  int exponent_difference;\n  uint shifted_multiplier;\n  uint shifted_mantissa;\n  uint sum;\n  uint quotient_mantissa;\n  uint quotient_exponent;\n  uint remainder;\n  undefined8 result;\n  \n  if ((0x08006d60 & ~multiplier) == 0) {\n    result = __muldf3(multiplicand, multiplier, multiplicand, multiplier);\n    result = __aeabi_dadd(multiplicand, multiplier, (int)result, (int)((ulonglong)result >> 0x20));\n    return result;\n  }\n  if ((int)multiplier < 1) {\n    if ((multiplier & 0x7fffffff | multiplicand) == 0) {\n      return CONCAT44(multiplier, multiplicand);\n    }\n    if (multiplier != 0) {\n      result = __subdf3(multiplicand, multiplier, multiplicand, multiplier);\n      quotient_high_bits = (undefined4)((ulonglong)result >> 0x20);\n      result = __divdf3((int)result, quotient_high_bits, (int)result, quotient_high_bits);\n      return result;\n    }\n  }\n  exponent_difference = (int)multiplier >> 0x14;\n  if (exponent_difference == 0) {\n    while (multiplier == 0) {\n      exponent_difference = exponent_difference + -0x15;\n      multiplier = multiplicand >> 0xb;\n      multiplicand = multiplicand << 0x15;\n    }\n    shifted_mantissa = 0;\n    for (; -1 < (int)(multiplier << 0xb); multiplier = multiplier << 1) {\n      shifted_mantissa = shifted_mantissa + 1;\n    }\n    exponent_difference = exponent_difference - (shifted_mantissa - 1);\n    shifted_multiplier = multiplier | multiplicand >> (0x20 - shifted_mantissa & 0xff);\n    multiplicand = multiplicand << (shifted_mantissa & 0xff);\n  }\n  quotient_high_bits = 0;\n  shifted_mantissa = shifted_multiplier & 0xfffff | 0x100000;\n  if ((exponent_difference + -0x3ff) * -0x80000000 < 0) {\n    shifted_mantissa = shifted_mantissa * 2 - ((int)multiplicand >> 0x1f);\n    multiplicand = multiplicand << 1;\n  }\n  shifted_mantissa = shifted_mantissa * 2 - ((int)multiplicand >> 0x1f);\n  quotient_mantissa = 0x16;\n  quotient_low_bits = 0;\n  quotient_exponent = 0x200000;\n  multiplicand = multiplicand << 1;\n  do {\n    remainder = quotient_low_bits + quotient_exponent;\n    if (remainder <= (int)shifted_mantissa) {\n      shifted_mantissa = shifted_mantissa - remainder;\n      quotient_low_bits = remainder + quotient_exponent;\n      quotient_high_bits = quotient_high_bits + quotient_exponent;\n    }\n    quotient_mantissa = quotient_mantissa - 1;\n    shifted_mantissa = shifted_mantissa * 2 - ((int)multiplicand >> 0x1f);\n    quotient_exponent = quotient_exponent >> 1;\n    multiplicand = multiplicand << 1;\n  } while (quotient_mantissa != 0);\n  quotient_exponent = 0x20;\n  sum = 0x80000000;\n  quotient_low_bits = quotient_mantissa;\n  do {\n    quotient_mantissa = sum + quotient_low_bits;\n    shifted_multiplier = quotient_high_bits;\n    if (((int)quotient_high_bits < (int)shifted_mantissa) || ((shifted_mantissa == quotient_high_bits && (quotient_mantissa <= multiplicand)))) {\n      quotient_low_bits = quotient_mantissa + sum;\n      if (((int)quotient_mantissa < 0) && (-1 < (int)quotient_low_bits)) {\n        shifted_multiplier = quotient_high_bits + 1;\n      }\n      shifted_mantissa = shifted_mantissa - quotient_mantissa;\n      if (multiplicand < quotient_low_bits) {\n        shifted_mantissa = shifted_mantissa - 1;\n      }\n      multiplicand = multiplicand - quotient_low_bits;\n      quotient_exponent = quotient_exponent + sum;\n    }\n    shifted_mantissa = shifted_mantissa * 2 - ((int)multiplicand >> 0x1f);\n    quotient_exponent = quotient_exponent - 1;\n    multiplicand = multiplicand << 1;\n    sum = sum >> 1;\n    quotient_high_bits = shifted_multiplier;\n  } while (quotient_exponent != 0);\n  if ((multiplicand | shifted_mantissa) != 0) {\n    if (quotient_low_bits == 0xffffffff) {\n      exponent_difference = exponent_difference + 1;\n      quotient_low_bits = quotient_exponent;\n    }\n    else {\n      quotient_low_bits = quotient_low_bits + 1 & 0xfffffffe;\n    }\n  }\n  quotient_low_bits = quotient_low_bits >> 1;\n  if (quotient_high_bits << 0x1f < 0) {\n    quotient_low_bits = quotient_low_bits | 0x80000000;\n  }\n  return CONCAT44((quotient_high_bits >> 1) + 0x3fe00000 + (exponent_difference + -0x3ff >> 1) * 0x100000, quotient_low_bits);\n}",
            "called": [
                "__divdf3",
                "__muldf3",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c0c",
            "calling": [
                "sqrt",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_multiplication_and_addition_08006c0c"
        },
        "FUN_0800426c": {
            "renaming": {
                "FUN_0800426c": "CalculateMotorSpeeds_0800426c",
                "throttle": "throttle",
                "pitch": "pitch",
                "roll": "roll",
                "yaw": "yaw",
                "uVar1": "throttle_diff",
                "uVar2": "pitch_diff",
                "uVar3": "roll_diff",
                "m4": "motor4_speed",
                "m3": "motor3_speed",
                "m2": "motor2_speed",
                "m1": "motor1_speed"
            },
            "code": "void CalculateMotorSpeeds_0800426c(float throttle, float pitch, float roll, float yaw) {\n  float throttle_diff = throttle - DAT_080042fc;\n  float pitch_diff = pitch - DAT_080042fc;\n  float roll_diff = roll - DAT_080042fc;\n  float yaw_diff = yaw - DAT_080042fc;\n  int motor4_speed = (int) roundf(throttle_diff - pitch_diff + roll_diff + yaw_diff);\n  int motor3_speed = (int) roundf(throttle_diff + pitch_diff + roll_diff - yaw_diff);\n  int motor2_speed = (int) roundf(throttle_diff + pitch_diff - roll_diff + yaw_diff);\n  int motor1_speed = (int) roundf(throttle_diff - pitch_diff - roll_diff - yaw_diff);\n  Motor_SetSpeed(motor1_speed, motor2_speed, motor3_speed, motor4_speed);\n}",
            "called": [
                "Motor_SetSpeed",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_f2iz"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800426c",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "CalculateMotorSpeeds_0800426c"
        },
        "FUN_08002538": {
            "renaming": {
                "FUN_08002538": "set_timer_channel_08002538",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "bdtr_instance",
                "pTVar2": "timer_instance",
                "DAT_08002560": "bdtr_instance"
            },
            "code": "HAL_StatusTypeDef set_timer_channel_08002538(TIM_HandleTypeDef *timer_handle, uint32_t channel) {\n  TIM_TypeDef *timer_instance = timer_handle->Instance;\n  TIM_TypeDef *DAT_08002560 = DAT_08002560;\n  TIM_CCxChannelCmd(timer_instance, channel, 1);\n  if (timer_instance == DAT_08002560) {\n    DAT_08002560 = (TIM_TypeDef *)(timer_instance->BDTR | 0x8000);\n  }\n  if (timer_instance == DAT_08002560) {\n    timer_instance->BDTR = (uint32_t)DAT_08002560;\n  }\n  timer_instance->CR1 = timer_instance->CR1 | 1;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002538",
            "calling": [
                "PWM_Init"
            ],
            "imported": false,
            "current_name": "set_timer_channel_08002538"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "read_i2c_data_080040e8",
                "device_add": "device_address",
                "register_add": "register_address",
                "byte_array": "data_buffer",
                "size": "buffer_size",
                "file": "file_name",
                "line": "line_number",
                "file_00": "file_name_ptr",
                "uVar1": "read_data",
                "iVar2": "i",
                "puVar3": "data_ptr"
            },
            "code": "void read_i2c_data_080040e8(uint16_t device_address, uint16_t register_address, uint8_t *data_buffer, uint16_t buffer_size, char *file_name, int line_number)\n{\n  uint8_t *data_ptr = data_buffer;\n  for (int i = 0; i < buffer_size; i++) {\n    uint8_t read_data = I2C_ReadByte(device_address, register_address + (short)i, file_name, 0x4c);\n    *data_ptr++ = read_data;\n  }\n  return;\n}",
            "called": [
                "I2C_ReadByte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "AK8963_ReadData",
                "MS5611_Init",
                "MPU9250_ReadGyroData",
                "AK8963_Init",
                "MPU9250_ReadAccelData"
            ],
            "imported": false,
            "current_name": "read_i2c_data_080040e8"
        },
        "FUN_08000c44": {
            "renaming": {
                "FUN_08000c44": "reverse_bits_08000c44",
                "param_1": "input",
                "iVar1": "leading_zeros",
                "uVar2": "shift_amount",
                "iVar4": "mask",
                "uVar3": "output",
                "uVar5": "unused_variable"
            },
            "code": "uint reverse_bits_08000c44(uint input)\n{\n  int leading_zeros = count_leading_zeroes(input);\n  int shift_amount = leading_zeros - 8;\n  uint mask = 0x7fffffff >> (31 - shift_amount);\n  uint output = ((input << shift_amount) & mask) | ((input >> (32 - shift_amount)) & ~mask);\n  return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c44",
            "calling": [
                "MS5611_Update",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "AK8963_Init",
                "PID_Compute",
                "MPU9250_ReadAccelData"
            ],
            "imported": false,
            "current_name": "reverse_bits_08000c44"
        },
        "FUN_08000a04": {
            "renaming": {
                "FUN_08000a04": "is_valid_input_08000a04",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int is_valid_input_08000a04(uint32_t input1, int input2, uint32_t input3, int input4) {\n\tint bit_shifted_input2 = input2 << 1;\n\tint bit_shifted_input4 = input4 << 1;\n\tint shifted_input2 = bit_shifted_input2 >> 0x15;\n\tint shifted_input4 = bit_shifted_input4 >> 0x15;\n\n\tif ((shifted_input2 != -1 || (input1 | (bit_shifted_input2 << 0xc)) == 0) &&\n\t    (shifted_input4 != -1 || (input3 | (bit_shifted_input4 << 0xc)) == 0)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a04",
            "calling": [
                "asin",
                "sqrt",
                "pow"
            ],
            "imported": false,
            "current_name": "is_valid_input_08000a04"
        },
        "FUN_080025e8": {
            "renaming": {
                "FUN_080025e8": "set_UART_config_080025e8",
                "*huart": "*huart",
                "uVar1": "sysclock_freq",
                "uVar2": "divider",
                "uVar3": "mantissa",
                "iVar4": "fraction",
                "uVar5": "baudrate",
                "iVar6": "usart_div_remainder",
                "pUVar7": "usart_instance",
                "(huart->Init).Parity": "parity",
                "(huart->Init).StopBits": "stop_bits",
                "(huart->Init).WordLength": "word_length",
                "(huart->Init).Mode": "mode",
                "(huart->Init).HwFlowCtl": "hw_flow_ctl",
                "DAT_08002720": "USART1",
                "pUVar7->CR2": "usart_instance->CR2",
                "pUVar7->CR1": "usart_instance->CR1",
                "pUVar7->CR3": "usart_instance->CR3",
                "pUVar7->BRR": "usart_instance->BRR"
            },
            "code": "void set_UART_config_080025e8(UART_HandleTypeDef *huart)\n{\n  uint32_t sysclock_freq = 0;\n  uint32_t baudrate = huart->Init.BaudRate;\n  USART_TypeDef *usart_instance = huart->Instance;\n  uint8_t parity = huart->Init.Parity;\n  uint8_t word_length = huart->Init.WordLength;\n  uint8_t mode = huart->Init.Mode;\n  uint8_t stop_bits = huart->Init.StopBits;\n  uint8_t hw_flow_ctl = huart->Init.HwFlowCtl;\n  if (usart_instance == DAT_08002720) {\n    sysclock_freq = HAL_RCC_GetPCLK2Freq();\n  }\n  else {\n    sysclock_freq = HAL_RCC_GetPCLK1Freq();\n  }\n  uint32_t divider = (sysclock_freq * 2) / baudrate;\n  uint32_t mantissa = divider / 16;\n  uint32_t fraction = (divider % 16) * 16 / 16;\n  usart_instance->CR2 &= 0xffffcfff;\n  usart_instance->CR2 |= stop_bits;\n  usart_instance->CR1 &= 0xffffe9f3;\n  usart_instance->CR1 |= word_length | parity | mode;\n  usart_instance->CR3 &= 0xfffffcff;\n  usart_instance->CR3 |= hw_flow_ctl;\n  usart_instance->BRR = (mantissa << 4) | fraction;\n}\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e8",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "set_UART_config_080025e8"
        },
        "FUN_08003078": {
            "renaming": {
                "FUN_08003078": "calculate_altitude_08003078",
                "puVar1": "ptr",
                "bVar2": "temp_osr",
                "lVar3": "pressure",
                "uVar4": "temp",
                "puVar5": "is_temp_ready",
                "puVar6": "is_pressure_ready",
                "puVar7": "alt_filter",
                "uVar8": "pressure_offset",
                "uVar9": "sens",
                "uVar10": "compensated_pressure",
                "uVar11": "pressure_ratio",
                "uVar12": "compensated_temperature",
                "uVar13": "millis",
                "uVar14": "raw_temp",
                "uVar15": "delta_temp",
                "uVar16": "offset",
                "uVar17": "sensitivity",
                "uVar23": "altitude",
                "extraout_r1": "unused",
                "unaff_r4": "unused",
                "unaff_r5": "unused",
                "unaff_r6": "unused",
                "unaff_r7": "unused",
                "iVar19": "temp_degrees_celsius",
                "iVar20": "delta_pressure",
                "iVar21": "raw_pressure",
                "bVar22": "is_negative",
                "puVar18": "alt_filter_ptr"
            },
            "code": "\nvoid calculate_altitude_08003078(void)\n\n{\n  undefined4 *ptr;\n  byte temp_osr;\n  longlong pressure;\n  uint temp;\n  undefined *is_temp_ready;\n  undefined *is_pressure_ready;\n  undefined *alt_filter;\n  uint pressure_offset;\n  uint sens;\n  undefined4 compensated_pressure;\n  undefined4 pressure_ratio;\n  undefined4 compensated_temperature;\n  uint32_t millis;\n  undefined4 unused;\n  uint raw_temp;\n  undefined4 unused;\n  uint delta_temp;\n  uint offset;\n  uint sensitivity;\n  undefined4 *alt_filter_ptr;\n  undefined4 unused;\n  undefined4 unused;\n  undefined4 unused;\n  int temp_degrees_celsius;\n  int delta_pressure;\n  int raw_pressure;\n  bool is_negative;\n  undefined8 altitude;\n  \n  is_pressure_ready = PTR_PRESSURE_READY_08003254;\n  is_temp_ready = PTR_TEMP_READY_08003250;\n  if ((*PTR_TEMP_READY_08003250 != '\\0') && (*PTR_PRESSURE_READY_08003254 != '\\0')) {\n    raw_pressure = *(int *)PTR_MS5611_RawTemperature_0800325c +\n             (uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 10) * -0x100;\n    raw_temp = (uint)((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 0xc) *\n                   (longlong)raw_pressure) >> 0x17 |\n             (int)((ulonglong)\n                   ((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 0xc) *\n                   (longlong)raw_pressure) >> 0x20) << 9;\n    delta_temp = (uint)((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 8) *\n                    (longlong)raw_pressure >> 7);\n    offset = delta_temp + (uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 4) * 0x10000;\n    pressure_offset = (uint)((ulonglong)\n                   ((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 6) *\n                   (longlong)raw_pressure) >> 8);\n    temp_degrees_celsius = raw_temp + 2000;\n    sens = pressure_offset + (uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 2) * 0x8000;\n    is_negative = (int)raw_temp < 0;\n    if (1999 < temp_degrees_celsius) {\n      raw_temp = 0;\n    }\n    temp = raw_temp;\n    if (is_negative != SBORROW4(temp_degrees_celsius,2000)) {\n      delta_pressure = raw_temp * raw_temp * 5;\n      raw_temp = delta_pressure >> 2;\n      temp = delta_pressure >> 1;\n    }\n    sensitivity = offset - temp;\n    pressure = (ulonglong)(sens - raw_temp) * (ulonglong)*(uint *)PTR_MS5611_RawPressure_08003260;\n    delta_pressure = *(uint *)PTR_MS5611_RawPressure_08003260 *\n             ((((int)((longlong)(int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 6) *\n                      (longlong)raw_pressure >> 0x28) +\n               (uint)CARRY4(pressure_offset,(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 2) * 0x8000))\n              - ((int)raw_temp >> 0x1f)) - (uint)(sens < raw_temp)) + (int)((ulonglong)pressure >> 0x20);\n    pressure_offset = (uint)pressure >> 0x15 | delta_pressure * 0x800;\n    compensated_pressure = __floatsisf(pressure_offset - sensitivity >> 0xf |\n                         (((delta_pressure >> 0x15) -\n                          ((((int)((longlong)\n                                   (int)(uint)*(ushort *)(PTR_MS5611_Coefficients_08003258 + 8) *\n                                   (longlong)raw_pressure >> 0x27) +\n                            (uint)CARRY4(delta_temp,(uint)*(ushort *)\n                                                       (PTR_MS5611_Coefficients_08003258 + 4) *\n                                                0x10000)) - ((int)temp >> 0x1f)) -\n                          (uint)(offset < temp))) - (uint)(pressure_offset < sensitivity)) * 0x20000);\n    pressure_ratio = __aeabi_fdiv(compensated_pressure,DAT_08003264);\n    *(undefined4 *)PTR_MS5611_CompensatedPressure_08003268 = pressure_ratio;\n    compensated_pressure = __floatsisf(temp_degrees_celsius);\n    compensated_temperature = __aeabi_fdiv(compensated_pressure,DAT_08003264);\n    compensated_pressure = DAT_08003270;\n    *(undefined4 *)PTR_MS5611_CompensatedTemperature_0800326c = compensated_temperature;\n    __aeabi_fdiv(pressure_ratio,compensated_pressure);\n    compensated_pressure = __aeabi_f2d();\n    pow((double)CONCAT44(unused,unused),(double)CONCAT44(unused,unused));\n    altitude = __subdf3(0,DAT_08003274,compensated_pressure,unused);\n    __muldf3((int)altitude,(int)((ulonglong)altitude >> 0x20),DAT_08003248,DAT_0800324c);\n    compensated_pressure = __truncdfsf2();\n    alt_filter = PTR_alt_filter_08003278;\n    *(undefined4 *)PTR_MS5611_Altitude_0800327c = compensated_pressure;\n    pressure_ratio = 0;\n    alt_filter_ptr = (undefined4 *)alt_filter;\n    do {\n      ptr = alt_filter_ptr + 1;\n      *alt_filter_ptr = *ptr;\n      pressure_ratio = __addsf3(pressure_ratio);\n      alt_filter_ptr = ptr;\n    } while ((undefined4 *)(alt_filter + 0x4c) != ptr);\n    *(undefined4 *)(alt_filter + 0x4c) = compensated_pressure;\n    compensated_pressure = __addsf3(pressure_ratio,compensated_pressure);\n    compensated_pressure = __aeabi_fdiv(compensated_pressure,DAT_08003280);\n    *(undefined4 *)PTR_MS5611_FilteredAltitude_08003284 = compensated_pressure;\n    temp_degrees_celsius = __aeabi_f2iz();\n    alt_filter = PTR_MS5611_OSR_0800328c;\n    *(int *)PTR_msp_txf_altitude_08003288 = temp_degrees_celsius * 100;\n    temp_osr = *alt_filter;\n    *is_temp_ready = 0;\n    *is_pressure_ready = 0;\n    I2C_WriteByte(0xee,temp_osr + 0x50,'\\x01','\\0');\n    millis = millis();\n    *(uint32_t *)PTR_temp_time_08003290 = millis;\n  }\n  millis = millis();\n  is_pressure_ready = PTR_pressure_time_08003294;\n  if (((10 < millis - *(int *)PTR_temp_time_08003290) && (*is_temp_ready == '\\0')) &&\n     (*PTR_PRESSURE_READY_08003254 == '\\0')) {\n    millis = MS5611_ReadADC();\n    alt_filter = PTR_MS5611_RawTemperature_0800325c;\n    *is_temp_ready = 1;\n    *(uint32_t *)alt_filter = millis;\n    I2C_WriteByte(0xee,(byte)*PTR_MS5611_OSR_0800328c + 0x40,'\\x01','\\0');\n    millis = millis();\n    *(uint32_t *)is_pressure_ready = millis;\n  }\n  millis = millis();\n  alt_filter = PTR_PRESSURE_READY_08003254;\n  if (((10 < millis - *(int *)is_pressure_ready) && (*is_temp_ready != '\\0')) &&\n     (*PTR_PRESSURE_READY_08003254 == '\\0')) {\n    millis = MS5611_ReadADC();\n    *(uint32_t *)PTR_MS5611_RawPressure_08003260 = millis;\n    *alt_filter = 1;\n  }\n  return;\n}\n\n",
            "called": [
                "__floatsisf",
                "__muldf3",
                "__addsf3",
                "millis",
                "__aeabi_fdiv",
                "__aeabi_f2d",
                "__truncdfsf2",
                "I2C_WriteByte",
                "__subdf3",
                "MS5611_ReadADC",
                "pow",
                "__aeabi_f2iz"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003078",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "calculate_altitude_08003078"
        },
        "FUN_080009c8": {
            "renaming": {
                "FUN_080009c8": "areBothZeroOrEquivalent_080009c8",
                "in_ZR": "isZero",
                "in_CY": "isCarrySet"
            },
            "code": "bool areBothZeroOrEquivalent_080009c8(void)\n{\n    bool areEqual = __aeabi_cdcmpeq();\n    return !in_CY || areEqual;\n}",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080009c8",
            "calling": [
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "areBothZeroOrEquivalent_080009c8"
        },
        "FUN_08000f9c": {
            "renaming": {
                "FUN_08000f9c": "check_overflow_08000f9c",
                "param_1": "num1",
                "param_2": "num2",
                "uVar2": "num1_times_2",
                "uVar3": "num2_times_2",
                "uVar4": "combined",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "code": "uint check_overflow_08000f9c(uint num1, uint num2)\n{\n  bool is_overflow1 = (num1 * 2) >> 0x18 == -1;\n  bool is_overflow2 = (num2 * 2) >> 0x18 == -1;\n  \n  if (is_overflow1 || is_overflow2) {\n    if ((is_overflow1 && ((num1 & 0x7fffff) != 0)) || ((is_overflow2 && ((num2 & 0x7fffff) != 0)))) {\n      return 1;\n    }\n  }\n  \n  uint combined = (num1 * 2) | (num2 & 0x7fffffff);\n  bool is_zero = combined == 0;\n  \n  if (!is_zero) {\n    uint xor_result = num1 ^ num2;\n    is_zero = xor_result == 0;\n  }\n  \n  bool is_negative = -1 < (int)(num1 ^ num2);\n  \n  if (is_negative && num2 <= num1 && !is_zero) {\n    num1 = (int)num2 >> 0x1f;\n  }\n  \n  if (!is_negative || num2 > num1) {\n    num1 = ~((int)num2 >> 0x1f);\n  }\n  \n  if (!is_zero) {\n    num1 = num1 | 1;\n  }\n  \n  return num1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000f9c",
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "imported": false,
            "current_name": "check_overflow_08000f9c"
        },
        "FUN_08002ed4": {
            "renaming": {
                "FUN_08002ed4": "applyLowPassFilterToRoll_08002ed4",
                "in_s0": "rollAngle",
                "fVar1": "filteredRollAngle",
                "PTR_lpf_roll_08002ee4": "rollFilter"
            },
            "code": "float applyLowPassFilterToRoll_08002ed4(void)\n{\n  float rollAngle;\n  float filteredRollAngle;\n  \n  rollAngle = getRollAngle();\n  filteredRollAngle = lowPassFilter(PTR_lpf_roll_08002ee4, rollAngle);\n  return filteredRollAngle;\n}",
            "called": [
                "lowPassFilter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed4",
            "calling": [
                "AHRS_ComputeAngles",
                "PID_Update"
            ],
            "imported": false,
            "current_name": "applyLowPassFilterToRoll_08002ed4"
        },
        "FUN_08006228": {
            "renaming": {
                "FUN_08006228": "calculate_result_08006228",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result_1",
                "extraout_r1": "extra_result_1",
                "extraout_r1_00": "extra_result_2",
                "uVar2": "result_2",
                "extraout_r1_01": "extra_result_3",
                "extraout_r1_02": "extra_result_4",
                "extraout_r1_03": "extra_result_5",
                "extraout_r1_04": "extra_result_6",
                "uVar3": "result_3",
                "iVar4": "variable_1",
                "uVar5": "result_4",
                "uVar6": "result_5",
                "uVar7": "result_6",
                "uVar8": "result_7",
                "uVar9": "result_8",
                "uVar10": "result_9",
                "uVar11": "result_10",
                "uVar12": "result_11",
                "uVar13": "result_12",
                "uVar14": "result_13",
                "uVar15": "result_14",
                "lVar16": "result_15",
                "uVar17": "result_16",
                "uVar18": "result_17",
                "uVar19": "result_18",
                "in_stack_ffffff94": "variable_2",
                "local_68": "local_variable_1",
                "local_64": "local_variable_2",
                "local_54": "local_variable_3"
            },
            "code": "\nvoid calculate_result_08006228(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result_1;\n  undefined4 extra_result_1;\n  uint extra_result_2;\n  undefined4 result_2;\n  undefined4 extra_result_3;\n  undefined4 extra_result_4;\n  uint extra_result_5;\n  undefined4 extra_result_6;\n  undefined4 result_3;\n  int variable_1;\n  uint result_4;\n  undefined4 result_5;\n  uint result_6;\n  undefined4 result_7;\n  uint result_8;\n  undefined4 result_9;\n  undefined4 result_10;\n  undefined8 result_11;\n  undefined8 result_12;\n  undefined8 result_13;\n  undefined8 result_14;\n  longlong result_15;\n  ulonglong result_16;\n  undefined8 result_17;\n  undefined4 result_18;\n  undefined4 variable_2;\n  undefined4 local_variable_1;\n  undefined4 local_variable_2;\n  int local_variable_3;\n  \n  result_8 = input_4 & 0x7fffffff;\n  if ((result_8 | input_3) == 0) {\n    return;\n  }\n  result_6 = input_2 & 0x7fffffff;\n  if ((int)result_6 <= (int)DAT_08006428) {\n    if (result_6 == DAT_08006428) {\n      if (input_1 == 0) {\n        if (result_6 < result_8) goto LAB_08006278;\nLAB_08006262:\n        if ((result_8 != DAT_08006428) || (input_3 == 0)) {\n          if (-1 < (int)input_2) goto LAB_0800632a;\n          if (DAT_08006430 < (int)result_8) {\n            result_1 = 2;\nLAB_080062ba:\n            if (input_3 == 0) {\n              if (result_8 == DAT_08006428) {\n                return;\n              }\nLAB_0800630c:\n              if (result_8 == DAT_08006438) {\n                if (-1 < (int)input_4) {\n                  return;\n                }\n                result_6 = 0;\n                result_8 = DAT_08006438;\n                goto LAB_08006320;\n              }\n              if (input_4 == 0x40000000) goto LAB_0800634a;\n              if ((input_4 == DAT_0800643c) && (-1 < (int)input_2)) {\n                __ieee754_sqrt(input_1,input_2);\n                return;\n              }\n            }\n          }\n          else {\n            if ((int)result_8 <= DAT_08006430 + -0x3500000) {\nLAB_0800632a:\n              result_1 = 0;\n              goto LAB_080062ba;\n            }\n            variable_1 = ((int)result_8 >> 0x14) + -0x3ff;\n            if (0x14 < variable_1) {\n              result_1 = input_3 >> (0x34U - variable_1 & 0xff);\n              if (input_3 == result_1 << (0x34U - variable_1 & 0xff)) {\n                result_1 = 2 - (result_1 & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (input_3 == 0) {\n              result_4 = (int)result_8 >> (0x14U - variable_1 & 0xff);\n              result_1 = input_3;\n              if (result_8 == result_4 << (0x14U - variable_1 & 0xff)) {\n                result_1 = 2 - (result_4 & 1);\n              }\n              goto LAB_0800630c;\n            }\n            result_1 = 0;\n          }\n          result_4 = input_1;\n          fabs((double)CONCAT44(variable_2,result_1));\n          result_16 = CONCAT44(input_2,result_4) & 0x7fffffffffffffff;\n          if ((input_1 == 0) && ((result_6 == 0 || ((input_2 & 0x3fffffff) == DAT_08006438)))) {\n            if ((int)input_4 < 0) {\n              __divdf3(0,DAT_08006438,result_4,extra_result_1);\n            }\n            if (-1 < (int)input_2) {\n              return;\n            }\n            if ((result_1 | result_6 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            result_4 = 0xffffffff - ((int)input_2 >> 0x1f);\n            if ((result_1 | result_4) != 0) {\n              if (DAT_08006440 < (int)result_8) {\n                if (DAT_08006440 + 0x2100000 < (int)result_8) {\n                  if (DAT_08006434 < (int)result_6) {\nLAB_08006418:\n                    if ((int)input_4 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)input_4) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if ((int)result_6 <= DAT_08006444) goto LAB_080063fa;\n                if ((int)DAT_08006438 < (int)result_6) goto LAB_08006418;\n                result_11 = __subdf3();\n                result_9 = (undefined4)((ulonglong)result_11 >> 0x20);\n                result_7 = (undefined4)result_11;\n                result_11 = __muldf3(result_7,result_9,DAT_080065a8,DAT_080065ac);\n                result_12 = __muldf3(result_7,result_9,DAT_080065b0,DAT_080065b4);\n                result_13 = __muldf3(result_7,result_9,0,DAT_080065d4);\n                result_13 = __subdf3(DAT_080065b8,DAT_080065bc,(int)result_13,\n                                  (int)((ulonglong)result_13 >> 0x20));\n                result_13 = __muldf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),result_7,result_9);\n                result_13 = __subdf3(0,DAT_080065d8,(int)result_13,(int)((ulonglong)result_13 >> 0x20));\n                result_14 = __muldf3(result_7,result_9,result_7,result_9);\n                result_13 = __muldf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),(int)result_14,\n                                  (int)((ulonglong)result_14 >> 0x20));\n                result_13 = __muldf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),DAT_080065c0,\n                                  DAT_080065c4);\n                result_12 = __subdf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_13,\n                                  (int)((ulonglong)result_13 >> 0x20));\n                __aeabi_dadd((int)result_11,(int)((ulonglong)result_11 >> 0x20),(int)result_12,\n                             (int)((ulonglong)result_12 >> 0x20));\n                result_15 = (ulonglong)extra_result_2 << 0x20;\n                result_8 = extra_result_2;\n              }\n              else {\n                local_variable_3 = 0;\n                if (result_6 < 0x100000) {\n                  result_16 = __muldf3();\n                  local_variable_3 = -0x35;\n                }\n                result_8 = (uint)(result_16 >> 0x20);\n                local_variable_3 = ((int)result_8 >> 0x14) + -0x3ff + local_variable_3;\n                result_8 = result_8 & 0xfffff;\n                result_6 = result_8 | 0x3ff00000;\n                if (DAT_0800691c < (int)result_8) {\n                  if (DAT_08006920 < (int)result_8) {\n                    result_6 = result_6 - 0x100000;\n                    local_variable_3 = local_variable_3 + 1;\n                    goto LAB_08006628;\n                  }\n                  variable_1 = 1;\n                }\n                else {\nLAB_08006628:\n                  variable_1 = 0;\n                }\n                result_5 = *(undefined4 *)(PTR_bp_08006924 + variable_1 * 8);\n                result_18 = *(undefined4 *)((int)(PTR_bp_08006924 + variable_1 * 8) + 4);\n                result_11 = __subdf3();\n                result_9 = (undefined4)((ulonglong)result_11 >> 0x20);\n                result_12 = __aeabi_dadd((int)result_16,result_6,result_5,result_18);\n                result_12 = __divdf3(0,DAT_08006928,(int)result_12,(int)((ulonglong)result_12 >> 0x20));\n                result_10 = (undefined4)((ulonglong)result_12 >> 0x20);\n                result_13 = __muldf3((int)result_11,result_9,(int)result_12,result_10);\n                result_2 = (undefined4)((ulonglong)result_13 >> 0x20);\n                result_7 = (undefined4)result_13;\n                result_13 = __muldf3(0,result_2);\n                result_11 = __subdf3((int)result_11,result_9,(int)result_13,(int)((ulonglong)result_13 >> 0x20));\n                result_13 = __subdf3(0,((int)result_6 >> 1 | 0x20000000U) + 0x80000 + variable_1 * 0x40000,\n                                  result_5,result_18);\n                result_13 = __subdf3((int)result_16,result_6,(int)result_13,(int)((ulonglong)result_13 >> 0x20));\n                result_13 = __muldf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),0,result_2);\n                result_11 = __subdf3((int)result_11,(int)((ulonglong)result_11 >> 0x20),(int)result_13,\n                                  (int)((ulonglong)result_13 >> 0x20));\n                result_11 = __muldf3((int)result_11,(int)((ulonglong)result_11 >> 0x20),(int)result_12,result_10);\n                result_10 = (undefined4)((ulonglong)result_11 >> 0x20);\n                result_12 = __muldf3(result_7,result_2);\n                result_5 = (undefined4)((ulonglong)result_12 >> 0x20);\n                result_9 = (undefined4)result_12;\n                result_12 = __muldf3(result_9,result_5,DAT_080068d0,DAT_080068d4);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_080068d8,\n                                      DAT_080068dc);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_9,result_5);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_080068e0,\n                                      DAT_080068e4);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_9,result_5);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_080068e8,\n                                      DAT_080068ec);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_9,result_5);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_080068f0,\n                                      DAT_080068f4);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_9,result_5);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_080068f8,\n                                      DAT_080068fc);\n                result_13 = __muldf3(result_9,result_5,result_9,result_5);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_13,\n                                  (int)((ulonglong)result_13 >> 0x20));\n                result_13 = __aeabi_dadd(result_7,result_2,0,result_2);\n                result_13 = __muldf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),(int)result_11,result_10);\n                result_12 = __aeabi_dadd((int)result_13,(int)((ulonglong)result_13 >> 0x20),(int)result_12,\n                                      (int)((ulonglong)result_12 >> 0x20));\n                result_9 = (undefined4)((ulonglong)result_12 >> 0x20);\n                result_13 = __muldf3(0,result_2,0,result_2);\n                result_5 = (undefined4)((ulonglong)result_13 >> 0x20);\n                result_14 = __aeabi_dadd((int)result_13,result_5,0,DAT_0800692c);\n                __aeabi_dadd((int)result_14,(int)((ulonglong)result_14 >> 0x20),(int)result_12,result_9);\n                result_14 = __muldf3(0,result_2,0,extra_result_3);\n                result_18 = (undefined4)((ulonglong)result_14 >> 0x20);\n                result_17 = __subdf3(0,extra_result_3,0,DAT_0800692c);\n                result_13 = __subdf3((int)result_17,(int)((ulonglong)result_17 >> 0x20),(int)result_13,result_5);\n                result_12 = __subdf3((int)result_12,result_9,(int)result_13,(int)((ulonglong)result_13 >> 0x20));\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_7,result_2);\n                result_11 = __muldf3((int)result_11,result_10,0,extra_result_3);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_11,\n                                      (int)((ulonglong)result_11 >> 0x20));\n                result_7 = (undefined4)((ulonglong)result_12 >> 0x20);\n                __aeabi_dadd((int)result_14,result_18,(int)result_12,result_7);\n                result_11 = __muldf3(0,extra_result_4,DAT_08006900,DAT_08006904);\n                result_13 = __subdf3(0,extra_result_4,(int)result_14,result_18);\n                result_12 = __subdf3((int)result_12,result_7,(int)result_13,(int)((ulonglong)result_13 >> 0x20));\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_08006908,\n                                  DAT_0800690c);\n                result_13 = __muldf3(0,extra_result_4,DAT_08006910,DAT_08006914);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_13,\n                                      (int)((ulonglong)result_13 >> 0x20));\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),\n                                      *(undefined4 *)(PTR_dp_l_08006930 + variable_1 * 8),\n                                      *(undefined4 *)((int)(PTR_dp_l_08006930 + variable_1 * 8) + 4));\n                result_13 = __aeabi_i2d(local_variable_3);\n                result_7 = (undefined4)((ulonglong)result_13 >> 0x20);\n                result_9 = *(undefined4 *)(PTR_dp_h_08006934 + variable_1 * 8);\n                result_10 = *(undefined4 *)((int)(PTR_dp_h_08006934 + variable_1 * 8) + 4);\n                result_14 = __aeabi_dadd((int)result_11,(int)((ulonglong)result_11 >> 0x20),(int)result_12,\n                                      (int)((ulonglong)result_12 >> 0x20));\n                result_14 = __aeabi_dadd((int)result_14,(int)((ulonglong)result_14 >> 0x20),result_9,result_10);\n                __aeabi_dadd((int)result_14,(int)((ulonglong)result_14 >> 0x20),(int)result_13,result_7);\n                result_13 = __subdf3(0,extra_result_5,(int)result_13,result_7);\n                result_15 = __subdf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),result_9,result_10);\n                result_8 = extra_result_5;\n              }\n              result_11 = __subdf3((int)result_15,(int)((ulonglong)result_15 >> 0x20),(int)result_11,\n                                (int)((ulonglong)result_11 >> 0x20));\n              result_11 = __subdf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_11,\n                                (int)((ulonglong)result_11 >> 0x20));\n              result_7 = DAT_080065dc;\n              if ((result_1 - 1 | result_4) != 0) {\n                result_7 = DAT_080065d0;\n              }\n              result_18 = 0;\n              result_12 = __subdf3(input_3,input_4,0,input_4);\n              result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),0,result_8);\n              result_11 = __muldf3((int)result_11,(int)((ulonglong)result_11 >> 0x20),input_3,input_4);\n              result_11 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_11,\n                                    (int)((ulonglong)result_11 >> 0x20));\n              result_2 = (undefined4)((ulonglong)result_11 >> 0x20);\n              result_9 = (undefined4)result_11;\n              result_11 = __muldf3(0,result_8,0,input_4);\n              result_5 = (undefined4)((ulonglong)result_11 >> 0x20);\n              result_10 = (undefined4)result_11;\n              result_15 = __aeabi_dadd(result_9,result_2,result_10,result_5);\n              result_6 = (uint)((ulonglong)result_15 >> 0x20);\n              result_8 = (uint)result_15;\n              if (DAT_080065e0 < (int)result_6) {\n                if ((result_6 + 0xbf700000 | result_8) == 0) {\n                  result_12 = __aeabi_dadd(result_9,result_2,DAT_08006ba8,DAT_08006bac);\n                  result_13 = __subdf3(result_8,result_6,result_10,result_5);\n                  variable_1 = __aeabi_dcmpgt((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_13,\n                                         (int)((ulonglong)result_13 >> 0x20));\n                  if (variable_1 == 0) goto LAB_08006968;\n                }\n                __muldf3(result_18,result_7,DAT_080065c8,DAT_080065cc);\n                goto LAB_0800634a;\n              }\n              if (DAT_08006c04 < (int)(result_6 & 0x7fffffff)) {\n                if ((DAT_08006c08 + result_6 | result_8) == 0) {\n                  result_12 = __subdf3(result_8,result_6,result_10,result_5);\n                  variable_1 = __aeabi_dcmple(result_9,result_2,(int)result_12,(int)((ulonglong)result_12 >> 0x20));\n                  if (variable_1 == 0) goto LAB_08006968;\n                }\n                __muldf3(result_18,result_7,DAT_08006bf0,DAT_08006bf4);\n              }\n              else {\nLAB_08006968:\n                if (DAT_08006bf8 < (int)(result_6 & 0x7fffffff)) {\n                  result_6 = (0x100000 >> (((int)(result_6 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          result_6;\n                  result_8 = (result_6 * 2 >> 0x15) - 0x3ff;\n                  variable_1 = (int)(result_6 & 0xfffff | 0x100000) >> (0x14 - result_8 & 0xff);\n                  if (result_15 < 0) {\n                    variable_1 = -variable_1;\n                  }\n                  result_11 = __subdf3(result_10,result_5,0,result_6 & ~(DAT_08006bfc >> (result_8 & 0xff)));\n                }\n                else {\n                  variable_1 = 0;\n                }\n                local_variable_2 = (undefined4)((ulonglong)result_11 >> 0x20);\n                local_variable_1 = (undefined4)result_11;\n                __aeabi_dadd(local_variable_1,local_variable_2,result_9,result_2);\n                result_11 = __muldf3(0,extra_result_6,DAT_08006bb0,DAT_08006bb4);\n                result_10 = (undefined4)((ulonglong)result_11 >> 0x20);\n                result_12 = __subdf3(0,extra_result_6,local_variable_1,local_variable_2);\n                result_12 = __subdf3(result_9,result_2,(int)result_12,(int)((ulonglong)result_12 >> 0x20));\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_08006bb8,\n                                  DAT_08006bbc);\n                result_13 = __muldf3(0,extra_result_6,DAT_08006bc0,DAT_08006bc4);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_13,\n                                      (int)((ulonglong)result_13 >> 0x20));\n                result_2 = (undefined4)((ulonglong)result_12 >> 0x20);\n                result_13 = __aeabi_dadd((int)result_11,result_10,(int)result_12,result_2);\n                result_5 = (undefined4)((ulonglong)result_13 >> 0x20);\n                result_9 = (undefined4)result_13;\n                result_11 = __subdf3(result_9,result_5,(int)result_11,result_10);\n                result_11 = __subdf3((int)result_12,result_2,(int)result_11,(int)((ulonglong)result_11 >> 0x20));\n                result_2 = (undefined4)((ulonglong)result_11 >> 0x20);\n                result_12 = __muldf3(result_9,result_5,result_9,result_5);\n                result_3 = (undefined4)((ulonglong)result_12 >> 0x20);\n                result_10 = (undefined4)result_12;\n                result_12 = __muldf3(result_10,result_3,DAT_08006bc8,DAT_08006bcc);\n                result_12 = __subdf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_08006bd0,\n                                  DAT_08006bd4);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_10,result_3);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_08006bd8,\n                                      DAT_08006bdc);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_10,result_3);\n                result_12 = __subdf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_08006be0,\n                                  DAT_08006be4);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_10,result_3);\n                result_12 = __aeabi_dadd((int)result_12,(int)((ulonglong)result_12 >> 0x20),DAT_08006be8,\n                                      DAT_08006bec);\n                result_12 = __muldf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),result_10,result_3);\n                result_12 = __subdf3(result_9,result_5,(int)result_12,(int)((ulonglong)result_12 >> 0x20));\n                result_10 = (undefined4)((ulonglong)result_12 >> 0x20);\n                result_13 = __muldf3(result_9,result_5,(int)result_12,result_10);\n                result_12 = __subdf3((int)result_12,result_10,0,0x40000000);\n                result_12 = __divdf3((int)result_13,(int)((ulonglong)result_13 >> 0x20),(int)result_12,\n                                  (int)((ulonglong)result_12 >> 0x20));\n                result_13 = __muldf3(result_9,result_5,(int)result_11,result_2);\n                result_11 = __aeabi_dadd((int)result_13,(int)((ulonglong)result_13 >> 0x20),(int)result_11,result_2\n                                     );\n                result_11 = __subdf3((int)result_12,(int)((ulonglong)result_12 >> 0x20),(int)result_11,\n                                  (int)((ulonglong)result_11 >> 0x20));\n                result_11 = __subdf3((int)result_11,(int)((ulonglong)result_11 >> 0x20),result_9,result_5);\n                result_11 = __subdf3(0,DAT_08006c00,(int)result_11,(int)((ulonglong)result_11 >> 0x20));\n                if ((int)((ulonglong)result_11 >> 0x20) + variable_1 * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(result_7,result_18),(int)result_11);\n                }\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          result_11 = __subdf3();\n          result_8 = (uint)((ulonglong)result_11 >> 0x20);\n          result_6 = (uint)result_11;\n          input_1 = result_6;\n          input_2 = result_8;\nLAB_08006320:\n          __divdf3(result_6,result_8,input_1,input_2);\n          return;\n        }\n      }\n    }\n    else if ((int)result_8 <= (int)DAT_08006428) goto LAB_08006262;\n  }\n  if ((result_6 + 0xc0100000 | input_1) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(PTR_DAT_0800642c);\n  return;\n}\n\n",
            "called": [
                "scalbn",
                "__aeabi_dcmple",
                "__divdf3",
                "__muldf3",
                "__ieee754_sqrt",
                "__aeabi_dcmpgt",
                "__aeabi_dadd",
                "fabs",
                "__subdf3",
                "__aeabi_i2d",
                "nan"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006228",
            "calling": [
                "pow"
            ],
            "imported": false,
            "current_name": "calculate_result_08006228"
        },
        "FUN_08000c3c": {
            "renaming": {
                "FUN_08000c3c": "calculate_square_root_08000c3c",
                "param_1": "input_number",
                "iVar1": "leading_zeroes_count",
                "uVar2": "shift_amount",
                "iVar3": "multiplier",
                "uVar4": "shift_mask",
                "shifted_input": "shifted_input",
                "shifted_multiplier": "shifted_multiplier"
            },
            "code": "uint calculate_square_root_08000c3c(uint input_number) {\n  int leading_zeroes_count = count_leading_zeroes(input_number);\n  uint shift_amount = leading_zeroes_count - 8;\n  int multiplier = shift_amount * -0x800000 + 0x4a800000;\n  if (leading_zeroes_count > 7) {\n    uint shift_mask = 0 << (shift_amount & 0xff);\n    uint shifted_input = input_number << (shift_amount & 0xff);\n    uint shifted_multiplier = multiplier + shifted_input + (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shift_mask);\n    if (shift_mask == 0x80000000) {\n      shifted_multiplier = shifted_multiplier & 0xfffffffe;\n    }\n    return shifted_multiplier;\n  }\n  uint shifted_input = input_number << (leading_zeroes_count + 0x18U & 0xff);\n  uint shifted_multiplier = multiplier + ((input_number >> (0x20 - (leading_zeroes_count + 0x18U) & 0xff)) - ((int)shifted_input >> 0x1f));\n  if ((shifted_input & 0x7fffffff) == 0) {\n    shifted_multiplier = shifted_multiplier & ~(shifted_input >> 0x1f);\n  }\n  return shifted_multiplier;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000c3c",
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "imported": false,
            "current_name": "calculate_square_root_08000c3c"
        },
        "FUN_08001214": {
            "renaming": {
                "FUN_08001214": "calculate_ticks_remaining_08001214",
                "TicksNumb": "ticks_total",
                "puVar1": "ptr1",
                "iVar2": "var1"
            },
            "code": "uint32_t calculate_ticks_remaining_08001214(uint32_t ticks_total) {\n  undefined4 *ptr1 = DAT_08001238;\n  int var1 = DAT_0800123c;\n  if (ticks_total - 1 < 0x1000000) {\n    ptr1[1] = ticks_total - 1;\n    *(undefined *)(var1 + 0x23) = 0xf0;\n    ptr1[2] = 0;\n    *ptr1 = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001214",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "calculate_ticks_remaining_08001214"
        },
        "FUN_08003fc4": {
            "renaming": {
                "FUN_08003fc4": "set_PWM_value_08003fc4",
                "pwm": "pwm_value",
                "PTR_htim4_08003fcc": "htim4"
            },
            "code": "void set_PWM_value_08003fc4(int pwm_value)\n{\n    int* PTR_htim4_08003fcc = (int*) *(int*)PTR_PTR_htim4_08003fcc_08003fcc;\n    int* pwm_register = PTR_htim4_08003fcc + 16;\n    *pwm_register = pwm_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fc4",
            "calling": [
                "Motor_SetSpeed",
                "Motor_StopAll"
            ],
            "imported": false,
            "current_name": "set_PWM_value_08003fc4"
        },
        "FUN_0800209c": {
            "renaming": {
                "FUN_0800209c": "configureClocks_0800209c",
                "*RCC_ClkInitStruct": "*clockInitStruct",
                "FLatency": "latency",
                "cVar1": "",
                "cVar2": "",
                "*puVar3": "",
                "uVar4": "",
                "uVar5": "",
                "uVar6": "",
                "uVar7": "",
                "DAT_08002204": "PTR_FLASH_LATENCY",
                "DAT_08002208": "PTR_RCC_CFGR",
                "PTR_SystemCoreClock_08002210": "PTR_SYSTEM_CORE_CLOCK",
                "PTR_AHBPrescTable_0800220c": "PTR_AHB_PRESCALER_TABLE",
                "count_leading_zeroes": "__builtin_clz"
            },
            "code": "HAL_StatusTypeDef configureClocks_0800209c(RCC_ClkInitTypeDef *clockInitStruct, uint32_t latency)\n{\n  uint32_t clockType = clockInitStruct->ClockType;\n  uint32_t sysClockFreq = HAL_RCC_GetSysClockFreq();\n  uint32_t ahbPrescaler = 0;\n  uint32_t apb1Prescaler = 0;\n  uint32_t apb2Prescaler = 0;\n  uint32_t timeout = 5000;\n  \n  if (latency > (*DAT_08002204 & 7))\n  {\n    *DAT_08002204 = (*DAT_08002204 & 0xfffffff8) | latency;\n  }\n  \n  if (latency != (*DAT_08002204 & 7))\n  {\n    return HAL_ERROR;\n  }\n  \n  if ((clockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)\n  {\n    uint32_t sysClockSource = clockInitStruct->SYSCLKSource;\n    \n    if (sysClockSource == RCC_SYSCLKSOURCE_PLLCLK)\n    {\n      RCC_OscInitTypeDef oscInit;\n      oscInit.PLL.PLLState = RCC_PLL_ON;\n      oscInit.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n      oscInit.PLL.PLLM = HSE_VALUE / 1000000;\n      oscInit.PLL.PLLN = 336;\n      oscInit.PLL.PLLP = RCC_PLLP_DIV2;\n      oscInit.PLL.PLLQ = 7;\n      HAL_RCC_OscConfig(&oscInit);\n      \n      RCC_ClkInitTypeDef clkInit;\n      clkInit.ClockType = RCC_CLOCKTYPE_SYSCLK;\n      clkInit.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n      clkInit.AHBCLKDivider = RCC_SYSCLK_DIV1;\n      clkInit.APB1CLKDivider = RCC_HCLK_DIV4;\n      clkInit.APB2CLKDivider = RCC_HCLK_DIV2;\n      HAL_RCC_ClockConfig(&clkInit, FLASH_LATENCY_5);\n    }\n  }\n  \n  if ((clockType & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\n  {\n    ahbPrescaler = clockInitStruct->AHBCLKDivider;\n  }\n  \n  if ((clockType & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\n  {\n    apb1Prescaler = clockInitStruct->APB1CLKDivider;\n  }\n  \n  if ((clockType & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\n  {\n    apb2Prescaler = clockInitStruct->APB2CLKDivider;\n  }\n  \n  ahbPrescaler = PTR_AHBPrescTable_0800220c[((DAT_08002208 & RCC_CFGR_HPRE) >> 4) * 4 + 3 - __builtin_clz(ahbPrescaler)];\n  apb1Prescaler = PTR_APB_PRESCALER_TABLE[((DAT_08002208 & RCC_CFGR_PPRE1) >> 10) * 4 + 3 - __builtin_clz(apb1Prescaler)];\n  apb2Prescaler = PTR_APB_PRESCALER_TABLE[((DAT_08002208 & RCC_CFGR_PPRE2) >> 13) * 4 + 3 - __builtin_clz(apb2Prescaler)];\n  \n  *(uint32_t *)PTR_SystemCoreClock_08002210 = sysClockFreq / ahbPrescaler;\n  HAL_InitTick(0);\n  \n  while ((RCC->CFGR & RCC_CFGR_SWS) != (clockInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))\n  {\n    if (--timeout == 0)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  \n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800209c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configureClocks_0800209c"
        },
        "FUN_08003f0e": {
            "renaming": {
                "FUN_08003f0e": "update_last_value_08003f0e",
                "var": "filter",
                "current": "current_value",
                "fVar3": "beta",
                "extraout_s0": "new_last",
                "uVar1": "beta_complement_times_current",
                "uVar2": "beta_times_last"
            },
            "code": "float update_last_value_08003f0e(LPF *filter, float current_value)\n{\n  float beta_complement = 1.0 - filter->beta;\n  float beta_complement_times_current = beta_complement * current_value;\n  float beta_times_last = filter->beta * filter->last;\n  float new_last = beta_complement_times_current + beta_times_last;\n  filter->last = new_last;\n  return new_last;\n}",
            "called": [
                "__aeabi_fmul",
                "__addsf3",
                "__aeabi_fsub"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0e",
            "calling": [
                "AHRS_GetPitch",
                "AHRS_GetRoll"
            ],
            "imported": false,
            "current_name": "update_last_value_08003f0e"
        },
        "FUN_0800403c": {
            "renaming": {
                "FUN_0800403c": "write_register_0800403c",
                "device_add": "device_address",
                "register_add": "register_address",
                "register_val": "register_value",
                "delay_mode": "delay_mode",
                "HVar1": "status",
                "byte": "buffer",
                "PTR_hi2c1_08004074": "hi2c1",
                "HAL_I2C_Mem_Write": "HAL_I2C_Mem_Write",
                "HAL_OK": "HAL_OK",
                "_Error_Handler": "_Error_Handler",
                "PTR_s____Src_i2c_c_08004078": "__FILE__",
                "0x1b": "__LINE__",
                "delay_ms": "delay_ms"
            },
            "code": "void write_register_0800403c(uint16_t device_address, uint16_t register_address, uint8_t register_value, uint8_t delay_mode) {\n    HAL_StatusTypeDef status;\n    uint8_t buffer[1];\n    buffer[0] = register_value;\n    status = HAL_I2C_Mem_Write(&PTR_hi2c1_08004074, device_address, register_address, 1, buffer, 1, 200);\n    if (status != HAL_OK) {\n        _Error_Handler(PTR_s____Src_i2c_c_08004078, __LINE__);\n    }\n    if (delay_mode != 0) {\n        delay_ms(50);\n    }\n    return;\n}",
            "called": [
                "HAL_I2C_Mem_Write",
                "delay_ms",
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800403c",
            "calling": [
                "MPU9250_Init",
                "MS5611_Update",
                "MS5611_Init",
                "AK8963_Init"
            ],
            "imported": false,
            "current_name": "write_register_0800403c"
        },
        "FUN_08000cec": {
            "renaming": {
                "FUN_08000cec": "calculate_float_08000cec",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "undefined",
                "param_4": "float3",
                "lVar1": "longVar1",
                "uVar2": "result",
                "uVar3": "byte1",
                "iVar4": "sum_of_bytes",
                "iVar5": "exp",
                "iVar7": "temp_exp",
                "uVar6": "mantissa",
                "uVar8": "temp_result",
                "bVar9": "flag1",
                "bVar10": "flag2"
            },
            "code": "\nuint calculate_float_08000cec(uint float1,uint float2,undefined4 undefined,uint float3)\n\n{\n  longlong longVar1;\n  uint result;\n  uint byte1;\n  int sum_of_bytes;\n  int exp;\n  uint mantissa;\n  int temp_exp;\n  uint temp_result;\n  bool flag1;\n  bool flag2;\n  \n  byte1 = float1 >> 0x17 & 0xff;\n  flag1 = byte1 == 0;\n  if (!flag1) {\n    float3 = float2 >> 0x17 & 0xff;\n    flag1 = float3 == 0;\n  }\n  if (!flag1) {\n    flag1 = byte1 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = float3 == 0xff;\n  }\n  if (flag1) {\n    float3 = float2 >> 0x17 & 0xff;\n    if (byte1 == 0xff || float3 == 0xff) {\n      flag1 = float1 == 0 || float1 == 0x80000000;\n      result = float2;\n      if (float1 != 0 && float1 != 0x80000000) {\n        flag1 = float2 == 0;\n        result = float1;\n      }\n      if (!flag1) {\n        flag1 = float2 == 0x80000000;\n      }\n      temp_result = result;\n      if (((flag1) || ((byte1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((float3 == 0xff && (temp_result = float2, (float2 & 0x7fffff) != 0)))) {\n        return temp_result | 0x7fc00000;\n      }\n      result = result ^ float2;\n      goto LAB_08000e3c;\n    }\n    flag1 = (float1 & 0x7fffffff) == 0;\n    if (!flag1) {\n      flag1 = (float2 & 0x7fffffff) == 0;\n    }\n    if (flag1) {\n      return (float1 ^ float2) & 0x80000000;\n    }\n    flag1 = byte1 == 0;\n    result = float1 & 0x80000000;\n    while( true ) {\n      if (flag1) {\n        float1 = float1 << 1;\n        flag1 = (float1 & 0x800000) == 0;\n      }\n      if (!flag1) break;\n      byte1 = byte1 - 1;\n    }\n    float1 = float1 | result;\n    flag1 = float3 == 0;\n    result = float2 & 0x80000000;\n    while( true ) {\n      if (flag1) {\n        float2 = float2 << 1;\n        flag1 = (float2 & 0x800000) == 0;\n      }\n      if (!flag1) break;\n      float3 = float3 - 1;\n    }\n    float2 = float2 | result;\n  }\n  sum_of_bytes = byte1 + float3;\n  temp_result = float1 ^ float2;\n  byte1 = float1 << 9;\n  flag1 = byte1 == 0;\n  if (!flag1) {\n    float2 = float2 << 9;\n    flag1 = float2 == 0;\n  }\n  if (flag1) {\n    if (byte1 == 0) {\n      float2 = float2 << 9;\n    }\n    result = temp_result & 0x80000000 | float1 & 0x7fffff | float2 >> 9;\n    flag2 = SBORROW4(sum_of_bytes,0x7f);\n    exp = sum_of_bytes + -0x7f;\n    flag1 = exp == 0;\n    temp_exp = exp;\n    if (!flag1 && 0x7e < sum_of_bytes) {\n      flag2 = SBORROW4(0xff,exp);\n      temp_exp = 0xff - exp;\n      flag1 = exp == 0xff;\n    }\n    if (!flag1 && temp_exp < 0 == flag2) {\n      result = result | exp * 0x800000;\n    }\n    if (!flag1 && temp_exp < 0 == flag2) {\n      return result;\n    }\n    result = result | 0x800000;\n    mantissa = 0;\n    flag2 = SBORROW4(exp,1);\n    temp_result = sum_of_bytes - 0x80;\n    flag1 = temp_result == 0;\n    byte1 = temp_result;\n  }\n  else {\n    longVar1 = (ulonglong)(byte1 >> 5 | 0x8000000) * (ulonglong)(float2 >> 5 | 0x8000000);\n    mantissa = (uint)longVar1;\n    result = (uint)((ulonglong)longVar1 >> 0x20);\n    flag1 = result < 0x800000;\n    if (flag1) {\n      result = result << 1;\n    }\n    if (flag1) {\n      result = result | mantissa >> 0x1f;\n      mantissa = mantissa << 1;\n    }\n    result = temp_result & 0x80000000 | result;\n    temp_result = (sum_of_bytes + -0x7f) - (uint)flag1;\n    flag2 = SBORROW4(temp_result,0xfd);\n    flag1 = temp_result == 0xfd;\n    byte1 = temp_result - 0xfd;\n    if (temp_result < 0xfe) {\n      result = result + temp_result * 0x800000 + (uint)(0x7fffffff < mantissa);\n      if (mantissa == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (flag1 || (int)byte1 < 0 != flag2) {\n    flag1 = (int)(temp_result + 0x19) < 0;\n    if (temp_result == 0xffffffe7 || flag1 != SCARRY4(temp_result,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (temp_result != 0xffffffe7 && flag1 == SCARRY4(temp_result,0x19)) {\n      byte1 = (result << 1) >> (-temp_result & 0xff);\n      temp_result = result << (temp_result + 0x20 & 0xff);\n      byte1 = ((uint)((result & 0x80000000) != 0) << 0x1f | byte1 >> 1) + (uint)((byte)byte1 & 1);\n      if ((mantissa | temp_result << 1) == 0) {\n        byte1 = byte1 & ~(temp_result >> 0x1f);\n      }\n      return byte1;\n    }\n    return result;\n  }\nLAB_08000e3c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000cec",
            "calling": [
                "AK8963_ReadData",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "PID_Update",
                "MPU9250_ReadGyroData",
                "lowPassFilter",
                "AK8963_Init",
                "PID_Compute",
                "MPU9250_ReadAccelData",
                "PID_UpdateAltitude"
            ],
            "imported": false,
            "current_name": "calculate_float_08000cec"
        },
        "FUN_0800277c": {
            "renaming": {
                "FUN_0800277c": "uart_transmit_0800277c",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "HVar3": "uart_state",
                "pUVar4": "uart_instance"
            },
            "code": "HAL_StatusTypeDef uart_transmit_0800277c(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size, uint32_t timeout)\\\n{\\n\\\n  uint32_t start_time;\\\n  uint32_t current_time;\\\n  HAL_UART_StateTypeDef uart_state;\\\n  USART_TypeDef *uart_instance;\\\n  \\\n  if ((uart_handle->State == HAL_UART_STATE_READY) || (uart_handle->State == HAL_UART_STATE_BUSY_RX)) {\\\n    if ((data == NULL) || (size == 0)) {\\\n      return HAL_ERROR;\\\n    }\\\n    if (uart_handle->Lock != HAL_LOCKED) {\\\n      uart_handle->Lock = HAL_LOCKED;\\\n      uart_handle->ErrorCode = 0;\\\n      uart_handle->TxXferSize = size;\\\n      if (uart_handle->State == HAL_UART_STATE_BUSY_RX) {\\\n        uart_state = HAL_UART_STATE_BUSY_TX_RX;\\\n      }\\\n      else {\\\n        uart_state = HAL_UART_STATE_BUSY_TX;\\\n      }\\\n      uart_handle->TxXferCount = size;\\\n      uart_handle->State = uart_state;\\\n      \\\n      while (uart_handle->TxXferCount > 0) {\\\n        if (HAL_GetTick() - start_time > timeout) {\\\n          uart_handle->State = HAL_UART_STATE_READY;\\\n          uart_handle->Lock = HAL_UNLOCKED;\\\n          return HAL_TIMEOUT;\\\n        }\\\n        if ((int)(uart_handle->Instance->SR << 0x19) < 0) {\\\n          if (uart_handle->State == HAL_UART_STATE_BUSY_TX_RX) {\\\n            uart_state = HAL_UART_STATE_BUSY_RX;\\\n          }\\\n          else {\\\n            uart_state = HAL_UART_STATE_READY;\\\n          }\\\n          uart_handle->State = uart_state;\\\n          uart_handle->Lock = HAL_UNLOCKED;\\\n          return HAL_OK;\\\n        }\\\n        if ((uart_handle->Init).WordLength == 0x1000) {\\\n          if ((int)(uart_handle->Instance->SR << 0x18) < 0) {\\\n            uart_handle->Instance->DR = *(unsigned short *)data & 0x1ff;\\\n            if ((uart_handle->Init).Parity == 0) {\\\n              data += 2;\\\n            }\\\n            else {\\\n              data ++;\\\n            }\\\n          }\\\n        }\\\n        else {\\\n          if ((int)(uart_handle->Instance->SR << 0x18) < 0) {\\\n            uart_handle->Instance->DR = (uint8_t)*data;\\\n            data ++;\\\n          }\\\n        }\\\n      }\\\n      uart_instance = uart_handle->Instance;\\\n      uart_instance->CR1 &= 0xffffff7f;\\\n      uart_instance->CR1 &= 0xffffffdf;\\\n      uart_instance->CR1 &= 0xfffffeff;\\\n      uart_instance->CR3 &= 0xfffffffe;\\\n      uart_handle->State = HAL_UART_STATE_READY;\\\n      uart_handle->Lock = HAL_UNLOCKED;\\\n      return HAL_OK;\\\n    }\\\n  }\\\n  return HAL_BUSY;\\\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800277c",
            "calling": [
                "serialWrite"
            ],
            "imported": false,
            "current_name": "uart_transmit_0800277c"
        },
        "FUN_0800483c": {
            "renaming": {
                "FUN_0800483c": "calculate_pid_output_0800483c",
                "pid": "pid_instance",
                "input": "process_variable",
                "set_point": "desired_value",
                "offset": "offset_value",
                "error": "error_value",
                "instance": "pid_instance_type",
                "proportional": "proportional_term",
                "integral": "integral_term",
                "derivative": "derivative_term",
                "con_KP": "proportional_gain",
                "con_KI": "integral_gain",
                "con_KD": "derivative_gain",
                "direction": "output_direction",
                "output": "output_value",
                "last_input": "previous_input",
                "last_error": "previous_error",
                "last_time": "previous_time"
            },
            "code": "void calculate_pid_output_0800483c(PID_TypeDef *pid)\n{\n  float input = pid->input;\n  float set_point = pid->set_point;\n  float offset = pid->offset;\n  float error = set_point + offset - input;\n  pid->error = error;\n  if (pid->instance == 3) {\n    bool error_is_positive = error > 0;\n    bool error_is_small = error < DAT_08004974;\n    bool error_is_big = error > DAT_08004964;\n    if ((error_is_positive && error_is_big) || (!error_is_positive && error_is_small)) {\n      float proportional_term = pid->con_KP * error;\n      float integral_term = pid->con_KI * pid->integral;\n      float derivative_term = pid->con_KD * (input - pid->last_input);\n      float output = proportional_term + integral_term - derivative_term;\n      int direction = pid->direction;\n      if (output < DAT_0800496c) {\n        output = DAT_0800496c;\n      } else if (output > DAT_08004970) {\n        output = DAT_08004970;\n      }\n      pid->output = output * direction;\n      pid->last_input = input;\n      pid->last_error = error;\n      pid->last_time = pid->time;\n      return;\n    }\n  }\n  pid->integral += error;\n  if (pid->integral < DAT_0800496c) {\n    pid->integral = DAT_0800496c;\n  } else if (pid->integral > DAT_08004970) {\n    pid->integral = DAT_08004970;\n  }\n  pid->proportional = pid->con_KP * error;\n  pid->derivative = input - pid->last_input;\n  pid->output = pid->proportional + pid->con_KI * pid->integral - pid->con_KD * pid->derivative;\n  int direction = pid->direction;\n  if (pid->output < DAT_0800496c) {\n    pid->output = DAT_0800496c;\n  } else if (pid->output > DAT_08004970) {\n    pid->output = DAT_08004970;\n  }\n  pid->output *= direction;\n  pid->last_input = input;\n  pid->last_error = error;\n  pid->last_time = pid->time;\n}\n",
            "called": [
                "__aeabi_fmul",
                "__aeabi_fcmpgt",
                "__floatsisf",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fdiv",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800483c",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "calculate_pid_output_0800483c"
        },
        "FUN_08001064": {
            "renaming": {
                "FUN_08001064": "isEndOfString_08001064",
                "in_CY": "currentChar"
            },
            "code": "bool isEndOfString_08001064(void)\n{\n  char currentChar;\n  __aeabi_cfrcmple();\n  return currentChar == '\\0';\n}",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001064",
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "isEndOfString_08001064"
        },
        "FUN_08000892": {
            "renaming": {
                "FUN_08000892": "calculate_result_08000892",
                "param_1": "x",
                "param_2": "y",
                "param_3": "z",
                "param_4": "w",
                "uVar1": "bit",
                "unaff_r4": "z_copy",
                "uVar2": "mask",
                "uVar3": "temp",
                "in_r12": "constant",
                "bVar4": "is_zero",
                "carry": "carry",
                "LAB_08000704": "result_a",
                "LAB_080006c8": "result_b"
            },
            "code": "ulonglong calculate_result_08000892(uint x, uint y, uint z, uint w) {\n  uint mask = w >> 0x14;\n  uint temp = y;\n  if (x != z || mask != z) {\n    if (x == z) {\n      if (((x | (y << 0xc)) == 0) && (x = z, temp = w, mask != z)) {\n        return (ulonglong)((y ^ w) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (mask == z) {\n      x = z;\n      temp = w;\n      if ((z | (w << 0xc)) == 0) {\n        return (ulonglong)((y ^ w) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bool is_x_zero = (x | (y << 1)) == 0;\n      bool is_z_zero = (z | (w << 1)) == 0;\n      if (!is_x_zero) {\n        is_x_zero = is_z_zero;\n      }\n      if (!is_x_zero) {\n        if (x == 0) {\n          uint carry = y & 0x80000000;\n          do {\n            uint bit = x & 0x80000000;\n            x = x << 1;\n            y = y * 2 + (uint)(bit != 0);\n          } while ((y & 0x100000) == 0);\n          y = y | carry;\n          if (mask != 0) {\n            return CONCAT44(y, x);\n          }\n        }\n        do {\n          uint carry = z & 0x80000000;\n          z = z << 1;\n          w = w * 2 + (uint)(carry != 0);\n        } while ((w & 0x100000) == 0);\n        return CONCAT44(y, x);\n      }\n      if ((x | (y << 1)) != 0) goto LAB_08000704;\n      if ((z | (w << 1)) != 0) goto LAB_080006c8;\n    }\n  }\n  return CONCAT44(temp, x) | 0x7ff8000000000000;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000892",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "calculate_result_08000892"
        },
        "FUN_08004458": {
            "renaming": {
                "FUN_08004458": "copy_data_and_send_packet_08004458",
                "puVar1": "source_ptr",
                "puVar2": "temp1",
                "puVar3": "dest16_ptr",
                "puVar4": "dest_ptr",
                "puVar5": "end_ptr",
                "local_30": "local_buffer",
                "local_24": "local_buffer16"
            },
            "code": "void copy_data_and_send_packet_08004458(void)\n{\n  uint32_t *source_ptr;\n  uint32_t *dest_ptr;\n  uint32_t temp1, temp2;\n  uint32_t *end_ptr;\n  uint16_t *dest16_ptr;\n  uint32_t local_buffer[3];\n  uint16_t local_buffer16[10];\n  \n  source_ptr = local_buffer;\n  dest_ptr = (uint32_t *)PTR_msp_txf_pid_0800448c;\n  end_ptr = (uint32_t *)(PTR_msp_txf_pid_0800448c + 0x18);\n  while (dest_ptr != end_ptr)\n  {\n    temp1 = dest_ptr[0];\n    temp2 = dest_ptr[1];\n    *source_ptr++ = temp1;\n    *source_ptr++ = temp2 >> 16;\n    *source_ptr++ = temp2 & 0xFFFF;\n    dest_ptr += 2;\n  }\n  source_ptr[0] = dest_ptr[0];\n  dest16_ptr = (uint16_t *)(source_ptr + 1);\n  dest16_ptr[0] = (uint16_t)(dest_ptr + 2);\n  MSP_SendFrame('p', (uint8_t *)local_buffer, 0x1e);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004458",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "copy_data_and_send_packet_08004458"
        },
        "FUN_08004d48": {
            "renaming": {
                "FUN_08004d48": "configure_I2C_GPIO_pins_08004d48",
                "hi2c": "i2c_handle",
                "GPIO_InitStruct": "GPIO_init_struct",
                "DAT_08004d80": "I2C1",
                "DAT_08004d84": "GPIOB",
                "DAT_08004d88": "0x40022000"
            },
            "code": "void configure_I2C_GPIO_pins_08004d48(I2C_HandleTypeDef *i2c_handle)\n{\n  uint32_t tmp_reg;\n  GPIO_InitTypeDef GPIO_init_struct;\n  if (i2c_handle->Instance == DAT_08004d80) {\n    GPIO_init_struct.Pin = GPIO_PIN_6 | GPIO_PIN_7;\n    GPIO_init_struct.Mode = GPIO_MODE_AF_OD;\n    GPIO_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(DAT_08004d84, &GPIO_init_struct);\n    *(uint *)(DAT_08004d88 + 0x1c) = *(uint *)(DAT_08004d88 + 0x1c) | 0x200000;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d48",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "configure_I2C_GPIO_pins_08004d48"
        },
        "FUN_08002280": {
            "renaming": {
                "FUN_08002280": "configure_timer_08002280",
                "TIMx": "timer",
                "OC_Config": "output_config",
                "uVar1": "ccer_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode_value"
            },
            "code": "void configure_timer_08002280(TIM_TypeDef *timer,TIM_OC_InitTypeDef *output_config)\n{\n  uint32_t ccer_value;\n  uint32_t cr2_value;\n  uint oc_mode_value;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  cr2_value = timer->CR2;\n  oc_mode_value = output_config->OCMode;\n  ccer_value = timer->CCER & 0xfffffffd | output_config->OCPolarity;\n  if (timer == PTR_080022cc) {\n    ccer_value = (ccer_value & 0xfffffff7 | output_config->OCNPolarity) & 0xfffffffb;\n    cr2_value = cr2_value & 0xfffffcff | output_config->OCIdleState | output_config->OCNIdleState;\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | oc_mode_value;\n  timer->CCR1 = output_config->Pulse;\n  timer->CCER = ccer_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002280",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08002280"
        },
        "FUN_08001194": {
            "renaming": {
                "FUN_08001194": "set_interrupt_priority_08001194",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_num",
                "uVar2": "priority_value",
                "uVar3": "group_priority_bits",
                "uVar4": "priority_bits",
                "uVar5": "sub_priority_bits"
            },
            "code": "void set_interrupt_priority_08001194(IRQn_Type irq, uint32_t preempt_priority, uint32_t sub_priority)\n{\n    uint32_t irq_num = (uint32_t)irq;\n    uint32_t priority_bits = (*(int *)(DAT_080011f4 + 0xc) << 0x15) >> 0x1d;\n    uint32_t group_priority_bits = 7 - priority_bits;\n    uint32_t sub_priority_bits = priority_bits + 4;\n    if (group_priority_bits > 3) {\n        group_priority_bits = 4;\n    }\n    if (sub_priority_bits < 7) {\n        priority_bits = 0;\n    }\n    group_priority_bits = (1 << (group_priority_bits & 0xff)) - 1;\n    if (sub_priority_bits > 6) {\n        priority_bits = priority_bits - 3;\n    }\n    uint8_t priority_value = (uint8_t) ((sub_priority & (1 << (priority_bits & 0xff)) - 1U | (preempt_priority & group_priority_bits) << (priority_bits & 0xff)) << 4);\n    if (irq_num >= 0) {\n        uint32_t irq_addr = irq_num + 0xe000e100;\n        *(volatile uint8_t *)(irq_addr + 0x300) = priority_value;\n    }\n    else {\n        uint32_t offset = irq_num & 0xf;\n        uint32_t irq_addr = DAT_080011f8 + offset;\n        *(volatile uint8_t *)irq_addr = priority_value;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001194",
            "calling": [
                "HAL_InitTick",
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08001194"
        },
        "FUN_08004348": {
            "renaming": {
                "FUN_08004348": "send_identification_frame_08004348",
                "*puVar1": "msp_identification_frame",
                "local_10": "local_variable",
                "local_c": "local_c",
                "in_r1": "in_r1"
            },
            "code": "void send_identification_frame_08004348(void)\n{\n  uint8_t *msp_identification_frame = PTR_msp_txf_ident_08004380;\n  msp_identification_frame[0] = 0xe9;\n  msp_identification_frame[1] = 3;\n  msp_identification_frame[2] = 0;\n  msp_identification_frame[3] = 4;\n  *(uint32_t *)(msp_identification_frame + 4) = 0;\n  msp_identification_frame[8] = 0;\n  msp_identification_frame[9] = 0;\n  msp_identification_frame[10] = 0;\n  uint32_t local_variable = *(uint32_t *)msp_identification_frame;\n  uint32_t local_c = (in_r1 & 0xff000000) | *(uint16_t *)(msp_identification_frame + 4);\n  MSP_SendFrame('d', (uint8_t *)&local_variable, 11);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004348",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_identification_frame_08004348"
        },
        "FUN_08001078": {
            "renaming": {
                "FUN_08001078": "calculate_integer_from_param_08001078",
                "param_1": "param",
                "uVar1": "shift_amount",
                "uVar2": "inverse_shift_amount",
                "shifted_param": "shifted_param"
            },
            "code": "uint calculate_integer_from_param_08001078(uint param)\n{\n  uint shift_amount, inverse_shift_amount;\n  if (param << 1 < 0x7f000000) {\n    return 0;\n  }\n  shift_amount = (param << 1) >> 0x18;\n  inverse_shift_amount = 0x9e - shift_amount;\n  if (shift_amount < 0x9f && inverse_shift_amount != 0) {\n    uint shifted_param = (param << 8 | 0x80000000) >> (inverse_shift_amount & 0xff);\n    if ((param & 0x80000000) != 0) {\n      shifted_param = -shifted_param;\n    }\n    return shifted_param;\n  }\n  if ((inverse_shift_amount == 0xffffff9f) && ((param & 0x7fffff) != 0)) {\n    return 0;\n  }\n  param = param & 0x80000000;\n  if (param == 0) {\n    param = 0x7fffffff;\n  }\n  return param;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001078",
            "calling": [
                "MS5611_Update",
                "AHRS_ComputeAngles",
                "Motor_DistributeSpeed"
            ],
            "imported": false,
            "current_name": "calculate_integer_from_param_08001078"
        },
        "FUN_08001754": {
            "renaming": {
                "FUN_08001754": "configureI2C_08001754",
                "*hi2c": "*i2c",
                "uVar1": "pclkFreq",
                "extraout_r1": "prescaler",
                "uVar2": "ccrValue",
                "pIVar3": "i2cInstance",
                "uVar4": "clockSpeed",
                "uVar5": "DAT_08001820",
                "uVar6": "riseTime"
            },
            "code": "HAL_StatusTypeDef configureI2C_08001754(I2C_HandleTypeDef *i2c)\n{\n    uint32_t pclkFreq = HAL_RCC_GetPCLK1Freq();\n    uint32_t clockSpeed = (i2c->Init).ClockSpeed;\n    uint32_t prescaler = pclkFreq / 1000000;\n    uint32_t riseTime = (prescaler * 300) / 1000 + 1;\n    uint32_t ccrValue;\n    I2C_TypeDef *i2cInstance;\n\n    if (i2c == NULL) {\n        return HAL_ERROR;\n    }\n\n    if (i2c->State == HAL_I2C_STATE_RESET) {\n        i2c->Lock = HAL_UNLOCKED;\n        HAL_I2C_MspInit(i2c);\n    }\n\n    i2cInstance = i2c->Instance;\n    i2cInstance->CR1 &= ~(1);\n\n    if (clockSpeed <= 100000) {\n        ccrValue = pclkFreq / (clockSpeed << 1);\n        if (ccrValue < 4) {\n            ccrValue = 4;\n        }\n        i2cInstance->CCR = ccrValue;\n        i2cInstance->TRISE = riseTime;\n    }\n    else {\n        if ((i2c->Init).DutyCycle == I2C_DUTYCYCLE_2) {\n            ccrValue = pclkFreq / (clockSpeed * 3);\n        }\n        else {\n            ccrValue = pclkFreq / (clockSpeed * 25);\n            ccrValue |= 0x00008000;\n        }\n        i2cInstance->CCR = ccrValue;\n        i2cInstance->TRISE = (prescaler * 1000) / 333 + 1;\n    }\n\n    i2cInstance->OAR1 = (i2c->Init).AddressingMode | (i2c->Init).OwnAddress1;\n    i2cInstance->OAR2 = (i2c->Init).DualAddressMode | (i2c->Init).OwnAddress2;\n    i2cInstance->CR1 |= ((i2c->Init).GeneralCallMode | (i2c->Init).NoStretchMode);\n    i2c->ErrorCode = HAL_I2C_ERROR_NONE;\n    i2c->State = HAL_I2C_STATE_READY;\n    i2c->Mode = HAL_I2C_MODE_NONE;\n\n    return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001754",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configureI2C_08001754"
        },
        "FUN_08002724": {
            "renaming": {
                "FUN_08002724": "initialize_uart_08002724",
                "huart": "uart_handle",
                "pUVar1": "uart_instance"
            },
            "code": "HAL_StatusTypeDef initialize_uart_08002724(UART_HandleTypeDef *uart_handle)\n{\n  USART_TypeDef *uart_instance;\n  \n  if (uart_handle != NULL) {\n    if (uart_handle->State == HAL_UART_STATE_RESET) {\n      uart_handle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uart_handle);\n    }\n    uart_handle->State = HAL_UART_STATE_BUSY;\n    uart_handle->Instance->CR1 &= ~(1 << 13);\n    UART_SetConfig(uart_handle);\n    uart_instance = uart_handle->Instance;\n    uart_instance->CR2 &= ~(1 << 11);\n    uart_instance->CR3 &= ~(1 << 2);\n    uart_instance->CR1 |= (1 << 13);\n    uart_handle->ErrorCode = 0;\n    uart_handle->State = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002724",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "initialize_uart_08002724"
        },
        "FUN_080043f0": {
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "local_10": "motor_data1",
                "uStack_c": "motor_data2"
            },
            "code": "void send_motor_data_080043f0(void)\n{\n  uint32_t motor_data1 = *(uint32_t *)PTR_msp_txf_motor_0800440c;\n  uint32_t motor_data2 = *(uint32_t *)(PTR_msp_txf_motor_0800440c + 4);\n  MSP_SendFrame('h', (uint8_t *)&motor_data1, 8);\n  return;\n}",
            "called": [
                "MSP_SendFrame"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043f0",
            "calling": [
                "taskScheduler"
            ],
            "imported": false,
            "current_name": "send_motor_data_080043f0"
        },
        "FUN_08000428": {
            "renaming": {
                "FUN_08000428": "calculate_hash_08000428",
                "param_1": "input",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "iVar6": "leading_zeroes",
                "uVar7": "temp6",
                "in_r12": "temp7",
                "bVar8": "is_equal",
                "bVar9": "is_zero",
                "bVar10": "is_ff"
            },
            "code": "unsigned long long calculate_hash_08000428(uint32_t input, uint32_t param_2, uint32_t param_3, uint32_t param_4)\n{\n    uint32_t temp1, temp2, temp3, temp4, temp5, leading_zeroes;\n    bool is_zero, is_ff;\n    temp5 = input << 1;\n    is_zero = temp5 == 0;\n    temp1 = ((input & 0x80000000) != 0) << 0x1f;\n    temp4 = (uint32_t)((int32_t)temp5 >> 3) >> 1;\n    temp3 = temp1 | temp4;\n    input = input << 0x1d;\n    if (!is_zero) {\n        temp4 = temp5 & 0xff000000;\n        is_zero = temp4 == 0;\n    }\n    if (!is_zero) {\n        is_zero = temp4 == 0xff000000;\n    }\n    if (!is_zero) {\n        return ((unsigned long long)temp3 << 32) | input) ^ 0x3800000000000000;\n    }\n    if (temp5 == 0 || temp4 == 0xff000000) {\n        return ((unsigned long long)temp3 << 32) | input;\n    }\n    temp2 = input;\n    temp5 = temp4;\n    if (temp4 == 0) {\n        temp2 = 0;\n        temp5 = input;\n    }\n    leading_zeroes = count_leading_zeroes(temp5) + 0x20 * (temp4 == 0);\n    if (leading_zeroes < 0x20) {\n        temp4 = leading_zeroes - 0xb;\n        is_ff = temp4 < 0x20;\n        if (is_ff) {\n            temp1 = 0x20 - temp4;\n            temp5 <<= temp4;\n            temp5 |= temp2 >> (temp1 & 0xff);\n            temp2 <<= temp4;\n        }\n    }\n    else {\n        temp4 = ~(leading_zeroes - 0x380);\n        is_ff = temp4 < 0x1f;\n        if (is_ff) {\n            temp1 = temp4 - 0x13;\n            if (temp1 != 0 && (temp1 < 0) == ((temp4 - 0x1f) < 0xc)) {\n                return ((unsigned long long)temp3 << 32) | (temp2 >> (0x20 - (0xc - temp1)) | temp5 << (0xc - temp1));\n            }\n            temp4++;\n            return ((unsigned long long)temp1 | temp5 >> (temp4 & 0xff)) | (temp2 >> (temp4 & 0xff) | temp5 << (0x20 - temp4 & 0xff)));\n        }\n    }\n    return ((unsigned long long)temp3 << 32) | (temp5 + (0x380 - leading_zeroes) * 0x100000 | temp1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000428",
            "calling": [
                "MS5611_Update",
                "MadgwickQuaternionUpdate"
            ],
            "imported": false,
            "current_name": "calculate_hash_08000428"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "configure_interrupts_08004ccc",
                "tmpreg": "interrupt_enable_register",
                "priority_grouping": "priority_grouping",
                "MemoryManagement_IRQn": "MemoryManagement_IRQn",
                "BusFault_IRQn": "BusFault_IRQn",
                "UsageFault_IRQn": "UsageFault_IRQn",
                "SVCall_IRQn": "SVCall_IRQn",
                "DebugMonitor_IRQn": "DebugMonitor_IRQn",
                "PendSV_IRQn": "PendSV_IRQn",
                "SysTick_IRQn": "SysTick_IRQn"
            },
            "code": "void configure_interrupts_08004ccc(void)\n{\n  uint32_t interrupt_enable_register;\n  uint32_t priority_grouping = 3;\n  uint32_t priority = 0;\n\n  interrupt_enable_register = *(uint *)(DAT_08004d44 + 0x18);\n  interrupt_enable_register |= 1;\n  *(uint *)(DAT_08004d44 + 0x18) = interrupt_enable_register;\n\n  HAL_NVIC_SetPriorityGrouping(priority_grouping);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, priority, 0);\n  HAL_NVIC_SetPriority(BusFault_IRQn, priority, 0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn, priority, 0);\n  HAL_NVIC_SetPriority(SVCall_IRQn, priority, 0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, priority, 0);\n  HAL_NVIC_SetPriority(PendSV_IRQn, priority, 0);\n  HAL_NVIC_SetPriority(SysTick_IRQn, priority, 0);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configure_interrupts_08004ccc"
        },
        "FUN_08004c30": {
            "renaming": {
                "FUN_08004c30": "receive_uart_data_08004c30",
                "*huart": "*uart_handle",
                "pData": "rx_buffer_ptr",
                "PTR_rx_buffer_08004c58": "rx_buffer_start",
                "DAT_08004c54": "uart_instance_1",
                "PTR_rxc_08004c5c": "rx_circular_buffer",
                "HAL_UART_Receive_IT": "HAL_UART_Receive_IT",
                "*PTR_huart1_08004c60": "*uart_handle_1"
            },
            "code": "void receive_uart_data_08004c30(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t *rx_buffer_ptr;\n  rx_buffer_ptr = PTR_rx_buffer_08004c58;\n  if (uart_handle->Instance == DAT_08004c54) {\n    circular_buffer_write(&PTR_rxc_08004c5c, *PTR_rx_buffer_08004c58);\n    HAL_UART_Receive_IT(uart_handle_1, rx_buffer_ptr, 1);\n    return;\n  }\n  return;\n}",
            "called": [
                "CB_Write",
                "HAL_UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c30",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "receive_uart_data_08004c30"
        },
        "FUN_080004d0": {
            "renaming": {
                "FUN_080004d0": "calculate_double_080004d0",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "iVar5": "result5",
                "uVar6": "result6",
                "unaff_r5": "result7",
                "uVar7": "result8",
                "uVar8": "result9",
                "bVar9": "bool1",
                "bVar10": "bool2",
                "bVar11": "bool3",
                "uVar12": "result10"
            },
            "code": "\nulonglong calculate_double_080004d0(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint result3;\n  uint result4;\n  int result5;\n  uint result6;\n  uint result7;\n  uint result8;\n  uint result9;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  ulonglong result10;\n  \n  result10 = CONCAT44(value2,value1);\n  result8 = 0x7ff;\n  result4 = value2 >> 0x14 & 0x7ff;\n  bool1 = result4 == 0;\n  if (!bool1) {\n    result7 = value4 >> 0x14 & 0x7ff;\n    bool1 = result7 == 0;\n  }\n  if (!bool1) {\n    bool1 = result4 == 0x7ff;\n  }\n  if (!bool1) {\n    bool1 = result7 == 0x7ff;\n  }\n  if (bool1) {\n    result10 = convert_bits_to_double_080006ac();\n  }\n  result3 = (uint)(result10 >> 0x20);\n  result5 = result4 + result7;\n  result4 = result3 ^ value4;\n  result3 = result3 & ~(result8 << 0x15);\n  value4 = value4 & ~(result8 << 0x15);\n  bool1 = ((uint)result10 | result3 << 0xc) == 0;\n  if (!bool1) {\n    bool1 = (value3 | value4 << 0xc) == 0;\n  }\n  result3 = result3 | 0x100000;\n  value4 = value4 | 0x100000;\n  if (bool1) {\n    value3 = (uint)result10 | value3;\n    value4 = (result4 & 0x80000000 | result3) ^ value4;\n    result4 = result8 >> 1;\n    bool3 = SBORROW4(result5,result4);\n    result6 = result5 - result4;\n    bool1 = result6 == 0;\n    result3 = result6;\n    if (!bool1 && (int)result4 <= result5) {\n      bool3 = SBORROW4(result8,result6);\n      result3 = result8 - result6;\n      bool1 = result8 == result6;\n    }\n    if (!bool1 && (int)result3 < 0 == bool3) {\n      value4 = value4 | result6 * 0x100000;\n    }\n    if (!bool1 && (int)result3 < 0 == bool3) {\n      return CONCAT44(value4,value3);\n    }\n    value4 = value4 | 0x100000;\n    result8 = 0;\n    bool3 = SBORROW4(result6,1);\n    result6 = result6 - 1;\n    bool1 = result6 == 0;\n    result4 = result6;\n  }\n  else {\n    result1 = (result10 & 0xffffffff) * (ulonglong)value3;\n    result10 = (result10 & 0xffffffff) * (ulonglong)value4 +\n             (ulonglong)result3 * (ulonglong)value3 + (result1 >> 0x20);\n    result9 = (uint)result10;\n    result2 = (ulonglong)result3 * (ulonglong)value4 + (result10 >> 0x20);\n    result8 = (uint)result2;\n    result3 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      result9 = result9 | 1;\n    }\n    result6 = (result5 + -0x3ff) - (uint)(result3 < 0x200);\n    if (result3 < 0x200) {\n      bool1 = (result9 & 0x80000000) != 0;\n      result9 = result9 << 1;\n      result2 = CONCAT44(result3 * 2 + (uint)(CARRY4(result8,result8) || CARRY4(result8 * 2,(uint)bool1)),\n                       result8 * 2 + (uint)bool1);\n    }\n    value4 = result4 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    value3 = (uint)result2 << 0xb | result9 >> 0x15;\n    result8 = result9 * 0x800;\n    bool2 = 0xfc < result6;\n    bool3 = SBORROW4(result6,0xfd);\n    result3 = result6 - 0xfd;\n    bool1 = result3 == 0;\n    result4 = result3;\n    if (bool2 && !bool1) {\n      bool2 = 0x6ff < result3;\n      bool3 = SBORROW4(result3,0x700);\n      result4 = result6 - 0x7fd;\n      bool1 = result3 == 0x700;\n    }\n    if (!bool2 || bool1) {\n      bool1 = 0x7fffffff < result8;\n      if (result8 == 0x80000000) {\n        bool1 = (result9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(value4 + result6 * 0x100000 + (uint)CARRY4(value3,(uint)bool1),value3 + bool1\n                     );\n    }\n  }\n  if (!bool1 && (int)result4 < 0 == bool3) {\n    return (ulonglong)(value4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bool2 = SCARRY4(result6,0x36);\n  bool1 = (int)(result6 + 0x36) < 0;\n  bool3 = result6 == 0xffffffca;\n  if (bool3 || bool1 != bool2) {\n    value3 = 0;\n  }\n  if (bool3 || bool1 != bool2) {\n    value4 = value4 & 0x80000000;\n  }\n  if (bool3 || bool1 != bool2) {\n    return CONCAT44(value4,value3);\n  }\n  result4 = -result6;\n  result3 = result4 - 0x20;\n  if (0x1f < (int)result4) {\n    result6 = value3 >> (result3 & 0xff) | value4 << (0x20 - result3 & 0xff);\n    result4 = (value4 >> (result3 & 0xff) & ~((value4 & 0x80000000) >> (result3 & 0xff))) -\n            ((int)result6 >> 0x1f);\n    if ((result8 | value3 << (0x20 - result3 & 0xff) | result6 << 1) == 0) {\n      result4 = result4 & ~(result6 >> 0x1f);\n    }\n    return CONCAT44(value4,result4) & 0x80000000ffffffff;\n  }\n  result5 = result4 - 0x14;\n  if (result5 == 0 || result5 < 0 != SCARRY4(result3,0xc)) {\n    result9 = value3 << (result6 + 0x20 & 0xff);\n    result3 = value3 >> (result4 & 0xff) | value4 << (result6 + 0x20 & 0xff);\n    result6 = result3 + -((int)result9 >> 0x1f);\n    if ((result8 | result9 << 1) == 0) {\n      result6 = result6 & ~(result9 >> 0x1f);\n    }\n    return CONCAT44((value4 & 0x80000000) +\n                    ((value4 & 0x7fffffff) >> (result4 & 0xff)) +\n                    (uint)CARRY4(result3,-((int)result9 >> 0x1f)),result6);\n  }\n  result4 = 0xc - result5;\n  result6 = value3 << (result4 & 0xff);\n  result4 = value3 >> (0x20 - result4 & 0xff) | value4 << (result4 & 0xff);\n  result3 = result4 + -((int)result6 >> 0x1f);\n  if ((result8 | result6 << 1) == 0) {\n    result3 = result3 & ~(result6 >> 0x1f);\n  }\n  return CONCAT44((value4 & 0x80000000) + (uint)CARRY4(result4,-((int)result6 >> 0x1f)),result3);\n}\n\n",
            "called": [
                "FUN_080006ac"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004d0",
            "calling": [
                "MS5611_Update",
                "scalbn",
                "MadgwickQuaternionUpdate",
                "__ieee754_sqrt",
                "atan",
                "pow",
                "__ieee754_asin",
                "__ieee754_pow"
            ],
            "imported": false,
            "current_name": "calculate_double_080004d0"
        },
        "FUN_0800729c": {
            "renaming": {
                "FUN_0800729c": "calculate_distance_0800729c",
                "__x": "x1",
                "__y": "y1",
                "in_d0": "distance"
            },
            "code": "double calculate_distance_0800729c(double x1, double y1, double x2, double y2)\n{\n  double distance;\n  distance = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2));\n  return distance;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800729c",
            "calling": [
                "scalbn"
            ],
            "imported": false,
            "current_name": "calculate_distance_0800729c"
        },
        "FUN_080041ae": {
            "renaming": {
                "FUN_080041ae": "runForkserverAndScheduleTasks_080041ae",
                "setup": "setupTasks",
                "taskScheduler": "runScheduledTasks"
            },
            "code": "int runForkserverAndScheduleTasks_080041ae(void)\n{\n  startForkserver(0);\n  setupTasks();\n  do {\n    HAL_IncTick();\n    runScheduledTasks();\n  } while( true );\n}",
            "called": [
                "HAL_IncTick",
                "setup",
                "taskScheduler",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041ae",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "runForkserverAndScheduleTasks_080041ae"
        },
        "FUN_080053d4": {
            "renaming": {
                "FUN_080053d4": "print_formatted_string_080053d4",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "width",
                "param_4": "print_func",
                "param_5": "args",
                "bVar1": "format_char",
                "iVar2": "result",
                "puVar3": "arg",
                "pvVar4": "end_of_string",
                "iVar5": "bytes_written",
                "puVar6": "hex_digits",
                "uVar7": "format_flags",
                "uVar9": "arg_value",
                "uVar10": "base",
                "puVar11": "digits",
                "__s": "formatted_string",
                "local_24": "field_width_and_precision"
            },
            "code": "\nuint print_formatted_string_080053d4(undefined4 stream,uint *format,undefined4 width,code *print_func,uint **args)\n\n{\n  byte format_char;\n  int result;\n  uint *arg;\n  void *end_of_string;\n  int bytes_written;\n  undefined *hex_digits;\n  uint format_flags;\n  uint **ppuVar8;\n  uint arg_value;\n  uint base;\n  undefined *digits;\n  undefined *formatted_string;\n  uint field_width_and_precision [2];\n  \n  format_char = *(byte *)(format + 6);\n  formatted_string = (undefined *)((int)format + 0x43);\n  if (format_char != 0x6e) {\n    if (format_char < 0x6f) {\n      if (format_char != 99) {\n        if (format_char < 100) {\n          if (format_char == 0) goto LAB_0800558e;\n          if (format_char != 0x58) goto LAB_08005404;\n          *(undefined *)((int)format + 0x45) = 0x58;\n          hex_digits = PTR_s_0123456789ABCDEF_08005610;\nLAB_0800551e:\n          format_flags = *format;\n          arg = *args;\n          *args = arg + 1;\n          if (((format_flags & 0x80) == 0) && ((int)(format_flags << 0x19) < 0)) {\n            arg_value = (uint)*(ushort *)arg;\n          }\n          else {\n            arg_value = *arg;\n          }\n          if ((int)(format_flags << 0x1f) < 0) {\n            *format = format_flags | 0x20;\n          }\n          if (arg_value == 0) {\n            *format = *format & 0xffffffdf;\n          }\n          format_flags = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)format + 0x43) = 0;\n        }\n        else {\n          if ((format_char != 100) && (format_char != 0x69)) goto LAB_08005404;\n          arg_value = *format;\n          arg = *args;\n          if ((arg_value & 0x80) == 0) {\n            *args = arg + 1;\n            if ((arg_value & 0x40) == 0) goto LAB_08005424;\n            arg_value = (uint)(short)*(ushort *)arg;\n          }\n          else {\n            *args = arg + 1;\nLAB_08005424:\n            arg_value = *arg;\n          }\n          if ((int)arg_value < 0) {\n            arg_value = -arg_value;\n            *(undefined *)((int)format + 0x43) = 0x2d;\n          }\n          format_flags = 10;\n          hex_digits = PTR_s_0123456789ABCDEF_08005610;\n        }\n        base = format[1];\n        format[2] = base;\n        digits = formatted_string;\n        if ((int)base < 0) {\n          if (arg_value != 0) goto LAB_08005552;\nLAB_08005600:\n          *(undefined *)((int)format + 0x42) = *hex_digits;\n          digits = (undefined *)((int)format + 0x42);\n        }\n        else {\n          *format = *format & 0xfffffffb;\n          if (arg_value == 0) {\n            if (base != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              base = arg_value / format_flags;\n              digits = digits + -1;\n              *digits = hex_digits[arg_value - format_flags * base];\n              arg_value = base;\n            } while (base != 0);\n          }\n        }\n        if (((format_flags == 8) && ((int)(*format << 0x1f) < 0)) && ((int)format[1] <= (int)format[4]))\n        {\n          digits[-1] = 0x30;\n          digits = digits + -1;\n        }\n        format[4] = (int)formatted_string - (int)digits;\n        formatted_string = digits;\n        goto LAB_080054fa;\n      }\n      arg = *args;\n      *args = arg + 1;\n      *(char *)((int)format + 0x42) = (char)*arg;\nLAB_08005464:\n      formatted_string = (undefined *)((int)format + 0x42);\n      arg_value = 1;\n    }\n    else {\n      if (format_char != 0x73) {\n        if (format_char < 0x74) {\n          if (format_char == 0x6f) {\nLAB_0800548a:\n            arg_value = *format;\n            arg = *args;\n            if ((arg_value & 0x80) == 0) {\n              *args = arg + 1;\n              if ((arg_value & 0x40) == 0) goto LAB_08005498;\n              arg_value = (uint)*(ushort *)arg;\n            }\n            else {\n              *args = arg + 1;\nLAB_08005498:\n              arg_value = *arg;\n            }\n            hex_digits = PTR_s_0123456789ABCDEF_08005610;\n            if (format_char == 0x6f) {\n              format_flags = 8;\n            }\n            else {\n              format_flags = 10;\n            }\n            goto LAB_080054b4;\n          }\n          if (format_char == 0x70) {\n            *format = *format | 0x20;\nLAB_0800544a:\n            hex_digits = PTR_s_0123456789abcdef_0800560c;\n            *(undefined *)((int)format + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (format_char == 0x75) goto LAB_0800548a;\n          if (format_char == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)format + 0x42) = format_char;\n        goto LAB_08005464;\n      }\n      arg = *args;\n      *args = arg + 1;\n      formatted_string = (undefined *)*arg;\n      end_of_string = memchr(formatted_string,0,format[1]);\n      if (end_of_string != (void *)0x0) {\n        format[1] = (int)end_of_string - (int)formatted_string;\n      }\n      arg_value = format[1];\n    }\n    format[4] = arg_value;\n    *(undefined *)((int)format + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  arg_value = *format;\n  ppuVar8 = (uint **)*args;\n  format_flags = format[5];\n  if ((arg_value & 0x80) == 0) {\n    *args = (uint *)(ppuVar8 + 1);\n    arg = *ppuVar8;\n    if ((arg_value & 0x40) == 0) goto LAB_0800557a;\n    *(short *)arg = (short)format_flags;\n  }\n  else {\n    *args = (uint *)(ppuVar8 + 1);\n    arg = *ppuVar8;\nLAB_0800557a:\n    *arg = format_flags;\n  }\nLAB_0800558e:\n  format[4] = 0;\nLAB_080054fa:\n  result = _printf_common(stream,format,field_width_and_precision,width,print_func);\n  if ((result == -1) || (result = (*print_func)(stream,width,formatted_string,format[4]), result == -1)) {\nLAB_0800550e:\n    arg_value = 0xffffffff;\n  }\n  else {\n    if ((int)(*format << 0x1e) < 0) {\n      for (result = 0; result < (int)(format[3] - field_width_and_precision[0]); result = result + 1) {\n        bytes_written = (*print_func)(stream,width,(int)format + 0x19,1);\n        if (bytes_written == -1) goto LAB_0800550e;\n      }\n    }\n    arg_value = format[3];\n    if ((int)format[3] < (int)field_width_and_precision[0]) {\n      arg_value = field_width_and_precision[0];\n    }\n  }\n  return arg_value;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053d4",
            "calling": [
                "_svfiprintf_r"
            ],
            "imported": false,
            "current_name": "print_formatted_string_080053d4"
        },
        "FUN_080041c4": {
            "renaming": {
                "FUN_080041c4": "stop_motors_080041c4",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void stop_motors_080041c4(void)\n{\n  Motor1_SetPWM(0);\n  Motor2_SetPWM(0);\n  Motor3_SetPWM(0);\n  Motor4_SetPWM(0);\n  return;\n}",
            "called": [
                "Motor2_SetPWM",
                "Motor1_SetPWM",
                "Motor4_SetPWM",
                "Motor3_SetPWM"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041c4",
            "calling": [
                "PID_Update"
            ],
            "imported": false,
            "current_name": "stop_motors_080041c4"
        },
        "FUN_0800567c": {
            "renaming": {
                "FUN_0800567c": "allocate_memory_0800567c",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "pointer",
                "extraout_r1": "next",
                "ppiVar2": "next",
                "ppiVar3": "next_block",
                "piVar4": "block",
                "ppiVar5": "free_list",
                "ppiVar6": "prev_free_list",
                "ppiVar7": "current"
            },
            "code": "void allocate_memory_0800567c(int* error_code, int size, int arg3, int arg4)\n{\n  int **free_list;\n  int **prev_free_list;\n  int **current;\n  int *block;\n  \n  if (size == 0) {\n    return;\n  }\n  current = (int **)(size - 4);\n  if (*(int *)(size - 4) < 0) {\n    current = (int **)((int)current + *(int *)(size - 4));\n  }\n  __malloc_lock();\n  prev_free_list = PTR___malloc_free_list_08005710;\n  free_list = *(int ***)PTR___malloc_free_list_08005710;\n  if (free_list == (int **)0x0) {\n    current[1] = (int *)0x0;\n    *(int ***)prev_free_list = current;\n    current = error_code;\n  }\n  else if (current < free_list) {\n    int **next = (int **)*current;\n    int **next_block = (int **)((int)current + (int)next);\n    if (free_list == next_block) {\n      block = *free_list;\n      free_list = (int **)free_list[1];\n      next_block = (int **)((int)block + (int)next);\n      *current = (int *)next_block;\n    }\n    current[1] = (int *)free_list;\n    *(int ***)prev_free_list = current;\n  }\n  else {\n    do {\n      prev_free_list = free_list;\n      int **next = (int **)free_list[1];\n      if (next == (int **)0x0) break;\n      free_list = next;\n    } while (free_list <= current);\n    int **next = (int **)*prev_free_list;\n    if ((int **)((int)prev_free_list + (int)next) == current) {\n      next = (int **)((int)next + (int)*current);\n      *prev_free_list = (int *)next;\n      if (next_block == (int **)((int)prev_free_list + (int)next)) {\n        block = *next_block;\n        next_block = (int **)next_block[1];\n        next = (int **)((int)next + (int)block);\n        *prev_free_list = (int *)next;\n        prev_free_list[1] = (int *)next_block;\n      }\n    }\n    else if (current < (int **)((int)prev_free_list + (int)next)) {\n      *error_code = 0xc;\n    }\n    else {\n      next = (int **)((int)current + (int)*current);\n      if (next_block == next) {\n        block = *next_block;\n        next_block = (int **)next_block[1];\n        next = (int **)((int)block + (int)*current);\n        *current = (int *)next;\n      }\n      current[1] = (int *)next_block;\n      prev_free_list[1] = (int *)current;\n    }\n  }\n  __malloc_unlock(error_code, next, next_block, arg4);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800567c",
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_0800567c"
        },
        "FUN_0800458c": {
            "renaming": {
                "FUN_0800458c": "initialize_peripherals_0800458c",
                "GPIOx": "gpio_port",
                "uVar1": "i2c_timing",
                "huart": "uart_handle",
                "HVar2": "hal_status",
                "uVar4": "status",
                "iVar5": "error_code",
                "uVar6": "pwm_output",
                "tmpreg": "temp_register",
                "tmpreg_1": "temp_register_1",
                "tmpreg_2": "temp_register_2",
                "sMasterConfig": "master_config",
                "sConfigOC": "output_config",
                "GPIO_InitStruct": "gpio_init",
                "puVar3": "peripheral_handle"
            },
            "code": "\nvoid initialize_peripherals_0800458c(void)\n\n{\n  GPIO_TypeDef *gpio_port;\n  undefined4 i2c_timing;\n  undefined *uart_handle;\n  HAL_StatusTypeDef hal_status;\n  uint status;\n  int error_code;\n  uint pwm_output;\n  uint32_t temp_register;\n  uint32_t temp_register_1;\n  uint32_t temp_register_2;\n  TIM_MasterConfigTypeDef master_config;\n  TIM_OC_InitTypeDef output_config;\n  GPIO_InitTypeDef gpio_init;\n  undefined *peripheral_handle;\n  \n  HAL_Init();\n  SystemClock_Config();\n  gpio_port = DAT_08004800;\n  error_code = DAT_080047fc;\n  *(uint *)(DAT_080047fc + 0x18) = *(uint *)(DAT_080047fc + 0x18) | 0x10;\n  pwm_output = 2;\n  *(uint *)(error_code + 0x18) = *(uint *)(error_code + 0x18) | 4;\n  i2c_timing = DAT_08004804;\n  *(uint *)(error_code + 0x18) = *(uint *)(error_code + 0x18) | 8;\n  HAL_GPIO_WritePin(gpio_port,0xe000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin(DAT_08004808,0x20,GPIO_PIN_RESET);\n  gpio_init.Pin = 0xe000;\n  gpio_init.Mode = 1;\n  gpio_init.Speed = 2;\n  HAL_GPIO_Init(DAT_08004800,&gpio_init);\n  gpio_init.Pin = 0x20;\n  gpio_init.Mode = 1;\n  gpio_init.Speed = 2;\n  HAL_GPIO_Init(DAT_08004808,&gpio_init);\n  peripheral_handle = PTR_hi2c1_0800480c;\n  *(undefined4 *)PTR_hi2c1_0800480c = DAT_08004810;\n  *(undefined4 *)(peripheral_handle + 4) = i2c_timing;\n  *(undefined4 *)(peripheral_handle + 0x10) = 0x4000;\n  *(undefined4 *)(peripheral_handle + 8) = 0;\n  *(undefined4 *)(peripheral_handle + 0xc) = 0;\n  *(undefined4 *)(peripheral_handle + 0x14) = 0;\n  *(undefined4 *)(peripheral_handle + 0x18) = 0;\n  *(undefined4 *)(peripheral_handle + 0x1c) = 0;\n  *(undefined4 *)(peripheral_handle + 0x20) = 0;\n  hal_status = HAL_I2C_Init((I2C_HandleTypeDef *)peripheral_handle);\n  peripheral_handle = (undefined *)(uint)hal_status;\n  if (peripheral_handle == (undefined *)0x0) goto LAB_0800463a;\n  error_code = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  peripheral_handle = PTR_s____Src_peripherals_c_08004814;\n                                  _Error_Handler(PTR_s____Src_peripherals_c_08004814,error_code);\nLAB_0800463a:\n                                  i2c_timing = DAT_0800481c;\n                                  uart_handle = PTR_uart_handle1_08004818;\n                                  *(undefined **)(PTR_uart_handle1_08004818 + 8) = peripheral_handle;\n                                  *(undefined **)(uart_handle + 0xc) = peripheral_handle;\n                                  *(undefined **)(uart_handle + 0x10) = peripheral_handle;\n                                  *(undefined **)(uart_handle + 0x18) = peripheral_handle;\n                                  *(undefined **)(uart_handle + 0x1c) = peripheral_handle;\n                                  *(undefined4 *)uart_handle = i2c_timing;\n                                  *(undefined4 *)(uart_handle + 4) = 0x1c200;\n                                  *(undefined4 *)(uart_handle + 0x14) = 0xc;\n                                  hal_status = HAL_UART_Init((UART_HandleTypeDef *)uart_handle);\n                                  i2c_timing = DAT_08004824;\n                                  peripheral_handle = PTR_htim1_08004820;\n                                  if (hal_status == HAL_OK) break;\n                                  error_code = 0x151;\n                                }\n                                *(undefined4 *)(PTR_htim1_08004820 + 8) = 0;\n                                *(undefined4 *)(peripheral_handle + 0x10) = 0;\n                                *(undefined4 *)(peripheral_handle + 0x14) = 0;\n                                *(undefined4 *)peripheral_handle = i2c_timing;\n                                *(uint *)(peripheral_handle + 4) = pwm_output;\n                                *(undefined4 *)(peripheral_handle + 0xc) = 1000;\n                                hal_status = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)peripheral_handle);\n                                status = (uint)hal_status;\n                                if (status == 0) break;\n                                error_code = 0x88;\n                              }\n                              master_config.MasterOutputTrigger = status;\n                              master_config.MasterSlaveMode = status;\n                              hal_status = HAL_TIMEx_MasterConfigSynchronization\n                                                ((TIM_HandleTypeDef *)peripheral_handle,&master_config);\n                              status = (uint)hal_status;\n                              if (status == 0) break;\n                              error_code = 0x8f;\n                            }\n                            output_config.OCMode = 0x60;\n                            output_config.Pulse = status;\n                            output_config.OCPolarity = status;\n                            output_config.OCFastMode = status;\n                            output_config.OCIdleState = status;\n                            output_config.OCNIdleState = status;\n                            hal_status = HAL_TIM_PWM_ConfigChannel\n                                              ((TIM_HandleTypeDef *)peripheral_handle,&output_config,0xc);\n                            status = (uint)hal_status;\n                            if (status == 0) break;\n                            error_code = 0x9a;\n                          }\n                          gpio_init.Pin = status;\n                          gpio_init.Mode = status;\n                          gpio_init.Pull = status;\n                          gpio_init.Speed = status;\n                          hal_status = HAL_TIMEx_ConfigBreakDeadTime\n                                            ((TIM_HandleTypeDef *)peripheral_handle,\n                                             (TIM_BreakDeadTimeConfigTypeDef *)&gpio_init);\n                          if (hal_status == HAL_OK) break;\n                          error_code = 0xa6;\n                        }\n                        HAL_TIM_MspPostInit((TIM_HandleTypeDef *)peripheral_handle);\n                        peripheral_handle = PTR_htim2_08004828;\n                        *(undefined4 *)PTR_htim2_08004828 = 0x40000000;\n                        *(uint *)(peripheral_handle + 4) = pwm_output;\n                        *(undefined4 *)(peripheral_handle + 8) = 0;\n                        *(undefined4 *)(peripheral_handle + 0xc) = 1000;\n                        *(undefined4 *)(peripheral_handle + 0x10) = 0;\n                        hal_status = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)peripheral_handle);\n                        status = (uint)hal_status;\n                        if (status == 0) break;\n                        error_code = 0xc3;\n                      }\n                      output_config.OCMode = status;\n                      output_config.Pulse = status;\n                      hal_status = HAL_TIMEx_MasterConfigSynchronization\n                                        ((TIM_HandleTypeDef *)peripheral_handle,\n                                         (TIM_MasterConfigTypeDef *)&output_config);\n                      status = (uint)hal_status;\n                      if (status == 0) break;\n                      error_code = 0xca;\n                    }\n                    gpio_init.Pin = 0x60;\n                    gpio_init.Mode = status;\n                    gpio_init.Pull = status;\n                    hal_status = HAL_TIM_PWM_ConfigChannel\n                                      ((TIM_HandleTypeDef *)peripheral_handle,\n                                       (TIM_OC_InitTypeDef *)&gpio_init,4);\n                    if (hal_status == HAL_OK) break;\n                    error_code = 0xd3;\n                  }\n                  HAL_TIM_MspPostInit((TIM_HandleTypeDef *)peripheral_handle);\n                  i2c_timing = DAT_08004830;\n                  peripheral_handle = PTR_htim3_0800482c;\n                  *(undefined4 *)(PTR_htim3_0800482c + 0xc) = 1000;\n                  *(undefined4 *)peripheral_handle = i2c_timing;\n                  *(uint *)(peripheral_handle + 4) = pwm_output;\n                  *(undefined4 *)(peripheral_handle + 8) = 0;\n                  *(undefined4 *)(peripheral_handle + 0x10) = 0;\n                  hal_status = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)peripheral_handle);\n                  if (hal_status == HAL_OK) break;\n                  error_code = 0xf0;\n                }\n                output_config.OCMode = 0;\n                output_config.Pulse = 0;\n                hal_status = HAL_TIMEx_MasterConfigSynchronization\n                                  ((TIM_HandleTypeDef *)PTR_htim3_0800482c,\n                                   (TIM_MasterConfigTypeDef *)&output_config);\n                status = (uint)hal_status;\n                if (status == 0) break;\n                error_code = 0xf7;\n              }\n              gpio_init.Pin = 0x60;\n              gpio_init.Mode = status;\n              gpio_init.Pull = status;\n              hal_status = HAL_TIM_PWM_ConfigChannel\n                                ((TIM_HandleTypeDef *)PTR_htim3_0800482c,\n                                 (TIM_OC_InitTypeDef *)&gpio_init,8);\n              if (hal_status == HAL_OK) break;\n              error_code = 0x100;\n            }\n            hal_status = HAL_TIM_PWM_ConfigChannel\n                              ((TIM_HandleTypeDef *)PTR_htim3_0800482c,\n                               (TIM_OC_InitTypeDef *)&gpio_init,0xc);\n            pwm_output = (uint)hal_status;\n            if (pwm_output == 0) break;\n            error_code = 0x105;\n          }\n          HAL_TIM_MspPostInit((TIM_HandleTypeDef *)PTR_htim3_0800482c);\n          peripheral_handle = PTR_htim4_08004834;\n          *(undefined4 *)PTR_htim4_08004834 = DAT_08004838;\n          *(undefined4 *)(peripheral_handle + 4) = 2;\n          *(undefined4 *)(peripheral_handle + 8) = 0;\n          *(undefined4 *)(peripheral_handle + 0xc) = 1000;\n          *(undefined4 *)(peripheral_handle + 0x10) = 0;\n          hal_status = HAL_TIM_PWM_Init((TIM_HandleTypeDef *)peripheral_handle);\n          status = (uint)hal_status;\n          if (status == 0) break;\n          error_code = 0x122;\n        }\n        output_config.OCMode = status;\n        output_config.Pulse = status;\n        hal_status = HAL_TIMEx_MasterConfigSynchronization\n                          ((TIM_HandleTypeDef *)peripheral_handle,(TIM_MasterConfigTypeDef *)&output_config);\n        status = (uint)hal_status;\n        if (status == 0) break;\n        error_code = 0x129;\n      }\n      gpio_init.Pin = 0x60;\n      gpio_init.Mode = status;\n      gpio_init.Pull = status;\n      hal_status = HAL_TIM_PWM_ConfigChannel\n                        ((TIM_HandleTypeDef *)peripheral_handle,(TIM_OC_InitTypeDef *)&gpio_init,8);\n      if (hal_status == HAL_OK) break;\n      error_code = 0x132;\n    }\n    hal_status = HAL_TIM_PWM_ConfigChannel\n                      ((TIM_HandleTypeDef *)peripheral_handle,(TIM_OC_InitTypeDef *)&gpio_init,0xc);\n    if (hal_status == HAL_OK) break;\n    error_code = 0x137;\n  }\n  HAL_TIM_MspPostInit((TIM_HandleTypeDef *)peripheral_handle);\n  return;\n}\n\n",
            "called": [
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_I2C_Init",
                "_Error_Handler",
                "HAL_GPIO_Init",
                "HAL_Init",
                "HAL_TIM_MspPostInit",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_PWM_ConfigChannel",
                "SystemClock_Config",
                "HAL_UART_Init",
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800458c",
            "calling": [
                "Devices_Init"
            ],
            "imported": false,
            "current_name": "initialize_peripherals_0800458c"
        },
        "FUN_08000ffc": {
            "renaming": {
                "FUN_08000ffc": "compare_floats_08000ffc",
                "param_1": "float1",
                "param_2": "float2"
            },
            "code": "void compare_floats_08000ffc(float float1, float float2) {\n  __aeabi_cfcmpeq(float2, float1);\n  return;\n}",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000ffc",
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "imported": false,
            "current_name": "compare_floats_08000ffc"
        },
        "FUN_080016f4": {
            "renaming": {
                "FUN_080016f4": "I2C_Wait_For_Event_080016f4",
                "*hi2c": "*i2c_handler",
                "Timeout": "timeout_ms",
                "uVar1": "start_time_ms",
                "uVar2": "current_time_ms",
                "*pIVar3": "*i2c_instance"
            },
            "code": "HAL_StatusTypeDef I2C_Wait_For_Event_080016f4(I2C_HandleTypeDef *i2c_handler, uint32_t timeout_ms) {\n    uint32_t start_time_ms = HAL_GetTick();\n    while(true) {\n        I2C_TypeDef *i2c_instance = i2c_handler->Instance;\n        if ((i2c_instance->SR1 & I2C_SR1_BTF) != 0) {\n            return HAL_OK;\n        }\n        if ((int)(i2c_instance->SR1 << 0x1b) < 0) {\n            break;\n        }\n        if ((timeout_ms > 0) && (HAL_GetTick() - start_time_ms > timeout_ms)) {\n            i2c_handler->ErrorCode |= I2C_ERROR_TIMEOUT;\n            i2c_handler->State = HAL_I2C_STATE_READY;\n            i2c_handler->Lock = HAL_UNLOCKED;\n            return HAL_TIMEOUT;\n        }\n    }\n    i2c_instance->SR1 &= ~(I2C_SR1_AF);\n    i2c_handler->ErrorCode = 0;\n    i2c_handler->Lock = HAL_UNLOCKED;\n    i2c_handler->State = HAL_I2C_STATE_READY;\n    return HAL_ERROR;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080016f4",
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "imported": false,
            "current_name": "I2C_Wait_For_Event_080016f4"
        },
        "FUN_080025a4": {
            "renaming": {
                "FUN_080025a4": "configure_timer_080025a4",
                "*htim": "*timer_handle",
                "*sMasterConfig": "*master_config",
                "uVar1": "master_slave_mode",
                "HVar2": "status",
                "*pTVar3": "*timer_instance",
                "uVar4": "master_output_trigger"
            },
            "code": "HAL_StatusTypeDef configure_timer_080025a4(TIM_HandleTypeDef *timer_handle, TIM_MasterConfigTypeDef *master_config) {\n  uint32_t master_output_trigger;\n  uint32_t master_slave_mode;\n  HAL_StatusTypeDef status = HAL_BUSY;\n  if (timer_handle->Lock != HAL_LOCKED) {\n    timer_handle->State = HAL_TIM_STATE_BUSY;\n    TIM_TypeDef *timer_instance = timer_handle->Instance;\n    master_output_trigger = master_config->MasterOutputTrigger;\n    master_slave_mode = master_config->MasterSlaveMode;\n    timer_instance->CR2 &= 0xffffff8f;\n    timer_instance->CR2 |= master_output_trigger;\n    timer_instance->SMCR &= 0xffffff7f;\n    timer_instance->SMCR |= master_slave_mode;\n    timer_handle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025a4",
            "calling": [
                "Peripherals_Init"
            ],
            "imported": false,
            "current_name": "configure_timer_080025a4"
        },
        "FUN_08003034": {
            "renaming": {
                "FUN_08003034": "read_MS5611_data_08003034",
                "in_r3": "",
                "rxbuf": "rx_buffer",
                "_rxbuf": "",
                "PTR_s____Src_MS5611_c_08003064": "ms5611_src_ptr",
                "CONCAT12": "",
                "CONCAT11": "",
                "uint8_t": "",
                "undefined4": "",
                "uint32_t": "",
                "uint": "",
                "0xee": "",
                "0": "",
                "3": "",
                "0x8c": ""
            },
            "code": "uint32_t read_MS5611_data_08003034(void)\n{\n  uint8_t rx_buffer[3];\n  uint32_t data;\n  I2C_ReadBytes(0xee, 0, rx_buffer, 3, PTR_s____Src_MS5611_c_08003064, 0x8c);\n  data = (uint32_t)CONCAT12(rx_buffer[0], CONCAT11(rx_buffer[1], rx_buffer[2]));\n  return data;\n}",
            "called": [
                "I2C_ReadBytes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003034",
            "calling": [
                "MS5611_Update"
            ],
            "imported": false,
            "current_name": "read_MS5611_data_08003034"
        },
        "FUN_08004e7c": {
            "renaming": {
                "FUN_08004e7c": "configure_uart_gpio_08004e7c",
                "huart": "uart_handle",
                "tmpreg": "cr3",
                "GPIO_InitStruct": "gpio_init",
                "Instance": "USART1",
                "DAT_08004edc": "PTR_DAT_08004edc",
                "DAT_08004ee0": "PTR_DAT_08004ee0"
            },
            "code": "void configure_uart_gpio_08004e7c(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t cr3;\n  GPIO_InitTypeDef gpio_init;\n  if (uart_handle->Instance == USART1) {\n    cr3 = DAT_08004edc[0x7b7].CR3 | 0x4000;\n    DAT_08004edc[0x7b7].CR3 = cr3;\n    gpio_init.Pin = GPIO_PIN_9;\n    gpio_init.Mode = GPIO_MODE_AF_PP;\n    gpio_init.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(DAT_08004ee0, &gpio_init);\n    gpio_init.Pin = GPIO_PIN_10;\n    gpio_init.Mode = GPIO_MODE_INPUT;\n    gpio_init.Pull = GPIO_NOPULL;\n    HAL_GPIO_Init(DAT_08004ee0, &gpio_init);\n    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);\n    HAL_NVIC_EnableIRQ(USART1_IRQn);\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_GPIO_Init",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e7c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_gpio_08004e7c"
        },
        "FUN_08001530": {
            "renaming": {
                "FUN_08001530": "i2c_read_data_08001530",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "pIVar4": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef i2c_read_data_08001530(I2C_HandleTypeDef *i2c_handle, uint16_t device_address, uint16_t memory_address, uint16_t memory_address_size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time = HAL_GetTick();\n  I2C_TypeDef *i2c_instance = i2c_handle->Instance;\n\n  i2c_instance->CR1 |= 0x100;\n  while (true) {\n    if (i2c_instance->SR1 & 0x8000) {\n      i2c_instance->DR = device_address & 0xFE;\n      status = I2C_WaitOnMasterAddressFlagUntilTimeout(i2c_handle, DAT_080015e4, timeout);\n      if (status == HAL_OK) {\n        status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\n        if (status == HAL_OK) {\n          if (memory_address_size == 1) {\n            i2c_instance->DR = (uint8_t)memory_address;\n            return status;\n          }\n          i2c_instance->DR = (uint8_t)(memory_address >> 8);\n          status = I2C_WaitOnTXEFlagUntilTimeout(i2c_handle, timeout);\n          if (status == HAL_OK) {\n            i2c_instance->DR = (uint8_t)memory_address;\n            return status;\n          }\n        }\n        if (i2c_handle->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        i2c_instance->CR1 |= 0x200;\n      }\n      else if (i2c_handle->ErrorCode != 4) {\n        return HAL_TIMEOUT;\n      }\n      return HAL_ERROR;\n    }\n    if (timeout != 0xFFFFFFFF) {\n      uint32_t current_time = HAL_GetTick();\n      if (timeout == 0 || current_time - start_time >= timeout) {\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n}",
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001530",
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "imported": false,
            "current_name": "i2c_read_data_08001530"
        },
        "FUN_0800411c": {
            "renaming": {
                "FUN_0800411c": "updateSensorsAndSendData_0800411c",
                "puVar1": "lastTick",
                "uVar2": "currentMillis",
                "PTR_last_tick1_08004188": "lastTick1",
                "PTR_last_tick3_0800418c": "lastTick3",
                "PTR_last_tick2_08004190": "lastTick2"
            },
            "code": "void updateSensorsAndSendData_0800411c(void)\n{\n  uint32_t currentMillis = millis();\n  uint32_t* PTR_last_tick1_08004188 = PTR_last_tick1_08004188;\n  if (currentMillis - *(int*)PTR_last_tick1_08004188 > 1) {\n    *PTR_last_tick1_08004188 = currentMillis;\n    AHRS_ComputeAngles();\n  }\n  uint32_t* PTR_last_tick3_0800418c = PTR_last_tick3_0800418c;\n  if (currentMillis - *(int*)PTR_last_tick3_0800418c > 2) {\n    *PTR_last_tick3_0800418c = currentMillis;\n    PID_Update();\n  }\n  uint32_t* PTR_last_tick2_08004190 = PTR_last_tick2_08004190;\n  if (currentMillis - *(int*)PTR_last_tick2_08004190 > 3) {\n    *PTR_last_tick2_08004190 = currentMillis;\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}",
            "called": [
                "MS5611_Update",
                "MSP_SendPID",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendAltitude",
                "millis",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendRawIMU",
                "MSP_SendMotor",
                "MSP_SendIdent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800411c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "updateSensorsAndSendData_0800411c"
        },
        "FUN_080040b8": {
            "renaming": {
                "FUN_080040b8": "read_i2c_memory_080040b8",
                "device_add": "device_address",
                "register_add": "register_address",
                "bytes": "data",
                "size": "size",
                "file": "file_name",
                "line": "line_number",
                "HVar1": "status"
            },
            "code": "void read_i2c_memory_080040b8(uint16_t device_address, uint16_t register_address, uint8_t *data, uint16_t size, char *file_name, int line_number) {\n  HAL_StatusTypeDef status = HAL_I2C_Mem_Read((I2C_HandleTypeDef *)PTR_hi2c1_080040e4, device_address, register_address, 1, data, size, 200);\n  if (status != HAL_OK) {\n    _Error_Handler(file_name, line_number);\n    return;\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040b8",
            "calling": [
                "MS5611_ReadADC"
            ],
            "imported": false,
            "current_name": "read_i2c_memory_080040b8"
        },
        "FUN_08004490": {
            "renaming": {
                "FUN_08004490": "log_error_08004490",
                "file": "filename",
                "line": "line_number",
                "*GPIOx": "*gpio_port",
                "*data": "*error_message",
                "*data_00": "*line_message"
            },
            "code": "void log_error_08004490(char *filename, int line_number)\n{\n  GPIO_TypeDef *gpio_port;\n  char *error_message;\n  char *line_message;\n  HAL_GPIO_WritePin(gpio_port, GPIO_PIN_14, GPIO_PIN_SET);\n  HAL_GPIO_WritePin(gpio_port, GPIO_PIN_15, GPIO_PIN_RESET);\n  HAL_GPIO_WritePin(gpio_port, GPIO_PIN_13, GPIO_PIN_RESET);\n  error_message = PTR_s_Error_with_08004510;\n  line_message = PTR_s__at_line__0800450c;\n  gpio_port = DAT_08004508;\n  do {\n    HAL_GPIO_TogglePin(gpio_port, GPIO_PIN_14);\n    HAL_GPIO_TogglePin(gpio_port, GPIO_PIN_15);\n    HAL_GPIO_TogglePin(gpio_port, GPIO_PIN_13);\n    serialPrint(error_message);\n    serialPrint(filename);\n    serialPrint(line_message);\n    serialInt(line_number);\n    serialWrite('\n');\n    delay_ms(500);\n  } while( true );\n}",
            "called": [
                "serialInt",
                "HAL_GPIO_TogglePin",
                "delay_ms",
                "serialPrint",
                "HAL_GPIO_WritePin",
                "serialWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004490",
            "calling": [
                "I2C_WriteByte",
                "I2C_ReadByte",
                "Peripherals_Init",
                "I2C_ReadBytes",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "log_error_08004490"
        },
        "FUN_08000e54": {
            "renaming": {
                "FUN_08000e54": "float_bits_to_float_08000e54",
                "param_1": "float_bits",
                "param_2": "float_bits2",
                "param_3": "unused",
                "param_4": "shift",
                "uVar1": "mantissa_bit",
                "uVar2": "exponent_bits",
                "iVar3": "diff_of_exponents",
                "uVar4": "shifted_exponent",
                "iVar5": "sum_of_exponents",
                "uVar6": "result",
                "bVar7": "flag",
                "bVar8": "flag2",
                "bVar9": "flag3"
            },
            "code": "\nuint float_bits_to_float_08000e54(uint float_bits,uint float_bits2,undefined4 unused,uint shift)\n\n{\n  uint mantissa_bit;\n  uint exponent_bits;\n  int diff_of_exponents;\n  uint shifted_exponent;\n  int sum_of_exponents;\n  uint result;\n  bool flag;\n  bool flag2;\n  bool flag3;\n  \n  exponent_bits = float_bits >> 0x17 & 0xff;\n  flag = exponent_bits == 0;\n  if (!flag) {\n    shift = float_bits2 >> 0x17 & 0xff;\n    flag = shift == 0;\n  }\n  if (!flag) {\n    flag = exponent_bits == 0xff;\n  }\n  if (!flag) {\n    flag = shift == 0xff;\n  }\n  if (flag) {\n    shift = float_bits2 >> 0x17 & 0xff;\n    result = float_bits;\n    if (exponent_bits == 0xff) {\n      if (((float_bits & 0x7fffff) != 0) || (result = float_bits2, shift == 0xff)) {\nLAB_08000e4a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (shift == 0xff) {\n        result = float_bits2;\n        if ((float_bits2 & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (float_bits ^ float_bits2) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      flag = (float_bits & 0x7fffffff) == 0;\n      if (!flag) {\n        flag = (float_bits2 & 0x7fffffff) == 0;\n      }\n      if (!flag) {\n        flag = exponent_bits == 0;\n        result = float_bits & 0x80000000;\n        while( true ) {\n          if (flag) {\n            float_bits = float_bits << 1;\n            flag = (float_bits & 0x800000) == 0;\n          }\n          if (!flag) break;\n          exponent_bits = exponent_bits - 1;\n        }\n        float_bits = float_bits | result;\n        flag = shift == 0;\n        result = float_bits2 & 0x80000000;\n        while( true ) {\n          if (flag) {\n            float_bits2 = float_bits2 << 1;\n            flag = (float_bits2 & 0x800000) == 0;\n          }\n          if (!flag) break;\n          shift = shift - 1;\n        }\n        float_bits2 = float_bits2 | result;\n        goto LAB_08000e6c;\n      }\n      if ((float_bits & 0x7fffffff) == 0) {\n        if ((float_bits2 & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    float_bits = float_bits ^ float_bits2;\n  }\n  else {\nLAB_08000e6c:\n    diff_of_exponents = exponent_bits - shift;\n    if (float_bits2 << 9 == 0) {\n      float_bits = (float_bits ^ float_bits2) & 0x80000000 | float_bits & 0x7fffff;\n      flag3 = SCARRY4(diff_of_exponents,0x7f);\n      sum_of_exponents = diff_of_exponents + 0x7f;\n      flag = sum_of_exponents < 0;\n      flag2 = sum_of_exponents == 0;\n      if (!flag2 && flag == flag3) {\n        flag3 = SBORROW4(0xff,sum_of_exponents);\n        flag = 0xff - sum_of_exponents < 0;\n        flag2 = sum_of_exponents == 0xff;\n      }\n      if (!flag2 && flag == flag3) {\n        float_bits = float_bits | sum_of_exponents * 0x800000;\n      }\n      if (!flag2 && flag == flag3) {\n        return float_bits;\n      }\n      float_bits = float_bits | 0x800000;\n      exponent_bits = 0;\n      flag2 = SBORROW4(sum_of_exponents,1);\n      shifted_exponent = diff_of_exponents + 0x7e;\n      flag = shifted_exponent == 0;\n      result = shifted_exponent;\n    }\n    else {\n      mantissa_bit = (float_bits2 << 9) >> 4 | 0x10000000;\n      exponent_bits = (float_bits << 9) >> 4 | 0x10000000;\n      float_bits = (float_bits ^ float_bits2) & 0x80000000;\n      flag = mantissa_bit <= exponent_bits;\n      if (!flag) {\n        exponent_bits = exponent_bits << 1;\n      }\n      shifted_exponent = diff_of_exponents + 0x7d + (uint)flag;\n      result = 0x800000;\n      do {\n        if (mantissa_bit <= exponent_bits) {\n          exponent_bits = exponent_bits - mantissa_bit;\n          float_bits = float_bits | result;\n        }\n        flag = mantissa_bit >> 1 <= exponent_bits;\n        if (flag) {\n          exponent_bits = exponent_bits - (mantissa_bit >> 1);\n        }\n        if (flag) {\n          float_bits = float_bits | result >> 1;\n        }\n        flag = mantissa_bit >> 2 <= exponent_bits;\n        if (flag) {\n          exponent_bits = exponent_bits - (mantissa_bit >> 2);\n        }\n        if (flag) {\n          float_bits = float_bits | result >> 2;\n        }\n        flag = mantissa_bit >> 3 <= exponent_bits;\n        if (flag) {\n          exponent_bits = exponent_bits - (mantissa_bit >> 3);\n        }\n        if (flag) {\n          float_bits = float_bits | result >> 3;\n        }\n        exponent_bits = exponent_bits * 0x10;\n        flag = exponent_bits == 0;\n        if (!flag) {\n          result = result >> 4;\n          flag = result == 0;\n        }\n      } while (!flag);\n      flag2 = SBORROW4(shifted_exponent,0xfd);\n      flag = shifted_exponent == 0xfd;\n      result = shifted_exponent - 0xfd;\n      if (shifted_exponent < 0xfe) {\n        float_bits = float_bits + shifted_exponent * 0x800000 + (uint)(mantissa_bit <= exponent_bits);\n        if (exponent_bits - mantissa_bit == 0) {\n          float_bits = float_bits & 0xfffffffe;\n        }\n        return float_bits;\n      }\n    }\n    if (flag || (int)result < 0 != flag2) {\n      flag = (int)(shifted_exponent + 0x19) < 0;\n      if (shifted_exponent == 0xffffffe7 || flag != SCARRY4(shifted_exponent,0x19)) {\n        float_bits = float_bits & 0x80000000;\n      }\n      if (shifted_exponent == 0xffffffe7 || flag != SCARRY4(shifted_exponent,0x19)) {\n        return float_bits;\n      }\n      result = (float_bits << 1) >> (-shifted_exponent & 0xff);\n      shifted_exponent = float_bits << (shifted_exponent + 0x20 & 0xff);\n      result = ((uint)((float_bits & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((exponent_bits | shifted_exponent << 1) == 0) {\n        result = result & ~(shifted_exponent >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return float_bits & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000e54",
            "calling": [
                "MS5611_Update",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "PID_Compute"
            ],
            "imported": false,
            "current_name": "float_bits_to_float_08000e54"
        },
        "FUN_080015e8": {
            "renaming": {
                "FUN_080015e8": "I2C_Read_080015e8",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_tick",
                "uVar3": "current_tick",
                "pIVar4": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef I2C_Read_080015e8(I2C_HandleTypeDef *hi2c, uint16_t device_address, uint16_t memory_address, uint16_t memory_address_size, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_tick = HAL_GetTick();\n  I2C_TypeDef *i2c_instance = hi2c->Instance;\n  i2c_instance->CR1 |= I2C_CR1_ACK | I2C_CR1_START;\n  while ((i2c_instance->SR1 & I2C_SR1_ADDR) == RESET && (timeout == 0 || HAL_GetTick() - start_tick < timeout));\n  if ((i2c_instance->SR1 & I2C_SR1_ADDR) == RESET)\n  {\n    status = HAL_TIMEOUT;\n  }\n  else\n  {\n    i2c_instance->SR2;\n    i2c_instance->DR = (uint8_t)(device_address << 1);\n    while ((i2c_instance->SR1 & I2C_SR1_TXE) == RESET && (timeout == 0 || HAL_GetTick() - start_tick < timeout));\n    if ((i2c_instance->SR1 & I2C_SR1_TXE) == RESET)\n    {\n      status = HAL_TIMEOUT;\n    }\n    else\n    {\n      if (memory_address_size == 2)\n      {\n        i2c_instance->DR = (uint8_t)(memory_address >> 8);\n        while ((i2c_instance->SR1 & I2C_SR1_TXE) == RESET && (timeout == 0 || HAL_GetTick() - start_tick < timeout));\n        if ((i2c_instance->SR1 & I2C_SR1_TXE) == RESET)\n        {\n          status = HAL_TIMEOUT;\n          goto I2C_Read_080015e8_Exit;\n        }\n      }\n      i2c_instance->DR = (uint8_t)memory_address;\n      while ((i2c_instance->SR1 & I2C_SR1_TXE) == RESET && (timeout == 0 || HAL_GetTick() - start_tick < timeout));\n      if ((i2c_instance->SR1 & I2C_SR1_TXE) == RESET)\n      {\n        status = HAL_TIMEOUT;\n        goto I2C_Read_080015e8_Exit;\n      }\n      i2c_instance->CR1 |= I2C_CR1_START;\n      while ((i2c_instance->SR1 & I2C_SR1_ADDR) == RESET && (timeout == 0 || HAL_GetTick() - start_tick < timeout));\n      if ((i2c_instance->SR1 & I2C_SR1_ADDR) == RESET)\n      {\n        status = HAL_TIMEOUT;\n        goto I2C_Read_080015e8_Exit;\n      }\n      i2c_instance->SR2;\n      i2c_instance->DR = (uint8_t)((device_address << 1) | 1);\n      while ((i2c_instance->SR1 & I2C_SR1_RXNE) == RESET && (timeout == 0 || HAL_GetTick() - start_tick < timeout));\n      if ((i2c_instance->SR1 & I2C_SR1_RXNE) == RESET)\n      {\n        status = HAL_TIMEOUT;\n        goto I2C_Read_080015e8_Exit;\n      }\n      status = HAL_OK;\n    }\n  }\nI2C_Read_080015e8_Exit:\n  i2c_instance->CR1 |= I2C_CR1_STOP;\n  return status;\n}\n",
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080015e8",
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "imported": false,
            "current_name": "I2C_Read_080015e8"
        }
    },
    "used_tokens": 220109,
    "layers": [
        [
            "FUN_08003320",
            "FUN_08004410",
            "FUN_08003ef2",
            "FUN_08001264",
            "FUN_080058fc",
            "FUN_080070b0",
            "FUN_08001028",
            "FUN_080006ac",
            "FUN_0800125a",
            "FUN_08001828",
            "FUN_0800290c",
            "FUN_080028a6",
            "FUN_08004300",
            "FUN_08005630",
            "FUN_08000980",
            "FUN_08002368",
            "FUN_08002008",
            "FUN_080008fc",
            "FUN_0800114c",
            "FUN_08002250",
            "FUN_080011fc",
            "FUN_08003f7c",
            "FUN_08005646",
            "FUN_08000990",
            "FUN_08004ee6",
            "FUN_08004434",
            "FUN_08004ee8",
            "FUN_08004ffc",
            "FUN_0800103c",
            "FUN_0800115c",
            "FUN_08004f60",
            "FUN_08002d88",
            "FUN_08002b48",
            "FUN_08004f68",
            "FUN_08001170",
            "FUN_08002bf0",
            "FUN_08002ad0",
            "FUN_08001050",
            "FUN_08004ef4",
            "FUN_080043bc",
            "FUN_08004f5c",
            "FUN_08000404",
            "FUN_08004eec",
            "FUN_08004eea",
            "FUN_08006070",
            "FUN_08004cac",
            "FUN_08004c18",
            "FUN_08004c8c",
            "FUN_08001460",
            "FUN_08003fd0",
            "FUN_08000134",
            "FUN_08003eb0",
            "FUN_08002ee8",
            "FUN_08001104",
            "FUN_08004978",
            "FUN_08000c60",
            "FUN_08004f04",
            "FUN_080072b8",
            "FUN_0800581c",
            "FUN_08003eac",
            "FUN_080072ac",
            "FUN_08002cb0",
            "FUN_08002324",
            "FUN_08002564",
            "FUN_08004fb0",
            "FUN_08003ec8",
            "FUN_08003fe8",
            "FUN_08005714",
            "FUN_08004fb4",
            "FUN_080009dc",
            "FUN_08000c70",
            "FUN_080023d0",
            "FUN_08000a30",
            "FUN_08003fdc",
            "FUN_080009f0",
            "FUN_08004f10",
            "FUN_08005044",
            "FUN_08004194",
            "FUN_08001240",
            "FUN_08005840",
            "FUN_08000150",
            "FUN_08003f3c",
            "FUN_08002214",
            "FUN_08003ff4",
            "FUN_08001004",
            "FUN_08004514",
            "FUN_080057d0",
            "FUN_080072d4",
            "FUN_08002220",
            "FUN_08003314",
            "FUN_08001014",
            "FUN_080071c0",
            "FUN_08005614",
            "FUN_080070a4",
            "FUN_0800407c",
            "FUN_080022d0",
            "FUN_080010c4",
            "FUN_0800245c",
            "FUN_080008f4",
            "FUN_08004e14",
            "FUN_08002ea0",
            "FUN_08001424",
            "FUN_08004c64",
            "FUN_080041e4",
            "FUN_080003e4",
            "FUN_08007092",
            "FUN_08002f28",
            "FUN_08004384",
            "FUN_080009a0",
            "FUN_08003298",
            "FUN_08004028",
            "FUN_0800708c",
            "FUN_08002520",
            "FUN_08000464",
            "FUN_08002404",
            "FUN_08001436",
            "FUN_08004a30",
            "FUN_08004c70",
            "FUN_08000904",
            "FUN_0800299a",
            "FUN_080052e4",
            "FUN_08000f94",
            "FUN_080014e2",
            "FUN_0800142e",
            "FUN_08004d8c",
            "FUN_080009b4",
            "FUN_08003068",
            "FUN_08000f8c",
            "FUN_08000474",
            "FUN_08000110",
            "FUN_0800709e",
            "FUN_08002ec0",
            "FUN_08006c0c",
            "FUN_0800426c",
            "FUN_08002538",
            "FUN_080040e8",
            "FUN_08000c44",
            "FUN_08000a04",
            "FUN_080025e8",
            "FUN_080009c8",
            "FUN_08000f9c",
            "FUN_08002ed4",
            "FUN_08000c3c",
            "FUN_08001214",
            "FUN_08003fc4",
            "FUN_0800209c",
            "FUN_08003f0e",
            "FUN_0800403c",
            "FUN_0800277c",
            "FUN_0800483c",
            "FUN_08001064",
            "FUN_08000892",
            "FUN_08004458",
            "FUN_08004d48",
            "FUN_08002280",
            "FUN_08001194",
            "FUN_08004348",
            "FUN_08001078",
            "FUN_08001754",
            "FUN_08002724",
            "FUN_080043f0",
            "FUN_08000428",
            "FUN_08004ccc",
            "FUN_08004c30",
            "FUN_0800729c",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_0800567c",
            "FUN_08000ffc",
            "FUN_080016f4",
            "FUN_080025a4",
            "FUN_08003034",
            "FUN_08004e7c",
            "FUN_08001530",
            "FUN_0800411c",
            "FUN_080040b8",
            "FUN_08004490",
            "FUN_080015e8"
        ],
        [
            "FUN_08001128",
            "FUN_08004a84",
            "FUN_08005854",
            "FUN_08005bc8"
        ],
        [
            "FUN_080050fc",
            "FUN_0800016c",
            "FUN_08001b58",
            "FUN_08003330",
            "FUN_08005c70",
            "FUN_08006d68",
            "FUN_08000ad0",
            "FUN_08000ad8",
            "FUN_08000adc",
            "FUN_08000160",
            "FUN_08000168",
            "FUN_08000724",
            "FUN_08001938",
            "FUN_08003078",
            "FUN_08006228",
            "FUN_08000cec",
            "FUN_080004d0",
            "FUN_080053d4",
            "FUN_0800458c",
            "FUN_08000e54"
        ],
        [
            "FUN_08005900"
        ]
    ],
    "locked_functions": []
}